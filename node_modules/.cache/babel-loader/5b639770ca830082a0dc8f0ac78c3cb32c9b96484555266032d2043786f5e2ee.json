{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Vector3DTilePolylinesVS from \"../Shaders/Vector3DTilePolylinesVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\n\n/**\n * Creates a batch of polylines that have been subdivided to be draped on terrain.\n *\n * @alias Vector3DTilePolylines\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polylines\n * @param {Uint32Array} options.counts The number or positions in the each polyline.\n * @param {Uint16Array} options.widths The width of each polyline.\n * @param {number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polylines.\n * @param {Uint16Array} options.batchIds The batch ids for each polyline.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polylines.\n * @param {boolean} options.keepDecodedPositions Whether to keep decoded positions in memory.\n *\n * @private\n */\nfunction Vector3DTilePolylines(options) {\n  // these arrays are all released after the first update.\n  this._positions = options.positions;\n  this._widths = options.widths;\n  this._counts = options.counts;\n  this._batchIds = options.batchIds;\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._center = options.center;\n  this._rectangle = options.rectangle;\n  this._boundingVolume = options.boundingVolume;\n  this._batchTable = options.batchTable;\n  this._va = undefined;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._uniformMap = undefined;\n  this._command = undefined;\n  this._transferrableBatchIds = undefined;\n  this._packedBuffer = undefined;\n  this._keepDecodedPositions = options.keepDecodedPositions;\n  this._decodedPositions = undefined;\n  this._decodedPositionOffsets = undefined;\n  this._currentPositions = undefined;\n  this._previousPositions = undefined;\n  this._nextPositions = undefined;\n  this._expandAndWidth = undefined;\n  this._vertexBatchIds = undefined;\n  this._indices = undefined;\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n  this._trianglesLength = 0;\n  this._geometryByteLength = 0;\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n}\nObject.defineProperties(Vector3DTilePolylines.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n  /**\n   * Returns true when the primitive is ready to render.\n   * @memberof Vector3DTilePolylines.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  }\n});\nfunction packBuffer(polylines) {\n  const rectangle = polylines._rectangle;\n  const minimumHeight = polylines._minimumHeight;\n  const maximumHeight = polylines._maximumHeight;\n  const ellipsoid = polylines._ellipsoid;\n  const center = polylines._center;\n  const packedLength = 2 + Rectangle.packedLength + Ellipsoid.packedLength + Cartesian3.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n  Cartesian3.pack(center, packedBuffer, offset);\n  return packedBuffer;\n}\nconst createVerticesTaskProcessor = new TaskProcessor(\"createVectorTilePolylines\", 5);\nconst attributeLocations = {\n  previousPosition: 0,\n  currentPosition: 1,\n  nextPosition: 2,\n  expandAndWidth: 3,\n  a_batchId: 4\n};\nfunction createVertexArray(polylines, context) {\n  if (defined(polylines._va)) {\n    return;\n  }\n  let positions = polylines._positions;\n  let widths = polylines._widths;\n  let counts = polylines._counts;\n  let batchIds = polylines._transferrableBatchIds;\n  let packedBuffer = polylines._packedBuffer;\n  if (!defined(packedBuffer)) {\n    // Copy because they may be the views on the same buffer.\n    positions = polylines._positions = positions.slice();\n    widths = polylines._widths = widths.slice();\n    counts = polylines._counts = counts.slice();\n    batchIds = polylines._transferrableBatchIds = polylines._batchIds.slice();\n    packedBuffer = polylines._packedBuffer = packBuffer(polylines);\n  }\n  const transferrableObjects = [positions.buffer, widths.buffer, counts.buffer, batchIds.buffer, packedBuffer.buffer];\n  const parameters = {\n    positions: positions.buffer,\n    widths: widths.buffer,\n    counts: counts.buffer,\n    batchIds: batchIds.buffer,\n    packedBuffer: packedBuffer.buffer,\n    keepDecodedPositions: polylines._keepDecodedPositions\n  };\n  const verticesPromise = createVerticesTaskProcessor.scheduleTask(parameters, transferrableObjects);\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return;\n  }\n  return verticesPromise.then(function (result) {\n    if (polylines.isDestroyed()) {\n      return;\n    }\n    if (polylines._keepDecodedPositions) {\n      polylines._decodedPositions = new Float64Array(result.decodedPositions);\n      polylines._decodedPositionOffsets = new Uint32Array(result.decodedPositionOffsets);\n    }\n    polylines._currentPositions = new Float32Array(result.currentPositions);\n    polylines._previousPositions = new Float32Array(result.previousPositions);\n    polylines._nextPositions = new Float32Array(result.nextPositions);\n    polylines._expandAndWidth = new Float32Array(result.expandAndWidth);\n    polylines._vertexBatchIds = new Uint16Array(result.batchIds);\n    const indexDatatype = result.indexDatatype;\n    polylines._indices = indexDatatype === IndexDatatype.UNSIGNED_SHORT ? new Uint16Array(result.indices) : new Uint32Array(result.indices);\n    finishVertexArray(polylines, context);\n    polylines._ready = true;\n  }).catch(error => {\n    if (polylines.isDestroyed()) {\n      return;\n    }\n\n    // Throw the error next frame\n    polylines._error = error;\n  });\n}\nfunction finishVertexArray(polylines, context) {\n  if (!defined(polylines._va)) {\n    const curPositions = polylines._currentPositions;\n    const prevPositions = polylines._previousPositions;\n    const nextPositions = polylines._nextPositions;\n    const expandAndWidth = polylines._expandAndWidth;\n    const vertexBatchIds = polylines._vertexBatchIds;\n    const indices = polylines._indices;\n    let byteLength = prevPositions.byteLength + curPositions.byteLength + nextPositions.byteLength;\n    byteLength += expandAndWidth.byteLength + vertexBatchIds.byteLength + indices.byteLength;\n    polylines._trianglesLength = indices.length / 3;\n    polylines._geometryByteLength = byteLength;\n    const prevPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: prevPositions,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const curPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: curPositions,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const nextPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: nextPositions,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const expandAndWidthBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: expandAndWidth,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const idBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: vertexBatchIds,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: indices.BYTES_PER_ELEMENT === 2 ? IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT\n    });\n    const vertexAttributes = [{\n      index: attributeLocations.previousPosition,\n      vertexBuffer: prevPositionBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      index: attributeLocations.currentPosition,\n      vertexBuffer: curPositionBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      index: attributeLocations.nextPosition,\n      vertexBuffer: nextPositionBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      index: attributeLocations.expandAndWidth,\n      vertexBuffer: expandAndWidthBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2\n    }, {\n      index: attributeLocations.a_batchId,\n      vertexBuffer: idBuffer,\n      componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      componentsPerAttribute: 1\n    }];\n    polylines._va = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: indexBuffer\n    });\n    polylines._positions = undefined;\n    polylines._widths = undefined;\n    polylines._counts = undefined;\n    polylines._ellipsoid = undefined;\n    polylines._minimumHeight = undefined;\n    polylines._maximumHeight = undefined;\n    polylines._rectangle = undefined;\n    polylines._transferrableBatchIds = undefined;\n    polylines._packedBuffer = undefined;\n    polylines._currentPositions = undefined;\n    polylines._previousPositions = undefined;\n    polylines._nextPositions = undefined;\n    polylines._expandAndWidth = undefined;\n    polylines._vertexBatchIds = undefined;\n    polylines._indices = undefined;\n  }\n}\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n  primitive._uniformMap = {\n    u_modifiedModelView: function () {\n      const viewMatrix = context.uniformState.view;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive._center, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    }\n  };\n}\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rs)) {\n    return;\n  }\n  const polygonOffset = {\n    enabled: true,\n    factor: -5.0,\n    units: -5.0\n  };\n  primitive._rs = RenderState.fromCache({\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false,\n    depthTest: {\n      enabled: true\n    },\n    polygonOffset: polygonOffset\n  });\n}\nconst PolylineFS = \"uniform vec4 u_highlightColor; \\n\" + \"void main()\\n\" + \"{\\n\" + \"    out_FragColor = u_highlightColor;\\n\" + \"}\\n\";\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n  const batchTable = primitive._batchTable;\n  const vsSource = batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(Vector3DTilePolylinesVS);\n  const fsSource = batchTable.getFragmentShaderCallback(false, undefined, false)(PolylineFS);\n  const vs = new ShaderSource({\n    defines: [\"VECTOR_TILE\", !FeatureDetection.isInternetExplorer() ? \"CLIP_POLYLINE\" : \"\"],\n    sources: [PolylineCommon, vsSource]\n  });\n  const fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\nfunction queueCommands(primitive, frameState) {\n  if (!defined(primitive._command)) {\n    const uniformMap = primitive._batchTable.getUniformMapCallback()(primitive._uniformMap);\n    primitive._command = new DrawCommand({\n      owner: primitive,\n      vertexArray: primitive._va,\n      renderState: primitive._rs,\n      shaderProgram: primitive._sp,\n      uniformMap: uniformMap,\n      boundingVolume: primitive._boundingVolume,\n      pass: Pass.TRANSLUCENT,\n      pickId: primitive._batchTable.getPickId()\n    });\n  }\n  frameState.commandList.push(primitive._command);\n}\nVector3DTilePolylines.getPolylinePositions = function (polylines, batchId) {\n  const batchIds = polylines._batchIds;\n  const positions = polylines._decodedPositions;\n  const offsets = polylines._decodedPositionOffsets;\n  if (!defined(batchIds) || !defined(positions)) {\n    return undefined;\n  }\n  let i;\n  let j;\n  const polylinesLength = batchIds.length;\n  let positionsLength = 0;\n  let resultCounter = 0;\n  for (i = 0; i < polylinesLength; ++i) {\n    if (batchIds[i] === batchId) {\n      positionsLength += offsets[i + 1] - offsets[i];\n    }\n  }\n  if (positionsLength === 0) {\n    return undefined;\n  }\n  const results = new Float64Array(positionsLength * 3);\n  for (i = 0; i < polylinesLength; ++i) {\n    if (batchIds[i] === batchId) {\n      const offset = offsets[i];\n      const count = offsets[i + 1] - offset;\n      for (j = 0; j < count; ++j) {\n        const decodedOffset = (offset + j) * 3;\n        results[resultCounter++] = positions[decodedOffset];\n        results[resultCounter++] = positions[decodedOffset + 1];\n        results[resultCounter++] = positions[decodedOffset + 2];\n      }\n    }\n  }\n  return results;\n};\n\n/**\n * Get the polyline positions for the given feature.\n *\n * @param {number} batchId The batch ID of the feature.\n */\nVector3DTilePolylines.prototype.getPositions = function (batchId) {\n  return Vector3DTilePolylines.getPolylinePositions(this, batchId);\n};\n\n/**\n * Creates features for each polyline and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolylines.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polyline batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolylines.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n}\nconst scratchColor = new Color();\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolylines.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n    feature.color = defined(style.color) ? style.color.evaluateColor(feature, scratchColor) : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show) ? style.show.evaluate(feature) : DEFAULT_SHOW_VALUE;\n  }\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolylines.prototype.update = function (frameState) {\n  const context = frameState.context;\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = createVertexArray(this, context);\n    }\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n    return;\n  }\n  createUniformMap(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    queueCommands(this, frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolylines.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolylines.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolylines;","map":{"version":3,"names":["Cartesian3","Color","ComponentDatatype","defaultValue","defined","destroyObject","Ellipsoid","FeatureDetection","IndexDatatype","Matrix4","Rectangle","TaskProcessor","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","PolylineCommon","Vector3DTilePolylinesVS","BlendingState","Cesium3DTileFeature","Vector3DTilePolylines","options","_positions","positions","_widths","widths","_counts","counts","_batchIds","batchIds","_ellipsoid","ellipsoid","WGS84","_minimumHeight","minimumHeight","_maximumHeight","maximumHeight","_center","center","_rectangle","rectangle","_boundingVolume","boundingVolume","_batchTable","batchTable","_va","undefined","_sp","_rs","_uniformMap","_command","_transferrableBatchIds","_packedBuffer","_keepDecodedPositions","keepDecodedPositions","_decodedPositions","_decodedPositionOffsets","_currentPositions","_previousPositions","_nextPositions","_expandAndWidth","_vertexBatchIds","_indices","_constantColor","clone","WHITE","_highlightColor","_trianglesLength","_geometryByteLength","_ready","_promise","_error","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","ready","packBuffer","polylines","packedLength","packedBuffer","Float64Array","offset","pack","createVerticesTaskProcessor","attributeLocations","previousPosition","currentPosition","nextPosition","expandAndWidth","a_batchId","createVertexArray","context","slice","transferrableObjects","buffer","parameters","verticesPromise","scheduleTask","then","result","isDestroyed","decodedPositions","Uint32Array","decodedPositionOffsets","Float32Array","currentPositions","previousPositions","nextPositions","Uint16Array","indexDatatype","UNSIGNED_SHORT","indices","finishVertexArray","catch","error","curPositions","prevPositions","vertexBatchIds","byteLength","length","prevPositionBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","curPositionBuffer","nextPositionBuffer","expandAndWidthBuffer","idBuffer","indexBuffer","createIndexBuffer","BYTES_PER_ELEMENT","UNSIGNED_INT","vertexAttributes","index","vertexBuffer","componentDatatype","FLOAT","componentsPerAttribute","attributes","modifiedModelViewScratch","rtcScratch","createUniformMap","primitive","u_modifiedModelView","viewMatrix","uniformState","view","multiplyByPoint","setTranslation","u_highlightColor","createRenderStates","polygonOffset","enabled","factor","units","fromCache","blending","ALPHA_BLEND","depthMask","depthTest","PolylineFS","createShaders","vsSource","getVertexShaderCallback","fsSource","getFragmentShaderCallback","vs","defines","isInternetExplorer","sources","fs","vertexShaderSource","fragmentShaderSource","queueCommands","frameState","uniformMap","getUniformMapCallback","owner","vertexArray","renderState","shaderProgram","pass","TRANSLUCENT","pickId","getPickId","commandList","push","getPolylinePositions","batchId","offsets","i","j","polylinesLength","positionsLength","resultCounter","results","count","decodedOffset","getPositions","createFeatures","content","features","applyDebugSettings","color","clearStyle","polygons","feature","show","scratchColor","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","applyStyle","style","evaluateColor","evaluate","update","passes","render","pick","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Vector3DTilePolylines.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Vector3DTilePolylinesVS from \"../Shaders/Vector3DTilePolylinesVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\n\n/**\n * Creates a batch of polylines that have been subdivided to be draped on terrain.\n *\n * @alias Vector3DTilePolylines\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polylines\n * @param {Uint32Array} options.counts The number or positions in the each polyline.\n * @param {Uint16Array} options.widths The width of each polyline.\n * @param {number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polylines.\n * @param {Uint16Array} options.batchIds The batch ids for each polyline.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polylines.\n * @param {boolean} options.keepDecodedPositions Whether to keep decoded positions in memory.\n *\n * @private\n */\nfunction Vector3DTilePolylines(options) {\n  // these arrays are all released after the first update.\n  this._positions = options.positions;\n  this._widths = options.widths;\n  this._counts = options.counts;\n  this._batchIds = options.batchIds;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._center = options.center;\n  this._rectangle = options.rectangle;\n\n  this._boundingVolume = options.boundingVolume;\n  this._batchTable = options.batchTable;\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._transferrableBatchIds = undefined;\n  this._packedBuffer = undefined;\n\n  this._keepDecodedPositions = options.keepDecodedPositions;\n  this._decodedPositions = undefined;\n  this._decodedPositionOffsets = undefined;\n\n  this._currentPositions = undefined;\n  this._previousPositions = undefined;\n  this._nextPositions = undefined;\n  this._expandAndWidth = undefined;\n  this._vertexBatchIds = undefined;\n  this._indices = undefined;\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._trianglesLength = 0;\n  this._geometryByteLength = 0;\n\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n}\n\nObject.defineProperties(Vector3DTilePolylines.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Returns true when the primitive is ready to render.\n   * @memberof Vector3DTilePolylines.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\nfunction packBuffer(polylines) {\n  const rectangle = polylines._rectangle;\n  const minimumHeight = polylines._minimumHeight;\n  const maximumHeight = polylines._maximumHeight;\n  const ellipsoid = polylines._ellipsoid;\n  const center = polylines._center;\n\n  const packedLength =\n    2 +\n    Rectangle.packedLength +\n    Ellipsoid.packedLength +\n    Cartesian3.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.pack(center, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTilePolylines\",\n  5,\n);\nconst attributeLocations = {\n  previousPosition: 0,\n  currentPosition: 1,\n  nextPosition: 2,\n  expandAndWidth: 3,\n  a_batchId: 4,\n};\n\nfunction createVertexArray(polylines, context) {\n  if (defined(polylines._va)) {\n    return;\n  }\n\n  let positions = polylines._positions;\n  let widths = polylines._widths;\n  let counts = polylines._counts;\n  let batchIds = polylines._transferrableBatchIds;\n\n  let packedBuffer = polylines._packedBuffer;\n\n  if (!defined(packedBuffer)) {\n    // Copy because they may be the views on the same buffer.\n    positions = polylines._positions = positions.slice();\n    widths = polylines._widths = widths.slice();\n    counts = polylines._counts = counts.slice();\n\n    batchIds = polylines._transferrableBatchIds = polylines._batchIds.slice();\n\n    packedBuffer = polylines._packedBuffer = packBuffer(polylines);\n  }\n\n  const transferrableObjects = [\n    positions.buffer,\n    widths.buffer,\n    counts.buffer,\n    batchIds.buffer,\n    packedBuffer.buffer,\n  ];\n  const parameters = {\n    positions: positions.buffer,\n    widths: widths.buffer,\n    counts: counts.buffer,\n    batchIds: batchIds.buffer,\n    packedBuffer: packedBuffer.buffer,\n    keepDecodedPositions: polylines._keepDecodedPositions,\n  };\n\n  const verticesPromise = createVerticesTaskProcessor.scheduleTask(\n    parameters,\n    transferrableObjects,\n  );\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return;\n  }\n\n  return verticesPromise\n    .then(function (result) {\n      if (polylines.isDestroyed()) {\n        return;\n      }\n\n      if (polylines._keepDecodedPositions) {\n        polylines._decodedPositions = new Float64Array(result.decodedPositions);\n        polylines._decodedPositionOffsets = new Uint32Array(\n          result.decodedPositionOffsets,\n        );\n      }\n\n      polylines._currentPositions = new Float32Array(result.currentPositions);\n      polylines._previousPositions = new Float32Array(result.previousPositions);\n      polylines._nextPositions = new Float32Array(result.nextPositions);\n      polylines._expandAndWidth = new Float32Array(result.expandAndWidth);\n      polylines._vertexBatchIds = new Uint16Array(result.batchIds);\n\n      const indexDatatype = result.indexDatatype;\n      polylines._indices =\n        indexDatatype === IndexDatatype.UNSIGNED_SHORT\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n\n      finishVertexArray(polylines, context);\n\n      polylines._ready = true;\n    })\n    .catch((error) => {\n      if (polylines.isDestroyed()) {\n        return;\n      }\n\n      // Throw the error next frame\n      polylines._error = error;\n    });\n}\n\nfunction finishVertexArray(polylines, context) {\n  if (!defined(polylines._va)) {\n    const curPositions = polylines._currentPositions;\n    const prevPositions = polylines._previousPositions;\n    const nextPositions = polylines._nextPositions;\n    const expandAndWidth = polylines._expandAndWidth;\n    const vertexBatchIds = polylines._vertexBatchIds;\n    const indices = polylines._indices;\n\n    let byteLength =\n      prevPositions.byteLength +\n      curPositions.byteLength +\n      nextPositions.byteLength;\n    byteLength +=\n      expandAndWidth.byteLength +\n      vertexBatchIds.byteLength +\n      indices.byteLength;\n    polylines._trianglesLength = indices.length / 3;\n    polylines._geometryByteLength = byteLength;\n\n    const prevPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: prevPositions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const curPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: curPositions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const nextPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: nextPositions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const expandAndWidthBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: expandAndWidth,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const idBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: vertexBatchIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype:\n        indices.BYTES_PER_ELEMENT === 2\n          ? IndexDatatype.UNSIGNED_SHORT\n          : IndexDatatype.UNSIGNED_INT,\n    });\n\n    const vertexAttributes = [\n      {\n        index: attributeLocations.previousPosition,\n        vertexBuffer: prevPositionBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.currentPosition,\n        vertexBuffer: curPositionBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.nextPosition,\n        vertexBuffer: nextPositionBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.expandAndWidth,\n        vertexBuffer: expandAndWidthBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n      },\n      {\n        index: attributeLocations.a_batchId,\n        vertexBuffer: idBuffer,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        componentsPerAttribute: 1,\n      },\n    ];\n\n    polylines._va = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: indexBuffer,\n    });\n\n    polylines._positions = undefined;\n    polylines._widths = undefined;\n    polylines._counts = undefined;\n\n    polylines._ellipsoid = undefined;\n    polylines._minimumHeight = undefined;\n    polylines._maximumHeight = undefined;\n    polylines._rectangle = undefined;\n\n    polylines._transferrableBatchIds = undefined;\n    polylines._packedBuffer = undefined;\n\n    polylines._currentPositions = undefined;\n    polylines._previousPositions = undefined;\n    polylines._nextPositions = undefined;\n    polylines._expandAndWidth = undefined;\n    polylines._vertexBatchIds = undefined;\n    polylines._indices = undefined;\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  primitive._uniformMap = {\n    u_modifiedModelView: function () {\n      const viewMatrix = context.uniformState.view;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch,\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch,\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n  };\n}\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rs)) {\n    return;\n  }\n\n  const polygonOffset = {\n    enabled: true,\n    factor: -5.0,\n    units: -5.0,\n  };\n\n  primitive._rs = RenderState.fromCache({\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false,\n    depthTest: {\n      enabled: true,\n    },\n    polygonOffset: polygonOffset,\n  });\n}\n\nconst PolylineFS =\n  \"uniform vec4 u_highlightColor; \\n\" +\n  \"void main()\\n\" +\n  \"{\\n\" +\n  \"    out_FragColor = u_highlightColor;\\n\" +\n  \"}\\n\";\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  const batchTable = primitive._batchTable;\n\n  const vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined,\n  )(Vector3DTilePolylinesVS);\n  const fsSource = batchTable.getFragmentShaderCallback(\n    false,\n    undefined,\n    false,\n  )(PolylineFS);\n\n  const vs = new ShaderSource({\n    defines: [\n      \"VECTOR_TILE\",\n      !FeatureDetection.isInternetExplorer() ? \"CLIP_POLYLINE\" : \"\",\n    ],\n    sources: [PolylineCommon, vsSource],\n  });\n  const fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction queueCommands(primitive, frameState) {\n  if (!defined(primitive._command)) {\n    const uniformMap = primitive._batchTable.getUniformMapCallback()(\n      primitive._uniformMap,\n    );\n    primitive._command = new DrawCommand({\n      owner: primitive,\n      vertexArray: primitive._va,\n      renderState: primitive._rs,\n      shaderProgram: primitive._sp,\n      uniformMap: uniformMap,\n      boundingVolume: primitive._boundingVolume,\n      pass: Pass.TRANSLUCENT,\n      pickId: primitive._batchTable.getPickId(),\n    });\n  }\n\n  frameState.commandList.push(primitive._command);\n}\n\nVector3DTilePolylines.getPolylinePositions = function (polylines, batchId) {\n  const batchIds = polylines._batchIds;\n  const positions = polylines._decodedPositions;\n  const offsets = polylines._decodedPositionOffsets;\n\n  if (!defined(batchIds) || !defined(positions)) {\n    return undefined;\n  }\n\n  let i;\n  let j;\n  const polylinesLength = batchIds.length;\n  let positionsLength = 0;\n  let resultCounter = 0;\n\n  for (i = 0; i < polylinesLength; ++i) {\n    if (batchIds[i] === batchId) {\n      positionsLength += offsets[i + 1] - offsets[i];\n    }\n  }\n\n  if (positionsLength === 0) {\n    return undefined;\n  }\n\n  const results = new Float64Array(positionsLength * 3);\n\n  for (i = 0; i < polylinesLength; ++i) {\n    if (batchIds[i] === batchId) {\n      const offset = offsets[i];\n      const count = offsets[i + 1] - offset;\n      for (j = 0; j < count; ++j) {\n        const decodedOffset = (offset + j) * 3;\n        results[resultCounter++] = positions[decodedOffset];\n        results[resultCounter++] = positions[decodedOffset + 1];\n        results[resultCounter++] = positions[decodedOffset + 2];\n      }\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get the polyline positions for the given feature.\n *\n * @param {number} batchId The batch ID of the feature.\n */\nVector3DTilePolylines.prototype.getPositions = function (batchId) {\n  return Vector3DTilePolylines.getPolylinePositions(this, batchId);\n};\n\n/**\n * Creates features for each polyline and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolylines.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polyline batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolylines.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n}\n\nconst scratchColor = new Color();\n\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolylines.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolylines.prototype.update = function (frameState) {\n  const context = frameState.context;\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = createVertexArray(this, context);\n    }\n\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n\n    return;\n  }\n\n  createUniformMap(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    queueCommands(this, frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolylines.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolylines.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolylines;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}