{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport EllipsoidOutlineGeometry from \"../Core/EllipsoidOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nconst defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst radiiScratch = new Cartesian3();\nconst innerRadiiScratch = new Cartesian3();\nconst scratchColor = new Color();\nconst unitSphere = new Cartesian3(1, 1, 1);\nfunction EllipsoidGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.radii = undefined;\n  this.innerRadii = undefined;\n  this.minimumClock = undefined;\n  this.maximumClock = undefined;\n  this.minimumCone = undefined;\n  this.maximumCone = undefined;\n  this.stackPartitions = undefined;\n  this.slicePartitions = undefined;\n  this.subdivisions = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for ellipsoids.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipsoidGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction EllipsoidGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipsoidGeometryOptions(entity),\n    geometryPropertyName: \"ellipsoid\",\n    observedPropertyNames: [\"availability\", \"position\", \"orientation\", \"ellipsoid\"]\n  });\n  this._onEntityPropertyChanged(entity, \"ellipsoid\", entity.ellipsoid, undefined);\n}\nif (defined(Object.create)) {\n  EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n}\nObject.defineProperties(EllipsoidGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof EllipsoidGeometryUpdater.prototype\n   * @readonly\n   * @private\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    }\n  }\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nEllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function (time, skipModelMatrix, modelMatrixResult) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  let color;\n  const show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n    attributes.color = color;\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidGeometry(this._options),\n    modelMatrix: skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.ellipsoid, modelMatrixResult),\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nEllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function (time, skipModelMatrix, modelMatrixResult) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidOutlineGeometry(this._options),\n    modelMatrix: skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.ellipsoid, modelMatrixResult),\n    attributes: attributes\n  });\n};\nEllipsoidGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\nEllipsoidGeometryUpdater.prototype._isHidden = function (entity, ellipsoid) {\n  return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);\n};\nEllipsoidGeometryUpdater.prototype._isDynamic = function (entity, ellipsoid) {\n  return !entity.position.isConstant ||\n  //\n  !Property.isConstant(entity.orientation) ||\n  //\n  !ellipsoid.radii.isConstant ||\n  //\n  !Property.isConstant(ellipsoid.innerRadii) ||\n  //\n  !Property.isConstant(ellipsoid.stackPartitions) ||\n  //\n  !Property.isConstant(ellipsoid.slicePartitions) ||\n  //\n  !Property.isConstant(ellipsoid.outlineWidth) ||\n  //\n  !Property.isConstant(ellipsoid.minimumClock) ||\n  //\n  !Property.isConstant(ellipsoid.maximumClock) ||\n  //\n  !Property.isConstant(ellipsoid.minimumCone) ||\n  //\n  !Property.isConstant(ellipsoid.maximumCone) ||\n  //\n  !Property.isConstant(ellipsoid.subdivisions);\n};\nEllipsoidGeometryUpdater.prototype._setStaticOptions = function (entity, ellipsoid) {\n  const heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  const options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);\n  options.innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, options.radii);\n  options.minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, Iso8601.MINIMUM_VALUE);\n  options.maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, Iso8601.MINIMUM_VALUE);\n  options.minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, Iso8601.MINIMUM_VALUE);\n  options.maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, Iso8601.MINIMUM_VALUE);\n  options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);\n  options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);\n  options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n};\nEllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\nEllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n  this._scene = geometryUpdater._scene;\n  this._modelMatrix = new Matrix4();\n  this._attributes = undefined;\n  this._outlineAttributes = undefined;\n  this._lastSceneMode = undefined;\n  this._lastShow = undefined;\n  this._lastOutlineShow = undefined;\n  this._lastOutlineWidth = undefined;\n  this._lastOutlineColor = undefined;\n  this._lastOffset = new Cartesian3();\n  this._material = {};\n}\nif (defined(Object.create)) {\n  DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n}\nDynamicEllipsoidGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const ellipsoid = entity.ellipsoid;\n  if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n    return;\n  }\n  const radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n  let modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.ellipsoid, this._modelMatrix) : undefined;\n  if (!defined(modelMatrix) || !defined(radii)) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n    return;\n  }\n\n  //Compute attributes and material.\n  const showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n  const showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n  const outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);\n  const material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);\n\n  // Check properties that could trigger a primitive rebuild.\n  const innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, time, innerRadiiScratch);\n  const minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, time);\n  const maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, time);\n  const minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n  const maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n  const stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);\n  const slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);\n  const subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n  const outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);\n  const heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);\n  const offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n\n  //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n  //Also check for height reference because this method doesn't work when the height is relative to terrain.\n  const sceneMode = this._scene.mode;\n  const in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n  const options = this._options;\n  const shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n  const distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;\n  const distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);\n  const offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch);\n\n  //We only rebuild the primitive if something other than the radii has changed\n  //For the radii, we use unit sphere and then deform it with a scale matrix.\n  const rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) ||\n  //\n  options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions ||\n  //\n  defined(innerRadii) && !Cartesian3.equals(options.innerRadii !== innerRadii) || options.minimumClock !== minimumClock ||\n  //\n  options.maximumClock !== maximumClock || options.minimumCone !== minimumCone ||\n  //\n  options.maximumCone !== maximumCone || options.subdivisions !== subdivisions ||\n  //\n  this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;\n  if (rebuildPrimitives) {\n    const primitives = this._primitives;\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._primitive = undefined;\n    this._outlinePrimitive = undefined;\n    this._lastSceneMode = sceneMode;\n    this._lastOutlineWidth = outlineWidth;\n    options.stackPartitions = stackPartitions;\n    options.slicePartitions = slicePartitions;\n    options.subdivisions = subdivisions;\n    options.offsetAttribute = offsetAttribute;\n    options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n    if (defined(innerRadii)) {\n      if (in3D) {\n        options.innerRadii = Cartesian3.fromElements(innerRadii.x / radii.x, innerRadii.y / radii.y, innerRadii.z / radii.z, options.innerRadii);\n      } else {\n        options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n      }\n    } else {\n      options.innerRadii = undefined;\n    }\n    options.minimumClock = minimumClock;\n    options.maximumClock = maximumClock;\n    options.minimumCone = minimumCone;\n    options.maximumCone = maximumCone;\n    const appearance = new MaterialAppearance({\n      material: material,\n      translucent: material.isTranslucent(),\n      closed: true\n    });\n    options.vertexFormat = appearance.vertexFormat;\n    const fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);\n    this._primitive = primitives.add(new Primitive({\n      geometryInstances: fillInstance,\n      appearance: appearance,\n      asynchronous: false,\n      shadows: shadows\n    }));\n    const outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);\n    this._outlinePrimitive = primitives.add(new Primitive({\n      geometryInstances: outlineInstance,\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: outlineInstance.attributes.color.value[3] !== 255,\n        renderState: {\n          lineWidth: this._geometryUpdater._scene.clampLineWidth(outlineWidth)\n        }\n      }),\n      asynchronous: false,\n      shadows: shadows\n    }));\n    this._lastShow = showFill;\n    this._lastOutlineShow = showOutline;\n    this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n    this._lastDistanceDisplayCondition = distanceDisplayCondition;\n    this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n  } else if (this._primitive.ready) {\n    //Update attributes only.\n    const primitive = this._primitive;\n    const outlinePrimitive = this._outlinePrimitive;\n    primitive.show = true;\n    outlinePrimitive.show = true;\n    primitive.appearance.material = material;\n    let attributes = this._attributes;\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(entity);\n      this._attributes = attributes;\n    }\n    if (showFill !== this._lastShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);\n      this._lastShow = showFill;\n    }\n    let outlineAttributes = this._outlineAttributes;\n    if (!defined(outlineAttributes)) {\n      outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n      this._outlineAttributes = outlineAttributes;\n    }\n    if (showOutline !== this._lastOutlineShow) {\n      outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);\n      this._lastOutlineShow = showOutline;\n    }\n    if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n      outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);\n      Color.clone(outlineColor, this._lastOutlineColor);\n    }\n    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {\n      attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n      outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);\n      DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);\n    }\n    if (!Cartesian3.equals(offset, this._lastOffset)) {\n      attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n      outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n      Cartesian3.clone(offset, this._lastOffset);\n    }\n  }\n  if (in3D) {\n    //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n    //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n    //that you get passing EllipsoidGeometry a radii with a zero component.\n    radii.x = Math.max(radii.x, 0.001);\n    radii.y = Math.max(radii.y, 0.001);\n    radii.z = Math.max(radii.z, 0.001);\n    modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n    this._primitive.modelMatrix = modelMatrix;\n    this._outlinePrimitive.modelMatrix = modelMatrix;\n  }\n};\nexport default EllipsoidGeometryUpdater;","map":{"version":3,"names":["Cartesian3","Check","Color","ColorGeometryInstanceAttribute","defaultValue","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","EllipsoidGeometry","EllipsoidOutlineGeometry","GeometryInstance","GeometryOffsetAttribute","Iso8601","Matrix4","OffsetGeometryInstanceAttribute","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","Primitive","SceneMode","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","heightReferenceOnEntityPropertyChanged","MaterialProperty","Property","defaultMaterial","WHITE","defaultOffset","ZERO","offsetScratch","radiiScratch","innerRadiiScratch","scratchColor","unitSphere","EllipsoidGeometryOptions","entity","id","vertexFormat","undefined","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","offsetAttribute","EllipsoidGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","ellipsoid","Object","create","prototype","constructor","defineProperties","terrainOffsetProperty","get","_terrainOffsetProperty","createFillGeometryInstance","time","skipModelMatrix","modelMatrixResult","_entity","isAvailable","color","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","_distanceDisplayConditionProperty","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","attributes","offset","_materialProperty","currentColor","isConstant","fromColor","_options","fromCartesian3","getValueOrDefault","geometry","modelMatrix","computeModelMatrixForHeightReference","heightReference","z","_scene","createOutlineGeometryInstance","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","position","_isHidden","_isDynamic","orientation","outlineWidth","_setStaticOptions","MINIMUM_VALUE","NONE","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","ALL","DynamicEllipsoidGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_modelMatrix","_attributes","_outlineAttributes","_lastSceneMode","_lastShow","_lastOutlineShow","_lastOutlineWidth","_lastOutlineColor","_lastOffset","_material","update","_primitive","_outlinePrimitive","showFill","fill","showOutline","outline","getValueOrClonedDefault","material","sceneMode","mode","in3D","SCENE3D","shadows","_geometryUpdater","shadowsProperty","distanceDisplayConditionProperty","rebuildPrimitives","equals","_primitives","removeAndDestroy","clone","fromElements","x","y","appearance","translucent","isTranslucent","closed","fillInstance","add","geometryInstances","asynchronous","outlineInstance","flat","value","renderState","lineWidth","clampLineWidth","_lastDistanceDisplayCondition","ready","primitive","outlinePrimitive","getGeometryInstanceAttributes","toValue","outlineAttributes","Math","max","multiplyByScale"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/EllipsoidGeometryUpdater.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport EllipsoidOutlineGeometry from \"../Core/EllipsoidOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nconst defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nconst defaultOffset = Cartesian3.ZERO;\n\nconst offsetScratch = new Cartesian3();\nconst radiiScratch = new Cartesian3();\nconst innerRadiiScratch = new Cartesian3();\nconst scratchColor = new Color();\nconst unitSphere = new Cartesian3(1, 1, 1);\n\nfunction EllipsoidGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.radii = undefined;\n  this.innerRadii = undefined;\n  this.minimumClock = undefined;\n  this.maximumClock = undefined;\n  this.minimumCone = undefined;\n  this.maximumCone = undefined;\n  this.stackPartitions = undefined;\n  this.slicePartitions = undefined;\n  this.subdivisions = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for ellipsoids.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipsoidGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction EllipsoidGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipsoidGeometryOptions(entity),\n    geometryPropertyName: \"ellipsoid\",\n    observedPropertyNames: [\n      \"availability\",\n      \"position\",\n      \"orientation\",\n      \"ellipsoid\",\n    ],\n  });\n\n  this._onEntityPropertyChanged(\n    entity,\n    \"ellipsoid\",\n    entity.ellipsoid,\n    undefined,\n  );\n}\n\nif (defined(Object.create)) {\n  EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n}\n\nObject.defineProperties(EllipsoidGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof EllipsoidGeometryUpdater.prototype\n   * @readonly\n   * @private\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    },\n  },\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nEllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function (\n  time,\n  skipModelMatrix,\n  modelMatrixResult,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n\n  let color;\n  const show = new ShowGeometryInstanceAttribute(\n    isAvailable &&\n      entity.isShowing &&\n      this._showProperty.getValue(time) &&\n      this._fillProperty.getValue(time),\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute =\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition,\n    );\n\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n    attributes.color = color;\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidGeometry(this._options),\n    modelMatrix: skipModelMatrix\n      ? undefined\n      : entity.computeModelMatrixForHeightReference(\n          time,\n          entity.ellipsoid.heightReference,\n          this._options.radii.z * 0.5,\n          this._scene.ellipsoid,\n          modelMatrixResult,\n        ),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @param {boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nEllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time,\n  skipModelMatrix,\n  modelMatrixResult,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n\n  const outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time),\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        distanceDisplayCondition,\n      ),\n    offset: undefined,\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipsoidOutlineGeometry(this._options),\n    modelMatrix: skipModelMatrix\n      ? undefined\n      : entity.computeModelMatrixForHeightReference(\n          time,\n          entity.ellipsoid.heightReference,\n          this._options.radii.z * 0.5,\n          this._scene.ellipsoid,\n          modelMatrixResult,\n        ),\n    attributes: attributes,\n  });\n};\n\nEllipsoidGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nEllipsoidGeometryUpdater.prototype._isHidden = function (entity, ellipsoid) {\n  return (\n    !defined(entity.position) ||\n    !defined(ellipsoid.radii) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid)\n  );\n};\n\nEllipsoidGeometryUpdater.prototype._isDynamic = function (entity, ellipsoid) {\n  return (\n    !entity.position.isConstant || //\n    !Property.isConstant(entity.orientation) || //\n    !ellipsoid.radii.isConstant || //\n    !Property.isConstant(ellipsoid.innerRadii) || //\n    !Property.isConstant(ellipsoid.stackPartitions) || //\n    !Property.isConstant(ellipsoid.slicePartitions) || //\n    !Property.isConstant(ellipsoid.outlineWidth) || //\n    !Property.isConstant(ellipsoid.minimumClock) || //\n    !Property.isConstant(ellipsoid.maximumClock) || //\n    !Property.isConstant(ellipsoid.minimumCone) || //\n    !Property.isConstant(ellipsoid.maximumCone) || //\n    !Property.isConstant(ellipsoid.subdivisions)\n  );\n};\n\nEllipsoidGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  ellipsoid,\n) {\n  const heightReference = Property.getValueOrDefault(\n    ellipsoid.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n  const options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.radii = ellipsoid.radii.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.radii,\n  );\n  options.innerRadii = Property.getValueOrUndefined(\n    ellipsoid.innerRadii,\n    options.radii,\n  );\n  options.minimumClock = Property.getValueOrUndefined(\n    ellipsoid.minimumClock,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.maximumClock = Property.getValueOrUndefined(\n    ellipsoid.maximumClock,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.minimumCone = Property.getValueOrUndefined(\n    ellipsoid.minimumCone,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.maximumCone = Property.getValueOrUndefined(\n    ellipsoid.maximumCone,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.stackPartitions = Property.getValueOrUndefined(\n    ellipsoid.stackPartitions,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.slicePartitions = Property.getValueOrUndefined(\n    ellipsoid.slicePartitions,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.subdivisions = Property.getValueOrUndefined(\n    ellipsoid.subdivisions,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n};\n\nEllipsoidGeometryUpdater.prototype._onEntityPropertyChanged =\n  heightReferenceOnEntityPropertyChanged;\n\nEllipsoidGeometryUpdater.DynamicGeometryUpdater =\n  DynamicEllipsoidGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicEllipsoidGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives,\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives,\n  );\n\n  this._scene = geometryUpdater._scene;\n  this._modelMatrix = new Matrix4();\n  this._attributes = undefined;\n  this._outlineAttributes = undefined;\n  this._lastSceneMode = undefined;\n  this._lastShow = undefined;\n  this._lastOutlineShow = undefined;\n  this._lastOutlineWidth = undefined;\n  this._lastOutlineColor = undefined;\n  this._lastOffset = new Cartesian3();\n  this._material = {};\n}\n\nif (defined(Object.create)) {\n  DynamicEllipsoidGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype,\n  );\n  DynamicEllipsoidGeometryUpdater.prototype.constructor =\n    DynamicEllipsoidGeometryUpdater;\n}\n\nDynamicEllipsoidGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const ellipsoid = entity.ellipsoid;\n  if (\n    !entity.isShowing ||\n    !entity.isAvailable(time) ||\n    !Property.getValueOrDefault(ellipsoid.show, time, true)\n  ) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n    return;\n  }\n\n  const radii = Property.getValueOrUndefined(\n    ellipsoid.radii,\n    time,\n    radiiScratch,\n  );\n  let modelMatrix = defined(radii)\n    ? entity.computeModelMatrixForHeightReference(\n        time,\n        ellipsoid.heightReference,\n        radii.z * 0.5,\n        this._scene.ellipsoid,\n        this._modelMatrix,\n      )\n    : undefined;\n  if (!defined(modelMatrix) || !defined(radii)) {\n    if (defined(this._primitive)) {\n      this._primitive.show = false;\n    }\n\n    if (defined(this._outlinePrimitive)) {\n      this._outlinePrimitive.show = false;\n    }\n    return;\n  }\n\n  //Compute attributes and material.\n  const showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n  const showOutline = Property.getValueOrDefault(\n    ellipsoid.outline,\n    time,\n    false,\n  );\n  const outlineColor = Property.getValueOrClonedDefault(\n    ellipsoid.outlineColor,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const material = MaterialProperty.getValue(\n    time,\n    defaultValue(ellipsoid.material, defaultMaterial),\n    this._material,\n  );\n\n  // Check properties that could trigger a primitive rebuild.\n  const innerRadii = Property.getValueOrUndefined(\n    ellipsoid.innerRadii,\n    time,\n    innerRadiiScratch,\n  );\n  const minimumClock = Property.getValueOrUndefined(\n    ellipsoid.minimumClock,\n    time,\n  );\n  const maximumClock = Property.getValueOrUndefined(\n    ellipsoid.maximumClock,\n    time,\n  );\n  const minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n  const maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n  const stackPartitions = Property.getValueOrUndefined(\n    ellipsoid.stackPartitions,\n    time,\n  );\n  const slicePartitions = Property.getValueOrUndefined(\n    ellipsoid.slicePartitions,\n    time,\n  );\n  const subdivisions = Property.getValueOrUndefined(\n    ellipsoid.subdivisions,\n    time,\n  );\n  const outlineWidth = Property.getValueOrDefault(\n    ellipsoid.outlineWidth,\n    time,\n    1.0,\n  );\n  const heightReference = Property.getValueOrDefault(\n    ellipsoid.heightReference,\n    time,\n    HeightReference.NONE,\n  );\n  const offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n\n  //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n  //Also check for height reference because this method doesn't work when the height is relative to terrain.\n  const sceneMode = this._scene.mode;\n  const in3D =\n    sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n\n  const options = this._options;\n\n  const shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n  const distanceDisplayConditionProperty =\n    this._geometryUpdater.distanceDisplayConditionProperty;\n  const distanceDisplayCondition =\n    distanceDisplayConditionProperty.getValue(time);\n\n  const offset = Property.getValueOrDefault(\n    this._geometryUpdater.terrainOffsetProperty,\n    time,\n    defaultOffset,\n    offsetScratch,\n  );\n\n  //We only rebuild the primitive if something other than the radii has changed\n  //For the radii, we use unit sphere and then deform it with a scale matrix.\n  const rebuildPrimitives =\n    !in3D ||\n    this._lastSceneMode !== sceneMode ||\n    !defined(this._primitive) || //\n    options.stackPartitions !== stackPartitions ||\n    options.slicePartitions !== slicePartitions || //\n    (defined(innerRadii) &&\n      !Cartesian3.equals(options.innerRadii !== innerRadii)) ||\n    options.minimumClock !== minimumClock || //\n    options.maximumClock !== maximumClock ||\n    options.minimumCone !== minimumCone || //\n    options.maximumCone !== maximumCone ||\n    options.subdivisions !== subdivisions || //\n    this._lastOutlineWidth !== outlineWidth ||\n    options.offsetAttribute !== offsetAttribute;\n\n  if (rebuildPrimitives) {\n    const primitives = this._primitives;\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._primitive = undefined;\n    this._outlinePrimitive = undefined;\n    this._lastSceneMode = sceneMode;\n    this._lastOutlineWidth = outlineWidth;\n\n    options.stackPartitions = stackPartitions;\n    options.slicePartitions = slicePartitions;\n    options.subdivisions = subdivisions;\n    options.offsetAttribute = offsetAttribute;\n    options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n    if (defined(innerRadii)) {\n      if (in3D) {\n        options.innerRadii = Cartesian3.fromElements(\n          innerRadii.x / radii.x,\n          innerRadii.y / radii.y,\n          innerRadii.z / radii.z,\n          options.innerRadii,\n        );\n      } else {\n        options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n      }\n    } else {\n      options.innerRadii = undefined;\n    }\n    options.minimumClock = minimumClock;\n    options.maximumClock = maximumClock;\n    options.minimumCone = minimumCone;\n    options.maximumCone = maximumCone;\n\n    const appearance = new MaterialAppearance({\n      material: material,\n      translucent: material.isTranslucent(),\n      closed: true,\n    });\n    options.vertexFormat = appearance.vertexFormat;\n\n    const fillInstance = this._geometryUpdater.createFillGeometryInstance(\n      time,\n      in3D,\n      this._modelMatrix,\n    );\n\n    this._primitive = primitives.add(\n      new Primitive({\n        geometryInstances: fillInstance,\n        appearance: appearance,\n        asynchronous: false,\n        shadows: shadows,\n      }),\n    );\n\n    const outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(\n      time,\n      in3D,\n      this._modelMatrix,\n    );\n    this._outlinePrimitive = primitives.add(\n      new Primitive({\n        geometryInstances: outlineInstance,\n        appearance: new PerInstanceColorAppearance({\n          flat: true,\n          translucent: outlineInstance.attributes.color.value[3] !== 255,\n          renderState: {\n            lineWidth:\n              this._geometryUpdater._scene.clampLineWidth(outlineWidth),\n          },\n        }),\n        asynchronous: false,\n        shadows: shadows,\n      }),\n    );\n\n    this._lastShow = showFill;\n    this._lastOutlineShow = showOutline;\n    this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n    this._lastDistanceDisplayCondition = distanceDisplayCondition;\n    this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n  } else if (this._primitive.ready) {\n    //Update attributes only.\n    const primitive = this._primitive;\n    const outlinePrimitive = this._outlinePrimitive;\n\n    primitive.show = true;\n    outlinePrimitive.show = true;\n    primitive.appearance.material = material;\n\n    let attributes = this._attributes;\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(entity);\n      this._attributes = attributes;\n    }\n    if (showFill !== this._lastShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        showFill,\n        attributes.show,\n      );\n      this._lastShow = showFill;\n    }\n\n    let outlineAttributes = this._outlineAttributes;\n\n    if (!defined(outlineAttributes)) {\n      outlineAttributes =\n        outlinePrimitive.getGeometryInstanceAttributes(entity);\n      this._outlineAttributes = outlineAttributes;\n    }\n\n    if (showOutline !== this._lastOutlineShow) {\n      outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(\n        showOutline,\n        outlineAttributes.show,\n      );\n      this._lastOutlineShow = showOutline;\n    }\n\n    if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n      outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(\n        outlineColor,\n        outlineAttributes.color,\n      );\n      Color.clone(outlineColor, this._lastOutlineColor);\n    }\n\n    if (\n      !DistanceDisplayCondition.equals(\n        distanceDisplayCondition,\n        this._lastDistanceDisplayCondition,\n      )\n    ) {\n      attributes.distanceDisplayCondition =\n        DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n          distanceDisplayCondition,\n          attributes.distanceDisplayCondition,\n        );\n      outlineAttributes.distanceDisplayCondition =\n        DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n          distanceDisplayCondition,\n          outlineAttributes.distanceDisplayCondition,\n        );\n      DistanceDisplayCondition.clone(\n        distanceDisplayCondition,\n        this._lastDistanceDisplayCondition,\n      );\n    }\n\n    if (!Cartesian3.equals(offset, this._lastOffset)) {\n      attributes.offset = OffsetGeometryInstanceAttribute.toValue(\n        offset,\n        attributes.offset,\n      );\n      outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(\n        offset,\n        attributes.offset,\n      );\n      Cartesian3.clone(offset, this._lastOffset);\n    }\n  }\n\n  if (in3D) {\n    //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n    //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n    //that you get passing EllipsoidGeometry a radii with a zero component.\n    radii.x = Math.max(radii.x, 0.001);\n    radii.y = Math.max(radii.y, 0.001);\n    radii.z = Math.max(radii.z, 0.001);\n\n    modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n    this._primitive.modelMatrix = modelMatrix;\n    this._outlinePrimitive.modelMatrix = modelMatrix;\n  }\n};\nexport default EllipsoidGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}