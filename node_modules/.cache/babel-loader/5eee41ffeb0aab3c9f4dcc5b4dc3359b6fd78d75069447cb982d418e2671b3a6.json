{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nfunction addAttribute(attributes, attribute, index, context) {\n  const hasVertexBuffer = defined(attribute.vertexBuffer);\n  const hasValue = defined(attribute.value);\n  const componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!hasVertexBuffer && !hasValue) {\n    throw new DeveloperError(\"attribute must have a vertexBuffer or a value.\");\n  }\n  if (hasVertexBuffer && hasValue) {\n    throw new DeveloperError(\"attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.\");\n  }\n  if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {\n    if (hasValue) {\n      throw new DeveloperError(\"attribute.value.length must be in the range [1, 4].\");\n    }\n    throw new DeveloperError(\"attribute.componentsPerAttribute must be in the range [1, 4].\");\n  }\n  if (defined(attribute.componentDatatype) && !ComponentDatatype.validate(attribute.componentDatatype)) {\n    throw new DeveloperError(\"attribute must have a valid componentDatatype or not specify it.\");\n  }\n  if (defined(attribute.strideInBytes) && attribute.strideInBytes > 255) {\n    // WebGL limit.  Not in GL ES.\n    throw new DeveloperError(\"attribute must have a strideInBytes less than or equal to 255 or not specify it.\");\n  }\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && !context.instancedArrays) {\n    throw new DeveloperError(\"instanced arrays is not supported\");\n  }\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {\n    throw new DeveloperError(\"attribute must have an instanceDivisor greater than or equal to zero\");\n  }\n  if (defined(attribute.instanceDivisor) && hasValue) {\n    throw new DeveloperError(\"attribute cannot have have an instanceDivisor if it is not backed by a buffer\");\n  }\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor > 0 && attribute.index === 0) {\n    throw new DeveloperError(\"attribute zero cannot have an instanceDivisor greater than 0\");\n  }\n  //>>includeEnd('debug');\n\n  // Shallow copy the attribute; we do not want to copy the vertex buffer.\n  const attr = {\n    index: defaultValue(attribute.index, index),\n    enabled: defaultValue(attribute.enabled, true),\n    vertexBuffer: attribute.vertexBuffer,\n    value: hasValue ? attribute.value.slice(0) : undefined,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: defaultValue(attribute.componentDatatype, ComponentDatatype.FLOAT),\n    normalize: defaultValue(attribute.normalize, false),\n    offsetInBytes: defaultValue(attribute.offsetInBytes, 0),\n    strideInBytes: defaultValue(attribute.strideInBytes, 0),\n    instanceDivisor: defaultValue(attribute.instanceDivisor, 0)\n  };\n  if (hasVertexBuffer) {\n    // Common case: vertex buffer for per-vertex data\n    attr.vertexAttrib = function (gl) {\n      const index = this.index;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());\n      gl.vertexAttribPointer(index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes);\n      gl.enableVertexAttribArray(index);\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, this.instanceDivisor);\n        context._vertexAttribDivisors[index] = this.instanceDivisor;\n        context._previousDrawInstanced = true;\n      }\n    };\n    attr.disableVertexAttribArray = function (gl) {\n      gl.disableVertexAttribArray(this.index);\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, 0);\n      }\n    };\n  } else {\n    // Less common case: value array for the same data for each vertex\n    switch (attr.componentsPerAttribute) {\n      case 1:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib1fv(this.index, this.value);\n        };\n        break;\n      case 2:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib2fv(this.index, this.value);\n        };\n        break;\n      case 3:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib3fv(this.index, this.value);\n        };\n        break;\n      case 4:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib4fv(this.index, this.value);\n        };\n        break;\n    }\n    attr.disableVertexAttribArray = function (gl) {};\n  }\n  attributes.push(attr);\n}\nfunction bind(gl, attributes, indexBuffer) {\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n    if (attribute.enabled) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n  if (defined(indexBuffer)) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());\n  }\n}\n\n/**\n * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer\n * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.\n *\n * @param {object} options Object with the following properties:\n * @param {Context} options.context The context in which the VertexArray gets created.\n * @param {Object[]} options.attributes An array of attributes.\n * @param {IndexBuffer} [options.indexBuffer] An optional index buffer.\n *\n * @returns {VertexArray} The vertex array, ready for use with drawing.\n *\n * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.\n * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.\n * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.\n * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Create a vertex array with vertices made up of three floating point\n * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.\n * const positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         index                  : 0,\n *         enabled                : true,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : false,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 0 // tightly packed\n *         instanceDivisor        : 0 // not instanced\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 2. Create a vertex array with vertices from two different vertex buffers.\n * // Each vertex has a three-component position and three-component normal.\n * const positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const normalBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         index                  : 0,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     },\n *     {\n *         index                  : 1,\n *         vertexBuffer           : normalBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 3. Creates the same vertex layout as Example 2 using a single\n * // vertex buffer, instead of two.\n * const buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 24,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 24\n *     },\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : true,\n *         offsetInBytes          : 12,\n *         strideInBytes          : 24\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see Context#draw\n *\n * @private\n */\nfunction VertexArray(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  Check.defined(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const gl = context._gl;\n  const attributes = options.attributes;\n  const indexBuffer = options.indexBuffer;\n  let i;\n  const vaAttributes = [];\n  let numberOfVertices = 1; // if every attribute is backed by a single value\n  let hasInstancedAttributes = false;\n  let hasConstantAttributes = false;\n  let length = attributes.length;\n  for (i = 0; i < length; ++i) {\n    addAttribute(vaAttributes, attributes[i], i, context);\n  }\n  length = vaAttributes.length;\n  for (i = 0; i < length; ++i) {\n    const attribute = vaAttributes[i];\n    if (defined(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {\n      // This assumes that each vertex buffer in the vertex array has the same number of vertices.\n      const bytes = attribute.strideInBytes || attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;\n      break;\n    }\n  }\n  for (i = 0; i < length; ++i) {\n    if (vaAttributes[i].instanceDivisor > 0) {\n      hasInstancedAttributes = true;\n    }\n    if (defined(vaAttributes[i].value)) {\n      hasConstantAttributes = true;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  // Verify all attribute names are unique\n  const uniqueIndices = {};\n  for (i = 0; i < length; ++i) {\n    const index = vaAttributes[i].index;\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(`Index ${index} is used by more than one attribute.`);\n    }\n    uniqueIndices[index] = true;\n  }\n  //>>includeEnd('debug');\n\n  let vao;\n\n  // Setup VAO if supported\n  if (context.vertexArrayObject) {\n    vao = context.glCreateVertexArray();\n    context.glBindVertexArray(vao);\n    bind(gl, vaAttributes, indexBuffer);\n    context.glBindVertexArray(null);\n  }\n  this._numberOfVertices = numberOfVertices;\n  this._hasInstancedAttributes = hasInstancedAttributes;\n  this._hasConstantAttributes = hasConstantAttributes;\n  this._context = context;\n  this._gl = gl;\n  this._vao = vao;\n  this._attributes = vaAttributes;\n  this._indexBuffer = indexBuffer;\n}\nfunction computeNumberOfVertices(attribute) {\n  return attribute.values.length / attribute.componentsPerAttribute;\n}\nfunction computeAttributeSizeInBytes(attribute) {\n  return ComponentDatatype.getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;\n}\nfunction interleaveAttributes(attributes) {\n  let j;\n  let name;\n  let attribute;\n\n  // Extract attribute names.\n  const names = [];\n  for (name in attributes) {\n    // Attribute needs to have per-vertex values; not a constant value for all vertices.\n    if (attributes.hasOwnProperty(name) && defined(attributes[name]) && defined(attributes[name].values)) {\n      names.push(name);\n      if (attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n        attributes[name].componentDatatype = ComponentDatatype.FLOAT;\n        attributes[name].values = ComponentDatatype.createTypedArray(ComponentDatatype.FLOAT, attributes[name].values);\n      }\n    }\n  }\n\n  // Validation.  Compute number of vertices.\n  let numberOfVertices;\n  const namesLength = names.length;\n  if (namesLength > 0) {\n    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);\n    for (j = 1; j < namesLength; ++j) {\n      const currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);\n      if (currentNumberOfVertices !== numberOfVertices) {\n        throw new RuntimeError(`${\"Each attribute list must have the same number of vertices.  \" + \"Attribute \"}${names[j]} has a different number of vertices ` + `(${currentNumberOfVertices.toString()})` + ` than attribute ${names[0]} (${numberOfVertices.toString()}).`);\n      }\n    }\n  }\n\n  // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.\n  names.sort(function (left, right) {\n    return ComponentDatatype.getSizeInBytes(attributes[right].componentDatatype) - ComponentDatatype.getSizeInBytes(attributes[left].componentDatatype);\n  });\n\n  // Compute sizes and strides.\n  let vertexSizeInBytes = 0;\n  const offsetsInBytes = {};\n  for (j = 0; j < namesLength; ++j) {\n    name = names[j];\n    attribute = attributes[name];\n    offsetsInBytes[name] = vertexSizeInBytes;\n    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);\n  }\n  if (vertexSizeInBytes > 0) {\n    // Pad each vertex to be a multiple of the largest component datatype so each\n    // attribute can be addressed using typed arrays.\n    const maxComponentSizeInBytes = ComponentDatatype.getSizeInBytes(attributes[names[0]].componentDatatype); // Sorted large to small\n    const remainder = vertexSizeInBytes % maxComponentSizeInBytes;\n    if (remainder !== 0) {\n      vertexSizeInBytes += maxComponentSizeInBytes - remainder;\n    }\n\n    // Total vertex buffer size in bytes, including per-vertex padding.\n    const vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;\n\n    // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.\n    const buffer = new ArrayBuffer(vertexBufferSizeInBytes);\n    const views = {};\n    for (j = 0; j < namesLength; ++j) {\n      name = names[j];\n      const sizeInBytes = ComponentDatatype.getSizeInBytes(attributes[name].componentDatatype);\n      views[name] = {\n        pointer: ComponentDatatype.createTypedArray(attributes[name].componentDatatype, buffer),\n        index: offsetsInBytes[name] / sizeInBytes,\n        // Offset in ComponentType\n        strideInComponentType: vertexSizeInBytes / sizeInBytes\n      };\n    }\n\n    // Copy attributes into one interleaved array.\n    // PERFORMANCE_IDEA:  Can we optimize these loops?\n    for (j = 0; j < numberOfVertices; ++j) {\n      for (let n = 0; n < namesLength; ++n) {\n        name = names[n];\n        attribute = attributes[name];\n        const values = attribute.values;\n        const view = views[name];\n        const pointer = view.pointer;\n        const numberOfComponents = attribute.componentsPerAttribute;\n        for (let k = 0; k < numberOfComponents; ++k) {\n          pointer[view.index + k] = values[j * numberOfComponents + k];\n        }\n        view.index += view.strideInComponentType;\n      }\n    }\n    return {\n      buffer: buffer,\n      offsetsInBytes: offsetsInBytes,\n      vertexSizeInBytes: vertexSizeInBytes\n    };\n  }\n\n  // No attributes to interleave.\n  return undefined;\n}\n\n/**\n * Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data\n * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL\n * memory for use with rendering.\n * <br /><br />\n * The <code>geometry</code> argument should use the standard layout like the geometry returned by {@link BoxGeometry}.\n * <br /><br />\n * <code>options</code> can have four properties:\n * <ul>\n *   <li><code>geometry</code>:  The source geometry containing data used to create the vertex array.</li>\n *   <li><code>attributeLocations</code>:  An object that maps geometry attribute names to vertex shader attribute locations.</li>\n *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>\n *   <li><code>interleave</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>false</code>.</li>\n * </ul>\n * <br />\n * If <code>options</code> is not specified or the <code>geometry</code> contains no data, the returned vertex array is empty.\n *\n * @param {object} options An object defining the geometry, attribute indices, buffer usage, and vertex layout used to create the vertex array.\n *\n * @exception {RuntimeError} Each attribute list must have the same number of vertices.\n * @exception {DeveloperError} The geometry must have zero or one index lists.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw\n * // usage is used for the created vertex and index buffer.  The attributes are not\n * // interleaved by default.\n * const geometry = new BoxGeometry();\n * const va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n * });\n *\n * @example\n * // Example 2. Creates a vertex array with interleaved attributes in a\n * // single vertex buffer.  The vertex and index buffer have static draw usage.\n * const va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n *     bufferUsage        : BufferUsage.STATIC_DRAW,\n *     interleave         : true\n * });\n *\n * @example\n * // Example 3.  When the caller destroys the vertex array, it also destroys the\n * // attached vertex buffer(s) and index buffer.\n * va = va.destroy();\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see GeometryPipeline.createAttributeLocations\n * @see ShaderProgram\n */\nVertexArray.fromGeometry = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const geometry = defaultValue(options.geometry, defaultValue.EMPTY_OBJECT);\n  const bufferUsage = defaultValue(options.bufferUsage, BufferUsage.DYNAMIC_DRAW);\n  const attributeLocations = defaultValue(options.attributeLocations, defaultValue.EMPTY_OBJECT);\n  const interleave = defaultValue(options.interleave, false);\n  const createdVAAttributes = options.vertexArrayAttributes;\n  let name;\n  let attribute;\n  let vertexBuffer;\n  const vaAttributes = defined(createdVAAttributes) ? createdVAAttributes : [];\n  const attributes = geometry.attributes;\n  if (interleave) {\n    // Use a single vertex buffer with interleaved vertices.\n    const interleavedAttributes = interleaveAttributes(attributes);\n    if (defined(interleavedAttributes)) {\n      vertexBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: interleavedAttributes.buffer,\n        usage: bufferUsage\n      });\n      const offsetsInBytes = interleavedAttributes.offsetsInBytes;\n      const strideInBytes = interleavedAttributes.vertexSizeInBytes;\n      for (name in attributes) {\n        if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n          attribute = attributes[name];\n          if (defined(attribute.values)) {\n            // Common case: per-vertex attributes\n            vaAttributes.push({\n              index: attributeLocations[name],\n              vertexBuffer: vertexBuffer,\n              componentDatatype: attribute.componentDatatype,\n              componentsPerAttribute: attribute.componentsPerAttribute,\n              normalize: attribute.normalize,\n              offsetInBytes: offsetsInBytes[name],\n              strideInBytes: strideInBytes\n            });\n          } else {\n            // Constant attribute for all vertices\n            vaAttributes.push({\n              index: attributeLocations[name],\n              value: attribute.value,\n              componentDatatype: attribute.componentDatatype,\n              normalize: attribute.normalize\n            });\n          }\n        }\n      }\n    }\n  } else {\n    // One vertex buffer per attribute.\n    for (name in attributes) {\n      if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n        attribute = attributes[name];\n        let componentDatatype = attribute.componentDatatype;\n        if (componentDatatype === ComponentDatatype.DOUBLE) {\n          componentDatatype = ComponentDatatype.FLOAT;\n        }\n        vertexBuffer = undefined;\n        if (defined(attribute.values)) {\n          vertexBuffer = Buffer.createVertexBuffer({\n            context: context,\n            typedArray: ComponentDatatype.createTypedArray(componentDatatype, attribute.values),\n            usage: bufferUsage\n          });\n        }\n        vaAttributes.push({\n          index: attributeLocations[name],\n          vertexBuffer: vertexBuffer,\n          value: attribute.value,\n          componentDatatype: componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize\n        });\n      }\n    }\n  }\n  let indexBuffer;\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    if (Geometry.computeNumberOfVertices(geometry) >= CesiumMath.SIXTY_FOUR_KILOBYTES && context.elementIndexUint) {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint32Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_INT\n      });\n    } else {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint16Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_SHORT\n      });\n    }\n  }\n  return new VertexArray({\n    context: context,\n    attributes: vaAttributes,\n    indexBuffer: indexBuffer\n  });\n};\nObject.defineProperties(VertexArray.prototype, {\n  numberOfAttributes: {\n    get: function () {\n      return this._attributes.length;\n    }\n  },\n  numberOfVertices: {\n    get: function () {\n      return this._numberOfVertices;\n    }\n  },\n  indexBuffer: {\n    get: function () {\n      return this._indexBuffer;\n    }\n  }\n});\n\n/**\n * index is the location in the array of attributes, not the index property of an attribute.\n */\nVertexArray.prototype.getAttribute = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._attributes[index];\n};\n\n// Workaround for ANGLE, where the attribute divisor seems to be part of the global state instead\n// of the VAO state. This function is called when the vao is bound, and should be removed\n// once the ANGLE issue is resolved. Setting the divisor should normally happen in vertexAttrib and\n// disableVertexAttribArray.\nfunction setVertexAttribDivisor(vertexArray) {\n  const context = vertexArray._context;\n  const hasInstancedAttributes = vertexArray._hasInstancedAttributes;\n  if (!hasInstancedAttributes && !context._previousDrawInstanced) {\n    return;\n  }\n  context._previousDrawInstanced = hasInstancedAttributes;\n  const divisors = context._vertexAttribDivisors;\n  const attributes = vertexArray._attributes;\n  const maxAttributes = ContextLimits.maximumVertexAttributes;\n  let i;\n  if (hasInstancedAttributes) {\n    const length = attributes.length;\n    for (i = 0; i < length; ++i) {\n      const attribute = attributes[i];\n      if (attribute.enabled) {\n        const divisor = attribute.instanceDivisor;\n        const index = attribute.index;\n        if (divisor !== divisors[index]) {\n          context.glVertexAttribDivisor(index, divisor);\n          divisors[index] = divisor;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < maxAttributes; ++i) {\n      if (divisors[i] > 0) {\n        context.glVertexAttribDivisor(i, 0);\n        divisors[i] = 0;\n      }\n    }\n  }\n}\n\n// Vertex attributes backed by a constant value go through vertexAttrib[1234]f[v]\n// which is part of context state rather than VAO state.\nfunction setConstantAttributes(vertexArray, gl) {\n  const attributes = vertexArray._attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    if (attribute.enabled && defined(attribute.value)) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n}\nVertexArray.prototype._bind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(this._vao);\n    if (this._context.instancedArrays) {\n      setVertexAttribDivisor(this);\n    }\n    if (this._hasConstantAttributes) {\n      setConstantAttributes(this, this._gl);\n    }\n  } else {\n    bind(this._gl, this._attributes, this._indexBuffer);\n  }\n};\nVertexArray.prototype._unBind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(null);\n  } else {\n    const attributes = this._attributes;\n    const gl = this._gl;\n    for (let i = 0; i < attributes.length; ++i) {\n      const attribute = attributes[i];\n      if (attribute.enabled) {\n        attribute.disableVertexAttribArray(gl);\n      }\n    }\n    if (this._indexBuffer) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n  }\n};\nVertexArray.prototype.isDestroyed = function () {\n  return false;\n};\nVertexArray.prototype.destroy = function () {\n  const attributes = this._attributes;\n  for (let i = 0; i < attributes.length; ++i) {\n    const vertexBuffer = attributes[i].vertexBuffer;\n    if (defined(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {\n      vertexBuffer.destroy();\n    }\n  }\n  const indexBuffer = this._indexBuffer;\n  if (defined(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {\n    indexBuffer.destroy();\n  }\n  if (defined(this._vao)) {\n    this._context.glDeleteVertexArray(this._vao);\n  }\n  return destroyObject(this);\n};\nexport default VertexArray;","map":{"version":3,"names":["Check","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","Geometry","IndexDatatype","CesiumMath","RuntimeError","Buffer","BufferUsage","ContextLimits","addAttribute","attributes","attribute","index","context","hasVertexBuffer","vertexBuffer","hasValue","value","componentsPerAttribute","length","componentDatatype","validate","strideInBytes","instanceDivisor","instancedArrays","attr","enabled","slice","undefined","FLOAT","normalize","offsetInBytes","vertexAttrib","gl","bindBuffer","ARRAY_BUFFER","_getBuffer","vertexAttribPointer","enableVertexAttribArray","glVertexAttribDivisor","_vertexAttribDivisors","_previousDrawInstanced","disableVertexAttribArray","vertexAttrib1fv","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","push","bind","indexBuffer","i","ELEMENT_ARRAY_BUFFER","VertexArray","options","EMPTY_OBJECT","_gl","vaAttributes","numberOfVertices","hasInstancedAttributes","hasConstantAttributes","bytes","getSizeInBytes","sizeInBytes","uniqueIndices","vao","vertexArrayObject","glCreateVertexArray","glBindVertexArray","_numberOfVertices","_hasInstancedAttributes","_hasConstantAttributes","_context","_vao","_attributes","_indexBuffer","computeNumberOfVertices","values","computeAttributeSizeInBytes","interleaveAttributes","j","name","names","hasOwnProperty","DOUBLE","createTypedArray","namesLength","currentNumberOfVertices","toString","sort","left","right","vertexSizeInBytes","offsetsInBytes","maxComponentSizeInBytes","remainder","vertexBufferSizeInBytes","buffer","ArrayBuffer","views","pointer","strideInComponentType","n","view","numberOfComponents","k","fromGeometry","geometry","bufferUsage","DYNAMIC_DRAW","attributeLocations","interleave","createdVAAttributes","vertexArrayAttributes","interleavedAttributes","createVertexBuffer","typedArray","usage","indices","SIXTY_FOUR_KILOBYTES","elementIndexUint","createIndexBuffer","Uint32Array","indexDatatype","UNSIGNED_INT","Uint16Array","UNSIGNED_SHORT","Object","defineProperties","prototype","numberOfAttributes","get","getAttribute","setVertexAttribDivisor","vertexArray","divisors","maxAttributes","maximumVertexAttributes","divisor","setConstantAttributes","_bind","_unBind","isDestroyed","destroy","vertexArrayDestroyable","glDeleteVertexArray"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/VertexArray.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport ContextLimits from \"./ContextLimits.js\";\n\nfunction addAttribute(attributes, attribute, index, context) {\n  const hasVertexBuffer = defined(attribute.vertexBuffer);\n  const hasValue = defined(attribute.value);\n  const componentsPerAttribute = attribute.value\n    ? attribute.value.length\n    : attribute.componentsPerAttribute;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!hasVertexBuffer && !hasValue) {\n    throw new DeveloperError(\"attribute must have a vertexBuffer or a value.\");\n  }\n  if (hasVertexBuffer && hasValue) {\n    throw new DeveloperError(\n      \"attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.\",\n    );\n  }\n  if (\n    componentsPerAttribute !== 1 &&\n    componentsPerAttribute !== 2 &&\n    componentsPerAttribute !== 3 &&\n    componentsPerAttribute !== 4\n  ) {\n    if (hasValue) {\n      throw new DeveloperError(\n        \"attribute.value.length must be in the range [1, 4].\",\n      );\n    }\n\n    throw new DeveloperError(\n      \"attribute.componentsPerAttribute must be in the range [1, 4].\",\n    );\n  }\n  if (\n    defined(attribute.componentDatatype) &&\n    !ComponentDatatype.validate(attribute.componentDatatype)\n  ) {\n    throw new DeveloperError(\n      \"attribute must have a valid componentDatatype or not specify it.\",\n    );\n  }\n  if (defined(attribute.strideInBytes) && attribute.strideInBytes > 255) {\n    // WebGL limit.  Not in GL ES.\n    throw new DeveloperError(\n      \"attribute must have a strideInBytes less than or equal to 255 or not specify it.\",\n    );\n  }\n  if (\n    defined(attribute.instanceDivisor) &&\n    attribute.instanceDivisor > 0 &&\n    !context.instancedArrays\n  ) {\n    throw new DeveloperError(\"instanced arrays is not supported\");\n  }\n  if (defined(attribute.instanceDivisor) && attribute.instanceDivisor < 0) {\n    throw new DeveloperError(\n      \"attribute must have an instanceDivisor greater than or equal to zero\",\n    );\n  }\n  if (defined(attribute.instanceDivisor) && hasValue) {\n    throw new DeveloperError(\n      \"attribute cannot have have an instanceDivisor if it is not backed by a buffer\",\n    );\n  }\n  if (\n    defined(attribute.instanceDivisor) &&\n    attribute.instanceDivisor > 0 &&\n    attribute.index === 0\n  ) {\n    throw new DeveloperError(\n      \"attribute zero cannot have an instanceDivisor greater than 0\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Shallow copy the attribute; we do not want to copy the vertex buffer.\n  const attr = {\n    index: defaultValue(attribute.index, index),\n    enabled: defaultValue(attribute.enabled, true),\n    vertexBuffer: attribute.vertexBuffer,\n    value: hasValue ? attribute.value.slice(0) : undefined,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: defaultValue(\n      attribute.componentDatatype,\n      ComponentDatatype.FLOAT,\n    ),\n    normalize: defaultValue(attribute.normalize, false),\n    offsetInBytes: defaultValue(attribute.offsetInBytes, 0),\n    strideInBytes: defaultValue(attribute.strideInBytes, 0),\n    instanceDivisor: defaultValue(attribute.instanceDivisor, 0),\n  };\n\n  if (hasVertexBuffer) {\n    // Common case: vertex buffer for per-vertex data\n    attr.vertexAttrib = function (gl) {\n      const index = this.index;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());\n      gl.vertexAttribPointer(\n        index,\n        this.componentsPerAttribute,\n        this.componentDatatype,\n        this.normalize,\n        this.strideInBytes,\n        this.offsetInBytes,\n      );\n      gl.enableVertexAttribArray(index);\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, this.instanceDivisor);\n        context._vertexAttribDivisors[index] = this.instanceDivisor;\n        context._previousDrawInstanced = true;\n      }\n    };\n\n    attr.disableVertexAttribArray = function (gl) {\n      gl.disableVertexAttribArray(this.index);\n      if (this.instanceDivisor > 0) {\n        context.glVertexAttribDivisor(index, 0);\n      }\n    };\n  } else {\n    // Less common case: value array for the same data for each vertex\n    switch (attr.componentsPerAttribute) {\n      case 1:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib1fv(this.index, this.value);\n        };\n        break;\n      case 2:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib2fv(this.index, this.value);\n        };\n        break;\n      case 3:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib3fv(this.index, this.value);\n        };\n        break;\n      case 4:\n        attr.vertexAttrib = function (gl) {\n          gl.vertexAttrib4fv(this.index, this.value);\n        };\n        break;\n    }\n\n    attr.disableVertexAttribArray = function (gl) {};\n  }\n\n  attributes.push(attr);\n}\n\nfunction bind(gl, attributes, indexBuffer) {\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n    if (attribute.enabled) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n\n  if (defined(indexBuffer)) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());\n  }\n}\n\n/**\n * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer\n * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.\n *\n * @param {object} options Object with the following properties:\n * @param {Context} options.context The context in which the VertexArray gets created.\n * @param {Object[]} options.attributes An array of attributes.\n * @param {IndexBuffer} [options.indexBuffer] An optional index buffer.\n *\n * @returns {VertexArray} The vertex array, ready for use with drawing.\n *\n * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.\n * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.\n * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.\n * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Create a vertex array with vertices made up of three floating point\n * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.\n * const positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         index                  : 0,\n *         enabled                : true,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : false,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 0 // tightly packed\n *         instanceDivisor        : 0 // not instanced\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 2. Create a vertex array with vertices from two different vertex buffers.\n * // Each vertex has a three-component position and three-component normal.\n * const positionBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const normalBuffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 12,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         index                  : 0,\n *         vertexBuffer           : positionBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     },\n *     {\n *         index                  : 1,\n *         vertexBuffer           : normalBuffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @example\n * // Example 3. Creates the same vertex layout as Example 2 using a single\n * // vertex buffer, instead of two.\n * const buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 24,\n *     usage : BufferUsage.STATIC_DRAW\n * });\n * const attributes = [\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         offsetInBytes          : 0,\n *         strideInBytes          : 24\n *     },\n *     {\n *         vertexBuffer           : buffer,\n *         componentsPerAttribute : 3,\n *         componentDatatype      : ComponentDatatype.FLOAT,\n *         normalize              : true,\n *         offsetInBytes          : 12,\n *         strideInBytes          : 24\n *     }\n * ];\n * const va = new VertexArray({\n *     context : context,\n *     attributes : attributes\n * });\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see Context#draw\n *\n * @private\n */\nfunction VertexArray(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  Check.defined(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const gl = context._gl;\n  const attributes = options.attributes;\n  const indexBuffer = options.indexBuffer;\n\n  let i;\n  const vaAttributes = [];\n  let numberOfVertices = 1; // if every attribute is backed by a single value\n  let hasInstancedAttributes = false;\n  let hasConstantAttributes = false;\n\n  let length = attributes.length;\n  for (i = 0; i < length; ++i) {\n    addAttribute(vaAttributes, attributes[i], i, context);\n  }\n\n  length = vaAttributes.length;\n  for (i = 0; i < length; ++i) {\n    const attribute = vaAttributes[i];\n\n    if (defined(attribute.vertexBuffer) && attribute.instanceDivisor === 0) {\n      // This assumes that each vertex buffer in the vertex array has the same number of vertices.\n      const bytes =\n        attribute.strideInBytes ||\n        attribute.componentsPerAttribute *\n          ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n      numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;\n      break;\n    }\n  }\n\n  for (i = 0; i < length; ++i) {\n    if (vaAttributes[i].instanceDivisor > 0) {\n      hasInstancedAttributes = true;\n    }\n    if (defined(vaAttributes[i].value)) {\n      hasConstantAttributes = true;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  // Verify all attribute names are unique\n  const uniqueIndices = {};\n  for (i = 0; i < length; ++i) {\n    const index = vaAttributes[i].index;\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(\n        `Index ${index} is used by more than one attribute.`,\n      );\n    }\n    uniqueIndices[index] = true;\n  }\n  //>>includeEnd('debug');\n\n  let vao;\n\n  // Setup VAO if supported\n  if (context.vertexArrayObject) {\n    vao = context.glCreateVertexArray();\n    context.glBindVertexArray(vao);\n    bind(gl, vaAttributes, indexBuffer);\n    context.glBindVertexArray(null);\n  }\n\n  this._numberOfVertices = numberOfVertices;\n  this._hasInstancedAttributes = hasInstancedAttributes;\n  this._hasConstantAttributes = hasConstantAttributes;\n  this._context = context;\n  this._gl = gl;\n  this._vao = vao;\n  this._attributes = vaAttributes;\n  this._indexBuffer = indexBuffer;\n}\n\nfunction computeNumberOfVertices(attribute) {\n  return attribute.values.length / attribute.componentsPerAttribute;\n}\n\nfunction computeAttributeSizeInBytes(attribute) {\n  return (\n    ComponentDatatype.getSizeInBytes(attribute.componentDatatype) *\n    attribute.componentsPerAttribute\n  );\n}\n\nfunction interleaveAttributes(attributes) {\n  let j;\n  let name;\n  let attribute;\n\n  // Extract attribute names.\n  const names = [];\n  for (name in attributes) {\n    // Attribute needs to have per-vertex values; not a constant value for all vertices.\n    if (\n      attributes.hasOwnProperty(name) &&\n      defined(attributes[name]) &&\n      defined(attributes[name].values)\n    ) {\n      names.push(name);\n\n      if (attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n        attributes[name].componentDatatype = ComponentDatatype.FLOAT;\n        attributes[name].values = ComponentDatatype.createTypedArray(\n          ComponentDatatype.FLOAT,\n          attributes[name].values,\n        );\n      }\n    }\n  }\n\n  // Validation.  Compute number of vertices.\n  let numberOfVertices;\n  const namesLength = names.length;\n\n  if (namesLength > 0) {\n    numberOfVertices = computeNumberOfVertices(attributes[names[0]]);\n\n    for (j = 1; j < namesLength; ++j) {\n      const currentNumberOfVertices = computeNumberOfVertices(\n        attributes[names[j]],\n      );\n\n      if (currentNumberOfVertices !== numberOfVertices) {\n        throw new RuntimeError(\n          `${\n            \"Each attribute list must have the same number of vertices.  \" +\n            \"Attribute \"\n          }${names[j]} has a different number of vertices ` +\n            `(${currentNumberOfVertices.toString()})` +\n            ` than attribute ${names[0]} (${numberOfVertices.toString()}).`,\n        );\n      }\n    }\n  }\n\n  // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.\n  names.sort(function (left, right) {\n    return (\n      ComponentDatatype.getSizeInBytes(attributes[right].componentDatatype) -\n      ComponentDatatype.getSizeInBytes(attributes[left].componentDatatype)\n    );\n  });\n\n  // Compute sizes and strides.\n  let vertexSizeInBytes = 0;\n  const offsetsInBytes = {};\n\n  for (j = 0; j < namesLength; ++j) {\n    name = names[j];\n    attribute = attributes[name];\n\n    offsetsInBytes[name] = vertexSizeInBytes;\n    vertexSizeInBytes += computeAttributeSizeInBytes(attribute);\n  }\n\n  if (vertexSizeInBytes > 0) {\n    // Pad each vertex to be a multiple of the largest component datatype so each\n    // attribute can be addressed using typed arrays.\n    const maxComponentSizeInBytes = ComponentDatatype.getSizeInBytes(\n      attributes[names[0]].componentDatatype,\n    ); // Sorted large to small\n    const remainder = vertexSizeInBytes % maxComponentSizeInBytes;\n    if (remainder !== 0) {\n      vertexSizeInBytes += maxComponentSizeInBytes - remainder;\n    }\n\n    // Total vertex buffer size in bytes, including per-vertex padding.\n    const vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;\n\n    // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.\n    const buffer = new ArrayBuffer(vertexBufferSizeInBytes);\n    const views = {};\n\n    for (j = 0; j < namesLength; ++j) {\n      name = names[j];\n      const sizeInBytes = ComponentDatatype.getSizeInBytes(\n        attributes[name].componentDatatype,\n      );\n\n      views[name] = {\n        pointer: ComponentDatatype.createTypedArray(\n          attributes[name].componentDatatype,\n          buffer,\n        ),\n        index: offsetsInBytes[name] / sizeInBytes, // Offset in ComponentType\n        strideInComponentType: vertexSizeInBytes / sizeInBytes,\n      };\n    }\n\n    // Copy attributes into one interleaved array.\n    // PERFORMANCE_IDEA:  Can we optimize these loops?\n    for (j = 0; j < numberOfVertices; ++j) {\n      for (let n = 0; n < namesLength; ++n) {\n        name = names[n];\n        attribute = attributes[name];\n        const values = attribute.values;\n        const view = views[name];\n        const pointer = view.pointer;\n\n        const numberOfComponents = attribute.componentsPerAttribute;\n        for (let k = 0; k < numberOfComponents; ++k) {\n          pointer[view.index + k] = values[j * numberOfComponents + k];\n        }\n\n        view.index += view.strideInComponentType;\n      }\n    }\n\n    return {\n      buffer: buffer,\n      offsetsInBytes: offsetsInBytes,\n      vertexSizeInBytes: vertexSizeInBytes,\n    };\n  }\n\n  // No attributes to interleave.\n  return undefined;\n}\n\n/**\n * Creates a vertex array from a geometry.  A geometry contains vertex attributes and optional index data\n * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL\n * memory for use with rendering.\n * <br /><br />\n * The <code>geometry</code> argument should use the standard layout like the geometry returned by {@link BoxGeometry}.\n * <br /><br />\n * <code>options</code> can have four properties:\n * <ul>\n *   <li><code>geometry</code>:  The source geometry containing data used to create the vertex array.</li>\n *   <li><code>attributeLocations</code>:  An object that maps geometry attribute names to vertex shader attribute locations.</li>\n *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>\n *   <li><code>interleave</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>false</code>.</li>\n * </ul>\n * <br />\n * If <code>options</code> is not specified or the <code>geometry</code> contains no data, the returned vertex array is empty.\n *\n * @param {object} options An object defining the geometry, attribute indices, buffer usage, and vertex layout used to create the vertex array.\n *\n * @exception {RuntimeError} Each attribute list must have the same number of vertices.\n * @exception {DeveloperError} The geometry must have zero or one index lists.\n * @exception {DeveloperError} Index n is used by more than one attribute.\n *\n *\n * @example\n * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw\n * // usage is used for the created vertex and index buffer.  The attributes are not\n * // interleaved by default.\n * const geometry = new BoxGeometry();\n * const va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n * });\n *\n * @example\n * // Example 2. Creates a vertex array with interleaved attributes in a\n * // single vertex buffer.  The vertex and index buffer have static draw usage.\n * const va = VertexArray.fromGeometry({\n *     context            : context,\n *     geometry           : geometry,\n *     attributeLocations : GeometryPipeline.createAttributeLocations(geometry),\n *     bufferUsage        : BufferUsage.STATIC_DRAW,\n *     interleave         : true\n * });\n *\n * @example\n * // Example 3.  When the caller destroys the vertex array, it also destroys the\n * // attached vertex buffer(s) and index buffer.\n * va = va.destroy();\n *\n * @see Buffer#createVertexBuffer\n * @see Buffer#createIndexBuffer\n * @see GeometryPipeline.createAttributeLocations\n * @see ShaderProgram\n */\nVertexArray.fromGeometry = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const geometry = defaultValue(options.geometry, defaultValue.EMPTY_OBJECT);\n\n  const bufferUsage = defaultValue(\n    options.bufferUsage,\n    BufferUsage.DYNAMIC_DRAW,\n  );\n\n  const attributeLocations = defaultValue(\n    options.attributeLocations,\n    defaultValue.EMPTY_OBJECT,\n  );\n  const interleave = defaultValue(options.interleave, false);\n  const createdVAAttributes = options.vertexArrayAttributes;\n\n  let name;\n  let attribute;\n  let vertexBuffer;\n  const vaAttributes = defined(createdVAAttributes) ? createdVAAttributes : [];\n  const attributes = geometry.attributes;\n\n  if (interleave) {\n    // Use a single vertex buffer with interleaved vertices.\n    const interleavedAttributes = interleaveAttributes(attributes);\n    if (defined(interleavedAttributes)) {\n      vertexBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: interleavedAttributes.buffer,\n        usage: bufferUsage,\n      });\n      const offsetsInBytes = interleavedAttributes.offsetsInBytes;\n      const strideInBytes = interleavedAttributes.vertexSizeInBytes;\n\n      for (name in attributes) {\n        if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n          attribute = attributes[name];\n\n          if (defined(attribute.values)) {\n            // Common case: per-vertex attributes\n            vaAttributes.push({\n              index: attributeLocations[name],\n              vertexBuffer: vertexBuffer,\n              componentDatatype: attribute.componentDatatype,\n              componentsPerAttribute: attribute.componentsPerAttribute,\n              normalize: attribute.normalize,\n              offsetInBytes: offsetsInBytes[name],\n              strideInBytes: strideInBytes,\n            });\n          } else {\n            // Constant attribute for all vertices\n            vaAttributes.push({\n              index: attributeLocations[name],\n              value: attribute.value,\n              componentDatatype: attribute.componentDatatype,\n              normalize: attribute.normalize,\n            });\n          }\n        }\n      }\n    }\n  } else {\n    // One vertex buffer per attribute.\n    for (name in attributes) {\n      if (attributes.hasOwnProperty(name) && defined(attributes[name])) {\n        attribute = attributes[name];\n\n        let componentDatatype = attribute.componentDatatype;\n        if (componentDatatype === ComponentDatatype.DOUBLE) {\n          componentDatatype = ComponentDatatype.FLOAT;\n        }\n\n        vertexBuffer = undefined;\n        if (defined(attribute.values)) {\n          vertexBuffer = Buffer.createVertexBuffer({\n            context: context,\n            typedArray: ComponentDatatype.createTypedArray(\n              componentDatatype,\n              attribute.values,\n            ),\n            usage: bufferUsage,\n          });\n        }\n\n        vaAttributes.push({\n          index: attributeLocations[name],\n          vertexBuffer: vertexBuffer,\n          value: attribute.value,\n          componentDatatype: componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n        });\n      }\n    }\n  }\n\n  let indexBuffer;\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    if (\n      Geometry.computeNumberOfVertices(geometry) >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES &&\n      context.elementIndexUint\n    ) {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint32Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_INT,\n      });\n    } else {\n      indexBuffer = Buffer.createIndexBuffer({\n        context: context,\n        typedArray: new Uint16Array(indices),\n        usage: bufferUsage,\n        indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n      });\n    }\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: vaAttributes,\n    indexBuffer: indexBuffer,\n  });\n};\n\nObject.defineProperties(VertexArray.prototype, {\n  numberOfAttributes: {\n    get: function () {\n      return this._attributes.length;\n    },\n  },\n  numberOfVertices: {\n    get: function () {\n      return this._numberOfVertices;\n    },\n  },\n  indexBuffer: {\n    get: function () {\n      return this._indexBuffer;\n    },\n  },\n});\n\n/**\n * index is the location in the array of attributes, not the index property of an attribute.\n */\nVertexArray.prototype.getAttribute = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._attributes[index];\n};\n\n// Workaround for ANGLE, where the attribute divisor seems to be part of the global state instead\n// of the VAO state. This function is called when the vao is bound, and should be removed\n// once the ANGLE issue is resolved. Setting the divisor should normally happen in vertexAttrib and\n// disableVertexAttribArray.\nfunction setVertexAttribDivisor(vertexArray) {\n  const context = vertexArray._context;\n  const hasInstancedAttributes = vertexArray._hasInstancedAttributes;\n  if (!hasInstancedAttributes && !context._previousDrawInstanced) {\n    return;\n  }\n  context._previousDrawInstanced = hasInstancedAttributes;\n\n  const divisors = context._vertexAttribDivisors;\n  const attributes = vertexArray._attributes;\n  const maxAttributes = ContextLimits.maximumVertexAttributes;\n  let i;\n\n  if (hasInstancedAttributes) {\n    const length = attributes.length;\n    for (i = 0; i < length; ++i) {\n      const attribute = attributes[i];\n      if (attribute.enabled) {\n        const divisor = attribute.instanceDivisor;\n        const index = attribute.index;\n        if (divisor !== divisors[index]) {\n          context.glVertexAttribDivisor(index, divisor);\n          divisors[index] = divisor;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < maxAttributes; ++i) {\n      if (divisors[i] > 0) {\n        context.glVertexAttribDivisor(i, 0);\n        divisors[i] = 0;\n      }\n    }\n  }\n}\n\n// Vertex attributes backed by a constant value go through vertexAttrib[1234]f[v]\n// which is part of context state rather than VAO state.\nfunction setConstantAttributes(vertexArray, gl) {\n  const attributes = vertexArray._attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    if (attribute.enabled && defined(attribute.value)) {\n      attribute.vertexAttrib(gl);\n    }\n  }\n}\n\nVertexArray.prototype._bind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(this._vao);\n    if (this._context.instancedArrays) {\n      setVertexAttribDivisor(this);\n    }\n    if (this._hasConstantAttributes) {\n      setConstantAttributes(this, this._gl);\n    }\n  } else {\n    bind(this._gl, this._attributes, this._indexBuffer);\n  }\n};\n\nVertexArray.prototype._unBind = function () {\n  if (defined(this._vao)) {\n    this._context.glBindVertexArray(null);\n  } else {\n    const attributes = this._attributes;\n    const gl = this._gl;\n\n    for (let i = 0; i < attributes.length; ++i) {\n      const attribute = attributes[i];\n      if (attribute.enabled) {\n        attribute.disableVertexAttribArray(gl);\n      }\n    }\n    if (this._indexBuffer) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n  }\n};\n\nVertexArray.prototype.isDestroyed = function () {\n  return false;\n};\n\nVertexArray.prototype.destroy = function () {\n  const attributes = this._attributes;\n  for (let i = 0; i < attributes.length; ++i) {\n    const vertexBuffer = attributes[i].vertexBuffer;\n    if (\n      defined(vertexBuffer) &&\n      !vertexBuffer.isDestroyed() &&\n      vertexBuffer.vertexArrayDestroyable\n    ) {\n      vertexBuffer.destroy();\n    }\n  }\n\n  const indexBuffer = this._indexBuffer;\n  if (\n    defined(indexBuffer) &&\n    !indexBuffer.isDestroyed() &&\n    indexBuffer.vertexArrayDestroyable\n  ) {\n    indexBuffer.destroy();\n  }\n\n  if (defined(this._vao)) {\n    this._context.glDeleteVertexArray(this._vao);\n  }\n\n  return destroyObject(this);\n};\nexport default VertexArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}