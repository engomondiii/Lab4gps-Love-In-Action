{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useLocationInfo.js\nimport { useState, useEffect, useRef } from 'react';\nimport { debounce } from 'lodash';\n\n/**\n * Custom hook to manage location information based on Cesium camera movements.\n *\n * @param {Cesium.Viewer} viewer - The Cesium Viewer instance.\n * @param {object} Cesium - The Cesium library accessed via window.Cesium.\n * @param {Function} reverseGeocode - Function to perform reverse geocoding.\n * @param {string} language - Language code ('en' for English, 'ko' for Korean).\n * @returns {Object} - Contains locationInfo, loading, and error states.\n */\nconst useLocationInfo = (viewer, Cesium, reverseGeocode, language = 'en') => {\n  _s();\n  // State to store location information\n  const [locationInfo, setLocationInfo] = useState(null);\n  // State to manage loading status\n  const [loading, setLoading] = useState(false);\n  // State to manage error messages\n  const [error, setError] = useState(null);\n  // Ref to store the debounced handler\n  const handleCameraMoveEnd = useRef(null);\n  useEffect(() => {\n    // If any of the required dependencies are missing, exit early\n    if (!viewer || !Cesium || !reverseGeocode) return;\n\n    /**\n     * Debounced function to handle camera movements.\n     * This prevents excessive API calls during rapid camera movements.\n     */\n    handleCameraMoveEnd.current = debounce(async () => {\n      var _viewer$scene, _viewer$scene$globe;\n      setLoading(true); // Start loading\n      setError(null); // Reset any previous errors\n\n      const camera = viewer.camera;\n      const ellipsoid = (_viewer$scene = viewer.scene) === null || _viewer$scene === void 0 ? void 0 : (_viewer$scene$globe = _viewer$scene.globe) === null || _viewer$scene$globe === void 0 ? void 0 : _viewer$scene$globe.ellipsoid;\n\n      // Safety checks to ensure camera and ellipsoid are defined\n      if (!camera || !ellipsoid) {\n        console.error('Camera or ellipsoid is not defined.');\n        setError('Camera or ellipsoid not available');\n        setLocationInfo({\n          longitude: 'Unknown',\n          latitude: 'Unknown',\n          height: 'Unknown',\n          zoomLevel: 'Unknown',\n          address: 'Unknown'\n        });\n        setLoading(false);\n        return;\n      }\n      try {\n        // Get the current camera position in cartesian coordinates\n        const cartesian = camera.positionWC;\n        if (!cartesian) {\n          console.error('Camera position is undefined.');\n          setError('Camera position not available');\n          setLocationInfo({\n            longitude: 'Unknown',\n            latitude: 'Unknown',\n            height: 'Unknown',\n            zoomLevel: 'Unknown',\n            address: 'Unknown'\n          });\n          setLoading(false);\n          return;\n        }\n\n        // Convert cartesian coordinates to cartographic (longitude, latitude, height)\n        const cartographic = Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\n        if (!cartographic) {\n          console.error('Failed to convert cartesian to cartographic.');\n          setError('Conversion error');\n          setLocationInfo({\n            longitude: 'Unknown',\n            latitude: 'Unknown',\n            height: 'Unknown',\n            zoomLevel: 'Unknown',\n            address: 'Unknown'\n          });\n          setLoading(false);\n          return;\n        }\n\n        // Convert radians to degrees and format to fixed decimal places\n        const longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);\n        const latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);\n        const height = cartographic.height.toFixed(2); // Height in meters\n\n        // Determine zoom level based on height\n        let zoomLevel;\n        if (height < 1000) {\n          zoomLevel = 'Very High';\n        } else if (height < 5000) {\n          zoomLevel = 'High';\n        } else if (height < 20000) {\n          zoomLevel = 'Medium';\n        } else {\n          zoomLevel = 'Low';\n        }\n\n        // Perform reverse geocoding to get the address in the desired language\n        const address = await reverseGeocode(latitude, longitude, language);\n\n        // Update the location information state\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address\n        });\n      } catch (err) {\n        // Handle any errors during the reverse geocoding process\n        console.error('Reverse geocoding failed:', err);\n        setError('Failed to fetch address');\n        setLocationInfo({\n          longitude: 'Unknown',\n          latitude: 'Unknown',\n          height: 'Unknown',\n          zoomLevel: 'Unknown',\n          address: 'Unknown'\n        });\n      } finally {\n        setLoading(false); // Stop loading\n      }\n    }, 500); // 500ms debounce delay to optimize performance\n\n    // Attach the debounced handler to the camera's moveEnd event\n    viewer.camera.moveEnd.addEventListener(handleCameraMoveEnd.current);\n\n    // Trigger an initial fetch of location information\n    handleCameraMoveEnd.current();\n\n    // Cleanup function to remove event listeners and cancel debounced functions on unmount\n    return () => {\n      viewer.camera.moveEnd.removeEventListener(handleCameraMoveEnd.current);\n      handleCameraMoveEnd.current.cancel();\n    };\n  }, [viewer, Cesium, reverseGeocode, language]); // Re-run the effect if any dependencies change\n\n  // Return the location information, loading status, and any errors\n  return {\n    locationInfo,\n    loading,\n    error\n  };\n};\n_s(useLocationInfo, \"pjkE1rAieKkE75zQ/1wW42NMt+A=\");\nexport default useLocationInfo;","map":{"version":3,"names":["useState","useEffect","useRef","debounce","useLocationInfo","viewer","Cesium","reverseGeocode","language","_s","locationInfo","setLocationInfo","loading","setLoading","error","setError","handleCameraMoveEnd","current","_viewer$scene","_viewer$scene$globe","camera","ellipsoid","scene","globe","console","longitude","latitude","height","zoomLevel","address","cartesian","positionWC","cartographic","Cartographic","fromCartesian","Math","toDegrees","toFixed","err","moveEnd","addEventListener","removeEventListener","cancel"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/src/components/hooks/useLocationInfo.js"],"sourcesContent":["// src/hooks/useLocationInfo.js\nimport { useState, useEffect, useRef } from 'react';\nimport { debounce } from 'lodash';\n\n/**\n * Custom hook to manage location information based on Cesium camera movements.\n *\n * @param {Cesium.Viewer} viewer - The Cesium Viewer instance.\n * @param {object} Cesium - The Cesium library accessed via window.Cesium.\n * @param {Function} reverseGeocode - Function to perform reverse geocoding.\n * @param {string} language - Language code ('en' for English, 'ko' for Korean).\n * @returns {Object} - Contains locationInfo, loading, and error states.\n */\nconst useLocationInfo = (viewer, Cesium, reverseGeocode, language = 'en') => {\n  // State to store location information\n  const [locationInfo, setLocationInfo] = useState(null);\n  // State to manage loading status\n  const [loading, setLoading] = useState(false);\n  // State to manage error messages\n  const [error, setError] = useState(null);\n  // Ref to store the debounced handler\n  const handleCameraMoveEnd = useRef(null);\n\n  useEffect(() => {\n    // If any of the required dependencies are missing, exit early\n    if (!viewer || !Cesium || !reverseGeocode) return;\n\n    /**\n     * Debounced function to handle camera movements.\n     * This prevents excessive API calls during rapid camera movements.\n     */\n    handleCameraMoveEnd.current = debounce(async () => {\n      setLoading(true);   // Start loading\n      setError(null);     // Reset any previous errors\n\n      const camera = viewer.camera;\n      const ellipsoid = viewer.scene?.globe?.ellipsoid;\n\n      // Safety checks to ensure camera and ellipsoid are defined\n      if (!camera || !ellipsoid) {\n        console.error('Camera or ellipsoid is not defined.');\n        setError('Camera or ellipsoid not available');\n        setLocationInfo({\n          longitude: 'Unknown',\n          latitude: 'Unknown',\n          height: 'Unknown',\n          zoomLevel: 'Unknown',\n          address: 'Unknown',\n        });\n        setLoading(false);\n        return;\n      }\n\n      try {\n        // Get the current camera position in cartesian coordinates\n        const cartesian = camera.positionWC;\n\n        if (!cartesian) {\n          console.error('Camera position is undefined.');\n          setError('Camera position not available');\n          setLocationInfo({\n            longitude: 'Unknown',\n            latitude: 'Unknown',\n            height: 'Unknown',\n            zoomLevel: 'Unknown',\n            address: 'Unknown',\n          });\n          setLoading(false);\n          return;\n        }\n\n        // Convert cartesian coordinates to cartographic (longitude, latitude, height)\n        const cartographic = Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\n\n        if (!cartographic) {\n          console.error('Failed to convert cartesian to cartographic.');\n          setError('Conversion error');\n          setLocationInfo({\n            longitude: 'Unknown',\n            latitude: 'Unknown',\n            height: 'Unknown',\n            zoomLevel: 'Unknown',\n            address: 'Unknown',\n          });\n          setLoading(false);\n          return;\n        }\n\n        // Convert radians to degrees and format to fixed decimal places\n        const longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);\n        const latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);\n        const height = cartographic.height.toFixed(2); // Height in meters\n\n        // Determine zoom level based on height\n        let zoomLevel;\n        if (height < 1000) {\n          zoomLevel = 'Very High';\n        } else if (height < 5000) {\n          zoomLevel = 'High';\n        } else if (height < 20000) {\n          zoomLevel = 'Medium';\n        } else {\n          zoomLevel = 'Low';\n        }\n\n        // Perform reverse geocoding to get the address in the desired language\n        const address = await reverseGeocode(latitude, longitude, language);\n\n        // Update the location information state\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address,\n        });\n      } catch (err) {\n        // Handle any errors during the reverse geocoding process\n        console.error('Reverse geocoding failed:', err);\n        setError('Failed to fetch address');\n        setLocationInfo({\n          longitude: 'Unknown',\n          latitude: 'Unknown',\n          height: 'Unknown',\n          zoomLevel: 'Unknown',\n          address: 'Unknown',\n        });\n      } finally {\n        setLoading(false); // Stop loading\n      }\n    }, 500); // 500ms debounce delay to optimize performance\n\n    // Attach the debounced handler to the camera's moveEnd event\n    viewer.camera.moveEnd.addEventListener(handleCameraMoveEnd.current);\n\n    // Trigger an initial fetch of location information\n    handleCameraMoveEnd.current();\n\n    // Cleanup function to remove event listeners and cancel debounced functions on unmount\n    return () => {\n      viewer.camera.moveEnd.removeEventListener(handleCameraMoveEnd.current);\n      handleCameraMoveEnd.current.cancel();\n    };\n  }, [viewer, Cesium, reverseGeocode, language]); // Re-run the effect if any dependencies change\n\n  // Return the location information, loading status, and any errors\n  return { locationInfo, loading, error };\n};\n\nexport default useLocationInfo;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}