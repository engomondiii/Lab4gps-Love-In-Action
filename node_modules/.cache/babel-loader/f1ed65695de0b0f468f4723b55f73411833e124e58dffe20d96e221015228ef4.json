{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, Intersections,\\n\\\n// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection,\\n\\\n// intersectIntersections\\n\\\n// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,\\n\\\n// intersectFlippedWedge, intersectRegularWedge\\n\\\n\\n\\\n/* Cylinder defines (set in Scene/VoxelCylinderShape.js)\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\\n\\\n\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\\n\\\n#define CYLINDER_INTERSECTION_INDEX_ANGLE\\n\\\n*/\\n\\\n\\n\\\n// Cylinder uniforms\\n\\\nuniform vec2 u_cylinderRenderRadiusMinMax;\\n\\\nuniform vec2 u_cylinderRenderHeightMinMax;\\n\\\n#if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE)\\n\\\n    uniform vec2 u_cylinderRenderAngleMinMax;\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with the volume defined by two planes of constant z\\n\\\n */\\n\\\nRayShapeIntersection intersectHeightBounds(in Ray ray, in vec2 minMaxHeight, in bool convex)\\n\\\n{\\n\\\n    float zPosition = ray.pos.z;\\n\\\n    float zDirection = ray.dir.z;\\n\\\n\\n\\\n    float tmin = (minMaxHeight.x - zPosition) / zDirection;\\n\\\n    float tmax = (minMaxHeight.y - zPosition) / zDirection;\\n\\\n\\n\\\n    // Normals point outside the volume\\n\\\n    float signFlip = convex ? 1.0 : -1.0;\\n\\\n    vec4 intersectMin = vec4(0.0, 0.0, -1.0 * signFlip, tmin);\\n\\\n    vec4 intersectMax = vec4(0.0, 0.0, 1.0 * signFlip, tmax);\\n\\\n\\n\\\n    bool topEntry = zDirection < 0.0;\\n\\\n    vec4 entry = topEntry ? intersectMax : intersectMin;\\n\\\n    vec4 exit = topEntry ? intersectMin : intersectMax;\\n\\\n\\n\\\n    return RayShapeIntersection(entry, exit);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical surface of a given radius\\n\\\n * about the z-axis.\\n\\\n */\\n\\\nRayShapeIntersection intersectCylinder(in Ray ray, in float radius, in bool convex)\\n\\\n{\\n\\\n    vec2 position = ray.pos.xy;\\n\\\n    vec2 direction = ray.dir.xy;\\n\\\n\\n\\\n    float a = dot(direction, direction);\\n\\\n    float b = dot(position, direction);\\n\\\n    float c = dot(position, position) - radius * radius;\\n\\\n    float determinant = b * b - a * c;\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n    float t1 = (-b - determinant) / a;\\n\\\n    float t2 = (-b + determinant) / a;\\n\\\n    float signFlip = convex ? 1.0 : -1.0;\\n\\\n    vec4 intersect1 = vec4(normalize(position + t1 * direction) * signFlip, 0.0, t1);\\n\\\n    vec4 intersect2 = vec4(normalize(position + t2 * direction) * signFlip, 0.0, t2);\\n\\\n\\n\\\n    return RayShapeIntersection(intersect1, intersect2);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical solid of given\\n\\\n * radius and height bounds. NOTE: The shape is assumed to be convex.\\n\\\n */\\n\\\nRayShapeIntersection intersectBoundedCylinder(in Ray ray, in float radius, in vec2 minMaxHeight)\\n\\\n{\\n\\\n    RayShapeIntersection cylinderIntersection = intersectCylinder(ray, radius, true);\\n\\\n    RayShapeIntersection heightBoundsIntersection = intersectHeightBounds(ray, minMaxHeight, true);\\n\\\n    return intersectIntersections(ray, cylinderIntersection, heightBoundsIntersection);\\n\\\n}\\n\\\n\\n\\\nvoid intersectShape(Ray ray, inout Intersections ix)\\n\\\n{\\n\\\n    // Position is converted from [0,1] to [-1,+1] because shape intersections assume unit space is [-1,+1].\\n\\\n    // Direction is scaled as well to be in sync with position.\\n\\\n    ray.pos = ray.pos * 2.0 - 1.0;\\n\\\n    ray.dir *= 2.0;\\n\\\n\\n\\\n    RayShapeIntersection outerIntersect = intersectBoundedCylinder(ray, u_cylinderRenderRadiusMinMax.y, u_cylinderRenderHeightMinMax);\\n\\\n\\n\\\n    setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MAX, outerIntersect);\\n\\\n\\n\\\n    if (outerIntersect.entry.w == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT)\\n\\\n        // When the cylinder is perfectly thin it's necessary to sandwich the\\n\\\n        // inner cylinder intersection inside the outer cylinder intersection.\\n\\\n\\n\\\n        // Without this special case,\\n\\\n        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, outerMax, innerMax] which will cause the back\\n\\\n        // side of the cylinder to be invisible because it will think the ray\\n\\\n        // is still inside the inner (negative) cylinder after exiting the\\n\\\n        // outer (positive) cylinder.\\n\\\n\\n\\\n        // With this special case,\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.\\n\\\n\\n\\\n        // Note: If initializeIntersections() changes its sorting function\\n\\\n        // from bubble sort to something else, this code may need to change.\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, 1.0, false);\\n\\\n        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter\\n\\\n        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter\\n\\\n        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit\\n\\\n        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN)\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, u_cylinderRenderRadiusMinMax.x, false);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MIN, innerIntersect);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_cylinderRenderAngleMinMax);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE, wedgeIntersect);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectFlippedWedge(ray, u_cylinderRenderAngleMinMax, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectHalfPlane(ray, u_cylinderRenderAngleMinMax.x, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/IntersectCylinder.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, Intersections,\\n\\\n// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection,\\n\\\n// intersectIntersections\\n\\\n// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,\\n\\\n// intersectFlippedWedge, intersectRegularWedge\\n\\\n\\n\\\n/* Cylinder defines (set in Scene/VoxelCylinderShape.js)\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\\n\\\n\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\\n\\\n#define CYLINDER_INTERSECTION_INDEX_ANGLE\\n\\\n*/\\n\\\n\\n\\\n// Cylinder uniforms\\n\\\nuniform vec2 u_cylinderRenderRadiusMinMax;\\n\\\nuniform vec2 u_cylinderRenderHeightMinMax;\\n\\\n#if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE)\\n\\\n    uniform vec2 u_cylinderRenderAngleMinMax;\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with the volume defined by two planes of constant z\\n\\\n */\\n\\\nRayShapeIntersection intersectHeightBounds(in Ray ray, in vec2 minMaxHeight, in bool convex)\\n\\\n{\\n\\\n    float zPosition = ray.pos.z;\\n\\\n    float zDirection = ray.dir.z;\\n\\\n\\n\\\n    float tmin = (minMaxHeight.x - zPosition) / zDirection;\\n\\\n    float tmax = (minMaxHeight.y - zPosition) / zDirection;\\n\\\n\\n\\\n    // Normals point outside the volume\\n\\\n    float signFlip = convex ? 1.0 : -1.0;\\n\\\n    vec4 intersectMin = vec4(0.0, 0.0, -1.0 * signFlip, tmin);\\n\\\n    vec4 intersectMax = vec4(0.0, 0.0, 1.0 * signFlip, tmax);\\n\\\n\\n\\\n    bool topEntry = zDirection < 0.0;\\n\\\n    vec4 entry = topEntry ? intersectMax : intersectMin;\\n\\\n    vec4 exit = topEntry ? intersectMin : intersectMax;\\n\\\n\\n\\\n    return RayShapeIntersection(entry, exit);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical surface of a given radius\\n\\\n * about the z-axis.\\n\\\n */\\n\\\nRayShapeIntersection intersectCylinder(in Ray ray, in float radius, in bool convex)\\n\\\n{\\n\\\n    vec2 position = ray.pos.xy;\\n\\\n    vec2 direction = ray.dir.xy;\\n\\\n\\n\\\n    float a = dot(direction, direction);\\n\\\n    float b = dot(position, direction);\\n\\\n    float c = dot(position, position) - radius * radius;\\n\\\n    float determinant = b * b - a * c;\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n    float t1 = (-b - determinant) / a;\\n\\\n    float t2 = (-b + determinant) / a;\\n\\\n    float signFlip = convex ? 1.0 : -1.0;\\n\\\n    vec4 intersect1 = vec4(normalize(position + t1 * direction) * signFlip, 0.0, t1);\\n\\\n    vec4 intersect2 = vec4(normalize(position + t2 * direction) * signFlip, 0.0, t2);\\n\\\n\\n\\\n    return RayShapeIntersection(intersect1, intersect2);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical solid of given\\n\\\n * radius and height bounds. NOTE: The shape is assumed to be convex.\\n\\\n */\\n\\\nRayShapeIntersection intersectBoundedCylinder(in Ray ray, in float radius, in vec2 minMaxHeight)\\n\\\n{\\n\\\n    RayShapeIntersection cylinderIntersection = intersectCylinder(ray, radius, true);\\n\\\n    RayShapeIntersection heightBoundsIntersection = intersectHeightBounds(ray, minMaxHeight, true);\\n\\\n    return intersectIntersections(ray, cylinderIntersection, heightBoundsIntersection);\\n\\\n}\\n\\\n\\n\\\nvoid intersectShape(Ray ray, inout Intersections ix)\\n\\\n{\\n\\\n    // Position is converted from [0,1] to [-1,+1] because shape intersections assume unit space is [-1,+1].\\n\\\n    // Direction is scaled as well to be in sync with position.\\n\\\n    ray.pos = ray.pos * 2.0 - 1.0;\\n\\\n    ray.dir *= 2.0;\\n\\\n\\n\\\n    RayShapeIntersection outerIntersect = intersectBoundedCylinder(ray, u_cylinderRenderRadiusMinMax.y, u_cylinderRenderHeightMinMax);\\n\\\n\\n\\\n    setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MAX, outerIntersect);\\n\\\n\\n\\\n    if (outerIntersect.entry.w == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT)\\n\\\n        // When the cylinder is perfectly thin it's necessary to sandwich the\\n\\\n        // inner cylinder intersection inside the outer cylinder intersection.\\n\\\n\\n\\\n        // Without this special case,\\n\\\n        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, outerMax, innerMax] which will cause the back\\n\\\n        // side of the cylinder to be invisible because it will think the ray\\n\\\n        // is still inside the inner (negative) cylinder after exiting the\\n\\\n        // outer (positive) cylinder.\\n\\\n\\n\\\n        // With this special case,\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.\\n\\\n\\n\\\n        // Note: If initializeIntersections() changes its sorting function\\n\\\n        // from bubble sort to something else, this code may need to change.\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, 1.0, false);\\n\\\n        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter\\n\\\n        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter\\n\\\n        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit\\n\\\n        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN)\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, u_cylinderRenderRadiusMinMax.x, false);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MIN, innerIntersect);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_cylinderRenderAngleMinMax);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE, wedgeIntersect);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectFlippedWedge(ray, u_cylinderRenderAngleMinMax, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectHalfPlane(ray, u_cylinderRenderAngleMinMax.x, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}