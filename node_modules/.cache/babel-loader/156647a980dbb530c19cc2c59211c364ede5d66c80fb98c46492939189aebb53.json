{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"/**\\n\\\n * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as\\n\\\n * the transmittance value for the ray. This function uses automatic uniforms\\n\\\n * so the atmosphere settings are always synced with the current scene.\\n\\\n *\\n\\\n * @name czm_computeScattering\\n\\\n * @glslfunction\\n\\\n *\\n\\\n * @param {czm_ray} primaryRay The ray from the camera to the position.\\n\\\n * @param {float} primaryRayLength The length of the primary ray.\\n\\\n * @param {vec3} lightDirection The direction of the light to calculate the scattering from.\\n\\\n * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to.\\n\\\n * @param {vec3} mieColor The variable the Mie scattering will be written to.\\n\\\n * @param {float} opacity The variable the transmittance will be written to.\\n\\\n */\\n\\\nvoid czm_computeScattering(\\n\\\n    czm_ray primaryRay,\\n\\\n    float primaryRayLength,\\n\\\n    vec3 lightDirection,\\n\\\n    float atmosphereInnerRadius,\\n\\\n    out vec3 rayleighColor,\\n\\\n    out vec3 mieColor,\\n\\\n    out float opacity\\n\\\n) {\\n\\\n    const float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters.\\n\\\n    const int PRIMARY_STEPS_MAX = 16; // Maximum number of times the ray from the camera to the world position (primary ray) is sampled.\\n\\\n    const int LIGHT_STEPS_MAX = 4; // Maximum number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\\n\\\n\\n\\\n    // Initialize the default scattering amounts to 0.\\n\\\n    rayleighColor = vec3(0.0);\\n\\\n    mieColor = vec3(0.0);\\n\\\n    opacity = 0.0;\\n\\\n\\n\\\n    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;\\n\\\n\\n\\\n    vec3 origin = vec3(0.0);\\n\\\n\\n\\\n    // Calculate intersection from the camera to the outer ring of the atmosphere.\\n\\\n    czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius);\\n\\\n\\n\\\n    // Return empty colors if no intersection with the atmosphere geometry.\\n\\\n    if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    // To deal with smaller values of PRIMARY_STEPS (e.g. 4)\\n\\\n    // we implement a split strategy: sky or horizon.\\n\\\n    // For performance reasons, instead of a if/else branch\\n\\\n    // a soft choice is implemented through a weight 0.0 <= w_stop_gt_lprl <= 1.0\\n\\\n    float x = 1e-7 * primaryRayAtmosphereIntersect.stop / length(primaryRayLength);\\n\\\n    // Value close to 0.0: close to the horizon\\n\\\n    // Value close to 1.0: above in the sky\\n\\\n    float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x));\\n\\\n\\n\\\n    // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere.\\n\\\n    float start_0 = primaryRayAtmosphereIntersect.start;\\n\\\n    primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0);\\n\\\n    // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller.\\n\\\n    primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength));\\n\\\n\\n\\\n    // For the number of ray steps, distinguish inside or outside atmosphere (outer space)\\n\\\n    // (1) from outer space we have to use more ray steps to get a realistic rendering\\n\\\n    // (2) within atmosphere we need fewer steps for faster rendering\\n\\\n    float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters\\n\\\n    float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a));\\n\\\n    int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled.\\n\\\n    int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\\n\\\n\\n\\\n    // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere.\\n\\\n    float rayPositionLength = primaryRayAtmosphereIntersect.start;\\n\\\n    // (1) Outside the atmosphere: constant rayStepLength\\n\\\n    // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps\\n\\\n    float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength;\\n\\\n    float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0));\\n\\\n    float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS));\\n\\\n\\n\\\n    vec3 rayleighAccumulation = vec3(0.0);\\n\\\n    vec3 mieAccumulation = vec3(0.0);\\n\\\n    vec2 opticalDepth = vec2(0.0);\\n\\\n    vec2 heightScale = vec2(czm_atmosphereRayleighScaleHeight, czm_atmosphereMieScaleHeight);\\n\\\n\\n\\\n    // Sample positions on the primary ray.\\n\\\n    for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) {\\n\\\n\\n\\\n        // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot\\n\\\n        // loop with non-constant condition, so it has to break early instead\\n\\\n        if (i >= PRIMARY_STEPS) {\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        // Calculate sample position along viewpoint ray.\\n\\\n        vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength);\\n\\\n\\n\\\n        // Calculate height of sample position above ellipsoid.\\n\\\n        float sampleHeight = length(samplePosition) - atmosphereInnerRadius;\\n\\\n\\n\\\n        // Calculate and accumulate density of particles at the sample position.\\n\\\n        vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength;\\n\\\n        opticalDepth += sampleDensity;\\n\\\n\\n\\\n        // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere.\\n\\\n        czm_ray lightRay = czm_ray(samplePosition, lightDirection);\\n\\\n        czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius);\\n\\\n\\n\\\n        float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS);\\n\\\n        float lightPositionLength = 0.0;\\n\\\n\\n\\\n        vec2 lightOpticalDepth = vec2(0.0);\\n\\\n\\n\\\n        // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment.\\n\\\n        for (int j = 0; j < LIGHT_STEPS_MAX; ++j) {\\n\\\n\\n\\\n            // The loop should be: for (int j = 0; i < LIGHT_STEPS; ++j) {...} but WebGL1 cannot\\n\\\n            // loop with non-constant condition, so it has to break early instead\\n\\\n            if (j >= LIGHT_STEPS) {\\n\\\n                break;\\n\\\n            }\\n\\\n\\n\\\n            // Calculate sample position along light ray.\\n\\\n            vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5);\\n\\\n\\n\\\n            // Calculate height of the light sample position above ellipsoid.\\n\\\n            float lightHeight = length(lightPosition) - atmosphereInnerRadius;\\n\\\n\\n\\\n            // Calculate density of photons at the light sample position.\\n\\\n            lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength;\\n\\\n\\n\\\n            // Increment distance on light ray.\\n\\\n            lightPositionLength += lightStepLength;\\n\\\n        }\\n\\\n\\n\\\n        // Compute attenuation via the primary ray and the light ray.\\n\\\n        vec3 attenuation = exp(-((czm_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (czm_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x))));\\n\\\n\\n\\\n        // Accumulate the scattering.\\n\\\n        rayleighAccumulation += sampleDensity.x * attenuation;\\n\\\n        mieAccumulation += sampleDensity.y * attenuation;\\n\\\n\\n\\\n        // Increment distance on primary ray.\\n\\\n        rayPositionLength += (rayStepLength += rayStepLengthIncrease);\\n\\\n    }\\n\\\n\\n\\\n    // Compute the scattering amount.\\n\\\n    rayleighColor = czm_atmosphereRayleighCoefficient * rayleighAccumulation;\\n\\\n    mieColor = czm_atmosphereMieCoefficient * mieAccumulation;\\n\\\n\\n\\\n    // Compute the transmittance i.e. how much light is passing through the atmosphere.\\n\\\n    opacity = length(exp(-((czm_atmosphereMieCoefficient * opticalDepth.y) + (czm_atmosphereRayleighCoefficient * opticalDepth.x))));\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Builtin/Functions/computeScattering.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"/**\\n\\\n * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as\\n\\\n * the transmittance value for the ray. This function uses automatic uniforms\\n\\\n * so the atmosphere settings are always synced with the current scene.\\n\\\n *\\n\\\n * @name czm_computeScattering\\n\\\n * @glslfunction\\n\\\n *\\n\\\n * @param {czm_ray} primaryRay The ray from the camera to the position.\\n\\\n * @param {float} primaryRayLength The length of the primary ray.\\n\\\n * @param {vec3} lightDirection The direction of the light to calculate the scattering from.\\n\\\n * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to.\\n\\\n * @param {vec3} mieColor The variable the Mie scattering will be written to.\\n\\\n * @param {float} opacity The variable the transmittance will be written to.\\n\\\n */\\n\\\nvoid czm_computeScattering(\\n\\\n    czm_ray primaryRay,\\n\\\n    float primaryRayLength,\\n\\\n    vec3 lightDirection,\\n\\\n    float atmosphereInnerRadius,\\n\\\n    out vec3 rayleighColor,\\n\\\n    out vec3 mieColor,\\n\\\n    out float opacity\\n\\\n) {\\n\\\n    const float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters.\\n\\\n    const int PRIMARY_STEPS_MAX = 16; // Maximum number of times the ray from the camera to the world position (primary ray) is sampled.\\n\\\n    const int LIGHT_STEPS_MAX = 4; // Maximum number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\\n\\\n\\n\\\n    // Initialize the default scattering amounts to 0.\\n\\\n    rayleighColor = vec3(0.0);\\n\\\n    mieColor = vec3(0.0);\\n\\\n    opacity = 0.0;\\n\\\n\\n\\\n    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;\\n\\\n\\n\\\n    vec3 origin = vec3(0.0);\\n\\\n\\n\\\n    // Calculate intersection from the camera to the outer ring of the atmosphere.\\n\\\n    czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius);\\n\\\n\\n\\\n    // Return empty colors if no intersection with the atmosphere geometry.\\n\\\n    if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    // To deal with smaller values of PRIMARY_STEPS (e.g. 4)\\n\\\n    // we implement a split strategy: sky or horizon.\\n\\\n    // For performance reasons, instead of a if/else branch\\n\\\n    // a soft choice is implemented through a weight 0.0 <= w_stop_gt_lprl <= 1.0\\n\\\n    float x = 1e-7 * primaryRayAtmosphereIntersect.stop / length(primaryRayLength);\\n\\\n    // Value close to 0.0: close to the horizon\\n\\\n    // Value close to 1.0: above in the sky\\n\\\n    float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x));\\n\\\n\\n\\\n    // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere.\\n\\\n    float start_0 = primaryRayAtmosphereIntersect.start;\\n\\\n    primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0);\\n\\\n    // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller.\\n\\\n    primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength));\\n\\\n\\n\\\n    // For the number of ray steps, distinguish inside or outside atmosphere (outer space)\\n\\\n    // (1) from outer space we have to use more ray steps to get a realistic rendering\\n\\\n    // (2) within atmosphere we need fewer steps for faster rendering\\n\\\n    float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters\\n\\\n    float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a));\\n\\\n    int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled.\\n\\\n    int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\\n\\\n\\n\\\n    // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere.\\n\\\n    float rayPositionLength = primaryRayAtmosphereIntersect.start;\\n\\\n    // (1) Outside the atmosphere: constant rayStepLength\\n\\\n    // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps\\n\\\n    float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength;\\n\\\n    float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0));\\n\\\n    float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS));\\n\\\n\\n\\\n    vec3 rayleighAccumulation = vec3(0.0);\\n\\\n    vec3 mieAccumulation = vec3(0.0);\\n\\\n    vec2 opticalDepth = vec2(0.0);\\n\\\n    vec2 heightScale = vec2(czm_atmosphereRayleighScaleHeight, czm_atmosphereMieScaleHeight);\\n\\\n\\n\\\n    // Sample positions on the primary ray.\\n\\\n    for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) {\\n\\\n\\n\\\n        // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot\\n\\\n        // loop with non-constant condition, so it has to break early instead\\n\\\n        if (i >= PRIMARY_STEPS) {\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        // Calculate sample position along viewpoint ray.\\n\\\n        vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength);\\n\\\n\\n\\\n        // Calculate height of sample position above ellipsoid.\\n\\\n        float sampleHeight = length(samplePosition) - atmosphereInnerRadius;\\n\\\n\\n\\\n        // Calculate and accumulate density of particles at the sample position.\\n\\\n        vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength;\\n\\\n        opticalDepth += sampleDensity;\\n\\\n\\n\\\n        // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere.\\n\\\n        czm_ray lightRay = czm_ray(samplePosition, lightDirection);\\n\\\n        czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius);\\n\\\n\\n\\\n        float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS);\\n\\\n        float lightPositionLength = 0.0;\\n\\\n\\n\\\n        vec2 lightOpticalDepth = vec2(0.0);\\n\\\n\\n\\\n        // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment.\\n\\\n        for (int j = 0; j < LIGHT_STEPS_MAX; ++j) {\\n\\\n\\n\\\n            // The loop should be: for (int j = 0; i < LIGHT_STEPS; ++j) {...} but WebGL1 cannot\\n\\\n            // loop with non-constant condition, so it has to break early instead\\n\\\n            if (j >= LIGHT_STEPS) {\\n\\\n                break;\\n\\\n            }\\n\\\n\\n\\\n            // Calculate sample position along light ray.\\n\\\n            vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5);\\n\\\n\\n\\\n            // Calculate height of the light sample position above ellipsoid.\\n\\\n            float lightHeight = length(lightPosition) - atmosphereInnerRadius;\\n\\\n\\n\\\n            // Calculate density of photons at the light sample position.\\n\\\n            lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength;\\n\\\n\\n\\\n            // Increment distance on light ray.\\n\\\n            lightPositionLength += lightStepLength;\\n\\\n        }\\n\\\n\\n\\\n        // Compute attenuation via the primary ray and the light ray.\\n\\\n        vec3 attenuation = exp(-((czm_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (czm_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x))));\\n\\\n\\n\\\n        // Accumulate the scattering.\\n\\\n        rayleighAccumulation += sampleDensity.x * attenuation;\\n\\\n        mieAccumulation += sampleDensity.y * attenuation;\\n\\\n\\n\\\n        // Increment distance on primary ray.\\n\\\n        rayPositionLength += (rayStepLength += rayStepLengthIncrease);\\n\\\n    }\\n\\\n\\n\\\n    // Compute the scattering amount.\\n\\\n    rayleighColor = czm_atmosphereRayleighCoefficient * rayleighAccumulation;\\n\\\n    mieColor = czm_atmosphereMieCoefficient * mieAccumulation;\\n\\\n\\n\\\n    // Compute the transmittance i.e. how much light is passing through the atmosphere.\\n\\\n    opacity = length(exp(-((czm_atmosphereMieCoefficient * opticalDepth.y) + (czm_atmosphereRayleighCoefficient * opticalDepth.x))));\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}