{"ast":null,"code":"import { MetadataComponentType } from \"@cesium/engine\";\nimport defined from \"../Core/defined.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataPickingPipelineStage from \"./Model/MetadataPickingPipelineStage.js\";\n\n/**\n * @private\n */\nfunction DerivedCommand() {}\nconst fragDepthRegex = /\\bgl_FragDepth\\b/;\nconst discardRegex = /\\bdiscard\\b/;\nfunction getDepthOnlyShaderProgram(context, shaderProgram) {\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"depthOnly\");\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n  let fs = shaderProgram.fragmentShaderSource;\n  let writesDepthOrDiscards = false;\n  const sources = fs.sources;\n  for (let i = 0; i < sources.length; ++i) {\n    if (fragDepthRegex.test(sources[i]) || discardRegex.test(sources[i])) {\n      writesDepthOrDiscards = true;\n      break;\n    }\n  }\n  const usesLogDepth = fs.defines.indexOf(\"LOG_DEPTH\") >= 0;\n  if (!writesDepthOrDiscards && !usesLogDepth) {\n    const source = `void main()\n{\n    out_FragColor = vec4(1.0);\n}\n`;\n    fs = new ShaderSource({\n      sources: [source]\n    });\n  } else if (!writesDepthOrDiscards && usesLogDepth) {\n    const source = `void main()\n{\n    out_FragColor = vec4(1.0);\n    czm_writeLogDepth();\n}\n`;\n    fs = new ShaderSource({\n      defines: [\"LOG_DEPTH\"],\n      sources: [source]\n    });\n  }\n  return context.shaderCache.createDerivedShaderProgram(shaderProgram, \"depthOnly\", {\n    vertexShaderSource: shaderProgram.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: shaderProgram._attributeLocations\n  });\n}\nfunction getDepthOnlyRenderState(scene, renderState) {\n  const cache = scene._depthOnlyRenderStateCache;\n  const cachedDepthOnlyState = cache[renderState.id];\n  if (defined(cachedDepthOnlyState)) {\n    return cachedDepthOnlyState;\n  }\n  const rs = RenderState.getState(renderState);\n  rs.depthMask = true;\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n  const depthOnlyState = RenderState.fromCache(rs);\n  cache[renderState.id] = depthOnlyState;\n  return depthOnlyState;\n}\nDerivedCommand.createDepthOnlyDerivedCommand = function (scene, command, context, result) {\n  // For a depth only pass, we bind a framebuffer with only a depth attachment (no color attachments),\n  // do not write color, and write depth. If the fragment shader doesn't modify the fragment depth\n  // or discard, the driver can replace the fragment shader with a pass-through shader. We're unsure if this\n  // actually happens so we modify the shader to use a pass-through fragment shader.\n\n  if (!defined(result)) {\n    result = {};\n  }\n  const shader = result.depthOnlyCommand?.shaderProgram;\n  const renderState = result.depthOnlyCommand?.renderState;\n  result.depthOnlyCommand = DrawCommand.shallowClone(command, result.depthOnlyCommand);\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.depthOnlyCommand.shaderProgram = getDepthOnlyShaderProgram(context, command.shaderProgram);\n    result.depthOnlyCommand.renderState = getDepthOnlyRenderState(scene, command.renderState);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.depthOnlyCommand.shaderProgram = shader;\n    result.depthOnlyCommand.renderState = renderState;\n  }\n  return result;\n};\nconst writeLogDepthRegex = /\\s+czm_writeLogDepth\\(/;\nconst vertexlogDepthRegex = /\\s+czm_vertexLogDepth\\(/;\nfunction getLogDepthShaderProgram(context, shaderProgram) {\n  const disableLogDepthWrite = shaderProgram.fragmentShaderSource.defines.indexOf(\"LOG_DEPTH_READ_ONLY\") >= 0;\n  if (disableLogDepthWrite) {\n    return shaderProgram;\n  }\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"logDepth\");\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n  const attributeLocations = shaderProgram._attributeLocations;\n  const vs = shaderProgram.vertexShaderSource.clone();\n  const fs = shaderProgram.fragmentShaderSource.clone();\n  vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n  vs.defines.push(\"LOG_DEPTH\");\n  fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n  fs.defines.push(\"LOG_DEPTH\");\n  let writesLogDepth = false;\n  let sources = vs.sources;\n  for (let i = 0; i < sources.length; ++i) {\n    if (vertexlogDepthRegex.test(sources[i])) {\n      writesLogDepth = true;\n      break;\n    }\n  }\n  if (!writesLogDepth) {\n    for (let i = 0; i < sources.length; ++i) {\n      sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n    }\n    const logMain = `\n\nvoid main()\n{\n    czm_log_depth_main();\n    czm_vertexLogDepth();\n}\n`;\n    sources.push(logMain);\n  }\n  sources = fs.sources;\n  writesLogDepth = false;\n  for (let i = 0; i < sources.length; ++i) {\n    if (writeLogDepthRegex.test(sources[i])) {\n      writesLogDepth = true;\n    }\n  }\n  // This define indicates that a log depth value is written by the shader but doesn't use czm_writeLogDepth.\n  if (fs.defines.indexOf(\"LOG_DEPTH_WRITE\") !== -1) {\n    writesLogDepth = true;\n  }\n  let logSource = \"\";\n  if (!writesLogDepth) {\n    for (let i = 0; i < sources.length; i++) {\n      sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n    }\n    logSource = `\nvoid main()\n{\n    czm_log_depth_main();\n    czm_writeLogDepth();\n}\n`;\n  }\n  sources.push(logSource);\n  return context.shaderCache.createDerivedShaderProgram(shaderProgram, \"logDepth\", {\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\nDerivedCommand.createLogDepthCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  const shader = result.command?.shaderProgram;\n  result.command = DrawCommand.shallowClone(command, result.command);\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getLogDepthShaderProgram(context, command.shaderProgram);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n  return result;\n};\nfunction getPickShaderProgram(context, shaderProgram, pickId) {\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"pick\");\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n  const attributeLocations = shaderProgram._attributeLocations;\n  const {\n    sources,\n    defines\n  } = shaderProgram.fragmentShaderSource;\n  const hasFragData = sources.some(source => source.includes(\"out_FragData\"));\n  const outputColorVariable = hasFragData ? \"out_FragData_0\" : \"out_FragColor\";\n  const newMain = `void main () \n{ \n    czm_non_pick_main(); \n    if (${outputColorVariable}.a == 0.0) { \n        discard; \n    } \n    ${outputColorVariable} = ${pickId}; \n} `;\n  const length = sources.length;\n  const newSources = new Array(length + 1);\n  for (let i = 0; i < length; ++i) {\n    newSources[i] = ShaderSource.replaceMain(sources[i], \"czm_non_pick_main\");\n  }\n  newSources[length] = newMain;\n  const fragmentShaderSource = new ShaderSource({\n    sources: newSources,\n    defines: defines\n  });\n  return context.shaderCache.createDerivedShaderProgram(shaderProgram, \"pick\", {\n    vertexShaderSource: shaderProgram.vertexShaderSource,\n    fragmentShaderSource: fragmentShaderSource,\n    attributeLocations: attributeLocations\n  });\n}\nfunction getPickRenderState(scene, renderState) {\n  const cache = scene.picking.pickRenderStateCache;\n  const cachedPickState = cache[renderState.id];\n  if (defined(cachedPickState)) {\n    return cachedPickState;\n  }\n  const rs = RenderState.getState(renderState);\n  rs.blending.enabled = false;\n\n  // Turns on depth writing for opaque and translucent passes\n  // Overlapping translucent geometry on the globe surface may exhibit z-fighting\n  // during the pick pass which may not match the rendered scene. Once\n  // terrain is on by default and ground primitives are used instead\n  // this will become less of a problem.\n  rs.depthMask = true;\n  const pickState = RenderState.fromCache(rs);\n  cache[renderState.id] = pickState;\n  return pickState;\n}\nDerivedCommand.createPickDerivedCommand = function (scene, command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  const shader = result.pickCommand?.shaderProgram;\n  const renderState = result.pickCommand?.renderState;\n  result.pickCommand = DrawCommand.shallowClone(command, result.pickCommand);\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.pickCommand.shaderProgram = getPickShaderProgram(context, command.shaderProgram, command.pickId);\n    result.pickCommand.renderState = getPickRenderState(scene, command.renderState);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.pickCommand.shaderProgram = shader;\n    result.pickCommand.renderState = renderState;\n  }\n  return result;\n};\n\n/**\n * Replaces the value of the specified 'define' directive identifier\n * with the given value.\n *\n * The given defines are the parts of the define directives that are\n * stored in the `ShaderSource`. For example, the defines may be\n * `[\"EXAMPLE\", \"EXAMPLE_VALUE 123\"]`\n *\n * Calling `replaceDefine(defines, \"EXAMPLE\", 999)` will result in\n * the defines being\n * `[\"EXAMPLE 999\", \"EXAMPLE_VALUE 123\"]`\n *\n * @param {string[]} defines The define directive identifiers\n * @param {string} defineName The name (identifier) of the define directive\n * @param {any} newDefineValue The new value whose string representation\n * will become the token string for the define directive\n * @private\n */\nfunction replaceDefine(defines, defineName, newDefineValue) {\n  const n = defines.length;\n  for (let i = 0; i < n; i++) {\n    const define = defines[i];\n    const tokens = define.trimStart().split(/\\s+/);\n    if (tokens[0] === defineName) {\n      defines[i] = `${defineName} ${newDefineValue}`;\n    }\n  }\n}\n\n/**\n * Returns the component count for the given class property, or\n * its array length if it is an array.\n *\n * This will be\n * `[1, 2, 3, 4]` for `[SCALAR, VEC2, VEC3, VEC4`] types,\n * or the array length if it is an array.\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @returns {number} The component count\n * @private\n */\nfunction getComponentCount(classProperty) {\n  if (!classProperty.isArray) {\n    return MetadataType.getComponentCount(classProperty.type);\n  }\n  return classProperty.arrayLength;\n}\n\n/**\n * Returns the type that the given class property has in a GLSL shader.\n *\n * It returns the same string as `PropertyTextureProperty.prototype.getGlslType`\n * for a property texture property with the given class property\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @returns {string} The GLSL shader type string for the property\n */\nfunction getGlslType(classProperty) {\n  const componentCount = getComponentCount(classProperty);\n  if (classProperty.normalized) {\n    if (componentCount === 1) {\n      return \"float\";\n    }\n    return `vec${componentCount}`;\n  }\n  if (componentCount === 1) {\n    return \"int\";\n  }\n  return `ivec${componentCount}`;\n}\n\n/**\n * Returns a shader statement that applies the inverse of the\n * value transform to the given value, based on the given offset\n * and scale.\n *\n * @param {string} input The input value\n * @param {string} offset The offset\n * @param {string} scale The scale\n * @returns {string} The statement\n */\nfunction unapplyValueTransform(input, offset, scale) {\n  return `((${input} - float(${offset})) / float(${scale}))`;\n}\n\n/**\n * Returns a shader statement that applies the inverse of the\n * normalization, based on the given component type\n *\n * @param {string} input The input value\n * @param {string} componentType The component type\n * @returns {string} The statement\n */\nfunction unnormalize(input, componentType) {\n  const max = MetadataComponentType.getMaximum(componentType);\n  return `(${input}) / float(${max})`;\n}\n\n/**\n * Creates a shader statement that returns the value of the specified\n * property, normalized to the range [0, 1].\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @param {object} metadataProperty The metadata property, either\n * a `PropertyTextureProperty` or a `PropertyAttributeProperty`\n * @returns {string} The string\n */\nfunction getSourceValueStringScalar(classProperty, metadataProperty) {\n  let result = `float(value)`;\n\n  // The 'hasValueTransform' indicates whether the property\n  // (or its class property) did define an 'offset' or 'scale'.\n  // Even when they had not been defined in the JSON, they are\n  // defined in the object, with default values.\n  if (metadataProperty.hasValueTransform) {\n    const offset = metadataProperty.offset;\n    const scale = metadataProperty.scale;\n    result = unapplyValueTransform(result, offset, scale);\n  }\n  if (!classProperty.normalized) {\n    result = unnormalize(result, classProperty.componentType);\n  }\n  return result;\n}\n\n/**\n * Creates a shader statement that returns the value of the specified\n * component of the given property, normalized to the range [0, 1].\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @param {object} metadataProperty The metadata property, either\n * a `PropertyTextureProperty` or a `PropertyAttributeProperty`\n * @param {string} componentName The name, in [\"x\", \"y\", \"z\", \"w\"]\n * @returns {string} The string\n */\nfunction getSourceValueStringComponent(classProperty, metadataProperty, componentName) {\n  const valueString = `value.${componentName}`;\n  let result = `float(${valueString})`;\n\n  // The 'hasValueTransform' indicates whether the property\n  // (or its class property) did define an 'offset' or 'scale'.\n  // Even when they had not been defined in the JSON, they are\n  // defined in the object, with default values\n  // Note that in the 'PropertyTextureProperty' and the\n  // 'PropertyAttributeProperty', these values are\n  // stored as \"object types\" (like 'Cartesian2'), whereas\n  // in the 'MetadataClassProperty', they are stored as\n  // \"array types\", e.g. a `[number, number]`\n  if (metadataProperty.hasValueTransform) {\n    const offset = metadataProperty.offset[componentName];\n    const scale = metadataProperty.scale[componentName];\n    result = unapplyValueTransform(result, offset, scale);\n  }\n  if (!classProperty.normalized) {\n    result = unnormalize(result, classProperty.componentType);\n  }\n  return result;\n}\n\n/**\n * Creates a new `ShaderProgram` from the given input that renders metadata\n * values into the frame buffer, according to the given picked metadata info.\n *\n * This will update the `defines` of the fragment shader of the given shader\n * program, by setting `METADATA_PICKING_ENABLED`, and updating the\n * `METADATA_PICKING_VALUE_*` defines so that they reflect the components\n * of the metadata that should be written into the RGBA (vec4) that\n * ends up as the 'color' in the frame buffer.\n *\n * The RGBA values will eventually be converted back into an actual metadata\n * value in `Picking.js`, by calling `MetadataPicking.decodeMetadataValues`.\n *\n * @param {Context} context The context\n * @param {ShaderProgram} shaderProgram The shader program\n * @param {PickedMetadataInfo} pickedMetadataInfo The picked metadata info\n * @returns {ShaderProgram} The new shader program\n * @private\n */\nfunction getPickMetadataShaderProgram(context, shaderProgram, pickedMetadataInfo) {\n  const schemaId = pickedMetadataInfo.schemaId;\n  const className = pickedMetadataInfo.className;\n  const propertyName = pickedMetadataInfo.propertyName;\n  const keyword = `pickMetadata-${schemaId}-${className}-${propertyName}`;\n  const shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n  if (defined(shader)) {\n    return shader;\n  }\n  const metadataProperty = pickedMetadataInfo.metadataProperty;\n  const classProperty = pickedMetadataInfo.classProperty;\n  const glslType = getGlslType(classProperty);\n\n  // Define the components that will go into the output `metadataValues`.\n  // This will be the 'color' that is written into the frame buffer,\n  // meaning that the values should be in [0.0, 1.0], and will become\n  // values in [0, 255] in the frame buffer.\n  // By default, all of them are 0.0.\n  const sourceValueStrings = [\"0.0\", \"0.0\", \"0.0\", \"0.0\"];\n  const componentCount = getComponentCount(classProperty);\n  if (componentCount === 1) {\n    // When the property is a scalar, store the source value\n    // string directly in `metadataValues.x`\n    sourceValueStrings[0] = getSourceValueStringScalar(classProperty, metadataProperty);\n  } else {\n    // When the property is an array, store the array elements\n    // in `metadataValues.x/y/z/w`\n    const componentNames = [\"x\", \"y\", \"z\", \"w\"];\n    for (let i = 0; i < componentCount; i++) {\n      sourceValueStrings[i] = getSourceValueStringComponent(classProperty, metadataProperty, componentNames[i]);\n    }\n  }\n  const newDefines = shaderProgram.fragmentShaderSource.defines.slice();\n  newDefines.push(MetadataPickingPipelineStage.METADATA_PICKING_ENABLED);\n\n  // Replace the defines of the shader, using the type, property\n  // access, and value components  that have been determined\n  replaceDefine(newDefines, MetadataPickingPipelineStage.METADATA_PICKING_VALUE_TYPE, glslType);\n  replaceDefine(newDefines, MetadataPickingPipelineStage.METADATA_PICKING_VALUE_STRING, `metadata.${propertyName}`);\n  replaceDefine(newDefines, MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_X, sourceValueStrings[0]);\n  replaceDefine(newDefines, MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Y, sourceValueStrings[1]);\n  replaceDefine(newDefines, MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Z, sourceValueStrings[2]);\n  replaceDefine(newDefines, MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_W, sourceValueStrings[3]);\n  const newFragmentShaderSource = new ShaderSource({\n    sources: shaderProgram.fragmentShaderSource.sources,\n    defines: newDefines\n  });\n  const newShader = context.shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n    vertexShaderSource: shaderProgram.vertexShaderSource,\n    fragmentShaderSource: newFragmentShaderSource,\n    attributeLocations: shaderProgram._attributeLocations\n  });\n  return newShader;\n}\n\n/**\n * @private\n */\nDerivedCommand.createPickMetadataDerivedCommand = function (scene, command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  result.pickMetadataCommand = DrawCommand.shallowClone(command, result.pickMetadataCommand);\n  result.pickMetadataCommand.shaderProgram = getPickMetadataShaderProgram(context, command.shaderProgram, command.pickedMetadataInfo);\n  result.pickMetadataCommand.renderState = getPickRenderState(scene, command.renderState);\n  result.shaderProgramId = command.shaderProgram.id;\n  return result;\n};\nfunction getHdrShaderProgram(context, shaderProgram) {\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"HDR\");\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n  const attributeLocations = shaderProgram._attributeLocations;\n  const vs = shaderProgram.vertexShaderSource.clone();\n  const fs = shaderProgram.fragmentShaderSource.clone();\n  vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n  vs.defines.push(\"HDR\");\n  fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n  fs.defines.push(\"HDR\");\n  return context.shaderCache.createDerivedShaderProgram(shaderProgram, \"HDR\", {\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\nDerivedCommand.createHdrCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  const shader = result.command?.shaderProgram;\n  result.command = DrawCommand.shallowClone(command, result.command);\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getHdrShaderProgram(context, command.shaderProgram);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n  return result;\n};\nexport default DerivedCommand;","map":{"version":3,"names":["MetadataComponentType","defined","DrawCommand","RenderState","ShaderSource","MetadataType","MetadataPickingPipelineStage","DerivedCommand","fragDepthRegex","discardRegex","getDepthOnlyShaderProgram","context","shaderProgram","cachedShader","shaderCache","getDerivedShaderProgram","fs","fragmentShaderSource","writesDepthOrDiscards","sources","i","length","test","usesLogDepth","defines","indexOf","source","createDerivedShaderProgram","vertexShaderSource","attributeLocations","_attributeLocations","getDepthOnlyRenderState","scene","renderState","cache","_depthOnlyRenderStateCache","cachedDepthOnlyState","id","rs","getState","depthMask","colorMask","red","green","blue","alpha","depthOnlyState","fromCache","createDepthOnlyDerivedCommand","command","result","shader","depthOnlyCommand","shallowClone","shaderProgramId","writeLogDepthRegex","vertexlogDepthRegex","getLogDepthShaderProgram","disableLogDepthWrite","vs","clone","slice","push","writesLogDepth","replaceMain","logMain","logSource","createLogDepthCommand","getPickShaderProgram","pickId","hasFragData","some","includes","outputColorVariable","newMain","newSources","Array","getPickRenderState","picking","pickRenderStateCache","cachedPickState","blending","enabled","pickState","createPickDerivedCommand","pickCommand","replaceDefine","defineName","newDefineValue","n","define","tokens","trimStart","split","getComponentCount","classProperty","isArray","type","arrayLength","getGlslType","componentCount","normalized","unapplyValueTransform","input","offset","scale","unnormalize","componentType","max","getMaximum","getSourceValueStringScalar","metadataProperty","hasValueTransform","getSourceValueStringComponent","componentName","valueString","getPickMetadataShaderProgram","pickedMetadataInfo","schemaId","className","propertyName","keyword","glslType","sourceValueStrings","componentNames","newDefines","METADATA_PICKING_ENABLED","METADATA_PICKING_VALUE_TYPE","METADATA_PICKING_VALUE_STRING","METADATA_PICKING_VALUE_COMPONENT_X","METADATA_PICKING_VALUE_COMPONENT_Y","METADATA_PICKING_VALUE_COMPONENT_Z","METADATA_PICKING_VALUE_COMPONENT_W","newFragmentShaderSource","newShader","createPickMetadataDerivedCommand","pickMetadataCommand","getHdrShaderProgram","createHdrCommand"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/DerivedCommand.js"],"sourcesContent":["import { MetadataComponentType } from \"@cesium/engine\";\nimport defined from \"../Core/defined.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataPickingPipelineStage from \"./Model/MetadataPickingPipelineStage.js\";\n\n/**\n * @private\n */\nfunction DerivedCommand() {}\n\nconst fragDepthRegex = /\\bgl_FragDepth\\b/;\nconst discardRegex = /\\bdiscard\\b/;\n\nfunction getDepthOnlyShaderProgram(context, shaderProgram) {\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"depthOnly\",\n  );\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n\n  let fs = shaderProgram.fragmentShaderSource;\n\n  let writesDepthOrDiscards = false;\n  const sources = fs.sources;\n  for (let i = 0; i < sources.length; ++i) {\n    if (fragDepthRegex.test(sources[i]) || discardRegex.test(sources[i])) {\n      writesDepthOrDiscards = true;\n      break;\n    }\n  }\n\n  const usesLogDepth = fs.defines.indexOf(\"LOG_DEPTH\") >= 0;\n\n  if (!writesDepthOrDiscards && !usesLogDepth) {\n    const source = `void main()\n{\n    out_FragColor = vec4(1.0);\n}\n`;\n    fs = new ShaderSource({\n      sources: [source],\n    });\n  } else if (!writesDepthOrDiscards && usesLogDepth) {\n    const source = `void main()\n{\n    out_FragColor = vec4(1.0);\n    czm_writeLogDepth();\n}\n`;\n    fs = new ShaderSource({\n      defines: [\"LOG_DEPTH\"],\n      sources: [source],\n    });\n  }\n\n  return context.shaderCache.createDerivedShaderProgram(\n    shaderProgram,\n    \"depthOnly\",\n    {\n      vertexShaderSource: shaderProgram.vertexShaderSource,\n      fragmentShaderSource: fs,\n      attributeLocations: shaderProgram._attributeLocations,\n    },\n  );\n}\n\nfunction getDepthOnlyRenderState(scene, renderState) {\n  const cache = scene._depthOnlyRenderStateCache;\n\n  const cachedDepthOnlyState = cache[renderState.id];\n  if (defined(cachedDepthOnlyState)) {\n    return cachedDepthOnlyState;\n  }\n\n  const rs = RenderState.getState(renderState);\n  rs.depthMask = true;\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n\n  const depthOnlyState = RenderState.fromCache(rs);\n  cache[renderState.id] = depthOnlyState;\n\n  return depthOnlyState;\n}\n\nDerivedCommand.createDepthOnlyDerivedCommand = function (\n  scene,\n  command,\n  context,\n  result,\n) {\n  // For a depth only pass, we bind a framebuffer with only a depth attachment (no color attachments),\n  // do not write color, and write depth. If the fragment shader doesn't modify the fragment depth\n  // or discard, the driver can replace the fragment shader with a pass-through shader. We're unsure if this\n  // actually happens so we modify the shader to use a pass-through fragment shader.\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const shader = result.depthOnlyCommand?.shaderProgram;\n  const renderState = result.depthOnlyCommand?.renderState;\n\n  result.depthOnlyCommand = DrawCommand.shallowClone(\n    command,\n    result.depthOnlyCommand,\n  );\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.depthOnlyCommand.shaderProgram = getDepthOnlyShaderProgram(\n      context,\n      command.shaderProgram,\n    );\n    result.depthOnlyCommand.renderState = getDepthOnlyRenderState(\n      scene,\n      command.renderState,\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.depthOnlyCommand.shaderProgram = shader;\n    result.depthOnlyCommand.renderState = renderState;\n  }\n\n  return result;\n};\n\nconst writeLogDepthRegex = /\\s+czm_writeLogDepth\\(/;\nconst vertexlogDepthRegex = /\\s+czm_vertexLogDepth\\(/;\n\nfunction getLogDepthShaderProgram(context, shaderProgram) {\n  const disableLogDepthWrite =\n    shaderProgram.fragmentShaderSource.defines.indexOf(\"LOG_DEPTH_READ_ONLY\") >=\n    0;\n  if (disableLogDepthWrite) {\n    return shaderProgram;\n  }\n\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"logDepth\",\n  );\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n\n  const attributeLocations = shaderProgram._attributeLocations;\n  const vs = shaderProgram.vertexShaderSource.clone();\n  const fs = shaderProgram.fragmentShaderSource.clone();\n\n  vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n  vs.defines.push(\"LOG_DEPTH\");\n  fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n  fs.defines.push(\"LOG_DEPTH\");\n\n  let writesLogDepth = false;\n  let sources = vs.sources;\n  for (let i = 0; i < sources.length; ++i) {\n    if (vertexlogDepthRegex.test(sources[i])) {\n      writesLogDepth = true;\n      break;\n    }\n  }\n\n  if (!writesLogDepth) {\n    for (let i = 0; i < sources.length; ++i) {\n      sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n    }\n\n    const logMain = `\n\nvoid main()\n{\n    czm_log_depth_main();\n    czm_vertexLogDepth();\n}\n`;\n    sources.push(logMain);\n  }\n\n  sources = fs.sources;\n\n  writesLogDepth = false;\n  for (let i = 0; i < sources.length; ++i) {\n    if (writeLogDepthRegex.test(sources[i])) {\n      writesLogDepth = true;\n    }\n  }\n  // This define indicates that a log depth value is written by the shader but doesn't use czm_writeLogDepth.\n  if (fs.defines.indexOf(\"LOG_DEPTH_WRITE\") !== -1) {\n    writesLogDepth = true;\n  }\n\n  let logSource = \"\";\n\n  if (!writesLogDepth) {\n    for (let i = 0; i < sources.length; i++) {\n      sources[i] = ShaderSource.replaceMain(sources[i], \"czm_log_depth_main\");\n    }\n\n    logSource = `\nvoid main()\n{\n    czm_log_depth_main();\n    czm_writeLogDepth();\n}\n`;\n  }\n\n  sources.push(logSource);\n\n  return context.shaderCache.createDerivedShaderProgram(\n    shaderProgram,\n    \"logDepth\",\n    {\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    },\n  );\n}\n\nDerivedCommand.createLogDepthCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const shader = result.command?.shaderProgram;\n\n  result.command = DrawCommand.shallowClone(command, result.command);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getLogDepthShaderProgram(\n      context,\n      command.shaderProgram,\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n\n  return result;\n};\n\nfunction getPickShaderProgram(context, shaderProgram, pickId) {\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"pick\",\n  );\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n\n  const attributeLocations = shaderProgram._attributeLocations;\n  const { sources, defines } = shaderProgram.fragmentShaderSource;\n\n  const hasFragData = sources.some((source) => source.includes(\"out_FragData\"));\n  const outputColorVariable = hasFragData ? \"out_FragData_0\" : \"out_FragColor\";\n  const newMain = `void main () \n{ \n    czm_non_pick_main(); \n    if (${outputColorVariable}.a == 0.0) { \n        discard; \n    } \n    ${outputColorVariable} = ${pickId}; \n} `;\n\n  const length = sources.length;\n  const newSources = new Array(length + 1);\n  for (let i = 0; i < length; ++i) {\n    newSources[i] = ShaderSource.replaceMain(sources[i], \"czm_non_pick_main\");\n  }\n  newSources[length] = newMain;\n  const fragmentShaderSource = new ShaderSource({\n    sources: newSources,\n    defines: defines,\n  });\n  return context.shaderCache.createDerivedShaderProgram(shaderProgram, \"pick\", {\n    vertexShaderSource: shaderProgram.vertexShaderSource,\n    fragmentShaderSource: fragmentShaderSource,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction getPickRenderState(scene, renderState) {\n  const cache = scene.picking.pickRenderStateCache;\n  const cachedPickState = cache[renderState.id];\n  if (defined(cachedPickState)) {\n    return cachedPickState;\n  }\n\n  const rs = RenderState.getState(renderState);\n  rs.blending.enabled = false;\n\n  // Turns on depth writing for opaque and translucent passes\n  // Overlapping translucent geometry on the globe surface may exhibit z-fighting\n  // during the pick pass which may not match the rendered scene. Once\n  // terrain is on by default and ground primitives are used instead\n  // this will become less of a problem.\n  rs.depthMask = true;\n\n  const pickState = RenderState.fromCache(rs);\n  cache[renderState.id] = pickState;\n  return pickState;\n}\n\nDerivedCommand.createPickDerivedCommand = function (\n  scene,\n  command,\n  context,\n  result,\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const shader = result.pickCommand?.shaderProgram;\n  const renderState = result.pickCommand?.renderState;\n\n  result.pickCommand = DrawCommand.shallowClone(command, result.pickCommand);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.pickCommand.shaderProgram = getPickShaderProgram(\n      context,\n      command.shaderProgram,\n      command.pickId,\n    );\n    result.pickCommand.renderState = getPickRenderState(\n      scene,\n      command.renderState,\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.pickCommand.shaderProgram = shader;\n    result.pickCommand.renderState = renderState;\n  }\n\n  return result;\n};\n\n/**\n * Replaces the value of the specified 'define' directive identifier\n * with the given value.\n *\n * The given defines are the parts of the define directives that are\n * stored in the `ShaderSource`. For example, the defines may be\n * `[\"EXAMPLE\", \"EXAMPLE_VALUE 123\"]`\n *\n * Calling `replaceDefine(defines, \"EXAMPLE\", 999)` will result in\n * the defines being\n * `[\"EXAMPLE 999\", \"EXAMPLE_VALUE 123\"]`\n *\n * @param {string[]} defines The define directive identifiers\n * @param {string} defineName The name (identifier) of the define directive\n * @param {any} newDefineValue The new value whose string representation\n * will become the token string for the define directive\n * @private\n */\nfunction replaceDefine(defines, defineName, newDefineValue) {\n  const n = defines.length;\n  for (let i = 0; i < n; i++) {\n    const define = defines[i];\n    const tokens = define.trimStart().split(/\\s+/);\n    if (tokens[0] === defineName) {\n      defines[i] = `${defineName} ${newDefineValue}`;\n    }\n  }\n}\n\n/**\n * Returns the component count for the given class property, or\n * its array length if it is an array.\n *\n * This will be\n * `[1, 2, 3, 4]` for `[SCALAR, VEC2, VEC3, VEC4`] types,\n * or the array length if it is an array.\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @returns {number} The component count\n * @private\n */\nfunction getComponentCount(classProperty) {\n  if (!classProperty.isArray) {\n    return MetadataType.getComponentCount(classProperty.type);\n  }\n  return classProperty.arrayLength;\n}\n\n/**\n * Returns the type that the given class property has in a GLSL shader.\n *\n * It returns the same string as `PropertyTextureProperty.prototype.getGlslType`\n * for a property texture property with the given class property\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @returns {string} The GLSL shader type string for the property\n */\nfunction getGlslType(classProperty) {\n  const componentCount = getComponentCount(classProperty);\n  if (classProperty.normalized) {\n    if (componentCount === 1) {\n      return \"float\";\n    }\n    return `vec${componentCount}`;\n  }\n  if (componentCount === 1) {\n    return \"int\";\n  }\n  return `ivec${componentCount}`;\n}\n\n/**\n * Returns a shader statement that applies the inverse of the\n * value transform to the given value, based on the given offset\n * and scale.\n *\n * @param {string} input The input value\n * @param {string} offset The offset\n * @param {string} scale The scale\n * @returns {string} The statement\n */\nfunction unapplyValueTransform(input, offset, scale) {\n  return `((${input} - float(${offset})) / float(${scale}))`;\n}\n\n/**\n * Returns a shader statement that applies the inverse of the\n * normalization, based on the given component type\n *\n * @param {string} input The input value\n * @param {string} componentType The component type\n * @returns {string} The statement\n */\nfunction unnormalize(input, componentType) {\n  const max = MetadataComponentType.getMaximum(componentType);\n  return `(${input}) / float(${max})`;\n}\n\n/**\n * Creates a shader statement that returns the value of the specified\n * property, normalized to the range [0, 1].\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @param {object} metadataProperty The metadata property, either\n * a `PropertyTextureProperty` or a `PropertyAttributeProperty`\n * @returns {string} The string\n */\nfunction getSourceValueStringScalar(classProperty, metadataProperty) {\n  let result = `float(value)`;\n\n  // The 'hasValueTransform' indicates whether the property\n  // (or its class property) did define an 'offset' or 'scale'.\n  // Even when they had not been defined in the JSON, they are\n  // defined in the object, with default values.\n  if (metadataProperty.hasValueTransform) {\n    const offset = metadataProperty.offset;\n    const scale = metadataProperty.scale;\n    result = unapplyValueTransform(result, offset, scale);\n  }\n  if (!classProperty.normalized) {\n    result = unnormalize(result, classProperty.componentType);\n  }\n  return result;\n}\n\n/**\n * Creates a shader statement that returns the value of the specified\n * component of the given property, normalized to the range [0, 1].\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @param {object} metadataProperty The metadata property, either\n * a `PropertyTextureProperty` or a `PropertyAttributeProperty`\n * @param {string} componentName The name, in [\"x\", \"y\", \"z\", \"w\"]\n * @returns {string} The string\n */\nfunction getSourceValueStringComponent(\n  classProperty,\n  metadataProperty,\n  componentName,\n) {\n  const valueString = `value.${componentName}`;\n  let result = `float(${valueString})`;\n\n  // The 'hasValueTransform' indicates whether the property\n  // (or its class property) did define an 'offset' or 'scale'.\n  // Even when they had not been defined in the JSON, they are\n  // defined in the object, with default values\n  // Note that in the 'PropertyTextureProperty' and the\n  // 'PropertyAttributeProperty', these values are\n  // stored as \"object types\" (like 'Cartesian2'), whereas\n  // in the 'MetadataClassProperty', they are stored as\n  // \"array types\", e.g. a `[number, number]`\n  if (metadataProperty.hasValueTransform) {\n    const offset = metadataProperty.offset[componentName];\n    const scale = metadataProperty.scale[componentName];\n    result = unapplyValueTransform(result, offset, scale);\n  }\n  if (!classProperty.normalized) {\n    result = unnormalize(result, classProperty.componentType);\n  }\n  return result;\n}\n\n/**\n * Creates a new `ShaderProgram` from the given input that renders metadata\n * values into the frame buffer, according to the given picked metadata info.\n *\n * This will update the `defines` of the fragment shader of the given shader\n * program, by setting `METADATA_PICKING_ENABLED`, and updating the\n * `METADATA_PICKING_VALUE_*` defines so that they reflect the components\n * of the metadata that should be written into the RGBA (vec4) that\n * ends up as the 'color' in the frame buffer.\n *\n * The RGBA values will eventually be converted back into an actual metadata\n * value in `Picking.js`, by calling `MetadataPicking.decodeMetadataValues`.\n *\n * @param {Context} context The context\n * @param {ShaderProgram} shaderProgram The shader program\n * @param {PickedMetadataInfo} pickedMetadataInfo The picked metadata info\n * @returns {ShaderProgram} The new shader program\n * @private\n */\nfunction getPickMetadataShaderProgram(\n  context,\n  shaderProgram,\n  pickedMetadataInfo,\n) {\n  const schemaId = pickedMetadataInfo.schemaId;\n  const className = pickedMetadataInfo.className;\n  const propertyName = pickedMetadataInfo.propertyName;\n  const keyword = `pickMetadata-${schemaId}-${className}-${propertyName}`;\n  const shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    keyword,\n  );\n  if (defined(shader)) {\n    return shader;\n  }\n\n  const metadataProperty = pickedMetadataInfo.metadataProperty;\n  const classProperty = pickedMetadataInfo.classProperty;\n  const glslType = getGlslType(classProperty);\n\n  // Define the components that will go into the output `metadataValues`.\n  // This will be the 'color' that is written into the frame buffer,\n  // meaning that the values should be in [0.0, 1.0], and will become\n  // values in [0, 255] in the frame buffer.\n  // By default, all of them are 0.0.\n  const sourceValueStrings = [\"0.0\", \"0.0\", \"0.0\", \"0.0\"];\n  const componentCount = getComponentCount(classProperty);\n  if (componentCount === 1) {\n    // When the property is a scalar, store the source value\n    // string directly in `metadataValues.x`\n    sourceValueStrings[0] = getSourceValueStringScalar(\n      classProperty,\n      metadataProperty,\n    );\n  } else {\n    // When the property is an array, store the array elements\n    // in `metadataValues.x/y/z/w`\n    const componentNames = [\"x\", \"y\", \"z\", \"w\"];\n    for (let i = 0; i < componentCount; i++) {\n      sourceValueStrings[i] = getSourceValueStringComponent(\n        classProperty,\n        metadataProperty,\n        componentNames[i],\n      );\n    }\n  }\n\n  const newDefines = shaderProgram.fragmentShaderSource.defines.slice();\n  newDefines.push(MetadataPickingPipelineStage.METADATA_PICKING_ENABLED);\n\n  // Replace the defines of the shader, using the type, property\n  // access, and value components  that have been determined\n  replaceDefine(\n    newDefines,\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_TYPE,\n    glslType,\n  );\n  replaceDefine(\n    newDefines,\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_STRING,\n    `metadata.${propertyName}`,\n  );\n  replaceDefine(\n    newDefines,\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_X,\n    sourceValueStrings[0],\n  );\n  replaceDefine(\n    newDefines,\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Y,\n    sourceValueStrings[1],\n  );\n  replaceDefine(\n    newDefines,\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_Z,\n    sourceValueStrings[2],\n  );\n  replaceDefine(\n    newDefines,\n    MetadataPickingPipelineStage.METADATA_PICKING_VALUE_COMPONENT_W,\n    sourceValueStrings[3],\n  );\n\n  const newFragmentShaderSource = new ShaderSource({\n    sources: shaderProgram.fragmentShaderSource.sources,\n    defines: newDefines,\n  });\n  const newShader = context.shaderCache.createDerivedShaderProgram(\n    shaderProgram,\n    keyword,\n    {\n      vertexShaderSource: shaderProgram.vertexShaderSource,\n      fragmentShaderSource: newFragmentShaderSource,\n      attributeLocations: shaderProgram._attributeLocations,\n    },\n  );\n  return newShader;\n}\n\n/**\n * @private\n */\nDerivedCommand.createPickMetadataDerivedCommand = function (\n  scene,\n  command,\n  context,\n  result,\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n  result.pickMetadataCommand = DrawCommand.shallowClone(\n    command,\n    result.pickMetadataCommand,\n  );\n\n  result.pickMetadataCommand.shaderProgram = getPickMetadataShaderProgram(\n    context,\n    command.shaderProgram,\n    command.pickedMetadataInfo,\n  );\n  result.pickMetadataCommand.renderState = getPickRenderState(\n    scene,\n    command.renderState,\n  );\n  result.shaderProgramId = command.shaderProgram.id;\n\n  return result;\n};\n\nfunction getHdrShaderProgram(context, shaderProgram) {\n  const cachedShader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"HDR\",\n  );\n  if (defined(cachedShader)) {\n    return cachedShader;\n  }\n\n  const attributeLocations = shaderProgram._attributeLocations;\n  const vs = shaderProgram.vertexShaderSource.clone();\n  const fs = shaderProgram.fragmentShaderSource.clone();\n\n  vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n  vs.defines.push(\"HDR\");\n  fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n  fs.defines.push(\"HDR\");\n\n  return context.shaderCache.createDerivedShaderProgram(shaderProgram, \"HDR\", {\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nDerivedCommand.createHdrCommand = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const shader = result.command?.shaderProgram;\n\n  result.command = DrawCommand.shallowClone(command, result.command);\n\n  if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.command.shaderProgram = getHdrShaderProgram(\n      context,\n      command.shaderProgram,\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.command.shaderProgram = shader;\n  }\n\n  return result;\n};\nexport default DerivedCommand;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}