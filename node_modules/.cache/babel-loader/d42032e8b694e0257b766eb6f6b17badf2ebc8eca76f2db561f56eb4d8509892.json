{"ast":null,"code":"import createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nconst entityOptionsScratch = {\n  id: undefined\n};\nconst entityIdScratch = new Array(2);\nfunction clean(entity) {\n  const propertyNames = entity.propertyNames;\n  const propertyNamesLength = propertyNames.length;\n  for (let i = 0; i < propertyNamesLength; i++) {\n    entity[propertyNames[i]] = undefined;\n  }\n  entity._name = undefined;\n  entity._availability = undefined;\n}\nfunction subscribeToEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  eventHash[JSON.stringify(entityIdScratch)] = entity.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged, that);\n}\nfunction unsubscribeFromEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  const id = JSON.stringify(entityIdScratch);\n  eventHash[id]();\n  eventHash[id] = undefined;\n}\nfunction recomposite(that) {\n  that._shouldRecomposite = true;\n  if (that._suspendCount !== 0) {\n    return;\n  }\n  const collections = that._collections;\n  const collectionsLength = collections.length;\n  const collectionsCopy = that._collectionsCopy;\n  const collectionsCopyLength = collectionsCopy.length;\n  let i;\n  let entity;\n  let entities;\n  let iEntities;\n  let collection;\n  const composite = that._composite;\n  const newEntities = new EntityCollection(that);\n  const eventHash = that._eventHash;\n  let collectionId;\n  for (i = 0; i < collectionsCopyLength; i++) {\n    collection = collectionsCopy[i];\n    collection.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);\n    entities = collection.values;\n    collectionId = collection.id;\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      unsubscribeFromEntity(that, eventHash, collectionId, entity);\n    }\n  }\n  for (i = collectionsLength - 1; i >= 0; i--) {\n    collection = collections[i];\n    collection.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);\n\n    //Merge all of the existing entities.\n    entities = collection.values;\n    collectionId = collection.id;\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      subscribeToEntity(that, eventHash, collectionId, entity);\n      let compositeEntity = newEntities.getById(entity.id);\n      if (!defined(compositeEntity)) {\n        compositeEntity = composite.getById(entity.id);\n        if (!defined(compositeEntity)) {\n          entityOptionsScratch.id = entity.id;\n          compositeEntity = new Entity(entityOptionsScratch);\n        } else {\n          clean(compositeEntity);\n        }\n        newEntities.add(compositeEntity);\n      }\n      compositeEntity.merge(entity);\n    }\n  }\n  that._collectionsCopy = collections.slice(0);\n  composite.suspendEvents();\n  composite.removeAll();\n  const newEntitiesArray = newEntities.values;\n  for (i = 0; i < newEntitiesArray.length; i++) {\n    composite.add(newEntitiesArray[i]);\n  }\n  composite.resumeEvents();\n}\n\n/**\n * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.\n * If a Entity with the same ID exists in multiple collections, it is non-destructively\n * merged into a single new entity instance.  If an entity has the same property in multiple\n * collections, the property of the Entity in the last collection of the list it\n * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a\n * EntityCollection is used.\n *\n * @alias CompositeEntityCollection\n * @constructor\n *\n * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.\n * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.\n */\nfunction CompositeEntityCollection(collections, owner) {\n  this._owner = owner;\n  this._composite = new EntityCollection(this);\n  this._suspendCount = 0;\n  this._collections = defined(collections) ? collections.slice() : [];\n  this._collectionsCopy = [];\n  this._id = createGuid();\n  this._eventHash = {};\n  recomposite(this);\n  this._shouldRecomposite = false;\n}\nObject.defineProperties(CompositeEntityCollection.prototype, {\n  /**\n   * Gets the event that is fired when entities are added or removed from the collection.\n   * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Event}\n   */\n  collectionChanged: {\n    get: function () {\n      return this._composite._collectionChanged;\n    }\n  },\n  /**\n   * Gets a globally unique identifier for this collection.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {string}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * Gets the array of Entity instances in the collection.\n   * This array should not be modified directly.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Entity[]}\n   */\n  values: {\n    get: function () {\n      return this._composite.values;\n    }\n  },\n  /**\n   * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {DataSource|CompositeEntityCollection}\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  }\n});\n\n/**\n * Adds a collection to the composite.\n *\n * @param {EntityCollection} collection the collection to add.\n * @param {number} [index] the index to add the collection at.  If omitted, the collection will\n *                         added on top of all existing collections.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.\n */\nCompositeEntityCollection.prototype.addCollection = function (collection, index) {\n  const hasIndex = defined(index);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._collections.length) {\n      throw new DeveloperError(\"index must be less than or equal to the number of collections.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._collections.length;\n    this._collections.push(collection);\n  } else {\n    this._collections.splice(index, 0, collection);\n  }\n  recomposite(this);\n};\n\n/**\n * Removes a collection from this composite, if present.\n *\n * @param {EntityCollection} collection The collection to remove.\n * @returns {boolean} true if the collection was in the composite and was removed,\n *                    false if the collection was not in the composite.\n */\nCompositeEntityCollection.prototype.removeCollection = function (collection) {\n  const index = this._collections.indexOf(collection);\n  if (index !== -1) {\n    this._collections.splice(index, 1);\n    recomposite(this);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all collections from this composite.\n */\nCompositeEntityCollection.prototype.removeAllCollections = function () {\n  this._collections.length = 0;\n  recomposite(this);\n};\n\n/**\n * Checks to see if the composite contains a given collection.\n *\n * @param {EntityCollection} collection the collection to check for.\n * @returns {boolean} true if the composite contains the collection, false otherwise.\n */\nCompositeEntityCollection.prototype.containsCollection = function (collection) {\n  return this._collections.indexOf(collection) !== -1;\n};\n\n/**\n * Returns true if the provided entity is in this collection, false otherwise.\n *\n * @param {Entity} entity The entity.\n * @returns {boolean} true if the provided entity is in this collection, false otherwise.\n */\nCompositeEntityCollection.prototype.contains = function (entity) {\n  return this._composite.contains(entity);\n};\n\n/**\n * Determines the index of a given collection in the composite.\n *\n * @param {EntityCollection} collection The collection to find the index of.\n * @returns {number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.\n */\nCompositeEntityCollection.prototype.indexOfCollection = function (collection) {\n  return this._collections.indexOf(collection);\n};\n\n/**\n * Gets a collection by index from the composite.\n *\n * @param {number} index the index to retrieve.\n */\nCompositeEntityCollection.prototype.getCollection = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._collections[index];\n};\n\n/**\n * Gets the number of collections in this composite.\n */\nCompositeEntityCollection.prototype.getCollectionsLength = function () {\n  return this._collections.length;\n};\nfunction getCollectionIndex(collections, collection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const index = collections.indexOf(collection);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"collection is not in this composite.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\nfunction swapCollections(composite, i, j) {\n  const arr = composite._collections;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n  if (i === j) {\n    return;\n  }\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n  recomposite(composite);\n}\n\n/**\n * Raises a collection up one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.raiseCollection = function (collection) {\n  const index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index + 1);\n};\n\n/**\n * Lowers a collection down one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.lowerCollection = function (collection) {\n  const index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index - 1);\n};\n\n/**\n * Raises a collection to the top of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.raiseCollectionToTop = function (collection) {\n  const index = getCollectionIndex(this._collections, collection);\n  if (index === this._collections.length - 1) {\n    return;\n  }\n  this._collections.splice(index, 1);\n  this._collections.push(collection);\n  recomposite(this);\n};\n\n/**\n * Lowers a collection to the bottom of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.lowerCollectionToBottom = function (collection) {\n  const index = getCollectionIndex(this._collections, collection);\n  if (index === 0) {\n    return;\n  }\n  this._collections.splice(index, 1);\n  this._collections.splice(0, 0, collection);\n  recomposite(this);\n};\n\n/**\n * Prevents {@link EntityCollection#collectionChanged} events from being raised\n * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which\n * point a single event will be raised that covers all suspended operations.\n * This allows for many items to be added and removed efficiently.\n * While events are suspended, recompositing of the collections will\n * also be suspended, as this can be a costly operation.\n * This function can be safely called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n */\nCompositeEntityCollection.prototype.suspendEvents = function () {\n  this._suspendCount++;\n  this._composite.suspendEvents();\n};\n\n/**\n * Resumes raising {@link EntityCollection#collectionChanged} events immediately\n * when an item is added or removed.  Any modifications made while while events were suspended\n * will be triggered as a single event when this function is called.  This function also ensures\n * the collection is recomposited if events are also resumed.\n * This function is reference counted and can safely be called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n *\n * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.\n */\nCompositeEntityCollection.prototype.resumeEvents = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._suspendCount === 0) {\n    throw new DeveloperError(\"resumeEvents can not be called before suspendEvents.\");\n  }\n  //>>includeEnd('debug');\n\n  this._suspendCount--;\n  // recomposite before triggering events (but only if required for performance) that might depend on a composited collection\n  if (this._shouldRecomposite && this._suspendCount === 0) {\n    recomposite(this);\n    this._shouldRecomposite = false;\n  }\n  this._composite.resumeEvents();\n};\n\n/**\n * Computes the maximum availability of the entities in the collection.\n * If the collection contains a mix of infinitely available data and non-infinite data,\n * It will return the interval pertaining to the non-infinite data only.  If all\n * data is infinite, an infinite interval will be returned.\n *\n * @returns {TimeInterval} The availability of entities in the collection.\n */\nCompositeEntityCollection.prototype.computeAvailability = function () {\n  return this._composite.computeAvailability();\n};\n\n/**\n * Gets an entity with the specified id.\n *\n * @param {string} id The id of the entity to retrieve.\n * @returns {Entity|undefined} The entity with the provided id or undefined if the id did not exist in the collection.\n */\nCompositeEntityCollection.prototype.getById = function (id) {\n  return this._composite.getById(id);\n};\nCompositeEntityCollection.prototype._onCollectionChanged = function (collection, added, removed) {\n  const collections = this._collectionsCopy;\n  const collectionsLength = collections.length;\n  const composite = this._composite;\n  composite.suspendEvents();\n  let i;\n  let q;\n  let entity;\n  let compositeEntity;\n  const removedLength = removed.length;\n  const eventHash = this._eventHash;\n  const collectionId = collection.id;\n  for (i = 0; i < removedLength; i++) {\n    const removedEntity = removed[i];\n    unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);\n    const removedId = removedEntity.id;\n    //Check if the removed entity exists in any of the remaining collections\n    //If so, we clean and remerge it.\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(removedId);\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(removedId);\n          clean(compositeEntity);\n        }\n        compositeEntity.merge(entity);\n      }\n    }\n    //We never retrieved the compositeEntity, which means it no longer\n    //exists in any of the collections, remove it from the composite.\n    if (!defined(compositeEntity)) {\n      composite.removeById(removedId);\n    }\n    compositeEntity = undefined;\n  }\n  const addedLength = added.length;\n  for (i = 0; i < addedLength; i++) {\n    const addedEntity = added[i];\n    subscribeToEntity(this, eventHash, collectionId, addedEntity);\n    const addedId = addedEntity.id;\n    //We know the added entity exists in at least one collection,\n    //but we need to check all collections and re-merge in order\n    //to maintain the priority of properties.\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(addedId);\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(addedId);\n          if (!defined(compositeEntity)) {\n            entityOptionsScratch.id = addedId;\n            compositeEntity = new Entity(entityOptionsScratch);\n            composite.add(compositeEntity);\n          } else {\n            clean(compositeEntity);\n          }\n        }\n        compositeEntity.merge(entity);\n      }\n    }\n    compositeEntity = undefined;\n  }\n  composite.resumeEvents();\n};\nCompositeEntityCollection.prototype._onDefinitionChanged = function (entity, propertyName, newValue, oldValue) {\n  const collections = this._collections;\n  const composite = this._composite;\n  const collectionsLength = collections.length;\n  const id = entity.id;\n  const compositeEntity = composite.getById(id);\n  let compositeProperty = compositeEntity[propertyName];\n  const newProperty = !defined(compositeProperty);\n  let firstTime = true;\n  for (let q = collectionsLength - 1; q >= 0; q--) {\n    const innerEntity = collections[q].getById(entity.id);\n    if (defined(innerEntity)) {\n      const property = innerEntity[propertyName];\n      if (defined(property)) {\n        if (firstTime) {\n          firstTime = false;\n          //We only want to clone if the property is also mergeable.\n          //This ensures that leaf properties are referenced and not copied,\n          //which is the entire point of compositing.\n          if (defined(property.merge) && defined(property.clone)) {\n            compositeProperty = property.clone(compositeProperty);\n          } else {\n            compositeProperty = property;\n            break;\n          }\n        }\n        compositeProperty.merge(property);\n      }\n    }\n  }\n  if (newProperty && compositeEntity.propertyNames.indexOf(propertyName) === -1) {\n    compositeEntity.addProperty(propertyName);\n  }\n  compositeEntity[propertyName] = compositeProperty;\n};\nexport default CompositeEntityCollection;","map":{"version":3,"names":["createGuid","defined","DeveloperError","CesiumMath","Entity","EntityCollection","entityOptionsScratch","id","undefined","entityIdScratch","Array","clean","entity","propertyNames","propertyNamesLength","length","i","_name","_availability","subscribeToEntity","that","eventHash","collectionId","JSON","stringify","definitionChanged","addEventListener","CompositeEntityCollection","prototype","_onDefinitionChanged","unsubscribeFromEntity","recomposite","_shouldRecomposite","_suspendCount","collections","_collections","collectionsLength","collectionsCopy","_collectionsCopy","collectionsCopyLength","entities","iEntities","collection","composite","_composite","newEntities","_eventHash","collectionChanged","removeEventListener","_onCollectionChanged","values","compositeEntity","getById","add","merge","slice","suspendEvents","removeAll","newEntitiesArray","resumeEvents","owner","_owner","_id","Object","defineProperties","get","_collectionChanged","addCollection","index","hasIndex","push","splice","removeCollection","indexOf","removeAllCollections","containsCollection","contains","indexOfCollection","getCollection","getCollectionsLength","getCollectionIndex","swapCollections","j","arr","clamp","temp","raiseCollection","lowerCollection","raiseCollectionToTop","lowerCollectionToBottom","computeAvailability","added","removed","q","removedLength","removedEntity","removedId","removeById","addedLength","addedEntity","addedId","propertyName","newValue","oldValue","compositeProperty","newProperty","firstTime","innerEntity","property","clone","addProperty"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/CompositeEntityCollection.js"],"sourcesContent":["import createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCollection from \"./EntityCollection.js\";\n\nconst entityOptionsScratch = {\n  id: undefined,\n};\nconst entityIdScratch = new Array(2);\n\nfunction clean(entity) {\n  const propertyNames = entity.propertyNames;\n  const propertyNamesLength = propertyNames.length;\n  for (let i = 0; i < propertyNamesLength; i++) {\n    entity[propertyNames[i]] = undefined;\n  }\n  entity._name = undefined;\n  entity._availability = undefined;\n}\n\nfunction subscribeToEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  eventHash[JSON.stringify(entityIdScratch)] =\n    entity.definitionChanged.addEventListener(\n      CompositeEntityCollection.prototype._onDefinitionChanged,\n      that,\n    );\n}\n\nfunction unsubscribeFromEntity(that, eventHash, collectionId, entity) {\n  entityIdScratch[0] = collectionId;\n  entityIdScratch[1] = entity.id;\n  const id = JSON.stringify(entityIdScratch);\n  eventHash[id]();\n  eventHash[id] = undefined;\n}\n\nfunction recomposite(that) {\n  that._shouldRecomposite = true;\n  if (that._suspendCount !== 0) {\n    return;\n  }\n\n  const collections = that._collections;\n  const collectionsLength = collections.length;\n\n  const collectionsCopy = that._collectionsCopy;\n  const collectionsCopyLength = collectionsCopy.length;\n\n  let i;\n  let entity;\n  let entities;\n  let iEntities;\n  let collection;\n  const composite = that._composite;\n  const newEntities = new EntityCollection(that);\n  const eventHash = that._eventHash;\n  let collectionId;\n\n  for (i = 0; i < collectionsCopyLength; i++) {\n    collection = collectionsCopy[i];\n    collection.collectionChanged.removeEventListener(\n      CompositeEntityCollection.prototype._onCollectionChanged,\n      that,\n    );\n    entities = collection.values;\n    collectionId = collection.id;\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      unsubscribeFromEntity(that, eventHash, collectionId, entity);\n    }\n  }\n\n  for (i = collectionsLength - 1; i >= 0; i--) {\n    collection = collections[i];\n    collection.collectionChanged.addEventListener(\n      CompositeEntityCollection.prototype._onCollectionChanged,\n      that,\n    );\n\n    //Merge all of the existing entities.\n    entities = collection.values;\n    collectionId = collection.id;\n    for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {\n      entity = entities[iEntities];\n      subscribeToEntity(that, eventHash, collectionId, entity);\n\n      let compositeEntity = newEntities.getById(entity.id);\n      if (!defined(compositeEntity)) {\n        compositeEntity = composite.getById(entity.id);\n        if (!defined(compositeEntity)) {\n          entityOptionsScratch.id = entity.id;\n          compositeEntity = new Entity(entityOptionsScratch);\n        } else {\n          clean(compositeEntity);\n        }\n        newEntities.add(compositeEntity);\n      }\n      compositeEntity.merge(entity);\n    }\n  }\n  that._collectionsCopy = collections.slice(0);\n\n  composite.suspendEvents();\n  composite.removeAll();\n  const newEntitiesArray = newEntities.values;\n  for (i = 0; i < newEntitiesArray.length; i++) {\n    composite.add(newEntitiesArray[i]);\n  }\n  composite.resumeEvents();\n}\n\n/**\n * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.\n * If a Entity with the same ID exists in multiple collections, it is non-destructively\n * merged into a single new entity instance.  If an entity has the same property in multiple\n * collections, the property of the Entity in the last collection of the list it\n * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a\n * EntityCollection is used.\n *\n * @alias CompositeEntityCollection\n * @constructor\n *\n * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.\n * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.\n */\nfunction CompositeEntityCollection(collections, owner) {\n  this._owner = owner;\n  this._composite = new EntityCollection(this);\n  this._suspendCount = 0;\n  this._collections = defined(collections) ? collections.slice() : [];\n  this._collectionsCopy = [];\n  this._id = createGuid();\n  this._eventHash = {};\n  recomposite(this);\n  this._shouldRecomposite = false;\n}\n\nObject.defineProperties(CompositeEntityCollection.prototype, {\n  /**\n   * Gets the event that is fired when entities are added or removed from the collection.\n   * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Event}\n   */\n  collectionChanged: {\n    get: function () {\n      return this._composite._collectionChanged;\n    },\n  },\n  /**\n   * Gets a globally unique identifier for this collection.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {string}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * Gets the array of Entity instances in the collection.\n   * This array should not be modified directly.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {Entity[]}\n   */\n  values: {\n    get: function () {\n      return this._composite.values;\n    },\n  },\n  /**\n   * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.\n   * @memberof CompositeEntityCollection.prototype\n   * @readonly\n   * @type {DataSource|CompositeEntityCollection}\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n});\n\n/**\n * Adds a collection to the composite.\n *\n * @param {EntityCollection} collection the collection to add.\n * @param {number} [index] the index to add the collection at.  If omitted, the collection will\n *                         added on top of all existing collections.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.\n */\nCompositeEntityCollection.prototype.addCollection = function (\n  collection,\n  index,\n) {\n  const hasIndex = defined(index);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._collections.length) {\n      throw new DeveloperError(\n        \"index must be less than or equal to the number of collections.\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._collections.length;\n    this._collections.push(collection);\n  } else {\n    this._collections.splice(index, 0, collection);\n  }\n\n  recomposite(this);\n};\n\n/**\n * Removes a collection from this composite, if present.\n *\n * @param {EntityCollection} collection The collection to remove.\n * @returns {boolean} true if the collection was in the composite and was removed,\n *                    false if the collection was not in the composite.\n */\nCompositeEntityCollection.prototype.removeCollection = function (collection) {\n  const index = this._collections.indexOf(collection);\n  if (index !== -1) {\n    this._collections.splice(index, 1);\n    recomposite(this);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all collections from this composite.\n */\nCompositeEntityCollection.prototype.removeAllCollections = function () {\n  this._collections.length = 0;\n  recomposite(this);\n};\n\n/**\n * Checks to see if the composite contains a given collection.\n *\n * @param {EntityCollection} collection the collection to check for.\n * @returns {boolean} true if the composite contains the collection, false otherwise.\n */\nCompositeEntityCollection.prototype.containsCollection = function (collection) {\n  return this._collections.indexOf(collection) !== -1;\n};\n\n/**\n * Returns true if the provided entity is in this collection, false otherwise.\n *\n * @param {Entity} entity The entity.\n * @returns {boolean} true if the provided entity is in this collection, false otherwise.\n */\nCompositeEntityCollection.prototype.contains = function (entity) {\n  return this._composite.contains(entity);\n};\n\n/**\n * Determines the index of a given collection in the composite.\n *\n * @param {EntityCollection} collection The collection to find the index of.\n * @returns {number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.\n */\nCompositeEntityCollection.prototype.indexOfCollection = function (collection) {\n  return this._collections.indexOf(collection);\n};\n\n/**\n * Gets a collection by index from the composite.\n *\n * @param {number} index the index to retrieve.\n */\nCompositeEntityCollection.prototype.getCollection = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._collections[index];\n};\n\n/**\n * Gets the number of collections in this composite.\n */\nCompositeEntityCollection.prototype.getCollectionsLength = function () {\n  return this._collections.length;\n};\n\nfunction getCollectionIndex(collections, collection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(collection)) {\n    throw new DeveloperError(\"collection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const index = collections.indexOf(collection);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"collection is not in this composite.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\n\nfunction swapCollections(composite, i, j) {\n  const arr = composite._collections;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n\n  recomposite(composite);\n}\n\n/**\n * Raises a collection up one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.raiseCollection = function (collection) {\n  const index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index + 1);\n};\n\n/**\n * Lowers a collection down one position in the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.lowerCollection = function (collection) {\n  const index = getCollectionIndex(this._collections, collection);\n  swapCollections(this, index, index - 1);\n};\n\n/**\n * Raises a collection to the top of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.raiseCollectionToTop = function (\n  collection,\n) {\n  const index = getCollectionIndex(this._collections, collection);\n  if (index === this._collections.length - 1) {\n    return;\n  }\n  this._collections.splice(index, 1);\n  this._collections.push(collection);\n\n  recomposite(this);\n};\n\n/**\n * Lowers a collection to the bottom of the composite.\n *\n * @param {EntityCollection} collection the collection to move.\n *\n * @exception {DeveloperError} collection is not in this composite.\n */\nCompositeEntityCollection.prototype.lowerCollectionToBottom = function (\n  collection,\n) {\n  const index = getCollectionIndex(this._collections, collection);\n  if (index === 0) {\n    return;\n  }\n  this._collections.splice(index, 1);\n  this._collections.splice(0, 0, collection);\n\n  recomposite(this);\n};\n\n/**\n * Prevents {@link EntityCollection#collectionChanged} events from being raised\n * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which\n * point a single event will be raised that covers all suspended operations.\n * This allows for many items to be added and removed efficiently.\n * While events are suspended, recompositing of the collections will\n * also be suspended, as this can be a costly operation.\n * This function can be safely called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n */\nCompositeEntityCollection.prototype.suspendEvents = function () {\n  this._suspendCount++;\n  this._composite.suspendEvents();\n};\n\n/**\n * Resumes raising {@link EntityCollection#collectionChanged} events immediately\n * when an item is added or removed.  Any modifications made while while events were suspended\n * will be triggered as a single event when this function is called.  This function also ensures\n * the collection is recomposited if events are also resumed.\n * This function is reference counted and can safely be called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n *\n * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.\n */\nCompositeEntityCollection.prototype.resumeEvents = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._suspendCount === 0) {\n    throw new DeveloperError(\n      \"resumeEvents can not be called before suspendEvents.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._suspendCount--;\n  // recomposite before triggering events (but only if required for performance) that might depend on a composited collection\n  if (this._shouldRecomposite && this._suspendCount === 0) {\n    recomposite(this);\n    this._shouldRecomposite = false;\n  }\n\n  this._composite.resumeEvents();\n};\n\n/**\n * Computes the maximum availability of the entities in the collection.\n * If the collection contains a mix of infinitely available data and non-infinite data,\n * It will return the interval pertaining to the non-infinite data only.  If all\n * data is infinite, an infinite interval will be returned.\n *\n * @returns {TimeInterval} The availability of entities in the collection.\n */\nCompositeEntityCollection.prototype.computeAvailability = function () {\n  return this._composite.computeAvailability();\n};\n\n/**\n * Gets an entity with the specified id.\n *\n * @param {string} id The id of the entity to retrieve.\n * @returns {Entity|undefined} The entity with the provided id or undefined if the id did not exist in the collection.\n */\nCompositeEntityCollection.prototype.getById = function (id) {\n  return this._composite.getById(id);\n};\n\nCompositeEntityCollection.prototype._onCollectionChanged = function (\n  collection,\n  added,\n  removed,\n) {\n  const collections = this._collectionsCopy;\n  const collectionsLength = collections.length;\n  const composite = this._composite;\n  composite.suspendEvents();\n\n  let i;\n  let q;\n  let entity;\n  let compositeEntity;\n  const removedLength = removed.length;\n  const eventHash = this._eventHash;\n  const collectionId = collection.id;\n  for (i = 0; i < removedLength; i++) {\n    const removedEntity = removed[i];\n    unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);\n\n    const removedId = removedEntity.id;\n    //Check if the removed entity exists in any of the remaining collections\n    //If so, we clean and remerge it.\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(removedId);\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(removedId);\n          clean(compositeEntity);\n        }\n        compositeEntity.merge(entity);\n      }\n    }\n    //We never retrieved the compositeEntity, which means it no longer\n    //exists in any of the collections, remove it from the composite.\n    if (!defined(compositeEntity)) {\n      composite.removeById(removedId);\n    }\n    compositeEntity = undefined;\n  }\n\n  const addedLength = added.length;\n  for (i = 0; i < addedLength; i++) {\n    const addedEntity = added[i];\n    subscribeToEntity(this, eventHash, collectionId, addedEntity);\n\n    const addedId = addedEntity.id;\n    //We know the added entity exists in at least one collection,\n    //but we need to check all collections and re-merge in order\n    //to maintain the priority of properties.\n    for (q = collectionsLength - 1; q >= 0; q--) {\n      entity = collections[q].getById(addedId);\n      if (defined(entity)) {\n        if (!defined(compositeEntity)) {\n          compositeEntity = composite.getById(addedId);\n          if (!defined(compositeEntity)) {\n            entityOptionsScratch.id = addedId;\n            compositeEntity = new Entity(entityOptionsScratch);\n            composite.add(compositeEntity);\n          } else {\n            clean(compositeEntity);\n          }\n        }\n        compositeEntity.merge(entity);\n      }\n    }\n    compositeEntity = undefined;\n  }\n\n  composite.resumeEvents();\n};\n\nCompositeEntityCollection.prototype._onDefinitionChanged = function (\n  entity,\n  propertyName,\n  newValue,\n  oldValue,\n) {\n  const collections = this._collections;\n  const composite = this._composite;\n\n  const collectionsLength = collections.length;\n  const id = entity.id;\n  const compositeEntity = composite.getById(id);\n  let compositeProperty = compositeEntity[propertyName];\n  const newProperty = !defined(compositeProperty);\n\n  let firstTime = true;\n  for (let q = collectionsLength - 1; q >= 0; q--) {\n    const innerEntity = collections[q].getById(entity.id);\n    if (defined(innerEntity)) {\n      const property = innerEntity[propertyName];\n      if (defined(property)) {\n        if (firstTime) {\n          firstTime = false;\n          //We only want to clone if the property is also mergeable.\n          //This ensures that leaf properties are referenced and not copied,\n          //which is the entire point of compositing.\n          if (defined(property.merge) && defined(property.clone)) {\n            compositeProperty = property.clone(compositeProperty);\n          } else {\n            compositeProperty = property;\n            break;\n          }\n        }\n        compositeProperty.merge(property);\n      }\n    }\n  }\n\n  if (\n    newProperty &&\n    compositeEntity.propertyNames.indexOf(propertyName) === -1\n  ) {\n    compositeEntity.addProperty(propertyName);\n  }\n\n  compositeEntity[propertyName] = compositeProperty;\n};\nexport default CompositeEntityCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}