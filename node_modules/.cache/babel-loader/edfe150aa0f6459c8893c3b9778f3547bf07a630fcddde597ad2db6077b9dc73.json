{"ast":null,"code":"import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport * as zip from \"@zip.js/zip.js/lib/zip-no-worker.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nconst BILLBOARD_SIZE = 32;\nconst kmlNamespace = \"http://www.opengis.net/kml/2.2\";\nconst gxNamespace = \"http://www.google.com/kml/ext/2.2\";\nconst xmlnsNamespace = \"http://www.w3.org/2000/xmlns/\";\n\n//\n// Handles files external to the KML (eg. textures and models)\n//\nfunction ExternalFileHandler(modelCallback) {\n  this._files = {};\n  this._promises = [];\n  this._count = 0;\n  this._modelCallback = modelCallback;\n}\nconst imageTypeRegex = /^data:image\\/([^,;]+)/;\nExternalFileHandler.prototype.texture = function (texture) {\n  const that = this;\n  let filename;\n  if (typeof texture === \"string\" || texture instanceof Resource) {\n    texture = Resource.createIfNeeded(texture);\n    if (!texture.isDataUri) {\n      return texture.url;\n    }\n\n    // If its a data URI try and get the correct extension and then fetch the blob\n    const regexResult = texture.url.match(imageTypeRegex);\n    filename = `texture_${++this._count}`;\n    if (defined(regexResult)) {\n      filename += `.${regexResult[1]}`;\n    }\n    const promise = texture.fetchBlob().then(function (blob) {\n      that._files[filename] = blob;\n    });\n    this._promises.push(promise);\n    return filename;\n  }\n  if (texture instanceof HTMLCanvasElement) {\n    filename = `texture_${++this._count}.png`;\n    const promise = new Promise(resolve => {\n      texture.toBlob(function (blob) {\n        that._files[filename] = blob;\n        resolve();\n      });\n    });\n    this._promises.push(promise);\n    return filename;\n  }\n  return \"\";\n};\nfunction getModelBlobHander(that, filename) {\n  return function (blob) {\n    that._files[filename] = blob;\n  };\n}\nExternalFileHandler.prototype.model = function (model, time) {\n  const modelCallback = this._modelCallback;\n  if (!defined(modelCallback)) {\n    throw new RuntimeError(\"Encountered a model entity while exporting to KML, but no model callback was supplied.\");\n  }\n  const externalFiles = {};\n  const url = modelCallback(model, time, externalFiles);\n\n  // Iterate through external files and add them to our list once the promise resolves\n  for (const filename in externalFiles) {\n    if (externalFiles.hasOwnProperty(filename)) {\n      const promise = Promise.resolve(externalFiles[filename]);\n      this._promises.push(promise);\n      promise.then(getModelBlobHander(this, filename));\n    }\n  }\n  return url;\n};\nObject.defineProperties(ExternalFileHandler.prototype, {\n  promise: {\n    get: function () {\n      return Promise.all(this._promises);\n    }\n  },\n  files: {\n    get: function () {\n      return this._files;\n    }\n  }\n});\n\n//\n// Handles getting values from properties taking the desired time and default values into account\n//\nfunction ValueGetter(time) {\n  this._time = time;\n}\nValueGetter.prototype.get = function (property, defaultVal, result) {\n  let value;\n  if (defined(property)) {\n    value = defined(property.getValue) ? property.getValue(this._time, result) : property;\n  }\n  return defaultValue(value, defaultVal);\n};\nValueGetter.prototype.getColor = function (property, defaultVal) {\n  const result = this.get(property, defaultVal);\n  if (defined(result)) {\n    return colorToString(result);\n  }\n};\nValueGetter.prototype.getMaterialType = function (property) {\n  if (!defined(property)) {\n    return;\n  }\n  return property.getType(this._time);\n};\n\n//\n// Caches styles so we don't generate a ton of duplicate styles\n//\nfunction StyleCache() {\n  this._ids = {};\n  this._styles = {};\n  this._count = 0;\n}\nStyleCache.prototype.get = function (element) {\n  const ids = this._ids;\n  const key = element.innerHTML;\n  if (defined(ids[key])) {\n    return ids[key];\n  }\n  let styleId = `style-${++this._count}`;\n  element.setAttribute(\"id\", styleId);\n\n  // Store with #\n  styleId = `#${styleId}`;\n  ids[key] = styleId;\n  this._styles[key] = element;\n  return styleId;\n};\nStyleCache.prototype.save = function (parentElement) {\n  const styles = this._styles;\n  const firstElement = parentElement.childNodes[0];\n  for (const key in styles) {\n    if (styles.hasOwnProperty(key)) {\n      parentElement.insertBefore(styles[key], firstElement);\n    }\n  }\n};\n\n//\n// Manages the generation of IDs because an entity may have geometry and a Folder for children\n//\nfunction IdManager() {\n  this._ids = {};\n}\nIdManager.prototype.get = function (id) {\n  if (!defined(id)) {\n    return this.get(createGuid());\n  }\n  const ids = this._ids;\n  if (!defined(ids[id])) {\n    ids[id] = 0;\n    return id;\n  }\n  return `${id.toString()}-${++ids[id]}`;\n};\n\n/**\n * @typedef exportKmlResultKml\n * @type {object}\n * @property {string} kml The generated KML.\n * @property {Object<string, Blob>} externalFiles An object dictionary of external files\n */\n\n/**\n * @typedef exportKmlResultKmz\n * @type {object}\n * @property {Blob} kmz The generated kmz file.\n */\n\n/**\n * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries\n * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For\n * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at\n * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties\n * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using\n * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported\n * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary\n * color is used. Canvas objects are exported as PNG images.\n *\n * @function exportKml\n *\n * @param {object} options An object with the following properties:\n * @param {EntityCollection} options.entities The EntityCollection to export as KML.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for the output file.\n * @param {exportKmlModelCallback} [options.modelCallback] A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.\n * @param {JulianDate} [options.time=entities.computeAvailability().start] The time value to use to get properties that are not time varying in KML.\n * @param {TimeInterval} [options.defaultAvailability=entities.computeAvailability()] The interval that will be sampled if an entity doesn't have an availability.\n * @param {number} [options.sampleDuration=60] The number of seconds to sample properties that are varying in KML.\n * @param {boolean} [options.kmz=false] If true KML and external files will be compressed into a kmz file.\n *\n * @returns {Promise<exportKmlResultKml|exportKmlResultKmz>} A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Export%20KML.html|Cesium Sandcastle KML Export Demo}\n * @example\n * Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     const externalFiles = result.externalFiles\n *     for(const file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *\n */\nfunction exportKml(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const entities = options.entities;\n  const kmz = defaultValue(options.kmz, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entities)) {\n    throw new DeveloperError(\"entities is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Get the state that is passed around during the recursion\n  // This is separated out for testing.\n  const state = exportKml._createState(options);\n\n  // Filter EntityCollection so we only have top level entities\n  const rootEntities = entities.values.filter(function (entity) {\n    return !defined(entity.parent);\n  });\n\n  // Add the <Document>\n  const kmlDoc = state.kmlDoc;\n  const kmlElement = kmlDoc.documentElement;\n  kmlElement.setAttributeNS(xmlnsNamespace, \"xmlns:gx\", gxNamespace);\n  const kmlDocumentElement = kmlDoc.createElement(\"Document\");\n  kmlElement.appendChild(kmlDocumentElement);\n\n  // Create the KML Hierarchy\n  recurseEntities(state, kmlDocumentElement, rootEntities);\n\n  // Write out the <Style> elements\n  state.styleCache.save(kmlDocumentElement);\n\n  // Once all the blobs have resolved return the KML string along with the blob collection\n  const externalFileHandler = state.externalFileHandler;\n  return externalFileHandler.promise.then(function () {\n    const serializer = new XMLSerializer();\n    const kmlString = serializer.serializeToString(state.kmlDoc);\n    if (kmz) {\n      return createKmz(kmlString, externalFileHandler.files);\n    }\n    return {\n      kml: kmlString,\n      externalFiles: externalFileHandler.files\n    };\n  });\n}\nfunction createKmz(kmlString, externalFiles) {\n  const zWorkerUrl = buildModuleUrl(\"ThirdParty/Workers/z-worker-pako.js\");\n  zip.configure({\n    workerScripts: {\n      deflate: [zWorkerUrl, \"./pako_deflate.min.js\"],\n      inflate: [zWorkerUrl, \"./pako_inflate.min.js\"]\n    }\n  });\n  const blobWriter = new zip.BlobWriter();\n  const writer = new zip.ZipWriter(blobWriter);\n  // We need to only write one file at a time so the zip doesn't get corrupted\n  return writer.add(\"doc.kml\", new zip.TextReader(kmlString)).then(function () {\n    const keys = Object.keys(externalFiles);\n    return addExternalFilesToZip(writer, keys, externalFiles, 0);\n  }).then(function () {\n    return writer.close();\n  }).then(function (blob) {\n    return {\n      kmz: blob\n    };\n  });\n}\nfunction addExternalFilesToZip(writer, keys, externalFiles, index) {\n  if (keys.length === index) {\n    return;\n  }\n  const filename = keys[index];\n  return writer.add(filename, new zip.BlobReader(externalFiles[filename])).then(function () {\n    return addExternalFilesToZip(writer, keys, externalFiles, index + 1);\n  });\n}\nexportKml._createState = function (options) {\n  const entities = options.entities;\n  const styleCache = new StyleCache();\n\n  // Use the start time as the default because just in case they define\n  //  properties with an interval even if they don't change.\n  const entityAvailability = entities.computeAvailability();\n  const time = defined(options.time) ? options.time : entityAvailability.start;\n\n  // Figure out how we will sample dynamic position properties\n  let defaultAvailability = defaultValue(options.defaultAvailability, entityAvailability);\n  const sampleDuration = defaultValue(options.sampleDuration, 60);\n\n  // Make sure we don't have infinite availability if we need to sample\n  if (defaultAvailability.start === Iso8601.MINIMUM_VALUE) {\n    if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n      // Infinite, so just use the default\n      defaultAvailability = new TimeInterval();\n    } else {\n      // No start time, so just sample 10 times before the stop\n      JulianDate.addSeconds(defaultAvailability.stop, -10 * sampleDuration, defaultAvailability.start);\n    }\n  } else if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n    // No stop time, so just sample 10 times after the start\n    JulianDate.addSeconds(defaultAvailability.start, 10 * sampleDuration, defaultAvailability.stop);\n  }\n  const externalFileHandler = new ExternalFileHandler(options.modelCallback);\n  const kmlDoc = document.implementation.createDocument(kmlNamespace, \"kml\");\n  return {\n    kmlDoc: kmlDoc,\n    ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.default),\n    idManager: new IdManager(),\n    styleCache: styleCache,\n    externalFileHandler: externalFileHandler,\n    time: time,\n    valueGetter: new ValueGetter(time),\n    sampleDuration: sampleDuration,\n    // Wrap it in a TimeIntervalCollection because that is what entity.availability is\n    defaultAvailability: new TimeIntervalCollection([defaultAvailability])\n  };\n};\nfunction recurseEntities(state, parentNode, entities) {\n  const kmlDoc = state.kmlDoc;\n  const styleCache = state.styleCache;\n  const valueGetter = state.valueGetter;\n  const idManager = state.idManager;\n  const count = entities.length;\n  let overlays;\n  let geometries;\n  let styles;\n  for (let i = 0; i < count; ++i) {\n    const entity = entities[i];\n    overlays = [];\n    geometries = [];\n    styles = [];\n    createPoint(state, entity, geometries, styles);\n    createLineString(state, entity.polyline, geometries, styles);\n    createPolygon(state, entity.rectangle, geometries, styles, overlays);\n    createPolygon(state, entity.polygon, geometries, styles, overlays);\n    createModel(state, entity, entity.model, geometries, styles);\n    let timeSpan;\n    const availability = entity.availability;\n    if (defined(availability)) {\n      timeSpan = kmlDoc.createElement(\"TimeSpan\");\n      if (!JulianDate.equals(availability.start, Iso8601.MINIMUM_VALUE)) {\n        timeSpan.appendChild(createBasicElementWithText(kmlDoc, \"begin\", JulianDate.toIso8601(availability.start)));\n      }\n      if (!JulianDate.equals(availability.stop, Iso8601.MAXIMUM_VALUE)) {\n        timeSpan.appendChild(createBasicElementWithText(kmlDoc, \"end\", JulianDate.toIso8601(availability.stop)));\n      }\n    }\n    for (let overlayIndex = 0; overlayIndex < overlays.length; ++overlayIndex) {\n      const overlay = overlays[overlayIndex];\n      overlay.setAttribute(\"id\", idManager.get(entity.id));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"name\", entity.name));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      if (defined(timeSpan)) {\n        overlay.appendChild(timeSpan);\n      }\n      parentNode.appendChild(overlay);\n    }\n    const geometryCount = geometries.length;\n    if (geometryCount > 0) {\n      const placemark = kmlDoc.createElement(\"Placemark\");\n      placemark.setAttribute(\"id\", idManager.get(entity.id));\n      let name = entity.name;\n      const labelGraphics = entity.label;\n      if (defined(labelGraphics)) {\n        const labelStyle = kmlDoc.createElement(\"LabelStyle\");\n\n        // KML only shows the name as a label, so just change the name if we need to show a label\n        const text = valueGetter.get(labelGraphics.text);\n        name = defined(text) && text.length > 0 ? text : name;\n        const color = valueGetter.getColor(labelGraphics.fillColor);\n        if (defined(color)) {\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n        }\n        const scale = valueGetter.get(labelGraphics.scale);\n        if (defined(scale)) {\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n        }\n        styles.push(labelStyle);\n      }\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"name\", name));\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      if (defined(timeSpan)) {\n        placemark.appendChild(timeSpan);\n      }\n      parentNode.appendChild(placemark);\n      const styleCount = styles.length;\n      if (styleCount > 0) {\n        const style = kmlDoc.createElement(\"Style\");\n        for (let styleIndex = 0; styleIndex < styleCount; ++styleIndex) {\n          style.appendChild(styles[styleIndex]);\n        }\n        placemark.appendChild(createBasicElementWithText(kmlDoc, \"styleUrl\", styleCache.get(style)));\n      }\n      if (geometries.length === 1) {\n        placemark.appendChild(geometries[0]);\n      } else if (geometries.length > 1) {\n        const multigeometry = kmlDoc.createElement(\"MultiGeometry\");\n        for (let geometryIndex = 0; geometryIndex < geometryCount; ++geometryIndex) {\n          multigeometry.appendChild(geometries[geometryIndex]);\n        }\n        placemark.appendChild(multigeometry);\n      }\n    }\n    const children = entity._children;\n    if (children.length > 0) {\n      const folderNode = kmlDoc.createElement(\"Folder\");\n      folderNode.setAttribute(\"id\", idManager.get(entity.id));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"name\", entity.name));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      parentNode.appendChild(folderNode);\n      recurseEntities(state, folderNode, children);\n    }\n  }\n}\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchJulianDate = new JulianDate();\nfunction createPoint(state, entity, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  const pointGraphics = defaultValue(entity.billboard, entity.point);\n  if (!defined(pointGraphics) && !defined(entity.path)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, pointGraphics, geometries, styles);\n    return;\n  }\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(scratchCartesian3, ellipsoid));\n  const pointGeometry = kmlDoc.createElement(\"Point\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, pointGraphics.heightReference));\n  pointGeometry.appendChild(altitudeMode);\n  pointGeometry.appendChild(coordinates);\n  geometries.push(pointGeometry);\n\n  // Create style\n  const iconStyle = pointGraphics instanceof BillboardGraphics ? createIconStyleFromBillboard(state, pointGraphics) : createIconStyleFromPoint(state, pointGraphics);\n  styles.push(iconStyle);\n}\nfunction createTracks(state, entity, pointGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  let intervals;\n  const entityPositionProperty = entity.position;\n  let useEntityPositionProperty = true;\n  if (entityPositionProperty instanceof CompositePositionProperty) {\n    intervals = entityPositionProperty.intervals;\n    useEntityPositionProperty = false;\n  } else {\n    intervals = defaultValue(entity.availability, state.defaultAvailability);\n  }\n  const isModel = pointGraphics instanceof ModelGraphics;\n  let i, j, times;\n  const tracks = [];\n  for (i = 0; i < intervals.length; ++i) {\n    const interval = intervals.get(i);\n    let positionProperty = useEntityPositionProperty ? entityPositionProperty : interval.data;\n    const trackAltitudeMode = kmlDoc.createElement(\"altitudeMode\");\n    // This is something that KML importing uses to handle clampToGround,\n    //  so just extract the internal property and set the altitudeMode.\n    if (positionProperty instanceof ScaledPositionProperty) {\n      positionProperty = positionProperty._value;\n      trackAltitudeMode.appendChild(getAltitudeMode(state, HeightReference.CLAMP_TO_GROUND));\n    } else if (defined(pointGraphics)) {\n      trackAltitudeMode.appendChild(getAltitudeMode(state, pointGraphics.heightReference));\n    } else {\n      // Path graphics only, which has no height reference\n      trackAltitudeMode.appendChild(getAltitudeMode(state, HeightReference.NONE));\n    }\n    const positionTimes = [];\n    const positionValues = [];\n    if (positionProperty.isConstant) {\n      valueGetter.get(positionProperty, undefined, scratchCartesian3);\n      const constCoordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(scratchCartesian3, ellipsoid));\n\n      // This interval is constant so add a track with the same position\n      positionTimes.push(JulianDate.toIso8601(interval.start));\n      positionValues.push(constCoordinates);\n      positionTimes.push(JulianDate.toIso8601(interval.stop));\n      positionValues.push(constCoordinates);\n    } else if (positionProperty instanceof SampledPositionProperty) {\n      times = positionProperty._property._times;\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        positionProperty.getValueInReferenceFrame(times[j], ReferenceFrame.FIXED, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else if (positionProperty instanceof SampledProperty) {\n      times = positionProperty._times;\n      const values = positionProperty._values;\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        Cartesian3.fromArray(values, j * 3, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else {\n      const duration = state.sampleDuration;\n      interval.start.clone(scratchJulianDate);\n      if (!interval.isStartIncluded) {\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n      const stopDate = interval.stop;\n      while (JulianDate.lessThan(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n      if (interval.isStopIncluded && JulianDate.equals(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    }\n    const trackGeometry = kmlDoc.createElementNS(gxNamespace, \"Track\");\n    trackGeometry.appendChild(trackAltitudeMode);\n    for (let k = 0; k < positionTimes.length; ++k) {\n      const when = createBasicElementWithText(kmlDoc, \"when\", positionTimes[k]);\n      const coord = createBasicElementWithText(kmlDoc, \"coord\", positionValues[k], gxNamespace);\n      trackGeometry.appendChild(when);\n      trackGeometry.appendChild(coord);\n    }\n    if (isModel) {\n      trackGeometry.appendChild(createModelGeometry(state, pointGraphics));\n    }\n    tracks.push(trackGeometry);\n  }\n\n  // If one track, then use it otherwise combine into a multitrack\n  if (tracks.length === 1) {\n    geometries.push(tracks[0]);\n  } else if (tracks.length > 1) {\n    const multiTrackGeometry = kmlDoc.createElementNS(gxNamespace, \"MultiTrack\");\n    for (i = 0; i < tracks.length; ++i) {\n      multiTrackGeometry.appendChild(tracks[i]);\n    }\n    geometries.push(multiTrackGeometry);\n  }\n\n  // Create style\n  if (defined(pointGraphics) && !isModel) {\n    const iconStyle = pointGraphics instanceof BillboardGraphics ? createIconStyleFromBillboard(state, pointGraphics) : createIconStyleFromPoint(state, pointGraphics);\n    styles.push(iconStyle);\n  }\n\n  // See if we have a line that needs to be drawn\n  const path = entity.path;\n  if (defined(path)) {\n    const width = valueGetter.get(path.width);\n    const material = path.material;\n    if (defined(material) || defined(width)) {\n      const lineStyle = kmlDoc.createElement(\"LineStyle\");\n      if (defined(width)) {\n        lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n      }\n      processMaterial(state, material, lineStyle);\n      styles.push(lineStyle);\n    }\n  }\n}\nfunction createIconStyleFromPoint(state, pointGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n  const color = valueGetter.getColor(pointGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n  const pixelSize = valueGetter.get(pointGraphics.pixelSize);\n  if (defined(pixelSize)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", pixelSize / BILLBOARD_SIZE));\n  }\n  return iconStyle;\n}\nfunction createIconStyleFromBillboard(state, billboardGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n  let image = valueGetter.get(billboardGraphics.image);\n  if (defined(image)) {\n    image = externalFileHandler.texture(image);\n    const icon = kmlDoc.createElement(\"Icon\");\n    icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", image));\n    const imageSubRegion = valueGetter.get(billboardGraphics.imageSubRegion);\n    if (defined(imageSubRegion)) {\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"x\", imageSubRegion.x, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"y\", imageSubRegion.y, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"w\", imageSubRegion.width, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"h\", imageSubRegion.height, gxNamespace));\n    }\n    iconStyle.appendChild(icon);\n  }\n  const color = valueGetter.getColor(billboardGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n  let scale = valueGetter.get(billboardGraphics.scale);\n  if (defined(scale)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n  }\n  const pixelOffset = valueGetter.get(billboardGraphics.pixelOffset);\n  if (defined(pixelOffset)) {\n    scale = defaultValue(scale, 1.0);\n    Cartesian2.divideByScalar(pixelOffset, scale, pixelOffset);\n    const width = valueGetter.get(billboardGraphics.width, BILLBOARD_SIZE);\n    const height = valueGetter.get(billboardGraphics.height, BILLBOARD_SIZE);\n\n    // KML Hotspots are from the bottom left, but we work from the top left\n\n    // Move to left\n    const horizontalOrigin = valueGetter.get(billboardGraphics.horizontalOrigin, HorizontalOrigin.CENTER);\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      pixelOffset.x -= width * 0.5;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      pixelOffset.x -= width;\n    }\n\n    // Move to bottom\n    const verticalOrigin = valueGetter.get(billboardGraphics.verticalOrigin, VerticalOrigin.CENTER);\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      pixelOffset.y += height;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      pixelOffset.y += height * 0.5;\n    }\n    const hotSpot = kmlDoc.createElement(\"hotSpot\");\n    hotSpot.setAttribute(\"x\", -pixelOffset.x);\n    hotSpot.setAttribute(\"y\", pixelOffset.y);\n    hotSpot.setAttribute(\"xunits\", \"pixels\");\n    hotSpot.setAttribute(\"yunits\", \"pixels\");\n    iconStyle.appendChild(hotSpot);\n  }\n\n  // We can only specify heading so if axis isn't Z, then we skip the rotation\n  // GE treats a heading of zero as no heading but can still point north using a 360 degree angle\n  let rotation = valueGetter.get(billboardGraphics.rotation);\n  const alignedAxis = valueGetter.get(billboardGraphics.alignedAxis);\n  if (defined(rotation) && Cartesian3.equals(Cartesian3.UNIT_Z, alignedAxis)) {\n    rotation = CesiumMath.toDegrees(-rotation);\n    if (rotation === 0) {\n      rotation = 360;\n    }\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"heading\", rotation));\n  }\n  return iconStyle;\n}\nfunction createLineString(state, polylineGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  if (!defined(polylineGraphics)) {\n    return;\n  }\n  const lineStringGeometry = kmlDoc.createElement(\"LineString\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  const clampToGround = valueGetter.get(polylineGraphics.clampToGround, false);\n  let altitudeModeText;\n  if (clampToGround) {\n    lineStringGeometry.appendChild(createBasicElementWithText(kmlDoc, \"tessellate\", true));\n    altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n  } else {\n    altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n  }\n  altitudeMode.appendChild(altitudeModeText);\n  lineStringGeometry.appendChild(altitudeMode);\n\n  // Set coordinates\n  const positionsProperty = polylineGraphics.positions;\n  const cartesians = valueGetter.get(positionsProperty);\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(cartesians, ellipsoid));\n  lineStringGeometry.appendChild(coordinates);\n\n  // Set draw order\n  const zIndex = valueGetter.get(polylineGraphics.zIndex);\n  if (clampToGround && defined(zIndex)) {\n    lineStringGeometry.appendChild(createBasicElementWithText(kmlDoc, \"drawOrder\", zIndex, gxNamespace));\n  }\n  geometries.push(lineStringGeometry);\n\n  // Create style\n  const lineStyle = kmlDoc.createElement(\"LineStyle\");\n  const width = valueGetter.get(polylineGraphics.width);\n  if (defined(width)) {\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n  }\n  processMaterial(state, polylineGraphics.material, lineStyle);\n  styles.push(lineStyle);\n}\nfunction getRectangleBoundaries(state, rectangleGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  let height = valueGetter.get(rectangleGraphics.height, 0.0);\n  if (extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n  const coordinatesProperty = rectangleGraphics.coordinates;\n  const rectangle = valueGetter.get(coordinatesProperty);\n  const coordinateStrings = [];\n  const cornerFunction = [Rectangle.northeast, Rectangle.southeast, Rectangle.southwest, Rectangle.northwest];\n  for (let i = 0; i < 4; ++i) {\n    cornerFunction[i](rectangle, scratchCartographic);\n    coordinateStrings.push(`${CesiumMath.toDegrees(scratchCartographic.longitude)},${CesiumMath.toDegrees(scratchCartographic.latitude)},${height}`);\n  }\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", coordinateStrings.join(\" \"));\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  outerBoundaryIs.appendChild(linearRing);\n  return [outerBoundaryIs];\n}\nfunction getLinearRing(state, positions, height, perPositionHeight) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const coordinateStrings = [];\n  const positionCount = positions.length;\n  for (let i = 0; i < positionCount; ++i) {\n    Cartographic.fromCartesian(positions[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(`${CesiumMath.toDegrees(scratchCartographic.longitude)},${CesiumMath.toDegrees(scratchCartographic.latitude)},${perPositionHeight ? scratchCartographic.height : height}`);\n  }\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", coordinateStrings.join(\" \"));\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  return linearRing;\n}\nfunction getPolygonBoundaries(state, polygonGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  let height = valueGetter.get(polygonGraphics.height, 0.0);\n  const perPositionHeight = valueGetter.get(polygonGraphics.perPositionHeight, false);\n  if (!perPositionHeight && extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n  const boundaries = [];\n  const hierarchyProperty = polygonGraphics.hierarchy;\n  const hierarchy = valueGetter.get(hierarchyProperty);\n\n  // Polygon hierarchy can sometimes just be an array of positions\n  const positions = Array.isArray(hierarchy) ? hierarchy : hierarchy.positions;\n\n  // Polygon boundaries\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  outerBoundaryIs.appendChild(getLinearRing(state, positions, height, perPositionHeight));\n  boundaries.push(outerBoundaryIs);\n\n  // Hole boundaries\n  const holes = hierarchy.holes;\n  if (defined(holes)) {\n    const holeCount = holes.length;\n    for (let i = 0; i < holeCount; ++i) {\n      const innerBoundaryIs = kmlDoc.createElement(\"innerBoundaryIs\");\n      innerBoundaryIs.appendChild(getLinearRing(state, holes[i].positions, height, perPositionHeight));\n      boundaries.push(innerBoundaryIs);\n    }\n  }\n  return boundaries;\n}\nfunction createPolygon(state, geometry, geometries, styles, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  if (!defined(geometry)) {\n    return;\n  }\n\n  // Detect textured quads and use ground overlays instead\n  const isRectangle = geometry instanceof RectangleGraphics;\n  if (isRectangle && valueGetter.getMaterialType(geometry.material) === \"Image\") {\n    createGroundOverlay(state, geometry, overlays);\n    return;\n  }\n  const polygonGeometry = kmlDoc.createElement(\"Polygon\");\n  const extrudedHeight = valueGetter.get(geometry.extrudedHeight, 0.0);\n  if (extrudedHeight > 0) {\n    polygonGeometry.appendChild(createBasicElementWithText(kmlDoc, \"extrude\", true));\n  }\n\n  // Set boundaries\n  const boundaries = isRectangle ? getRectangleBoundaries(state, geometry, extrudedHeight) : getPolygonBoundaries(state, geometry, extrudedHeight);\n  const boundaryCount = boundaries.length;\n  for (let i = 0; i < boundaryCount; ++i) {\n    polygonGeometry.appendChild(boundaries[i]);\n  }\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, geometry.heightReference));\n  polygonGeometry.appendChild(altitudeMode);\n  geometries.push(polygonGeometry);\n\n  // Create style\n  const polyStyle = kmlDoc.createElement(\"PolyStyle\");\n  const fill = valueGetter.get(geometry.fill, false);\n  if (fill) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"fill\", fill));\n  }\n  processMaterial(state, geometry.material, polyStyle);\n  const outline = valueGetter.get(geometry.outline, false);\n  if (outline) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"outline\", outline));\n\n    // Outline uses LineStyle\n    const lineStyle = kmlDoc.createElement(\"LineStyle\");\n    const outlineWidth = valueGetter.get(geometry.outlineWidth, 1.0);\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", outlineWidth));\n    const outlineColor = valueGetter.getColor(geometry.outlineColor, Color.BLACK);\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", outlineColor));\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n    styles.push(lineStyle);\n  }\n  styles.push(polyStyle);\n}\nfunction createGroundOverlay(state, rectangleGraphics, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n  const groundOverlay = kmlDoc.createElement(\"GroundOverlay\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, rectangleGraphics.heightReference));\n  groundOverlay.appendChild(altitudeMode);\n  const height = valueGetter.get(rectangleGraphics.height);\n  if (defined(height)) {\n    groundOverlay.appendChild(createBasicElementWithText(kmlDoc, \"altitude\", height));\n  }\n  const rectangle = valueGetter.get(rectangleGraphics.coordinates);\n  const latLonBox = kmlDoc.createElement(\"LatLonBox\");\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"north\", CesiumMath.toDegrees(rectangle.north)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"south\", CesiumMath.toDegrees(rectangle.south)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"east\", CesiumMath.toDegrees(rectangle.east)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"west\", CesiumMath.toDegrees(rectangle.west)));\n  groundOverlay.appendChild(latLonBox);\n\n  // We should only end up here if we have an ImageMaterialProperty\n  const material = valueGetter.get(rectangleGraphics.material);\n  const href = externalFileHandler.texture(material.image);\n  const icon = kmlDoc.createElement(\"Icon\");\n  icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", href));\n  groundOverlay.appendChild(icon);\n  const color = material.color;\n  if (defined(color)) {\n    groundOverlay.appendChild(createBasicElementWithText(kmlDoc, \"color\", colorToString(material.color)));\n  }\n  overlays.push(groundOverlay);\n}\nfunction createModelGeometry(state, modelGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n  const modelGeometry = kmlDoc.createElement(\"Model\");\n  const scale = valueGetter.get(modelGraphics.scale);\n  if (defined(scale)) {\n    const scaleElement = kmlDoc.createElement(\"scale\");\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"x\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"y\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"z\", scale));\n    modelGeometry.appendChild(scaleElement);\n  }\n  const link = kmlDoc.createElement(\"Link\");\n  const uri = externalFileHandler.model(modelGraphics, state.time);\n  link.appendChild(createBasicElementWithText(kmlDoc, \"href\", uri));\n  modelGeometry.appendChild(link);\n  return modelGeometry;\n}\nfunction createModel(state, entity, modelGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  if (!defined(modelGraphics)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, modelGraphics, geometries, styles);\n    return;\n  }\n  const modelGeometry = createModelGeometry(state, modelGraphics);\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, modelGraphics.heightReference));\n  modelGeometry.appendChild(altitudeMode);\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  Cartographic.fromCartesian(scratchCartesian3, ellipsoid, scratchCartographic);\n  const location = kmlDoc.createElement(\"Location\");\n  location.appendChild(createBasicElementWithText(kmlDoc, \"longitude\", CesiumMath.toDegrees(scratchCartographic.longitude)));\n  location.appendChild(createBasicElementWithText(kmlDoc, \"latitude\", CesiumMath.toDegrees(scratchCartographic.latitude)));\n  location.appendChild(createBasicElementWithText(kmlDoc, \"altitude\", scratchCartographic.height));\n  modelGeometry.appendChild(location);\n  geometries.push(modelGeometry);\n}\nfunction processMaterial(state, materialProperty, style) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  if (!defined(materialProperty)) {\n    return;\n  }\n  const material = valueGetter.get(materialProperty);\n  if (!defined(material)) {\n    return;\n  }\n  let color;\n  const type = valueGetter.getMaterialType(materialProperty);\n  let outlineColor;\n  let outlineWidth;\n  switch (type) {\n    case \"Image\":\n      // Image materials are only able to be represented on rectangles, so if we make it\n      //  here we can't texture a generic polygon or polyline in KML, so just use white.\n      color = colorToString(Color.WHITE);\n      break;\n    case \"Color\":\n    case \"Grid\":\n    case \"PolylineGlow\":\n    case \"PolylineArrow\":\n    case \"PolylineDash\":\n      color = colorToString(material.color);\n      break;\n    case \"PolylineOutline\":\n      color = colorToString(material.color);\n      outlineColor = colorToString(material.outlineColor);\n      outlineWidth = material.outlineWidth;\n      style.appendChild(createBasicElementWithText(kmlDoc, \"outerColor\", outlineColor, gxNamespace));\n      style.appendChild(createBasicElementWithText(kmlDoc, \"outerWidth\", outlineWidth, gxNamespace));\n      break;\n    case \"Stripe\":\n      color = colorToString(material.oddColor);\n      break;\n  }\n  if (defined(color)) {\n    style.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    style.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n}\nfunction getAltitudeMode(state, heightReferenceProperty) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const heightReference = valueGetter.get(heightReferenceProperty, HeightReference.NONE);\n  let altitudeModeText;\n  switch (heightReference) {\n    case HeightReference.NONE:\n      altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n      break;\n    case HeightReference.CLAMP_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n      break;\n    case HeightReference.RELATIVE_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"relativeToGround\");\n      break;\n  }\n  return altitudeModeText;\n}\nfunction getCoordinates(coordinates, ellipsoid) {\n  if (!Array.isArray(coordinates)) {\n    coordinates = [coordinates];\n  }\n  const count = coordinates.length;\n  const coordinateStrings = [];\n  for (let i = 0; i < count; ++i) {\n    Cartographic.fromCartesian(coordinates[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(`${CesiumMath.toDegrees(scratchCartographic.longitude)},${CesiumMath.toDegrees(scratchCartographic.latitude)},${scratchCartographic.height}`);\n  }\n  return coordinateStrings.join(\" \");\n}\nfunction createBasicElementWithText(kmlDoc, elementName, elementValue, namespace) {\n  elementValue = defaultValue(elementValue, \"\");\n  if (typeof elementValue === \"boolean\") {\n    elementValue = elementValue ? \"1\" : \"0\";\n  }\n\n  // Create element with optional namespace\n  const element = defined(namespace) ? kmlDoc.createElementNS(namespace, elementName) : kmlDoc.createElement(elementName);\n\n  // Wrap value in CDATA section if it contains HTML\n  const text = elementValue === \"string\" && elementValue.indexOf(\"<\") !== -1 ? kmlDoc.createCDATASection(elementValue) : kmlDoc.createTextNode(elementValue);\n  element.appendChild(text);\n  return element;\n}\nfunction colorToString(color) {\n  let result = \"\";\n  const bytes = color.toBytes();\n  for (let i = 3; i >= 0; --i) {\n    result += bytes[i] < 16 ? `0${bytes[i].toString(16)}` : bytes[i].toString(16);\n  }\n  return result;\n}\n\n/**\n * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.\n * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,\n * or otherwise returned with the KML string when exporting.\n *\n * @callback exportKmlModelCallback\n *\n * @param {ModelGraphics} model The ModelGraphics instance for an Entity.\n * @param {JulianDate} time The time that any properties should use to get the value.\n * @param {object} externalFiles An object that maps a filename to a Blob or a Promise that resolves to a Blob.\n * @returns {string} The URL to use for the href in the KML document.\n */\nexport default exportKml;","map":{"version":3,"names":["buildModuleUrl","Cartesian2","Cartesian3","Cartographic","Color","createGuid","defaultValue","defined","DeveloperError","Ellipsoid","Iso8601","JulianDate","CesiumMath","Rectangle","ReferenceFrame","Resource","RuntimeError","TimeInterval","TimeIntervalCollection","HeightReference","HorizontalOrigin","VerticalOrigin","zip","BillboardGraphics","CompositePositionProperty","ModelGraphics","RectangleGraphics","SampledPositionProperty","SampledProperty","ScaledPositionProperty","BILLBOARD_SIZE","kmlNamespace","gxNamespace","xmlnsNamespace","ExternalFileHandler","modelCallback","_files","_promises","_count","_modelCallback","imageTypeRegex","prototype","texture","that","filename","createIfNeeded","isDataUri","url","regexResult","match","promise","fetchBlob","then","blob","push","HTMLCanvasElement","Promise","resolve","toBlob","getModelBlobHander","model","time","externalFiles","hasOwnProperty","Object","defineProperties","get","all","files","ValueGetter","_time","property","defaultVal","result","value","getValue","getColor","colorToString","getMaterialType","getType","StyleCache","_ids","_styles","element","ids","key","innerHTML","styleId","setAttribute","save","parentElement","styles","firstElement","childNodes","insertBefore","IdManager","id","toString","exportKml","options","EMPTY_OBJECT","entities","kmz","state","_createState","rootEntities","values","filter","entity","parent","kmlDoc","kmlElement","documentElement","setAttributeNS","kmlDocumentElement","createElement","appendChild","recurseEntities","styleCache","externalFileHandler","serializer","XMLSerializer","kmlString","serializeToString","createKmz","kml","zWorkerUrl","configure","workerScripts","deflate","inflate","blobWriter","BlobWriter","writer","ZipWriter","add","TextReader","keys","addExternalFilesToZip","close","index","length","BlobReader","entityAvailability","computeAvailability","start","defaultAvailability","sampleDuration","MINIMUM_VALUE","stop","MAXIMUM_VALUE","addSeconds","document","implementation","createDocument","ellipsoid","default","idManager","valueGetter","parentNode","count","overlays","geometries","i","createPoint","createLineString","polyline","createPolygon","rectangle","polygon","createModel","timeSpan","availability","equals","createBasicElementWithText","toIso8601","overlayIndex","overlay","name","show","description","geometryCount","placemark","labelGraphics","label","labelStyle","text","color","fillColor","scale","styleCount","style","styleIndex","multigeometry","geometryIndex","children","_children","folderNode","scratchCartesian3","scratchCartographic","scratchJulianDate","pointGraphics","billboard","point","path","entityPositionProperty","position","isConstant","createTracks","undefined","coordinates","getCoordinates","pointGeometry","altitudeMode","getAltitudeMode","heightReference","iconStyle","createIconStyleFromBillboard","createIconStyleFromPoint","intervals","useEntityPositionProperty","isModel","j","times","tracks","interval","positionProperty","data","trackAltitudeMode","_value","CLAMP_TO_GROUND","NONE","positionTimes","positionValues","constCoordinates","_property","_times","getValueInReferenceFrame","FIXED","_values","fromArray","duration","clone","isStartIncluded","stopDate","lessThan","isStopIncluded","trackGeometry","createElementNS","k","when","coord","createModelGeometry","multiTrackGeometry","width","material","lineStyle","processMaterial","pixelSize","billboardGraphics","image","icon","imageSubRegion","x","y","height","pixelOffset","divideByScalar","horizontalOrigin","CENTER","RIGHT","verticalOrigin","TOP","hotSpot","rotation","alignedAxis","UNIT_Z","toDegrees","polylineGraphics","lineStringGeometry","clampToGround","altitudeModeText","createTextNode","positionsProperty","positions","cartesians","zIndex","getRectangleBoundaries","rectangleGraphics","extrudedHeight","coordinatesProperty","coordinateStrings","cornerFunction","northeast","southeast","southwest","northwest","longitude","latitude","join","outerBoundaryIs","linearRing","getLinearRing","perPositionHeight","positionCount","fromCartesian","getPolygonBoundaries","polygonGraphics","boundaries","hierarchyProperty","hierarchy","Array","isArray","holes","holeCount","innerBoundaryIs","geometry","isRectangle","createGroundOverlay","polygonGeometry","boundaryCount","polyStyle","fill","outline","outlineWidth","outlineColor","BLACK","groundOverlay","latLonBox","north","south","east","west","href","modelGraphics","modelGeometry","scaleElement","link","uri","location","materialProperty","type","WHITE","oddColor","heightReferenceProperty","RELATIVE_TO_GROUND","elementName","elementValue","namespace","indexOf","createCDATASection","bytes","toBytes"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/exportKml.js"],"sourcesContent":["import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport * as zip from \"@zip.js/zip.js/lib/zip-no-worker.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\n\nconst BILLBOARD_SIZE = 32;\nconst kmlNamespace = \"http://www.opengis.net/kml/2.2\";\nconst gxNamespace = \"http://www.google.com/kml/ext/2.2\";\nconst xmlnsNamespace = \"http://www.w3.org/2000/xmlns/\";\n\n//\n// Handles files external to the KML (eg. textures and models)\n//\nfunction ExternalFileHandler(modelCallback) {\n  this._files = {};\n  this._promises = [];\n  this._count = 0;\n  this._modelCallback = modelCallback;\n}\n\nconst imageTypeRegex = /^data:image\\/([^,;]+)/;\nExternalFileHandler.prototype.texture = function (texture) {\n  const that = this;\n  let filename;\n\n  if (typeof texture === \"string\" || texture instanceof Resource) {\n    texture = Resource.createIfNeeded(texture);\n    if (!texture.isDataUri) {\n      return texture.url;\n    }\n\n    // If its a data URI try and get the correct extension and then fetch the blob\n    const regexResult = texture.url.match(imageTypeRegex);\n    filename = `texture_${++this._count}`;\n    if (defined(regexResult)) {\n      filename += `.${regexResult[1]}`;\n    }\n\n    const promise = texture.fetchBlob().then(function (blob) {\n      that._files[filename] = blob;\n    });\n\n    this._promises.push(promise);\n\n    return filename;\n  }\n\n  if (texture instanceof HTMLCanvasElement) {\n    filename = `texture_${++this._count}.png`;\n    const promise = new Promise((resolve) => {\n      texture.toBlob(function (blob) {\n        that._files[filename] = blob;\n        resolve();\n      });\n    });\n    this._promises.push(promise);\n\n    return filename;\n  }\n\n  return \"\";\n};\n\nfunction getModelBlobHander(that, filename) {\n  return function (blob) {\n    that._files[filename] = blob;\n  };\n}\n\nExternalFileHandler.prototype.model = function (model, time) {\n  const modelCallback = this._modelCallback;\n  if (!defined(modelCallback)) {\n    throw new RuntimeError(\n      \"Encountered a model entity while exporting to KML, but no model callback was supplied.\",\n    );\n  }\n\n  const externalFiles = {};\n  const url = modelCallback(model, time, externalFiles);\n\n  // Iterate through external files and add them to our list once the promise resolves\n  for (const filename in externalFiles) {\n    if (externalFiles.hasOwnProperty(filename)) {\n      const promise = Promise.resolve(externalFiles[filename]);\n      this._promises.push(promise);\n\n      promise.then(getModelBlobHander(this, filename));\n    }\n  }\n\n  return url;\n};\n\nObject.defineProperties(ExternalFileHandler.prototype, {\n  promise: {\n    get: function () {\n      return Promise.all(this._promises);\n    },\n  },\n  files: {\n    get: function () {\n      return this._files;\n    },\n  },\n});\n\n//\n// Handles getting values from properties taking the desired time and default values into account\n//\nfunction ValueGetter(time) {\n  this._time = time;\n}\n\nValueGetter.prototype.get = function (property, defaultVal, result) {\n  let value;\n  if (defined(property)) {\n    value = defined(property.getValue)\n      ? property.getValue(this._time, result)\n      : property;\n  }\n\n  return defaultValue(value, defaultVal);\n};\n\nValueGetter.prototype.getColor = function (property, defaultVal) {\n  const result = this.get(property, defaultVal);\n  if (defined(result)) {\n    return colorToString(result);\n  }\n};\n\nValueGetter.prototype.getMaterialType = function (property) {\n  if (!defined(property)) {\n    return;\n  }\n\n  return property.getType(this._time);\n};\n\n//\n// Caches styles so we don't generate a ton of duplicate styles\n//\nfunction StyleCache() {\n  this._ids = {};\n  this._styles = {};\n  this._count = 0;\n}\n\nStyleCache.prototype.get = function (element) {\n  const ids = this._ids;\n  const key = element.innerHTML;\n  if (defined(ids[key])) {\n    return ids[key];\n  }\n\n  let styleId = `style-${++this._count}`;\n  element.setAttribute(\"id\", styleId);\n\n  // Store with #\n  styleId = `#${styleId}`;\n  ids[key] = styleId;\n  this._styles[key] = element;\n\n  return styleId;\n};\n\nStyleCache.prototype.save = function (parentElement) {\n  const styles = this._styles;\n\n  const firstElement = parentElement.childNodes[0];\n  for (const key in styles) {\n    if (styles.hasOwnProperty(key)) {\n      parentElement.insertBefore(styles[key], firstElement);\n    }\n  }\n};\n\n//\n// Manages the generation of IDs because an entity may have geometry and a Folder for children\n//\nfunction IdManager() {\n  this._ids = {};\n}\n\nIdManager.prototype.get = function (id) {\n  if (!defined(id)) {\n    return this.get(createGuid());\n  }\n\n  const ids = this._ids;\n  if (!defined(ids[id])) {\n    ids[id] = 0;\n    return id;\n  }\n\n  return `${id.toString()}-${++ids[id]}`;\n};\n\n/**\n * @typedef exportKmlResultKml\n * @type {object}\n * @property {string} kml The generated KML.\n * @property {Object<string, Blob>} externalFiles An object dictionary of external files\n */\n\n/**\n * @typedef exportKmlResultKmz\n * @type {object}\n * @property {Blob} kmz The generated kmz file.\n */\n\n/**\n * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries\n * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For\n * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at\n * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties\n * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using\n * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported\n * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary\n * color is used. Canvas objects are exported as PNG images.\n *\n * @function exportKml\n *\n * @param {object} options An object with the following properties:\n * @param {EntityCollection} options.entities The EntityCollection to export as KML.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for the output file.\n * @param {exportKmlModelCallback} [options.modelCallback] A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.\n * @param {JulianDate} [options.time=entities.computeAvailability().start] The time value to use to get properties that are not time varying in KML.\n * @param {TimeInterval} [options.defaultAvailability=entities.computeAvailability()] The interval that will be sampled if an entity doesn't have an availability.\n * @param {number} [options.sampleDuration=60] The number of seconds to sample properties that are varying in KML.\n * @param {boolean} [options.kmz=false] If true KML and external files will be compressed into a kmz file.\n *\n * @returns {Promise<exportKmlResultKml|exportKmlResultKmz>} A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Export%20KML.html|Cesium Sandcastle KML Export Demo}\n * @example\n * Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     const externalFiles = result.externalFiles\n *     for(const file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *\n */\nfunction exportKml(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const entities = options.entities;\n  const kmz = defaultValue(options.kmz, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entities)) {\n    throw new DeveloperError(\"entities is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Get the state that is passed around during the recursion\n  // This is separated out for testing.\n  const state = exportKml._createState(options);\n\n  // Filter EntityCollection so we only have top level entities\n  const rootEntities = entities.values.filter(function (entity) {\n    return !defined(entity.parent);\n  });\n\n  // Add the <Document>\n  const kmlDoc = state.kmlDoc;\n  const kmlElement = kmlDoc.documentElement;\n  kmlElement.setAttributeNS(xmlnsNamespace, \"xmlns:gx\", gxNamespace);\n  const kmlDocumentElement = kmlDoc.createElement(\"Document\");\n  kmlElement.appendChild(kmlDocumentElement);\n\n  // Create the KML Hierarchy\n  recurseEntities(state, kmlDocumentElement, rootEntities);\n\n  // Write out the <Style> elements\n  state.styleCache.save(kmlDocumentElement);\n\n  // Once all the blobs have resolved return the KML string along with the blob collection\n  const externalFileHandler = state.externalFileHandler;\n  return externalFileHandler.promise.then(function () {\n    const serializer = new XMLSerializer();\n    const kmlString = serializer.serializeToString(state.kmlDoc);\n    if (kmz) {\n      return createKmz(kmlString, externalFileHandler.files);\n    }\n\n    return {\n      kml: kmlString,\n      externalFiles: externalFileHandler.files,\n    };\n  });\n}\n\nfunction createKmz(kmlString, externalFiles) {\n  const zWorkerUrl = buildModuleUrl(\"ThirdParty/Workers/z-worker-pako.js\");\n  zip.configure({\n    workerScripts: {\n      deflate: [zWorkerUrl, \"./pako_deflate.min.js\"],\n      inflate: [zWorkerUrl, \"./pako_inflate.min.js\"],\n    },\n  });\n  const blobWriter = new zip.BlobWriter();\n  const writer = new zip.ZipWriter(blobWriter);\n  // We need to only write one file at a time so the zip doesn't get corrupted\n  return writer\n    .add(\"doc.kml\", new zip.TextReader(kmlString))\n    .then(function () {\n      const keys = Object.keys(externalFiles);\n      return addExternalFilesToZip(writer, keys, externalFiles, 0);\n    })\n    .then(function () {\n      return writer.close();\n    })\n    .then(function (blob) {\n      return {\n        kmz: blob,\n      };\n    });\n}\n\nfunction addExternalFilesToZip(writer, keys, externalFiles, index) {\n  if (keys.length === index) {\n    return;\n  }\n  const filename = keys[index];\n  return writer\n    .add(filename, new zip.BlobReader(externalFiles[filename]))\n    .then(function () {\n      return addExternalFilesToZip(writer, keys, externalFiles, index + 1);\n    });\n}\n\nexportKml._createState = function (options) {\n  const entities = options.entities;\n\n  const styleCache = new StyleCache();\n\n  // Use the start time as the default because just in case they define\n  //  properties with an interval even if they don't change.\n  const entityAvailability = entities.computeAvailability();\n  const time = defined(options.time) ? options.time : entityAvailability.start;\n\n  // Figure out how we will sample dynamic position properties\n  let defaultAvailability = defaultValue(\n    options.defaultAvailability,\n    entityAvailability,\n  );\n  const sampleDuration = defaultValue(options.sampleDuration, 60);\n\n  // Make sure we don't have infinite availability if we need to sample\n  if (defaultAvailability.start === Iso8601.MINIMUM_VALUE) {\n    if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n      // Infinite, so just use the default\n      defaultAvailability = new TimeInterval();\n    } else {\n      // No start time, so just sample 10 times before the stop\n      JulianDate.addSeconds(\n        defaultAvailability.stop,\n        -10 * sampleDuration,\n        defaultAvailability.start,\n      );\n    }\n  } else if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n    // No stop time, so just sample 10 times after the start\n    JulianDate.addSeconds(\n      defaultAvailability.start,\n      10 * sampleDuration,\n      defaultAvailability.stop,\n    );\n  }\n\n  const externalFileHandler = new ExternalFileHandler(options.modelCallback);\n\n  const kmlDoc = document.implementation.createDocument(kmlNamespace, \"kml\");\n  return {\n    kmlDoc: kmlDoc,\n    ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.default),\n    idManager: new IdManager(),\n    styleCache: styleCache,\n    externalFileHandler: externalFileHandler,\n    time: time,\n    valueGetter: new ValueGetter(time),\n    sampleDuration: sampleDuration,\n    // Wrap it in a TimeIntervalCollection because that is what entity.availability is\n    defaultAvailability: new TimeIntervalCollection([defaultAvailability]),\n  };\n};\n\nfunction recurseEntities(state, parentNode, entities) {\n  const kmlDoc = state.kmlDoc;\n  const styleCache = state.styleCache;\n  const valueGetter = state.valueGetter;\n  const idManager = state.idManager;\n\n  const count = entities.length;\n  let overlays;\n  let geometries;\n  let styles;\n  for (let i = 0; i < count; ++i) {\n    const entity = entities[i];\n    overlays = [];\n    geometries = [];\n    styles = [];\n\n    createPoint(state, entity, geometries, styles);\n    createLineString(state, entity.polyline, geometries, styles);\n    createPolygon(state, entity.rectangle, geometries, styles, overlays);\n    createPolygon(state, entity.polygon, geometries, styles, overlays);\n    createModel(state, entity, entity.model, geometries, styles);\n\n    let timeSpan;\n    const availability = entity.availability;\n    if (defined(availability)) {\n      timeSpan = kmlDoc.createElement(\"TimeSpan\");\n\n      if (!JulianDate.equals(availability.start, Iso8601.MINIMUM_VALUE)) {\n        timeSpan.appendChild(\n          createBasicElementWithText(\n            kmlDoc,\n            \"begin\",\n            JulianDate.toIso8601(availability.start),\n          ),\n        );\n      }\n\n      if (!JulianDate.equals(availability.stop, Iso8601.MAXIMUM_VALUE)) {\n        timeSpan.appendChild(\n          createBasicElementWithText(\n            kmlDoc,\n            \"end\",\n            JulianDate.toIso8601(availability.stop),\n          ),\n        );\n      }\n    }\n\n    for (let overlayIndex = 0; overlayIndex < overlays.length; ++overlayIndex) {\n      const overlay = overlays[overlayIndex];\n\n      overlay.setAttribute(\"id\", idManager.get(entity.id));\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"name\", entity.name),\n      );\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show),\n      );\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description),\n      );\n\n      if (defined(timeSpan)) {\n        overlay.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(overlay);\n    }\n\n    const geometryCount = geometries.length;\n    if (geometryCount > 0) {\n      const placemark = kmlDoc.createElement(\"Placemark\");\n      placemark.setAttribute(\"id\", idManager.get(entity.id));\n\n      let name = entity.name;\n      const labelGraphics = entity.label;\n      if (defined(labelGraphics)) {\n        const labelStyle = kmlDoc.createElement(\"LabelStyle\");\n\n        // KML only shows the name as a label, so just change the name if we need to show a label\n        const text = valueGetter.get(labelGraphics.text);\n        name = defined(text) && text.length > 0 ? text : name;\n\n        const color = valueGetter.getColor(labelGraphics.fillColor);\n        if (defined(color)) {\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"color\", color),\n          );\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n          );\n        }\n\n        const scale = valueGetter.get(labelGraphics.scale);\n        if (defined(scale)) {\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"scale\", scale),\n          );\n        }\n\n        styles.push(labelStyle);\n      }\n\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"name\", name));\n      placemark.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show),\n      );\n      placemark.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description),\n      );\n\n      if (defined(timeSpan)) {\n        placemark.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(placemark);\n\n      const styleCount = styles.length;\n      if (styleCount > 0) {\n        const style = kmlDoc.createElement(\"Style\");\n        for (let styleIndex = 0; styleIndex < styleCount; ++styleIndex) {\n          style.appendChild(styles[styleIndex]);\n        }\n\n        placemark.appendChild(\n          createBasicElementWithText(kmlDoc, \"styleUrl\", styleCache.get(style)),\n        );\n      }\n\n      if (geometries.length === 1) {\n        placemark.appendChild(geometries[0]);\n      } else if (geometries.length > 1) {\n        const multigeometry = kmlDoc.createElement(\"MultiGeometry\");\n        for (\n          let geometryIndex = 0;\n          geometryIndex < geometryCount;\n          ++geometryIndex\n        ) {\n          multigeometry.appendChild(geometries[geometryIndex]);\n        }\n        placemark.appendChild(multigeometry);\n      }\n    }\n\n    const children = entity._children;\n    if (children.length > 0) {\n      const folderNode = kmlDoc.createElement(\"Folder\");\n      folderNode.setAttribute(\"id\", idManager.get(entity.id));\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"name\", entity.name),\n      );\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show),\n      );\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description),\n      );\n\n      parentNode.appendChild(folderNode);\n\n      recurseEntities(state, folderNode, children);\n    }\n  }\n}\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchJulianDate = new JulianDate();\n\nfunction createPoint(state, entity, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  const pointGraphics = defaultValue(entity.billboard, entity.point);\n  if (!defined(pointGraphics) && !defined(entity.path)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, pointGraphics, geometries, styles);\n    return;\n  }\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    getCoordinates(scratchCartesian3, ellipsoid),\n  );\n\n  const pointGeometry = kmlDoc.createElement(\"Point\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, pointGraphics.heightReference),\n  );\n  pointGeometry.appendChild(altitudeMode);\n\n  pointGeometry.appendChild(coordinates);\n  geometries.push(pointGeometry);\n\n  // Create style\n  const iconStyle =\n    pointGraphics instanceof BillboardGraphics\n      ? createIconStyleFromBillboard(state, pointGraphics)\n      : createIconStyleFromPoint(state, pointGraphics);\n  styles.push(iconStyle);\n}\n\nfunction createTracks(state, entity, pointGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  let intervals;\n  const entityPositionProperty = entity.position;\n  let useEntityPositionProperty = true;\n  if (entityPositionProperty instanceof CompositePositionProperty) {\n    intervals = entityPositionProperty.intervals;\n    useEntityPositionProperty = false;\n  } else {\n    intervals = defaultValue(entity.availability, state.defaultAvailability);\n  }\n\n  const isModel = pointGraphics instanceof ModelGraphics;\n\n  let i, j, times;\n  const tracks = [];\n  for (i = 0; i < intervals.length; ++i) {\n    const interval = intervals.get(i);\n    let positionProperty = useEntityPositionProperty\n      ? entityPositionProperty\n      : interval.data;\n\n    const trackAltitudeMode = kmlDoc.createElement(\"altitudeMode\");\n    // This is something that KML importing uses to handle clampToGround,\n    //  so just extract the internal property and set the altitudeMode.\n    if (positionProperty instanceof ScaledPositionProperty) {\n      positionProperty = positionProperty._value;\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, HeightReference.CLAMP_TO_GROUND),\n      );\n    } else if (defined(pointGraphics)) {\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, pointGraphics.heightReference),\n      );\n    } else {\n      // Path graphics only, which has no height reference\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, HeightReference.NONE),\n      );\n    }\n\n    const positionTimes = [];\n    const positionValues = [];\n\n    if (positionProperty.isConstant) {\n      valueGetter.get(positionProperty, undefined, scratchCartesian3);\n      const constCoordinates = createBasicElementWithText(\n        kmlDoc,\n        \"coordinates\",\n        getCoordinates(scratchCartesian3, ellipsoid),\n      );\n\n      // This interval is constant so add a track with the same position\n      positionTimes.push(JulianDate.toIso8601(interval.start));\n      positionValues.push(constCoordinates);\n      positionTimes.push(JulianDate.toIso8601(interval.stop));\n      positionValues.push(constCoordinates);\n    } else if (positionProperty instanceof SampledPositionProperty) {\n      times = positionProperty._property._times;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        positionProperty.getValueInReferenceFrame(\n          times[j],\n          ReferenceFrame.FIXED,\n          scratchCartesian3,\n        );\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else if (positionProperty instanceof SampledProperty) {\n      times = positionProperty._times;\n      const values = positionProperty._values;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        Cartesian3.fromArray(values, j * 3, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else {\n      const duration = state.sampleDuration;\n      interval.start.clone(scratchJulianDate);\n      if (!interval.isStartIncluded) {\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      const stopDate = interval.stop;\n      while (JulianDate.lessThan(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      if (\n        interval.isStopIncluded &&\n        JulianDate.equals(scratchJulianDate, stopDate)\n      ) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    }\n\n    const trackGeometry = kmlDoc.createElementNS(gxNamespace, \"Track\");\n    trackGeometry.appendChild(trackAltitudeMode);\n\n    for (let k = 0; k < positionTimes.length; ++k) {\n      const when = createBasicElementWithText(kmlDoc, \"when\", positionTimes[k]);\n      const coord = createBasicElementWithText(\n        kmlDoc,\n        \"coord\",\n        positionValues[k],\n        gxNamespace,\n      );\n\n      trackGeometry.appendChild(when);\n      trackGeometry.appendChild(coord);\n    }\n\n    if (isModel) {\n      trackGeometry.appendChild(createModelGeometry(state, pointGraphics));\n    }\n\n    tracks.push(trackGeometry);\n  }\n\n  // If one track, then use it otherwise combine into a multitrack\n  if (tracks.length === 1) {\n    geometries.push(tracks[0]);\n  } else if (tracks.length > 1) {\n    const multiTrackGeometry = kmlDoc.createElementNS(\n      gxNamespace,\n      \"MultiTrack\",\n    );\n\n    for (i = 0; i < tracks.length; ++i) {\n      multiTrackGeometry.appendChild(tracks[i]);\n    }\n\n    geometries.push(multiTrackGeometry);\n  }\n\n  // Create style\n  if (defined(pointGraphics) && !isModel) {\n    const iconStyle =\n      pointGraphics instanceof BillboardGraphics\n        ? createIconStyleFromBillboard(state, pointGraphics)\n        : createIconStyleFromPoint(state, pointGraphics);\n    styles.push(iconStyle);\n  }\n\n  // See if we have a line that needs to be drawn\n  const path = entity.path;\n  if (defined(path)) {\n    const width = valueGetter.get(path.width);\n    const material = path.material;\n    if (defined(material) || defined(width)) {\n      const lineStyle = kmlDoc.createElement(\"LineStyle\");\n      if (defined(width)) {\n        lineStyle.appendChild(\n          createBasicElementWithText(kmlDoc, \"width\", width),\n        );\n      }\n\n      processMaterial(state, material, lineStyle);\n      styles.push(lineStyle);\n    }\n  }\n}\n\nfunction createIconStyleFromPoint(state, pointGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n\n  const color = valueGetter.getColor(pointGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n  }\n\n  const pixelSize = valueGetter.get(pointGraphics.pixelSize);\n  if (defined(pixelSize)) {\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"scale\", pixelSize / BILLBOARD_SIZE),\n    );\n  }\n\n  return iconStyle;\n}\n\nfunction createIconStyleFromBillboard(state, billboardGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n\n  let image = valueGetter.get(billboardGraphics.image);\n  if (defined(image)) {\n    image = externalFileHandler.texture(image);\n\n    const icon = kmlDoc.createElement(\"Icon\");\n    icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", image));\n\n    const imageSubRegion = valueGetter.get(billboardGraphics.imageSubRegion);\n    if (defined(imageSubRegion)) {\n      icon.appendChild(\n        createBasicElementWithText(kmlDoc, \"x\", imageSubRegion.x, gxNamespace),\n      );\n      icon.appendChild(\n        createBasicElementWithText(kmlDoc, \"y\", imageSubRegion.y, gxNamespace),\n      );\n      icon.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"w\",\n          imageSubRegion.width,\n          gxNamespace,\n        ),\n      );\n      icon.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"h\",\n          imageSubRegion.height,\n          gxNamespace,\n        ),\n      );\n    }\n\n    iconStyle.appendChild(icon);\n  }\n\n  const color = valueGetter.getColor(billboardGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n  }\n\n  let scale = valueGetter.get(billboardGraphics.scale);\n  if (defined(scale)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n  }\n\n  const pixelOffset = valueGetter.get(billboardGraphics.pixelOffset);\n  if (defined(pixelOffset)) {\n    scale = defaultValue(scale, 1.0);\n\n    Cartesian2.divideByScalar(pixelOffset, scale, pixelOffset);\n\n    const width = valueGetter.get(billboardGraphics.width, BILLBOARD_SIZE);\n    const height = valueGetter.get(billboardGraphics.height, BILLBOARD_SIZE);\n\n    // KML Hotspots are from the bottom left, but we work from the top left\n\n    // Move to left\n    const horizontalOrigin = valueGetter.get(\n      billboardGraphics.horizontalOrigin,\n      HorizontalOrigin.CENTER,\n    );\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      pixelOffset.x -= width * 0.5;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      pixelOffset.x -= width;\n    }\n\n    // Move to bottom\n    const verticalOrigin = valueGetter.get(\n      billboardGraphics.verticalOrigin,\n      VerticalOrigin.CENTER,\n    );\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      pixelOffset.y += height;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      pixelOffset.y += height * 0.5;\n    }\n\n    const hotSpot = kmlDoc.createElement(\"hotSpot\");\n    hotSpot.setAttribute(\"x\", -pixelOffset.x);\n    hotSpot.setAttribute(\"y\", pixelOffset.y);\n    hotSpot.setAttribute(\"xunits\", \"pixels\");\n    hotSpot.setAttribute(\"yunits\", \"pixels\");\n\n    iconStyle.appendChild(hotSpot);\n  }\n\n  // We can only specify heading so if axis isn't Z, then we skip the rotation\n  // GE treats a heading of zero as no heading but can still point north using a 360 degree angle\n  let rotation = valueGetter.get(billboardGraphics.rotation);\n  const alignedAxis = valueGetter.get(billboardGraphics.alignedAxis);\n  if (defined(rotation) && Cartesian3.equals(Cartesian3.UNIT_Z, alignedAxis)) {\n    rotation = CesiumMath.toDegrees(-rotation);\n    if (rotation === 0) {\n      rotation = 360;\n    }\n\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"heading\", rotation),\n    );\n  }\n\n  return iconStyle;\n}\n\nfunction createLineString(state, polylineGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(polylineGraphics)) {\n    return;\n  }\n\n  const lineStringGeometry = kmlDoc.createElement(\"LineString\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  const clampToGround = valueGetter.get(polylineGraphics.clampToGround, false);\n  let altitudeModeText;\n  if (clampToGround) {\n    lineStringGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"tessellate\", true),\n    );\n    altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n  } else {\n    altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n  }\n  altitudeMode.appendChild(altitudeModeText);\n  lineStringGeometry.appendChild(altitudeMode);\n\n  // Set coordinates\n  const positionsProperty = polylineGraphics.positions;\n  const cartesians = valueGetter.get(positionsProperty);\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    getCoordinates(cartesians, ellipsoid),\n  );\n  lineStringGeometry.appendChild(coordinates);\n\n  // Set draw order\n  const zIndex = valueGetter.get(polylineGraphics.zIndex);\n  if (clampToGround && defined(zIndex)) {\n    lineStringGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"drawOrder\", zIndex, gxNamespace),\n    );\n  }\n\n  geometries.push(lineStringGeometry);\n\n  // Create style\n  const lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n  const width = valueGetter.get(polylineGraphics.width);\n  if (defined(width)) {\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n  }\n\n  processMaterial(state, polylineGraphics.material, lineStyle);\n\n  styles.push(lineStyle);\n}\n\nfunction getRectangleBoundaries(state, rectangleGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  let height = valueGetter.get(rectangleGraphics.height, 0.0);\n\n  if (extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  const coordinatesProperty = rectangleGraphics.coordinates;\n  const rectangle = valueGetter.get(coordinatesProperty);\n\n  const coordinateStrings = [];\n  const cornerFunction = [\n    Rectangle.northeast,\n    Rectangle.southeast,\n    Rectangle.southwest,\n    Rectangle.northwest,\n  ];\n\n  for (let i = 0; i < 4; ++i) {\n    cornerFunction[i](rectangle, scratchCartographic);\n    coordinateStrings.push(\n      `${CesiumMath.toDegrees(\n        scratchCartographic.longitude,\n      )},${CesiumMath.toDegrees(scratchCartographic.latitude)},${height}`,\n    );\n  }\n\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    coordinateStrings.join(\" \"),\n  );\n\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  outerBoundaryIs.appendChild(linearRing);\n\n  return [outerBoundaryIs];\n}\n\nfunction getLinearRing(state, positions, height, perPositionHeight) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n\n  const coordinateStrings = [];\n  const positionCount = positions.length;\n  for (let i = 0; i < positionCount; ++i) {\n    Cartographic.fromCartesian(positions[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(\n      `${CesiumMath.toDegrees(\n        scratchCartographic.longitude,\n      )},${CesiumMath.toDegrees(scratchCartographic.latitude)},${\n        perPositionHeight ? scratchCartographic.height : height\n      }`,\n    );\n  }\n\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    coordinateStrings.join(\" \"),\n  );\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n\n  return linearRing;\n}\n\nfunction getPolygonBoundaries(state, polygonGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  let height = valueGetter.get(polygonGraphics.height, 0.0);\n  const perPositionHeight = valueGetter.get(\n    polygonGraphics.perPositionHeight,\n    false,\n  );\n\n  if (!perPositionHeight && extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  const boundaries = [];\n  const hierarchyProperty = polygonGraphics.hierarchy;\n  const hierarchy = valueGetter.get(hierarchyProperty);\n\n  // Polygon hierarchy can sometimes just be an array of positions\n  const positions = Array.isArray(hierarchy) ? hierarchy : hierarchy.positions;\n\n  // Polygon boundaries\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  outerBoundaryIs.appendChild(\n    getLinearRing(state, positions, height, perPositionHeight),\n  );\n  boundaries.push(outerBoundaryIs);\n\n  // Hole boundaries\n  const holes = hierarchy.holes;\n  if (defined(holes)) {\n    const holeCount = holes.length;\n    for (let i = 0; i < holeCount; ++i) {\n      const innerBoundaryIs = kmlDoc.createElement(\"innerBoundaryIs\");\n      innerBoundaryIs.appendChild(\n        getLinearRing(state, holes[i].positions, height, perPositionHeight),\n      );\n      boundaries.push(innerBoundaryIs);\n    }\n  }\n\n  return boundaries;\n}\n\nfunction createPolygon(state, geometry, geometries, styles, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(geometry)) {\n    return;\n  }\n\n  // Detect textured quads and use ground overlays instead\n  const isRectangle = geometry instanceof RectangleGraphics;\n  if (\n    isRectangle &&\n    valueGetter.getMaterialType(geometry.material) === \"Image\"\n  ) {\n    createGroundOverlay(state, geometry, overlays);\n    return;\n  }\n\n  const polygonGeometry = kmlDoc.createElement(\"Polygon\");\n\n  const extrudedHeight = valueGetter.get(geometry.extrudedHeight, 0.0);\n  if (extrudedHeight > 0) {\n    polygonGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"extrude\", true),\n    );\n  }\n\n  // Set boundaries\n  const boundaries = isRectangle\n    ? getRectangleBoundaries(state, geometry, extrudedHeight)\n    : getPolygonBoundaries(state, geometry, extrudedHeight);\n\n  const boundaryCount = boundaries.length;\n  for (let i = 0; i < boundaryCount; ++i) {\n    polygonGeometry.appendChild(boundaries[i]);\n  }\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, geometry.heightReference));\n  polygonGeometry.appendChild(altitudeMode);\n\n  geometries.push(polygonGeometry);\n\n  // Create style\n  const polyStyle = kmlDoc.createElement(\"PolyStyle\");\n\n  const fill = valueGetter.get(geometry.fill, false);\n  if (fill) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"fill\", fill));\n  }\n\n  processMaterial(state, geometry.material, polyStyle);\n\n  const outline = valueGetter.get(geometry.outline, false);\n  if (outline) {\n    polyStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"outline\", outline),\n    );\n\n    // Outline uses LineStyle\n    const lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n    const outlineWidth = valueGetter.get(geometry.outlineWidth, 1.0);\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"width\", outlineWidth),\n    );\n\n    const outlineColor = valueGetter.getColor(\n      geometry.outlineColor,\n      Color.BLACK,\n    );\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"color\", outlineColor),\n    );\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n\n    styles.push(lineStyle);\n  }\n\n  styles.push(polyStyle);\n}\n\nfunction createGroundOverlay(state, rectangleGraphics, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n\n  const groundOverlay = kmlDoc.createElement(\"GroundOverlay\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, rectangleGraphics.heightReference),\n  );\n  groundOverlay.appendChild(altitudeMode);\n\n  const height = valueGetter.get(rectangleGraphics.height);\n  if (defined(height)) {\n    groundOverlay.appendChild(\n      createBasicElementWithText(kmlDoc, \"altitude\", height),\n    );\n  }\n\n  const rectangle = valueGetter.get(rectangleGraphics.coordinates);\n  const latLonBox = kmlDoc.createElement(\"LatLonBox\");\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"north\",\n      CesiumMath.toDegrees(rectangle.north),\n    ),\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"south\",\n      CesiumMath.toDegrees(rectangle.south),\n    ),\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"east\",\n      CesiumMath.toDegrees(rectangle.east),\n    ),\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"west\",\n      CesiumMath.toDegrees(rectangle.west),\n    ),\n  );\n  groundOverlay.appendChild(latLonBox);\n\n  // We should only end up here if we have an ImageMaterialProperty\n  const material = valueGetter.get(rectangleGraphics.material);\n  const href = externalFileHandler.texture(material.image);\n  const icon = kmlDoc.createElement(\"Icon\");\n  icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", href));\n  groundOverlay.appendChild(icon);\n\n  const color = material.color;\n  if (defined(color)) {\n    groundOverlay.appendChild(\n      createBasicElementWithText(\n        kmlDoc,\n        \"color\",\n        colorToString(material.color),\n      ),\n    );\n  }\n\n  overlays.push(groundOverlay);\n}\n\nfunction createModelGeometry(state, modelGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n\n  const modelGeometry = kmlDoc.createElement(\"Model\");\n\n  const scale = valueGetter.get(modelGraphics.scale);\n  if (defined(scale)) {\n    const scaleElement = kmlDoc.createElement(\"scale\");\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"x\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"y\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"z\", scale));\n    modelGeometry.appendChild(scaleElement);\n  }\n\n  const link = kmlDoc.createElement(\"Link\");\n  const uri = externalFileHandler.model(modelGraphics, state.time);\n\n  link.appendChild(createBasicElementWithText(kmlDoc, \"href\", uri));\n  modelGeometry.appendChild(link);\n\n  return modelGeometry;\n}\n\nfunction createModel(state, entity, modelGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(modelGraphics)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, modelGraphics, geometries, styles);\n    return;\n  }\n\n  const modelGeometry = createModelGeometry(state, modelGraphics);\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, modelGraphics.heightReference),\n  );\n  modelGeometry.appendChild(altitudeMode);\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  Cartographic.fromCartesian(scratchCartesian3, ellipsoid, scratchCartographic);\n  const location = kmlDoc.createElement(\"Location\");\n  location.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"longitude\",\n      CesiumMath.toDegrees(scratchCartographic.longitude),\n    ),\n  );\n  location.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"latitude\",\n      CesiumMath.toDegrees(scratchCartographic.latitude),\n    ),\n  );\n  location.appendChild(\n    createBasicElementWithText(kmlDoc, \"altitude\", scratchCartographic.height),\n  );\n  modelGeometry.appendChild(location);\n\n  geometries.push(modelGeometry);\n}\n\nfunction processMaterial(state, materialProperty, style) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(materialProperty)) {\n    return;\n  }\n\n  const material = valueGetter.get(materialProperty);\n  if (!defined(material)) {\n    return;\n  }\n\n  let color;\n  const type = valueGetter.getMaterialType(materialProperty);\n  let outlineColor;\n  let outlineWidth;\n  switch (type) {\n    case \"Image\":\n      // Image materials are only able to be represented on rectangles, so if we make it\n      //  here we can't texture a generic polygon or polyline in KML, so just use white.\n      color = colorToString(Color.WHITE);\n      break;\n    case \"Color\":\n    case \"Grid\":\n    case \"PolylineGlow\":\n    case \"PolylineArrow\":\n    case \"PolylineDash\":\n      color = colorToString(material.color);\n      break;\n    case \"PolylineOutline\":\n      color = colorToString(material.color);\n\n      outlineColor = colorToString(material.outlineColor);\n      outlineWidth = material.outlineWidth;\n      style.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"outerColor\",\n          outlineColor,\n          gxNamespace,\n        ),\n      );\n      style.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"outerWidth\",\n          outlineWidth,\n          gxNamespace,\n        ),\n      );\n      break;\n    case \"Stripe\":\n      color = colorToString(material.oddColor);\n      break;\n  }\n\n  if (defined(color)) {\n    style.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    style.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n  }\n}\n\nfunction getAltitudeMode(state, heightReferenceProperty) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  const heightReference = valueGetter.get(\n    heightReferenceProperty,\n    HeightReference.NONE,\n  );\n  let altitudeModeText;\n  switch (heightReference) {\n    case HeightReference.NONE:\n      altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n      break;\n    case HeightReference.CLAMP_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n      break;\n    case HeightReference.RELATIVE_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"relativeToGround\");\n      break;\n  }\n\n  return altitudeModeText;\n}\n\nfunction getCoordinates(coordinates, ellipsoid) {\n  if (!Array.isArray(coordinates)) {\n    coordinates = [coordinates];\n  }\n\n  const count = coordinates.length;\n  const coordinateStrings = [];\n  for (let i = 0; i < count; ++i) {\n    Cartographic.fromCartesian(coordinates[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(\n      `${CesiumMath.toDegrees(\n        scratchCartographic.longitude,\n      )},${CesiumMath.toDegrees(scratchCartographic.latitude)},${\n        scratchCartographic.height\n      }`,\n    );\n  }\n\n  return coordinateStrings.join(\" \");\n}\n\nfunction createBasicElementWithText(\n  kmlDoc,\n  elementName,\n  elementValue,\n  namespace,\n) {\n  elementValue = defaultValue(elementValue, \"\");\n\n  if (typeof elementValue === \"boolean\") {\n    elementValue = elementValue ? \"1\" : \"0\";\n  }\n\n  // Create element with optional namespace\n  const element = defined(namespace)\n    ? kmlDoc.createElementNS(namespace, elementName)\n    : kmlDoc.createElement(elementName);\n\n  // Wrap value in CDATA section if it contains HTML\n  const text =\n    elementValue === \"string\" && elementValue.indexOf(\"<\") !== -1\n      ? kmlDoc.createCDATASection(elementValue)\n      : kmlDoc.createTextNode(elementValue);\n\n  element.appendChild(text);\n\n  return element;\n}\n\nfunction colorToString(color) {\n  let result = \"\";\n  const bytes = color.toBytes();\n  for (let i = 3; i >= 0; --i) {\n    result +=\n      bytes[i] < 16 ? `0${bytes[i].toString(16)}` : bytes[i].toString(16);\n  }\n\n  return result;\n}\n\n/**\n * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.\n * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,\n * or otherwise returned with the KML string when exporting.\n *\n * @callback exportKmlModelCallback\n *\n * @param {ModelGraphics} model The ModelGraphics instance for an Entity.\n * @param {JulianDate} time The time that any properties should use to get the value.\n * @param {object} externalFiles An object that maps a filename to a Blob or a Promise that resolves to a Blob.\n * @returns {string} The URL to use for the href in the KML document.\n */\nexport default exportKml;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}