{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {number} options.negativeElevationThreshold Threshold for negative values\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const buffer = ...\n * const childTileMask = ...\n * const terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\"options.negativeAltitudeExponentBias\", options.negativeAltitudeExponentBias);\n  Check.typeOf.number(\"options.negativeElevationThreshold\", options.negativeElevationThreshold);\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold;\n\n  // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n  const googleChildTileMask = defaultValue(options.childTileMask, 15);\n  let childTileMask = googleChildTileMask & 3; // Bottom row is identical\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    }\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\nconst createMeshTaskName = \"createVerticesFromGoogleEarthEnterpriseBuffer\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(createMeshTaskName, TerrainData.maximumAsynchronousTasks);\nconst nativeRectangleScratch = new Rectangle();\nconst rectangleScratch = new Rectangle();\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(options.exaggerationRelativeHeight, 0.0);\n  const throttle = defaultValue(options.throttle, true);\n  const ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangleScratch));\n  const levelZeroMaxError = 40075.16; // From Google's Doc\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n  const createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold\n  });\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n  const that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), new Uint16Array(result.indices), result.indexCountWithoutSkirts, result.vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, BoundingSphere.clone(result.boundingSphere3D), Cartesian3.clone(result.occludeePointInScaledSpace), result.numberOfAttributes, OrientedBoundingBox.clone(result.orientedBoundingBox), TerrainEncoding.clone(result.encoding), result.westIndicesSouthToNorth, result.southIndicesEastToWest, result.eastIndicesNorthToSouth, result.northIndicesWestToEast);\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight;\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  const u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0.0, 1.0);\n  const v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0.0, 1.0);\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n  return interpolateMeshHeight(this, u, v);\n};\nconst upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\", TerrainData.maximumAsynchronousTasks);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid\n  });\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n  const that = this;\n  return upsamplePromise.then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);\n    const skirtHeight = that._skirtHeight;\n\n    // Use QuantizedMeshTerrainData since we have what we need already parsed\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(result.orientedBoundingBox),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits\n    });\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\nconst barycentricCoordinateScratch = new Cartesian3();\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    const uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    const uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n    const barycentric = Intersections2D.computeBarycentricCoordinates(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y, barycentricCoordinateScratch);\n    if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n      const h0 = encoding.decodeHeight(vertices, i0);\n      const h1 = encoding.decodeHeight(vertices, i1);\n      const h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nconst sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nconst sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nconst sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nconst sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  const buffer = terrainData._buffer;\n  let quad = 0; // SW\n  let uStart = 0.0;\n  let vStart = 0.0;\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n  const dv = new DataView(buffer);\n  let offset = 0;\n  for (let q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n  offset += sizeOfUint32; // Skip length of quad\n  offset += 2 * sizeOfDouble; // Skip origin\n\n  // Read sizes\n  const xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  const ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n\n  // Samples per quad\n  const xScale = rectangle.width / xSize / 2;\n  const yScale = rectangle.height / ySize / 2;\n\n  // Number of points\n  const numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32;\n\n  // Number of faces\n  const numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n  offset += sizeOfInt32; // Skip Level\n\n  const uBuffer = new Array(numPoints);\n  const vBuffer = new Array(numPoints);\n  const heights = new Array(numPoints);\n  let i;\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale;\n\n    // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n  const indices = new Array(numIndices);\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n    const barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);\n    if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n      return barycentric.x * heights[i0] + barycentric.y * heights[i1] + barycentric.z * heights[i2];\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nexport default GoogleEarthEnterpriseTerrainData;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Check","defaultValue","defined","DeveloperError","IndexDatatype","Intersections2D","CesiumMath","OrientedBoundingBox","QuantizedMeshTerrainData","Rectangle","TaskProcessor","TerrainData","TerrainEncoding","TerrainMesh","GoogleEarthEnterpriseTerrainData","options","EMPTY_OBJECT","typeOf","object","buffer","number","negativeAltitudeExponentBias","negativeElevationThreshold","_buffer","_credits","credits","_negativeAltitudeExponentBias","_negativeElevationThreshold","googleChildTileMask","childTileMask","_childTileMask","_createdByUpsampling","createdByUpsampling","_skirtHeight","undefined","_bufferType","constructor","_mesh","_minimumHeight","_maximumHeight","Object","defineProperties","prototype","get","waterMask","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","nativeRectangleScratch","rectangleScratch","createMesh","tilingScheme","x","y","level","exaggeration","exaggerationRelativeHeight","throttle","ellipsoid","tileXYToNativeRectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","thisLevelMaxError","Math","min","createMeshTaskProcessor","verticesPromise","scheduleTask","nativeRectangle","rectangle","relativeToCenter","skirtHeight","includeWebMercatorT","that","then","result","Float32Array","vertices","Uint16Array","indices","indexCountWithoutSkirts","vertexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","encoding","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","quantizedVertices","indicesTypedArray","createTypedArray","length","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","texCoordScratch0","texCoordScratch1","texCoordScratch2","barycentricCoordinateScratch","terrainData","i","len","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","sizeOfUint16","BYTES_PER_ELEMENT","sizeOfUint32","Uint32Array","sizeOfInt32","Int32Array","sizeOfFloat","sizeOfDouble","Float64Array","quad","uStart","vStart","dv","DataView","offset","q","getUint32","xSize","toRadians","getFloat64","ySize","xScale","yScale","numPoints","getInt32","numIndices","uBuffer","Array","vBuffer","heights","getUint8","getFloat32","getUint16","u0","u1","u2","v0","v1","v2"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/GoogleEarthEnterpriseTerrainData.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {number} options.negativeElevationThreshold Threshold for negative values\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const buffer = ...\n * const childTileMask = ...\n * const terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\n    \"options.negativeAltitudeExponentBias\",\n    options.negativeAltitudeExponentBias,\n  );\n  Check.typeOf.number(\n    \"options.negativeElevationThreshold\",\n    options.negativeElevationThreshold,\n  );\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold;\n\n  // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n  const googleChildTileMask = defaultValue(options.childTileMask, 15);\n  let childTileMask = googleChildTileMask & 3; // Bottom row is identical\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\nconst createMeshTaskName = \"createVerticesFromGoogleEarthEnterpriseBuffer\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks,\n);\n\nconst nativeRectangleScratch = new Rectangle();\nconst rectangleScratch = new Rectangle();\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0,\n  );\n  const throttle = defaultValue(options.throttle, true);\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(\n    Rectangle.center(rectangleScratch),\n  );\n\n  const levelZeroMaxError = 40075.16; // From Google's Doc\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      new Uint16Array(result.indices),\n      result.indexCountWithoutSkirts,\n      result.vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast,\n    );\n\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight;\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude,\n) {\n  const u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0,\n  );\n  const v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0,\n  );\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nconst upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel,\n  );\n\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return upsamplePromise.then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices,\n    );\n\n    const skirtHeight = that._skirtHeight;\n\n    // Use QuantizedMeshTerrainData since we have what we need already parsed\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox,\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits,\n    });\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling =\n  function () {\n    return this._createdByUpsampling;\n  };\n\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\nconst barycentricCoordinateScratch = new Cartesian3();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const uv0 = encoding.decodeTextureCoordinates(\n      vertices,\n      i0,\n      texCoordScratch0,\n    );\n    const uv1 = encoding.decodeTextureCoordinates(\n      vertices,\n      i1,\n      texCoordScratch1,\n    );\n    const uv2 = encoding.decodeTextureCoordinates(\n      vertices,\n      i2,\n      texCoordScratch2,\n    );\n\n    const barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      uv0.x,\n      uv0.y,\n      uv1.x,\n      uv1.y,\n      uv2.x,\n      uv2.y,\n      barycentricCoordinateScratch,\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      const h0 = encoding.decodeHeight(vertices, i0);\n      const h1 = encoding.decodeHeight(vertices, i1);\n      const h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nconst sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nconst sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nconst sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nconst sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  const buffer = terrainData._buffer;\n  let quad = 0; // SW\n  let uStart = 0.0;\n  let vStart = 0.0;\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n\n  const dv = new DataView(buffer);\n  let offset = 0;\n  for (let q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n  offset += sizeOfUint32; // Skip length of quad\n  offset += 2 * sizeOfDouble; // Skip origin\n\n  // Read sizes\n  const xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  const ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n\n  // Samples per quad\n  const xScale = rectangle.width / xSize / 2;\n  const yScale = rectangle.height / ySize / 2;\n\n  // Number of points\n  const numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32;\n\n  // Number of faces\n  const numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n\n  offset += sizeOfInt32; // Skip Level\n\n  const uBuffer = new Array(numPoints);\n  const vBuffer = new Array(numPoints);\n  const heights = new Array(numPoints);\n  let i;\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale;\n\n    // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n\n  const indices = new Array(numIndices);\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n\n    const barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      u0,\n      v0,\n      u1,\n      v1,\n      u2,\n      v2,\n      barycentricCoordinateScratch,\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      return (\n        barycentric.x * heights[i0] +\n        barycentric.y * heights[i1] +\n        barycentric.z * heights[i2]\n      );\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nexport default GoogleEarthEnterpriseTerrainData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}