{"ast":null,"code":"import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport getImagePixels from \"./getImagePixels.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nfunction DataRectangle(rectangle, maxLevel) {\n  this.rectangle = rectangle;\n  this.maxLevel = maxLevel;\n}\n\n/**\n * @typedef {Object} VRTheWorldTerrainProvider.ConstructorOptions\n *\n * Initialization options for the VRTheWorldTerrainProvider constructor\n *\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {VRTheWorldTerrainProvider.ConstructorOptions} options An object describing initialization options\n */\nfunction TerrainProviderBuilder(options) {\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this.tilingScheme = undefined;\n  this.heightmapWidth = undefined;\n  this.heightmapHeight = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.rectangles = [];\n}\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._tilingScheme = this.tilingScheme;\n  provider._heightmapWidth = this.heightmapWidth;\n  provider._heightmapHeight = this.heightmapHeight;\n  provider._levelZeroMaximumGeometricError = this.levelZeroMaximumGeometricError;\n  provider._rectangles = this.rectangles;\n};\nfunction metadataSuccess(terrainProviderBuilder, xml) {\n  const srs = xml.getElementsByTagName(\"SRS\")[0].textContent;\n  if (srs === \"EPSG:4326\") {\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({\n      ellipsoid: terrainProviderBuilder.ellipsoid\n    });\n  } else {\n    throw new RuntimeError(`SRS ${srs} is not supported`);\n  }\n  const tileFormat = xml.getElementsByTagName(\"TileFormat\")[0];\n  terrainProviderBuilder.heightmapWidth = parseInt(tileFormat.getAttribute(\"width\"), 10);\n  terrainProviderBuilder.heightmapHeight = parseInt(tileFormat.getAttribute(\"height\"), 10);\n  terrainProviderBuilder.levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(terrainProviderBuilder.ellipsoid, Math.min(terrainProviderBuilder.heightmapWidth, terrainProviderBuilder.heightmapHeight), terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0));\n  const dataRectangles = xml.getElementsByTagName(\"DataExtent\");\n  for (let i = 0; i < dataRectangles.length; ++i) {\n    const dataRectangle = dataRectangles[i];\n    const west = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"minx\")));\n    const south = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"miny\")));\n    const east = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"maxx\")));\n    const north = CesiumMath.toRadians(parseFloat(dataRectangle.getAttribute(\"maxy\")));\n    const maxLevel = parseInt(dataRectangle.getAttribute(\"maxlevel\"), 10);\n    terrainProviderBuilder.rectangles.push(new DataRectangle(new Rectangle(west, south, east, north), maxLevel));\n  }\n}\nfunction metadataFailure(resource, error, provider) {\n  let message = `An error occurred while accessing ${resource.url}`;\n  if (defined(error) && defined(error.message)) {\n    message = `${message}: ${error.message}`;\n  }\n  TileProviderError.reportError(undefined, provider, defined(provider) ? provider._errorEvent : undefined, message);\n  throw new RuntimeError(message);\n}\nasync function requestMetadata(terrainProviderBuilder, resource, provider) {\n  try {\n    const xml = await resource.fetchXML();\n    metadataSuccess(terrainProviderBuilder, xml);\n  } catch (error) {\n    metadataFailure(resource, error, provider);\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a VRTheWorldTerrainProvider, call {@link VRTheWorldTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.\n *\n * @alias VRTheWorldTerrainProvider\n * @constructor\n *\n * @param {VRTheWorldTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n *\n * @example\n * const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction VRTheWorldTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._errorEvent = new Event();\n  this._terrainDataStructure = {\n    heightScale: 1.0 / 1000.0,\n    heightOffset: -1000.0,\n    elementsPerHeight: 3,\n    stride: 4,\n    elementMultiplier: 256.0,\n    isBigEndian: true,\n    lowestEncodedHeight: 0,\n    highestEncodedHeight: 256 * 256 * 256 - 1\n  };\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n  this._tilingScheme = undefined;\n  this._rectangles = [];\n}\nObject.defineProperties(VRTheWorldTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    }\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\n\n/**\n * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.\n *\n * @param {Resource|String} url The URL of the VR-TheWorld TileMap.\n * @param {VRTheWorldTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<VRTheWorldTerrainProvider>}\n *\n * @example\n * const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n * @exception {RuntimeError} metadata specifies and unknown SRS\n */\nVRTheWorldTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  const resource = Resource.createIfNeeded(url);\n  await requestMetadata(terrainProviderBuilder, resource);\n  const provider = new VRTheWorldTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n  provider._resource = resource;\n  return provider;\n};\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nVRTheWorldTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  const yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);\n  const resource = this._resource.getDerivedResource({\n    url: `${level}/${x}/${yTiles - y - 1}.tif`,\n    queryParameters: {\n      cesium: true\n    },\n    request: request\n  });\n  const promise = resource.fetchImage({\n    preferImageBitmap: true\n  });\n  if (!defined(promise)) {\n    return undefined;\n  }\n  const that = this;\n  return Promise.resolve(promise).then(function (image) {\n    return new HeightmapTerrainData({\n      buffer: getImagePixels(image),\n      width: that._heightmapWidth,\n      height: that._heightmapHeight,\n      childTileMask: getChildMask(that, x, y, level),\n      structure: that._terrainDataStructure\n    });\n  });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nVRTheWorldTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\nconst rectangleScratch = new Rectangle();\nfunction getChildMask(provider, x, y, level) {\n  const tilingScheme = provider._tilingScheme;\n  const rectangles = provider._rectangles;\n  const parentRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  let childMask = 0;\n  for (let i = 0; i < rectangles.length && childMask !== 15; ++i) {\n    const rectangle = rectangles[i];\n    if (rectangle.maxLevel <= level) {\n      continue;\n    }\n    const testRectangle = rectangle.rectangle;\n    const intersection = Rectangle.intersection(testRectangle, parentRectangle, rectangleScratch);\n    if (defined(intersection)) {\n      // Parent tile is inside this rectangle, so at least one child is, too.\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2, level + 1)) {\n        childMask |= 4; // northwest\n      }\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2 + 1, y * 2, level + 1)) {\n        childMask |= 8; // northeast\n      }\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2 + 1, level + 1)) {\n        childMask |= 1; // southwest\n      }\n      if (isTileInRectangle(tilingScheme, testRectangle, x * 2 + 1, y * 2 + 1, level + 1)) {\n        childMask |= 2; // southeast\n      }\n    }\n  }\n  return childMask;\n}\nfunction isTileInRectangle(tilingScheme, rectangle, x, y, level) {\n  const tileRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  return defined(Rectangle.intersection(tileRectangle, rectangle, rectangleScratch));\n}\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nVRTheWorldTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nVRTheWorldTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  return undefined;\n};\nexport default VRTheWorldTerrainProvider;","map":{"version":3,"names":["Check","Credit","defaultValue","defined","Ellipsoid","Event","GeographicTilingScheme","getImagePixels","HeightmapTerrainData","CesiumMath","Rectangle","Resource","RuntimeError","TerrainProvider","TileProviderError","DataRectangle","rectangle","maxLevel","TerrainProviderBuilder","options","ellipsoid","default","tilingScheme","undefined","heightmapWidth","heightmapHeight","levelZeroMaximumGeometricError","rectangles","prototype","build","provider","_tilingScheme","_heightmapWidth","_heightmapHeight","_levelZeroMaximumGeometricError","_rectangles","metadataSuccess","terrainProviderBuilder","xml","srs","getElementsByTagName","textContent","tileFormat","parseInt","getAttribute","getEstimatedLevelZeroGeometricErrorForAHeightmap","Math","min","getNumberOfXTilesAtLevel","dataRectangles","i","length","dataRectangle","west","toRadians","parseFloat","south","east","north","push","metadataFailure","resource","error","message","url","reportError","_errorEvent","requestMetadata","fetchXML","VRTheWorldTerrainProvider","EMPTY_OBJECT","_terrainDataStructure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","lowestEncodedHeight","highestEncodedHeight","credit","_credit","Object","defineProperties","errorEvent","get","hasWaterMask","hasVertexNormals","availability","fromUrl","createIfNeeded","_resource","requestTileGeometry","x","y","level","request","yTiles","getNumberOfYTilesAtLevel","getDerivedResource","queryParameters","cesium","promise","fetchImage","preferImageBitmap","that","Promise","resolve","then","image","buffer","width","height","childTileMask","getChildMask","structure","getLevelMaximumGeometricError","rectangleScratch","parentRectangle","tileXYToRectangle","childMask","testRectangle","intersection","isTileInRectangle","tileRectangle","getTileDataAvailable","loadTileDataAvailability"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/VRTheWorldTerrainProvider.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport getImagePixels from \"./getImagePixels.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction DataRectangle(rectangle, maxLevel) {\n  this.rectangle = rectangle;\n  this.maxLevel = maxLevel;\n}\n\n/**\n * @typedef {Object} VRTheWorldTerrainProvider.ConstructorOptions\n *\n * Initialization options for the VRTheWorldTerrainProvider constructor\n *\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {VRTheWorldTerrainProvider.ConstructorOptions} options An object describing initialization options\n */\nfunction TerrainProviderBuilder(options) {\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this.tilingScheme = undefined;\n  this.heightmapWidth = undefined;\n  this.heightmapHeight = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.rectangles = [];\n}\n\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._tilingScheme = this.tilingScheme;\n  provider._heightmapWidth = this.heightmapWidth;\n  provider._heightmapHeight = this.heightmapHeight;\n  provider._levelZeroMaximumGeometricError =\n    this.levelZeroMaximumGeometricError;\n  provider._rectangles = this.rectangles;\n};\n\nfunction metadataSuccess(terrainProviderBuilder, xml) {\n  const srs = xml.getElementsByTagName(\"SRS\")[0].textContent;\n  if (srs === \"EPSG:4326\") {\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({\n      ellipsoid: terrainProviderBuilder.ellipsoid,\n    });\n  } else {\n    throw new RuntimeError(`SRS ${srs} is not supported`);\n  }\n\n  const tileFormat = xml.getElementsByTagName(\"TileFormat\")[0];\n  terrainProviderBuilder.heightmapWidth = parseInt(\n    tileFormat.getAttribute(\"width\"),\n    10,\n  );\n  terrainProviderBuilder.heightmapHeight = parseInt(\n    tileFormat.getAttribute(\"height\"),\n    10,\n  );\n  terrainProviderBuilder.levelZeroMaximumGeometricError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      terrainProviderBuilder.ellipsoid,\n      Math.min(\n        terrainProviderBuilder.heightmapWidth,\n        terrainProviderBuilder.heightmapHeight,\n      ),\n      terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n\n  const dataRectangles = xml.getElementsByTagName(\"DataExtent\");\n\n  for (let i = 0; i < dataRectangles.length; ++i) {\n    const dataRectangle = dataRectangles[i];\n\n    const west = CesiumMath.toRadians(\n      parseFloat(dataRectangle.getAttribute(\"minx\")),\n    );\n    const south = CesiumMath.toRadians(\n      parseFloat(dataRectangle.getAttribute(\"miny\")),\n    );\n    const east = CesiumMath.toRadians(\n      parseFloat(dataRectangle.getAttribute(\"maxx\")),\n    );\n    const north = CesiumMath.toRadians(\n      parseFloat(dataRectangle.getAttribute(\"maxy\")),\n    );\n    const maxLevel = parseInt(dataRectangle.getAttribute(\"maxlevel\"), 10);\n\n    terrainProviderBuilder.rectangles.push(\n      new DataRectangle(new Rectangle(west, south, east, north), maxLevel),\n    );\n  }\n}\n\nfunction metadataFailure(resource, error, provider) {\n  let message = `An error occurred while accessing ${resource.url}`;\n\n  if (defined(error) && defined(error.message)) {\n    message = `${message}: ${error.message}`;\n  }\n\n  TileProviderError.reportError(\n    undefined,\n    provider,\n    defined(provider) ? provider._errorEvent : undefined,\n    message,\n  );\n\n  throw new RuntimeError(message);\n}\n\nasync function requestMetadata(terrainProviderBuilder, resource, provider) {\n  try {\n    const xml = await resource.fetchXML();\n    metadataSuccess(terrainProviderBuilder, xml);\n  } catch (error) {\n    metadataFailure(resource, error, provider);\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a VRTheWorldTerrainProvider, call {@link VRTheWorldTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.\n *\n * @alias VRTheWorldTerrainProvider\n * @constructor\n *\n * @param {VRTheWorldTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n *\n * @example\n * const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction VRTheWorldTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._errorEvent = new Event();\n\n  this._terrainDataStructure = {\n    heightScale: 1.0 / 1000.0,\n    heightOffset: -1000.0,\n    elementsPerHeight: 3,\n    stride: 4,\n    elementMultiplier: 256.0,\n    isBigEndian: true,\n    lowestEncodedHeight: 0,\n    highestEncodedHeight: 256 * 256 * 256 - 1,\n  };\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._tilingScheme = undefined;\n  this._rectangles = [];\n}\n\nObject.defineProperties(VRTheWorldTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.\n *\n * @param {Resource|String} url The URL of the VR-TheWorld TileMap.\n * @param {VRTheWorldTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<VRTheWorldTerrainProvider>}\n *\n * @example\n * const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(\n *   \"https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\"\n * );\n * viewer.terrainProvider = terrainProvider;\n *\n * @exception {RuntimeError} metadata specifies and unknown SRS\n */\nVRTheWorldTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  const resource = Resource.createIfNeeded(url);\n\n  await requestMetadata(terrainProviderBuilder, resource);\n\n  const provider = new VRTheWorldTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n  provider._resource = resource;\n\n  return provider;\n};\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nVRTheWorldTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);\n  const resource = this._resource.getDerivedResource({\n    url: `${level}/${x}/${yTiles - y - 1}.tif`,\n    queryParameters: {\n      cesium: true,\n    },\n    request: request,\n  });\n  const promise = resource.fetchImage({\n    preferImageBitmap: true,\n  });\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(promise).then(function (image) {\n    return new HeightmapTerrainData({\n      buffer: getImagePixels(image),\n      width: that._heightmapWidth,\n      height: that._heightmapHeight,\n      childTileMask: getChildMask(that, x, y, level),\n      structure: that._terrainDataStructure,\n    });\n  });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nVRTheWorldTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level,\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\nconst rectangleScratch = new Rectangle();\n\nfunction getChildMask(provider, x, y, level) {\n  const tilingScheme = provider._tilingScheme;\n  const rectangles = provider._rectangles;\n  const parentRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  let childMask = 0;\n\n  for (let i = 0; i < rectangles.length && childMask !== 15; ++i) {\n    const rectangle = rectangles[i];\n    if (rectangle.maxLevel <= level) {\n      continue;\n    }\n\n    const testRectangle = rectangle.rectangle;\n\n    const intersection = Rectangle.intersection(\n      testRectangle,\n      parentRectangle,\n      rectangleScratch,\n    );\n    if (defined(intersection)) {\n      // Parent tile is inside this rectangle, so at least one child is, too.\n      if (\n        isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2, level + 1)\n      ) {\n        childMask |= 4; // northwest\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2 + 1,\n          y * 2,\n          level + 1,\n        )\n      ) {\n        childMask |= 8; // northeast\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2,\n          y * 2 + 1,\n          level + 1,\n        )\n      ) {\n        childMask |= 1; // southwest\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2 + 1,\n          y * 2 + 1,\n          level + 1,\n        )\n      ) {\n        childMask |= 2; // southeast\n      }\n    }\n  }\n\n  return childMask;\n}\n\nfunction isTileInRectangle(tilingScheme, rectangle, x, y, level) {\n  const tileRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  return defined(\n    Rectangle.intersection(tileRectangle, rectangle, rectangleScratch),\n  );\n}\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nVRTheWorldTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level,\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nVRTheWorldTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level,\n) {\n  return undefined;\n};\nexport default VRTheWorldTerrainProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}