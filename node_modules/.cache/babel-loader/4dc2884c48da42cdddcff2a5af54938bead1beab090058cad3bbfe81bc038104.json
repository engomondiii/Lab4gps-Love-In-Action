{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport WallGeometry from \"../Core/WallGeometry.js\";\nimport WallOutlineGeometry from \"../Core/WallOutlineGeometry.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport Property from \"./Property.js\";\nconst scratchColor = new Color();\nfunction WallGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.minimumHeights = undefined;\n  this.maximumHeights = undefined;\n  this.granularity = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for walls.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias WallGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction WallGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new WallGeometryOptions(entity),\n    geometryPropertyName: \"wall\",\n    observedPropertyNames: [\"availability\", \"wall\"]\n  });\n  this._onEntityPropertyChanged(entity, \"wall\", entity.wall, undefined);\n}\nif (defined(Object.create)) {\n  WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nWallGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  let attributes;\n  let color;\n  const show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n    attributes = {\n      show: show,\n      distanceDisplayCondition: distanceDisplayConditionAttribute,\n      color: color\n    };\n  } else {\n    attributes = {\n      show: show,\n      distanceDisplayCondition: distanceDisplayConditionAttribute\n    };\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new WallGeometry(this._options),\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nWallGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  return new GeometryInstance({\n    id: entity,\n    geometry: new WallOutlineGeometry(this._options),\n    attributes: {\n      show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n      color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n      distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n    }\n  });\n};\nWallGeometryUpdater.prototype._isHidden = function (entity, wall) {\n  return !defined(wall.positions) || GeometryUpdater.prototype._isHidden.call(this, entity, wall);\n};\nWallGeometryUpdater.prototype._getIsClosed = function (options) {\n  return false;\n};\nWallGeometryUpdater.prototype._isDynamic = function (entity, wall) {\n  return !wall.positions.isConstant ||\n  //\n  !Property.isConstant(wall.minimumHeights) ||\n  //\n  !Property.isConstant(wall.maximumHeights) ||\n  //\n  !Property.isConstant(wall.outlineWidth) ||\n  //\n  !Property.isConstant(wall.granularity);\n};\nWallGeometryUpdater.prototype._setStaticOptions = function (entity, wall) {\n  const minimumHeights = wall.minimumHeights;\n  const maximumHeights = wall.maximumHeights;\n  const granularity = wall.granularity;\n  const isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n  const options = this._options;\n  options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.positions = wall.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n  options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;\n  options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;\n  options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n};\nWallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicWallGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\nif (defined(Object.create)) {\n  DynamicWallGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;\n}\nDynamicWallGeometryUpdater.prototype._isHidden = function (entity, wall, time) {\n  return !defined(this._options.positions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time);\n};\nDynamicWallGeometryUpdater.prototype._setOptions = function (entity, wall, time) {\n  const options = this._options;\n  options.positions = Property.getValueOrUndefined(wall.positions, time, options.positions);\n  options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);\n  options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);\n  options.granularity = Property.getValueOrUndefined(wall.granularity, time);\n};\nexport default WallGeometryUpdater;","map":{"version":3,"names":["Check","Color","ColorGeometryInstanceAttribute","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","GeometryInstance","Iso8601","ShowGeometryInstanceAttribute","WallGeometry","WallOutlineGeometry","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","Property","scratchColor","WallGeometryOptions","entity","id","vertexFormat","undefined","positions","minimumHeights","maximumHeights","granularity","WallGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","wall","Object","create","prototype","constructor","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","attributes","color","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","_distanceDisplayConditionProperty","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","_materialProperty","currentColor","isConstant","WHITE","fromColor","geometry","_options","createOutlineGeometryInstance","_outlineEnabled","outlineColor","getValueOrDefault","_outlineColorProperty","BLACK","_showOutlineProperty","_isHidden","_getIsClosed","options","_isDynamic","outlineWidth","_setStaticOptions","isColorMaterial","VERTEX_FORMAT","MaterialSupport","TEXTURED","MINIMUM_VALUE","DynamicWallGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions","getValueOrUndefined"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/WallGeometryUpdater.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport WallGeometry from \"../Core/WallGeometry.js\";\nimport WallOutlineGeometry from \"../Core/WallOutlineGeometry.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport Property from \"./Property.js\";\n\nconst scratchColor = new Color();\n\nfunction WallGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.minimumHeights = undefined;\n  this.maximumHeights = undefined;\n  this.granularity = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for walls.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias WallGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction WallGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new WallGeometryOptions(entity),\n    geometryPropertyName: \"wall\",\n    observedPropertyNames: [\"availability\", \"wall\"],\n  });\n\n  this._onEntityPropertyChanged(entity, \"wall\", entity.wall, undefined);\n}\n\nif (defined(Object.create)) {\n  WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nWallGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n\n  let attributes;\n\n  let color;\n  const show = new ShowGeometryInstanceAttribute(\n    isAvailable &&\n      entity.isShowing &&\n      this._showProperty.getValue(time) &&\n      this._fillProperty.getValue(time),\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute =\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition,\n    );\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n    attributes = {\n      show: show,\n      distanceDisplayCondition: distanceDisplayConditionAttribute,\n      color: color,\n    };\n  } else {\n    attributes = {\n      show: show,\n      distanceDisplayCondition: distanceDisplayConditionAttribute,\n    };\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new WallGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nWallGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new WallOutlineGeometry(this._options),\n    attributes: {\n      show: new ShowGeometryInstanceAttribute(\n        isAvailable &&\n          entity.isShowing &&\n          this._showProperty.getValue(time) &&\n          this._showOutlineProperty.getValue(time),\n      ),\n      color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n      distanceDisplayCondition:\n        DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n          distanceDisplayCondition,\n        ),\n    },\n  });\n};\n\nWallGeometryUpdater.prototype._isHidden = function (entity, wall) {\n  return (\n    !defined(wall.positions) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, wall)\n  );\n};\n\nWallGeometryUpdater.prototype._getIsClosed = function (options) {\n  return false;\n};\n\nWallGeometryUpdater.prototype._isDynamic = function (entity, wall) {\n  return (\n    !wall.positions.isConstant || //\n    !Property.isConstant(wall.minimumHeights) || //\n    !Property.isConstant(wall.maximumHeights) || //\n    !Property.isConstant(wall.outlineWidth) || //\n    !Property.isConstant(wall.granularity)\n  );\n};\n\nWallGeometryUpdater.prototype._setStaticOptions = function (entity, wall) {\n  const minimumHeights = wall.minimumHeights;\n  const maximumHeights = wall.maximumHeights;\n  const granularity = wall.granularity;\n  const isColorMaterial =\n    this._materialProperty instanceof ColorMaterialProperty;\n\n  const options = this._options;\n  options.vertexFormat = isColorMaterial\n    ? PerInstanceColorAppearance.VERTEX_FORMAT\n    : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.positions = wall.positions.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.positions,\n  );\n  options.minimumHeights = defined(minimumHeights)\n    ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights)\n    : undefined;\n  options.maximumHeights = defined(maximumHeights)\n    ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights)\n    : undefined;\n  options.granularity = defined(granularity)\n    ? granularity.getValue(Iso8601.MINIMUM_VALUE)\n    : undefined;\n};\n\nWallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicWallGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives,\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives,\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicWallGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype,\n  );\n  DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;\n}\n\nDynamicWallGeometryUpdater.prototype._isHidden = function (entity, wall, time) {\n  return (\n    !defined(this._options.positions) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time)\n  );\n};\n\nDynamicWallGeometryUpdater.prototype._setOptions = function (\n  entity,\n  wall,\n  time,\n) {\n  const options = this._options;\n  options.positions = Property.getValueOrUndefined(\n    wall.positions,\n    time,\n    options.positions,\n  );\n  options.minimumHeights = Property.getValueOrUndefined(\n    wall.minimumHeights,\n    time,\n    options.minimumHeights,\n  );\n  options.maximumHeights = Property.getValueOrUndefined(\n    wall.maximumHeights,\n    time,\n    options.maximumHeights,\n  );\n  options.granularity = Property.getValueOrUndefined(wall.granularity, time);\n};\nexport default WallGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}