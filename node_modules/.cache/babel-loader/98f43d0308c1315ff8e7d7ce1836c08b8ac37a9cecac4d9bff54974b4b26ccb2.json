{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, Intersections, INF_HIT,\\n\\\n// NO_HIT, setShapeIntersection\\n\\\n\\n\\\n/* Clipping plane defines (set in Scene/VoxelRenderResources.js)\\n\\\n#define CLIPPING_PLANES_UNION\\n\\\n#define CLIPPING_PLANES_COUNT\\n\\\n#define CLIPPING_PLANES_INTERSECTION_INDEX\\n\\\n*/\\n\\\n\\n\\\nuniform sampler2D u_clippingPlanesTexture;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\n\\n\\\n// Plane is in Hessian Normal Form\\n\\\nvec4 intersectPlane(in Ray ray, in vec4 plane) {\\n\\\n    vec3 n = plane.xyz; // normal\\n\\\n    float w = plane.w; // -dot(pointOnPlane, normal)\\n\\\n\\n\\\n    float a = dot(ray.pos, n);\\n\\\n    float b = dot(ray.dir, n);\\n\\\n    float t = -(w + a) / b;\\n\\\n\\n\\\n    return vec4(n, t);\\n\\\n}\\n\\\n\\n\\\nvoid intersectClippingPlanes(in Ray ray, inout Intersections ix) {\\n\\\n    vec4 backSide = vec4(-ray.dir, -INF_HIT);\\n\\\n    vec4 farSide = vec4(ray.dir, +INF_HIT);\\n\\\n    RayShapeIntersection clippingVolume;\\n\\\n\\n\\\n    #if (CLIPPING_PLANES_COUNT == 1)\\n\\\n        // Union and intersection are the same when there's one clipping plane, and the code\\n\\\n        // is more simplified.\\n\\\n        vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, 0, u_clippingPlanesMatrix);\\n\\\n        vec4 intersection = intersectPlane(ray, planeUv);\\n\\\n        bool reflects = dot(ray.dir, intersection.xyz) < 0.0;\\n\\\n        clippingVolume.entry = reflects ? backSide : intersection;\\n\\\n        clippingVolume.exit = reflects ? intersection : farSide;\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume);\\n\\\n    #elif defined(CLIPPING_PLANES_UNION)\\n\\\n        vec4 firstTransmission = vec4(ray.dir, +INF_HIT);\\n\\\n        vec4 lastReflection = vec4(-ray.dir, -INF_HIT);\\n\\\n        for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) {\\n\\\n            vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix);\\n\\\n            vec4 intersection = intersectPlane(ray, planeUv);\\n\\\n            if (dot(ray.dir, planeUv.xyz) > 0.0) {\\n\\\n                firstTransmission = intersection.w <= firstTransmission.w ? intersection : firstTransmission;\\n\\\n            } else {\\n\\\n                lastReflection = intersection.w >= lastReflection.w ? intersection : lastReflection;\\n\\\n            }\\n\\\n        }\\n\\\n        clippingVolume.entry = backSide;\\n\\\n        clippingVolume.exit = lastReflection;\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 0, clippingVolume);\\n\\\n        clippingVolume.entry = firstTransmission;\\n\\\n        clippingVolume.exit = farSide;\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 1, clippingVolume);\\n\\\n    #else // intersection\\n\\\n        vec4 lastTransmission = vec4(ray.dir, -INF_HIT);\\n\\\n        vec4 firstReflection = vec4(-ray.dir, +INF_HIT);\\n\\\n        for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) {\\n\\\n            vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix);\\n\\\n            vec4 intersection = intersectPlane(ray, planeUv);\\n\\\n            if (dot(ray.dir, planeUv.xyz) > 0.0) {\\n\\\n                lastTransmission = intersection.w > lastTransmission.w ? intersection : lastTransmission;\\n\\\n            } else {\\n\\\n                firstReflection = intersection.w < firstReflection.w ? intersection: firstReflection;\\n\\\n            }\\n\\\n        }\\n\\\n        if (lastTransmission.w < firstReflection.w) {\\n\\\n            clippingVolume.entry = lastTransmission;\\n\\\n            clippingVolume.exit = firstReflection;\\n\\\n        } else {\\n\\\n            clippingVolume.entry = vec4(-ray.dir, NO_HIT);\\n\\\n            clippingVolume.exit = vec4(ray.dir, NO_HIT);\\n\\\n        }\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume);\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/IntersectClippingPlanes.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, Intersections, INF_HIT,\\n\\\n// NO_HIT, setShapeIntersection\\n\\\n\\n\\\n/* Clipping plane defines (set in Scene/VoxelRenderResources.js)\\n\\\n#define CLIPPING_PLANES_UNION\\n\\\n#define CLIPPING_PLANES_COUNT\\n\\\n#define CLIPPING_PLANES_INTERSECTION_INDEX\\n\\\n*/\\n\\\n\\n\\\nuniform sampler2D u_clippingPlanesTexture;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\n\\n\\\n// Plane is in Hessian Normal Form\\n\\\nvec4 intersectPlane(in Ray ray, in vec4 plane) {\\n\\\n    vec3 n = plane.xyz; // normal\\n\\\n    float w = plane.w; // -dot(pointOnPlane, normal)\\n\\\n\\n\\\n    float a = dot(ray.pos, n);\\n\\\n    float b = dot(ray.dir, n);\\n\\\n    float t = -(w + a) / b;\\n\\\n\\n\\\n    return vec4(n, t);\\n\\\n}\\n\\\n\\n\\\nvoid intersectClippingPlanes(in Ray ray, inout Intersections ix) {\\n\\\n    vec4 backSide = vec4(-ray.dir, -INF_HIT);\\n\\\n    vec4 farSide = vec4(ray.dir, +INF_HIT);\\n\\\n    RayShapeIntersection clippingVolume;\\n\\\n\\n\\\n    #if (CLIPPING_PLANES_COUNT == 1)\\n\\\n        // Union and intersection are the same when there's one clipping plane, and the code\\n\\\n        // is more simplified.\\n\\\n        vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, 0, u_clippingPlanesMatrix);\\n\\\n        vec4 intersection = intersectPlane(ray, planeUv);\\n\\\n        bool reflects = dot(ray.dir, intersection.xyz) < 0.0;\\n\\\n        clippingVolume.entry = reflects ? backSide : intersection;\\n\\\n        clippingVolume.exit = reflects ? intersection : farSide;\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume);\\n\\\n    #elif defined(CLIPPING_PLANES_UNION)\\n\\\n        vec4 firstTransmission = vec4(ray.dir, +INF_HIT);\\n\\\n        vec4 lastReflection = vec4(-ray.dir, -INF_HIT);\\n\\\n        for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) {\\n\\\n            vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix);\\n\\\n            vec4 intersection = intersectPlane(ray, planeUv);\\n\\\n            if (dot(ray.dir, planeUv.xyz) > 0.0) {\\n\\\n                firstTransmission = intersection.w <= firstTransmission.w ? intersection : firstTransmission;\\n\\\n            } else {\\n\\\n                lastReflection = intersection.w >= lastReflection.w ? intersection : lastReflection;\\n\\\n            }\\n\\\n        }\\n\\\n        clippingVolume.entry = backSide;\\n\\\n        clippingVolume.exit = lastReflection;\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 0, clippingVolume);\\n\\\n        clippingVolume.entry = firstTransmission;\\n\\\n        clippingVolume.exit = farSide;\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 1, clippingVolume);\\n\\\n    #else // intersection\\n\\\n        vec4 lastTransmission = vec4(ray.dir, -INF_HIT);\\n\\\n        vec4 firstReflection = vec4(-ray.dir, +INF_HIT);\\n\\\n        for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) {\\n\\\n            vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix);\\n\\\n            vec4 intersection = intersectPlane(ray, planeUv);\\n\\\n            if (dot(ray.dir, planeUv.xyz) > 0.0) {\\n\\\n                lastTransmission = intersection.w > lastTransmission.w ? intersection : lastTransmission;\\n\\\n            } else {\\n\\\n                firstReflection = intersection.w < firstReflection.w ? intersection: firstReflection;\\n\\\n            }\\n\\\n        }\\n\\\n        if (lastTransmission.w < firstReflection.w) {\\n\\\n            clippingVolume.entry = lastTransmission;\\n\\\n            clippingVolume.exit = firstReflection;\\n\\\n        } else {\\n\\\n            clippingVolume.entry = vec4(-ray.dir, NO_HIT);\\n\\\n            clippingVolume.exit = vec4(ray.dir, NO_HIT);\\n\\\n        }\\n\\\n        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume);\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}