{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nconst radiusScratch = new Cartesian2();\nconst normalScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.length The length of the cylinder.\n * @param {number} options.topRadius The radius of the top of the cylinder.\n * @param {number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const slices = defaultValue(options.slices, 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\"options.slices must be greater than or equal to 3.\");\n  }\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const vertexFormat = cylinderGeometry._vertexFormat;\n  const slices = cylinderGeometry._slices;\n  if (length <= 0 || topRadius < 0 || bottomRadius < 0 || topRadius === 0 && bottomRadius === 0) {\n    return;\n  }\n  const twoSlices = slices + slices;\n  const threeSlices = slices + twoSlices;\n  const numVertices = twoSlices + twoSlices;\n  const positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\n  const st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(numVertices * 3) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(numVertices * 3) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(numVertices * 3) : undefined;\n  let i;\n  const computeNormal = vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n  if (computeNormal) {\n    const computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n    let normalIndex = 0;\n    let tangentIndex = 0;\n    let bitangentIndex = 0;\n    const theta = Math.atan2(bottomRadius - topRadius, length);\n    const normal = normalScratch;\n    normal.z = Math.sin(theta);\n    const normalScale = Math.cos(theta);\n    let tangent = tangentScratch;\n    let bitangent = bitangentScratch;\n    for (i = 0; i < slices; i++) {\n      const angle = i / slices * CesiumMath.TWO_PI;\n      const x = normalScale * Math.cos(angle);\n      const y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n  const numIndices = 12 * slices - 12;\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  let index = 0;\n  let j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n    j += 2;\n  }\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n  let textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    const rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      const position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    });\n  }\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st\n    });\n  }\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n  const boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute\n  });\n};\nlet unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\n      topRadius: 1.0,\n      bottomRadius: 1.0,\n      length: 1.0,\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","ComponentDatatype","CylinderGeometryLibrary","defaultValue","defined","DeveloperError","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","VertexFormat","radiusScratch","normalScratch","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","EMPTY_OBJECT","length","topRadius","bottomRadius","vertexFormat","DEFAULT","slices","offsetAttribute","TOP","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchVertexFormat","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","positions","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","i","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","ZERO","magnitude","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","TRIANGLES","unitCylinderGeometry","getUnitCylinder","POSITION_ONLY"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CylinderGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst radiusScratch = new Cartesian2();\nconst normalScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.length The length of the cylinder.\n * @param {number} options.topRadius The radius of the top of the cylinder.\n * @param {number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const slices = defaultValue(options.slices, 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\n      \"options.slices must be greater than or equal to 3.\",\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const vertexFormat = cylinderGeometry._vertexFormat;\n  const slices = cylinderGeometry._slices;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const twoSlices = slices + slices;\n  const threeSlices = slices + twoSlices;\n  const numVertices = twoSlices + twoSlices;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    true,\n  );\n\n  const st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  const normals = vertexFormat.normal\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n\n  let i;\n  const computeNormal =\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    const computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n\n    let normalIndex = 0;\n    let tangentIndex = 0;\n    let bitangentIndex = 0;\n\n    const theta = Math.atan2(bottomRadius - topRadius, length);\n    const normal = normalScratch;\n    normal.z = Math.sin(theta);\n    const normalScale = Math.cos(theta);\n    let tangent = tangentScratch;\n    let bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      const angle = (i / slices) * CesiumMath.TWO_PI;\n      const x = normalScale * Math.cos(angle);\n      const y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent,\n          );\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  const numIndices = 12 * slices - 12;\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  let index = 0;\n  let j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  let textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    const rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      const position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch),\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\n\nlet unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\n      new CylinderGeometry({\n        topRadius: 1.0,\n        bottomRadius: 1.0,\n        length: 1.0,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      }),\n    );\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}