{"ast":null,"code":"import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Cesium3DTileRefine from \"../Cesium3DTileRefine.js\";\nimport clone from \"../../Core/clone.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OrthographicFrustum from \"../../Core/OrthographicFrustum.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport PointCloudStylingStageVS from \"../../Shaders/Model/PointCloudStylingStageVS.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nconst scratchUniform = new Cartesian4();\n\n/**\n * The point cloud styling stage is responsible for applying color,\n * size, and show styles to point clouds at runtime. It also handles\n * point cloud shading provided by either the model or the tileset that\n * owns it. Point cloud shading is only applied if no point size style\n * is provided.\n *\n * @namespace PointCloudStylingPipelineStage\n *\n * @private\n */\nconst PointCloudStylingPipelineStage = {\n  name: \"PointCloudStylingPipelineStage\" // Helps with debugging\n};\n\n/**\n * Processes a primitive. If the model that owns it has a style, then\n * this stage modifies the following parts of the render resources:\n * <ul>\n *  <li>adds the styling functions to the vertex shaders</li>\n *  <li>adds a define to compute the position in world coordinates</li>\n *  <li>adds a varying to compute point cloud color</li>\n * </ul>\n *\n * If the model has point cloud shading, then this stage modifies the following\n * part of the render resources:\n * <ul>\n *  <li>adds vertex shader code to compute attenuation and update gl_PointSize</li>\n *  <li>updates the uniform map to pass in point cloud parameters</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nPointCloudStylingPipelineStage.process = function (renderResources, primitive, frameState) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const style = model.style;\n\n  // Point cloud styling will only be applied on the GPU if there is\n  // no batch table. If a batch table exists, then:\n  //  - the property attribute will not be defined\n  //  - the model will be using a feature table\n\n  const structuralMetadata = model.structuralMetadata;\n  const propertyAttributes = defined(structuralMetadata) ? structuralMetadata.propertyAttributes : undefined;\n  const hasFeatureTable = defined(model.featureTableId) && model.featureTables[model.featureTableId].featuresLength > 0;\n  const hasBatchTable = !defined(propertyAttributes) && hasFeatureTable;\n  if (defined(style) && !hasBatchTable) {\n    const variableSubstitutionMap = getVariableSubstitutionMap(propertyAttributes);\n    const shaderFunctionInfo = getStyleShaderFunctionInfo(style, variableSubstitutionMap);\n    addShaderFunctionsAndDefines(shaderBuilder, shaderFunctionInfo);\n    const propertyNames = getPropertyNames(shaderFunctionInfo);\n    const usesNormalSemantic = propertyNames.indexOf(\"normalMC\") >= 0;\n    const hasNormals = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.NORMAL);\n    if (usesNormalSemantic && !hasNormals) {\n      throw new RuntimeError(\"Style references the NORMAL semantic but the point cloud does not have normals\");\n    }\n    shaderBuilder.addDefine(\"COMPUTE_POSITION_WC_STYLE\", undefined, ShaderDestination.VERTEX);\n\n    // If the style is translucent, the alpha options must be adjusted.\n    const styleTranslucent = shaderFunctionInfo.styleTranslucent;\n    if (styleTranslucent) {\n      renderResources.alphaOptions.pass = Pass.TRANSLUCENT;\n    }\n  }\n  const pointCloudShading = model.pointCloudShading;\n  if (pointCloudShading.attenuation) {\n    shaderBuilder.addDefine(\"HAS_POINT_CLOUD_ATTENUATION\", undefined, ShaderDestination.VERTEX);\n  }\n  if (pointCloudShading.backFaceCulling) {\n    shaderBuilder.addDefine(\"HAS_POINT_CLOUD_BACK_FACE_CULLING\", undefined, ShaderDestination.VERTEX);\n  }\n  let content;\n  let is3DTiles;\n  let usesAddRefinement;\n  if (ModelType.is3DTiles(model.type)) {\n    is3DTiles = true;\n    content = model.content;\n    usesAddRefinement = content.tile.refine === Cesium3DTileRefine.ADD;\n  }\n  shaderBuilder.addUniform(\"vec4\", \"model_pointCloudParameters\", ShaderDestination.VERTEX);\n  shaderBuilder.addVertexLines(PointCloudStylingStageVS);\n  const uniformMap = renderResources.uniformMap;\n  uniformMap.model_pointCloudParameters = function () {\n    const vec4 = scratchUniform;\n\n    // Point size\n    let defaultPointSize = 1.0;\n    if (is3DTiles) {\n      defaultPointSize = usesAddRefinement ? 5.0 : content.tileset.memoryAdjustedScreenSpaceError;\n    }\n    vec4.x = defaultValue(pointCloudShading.maximumAttenuation, defaultPointSize);\n    vec4.x *= frameState.pixelRatio;\n\n    // Geometric error\n    const geometricError = getGeometricError(renderResources, primitive, pointCloudShading, content);\n    vec4.y = geometricError * pointCloudShading.geometricErrorScale;\n    const context = frameState.context;\n    const frustum = frameState.camera.frustum;\n    let depthMultiplier;\n\n    // Attenuation is maximumAttenuation in 2D/ortho\n    if (frameState.mode === SceneMode.SCENE2D || frustum instanceof OrthographicFrustum) {\n      depthMultiplier = Number.POSITIVE_INFINITY;\n    } else {\n      depthMultiplier = context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n    }\n\n    // Depth multiplier\n    vec4.z = depthMultiplier;\n\n    // Time\n    if (is3DTiles) {\n      vec4.w = content.tileset.timeSinceLoad;\n    }\n    return vec4;\n  };\n};\nconst scratchDimensions = new Cartesian3();\nfunction getGeometricError(renderResources, primitive, pointCloudShading, content) {\n  if (defined(content)) {\n    const geometricError = content.tile.geometricError;\n    if (geometricError > 0) {\n      return geometricError;\n    }\n  }\n  if (defined(pointCloudShading.baseResolution)) {\n    return pointCloudShading.baseResolution;\n  }\n  const positionAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.POSITION);\n  const pointsLength = positionAttribute.count;\n\n  // Estimate the geometric error\n  const nodeTransform = renderResources.runtimeNode.transform;\n  let dimensions = Cartesian3.subtract(positionAttribute.max, positionAttribute.min, scratchDimensions);\n  // dimensions is a vector, as it is a subtraction between two points\n  dimensions = Matrix4.multiplyByPointAsVector(nodeTransform, dimensions, scratchDimensions);\n  const volume = dimensions.x * dimensions.y * dimensions.z;\n  const geometricErrorEstimate = CesiumMath.cbrt(volume / pointsLength);\n  return geometricErrorEstimate;\n}\nconst scratchShaderFunctionInfo = {\n  colorStyleFunction: undefined,\n  showStyleFunction: undefined,\n  pointSizeStyleFunction: undefined,\n  styleTranslucent: false\n};\nconst builtinVariableSubstitutionMap = {\n  POSITION: \"attributes.positionMC\",\n  POSITION_ABSOLUTE: \"v_positionWC\",\n  COLOR: \"attributes.color_0\",\n  NORMAL: \"attributes.normalMC\"\n};\nfunction getVariableSubstitutionMap(propertyAttributes) {\n  const variableSubstitutionMap = clone(builtinVariableSubstitutionMap);\n  if (!defined(propertyAttributes)) {\n    return variableSubstitutionMap;\n  }\n  for (let i = 0; i < propertyAttributes.length; i++) {\n    const propertyAttribute = propertyAttributes[i];\n    const properties = propertyAttribute.properties;\n    for (const propertyId in properties) {\n      // The property ID was already sanitized for GLSL by PntsLoader.\n      if (properties.hasOwnProperty(propertyId)) {\n        variableSubstitutionMap[propertyId] = `metadata.${propertyId}`;\n      }\n    }\n  }\n  return variableSubstitutionMap;\n}\nconst parameterList = \"ProcessedAttributes attributes, \" + \"Metadata metadata, \" + \"float tiles3d_tileset_time\";\nfunction getStyleShaderFunctionInfo(style, variableSubstitutionMap) {\n  const info = scratchShaderFunctionInfo;\n  const shaderState = {\n    translucent: false\n  };\n  info.colorStyleFunction = style.getColorShaderFunction(`getColorFromStyle(${parameterList})`, variableSubstitutionMap, shaderState);\n  info.showStyleFunction = style.getShowShaderFunction(`getShowFromStyle(${parameterList})`, variableSubstitutionMap, shaderState);\n  info.pointSizeStyleFunction = style.getPointSizeShaderFunction(`getPointSizeFromStyle(${parameterList})`, variableSubstitutionMap, shaderState);\n  info.styleTranslucent = defined(info.colorStyleFunction) && shaderState.translucent;\n  return info;\n}\nfunction addShaderFunctionsAndDefines(shaderBuilder, shaderFunctionInfo) {\n  const colorStyleFunction = shaderFunctionInfo.colorStyleFunction;\n  if (defined(colorStyleFunction)) {\n    shaderBuilder.addDefine(\"HAS_POINT_CLOUD_COLOR_STYLE\", undefined, ShaderDestination.BOTH);\n    shaderBuilder.addVertexLines(colorStyleFunction);\n\n    // The point cloud may not necessarily have a color attribute.\n    // Use a custom varying to account for this.\n    shaderBuilder.addVarying(\"vec4\", \"v_pointCloudColor\");\n  }\n  const showStyleFunction = shaderFunctionInfo.showStyleFunction;\n  if (defined(showStyleFunction)) {\n    shaderBuilder.addDefine(\"HAS_POINT_CLOUD_SHOW_STYLE\", undefined, ShaderDestination.BOTH);\n    shaderBuilder.addVertexLines(showStyleFunction);\n    shaderBuilder.addVarying(\"float\", \"v_pointCloudShow\");\n  }\n  const pointSizeStyleFunction = shaderFunctionInfo.pointSizeStyleFunction;\n  if (defined(pointSizeStyleFunction)) {\n    shaderBuilder.addDefine(\"HAS_POINT_CLOUD_POINT_SIZE_STYLE\", undefined, ShaderDestination.VERTEX);\n    shaderBuilder.addVertexLines(pointSizeStyleFunction);\n  }\n}\n\n/**\n * Gets all the built-in property names used by the given style\n * function.\n *\n * @param {Function} source The style function.\n * @param {string[]} propertyNames The array of property names to add to.\n *\n * @private\n */\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  const regex = /attributes\\.(\\w+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const name = matches[1];\n    // Add the property name if it isn't already in the array.\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\nfunction getPropertyNames(shaderFunctionInfo) {\n  const colorStyleFunction = shaderFunctionInfo.colorStyleFunction;\n  const showStyleFunction = shaderFunctionInfo.showStyleFunction;\n  const pointSizeStyleFunction = shaderFunctionInfo.pointSizeStyleFunction;\n\n  // Get the properties in use by the style.\n  const builtinPropertyNames = [];\n  if (defined(colorStyleFunction)) {\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n  }\n  if (defined(showStyleFunction)) {\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n  }\n  if (defined(pointSizeStyleFunction)) {\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n  }\n  return builtinPropertyNames;\n}\nexport default PointCloudStylingPipelineStage;","map":{"version":3,"names":["Cartesian3","Cartesian4","CesiumMath","Cesium3DTileRefine","clone","defaultValue","defined","Matrix4","ModelType","ModelUtility","OrthographicFrustum","Pass","PointCloudStylingStageVS","RuntimeError","SceneMode","ShaderDestination","VertexAttributeSemantic","scratchUniform","PointCloudStylingPipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","model","style","structuralMetadata","propertyAttributes","undefined","hasFeatureTable","featureTableId","featureTables","featuresLength","hasBatchTable","variableSubstitutionMap","getVariableSubstitutionMap","shaderFunctionInfo","getStyleShaderFunctionInfo","addShaderFunctionsAndDefines","propertyNames","getPropertyNames","usesNormalSemantic","indexOf","hasNormals","getAttributeBySemantic","NORMAL","addDefine","VERTEX","styleTranslucent","alphaOptions","pass","TRANSLUCENT","pointCloudShading","attenuation","backFaceCulling","content","is3DTiles","usesAddRefinement","type","tile","refine","ADD","addUniform","addVertexLines","uniformMap","model_pointCloudParameters","vec4","defaultPointSize","tileset","memoryAdjustedScreenSpaceError","x","maximumAttenuation","pixelRatio","geometricError","getGeometricError","y","geometricErrorScale","context","frustum","camera","depthMultiplier","mode","SCENE2D","Number","POSITIVE_INFINITY","drawingBufferHeight","sseDenominator","z","w","timeSinceLoad","scratchDimensions","baseResolution","positionAttribute","POSITION","pointsLength","count","nodeTransform","runtimeNode","transform","dimensions","subtract","max","min","multiplyByPointAsVector","volume","geometricErrorEstimate","cbrt","scratchShaderFunctionInfo","colorStyleFunction","showStyleFunction","pointSizeStyleFunction","builtinVariableSubstitutionMap","POSITION_ABSOLUTE","COLOR","i","length","propertyAttribute","properties","propertyId","hasOwnProperty","parameterList","info","shaderState","translucent","getColorShaderFunction","getShowShaderFunction","getPointSizeShaderFunction","BOTH","addVarying","getBuiltinPropertyNames","source","regex","matches","exec","push","builtinPropertyNames"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/PointCloudStylingPipelineStage.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Cesium3DTileRefine from \"../Cesium3DTileRefine.js\";\nimport clone from \"../../Core/clone.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OrthographicFrustum from \"../../Core/OrthographicFrustum.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport PointCloudStylingStageVS from \"../../Shaders/Model/PointCloudStylingStageVS.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst scratchUniform = new Cartesian4();\n\n/**\n * The point cloud styling stage is responsible for applying color,\n * size, and show styles to point clouds at runtime. It also handles\n * point cloud shading provided by either the model or the tileset that\n * owns it. Point cloud shading is only applied if no point size style\n * is provided.\n *\n * @namespace PointCloudStylingPipelineStage\n *\n * @private\n */\nconst PointCloudStylingPipelineStage = {\n  name: \"PointCloudStylingPipelineStage\", // Helps with debugging\n};\n\n/**\n * Processes a primitive. If the model that owns it has a style, then\n * this stage modifies the following parts of the render resources:\n * <ul>\n *  <li>adds the styling functions to the vertex shaders</li>\n *  <li>adds a define to compute the position in world coordinates</li>\n *  <li>adds a varying to compute point cloud color</li>\n * </ul>\n *\n * If the model has point cloud shading, then this stage modifies the following\n * part of the render resources:\n * <ul>\n *  <li>adds vertex shader code to compute attenuation and update gl_PointSize</li>\n *  <li>updates the uniform map to pass in point cloud parameters</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nPointCloudStylingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const style = model.style;\n\n  // Point cloud styling will only be applied on the GPU if there is\n  // no batch table. If a batch table exists, then:\n  //  - the property attribute will not be defined\n  //  - the model will be using a feature table\n\n  const structuralMetadata = model.structuralMetadata;\n  const propertyAttributes = defined(structuralMetadata)\n    ? structuralMetadata.propertyAttributes\n    : undefined;\n\n  const hasFeatureTable =\n    defined(model.featureTableId) &&\n    model.featureTables[model.featureTableId].featuresLength > 0;\n\n  const hasBatchTable = !defined(propertyAttributes) && hasFeatureTable;\n\n  if (defined(style) && !hasBatchTable) {\n    const variableSubstitutionMap =\n      getVariableSubstitutionMap(propertyAttributes);\n    const shaderFunctionInfo = getStyleShaderFunctionInfo(\n      style,\n      variableSubstitutionMap,\n    );\n    addShaderFunctionsAndDefines(shaderBuilder, shaderFunctionInfo);\n\n    const propertyNames = getPropertyNames(shaderFunctionInfo);\n\n    const usesNormalSemantic = propertyNames.indexOf(\"normalMC\") >= 0;\n    const hasNormals = ModelUtility.getAttributeBySemantic(\n      primitive,\n      VertexAttributeSemantic.NORMAL,\n    );\n\n    if (usesNormalSemantic && !hasNormals) {\n      throw new RuntimeError(\n        \"Style references the NORMAL semantic but the point cloud does not have normals\",\n      );\n    }\n\n    shaderBuilder.addDefine(\n      \"COMPUTE_POSITION_WC_STYLE\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n\n    // If the style is translucent, the alpha options must be adjusted.\n    const styleTranslucent = shaderFunctionInfo.styleTranslucent;\n    if (styleTranslucent) {\n      renderResources.alphaOptions.pass = Pass.TRANSLUCENT;\n    }\n  }\n\n  const pointCloudShading = model.pointCloudShading;\n  if (pointCloudShading.attenuation) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_ATTENUATION\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n  }\n\n  if (pointCloudShading.backFaceCulling) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_BACK_FACE_CULLING\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n  }\n\n  let content;\n  let is3DTiles;\n  let usesAddRefinement;\n\n  if (ModelType.is3DTiles(model.type)) {\n    is3DTiles = true;\n    content = model.content;\n    usesAddRefinement = content.tile.refine === Cesium3DTileRefine.ADD;\n  }\n\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_pointCloudParameters\",\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVertexLines(PointCloudStylingStageVS);\n\n  const uniformMap = renderResources.uniformMap;\n  uniformMap.model_pointCloudParameters = function () {\n    const vec4 = scratchUniform;\n\n    // Point size\n    let defaultPointSize = 1.0;\n    if (is3DTiles) {\n      defaultPointSize = usesAddRefinement\n        ? 5.0\n        : content.tileset.memoryAdjustedScreenSpaceError;\n    }\n    vec4.x = defaultValue(\n      pointCloudShading.maximumAttenuation,\n      defaultPointSize,\n    );\n    vec4.x *= frameState.pixelRatio;\n\n    // Geometric error\n    const geometricError = getGeometricError(\n      renderResources,\n      primitive,\n      pointCloudShading,\n      content,\n    );\n    vec4.y = geometricError * pointCloudShading.geometricErrorScale;\n\n    const context = frameState.context;\n    const frustum = frameState.camera.frustum;\n    let depthMultiplier;\n\n    // Attenuation is maximumAttenuation in 2D/ortho\n    if (\n      frameState.mode === SceneMode.SCENE2D ||\n      frustum instanceof OrthographicFrustum\n    ) {\n      depthMultiplier = Number.POSITIVE_INFINITY;\n    } else {\n      depthMultiplier =\n        context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n    }\n\n    // Depth multiplier\n    vec4.z = depthMultiplier;\n\n    // Time\n    if (is3DTiles) {\n      vec4.w = content.tileset.timeSinceLoad;\n    }\n\n    return vec4;\n  };\n};\n\nconst scratchDimensions = new Cartesian3();\nfunction getGeometricError(\n  renderResources,\n  primitive,\n  pointCloudShading,\n  content,\n) {\n  if (defined(content)) {\n    const geometricError = content.tile.geometricError;\n\n    if (geometricError > 0) {\n      return geometricError;\n    }\n  }\n\n  if (defined(pointCloudShading.baseResolution)) {\n    return pointCloudShading.baseResolution;\n  }\n\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const pointsLength = positionAttribute.count;\n\n  // Estimate the geometric error\n  const nodeTransform = renderResources.runtimeNode.transform;\n  let dimensions = Cartesian3.subtract(\n    positionAttribute.max,\n    positionAttribute.min,\n    scratchDimensions,\n  );\n  // dimensions is a vector, as it is a subtraction between two points\n  dimensions = Matrix4.multiplyByPointAsVector(\n    nodeTransform,\n    dimensions,\n    scratchDimensions,\n  );\n  const volume = dimensions.x * dimensions.y * dimensions.z;\n  const geometricErrorEstimate = CesiumMath.cbrt(volume / pointsLength);\n  return geometricErrorEstimate;\n}\n\nconst scratchShaderFunctionInfo = {\n  colorStyleFunction: undefined,\n  showStyleFunction: undefined,\n  pointSizeStyleFunction: undefined,\n  styleTranslucent: false,\n};\n\nconst builtinVariableSubstitutionMap = {\n  POSITION: \"attributes.positionMC\",\n  POSITION_ABSOLUTE: \"v_positionWC\",\n  COLOR: \"attributes.color_0\",\n  NORMAL: \"attributes.normalMC\",\n};\n\nfunction getVariableSubstitutionMap(propertyAttributes) {\n  const variableSubstitutionMap = clone(builtinVariableSubstitutionMap);\n\n  if (!defined(propertyAttributes)) {\n    return variableSubstitutionMap;\n  }\n\n  for (let i = 0; i < propertyAttributes.length; i++) {\n    const propertyAttribute = propertyAttributes[i];\n    const properties = propertyAttribute.properties;\n    for (const propertyId in properties) {\n      // The property ID was already sanitized for GLSL by PntsLoader.\n      if (properties.hasOwnProperty(propertyId)) {\n        variableSubstitutionMap[propertyId] = `metadata.${propertyId}`;\n      }\n    }\n  }\n\n  return variableSubstitutionMap;\n}\nconst parameterList =\n  \"ProcessedAttributes attributes, \" +\n  \"Metadata metadata, \" +\n  \"float tiles3d_tileset_time\";\n\nfunction getStyleShaderFunctionInfo(style, variableSubstitutionMap) {\n  const info = scratchShaderFunctionInfo;\n  const shaderState = {\n    translucent: false,\n  };\n\n  info.colorStyleFunction = style.getColorShaderFunction(\n    `getColorFromStyle(${parameterList})`,\n    variableSubstitutionMap,\n    shaderState,\n  );\n  info.showStyleFunction = style.getShowShaderFunction(\n    `getShowFromStyle(${parameterList})`,\n    variableSubstitutionMap,\n    shaderState,\n  );\n  info.pointSizeStyleFunction = style.getPointSizeShaderFunction(\n    `getPointSizeFromStyle(${parameterList})`,\n    variableSubstitutionMap,\n    shaderState,\n  );\n  info.styleTranslucent =\n    defined(info.colorStyleFunction) && shaderState.translucent;\n\n  return info;\n}\n\nfunction addShaderFunctionsAndDefines(shaderBuilder, shaderFunctionInfo) {\n  const colorStyleFunction = shaderFunctionInfo.colorStyleFunction;\n  if (defined(colorStyleFunction)) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_COLOR_STYLE\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n    shaderBuilder.addVertexLines(colorStyleFunction);\n\n    // The point cloud may not necessarily have a color attribute.\n    // Use a custom varying to account for this.\n    shaderBuilder.addVarying(\"vec4\", \"v_pointCloudColor\");\n  }\n\n  const showStyleFunction = shaderFunctionInfo.showStyleFunction;\n  if (defined(showStyleFunction)) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_SHOW_STYLE\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n    shaderBuilder.addVertexLines(showStyleFunction);\n    shaderBuilder.addVarying(\"float\", \"v_pointCloudShow\");\n  }\n\n  const pointSizeStyleFunction = shaderFunctionInfo.pointSizeStyleFunction;\n  if (defined(pointSizeStyleFunction)) {\n    shaderBuilder.addDefine(\n      \"HAS_POINT_CLOUD_POINT_SIZE_STYLE\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addVertexLines(pointSizeStyleFunction);\n  }\n}\n\n/**\n * Gets all the built-in property names used by the given style\n * function.\n *\n * @param {Function} source The style function.\n * @param {string[]} propertyNames The array of property names to add to.\n *\n * @private\n */\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  const regex = /attributes\\.(\\w+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const name = matches[1];\n    // Add the property name if it isn't already in the array.\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getPropertyNames(shaderFunctionInfo) {\n  const colorStyleFunction = shaderFunctionInfo.colorStyleFunction;\n  const showStyleFunction = shaderFunctionInfo.showStyleFunction;\n  const pointSizeStyleFunction = shaderFunctionInfo.pointSizeStyleFunction;\n\n  // Get the properties in use by the style.\n  const builtinPropertyNames = [];\n\n  if (defined(colorStyleFunction)) {\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n  }\n  if (defined(showStyleFunction)) {\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n  }\n  if (defined(pointSizeStyleFunction)) {\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n  }\n\n  return builtinPropertyNames;\n}\n\nexport default PointCloudStylingPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}