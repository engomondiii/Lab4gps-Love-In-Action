{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport srgbToLinear from \"../Core/srgbToLinear.js\";\n\n/**\n * This class implements an I3S Geometry. Each I3SGeometry\n * generates an in memory glTF to be used as content for a Cesium3DTile\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SNode}.\n * </p>\n * @alias I3SGeometry\n * @internalConstructor\n * @privateParam {I3SNode} parent The parent of that geometry\n * @privateParam {string} uri The uri to load the data from\n */\nfunction I3SGeometry(parent, uri) {\n  const dataProvider = parent._dataProvider;\n  const layer = parent._layer;\n  let resource;\n  if (defined(parent._nodeIndex)) {\n    resource = layer.resource.getDerivedResource({\n      url: `nodes/${parent._data.mesh.geometry.resource}/${uri}`\n    });\n  } else {\n    resource = parent.resource.getDerivedResource({\n      url: uri\n    });\n  }\n  this._parent = parent;\n  this._dataProvider = dataProvider;\n  this._layer = layer;\n  this._resource = resource;\n  this._customAttributes = undefined;\n}\nObject.defineProperties(I3SGeometry.prototype, {\n  /**\n   * Gets the resource for the geometry\n   * @memberof I3SGeometry.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    }\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SGeometry.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    }\n  },\n  /**\n   * Gets the custom attributes of the geometry.\n   * @memberof I3SGeometry.prototype\n   * @type {object}\n   * @readonly\n   */\n  customAttributes: {\n    get: function () {\n      return this._customAttributes;\n    }\n  }\n});\n\n/**\n * Loads the content.\n * @returns {Promise<object>} A promise that is resolved when the geometry data is loaded\n * @private\n */\nI3SGeometry.prototype.load = function () {\n  const that = this;\n  return this._dataProvider._loadBinary(this._resource).then(function (data) {\n    that._data = data;\n    return data;\n  });\n};\nconst scratchAb = new Cartesian3();\nconst scratchAp1 = new Cartesian3();\nconst scratchAp2 = new Cartesian3();\nconst scratchCp1 = new Cartesian3();\nconst scratchCp2 = new Cartesian3();\nfunction sameSide(p1, p2, a, b) {\n  const ab = Cartesian3.subtract(b, a, scratchAb);\n  const cp1 = Cartesian3.cross(ab, Cartesian3.subtract(p1, a, scratchAp1), scratchCp1);\n  const cp2 = Cartesian3.cross(ab, Cartesian3.subtract(p2, a, scratchAp2), scratchCp2);\n  return Cartesian3.dot(cp1, cp2) >= 0;\n}\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\nconst scratchV0V1 = new Cartesian3();\nconst scratchV0V2 = new Cartesian3();\nconst scratchCrossProd = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchV0p = new Cartesian3();\nconst scratchV1p = new Cartesian3();\nconst scratchV2p = new Cartesian3();\n\n/**\n * Find a triangle touching the point [px, py, pz], then return the vertex closest to the search point\n * @param {number} px The x component of the point to query\n * @param {number} py The y component of the point to query\n * @param {number} pz The z component of the point to query\n * @returns {object} A structure containing the index of the closest point,\n * the squared distance from the queried point to the point that is found,\n * the distance from the queried point to the point that is found,\n * the queried position in local space,\n * the closest position in local space\n */\nI3SGeometry.prototype.getClosestPointIndexOnTriangle = function (px, py, pz) {\n  if (defined(this._customAttributes) && defined(this._customAttributes.positions)) {\n    // Convert queried position to local\n    const position = new Cartesian3(px, py, pz);\n    position.x -= this._customAttributes.cartesianCenter.x;\n    position.y -= this._customAttributes.cartesianCenter.y;\n    position.z -= this._customAttributes.cartesianCenter.z;\n    Matrix3.multiplyByVector(this._customAttributes.parentRotation, position, position);\n    let bestTriDist = Number.MAX_VALUE;\n    let bestTri;\n    let bestDistSq;\n    let bestIndex;\n    let bestPt;\n\n    // Brute force lookup, @TODO: this can be improved with a spatial partitioning search system\n    const positions = this._customAttributes.positions;\n    const indices = this._customAttributes.indices;\n\n    // We may have indexed or non-indexed triangles here\n    let triCount;\n    if (defined(indices)) {\n      triCount = indices.length;\n    } else {\n      triCount = positions.length / 3;\n    }\n    for (let triIndex = 0; triIndex < triCount; triIndex++) {\n      let i0, i1, i2;\n      if (defined(indices)) {\n        i0 = indices[triIndex];\n        i1 = indices[triIndex + 1];\n        i2 = indices[triIndex + 2];\n      } else {\n        i0 = triIndex * 3;\n        i1 = triIndex * 3 + 1;\n        i2 = triIndex * 3 + 2;\n      }\n      const v0 = Cartesian3.fromElements(positions[i0 * 3], positions[i0 * 3 + 1], positions[i0 * 3 + 2], scratchV0);\n      const v1 = Cartesian3.fromElements(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2], scratchV1);\n      const v2 = new Cartesian3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2], scratchV2);\n\n      // Check how the point is positioned relative to the triangle.\n      // This will tell us whether the projection of the point in the triangle's plane lands in the triangle\n      if (!sameSide(position, v0, v1, v2) || !sameSide(position, v1, v0, v2) || !sameSide(position, v2, v0, v1)) {\n        continue;\n      }\n      // Because of precision issues, we can't always reliably tell if the point lands directly on the face, so the most robust way is just to find the closest one\n      const v0v1 = Cartesian3.subtract(v1, v0, scratchV0V1);\n      const v0v2 = Cartesian3.subtract(v2, v0, scratchV0V2);\n      const crossProd = Cartesian3.cross(v0v1, v0v2, scratchCrossProd);\n\n      // Skip \"triangles\" with 3 colinear points\n      if (Cartesian3.magnitude(crossProd) === 0) {\n        continue;\n      }\n      const normal = Cartesian3.normalize(crossProd, scratchNormal);\n      const v0p = Cartesian3.subtract(position, v0, scratchV0p);\n      const normalDist = Math.abs(Cartesian3.dot(v0p, normal));\n      if (normalDist < bestTriDist) {\n        bestTriDist = normalDist;\n        bestTri = triIndex;\n\n        // Found a triangle, return the index of the closest point\n        const d0 = Cartesian3.magnitudeSquared(Cartesian3.subtract(position, v0, v0p));\n        const d1 = Cartesian3.magnitudeSquared(Cartesian3.subtract(position, v1, scratchV1p));\n        const d2 = Cartesian3.magnitudeSquared(Cartesian3.subtract(position, v2, scratchV2p));\n        if (d0 < d1 && d0 < d2) {\n          bestIndex = i0;\n          bestPt = v0;\n          bestDistSq = d0;\n        } else if (d1 < d2) {\n          bestIndex = i1;\n          bestPt = v1;\n          bestDistSq = d1;\n        } else {\n          bestIndex = i2;\n          bestPt = v2;\n          bestDistSq = d2;\n        }\n      }\n    }\n    if (defined(bestTri)) {\n      return {\n        index: bestIndex,\n        distanceSquared: bestDistSq,\n        distance: Math.sqrt(bestDistSq),\n        queriedPosition: position,\n        closestPosition: Cartesian3.clone(bestPt)\n      };\n    }\n  }\n\n  // No hits found\n  return {\n    index: -1,\n    distanceSquared: Number.Infinity,\n    distance: Number.Infinity\n  };\n};\nfunction convertColorFactor(factor) {\n  const convertedFactor = [];\n  const length = factor.length;\n  for (let i = 0; i < length; i++) {\n    if (i < 3) {\n      convertedFactor.push(srgbToLinear(factor[i]));\n    } else {\n      convertedFactor.push(factor[i]);\n    }\n  }\n  return convertedFactor;\n}\n\n/**\n * @private\n */\nI3SGeometry.prototype._generateGltf = function (nodesInScene, nodes, meshes, buffers, bufferViews, accessors, extensions, extensionsUsed) {\n  // Get the material definition\n  let gltfMaterial = {\n    pbrMetallicRoughness: {\n      metallicFactor: 0.0\n    },\n    doubleSided: true,\n    name: \"Material\"\n  };\n  let isTextured = false;\n  let materialDefinition;\n  let texturePath = \"\";\n  if (defined(this._parent._data.mesh) && defined(this._layer._data.materialDefinitions)) {\n    const materialInfo = this._parent._data.mesh.material;\n    const materialIndex = materialInfo.definition;\n    if (materialIndex >= 0 && materialIndex < this._layer._data.materialDefinitions.length) {\n      materialDefinition = this._layer._data.materialDefinitions[materialIndex];\n      gltfMaterial = materialDefinition;\n      if (defined(gltfMaterial.pbrMetallicRoughness) && defined(gltfMaterial.pbrMetallicRoughness.baseColorTexture)) {\n        isTextured = true;\n        gltfMaterial.pbrMetallicRoughness.baseColorTexture.index = 0;\n\n        // Choose the JPG for the texture\n        let textureName = \"0\";\n        if (defined(this._layer._data.textureSetDefinitions)) {\n          for (let defIndex = 0; defIndex < this._layer._data.textureSetDefinitions.length; defIndex++) {\n            const textureSetDefinition = this._layer._data.textureSetDefinitions[defIndex];\n            for (let formatIndex = 0; formatIndex < textureSetDefinition.formats.length; formatIndex++) {\n              const textureFormat = textureSetDefinition.formats[formatIndex];\n              if (textureFormat.format === \"jpg\") {\n                textureName = textureFormat.name;\n                break;\n              }\n            }\n          }\n        }\n        if (defined(this._parent._data.mesh) && this._parent._data.mesh.material.resource >= 0) {\n          texturePath = this._layer.resource.getDerivedResource({\n            url: `nodes/${this._parent._data.mesh.material.resource}/textures/${textureName}`\n          }).url;\n        }\n      }\n\n      // Convert color factors from sRGB to linear color space\n      if (defined(gltfMaterial.pbrMetallicRoughness) && defined(gltfMaterial.pbrMetallicRoughness.baseColorFactor)) {\n        gltfMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFactor(gltfMaterial.pbrMetallicRoughness.baseColorFactor);\n      }\n      if (defined(gltfMaterial.emissiveFactor)) {\n        gltfMaterial.emissiveFactor = convertColorFactor(gltfMaterial.emissiveFactor);\n      }\n    }\n  } else if (defined(this._parent._data.textureData)) {\n    // No material definition, but if there's a texture reference, we can create a simple material using it (version 1.6 support)\n    isTextured = true;\n    texturePath = this._parent.resource.getDerivedResource({\n      url: `${this._parent._data.textureData[0].href}`\n    }).url;\n    gltfMaterial.pbrMetallicRoughness.baseColorTexture = {\n      index: 0\n    };\n  }\n  if (defined(gltfMaterial.alphaMode)) {\n    // I3S specifies alphaMode values in lowercase, but glTF expects values in uppercase\n    gltfMaterial.alphaMode = gltfMaterial.alphaMode.toUpperCase();\n  }\n  let gltfTextures = [];\n  let gltfImages = [];\n  let gltfSamplers = [];\n  if (isTextured) {\n    gltfTextures = [{\n      sampler: 0,\n      source: 0\n    }];\n    gltfImages = [{\n      uri: texturePath\n    }];\n    gltfSamplers = [{\n      magFilter: 9729,\n      minFilter: 9986,\n      wrapS: 10497,\n      wrapT: 10497\n    }];\n  }\n  const gltfMaterials = [];\n  const meshesLength = meshes.length;\n  for (let meshIndex = 0; meshIndex < meshesLength; meshIndex++) {\n    const primitives = meshes[meshIndex].primitives;\n    const primitivesLength = primitives.length;\n    for (let primitiveIndex = 0; primitiveIndex < primitivesLength; primitiveIndex++) {\n      const primitive = primitives[primitiveIndex];\n      if (defined(primitive.material)) {\n        // Create as many copies of the material as specified in the mesh primitives\n        while (primitive.material >= gltfMaterials.length) {\n          const material = clone(gltfMaterial, true);\n          gltfMaterials.push(material);\n        }\n        const primitiveMaterial = gltfMaterials[primitive.material];\n        if (defined(primitive.extra) && primitive.extra.isTransparent) {\n          // If the alpha mode is not specified in the original material but the geometry is transparent, we need to force set BLEND alpha mode. Otherwise the geometry will be rendered opaque.\n          if (!defined(primitiveMaterial.alphaMode)) {\n            primitiveMaterial.alphaMode = \"BLEND\";\n          }\n        } else if (primitiveMaterial.alphaMode === \"BLEND\") {\n          // If the geometry is not transparent, but the alpha mode is set to BLEND in the original material, we need to force set OPAQUE alpha mode. Otherwise the geometry will be rendered transparent.\n          primitiveMaterial.alphaMode = \"OPAQUE\";\n        }\n      }\n    }\n  }\n  const gltfData = {\n    scene: 0,\n    scenes: [{\n      nodes: nodesInScene\n    }],\n    nodes: nodes,\n    meshes: meshes,\n    buffers: buffers,\n    bufferViews: bufferViews,\n    accessors: accessors,\n    materials: gltfMaterials,\n    textures: gltfTextures,\n    images: gltfImages,\n    samplers: gltfSamplers,\n    asset: {\n      version: \"2.0\"\n    },\n    extensions: extensions,\n    extensionsUsed: extensionsUsed\n  };\n  return gltfData;\n};\nexport default I3SGeometry;","map":{"version":3,"names":["Cartesian3","clone","defined","Matrix3","srgbToLinear","I3SGeometry","parent","uri","dataProvider","_dataProvider","layer","_layer","resource","_nodeIndex","getDerivedResource","url","_data","mesh","geometry","_parent","_resource","_customAttributes","undefined","Object","defineProperties","prototype","get","data","customAttributes","load","that","_loadBinary","then","scratchAb","scratchAp1","scratchAp2","scratchCp1","scratchCp2","sameSide","p1","p2","a","b","ab","subtract","cp1","cross","cp2","dot","scratchV0","scratchV1","scratchV2","scratchV0V1","scratchV0V2","scratchCrossProd","scratchNormal","scratchV0p","scratchV1p","scratchV2p","getClosestPointIndexOnTriangle","px","py","pz","positions","position","x","cartesianCenter","y","z","multiplyByVector","parentRotation","bestTriDist","Number","MAX_VALUE","bestTri","bestDistSq","bestIndex","bestPt","indices","triCount","length","triIndex","i0","i1","i2","v0","fromElements","v1","v2","v0v1","v0v2","crossProd","magnitude","normal","normalize","v0p","normalDist","Math","abs","d0","magnitudeSquared","d1","d2","index","distanceSquared","distance","sqrt","queriedPosition","closestPosition","Infinity","convertColorFactor","factor","convertedFactor","i","push","_generateGltf","nodesInScene","nodes","meshes","buffers","bufferViews","accessors","extensions","extensionsUsed","gltfMaterial","pbrMetallicRoughness","metallicFactor","doubleSided","name","isTextured","materialDefinition","texturePath","materialDefinitions","materialInfo","material","materialIndex","definition","baseColorTexture","textureName","textureSetDefinitions","defIndex","textureSetDefinition","formatIndex","formats","textureFormat","format","baseColorFactor","emissiveFactor","textureData","href","alphaMode","toUpperCase","gltfTextures","gltfImages","gltfSamplers","sampler","source","magFilter","minFilter","wrapS","wrapT","gltfMaterials","meshesLength","meshIndex","primitives","primitivesLength","primitiveIndex","primitive","primitiveMaterial","extra","isTransparent","gltfData","scene","scenes","materials","textures","images","samplers","asset","version"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/I3SGeometry.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport srgbToLinear from \"../Core/srgbToLinear.js\";\n\n/**\n * This class implements an I3S Geometry. Each I3SGeometry\n * generates an in memory glTF to be used as content for a Cesium3DTile\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SNode}.\n * </p>\n * @alias I3SGeometry\n * @internalConstructor\n * @privateParam {I3SNode} parent The parent of that geometry\n * @privateParam {string} uri The uri to load the data from\n */\nfunction I3SGeometry(parent, uri) {\n  const dataProvider = parent._dataProvider;\n  const layer = parent._layer;\n\n  let resource;\n\n  if (defined(parent._nodeIndex)) {\n    resource = layer.resource.getDerivedResource({\n      url: `nodes/${parent._data.mesh.geometry.resource}/${uri}`,\n    });\n  } else {\n    resource = parent.resource.getDerivedResource({ url: uri });\n  }\n\n  this._parent = parent;\n  this._dataProvider = dataProvider;\n  this._layer = layer;\n  this._resource = resource;\n\n  this._customAttributes = undefined;\n}\n\nObject.defineProperties(I3SGeometry.prototype, {\n  /**\n   * Gets the resource for the geometry\n   * @memberof I3SGeometry.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SGeometry.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n  /**\n   * Gets the custom attributes of the geometry.\n   * @memberof I3SGeometry.prototype\n   * @type {object}\n   * @readonly\n   */\n  customAttributes: {\n    get: function () {\n      return this._customAttributes;\n    },\n  },\n});\n\n/**\n * Loads the content.\n * @returns {Promise<object>} A promise that is resolved when the geometry data is loaded\n * @private\n */\nI3SGeometry.prototype.load = function () {\n  const that = this;\n  return this._dataProvider._loadBinary(this._resource).then(function (data) {\n    that._data = data;\n    return data;\n  });\n};\n\nconst scratchAb = new Cartesian3();\nconst scratchAp1 = new Cartesian3();\nconst scratchAp2 = new Cartesian3();\nconst scratchCp1 = new Cartesian3();\nconst scratchCp2 = new Cartesian3();\n\nfunction sameSide(p1, p2, a, b) {\n  const ab = Cartesian3.subtract(b, a, scratchAb);\n  const cp1 = Cartesian3.cross(\n    ab,\n    Cartesian3.subtract(p1, a, scratchAp1),\n    scratchCp1,\n  );\n  const cp2 = Cartesian3.cross(\n    ab,\n    Cartesian3.subtract(p2, a, scratchAp2),\n    scratchCp2,\n  );\n  return Cartesian3.dot(cp1, cp2) >= 0;\n}\n\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\n\nconst scratchV0V1 = new Cartesian3();\nconst scratchV0V2 = new Cartesian3();\nconst scratchCrossProd = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n\nconst scratchV0p = new Cartesian3();\nconst scratchV1p = new Cartesian3();\nconst scratchV2p = new Cartesian3();\n\n/**\n * Find a triangle touching the point [px, py, pz], then return the vertex closest to the search point\n * @param {number} px The x component of the point to query\n * @param {number} py The y component of the point to query\n * @param {number} pz The z component of the point to query\n * @returns {object} A structure containing the index of the closest point,\n * the squared distance from the queried point to the point that is found,\n * the distance from the queried point to the point that is found,\n * the queried position in local space,\n * the closest position in local space\n */\nI3SGeometry.prototype.getClosestPointIndexOnTriangle = function (px, py, pz) {\n  if (\n    defined(this._customAttributes) &&\n    defined(this._customAttributes.positions)\n  ) {\n    // Convert queried position to local\n    const position = new Cartesian3(px, py, pz);\n\n    position.x -= this._customAttributes.cartesianCenter.x;\n    position.y -= this._customAttributes.cartesianCenter.y;\n    position.z -= this._customAttributes.cartesianCenter.z;\n    Matrix3.multiplyByVector(\n      this._customAttributes.parentRotation,\n      position,\n      position,\n    );\n\n    let bestTriDist = Number.MAX_VALUE;\n    let bestTri;\n    let bestDistSq;\n    let bestIndex;\n    let bestPt;\n\n    // Brute force lookup, @TODO: this can be improved with a spatial partitioning search system\n    const positions = this._customAttributes.positions;\n    const indices = this._customAttributes.indices;\n\n    // We may have indexed or non-indexed triangles here\n    let triCount;\n    if (defined(indices)) {\n      triCount = indices.length;\n    } else {\n      triCount = positions.length / 3;\n    }\n\n    for (let triIndex = 0; triIndex < triCount; triIndex++) {\n      let i0, i1, i2;\n      if (defined(indices)) {\n        i0 = indices[triIndex];\n        i1 = indices[triIndex + 1];\n        i2 = indices[triIndex + 2];\n      } else {\n        i0 = triIndex * 3;\n        i1 = triIndex * 3 + 1;\n        i2 = triIndex * 3 + 2;\n      }\n\n      const v0 = Cartesian3.fromElements(\n        positions[i0 * 3],\n        positions[i0 * 3 + 1],\n        positions[i0 * 3 + 2],\n        scratchV0,\n      );\n      const v1 = Cartesian3.fromElements(\n        positions[i1 * 3],\n        positions[i1 * 3 + 1],\n        positions[i1 * 3 + 2],\n        scratchV1,\n      );\n      const v2 = new Cartesian3(\n        positions[i2 * 3],\n        positions[i2 * 3 + 1],\n        positions[i2 * 3 + 2],\n        scratchV2,\n      );\n\n      // Check how the point is positioned relative to the triangle.\n      // This will tell us whether the projection of the point in the triangle's plane lands in the triangle\n      if (\n        !sameSide(position, v0, v1, v2) ||\n        !sameSide(position, v1, v0, v2) ||\n        !sameSide(position, v2, v0, v1)\n      ) {\n        continue;\n      }\n      // Because of precision issues, we can't always reliably tell if the point lands directly on the face, so the most robust way is just to find the closest one\n      const v0v1 = Cartesian3.subtract(v1, v0, scratchV0V1);\n      const v0v2 = Cartesian3.subtract(v2, v0, scratchV0V2);\n      const crossProd = Cartesian3.cross(v0v1, v0v2, scratchCrossProd);\n\n      // Skip \"triangles\" with 3 colinear points\n      if (Cartesian3.magnitude(crossProd) === 0) {\n        continue;\n      }\n      const normal = Cartesian3.normalize(crossProd, scratchNormal);\n\n      const v0p = Cartesian3.subtract(position, v0, scratchV0p);\n      const normalDist = Math.abs(Cartesian3.dot(v0p, normal));\n      if (normalDist < bestTriDist) {\n        bestTriDist = normalDist;\n        bestTri = triIndex;\n\n        // Found a triangle, return the index of the closest point\n        const d0 = Cartesian3.magnitudeSquared(\n          Cartesian3.subtract(position, v0, v0p),\n        );\n        const d1 = Cartesian3.magnitudeSquared(\n          Cartesian3.subtract(position, v1, scratchV1p),\n        );\n        const d2 = Cartesian3.magnitudeSquared(\n          Cartesian3.subtract(position, v2, scratchV2p),\n        );\n        if (d0 < d1 && d0 < d2) {\n          bestIndex = i0;\n          bestPt = v0;\n          bestDistSq = d0;\n        } else if (d1 < d2) {\n          bestIndex = i1;\n          bestPt = v1;\n          bestDistSq = d1;\n        } else {\n          bestIndex = i2;\n          bestPt = v2;\n          bestDistSq = d2;\n        }\n      }\n    }\n\n    if (defined(bestTri)) {\n      return {\n        index: bestIndex,\n        distanceSquared: bestDistSq,\n        distance: Math.sqrt(bestDistSq),\n        queriedPosition: position,\n        closestPosition: Cartesian3.clone(bestPt),\n      };\n    }\n  }\n\n  // No hits found\n  return {\n    index: -1,\n    distanceSquared: Number.Infinity,\n    distance: Number.Infinity,\n  };\n};\n\nfunction convertColorFactor(factor) {\n  const convertedFactor = [];\n  const length = factor.length;\n  for (let i = 0; i < length; i++) {\n    if (i < 3) {\n      convertedFactor.push(srgbToLinear(factor[i]));\n    } else {\n      convertedFactor.push(factor[i]);\n    }\n  }\n  return convertedFactor;\n}\n\n/**\n * @private\n */\nI3SGeometry.prototype._generateGltf = function (\n  nodesInScene,\n  nodes,\n  meshes,\n  buffers,\n  bufferViews,\n  accessors,\n  extensions,\n  extensionsUsed,\n) {\n  // Get the material definition\n  let gltfMaterial = {\n    pbrMetallicRoughness: {\n      metallicFactor: 0.0,\n    },\n    doubleSided: true,\n    name: \"Material\",\n  };\n\n  let isTextured = false;\n  let materialDefinition;\n  let texturePath = \"\";\n  if (\n    defined(this._parent._data.mesh) &&\n    defined(this._layer._data.materialDefinitions)\n  ) {\n    const materialInfo = this._parent._data.mesh.material;\n    const materialIndex = materialInfo.definition;\n    if (\n      materialIndex >= 0 &&\n      materialIndex < this._layer._data.materialDefinitions.length\n    ) {\n      materialDefinition = this._layer._data.materialDefinitions[materialIndex];\n      gltfMaterial = materialDefinition;\n\n      if (\n        defined(gltfMaterial.pbrMetallicRoughness) &&\n        defined(gltfMaterial.pbrMetallicRoughness.baseColorTexture)\n      ) {\n        isTextured = true;\n        gltfMaterial.pbrMetallicRoughness.baseColorTexture.index = 0;\n\n        // Choose the JPG for the texture\n        let textureName = \"0\";\n\n        if (defined(this._layer._data.textureSetDefinitions)) {\n          for (\n            let defIndex = 0;\n            defIndex < this._layer._data.textureSetDefinitions.length;\n            defIndex++\n          ) {\n            const textureSetDefinition =\n              this._layer._data.textureSetDefinitions[defIndex];\n            for (\n              let formatIndex = 0;\n              formatIndex < textureSetDefinition.formats.length;\n              formatIndex++\n            ) {\n              const textureFormat = textureSetDefinition.formats[formatIndex];\n              if (textureFormat.format === \"jpg\") {\n                textureName = textureFormat.name;\n                break;\n              }\n            }\n          }\n        }\n\n        if (\n          defined(this._parent._data.mesh) &&\n          this._parent._data.mesh.material.resource >= 0\n        ) {\n          texturePath = this._layer.resource.getDerivedResource({\n            url: `nodes/${this._parent._data.mesh.material.resource}/textures/${textureName}`,\n          }).url;\n        }\n      }\n\n      // Convert color factors from sRGB to linear color space\n      if (\n        defined(gltfMaterial.pbrMetallicRoughness) &&\n        defined(gltfMaterial.pbrMetallicRoughness.baseColorFactor)\n      ) {\n        gltfMaterial.pbrMetallicRoughness.baseColorFactor = convertColorFactor(\n          gltfMaterial.pbrMetallicRoughness.baseColorFactor,\n        );\n      }\n      if (defined(gltfMaterial.emissiveFactor)) {\n        gltfMaterial.emissiveFactor = convertColorFactor(\n          gltfMaterial.emissiveFactor,\n        );\n      }\n    }\n  } else if (defined(this._parent._data.textureData)) {\n    // No material definition, but if there's a texture reference, we can create a simple material using it (version 1.6 support)\n    isTextured = true;\n    texturePath = this._parent.resource.getDerivedResource({\n      url: `${this._parent._data.textureData[0].href}`,\n    }).url;\n    gltfMaterial.pbrMetallicRoughness.baseColorTexture = { index: 0 };\n  }\n  if (defined(gltfMaterial.alphaMode)) {\n    // I3S specifies alphaMode values in lowercase, but glTF expects values in uppercase\n    gltfMaterial.alphaMode = gltfMaterial.alphaMode.toUpperCase();\n  }\n\n  let gltfTextures = [];\n  let gltfImages = [];\n  let gltfSamplers = [];\n\n  if (isTextured) {\n    gltfTextures = [\n      {\n        sampler: 0,\n        source: 0,\n      },\n    ];\n\n    gltfImages = [\n      {\n        uri: texturePath,\n      },\n    ];\n\n    gltfSamplers = [\n      {\n        magFilter: 9729,\n        minFilter: 9986,\n        wrapS: 10497,\n        wrapT: 10497,\n      },\n    ];\n  }\n\n  const gltfMaterials = [];\n  const meshesLength = meshes.length;\n  for (let meshIndex = 0; meshIndex < meshesLength; meshIndex++) {\n    const primitives = meshes[meshIndex].primitives;\n    const primitivesLength = primitives.length;\n    for (\n      let primitiveIndex = 0;\n      primitiveIndex < primitivesLength;\n      primitiveIndex++\n    ) {\n      const primitive = primitives[primitiveIndex];\n      if (defined(primitive.material)) {\n        // Create as many copies of the material as specified in the mesh primitives\n        while (primitive.material >= gltfMaterials.length) {\n          const material = clone(gltfMaterial, true);\n          gltfMaterials.push(material);\n        }\n        const primitiveMaterial = gltfMaterials[primitive.material];\n        if (defined(primitive.extra) && primitive.extra.isTransparent) {\n          // If the alpha mode is not specified in the original material but the geometry is transparent, we need to force set BLEND alpha mode. Otherwise the geometry will be rendered opaque.\n          if (!defined(primitiveMaterial.alphaMode)) {\n            primitiveMaterial.alphaMode = \"BLEND\";\n          }\n        } else if (primitiveMaterial.alphaMode === \"BLEND\") {\n          // If the geometry is not transparent, but the alpha mode is set to BLEND in the original material, we need to force set OPAQUE alpha mode. Otherwise the geometry will be rendered transparent.\n          primitiveMaterial.alphaMode = \"OPAQUE\";\n        }\n      }\n    }\n  }\n  const gltfData = {\n    scene: 0,\n    scenes: [\n      {\n        nodes: nodesInScene,\n      },\n    ],\n    nodes: nodes,\n    meshes: meshes,\n    buffers: buffers,\n    bufferViews: bufferViews,\n    accessors: accessors,\n    materials: gltfMaterials,\n    textures: gltfTextures,\n    images: gltfImages,\n    samplers: gltfSamplers,\n    asset: {\n      version: \"2.0\",\n    },\n    extensions: extensions,\n    extensionsUsed: extensionsUsed,\n  };\n\n  return gltfData;\n};\n\nexport default I3SGeometry;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,YAAY,MAAM,yBAAyB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,MAAM,EAAEC,GAAG,EAAE;EAChC,MAAMC,YAAY,GAAGF,MAAM,CAACG,aAAa;EACzC,MAAMC,KAAK,GAAGJ,MAAM,CAACK,MAAM;EAE3B,IAAIC,QAAQ;EAEZ,IAAIV,OAAO,CAACI,MAAM,CAACO,UAAU,CAAC,EAAE;IAC9BD,QAAQ,GAAGF,KAAK,CAACE,QAAQ,CAACE,kBAAkB,CAAC;MAC3CC,GAAG,EAAE,SAAST,MAAM,CAACU,KAAK,CAACC,IAAI,CAACC,QAAQ,CAACN,QAAQ,IAAIL,GAAG;IAC1D,CAAC,CAAC;EACJ,CAAC,MAAM;IACLK,QAAQ,GAAGN,MAAM,CAACM,QAAQ,CAACE,kBAAkB,CAAC;MAAEC,GAAG,EAAER;IAAI,CAAC,CAAC;EAC7D;EAEA,IAAI,CAACY,OAAO,GAAGb,MAAM;EACrB,IAAI,CAACG,aAAa,GAAGD,YAAY;EACjC,IAAI,CAACG,MAAM,GAAGD,KAAK;EACnB,IAAI,CAACU,SAAS,GAAGR,QAAQ;EAEzB,IAAI,CAACS,iBAAiB,GAAGC,SAAS;AACpC;AAEAC,MAAM,CAACC,gBAAgB,CAACnB,WAAW,CAACoB,SAAS,EAAE;EAC7C;AACF;AACA;AACA;AACA;AACA;EACEb,QAAQ,EAAE;IACRc,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACN,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEO,IAAI,EAAE;IACJD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,KAAK;IACnB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;EACEY,gBAAgB,EAAE;IAChBF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACL,iBAAiB;IAC/B;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACAhB,WAAW,CAACoB,SAAS,CAACI,IAAI,GAAG,YAAY;EACvC,MAAMC,IAAI,GAAG,IAAI;EACjB,OAAO,IAAI,CAACrB,aAAa,CAACsB,WAAW,CAAC,IAAI,CAACX,SAAS,CAAC,CAACY,IAAI,CAAC,UAAUL,IAAI,EAAE;IACzEG,IAAI,CAACd,KAAK,GAAGW,IAAI;IACjB,OAAOA,IAAI;EACb,CAAC,CAAC;AACJ,CAAC;AAED,MAAMM,SAAS,GAAG,IAAIjC,UAAU,CAAC,CAAC;AAClC,MAAMkC,UAAU,GAAG,IAAIlC,UAAU,CAAC,CAAC;AACnC,MAAMmC,UAAU,GAAG,IAAInC,UAAU,CAAC,CAAC;AACnC,MAAMoC,UAAU,GAAG,IAAIpC,UAAU,CAAC,CAAC;AACnC,MAAMqC,UAAU,GAAG,IAAIrC,UAAU,CAAC,CAAC;AAEnC,SAASsC,QAAQA,CAACC,EAAE,EAAEC,EAAE,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC9B,MAAMC,EAAE,GAAG3C,UAAU,CAAC4C,QAAQ,CAACF,CAAC,EAAED,CAAC,EAAER,SAAS,CAAC;EAC/C,MAAMY,GAAG,GAAG7C,UAAU,CAAC8C,KAAK,CAC1BH,EAAE,EACF3C,UAAU,CAAC4C,QAAQ,CAACL,EAAE,EAAEE,CAAC,EAAEP,UAAU,CAAC,EACtCE,UACF,CAAC;EACD,MAAMW,GAAG,GAAG/C,UAAU,CAAC8C,KAAK,CAC1BH,EAAE,EACF3C,UAAU,CAAC4C,QAAQ,CAACJ,EAAE,EAAEC,CAAC,EAAEN,UAAU,CAAC,EACtCE,UACF,CAAC;EACD,OAAOrC,UAAU,CAACgD,GAAG,CAACH,GAAG,EAAEE,GAAG,CAAC,IAAI,CAAC;AACtC;AAEA,MAAME,SAAS,GAAG,IAAIjD,UAAU,CAAC,CAAC;AAClC,MAAMkD,SAAS,GAAG,IAAIlD,UAAU,CAAC,CAAC;AAClC,MAAMmD,SAAS,GAAG,IAAInD,UAAU,CAAC,CAAC;AAElC,MAAMoD,WAAW,GAAG,IAAIpD,UAAU,CAAC,CAAC;AACpC,MAAMqD,WAAW,GAAG,IAAIrD,UAAU,CAAC,CAAC;AACpC,MAAMsD,gBAAgB,GAAG,IAAItD,UAAU,CAAC,CAAC;AACzC,MAAMuD,aAAa,GAAG,IAAIvD,UAAU,CAAC,CAAC;AAEtC,MAAMwD,UAAU,GAAG,IAAIxD,UAAU,CAAC,CAAC;AACnC,MAAMyD,UAAU,GAAG,IAAIzD,UAAU,CAAC,CAAC;AACnC,MAAM0D,UAAU,GAAG,IAAI1D,UAAU,CAAC,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAK,WAAW,CAACoB,SAAS,CAACkC,8BAA8B,GAAG,UAAUC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAC3E,IACE5D,OAAO,CAAC,IAAI,CAACmB,iBAAiB,CAAC,IAC/BnB,OAAO,CAAC,IAAI,CAACmB,iBAAiB,CAAC0C,SAAS,CAAC,EACzC;IACA;IACA,MAAMC,QAAQ,GAAG,IAAIhE,UAAU,CAAC4D,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IAE3CE,QAAQ,CAACC,CAAC,IAAI,IAAI,CAAC5C,iBAAiB,CAAC6C,eAAe,CAACD,CAAC;IACtDD,QAAQ,CAACG,CAAC,IAAI,IAAI,CAAC9C,iBAAiB,CAAC6C,eAAe,CAACC,CAAC;IACtDH,QAAQ,CAACI,CAAC,IAAI,IAAI,CAAC/C,iBAAiB,CAAC6C,eAAe,CAACE,CAAC;IACtDjE,OAAO,CAACkE,gBAAgB,CACtB,IAAI,CAAChD,iBAAiB,CAACiD,cAAc,EACrCN,QAAQ,EACRA,QACF,CAAC;IAED,IAAIO,WAAW,GAAGC,MAAM,CAACC,SAAS;IAClC,IAAIC,OAAO;IACX,IAAIC,UAAU;IACd,IAAIC,SAAS;IACb,IAAIC,MAAM;;IAEV;IACA,MAAMd,SAAS,GAAG,IAAI,CAAC1C,iBAAiB,CAAC0C,SAAS;IAClD,MAAMe,OAAO,GAAG,IAAI,CAACzD,iBAAiB,CAACyD,OAAO;;IAE9C;IACA,IAAIC,QAAQ;IACZ,IAAI7E,OAAO,CAAC4E,OAAO,CAAC,EAAE;MACpBC,QAAQ,GAAGD,OAAO,CAACE,MAAM;IAC3B,CAAC,MAAM;MACLD,QAAQ,GAAGhB,SAAS,CAACiB,MAAM,GAAG,CAAC;IACjC;IAEA,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGF,QAAQ,EAAEE,QAAQ,EAAE,EAAE;MACtD,IAAIC,EAAE,EAAEC,EAAE,EAAEC,EAAE;MACd,IAAIlF,OAAO,CAAC4E,OAAO,CAAC,EAAE;QACpBI,EAAE,GAAGJ,OAAO,CAACG,QAAQ,CAAC;QACtBE,EAAE,GAAGL,OAAO,CAACG,QAAQ,GAAG,CAAC,CAAC;QAC1BG,EAAE,GAAGN,OAAO,CAACG,QAAQ,GAAG,CAAC,CAAC;MAC5B,CAAC,MAAM;QACLC,EAAE,GAAGD,QAAQ,GAAG,CAAC;QACjBE,EAAE,GAAGF,QAAQ,GAAG,CAAC,GAAG,CAAC;QACrBG,EAAE,GAAGH,QAAQ,GAAG,CAAC,GAAG,CAAC;MACvB;MAEA,MAAMI,EAAE,GAAGrF,UAAU,CAACsF,YAAY,CAChCvB,SAAS,CAACmB,EAAE,GAAG,CAAC,CAAC,EACjBnB,SAAS,CAACmB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EACrBnB,SAAS,CAACmB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EACrBjC,SACF,CAAC;MACD,MAAMsC,EAAE,GAAGvF,UAAU,CAACsF,YAAY,CAChCvB,SAAS,CAACoB,EAAE,GAAG,CAAC,CAAC,EACjBpB,SAAS,CAACoB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EACrBpB,SAAS,CAACoB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EACrBjC,SACF,CAAC;MACD,MAAMsC,EAAE,GAAG,IAAIxF,UAAU,CACvB+D,SAAS,CAACqB,EAAE,GAAG,CAAC,CAAC,EACjBrB,SAAS,CAACqB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EACrBrB,SAAS,CAACqB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EACrBjC,SACF,CAAC;;MAED;MACA;MACA,IACE,CAACb,QAAQ,CAAC0B,QAAQ,EAAEqB,EAAE,EAAEE,EAAE,EAAEC,EAAE,CAAC,IAC/B,CAAClD,QAAQ,CAAC0B,QAAQ,EAAEuB,EAAE,EAAEF,EAAE,EAAEG,EAAE,CAAC,IAC/B,CAAClD,QAAQ,CAAC0B,QAAQ,EAAEwB,EAAE,EAAEH,EAAE,EAAEE,EAAE,CAAC,EAC/B;QACA;MACF;MACA;MACA,MAAME,IAAI,GAAGzF,UAAU,CAAC4C,QAAQ,CAAC2C,EAAE,EAAEF,EAAE,EAAEjC,WAAW,CAAC;MACrD,MAAMsC,IAAI,GAAG1F,UAAU,CAAC4C,QAAQ,CAAC4C,EAAE,EAAEH,EAAE,EAAEhC,WAAW,CAAC;MACrD,MAAMsC,SAAS,GAAG3F,UAAU,CAAC8C,KAAK,CAAC2C,IAAI,EAAEC,IAAI,EAAEpC,gBAAgB,CAAC;;MAEhE;MACA,IAAItD,UAAU,CAAC4F,SAAS,CAACD,SAAS,CAAC,KAAK,CAAC,EAAE;QACzC;MACF;MACA,MAAME,MAAM,GAAG7F,UAAU,CAAC8F,SAAS,CAACH,SAAS,EAAEpC,aAAa,CAAC;MAE7D,MAAMwC,GAAG,GAAG/F,UAAU,CAAC4C,QAAQ,CAACoB,QAAQ,EAAEqB,EAAE,EAAE7B,UAAU,CAAC;MACzD,MAAMwC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAAClG,UAAU,CAACgD,GAAG,CAAC+C,GAAG,EAAEF,MAAM,CAAC,CAAC;MACxD,IAAIG,UAAU,GAAGzB,WAAW,EAAE;QAC5BA,WAAW,GAAGyB,UAAU;QACxBtB,OAAO,GAAGO,QAAQ;;QAElB;QACA,MAAMkB,EAAE,GAAGnG,UAAU,CAACoG,gBAAgB,CACpCpG,UAAU,CAAC4C,QAAQ,CAACoB,QAAQ,EAAEqB,EAAE,EAAEU,GAAG,CACvC,CAAC;QACD,MAAMM,EAAE,GAAGrG,UAAU,CAACoG,gBAAgB,CACpCpG,UAAU,CAAC4C,QAAQ,CAACoB,QAAQ,EAAEuB,EAAE,EAAE9B,UAAU,CAC9C,CAAC;QACD,MAAM6C,EAAE,GAAGtG,UAAU,CAACoG,gBAAgB,CACpCpG,UAAU,CAAC4C,QAAQ,CAACoB,QAAQ,EAAEwB,EAAE,EAAE9B,UAAU,CAC9C,CAAC;QACD,IAAIyC,EAAE,GAAGE,EAAE,IAAIF,EAAE,GAAGG,EAAE,EAAE;UACtB1B,SAAS,GAAGM,EAAE;UACdL,MAAM,GAAGQ,EAAE;UACXV,UAAU,GAAGwB,EAAE;QACjB,CAAC,MAAM,IAAIE,EAAE,GAAGC,EAAE,EAAE;UAClB1B,SAAS,GAAGO,EAAE;UACdN,MAAM,GAAGU,EAAE;UACXZ,UAAU,GAAG0B,EAAE;QACjB,CAAC,MAAM;UACLzB,SAAS,GAAGQ,EAAE;UACdP,MAAM,GAAGW,EAAE;UACXb,UAAU,GAAG2B,EAAE;QACjB;MACF;IACF;IAEA,IAAIpG,OAAO,CAACwE,OAAO,CAAC,EAAE;MACpB,OAAO;QACL6B,KAAK,EAAE3B,SAAS;QAChB4B,eAAe,EAAE7B,UAAU;QAC3B8B,QAAQ,EAAER,IAAI,CAACS,IAAI,CAAC/B,UAAU,CAAC;QAC/BgC,eAAe,EAAE3C,QAAQ;QACzB4C,eAAe,EAAE5G,UAAU,CAACC,KAAK,CAAC4E,MAAM;MAC1C,CAAC;IACH;EACF;;EAEA;EACA,OAAO;IACL0B,KAAK,EAAE,CAAC,CAAC;IACTC,eAAe,EAAEhC,MAAM,CAACqC,QAAQ;IAChCJ,QAAQ,EAAEjC,MAAM,CAACqC;EACnB,CAAC;AACH,CAAC;AAED,SAASC,kBAAkBA,CAACC,MAAM,EAAE;EAClC,MAAMC,eAAe,GAAG,EAAE;EAC1B,MAAMhC,MAAM,GAAG+B,MAAM,CAAC/B,MAAM;EAC5B,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjC,MAAM,EAAEiC,CAAC,EAAE,EAAE;IAC/B,IAAIA,CAAC,GAAG,CAAC,EAAE;MACTD,eAAe,CAACE,IAAI,CAAC9G,YAAY,CAAC2G,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC;IAC/C,CAAC,MAAM;MACLD,eAAe,CAACE,IAAI,CAACH,MAAM,CAACE,CAAC,CAAC,CAAC;IACjC;EACF;EACA,OAAOD,eAAe;AACxB;;AAEA;AACA;AACA;AACA3G,WAAW,CAACoB,SAAS,CAAC0F,aAAa,GAAG,UACpCC,YAAY,EACZC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,WAAW,EACXC,SAAS,EACTC,UAAU,EACVC,cAAc,EACd;EACA;EACA,IAAIC,YAAY,GAAG;IACjBC,oBAAoB,EAAE;MACpBC,cAAc,EAAE;IAClB,CAAC;IACDC,WAAW,EAAE,IAAI;IACjBC,IAAI,EAAE;EACR,CAAC;EAED,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,kBAAkB;EACtB,IAAIC,WAAW,GAAG,EAAE;EACpB,IACEjI,OAAO,CAAC,IAAI,CAACiB,OAAO,CAACH,KAAK,CAACC,IAAI,CAAC,IAChCf,OAAO,CAAC,IAAI,CAACS,MAAM,CAACK,KAAK,CAACoH,mBAAmB,CAAC,EAC9C;IACA,MAAMC,YAAY,GAAG,IAAI,CAAClH,OAAO,CAACH,KAAK,CAACC,IAAI,CAACqH,QAAQ;IACrD,MAAMC,aAAa,GAAGF,YAAY,CAACG,UAAU;IAC7C,IACED,aAAa,IAAI,CAAC,IAClBA,aAAa,GAAG,IAAI,CAAC5H,MAAM,CAACK,KAAK,CAACoH,mBAAmB,CAACpD,MAAM,EAC5D;MACAkD,kBAAkB,GAAG,IAAI,CAACvH,MAAM,CAACK,KAAK,CAACoH,mBAAmB,CAACG,aAAa,CAAC;MACzEX,YAAY,GAAGM,kBAAkB;MAEjC,IACEhI,OAAO,CAAC0H,YAAY,CAACC,oBAAoB,CAAC,IAC1C3H,OAAO,CAAC0H,YAAY,CAACC,oBAAoB,CAACY,gBAAgB,CAAC,EAC3D;QACAR,UAAU,GAAG,IAAI;QACjBL,YAAY,CAACC,oBAAoB,CAACY,gBAAgB,CAAClC,KAAK,GAAG,CAAC;;QAE5D;QACA,IAAImC,WAAW,GAAG,GAAG;QAErB,IAAIxI,OAAO,CAAC,IAAI,CAACS,MAAM,CAACK,KAAK,CAAC2H,qBAAqB,CAAC,EAAE;UACpD,KACE,IAAIC,QAAQ,GAAG,CAAC,EAChBA,QAAQ,GAAG,IAAI,CAACjI,MAAM,CAACK,KAAK,CAAC2H,qBAAqB,CAAC3D,MAAM,EACzD4D,QAAQ,EAAE,EACV;YACA,MAAMC,oBAAoB,GACxB,IAAI,CAAClI,MAAM,CAACK,KAAK,CAAC2H,qBAAqB,CAACC,QAAQ,CAAC;YACnD,KACE,IAAIE,WAAW,GAAG,CAAC,EACnBA,WAAW,GAAGD,oBAAoB,CAACE,OAAO,CAAC/D,MAAM,EACjD8D,WAAW,EAAE,EACb;cACA,MAAME,aAAa,GAAGH,oBAAoB,CAACE,OAAO,CAACD,WAAW,CAAC;cAC/D,IAAIE,aAAa,CAACC,MAAM,KAAK,KAAK,EAAE;gBAClCP,WAAW,GAAGM,aAAa,CAAChB,IAAI;gBAChC;cACF;YACF;UACF;QACF;QAEA,IACE9H,OAAO,CAAC,IAAI,CAACiB,OAAO,CAACH,KAAK,CAACC,IAAI,CAAC,IAChC,IAAI,CAACE,OAAO,CAACH,KAAK,CAACC,IAAI,CAACqH,QAAQ,CAAC1H,QAAQ,IAAI,CAAC,EAC9C;UACAuH,WAAW,GAAG,IAAI,CAACxH,MAAM,CAACC,QAAQ,CAACE,kBAAkB,CAAC;YACpDC,GAAG,EAAE,SAAS,IAAI,CAACI,OAAO,CAACH,KAAK,CAACC,IAAI,CAACqH,QAAQ,CAAC1H,QAAQ,aAAa8H,WAAW;UACjF,CAAC,CAAC,CAAC3H,GAAG;QACR;MACF;;MAEA;MACA,IACEb,OAAO,CAAC0H,YAAY,CAACC,oBAAoB,CAAC,IAC1C3H,OAAO,CAAC0H,YAAY,CAACC,oBAAoB,CAACqB,eAAe,CAAC,EAC1D;QACAtB,YAAY,CAACC,oBAAoB,CAACqB,eAAe,GAAGpC,kBAAkB,CACpEc,YAAY,CAACC,oBAAoB,CAACqB,eACpC,CAAC;MACH;MACA,IAAIhJ,OAAO,CAAC0H,YAAY,CAACuB,cAAc,CAAC,EAAE;QACxCvB,YAAY,CAACuB,cAAc,GAAGrC,kBAAkB,CAC9Cc,YAAY,CAACuB,cACf,CAAC;MACH;IACF;EACF,CAAC,MAAM,IAAIjJ,OAAO,CAAC,IAAI,CAACiB,OAAO,CAACH,KAAK,CAACoI,WAAW,CAAC,EAAE;IAClD;IACAnB,UAAU,GAAG,IAAI;IACjBE,WAAW,GAAG,IAAI,CAAChH,OAAO,CAACP,QAAQ,CAACE,kBAAkB,CAAC;MACrDC,GAAG,EAAE,GAAG,IAAI,CAACI,OAAO,CAACH,KAAK,CAACoI,WAAW,CAAC,CAAC,CAAC,CAACC,IAAI;IAChD,CAAC,CAAC,CAACtI,GAAG;IACN6G,YAAY,CAACC,oBAAoB,CAACY,gBAAgB,GAAG;MAAElC,KAAK,EAAE;IAAE,CAAC;EACnE;EACA,IAAIrG,OAAO,CAAC0H,YAAY,CAAC0B,SAAS,CAAC,EAAE;IACnC;IACA1B,YAAY,CAAC0B,SAAS,GAAG1B,YAAY,CAAC0B,SAAS,CAACC,WAAW,CAAC,CAAC;EAC/D;EAEA,IAAIC,YAAY,GAAG,EAAE;EACrB,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAIC,YAAY,GAAG,EAAE;EAErB,IAAIzB,UAAU,EAAE;IACduB,YAAY,GAAG,CACb;MACEG,OAAO,EAAE,CAAC;MACVC,MAAM,EAAE;IACV,CAAC,CACF;IAEDH,UAAU,GAAG,CACX;MACElJ,GAAG,EAAE4H;IACP,CAAC,CACF;IAEDuB,YAAY,GAAG,CACb;MACEG,SAAS,EAAE,IAAI;MACfC,SAAS,EAAE,IAAI;MACfC,KAAK,EAAE,KAAK;MACZC,KAAK,EAAE;IACT,CAAC,CACF;EACH;EAEA,MAAMC,aAAa,GAAG,EAAE;EACxB,MAAMC,YAAY,GAAG5C,MAAM,CAACtC,MAAM;EAClC,KAAK,IAAImF,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGD,YAAY,EAAEC,SAAS,EAAE,EAAE;IAC7D,MAAMC,UAAU,GAAG9C,MAAM,CAAC6C,SAAS,CAAC,CAACC,UAAU;IAC/C,MAAMC,gBAAgB,GAAGD,UAAU,CAACpF,MAAM;IAC1C,KACE,IAAIsF,cAAc,GAAG,CAAC,EACtBA,cAAc,GAAGD,gBAAgB,EACjCC,cAAc,EAAE,EAChB;MACA,MAAMC,SAAS,GAAGH,UAAU,CAACE,cAAc,CAAC;MAC5C,IAAIpK,OAAO,CAACqK,SAAS,CAACjC,QAAQ,CAAC,EAAE;QAC/B;QACA,OAAOiC,SAAS,CAACjC,QAAQ,IAAI2B,aAAa,CAACjF,MAAM,EAAE;UACjD,MAAMsD,QAAQ,GAAGrI,KAAK,CAAC2H,YAAY,EAAE,IAAI,CAAC;UAC1CqC,aAAa,CAAC/C,IAAI,CAACoB,QAAQ,CAAC;QAC9B;QACA,MAAMkC,iBAAiB,GAAGP,aAAa,CAACM,SAAS,CAACjC,QAAQ,CAAC;QAC3D,IAAIpI,OAAO,CAACqK,SAAS,CAACE,KAAK,CAAC,IAAIF,SAAS,CAACE,KAAK,CAACC,aAAa,EAAE;UAC7D;UACA,IAAI,CAACxK,OAAO,CAACsK,iBAAiB,CAAClB,SAAS,CAAC,EAAE;YACzCkB,iBAAiB,CAAClB,SAAS,GAAG,OAAO;UACvC;QACF,CAAC,MAAM,IAAIkB,iBAAiB,CAAClB,SAAS,KAAK,OAAO,EAAE;UAClD;UACAkB,iBAAiB,CAAClB,SAAS,GAAG,QAAQ;QACxC;MACF;IACF;EACF;EACA,MAAMqB,QAAQ,GAAG;IACfC,KAAK,EAAE,CAAC;IACRC,MAAM,EAAE,CACN;MACExD,KAAK,EAAED;IACT,CAAC,CACF;IACDC,KAAK,EAAEA,KAAK;IACZC,MAAM,EAAEA,MAAM;IACdC,OAAO,EAAEA,OAAO;IAChBC,WAAW,EAAEA,WAAW;IACxBC,SAAS,EAAEA,SAAS;IACpBqD,SAAS,EAAEb,aAAa;IACxBc,QAAQ,EAAEvB,YAAY;IACtBwB,MAAM,EAAEvB,UAAU;IAClBwB,QAAQ,EAAEvB,YAAY;IACtBwB,KAAK,EAAE;MACLC,OAAO,EAAE;IACX,CAAC;IACDzD,UAAU,EAAEA,UAAU;IACtBC,cAAc,EAAEA;EAClB,CAAC;EAED,OAAOgD,QAAQ;AACjB,CAAC;AAED,eAAetK,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}