{"ast":null,"code":"import ArcType from \"../Core/ArcType.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport * as topojson from \"topojson-client\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nfunction defaultCrsFunction(coordinates) {\n  return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);\n}\nconst crsNames = {\n  \"urn:ogc:def:crs:OGC:1.3:CRS84\": defaultCrsFunction,\n  \"EPSG:4326\": defaultCrsFunction,\n  \"urn:ogc:def:crs:EPSG::4326\": defaultCrsFunction\n};\nconst crsLinkHrefs = {};\nconst crsLinkTypes = {};\nlet defaultMarkerSize = 48;\nlet defaultMarkerSymbol;\nlet defaultMarkerColor = Color.ROYALBLUE;\nlet defaultStroke = Color.YELLOW;\nlet defaultStrokeWidth = 2;\nlet defaultFill = Color.fromBytes(255, 255, 0, 100);\nlet defaultClampToGround = false;\nconst sizes = {\n  small: 24,\n  medium: 48,\n  large: 64\n};\nconst simpleStyleIdentifiers = [\"title\", \"description\",\n//\n\"marker-size\", \"marker-symbol\", \"marker-color\", \"stroke\",\n//\n\"stroke-opacity\", \"stroke-width\", \"fill\", \"fill-opacity\"];\nfunction defaultDescribe(properties, nameProperty) {\n  let html = \"\";\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = properties[key];\n      if (defined(value)) {\n        if (typeof value === \"object\") {\n          html += `<tr><th>${key}</th><td>${defaultDescribe(value)}</td></tr>`;\n        } else {\n          html += `<tr><th>${key}</th><td>${value}</td></tr>`;\n        }\n      }\n    }\n  }\n  if (html.length > 0) {\n    html = `<table class=\"cesium-infoBox-defaultTable\"><tbody>${html}</tbody></table>`;\n  }\n  return html;\n}\nfunction createDescriptionCallback(describe, properties, nameProperty) {\n  let description;\n  return function (time, result) {\n    if (!defined(description)) {\n      description = describe(properties, nameProperty);\n    }\n    return description;\n  };\n}\nfunction defaultDescribeProperty(properties, nameProperty) {\n  return new CallbackProperty(createDescriptionCallback(defaultDescribe, properties, nameProperty), true);\n}\n\n//GeoJSON specifies only the Feature object has a usable id property\n//But since \"multi\" geometries create multiple entity,\n//we can't use it for them either.\nfunction createObject(geoJson, entityCollection, describe) {\n  let id = geoJson.id;\n  if (!defined(id) || geoJson.type !== \"Feature\") {\n    id = createGuid();\n  } else {\n    let i = 2;\n    let finalId = id;\n    while (defined(entityCollection.getById(finalId))) {\n      finalId = `${id}_${i}`;\n      i++;\n    }\n    id = finalId;\n  }\n  const entity = entityCollection.getOrCreateEntity(id);\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    entity.properties = properties;\n    let nameProperty;\n\n    //Check for the simplestyle specified name first.\n    const name = properties.title;\n    if (defined(name)) {\n      entity.name = name;\n      nameProperty = \"title\";\n    } else {\n      //Else, find the name by selecting an appropriate property.\n      //The name will be obtained based on this order:\n      //1) The first case-insensitive property with the name 'title',\n      //2) The first case-insensitive property with the name 'name',\n      //3) The first property containing the word 'title'.\n      //4) The first property containing the word 'name',\n      let namePropertyPrecedence = Number.MAX_VALUE;\n      for (const key in properties) {\n        if (properties.hasOwnProperty(key) && properties[key]) {\n          const lowerKey = key.toLowerCase();\n          if (namePropertyPrecedence > 1 && lowerKey === \"title\") {\n            namePropertyPrecedence = 1;\n            nameProperty = key;\n            break;\n          } else if (namePropertyPrecedence > 2 && lowerKey === \"name\") {\n            namePropertyPrecedence = 2;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 3 && /title/i.test(key)) {\n            namePropertyPrecedence = 3;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 4 && /name/i.test(key)) {\n            namePropertyPrecedence = 4;\n            nameProperty = key;\n          }\n        }\n      }\n      if (defined(nameProperty)) {\n        entity.name = properties[nameProperty];\n      }\n    }\n    const description = properties.description;\n    if (description !== null) {\n      entity.description = !defined(description) ? describe(properties, nameProperty) : new ConstantProperty(description);\n    }\n  }\n  return entity;\n}\nfunction coordinatesArrayToCartesianArray(coordinates, crsFunction) {\n  const positions = new Array(coordinates.length);\n  for (let i = 0; i < coordinates.length; i++) {\n    positions[i] = crsFunction(coordinates[i]);\n  }\n  return positions;\n}\nconst geoJsonObjectTypes = {\n  Feature: processFeature,\n  FeatureCollection: processFeatureCollection,\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology\n};\nconst geometryTypes = {\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology\n};\n\n// GeoJSON processing functions\nfunction processFeature(dataSource, feature, notUsed, crsFunction, options) {\n  if (feature.geometry === null) {\n    //Null geometry is allowed, so just create an empty entity instance for it.\n    createObject(feature, dataSource._entityCollection, options.describe);\n    return;\n  }\n  if (!defined(feature.geometry)) {\n    throw new RuntimeError(\"feature.geometry is required.\");\n  }\n  const geometryType = feature.geometry.type;\n  const geometryHandler = geometryTypes[geometryType];\n  if (!defined(geometryHandler)) {\n    throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n  }\n  geometryHandler(dataSource, feature, feature.geometry, crsFunction, options);\n}\nfunction processFeatureCollection(dataSource, featureCollection, notUsed, crsFunction, options) {\n  const features = featureCollection.features;\n  for (let i = 0, len = features.length; i < len; i++) {\n    processFeature(dataSource, features[i], undefined, crsFunction, options);\n  }\n}\nfunction processGeometryCollection(dataSource, geoJson, geometryCollection, crsFunction, options) {\n  const geometries = geometryCollection.geometries;\n  for (let i = 0, len = geometries.length; i < len; i++) {\n    const geometry = geometries[i];\n    const geometryType = geometry.type;\n    const geometryHandler = geometryTypes[geometryType];\n    if (!defined(geometryHandler)) {\n      throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n    }\n    geometryHandler(dataSource, geoJson, geometry, crsFunction, options);\n  }\n}\nfunction createPoint(dataSource, geoJson, crsFunction, coordinates, options) {\n  let symbol = options.markerSymbol;\n  let color = options.markerColor;\n  let size = options.markerSize;\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const cssColor = properties[\"marker-color\"];\n    if (defined(cssColor)) {\n      color = Color.fromCssColorString(cssColor);\n    }\n    size = defaultValue(sizes[properties[\"marker-size\"]], size);\n    const markerSymbol = properties[\"marker-symbol\"];\n    if (defined(markerSymbol)) {\n      symbol = markerSymbol;\n    }\n  }\n  let canvasOrPromise;\n  if (defined(symbol)) {\n    if (symbol.length === 1) {\n      canvasOrPromise = dataSource._pinBuilder.fromText(symbol.toUpperCase(), color, size);\n    } else {\n      canvasOrPromise = dataSource._pinBuilder.fromMakiIconId(symbol, color, size);\n    }\n  } else {\n    canvasOrPromise = dataSource._pinBuilder.fromColor(color, size);\n  }\n  const billboard = new BillboardGraphics();\n  billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);\n\n  // Clamp to ground if there isn't a height specified\n  if (coordinates.length === 2 && options.clampToGround) {\n    billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n  }\n  const entity = createObject(geoJson, dataSource._entityCollection, options.describe);\n  entity.billboard = billboard;\n  entity.position = new ConstantPositionProperty(crsFunction(coordinates));\n  const promise = Promise.resolve(canvasOrPromise).then(function (image) {\n    billboard.image = new ConstantProperty(image);\n  }).catch(function () {\n    billboard.image = new ConstantProperty(dataSource._pinBuilder.fromColor(color, size));\n  });\n  dataSource._promises.push(promise);\n}\nfunction processPoint(dataSource, geoJson, geometry, crsFunction, options) {\n  createPoint(dataSource, geoJson, crsFunction, geometry.coordinates, options);\n}\nfunction processMultiPoint(dataSource, geoJson, geometry, crsFunction, options) {\n  const coordinates = geometry.coordinates;\n  for (let i = 0; i < coordinates.length; i++) {\n    createPoint(dataSource, geoJson, crsFunction, coordinates[i], options);\n  }\n}\nfunction createLineString(dataSource, geoJson, crsFunction, coordinates, options) {\n  let material = options.strokeMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    const opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = material.color.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n    if (defined(color)) {\n      material = new ColorMaterialProperty(color);\n    }\n  }\n  const entity = createObject(geoJson, dataSource._entityCollection, options.describe);\n  const polylineGraphics = new PolylineGraphics();\n  entity.polyline = polylineGraphics;\n  polylineGraphics.clampToGround = options.clampToGround;\n  polylineGraphics.material = material;\n  polylineGraphics.width = widthProperty;\n  polylineGraphics.positions = new ConstantProperty(coordinatesArrayToCartesianArray(coordinates, crsFunction));\n  polylineGraphics.arcType = ArcType.RHUMB;\n}\nfunction processLineString(dataSource, geoJson, geometry, crsFunction, options) {\n  createLineString(dataSource, geoJson, crsFunction, geometry.coordinates, options);\n}\nfunction processMultiLineString(dataSource, geoJson, geometry, crsFunction, options) {\n  const lineStrings = geometry.coordinates;\n  for (let i = 0; i < lineStrings.length; i++) {\n    createLineString(dataSource, geoJson, crsFunction, lineStrings[i], options);\n  }\n}\nfunction createPolygon(dataSource, geoJson, crsFunction, coordinates, options) {\n  if (coordinates.length === 0 || coordinates[0].length === 0) {\n    return;\n  }\n  let outlineColorProperty = options.strokeMaterialProperty.color;\n  let material = options.fillMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    let opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = outlineColorProperty.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n    if (defined(color)) {\n      outlineColorProperty = new ConstantProperty(color);\n    }\n    let fillColor;\n    const fill = properties.fill;\n    const materialColor = material.color.getValue();\n    if (defined(fill)) {\n      fillColor = Color.fromCssColorString(fill);\n      fillColor.alpha = materialColor.alpha;\n    }\n    opacity = properties[\"fill-opacity\"];\n    if (defined(opacity) && opacity !== materialColor.alpha) {\n      if (!defined(fillColor)) {\n        fillColor = materialColor.clone();\n      }\n      fillColor.alpha = opacity;\n    }\n    if (defined(fillColor)) {\n      material = new ColorMaterialProperty(fillColor);\n    }\n  }\n  const polygon = new PolygonGraphics();\n  polygon.outline = new ConstantProperty(true);\n  polygon.outlineColor = outlineColorProperty;\n  polygon.outlineWidth = widthProperty;\n  polygon.material = material;\n  polygon.arcType = ArcType.RHUMB;\n  const holes = [];\n  for (let i = 1, len = coordinates.length; i < len; i++) {\n    holes.push(new PolygonHierarchy(coordinatesArrayToCartesianArray(coordinates[i], crsFunction)));\n  }\n  const positions = coordinates[0];\n  polygon.hierarchy = new ConstantProperty(new PolygonHierarchy(coordinatesArrayToCartesianArray(positions, crsFunction), holes));\n  if (positions[0].length > 2) {\n    polygon.perPositionHeight = new ConstantProperty(true);\n  } else if (!options.clampToGround) {\n    polygon.height = 0;\n  }\n  const entity = createObject(geoJson, dataSource._entityCollection, options.describe);\n  entity.polygon = polygon;\n}\nfunction processPolygon(dataSource, geoJson, geometry, crsFunction, options) {\n  createPolygon(dataSource, geoJson, crsFunction, geometry.coordinates, options);\n}\nfunction processMultiPolygon(dataSource, geoJson, geometry, crsFunction, options) {\n  const polygons = geometry.coordinates;\n  for (let i = 0; i < polygons.length; i++) {\n    createPolygon(dataSource, geoJson, crsFunction, polygons[i], options);\n  }\n}\nfunction processTopology(dataSource, geoJson, geometry, crsFunction, options) {\n  for (const property in geometry.objects) {\n    if (geometry.objects.hasOwnProperty(property)) {\n      const feature = topojson.feature(geometry, geometry.objects[property]);\n      const typeHandler = geoJsonObjectTypes[feature.type];\n      typeHandler(dataSource, feature, feature, crsFunction, options);\n    }\n  }\n}\n\n/**\n * @typedef {object} GeoJsonDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {GeoJsonDataSource.describe} [describe=GeoJsonDataSource.defaultDescribeProperty] A function which returns a Property object (or just a string).\n * @property {number} [markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.\n * @property {string} [markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.\n * @property {Color} [markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.\n * @property {Color} [stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.\n * @property {number} [strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.\n * @property {Color} [fill=GeoJsonDataSource.fill] The default color for polygon interiors.\n * @property {boolean} [clampToGround=GeoJsonDataSource.clampToGround] true if we want the geometry features (polygons or linestrings) clamped to the ground.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes both\n * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.\n * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they\n * are present.\n *\n * @alias GeoJsonDataSource\n * @constructor\n *\n * @param {string} [name] The name of this data source.  If undefined, a name will be taken from\n *                        the name of the GeoJSON file.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20and%20TopoJSON.html|Cesium Sandcastle GeoJSON and TopoJSON Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20simplestyle.html|Cesium Sandcastle GeoJSON simplestyle Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {\n *   stroke: Cesium.Color.HOTPINK,\n *   fill: Cesium.Color.PINK,\n *   strokeWidth: 3,\n *   markerSymbol: '?'\n * }));\n */\nfunction GeoJsonDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._entityCollection = new EntityCollection(this);\n  this._promises = [];\n  this._pinBuilder = new PinBuilder();\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.\n *\n * @param {Resource|string|object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<GeoJsonDataSource>} A promise that will resolve when the data is loaded.\n */\nGeoJsonDataSource.load = function (data, options) {\n  return new GeoJsonDataSource().load(data, options);\n};\nObject.defineProperties(GeoJsonDataSource, {\n  /**\n   * Gets or sets the default size of the map pin created for each point, in pixels.\n   * @memberof GeoJsonDataSource\n   * @type {number}\n   * @default 48\n   */\n  markerSize: {\n    get: function () {\n      return defaultMarkerSize;\n    },\n    set: function (value) {\n      defaultMarkerSize = value;\n    }\n  },\n  /**\n   * Gets or sets the default symbol of the map pin created for each point.\n   * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,\n   * or blank if no symbol is to be used.\n   * @memberof GeoJsonDataSource\n   * @type {string}\n   */\n  markerSymbol: {\n    get: function () {\n      return defaultMarkerSymbol;\n    },\n    set: function (value) {\n      defaultMarkerSymbol = value;\n    }\n  },\n  /**\n   * Gets or sets the default color of the map pin created for each point.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.ROYALBLUE\n   */\n  markerColor: {\n    get: function () {\n      return defaultMarkerColor;\n    },\n    set: function (value) {\n      defaultMarkerColor = value;\n    }\n  },\n  /**\n   * Gets or sets the default color of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.BLACK\n   */\n  stroke: {\n    get: function () {\n      return defaultStroke;\n    },\n    set: function (value) {\n      defaultStroke = value;\n    }\n  },\n  /**\n   * Gets or sets the default width of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {number}\n   * @default 2.0\n   */\n  strokeWidth: {\n    get: function () {\n      return defaultStrokeWidth;\n    },\n    set: function (value) {\n      defaultStrokeWidth = value;\n    }\n  },\n  /**\n   * Gets or sets default color for polygon interiors.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.YELLOW\n   */\n  fill: {\n    get: function () {\n      return defaultFill;\n    },\n    set: function (value) {\n      defaultFill = value;\n    }\n  },\n  /**\n   * Gets or sets default of whether to clamp to the ground.\n   * @memberof GeoJsonDataSource\n   * @type {boolean}\n   * @default false\n   */\n  clampToGround: {\n    get: function () {\n      return defaultClampToGround;\n    },\n    set: function (value) {\n      defaultClampToGround = value;\n    }\n  },\n  /**\n   * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate\n   * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which\n   * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,\n   * for example 'EPSG:4326'.\n   * @memberof GeoJsonDataSource\n   * @type {object}\n   */\n  crsNames: {\n    get: function () {\n      return crsNames;\n    }\n  },\n  /**\n   * Gets an object that maps the href property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming\n   * the link has a type specified.\n   * @memberof GeoJsonDataSource\n   * @type {object}\n   */\n  crsLinkHrefs: {\n    get: function () {\n      return crsLinkHrefs;\n    }\n  },\n  /**\n   * Gets an object that maps the type property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in <code>crsLinkHrefs</code> take precedence over this object.\n   * @memberof GeoJsonDataSource\n   * @type {object}\n   */\n  crsLinkTypes: {\n    get: function () {\n      return crsLinkTypes;\n    }\n  }\n});\nObject.defineProperties(GeoJsonDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    }\n  },\n  /**\n   * This DataSource only defines static data, therefore this property is always undefined.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    value: undefined,\n    writable: false\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    }\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    }\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    }\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    }\n  },\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    }\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  }\n});\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.\n *\n * @param {Resource|string|object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.load = function (data, options) {\n  return preload(this, data, options, true);\n};\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, without replacing any existing data.\n *\n * @param {Resource|string|object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.process = function (data, options) {\n  return preload(this, data, options, false);\n};\nfunction preload(that, data, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  DataSource.setLoading(that, true);\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  that._credit = credit;\n  let promise = data;\n  let sourceUri = options.sourceUri;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchJson();\n    sourceUri = defaultValue(sourceUri, data.getUrlComponent());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = that._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n  options = {\n    describe: defaultValue(options.describe, defaultDescribeProperty),\n    markerSize: defaultValue(options.markerSize, defaultMarkerSize),\n    markerSymbol: defaultValue(options.markerSymbol, defaultMarkerSymbol),\n    markerColor: defaultValue(options.markerColor, defaultMarkerColor),\n    strokeWidthProperty: new ConstantProperty(defaultValue(options.strokeWidth, defaultStrokeWidth)),\n    strokeMaterialProperty: new ColorMaterialProperty(defaultValue(options.stroke, defaultStroke)),\n    fillMaterialProperty: new ColorMaterialProperty(defaultValue(options.fill, defaultFill)),\n    clampToGround: defaultValue(options.clampToGround, defaultClampToGround)\n  };\n  return Promise.resolve(promise).then(function (geoJson) {\n    return load(that, geoJson, options, sourceUri, clear);\n  }).catch(function (error) {\n    DataSource.setLoading(that, false);\n    that._error.raiseEvent(that, error);\n    throw error;\n  });\n}\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nGeoJsonDataSource.prototype.update = function (time) {\n  return true;\n};\nfunction load(that, geoJson, options, sourceUri, clear) {\n  let name;\n  if (defined(sourceUri)) {\n    name = getFilenameFromUri(sourceUri);\n  }\n  if (defined(name) && that._name !== name) {\n    that._name = name;\n    that._changed.raiseEvent(that);\n  }\n  const typeHandler = geoJsonObjectTypes[geoJson.type];\n  if (!defined(typeHandler)) {\n    throw new RuntimeError(`Unsupported GeoJSON object type: ${geoJson.type}`);\n  }\n\n  //Check for a Coordinate Reference System.\n  const crs = geoJson.crs;\n  let crsFunction = crs !== null ? defaultCrsFunction : null;\n  if (defined(crs)) {\n    if (!defined(crs.properties)) {\n      throw new RuntimeError(\"crs.properties is undefined.\");\n    }\n    const properties = crs.properties;\n    if (crs.type === \"name\") {\n      crsFunction = crsNames[properties.name];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs name: ${properties.name}`);\n      }\n    } else if (crs.type === \"link\") {\n      let handler = crsLinkHrefs[properties.href];\n      if (!defined(handler)) {\n        handler = crsLinkTypes[properties.type];\n      }\n      if (!defined(handler)) {\n        throw new RuntimeError(`Unable to resolve crs link: ${JSON.stringify(properties)}`);\n      }\n      crsFunction = handler(properties);\n    } else if (crs.type === \"EPSG\") {\n      crsFunction = crsNames[`EPSG:${properties.code}`];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs EPSG code: ${properties.code}`);\n      }\n    } else {\n      throw new RuntimeError(`Unknown crs type: ${crs.type}`);\n    }\n  }\n  return Promise.resolve(crsFunction).then(function (crsFunction) {\n    if (clear) {\n      that._entityCollection.removeAll();\n    }\n\n    // null is a valid value for the crs, but means the entire load process becomes a no-op\n    // because we can't assume anything about the coordinates.\n    if (crsFunction !== null) {\n      typeHandler(that, geoJson, geoJson, crsFunction, options);\n    }\n    return Promise.all(that._promises).then(function () {\n      that._promises.length = 0;\n      DataSource.setLoading(that, false);\n      return that;\n    });\n  });\n}\n\n/**\n * This callback is displayed as part of the GeoJsonDataSource class.\n * @callback GeoJsonDataSource.describe\n * @param {object} properties The properties of the feature.\n * @param {string} nameProperty The property key that Cesium estimates to have the name of the feature.\n */\nexport default GeoJsonDataSource;","map":{"version":3,"names":["ArcType","Cartesian3","Color","createGuid","Credit","defaultValue","defined","DeveloperError","Event","getFilenameFromUri","PinBuilder","PolygonHierarchy","Resource","RuntimeError","HeightReference","VerticalOrigin","topojson","BillboardGraphics","CallbackProperty","ColorMaterialProperty","ConstantPositionProperty","ConstantProperty","DataSource","EntityCluster","EntityCollection","PolygonGraphics","PolylineGraphics","defaultCrsFunction","coordinates","fromDegrees","crsNames","crsLinkHrefs","crsLinkTypes","defaultMarkerSize","defaultMarkerSymbol","defaultMarkerColor","ROYALBLUE","defaultStroke","YELLOW","defaultStrokeWidth","defaultFill","fromBytes","defaultClampToGround","sizes","small","medium","large","simpleStyleIdentifiers","defaultDescribe","properties","nameProperty","html","key","hasOwnProperty","indexOf","value","length","createDescriptionCallback","describe","description","time","result","defaultDescribeProperty","createObject","geoJson","entityCollection","id","type","i","finalId","getById","entity","getOrCreateEntity","name","title","namePropertyPrecedence","Number","MAX_VALUE","lowerKey","toLowerCase","test","coordinatesArrayToCartesianArray","crsFunction","positions","Array","geoJsonObjectTypes","Feature","processFeature","FeatureCollection","processFeatureCollection","GeometryCollection","processGeometryCollection","LineString","processLineString","MultiLineString","processMultiLineString","MultiPoint","processMultiPoint","MultiPolygon","processMultiPolygon","Point","processPoint","Polygon","processPolygon","Topology","processTopology","geometryTypes","dataSource","feature","notUsed","options","geometry","_entityCollection","geometryType","geometryHandler","featureCollection","features","len","undefined","geometryCollection","geometries","createPoint","symbol","markerSymbol","color","markerColor","size","markerSize","cssColor","fromCssColorString","canvasOrPromise","_pinBuilder","fromText","toUpperCase","fromMakiIconId","fromColor","billboard","verticalOrigin","BOTTOM","clampToGround","heightReference","CLAMP_TO_GROUND","position","promise","Promise","resolve","then","image","catch","_promises","push","createLineString","material","strokeMaterialProperty","widthProperty","strokeWidthProperty","width","stroke","opacity","getValue","clone","alpha","polylineGraphics","polyline","arcType","RHUMB","lineStrings","createPolygon","outlineColorProperty","fillMaterialProperty","fillColor","fill","materialColor","polygon","outline","outlineColor","outlineWidth","holes","hierarchy","perPositionHeight","height","polygons","property","objects","typeHandler","GeoJsonDataSource","_name","_changed","_error","_isLoading","_loading","_entityCluster","_credit","_resourceCredits","load","data","Object","defineProperties","get","set","strokeWidth","prototype","raiseEvent","clock","writable","entities","isLoading","changedEvent","errorEvent","loadingEvent","show","clustering","credit","preload","process","that","clear","setLoading","EMPTY_OBJECT","sourceUri","createIfNeeded","fetchJson","getUrlComponent","resourceCredits","credits","error","update","crs","handler","href","JSON","stringify","code","removeAll","all"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/GeoJsonDataSource.js"],"sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport * as topojson from \"topojson-client\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\n\nfunction defaultCrsFunction(coordinates) {\n  return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);\n}\n\nconst crsNames = {\n  \"urn:ogc:def:crs:OGC:1.3:CRS84\": defaultCrsFunction,\n  \"EPSG:4326\": defaultCrsFunction,\n  \"urn:ogc:def:crs:EPSG::4326\": defaultCrsFunction,\n};\n\nconst crsLinkHrefs = {};\nconst crsLinkTypes = {};\nlet defaultMarkerSize = 48;\nlet defaultMarkerSymbol;\nlet defaultMarkerColor = Color.ROYALBLUE;\nlet defaultStroke = Color.YELLOW;\nlet defaultStrokeWidth = 2;\nlet defaultFill = Color.fromBytes(255, 255, 0, 100);\nlet defaultClampToGround = false;\n\nconst sizes = {\n  small: 24,\n  medium: 48,\n  large: 64,\n};\n\nconst simpleStyleIdentifiers = [\n  \"title\",\n  \"description\", //\n  \"marker-size\",\n  \"marker-symbol\",\n  \"marker-color\",\n  \"stroke\", //\n  \"stroke-opacity\",\n  \"stroke-width\",\n  \"fill\",\n  \"fill-opacity\",\n];\n\nfunction defaultDescribe(properties, nameProperty) {\n  let html = \"\";\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = properties[key];\n      if (defined(value)) {\n        if (typeof value === \"object\") {\n          html += `<tr><th>${key}</th><td>${defaultDescribe(value)}</td></tr>`;\n        } else {\n          html += `<tr><th>${key}</th><td>${value}</td></tr>`;\n        }\n      }\n    }\n  }\n\n  if (html.length > 0) {\n    html = `<table class=\"cesium-infoBox-defaultTable\"><tbody>${html}</tbody></table>`;\n  }\n\n  return html;\n}\n\nfunction createDescriptionCallback(describe, properties, nameProperty) {\n  let description;\n  return function (time, result) {\n    if (!defined(description)) {\n      description = describe(properties, nameProperty);\n    }\n    return description;\n  };\n}\n\nfunction defaultDescribeProperty(properties, nameProperty) {\n  return new CallbackProperty(\n    createDescriptionCallback(defaultDescribe, properties, nameProperty),\n    true,\n  );\n}\n\n//GeoJSON specifies only the Feature object has a usable id property\n//But since \"multi\" geometries create multiple entity,\n//we can't use it for them either.\nfunction createObject(geoJson, entityCollection, describe) {\n  let id = geoJson.id;\n  if (!defined(id) || geoJson.type !== \"Feature\") {\n    id = createGuid();\n  } else {\n    let i = 2;\n    let finalId = id;\n    while (defined(entityCollection.getById(finalId))) {\n      finalId = `${id}_${i}`;\n      i++;\n    }\n    id = finalId;\n  }\n\n  const entity = entityCollection.getOrCreateEntity(id);\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    entity.properties = properties;\n\n    let nameProperty;\n\n    //Check for the simplestyle specified name first.\n    const name = properties.title;\n    if (defined(name)) {\n      entity.name = name;\n      nameProperty = \"title\";\n    } else {\n      //Else, find the name by selecting an appropriate property.\n      //The name will be obtained based on this order:\n      //1) The first case-insensitive property with the name 'title',\n      //2) The first case-insensitive property with the name 'name',\n      //3) The first property containing the word 'title'.\n      //4) The first property containing the word 'name',\n      let namePropertyPrecedence = Number.MAX_VALUE;\n      for (const key in properties) {\n        if (properties.hasOwnProperty(key) && properties[key]) {\n          const lowerKey = key.toLowerCase();\n\n          if (namePropertyPrecedence > 1 && lowerKey === \"title\") {\n            namePropertyPrecedence = 1;\n            nameProperty = key;\n            break;\n          } else if (namePropertyPrecedence > 2 && lowerKey === \"name\") {\n            namePropertyPrecedence = 2;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 3 && /title/i.test(key)) {\n            namePropertyPrecedence = 3;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 4 && /name/i.test(key)) {\n            namePropertyPrecedence = 4;\n            nameProperty = key;\n          }\n        }\n      }\n      if (defined(nameProperty)) {\n        entity.name = properties[nameProperty];\n      }\n    }\n\n    const description = properties.description;\n    if (description !== null) {\n      entity.description = !defined(description)\n        ? describe(properties, nameProperty)\n        : new ConstantProperty(description);\n    }\n  }\n  return entity;\n}\n\nfunction coordinatesArrayToCartesianArray(coordinates, crsFunction) {\n  const positions = new Array(coordinates.length);\n  for (let i = 0; i < coordinates.length; i++) {\n    positions[i] = crsFunction(coordinates[i]);\n  }\n  return positions;\n}\n\nconst geoJsonObjectTypes = {\n  Feature: processFeature,\n  FeatureCollection: processFeatureCollection,\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology,\n};\n\nconst geometryTypes = {\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology,\n};\n\n// GeoJSON processing functions\nfunction processFeature(dataSource, feature, notUsed, crsFunction, options) {\n  if (feature.geometry === null) {\n    //Null geometry is allowed, so just create an empty entity instance for it.\n    createObject(feature, dataSource._entityCollection, options.describe);\n    return;\n  }\n\n  if (!defined(feature.geometry)) {\n    throw new RuntimeError(\"feature.geometry is required.\");\n  }\n\n  const geometryType = feature.geometry.type;\n  const geometryHandler = geometryTypes[geometryType];\n  if (!defined(geometryHandler)) {\n    throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n  }\n  geometryHandler(dataSource, feature, feature.geometry, crsFunction, options);\n}\n\nfunction processFeatureCollection(\n  dataSource,\n  featureCollection,\n  notUsed,\n  crsFunction,\n  options,\n) {\n  const features = featureCollection.features;\n  for (let i = 0, len = features.length; i < len; i++) {\n    processFeature(dataSource, features[i], undefined, crsFunction, options);\n  }\n}\n\nfunction processGeometryCollection(\n  dataSource,\n  geoJson,\n  geometryCollection,\n  crsFunction,\n  options,\n) {\n  const geometries = geometryCollection.geometries;\n  for (let i = 0, len = geometries.length; i < len; i++) {\n    const geometry = geometries[i];\n    const geometryType = geometry.type;\n    const geometryHandler = geometryTypes[geometryType];\n    if (!defined(geometryHandler)) {\n      throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n    }\n    geometryHandler(dataSource, geoJson, geometry, crsFunction, options);\n  }\n}\n\nfunction createPoint(dataSource, geoJson, crsFunction, coordinates, options) {\n  let symbol = options.markerSymbol;\n  let color = options.markerColor;\n  let size = options.markerSize;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const cssColor = properties[\"marker-color\"];\n    if (defined(cssColor)) {\n      color = Color.fromCssColorString(cssColor);\n    }\n\n    size = defaultValue(sizes[properties[\"marker-size\"]], size);\n    const markerSymbol = properties[\"marker-symbol\"];\n    if (defined(markerSymbol)) {\n      symbol = markerSymbol;\n    }\n  }\n\n  let canvasOrPromise;\n  if (defined(symbol)) {\n    if (symbol.length === 1) {\n      canvasOrPromise = dataSource._pinBuilder.fromText(\n        symbol.toUpperCase(),\n        color,\n        size,\n      );\n    } else {\n      canvasOrPromise = dataSource._pinBuilder.fromMakiIconId(\n        symbol,\n        color,\n        size,\n      );\n    }\n  } else {\n    canvasOrPromise = dataSource._pinBuilder.fromColor(color, size);\n  }\n\n  const billboard = new BillboardGraphics();\n  billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);\n\n  // Clamp to ground if there isn't a height specified\n  if (coordinates.length === 2 && options.clampToGround) {\n    billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe,\n  );\n  entity.billboard = billboard;\n  entity.position = new ConstantPositionProperty(crsFunction(coordinates));\n\n  const promise = Promise.resolve(canvasOrPromise)\n    .then(function (image) {\n      billboard.image = new ConstantProperty(image);\n    })\n    .catch(function () {\n      billboard.image = new ConstantProperty(\n        dataSource._pinBuilder.fromColor(color, size),\n      );\n    });\n\n  dataSource._promises.push(promise);\n}\n\nfunction processPoint(dataSource, geoJson, geometry, crsFunction, options) {\n  createPoint(dataSource, geoJson, crsFunction, geometry.coordinates, options);\n}\n\nfunction processMultiPoint(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options,\n) {\n  const coordinates = geometry.coordinates;\n  for (let i = 0; i < coordinates.length; i++) {\n    createPoint(dataSource, geoJson, crsFunction, coordinates[i], options);\n  }\n}\n\nfunction createLineString(\n  dataSource,\n  geoJson,\n  crsFunction,\n  coordinates,\n  options,\n) {\n  let material = options.strokeMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    const opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = material.color.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n    if (defined(color)) {\n      material = new ColorMaterialProperty(color);\n    }\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe,\n  );\n  const polylineGraphics = new PolylineGraphics();\n  entity.polyline = polylineGraphics;\n\n  polylineGraphics.clampToGround = options.clampToGround;\n  polylineGraphics.material = material;\n  polylineGraphics.width = widthProperty;\n  polylineGraphics.positions = new ConstantProperty(\n    coordinatesArrayToCartesianArray(coordinates, crsFunction),\n  );\n  polylineGraphics.arcType = ArcType.RHUMB;\n}\n\nfunction processLineString(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options,\n) {\n  createLineString(\n    dataSource,\n    geoJson,\n    crsFunction,\n    geometry.coordinates,\n    options,\n  );\n}\n\nfunction processMultiLineString(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options,\n) {\n  const lineStrings = geometry.coordinates;\n  for (let i = 0; i < lineStrings.length; i++) {\n    createLineString(dataSource, geoJson, crsFunction, lineStrings[i], options);\n  }\n}\n\nfunction createPolygon(dataSource, geoJson, crsFunction, coordinates, options) {\n  if (coordinates.length === 0 || coordinates[0].length === 0) {\n    return;\n  }\n\n  let outlineColorProperty = options.strokeMaterialProperty.color;\n  let material = options.fillMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    let opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = outlineColorProperty.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n\n    if (defined(color)) {\n      outlineColorProperty = new ConstantProperty(color);\n    }\n\n    let fillColor;\n    const fill = properties.fill;\n    const materialColor = material.color.getValue();\n    if (defined(fill)) {\n      fillColor = Color.fromCssColorString(fill);\n      fillColor.alpha = materialColor.alpha;\n    }\n    opacity = properties[\"fill-opacity\"];\n    if (defined(opacity) && opacity !== materialColor.alpha) {\n      if (!defined(fillColor)) {\n        fillColor = materialColor.clone();\n      }\n      fillColor.alpha = opacity;\n    }\n    if (defined(fillColor)) {\n      material = new ColorMaterialProperty(fillColor);\n    }\n  }\n\n  const polygon = new PolygonGraphics();\n  polygon.outline = new ConstantProperty(true);\n  polygon.outlineColor = outlineColorProperty;\n  polygon.outlineWidth = widthProperty;\n  polygon.material = material;\n  polygon.arcType = ArcType.RHUMB;\n\n  const holes = [];\n  for (let i = 1, len = coordinates.length; i < len; i++) {\n    holes.push(\n      new PolygonHierarchy(\n        coordinatesArrayToCartesianArray(coordinates[i], crsFunction),\n      ),\n    );\n  }\n\n  const positions = coordinates[0];\n  polygon.hierarchy = new ConstantProperty(\n    new PolygonHierarchy(\n      coordinatesArrayToCartesianArray(positions, crsFunction),\n      holes,\n    ),\n  );\n  if (positions[0].length > 2) {\n    polygon.perPositionHeight = new ConstantProperty(true);\n  } else if (!options.clampToGround) {\n    polygon.height = 0;\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe,\n  );\n  entity.polygon = polygon;\n}\n\nfunction processPolygon(dataSource, geoJson, geometry, crsFunction, options) {\n  createPolygon(\n    dataSource,\n    geoJson,\n    crsFunction,\n    geometry.coordinates,\n    options,\n  );\n}\n\nfunction processMultiPolygon(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options,\n) {\n  const polygons = geometry.coordinates;\n  for (let i = 0; i < polygons.length; i++) {\n    createPolygon(dataSource, geoJson, crsFunction, polygons[i], options);\n  }\n}\n\nfunction processTopology(dataSource, geoJson, geometry, crsFunction, options) {\n  for (const property in geometry.objects) {\n    if (geometry.objects.hasOwnProperty(property)) {\n      const feature = topojson.feature(geometry, geometry.objects[property]);\n      const typeHandler = geoJsonObjectTypes[feature.type];\n      typeHandler(dataSource, feature, feature, crsFunction, options);\n    }\n  }\n}\n\n/**\n * @typedef {object} GeoJsonDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {GeoJsonDataSource.describe} [describe=GeoJsonDataSource.defaultDescribeProperty] A function which returns a Property object (or just a string).\n * @property {number} [markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.\n * @property {string} [markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.\n * @property {Color} [markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.\n * @property {Color} [stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.\n * @property {number} [strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.\n * @property {Color} [fill=GeoJsonDataSource.fill] The default color for polygon interiors.\n * @property {boolean} [clampToGround=GeoJsonDataSource.clampToGround] true if we want the geometry features (polygons or linestrings) clamped to the ground.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes both\n * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.\n * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they\n * are present.\n *\n * @alias GeoJsonDataSource\n * @constructor\n *\n * @param {string} [name] The name of this data source.  If undefined, a name will be taken from\n *                        the name of the GeoJSON file.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20and%20TopoJSON.html|Cesium Sandcastle GeoJSON and TopoJSON Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20simplestyle.html|Cesium Sandcastle GeoJSON simplestyle Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {\n *   stroke: Cesium.Color.HOTPINK,\n *   fill: Cesium.Color.PINK,\n *   strokeWidth: 3,\n *   markerSymbol: '?'\n * }));\n */\nfunction GeoJsonDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._entityCollection = new EntityCollection(this);\n  this._promises = [];\n  this._pinBuilder = new PinBuilder();\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.\n *\n * @param {Resource|string|object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<GeoJsonDataSource>} A promise that will resolve when the data is loaded.\n */\nGeoJsonDataSource.load = function (data, options) {\n  return new GeoJsonDataSource().load(data, options);\n};\n\nObject.defineProperties(GeoJsonDataSource, {\n  /**\n   * Gets or sets the default size of the map pin created for each point, in pixels.\n   * @memberof GeoJsonDataSource\n   * @type {number}\n   * @default 48\n   */\n  markerSize: {\n    get: function () {\n      return defaultMarkerSize;\n    },\n    set: function (value) {\n      defaultMarkerSize = value;\n    },\n  },\n  /**\n   * Gets or sets the default symbol of the map pin created for each point.\n   * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,\n   * or blank if no symbol is to be used.\n   * @memberof GeoJsonDataSource\n   * @type {string}\n   */\n  markerSymbol: {\n    get: function () {\n      return defaultMarkerSymbol;\n    },\n    set: function (value) {\n      defaultMarkerSymbol = value;\n    },\n  },\n  /**\n   * Gets or sets the default color of the map pin created for each point.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.ROYALBLUE\n   */\n  markerColor: {\n    get: function () {\n      return defaultMarkerColor;\n    },\n    set: function (value) {\n      defaultMarkerColor = value;\n    },\n  },\n  /**\n   * Gets or sets the default color of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.BLACK\n   */\n  stroke: {\n    get: function () {\n      return defaultStroke;\n    },\n    set: function (value) {\n      defaultStroke = value;\n    },\n  },\n  /**\n   * Gets or sets the default width of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {number}\n   * @default 2.0\n   */\n  strokeWidth: {\n    get: function () {\n      return defaultStrokeWidth;\n    },\n    set: function (value) {\n      defaultStrokeWidth = value;\n    },\n  },\n  /**\n   * Gets or sets default color for polygon interiors.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.YELLOW\n   */\n  fill: {\n    get: function () {\n      return defaultFill;\n    },\n    set: function (value) {\n      defaultFill = value;\n    },\n  },\n  /**\n   * Gets or sets default of whether to clamp to the ground.\n   * @memberof GeoJsonDataSource\n   * @type {boolean}\n   * @default false\n   */\n  clampToGround: {\n    get: function () {\n      return defaultClampToGround;\n    },\n    set: function (value) {\n      defaultClampToGround = value;\n    },\n  },\n\n  /**\n   * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate\n   * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which\n   * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,\n   * for example 'EPSG:4326'.\n   * @memberof GeoJsonDataSource\n   * @type {object}\n   */\n  crsNames: {\n    get: function () {\n      return crsNames;\n    },\n  },\n\n  /**\n   * Gets an object that maps the href property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming\n   * the link has a type specified.\n   * @memberof GeoJsonDataSource\n   * @type {object}\n   */\n  crsLinkHrefs: {\n    get: function () {\n      return crsLinkHrefs;\n    },\n  },\n\n  /**\n   * Gets an object that maps the type property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in <code>crsLinkHrefs</code> take precedence over this object.\n   * @memberof GeoJsonDataSource\n   * @type {object}\n   */\n  crsLinkTypes: {\n    get: function () {\n      return crsLinkTypes;\n    },\n  },\n});\n\nObject.defineProperties(GeoJsonDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * This DataSource only defines static data, therefore this property is always undefined.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    value: undefined,\n    writable: false,\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.\n *\n * @param {Resource|string|object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.load = function (data, options) {\n  return preload(this, data, options, true);\n};\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, without replacing any existing data.\n *\n * @param {Resource|string|object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.process = function (data, options) {\n  return preload(this, data, options, false);\n};\n\nfunction preload(that, data, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  DataSource.setLoading(that, true);\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  that._credit = credit;\n\n  let promise = data;\n  let sourceUri = options.sourceUri;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchJson();\n    sourceUri = defaultValue(sourceUri, data.getUrlComponent());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = that._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n\n  options = {\n    describe: defaultValue(options.describe, defaultDescribeProperty),\n    markerSize: defaultValue(options.markerSize, defaultMarkerSize),\n    markerSymbol: defaultValue(options.markerSymbol, defaultMarkerSymbol),\n    markerColor: defaultValue(options.markerColor, defaultMarkerColor),\n    strokeWidthProperty: new ConstantProperty(\n      defaultValue(options.strokeWidth, defaultStrokeWidth),\n    ),\n    strokeMaterialProperty: new ColorMaterialProperty(\n      defaultValue(options.stroke, defaultStroke),\n    ),\n    fillMaterialProperty: new ColorMaterialProperty(\n      defaultValue(options.fill, defaultFill),\n    ),\n    clampToGround: defaultValue(options.clampToGround, defaultClampToGround),\n  };\n\n  return Promise.resolve(promise)\n    .then(function (geoJson) {\n      return load(that, geoJson, options, sourceUri, clear);\n    })\n    .catch(function (error) {\n      DataSource.setLoading(that, false);\n      that._error.raiseEvent(that, error);\n      throw error;\n    });\n}\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nGeoJsonDataSource.prototype.update = function (time) {\n  return true;\n};\n\nfunction load(that, geoJson, options, sourceUri, clear) {\n  let name;\n  if (defined(sourceUri)) {\n    name = getFilenameFromUri(sourceUri);\n  }\n\n  if (defined(name) && that._name !== name) {\n    that._name = name;\n    that._changed.raiseEvent(that);\n  }\n\n  const typeHandler = geoJsonObjectTypes[geoJson.type];\n  if (!defined(typeHandler)) {\n    throw new RuntimeError(`Unsupported GeoJSON object type: ${geoJson.type}`);\n  }\n\n  //Check for a Coordinate Reference System.\n  const crs = geoJson.crs;\n  let crsFunction = crs !== null ? defaultCrsFunction : null;\n\n  if (defined(crs)) {\n    if (!defined(crs.properties)) {\n      throw new RuntimeError(\"crs.properties is undefined.\");\n    }\n\n    const properties = crs.properties;\n    if (crs.type === \"name\") {\n      crsFunction = crsNames[properties.name];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs name: ${properties.name}`);\n      }\n    } else if (crs.type === \"link\") {\n      let handler = crsLinkHrefs[properties.href];\n      if (!defined(handler)) {\n        handler = crsLinkTypes[properties.type];\n      }\n\n      if (!defined(handler)) {\n        throw new RuntimeError(\n          `Unable to resolve crs link: ${JSON.stringify(properties)}`,\n        );\n      }\n\n      crsFunction = handler(properties);\n    } else if (crs.type === \"EPSG\") {\n      crsFunction = crsNames[`EPSG:${properties.code}`];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs EPSG code: ${properties.code}`);\n      }\n    } else {\n      throw new RuntimeError(`Unknown crs type: ${crs.type}`);\n    }\n  }\n\n  return Promise.resolve(crsFunction).then(function (crsFunction) {\n    if (clear) {\n      that._entityCollection.removeAll();\n    }\n\n    // null is a valid value for the crs, but means the entire load process becomes a no-op\n    // because we can't assume anything about the coordinates.\n    if (crsFunction !== null) {\n      typeHandler(that, geoJson, geoJson, crsFunction, options);\n    }\n\n    return Promise.all(that._promises).then(function () {\n      that._promises.length = 0;\n      DataSource.setLoading(that, false);\n      return that;\n    });\n  });\n}\n\n/**\n * This callback is displayed as part of the GeoJsonDataSource class.\n * @callback GeoJsonDataSource.describe\n * @param {object} properties The properties of the feature.\n * @param {string} nameProperty The property key that Cesium estimates to have the name of the feature.\n */\nexport default GeoJsonDataSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}