{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n  if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = -Cartesian3.dot(normal, point);\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\nconst scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  const distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!CesiumMath.equalsEpsilon(Cartesian3.magnitude(normal), 1.0, CesiumMath.EPSILON6)) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\nconst scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  const pointDistance = Plane.getPointDistance(plane, point);\n  const scaledNormal = Cartesian3.multiplyByScalar(plane.normal, pointDistance, scratchCartesian);\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\nconst scratchInverseTranspose = new Matrix4();\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformNormal = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const normal = plane.normal;\n  const distance = plane.distance;\n  const inverseTranspose = Matrix4.inverseTranspose(transform, scratchInverseTranspose);\n  let planeAsCartesian4 = Cartesian4.fromElements(normal.x, normal.y, normal.z, distance, scratchPlaneCartesian4);\n  planeAsCartesian4 = Matrix4.multiplyByVector(inverseTranspose, planeAsCartesian4, planeAsCartesian4);\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(planeAsCartesian4, scratchTransformNormal);\n  planeAsCartesian4 = Cartesian4.divideByScalar(planeAsCartesian4, Cartesian3.magnitude(transformedNormal), planeAsCartesian4);\n  return Plane.fromCartesian4(planeAsCartesian4, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.distance === right.distance && Cartesian3.equals(left.normal, right.normal);\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;","map":{"version":3,"names":["Cartesian3","Cartesian4","Check","defined","DeveloperError","CesiumMath","Matrix4","Plane","normal","distance","typeOf","object","equalsEpsilon","magnitude","EPSILON6","number","clone","fromPointNormal","point","result","dot","scratchNormal","fromCartesian4","coefficients","w","getPointDistance","plane","scratchCartesian","projectPointOntoPlane","pointDistance","scaledNormal","multiplyByScalar","subtract","scratchInverseTranspose","scratchPlaneCartesian4","scratchTransformNormal","transform","inverseTranspose","planeAsCartesian4","fromElements","x","y","z","multiplyByVector","transformedNormal","divideByScalar","equals","left","right","ORIGIN_XY_PLANE","Object","freeze","UNIT_Z","ORIGIN_YZ_PLANE","UNIT_X","ORIGIN_ZX_PLANE","UNIT_Y"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Plane.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = -Cartesian3.dot(normal, point);\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nconst scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  const distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6,\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nconst scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  const pointDistance = Plane.getPointDistance(plane, point);\n  const scaledNormal = Cartesian3.multiplyByScalar(\n    plane.normal,\n    pointDistance,\n    scratchCartesian,\n  );\n\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\n\nconst scratchInverseTranspose = new Matrix4();\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformNormal = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const normal = plane.normal;\n  const distance = plane.distance;\n  const inverseTranspose = Matrix4.inverseTranspose(\n    transform,\n    scratchInverseTranspose,\n  );\n  let planeAsCartesian4 = Cartesian4.fromElements(\n    normal.x,\n    normal.y,\n    normal.z,\n    distance,\n    scratchPlaneCartesian4,\n  );\n  planeAsCartesian4 = Matrix4.multiplyByVector(\n    inverseTranspose,\n    planeAsCartesian4,\n    planeAsCartesian4,\n  );\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(\n    planeAsCartesian4,\n    scratchTransformNormal,\n  );\n\n  planeAsCartesian4 = Cartesian4.divideByScalar(\n    planeAsCartesian4,\n    Cartesian3.magnitude(transformedNormal),\n    planeAsCartesian4,\n  );\n\n  return Plane.fromCartesian4(planeAsCartesian4, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.distance === right.distance &&\n    Cartesian3.equals(left.normal, right.normal)\n  );\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}