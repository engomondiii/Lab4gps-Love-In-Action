{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec3 v_outerPositionWC;\\n\\\n\\n\\\nuniform vec3 u_hsbShift;\\n\\\n\\n\\\n#ifndef PER_FRAGMENT_ATMOSPHERE\\n\\\nin vec3 v_mieColor;\\n\\\nin vec3 v_rayleighColor;\\n\\\nin float v_opacity;\\n\\\nin float v_translucent;\\n\\\n#endif\\n\\\n\\n\\\nvoid main (void)\\n\\\n{\\n\\\n    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;\\n\\\n    vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(v_outerPositionWC, lightEnum);\\n\\\n\\n\\\n    vec3 mieColor;\\n\\\n    vec3 rayleighColor;\\n\\\n    float opacity;\\n\\\n    float translucent;\\n\\\n\\n\\\n    #ifdef PER_FRAGMENT_ATMOSPHERE\\n\\\n        computeAtmosphereScattering(\\n\\\n            v_outerPositionWC,\\n\\\n            lightDirection,\\n\\\n            rayleighColor,\\n\\\n            mieColor,\\n\\\n            opacity,\\n\\\n            translucent\\n\\\n        );\\n\\\n    #else\\n\\\n        mieColor = v_mieColor;\\n\\\n        rayleighColor = v_rayleighColor;\\n\\\n        opacity = v_opacity;\\n\\\n        translucent = v_translucent;\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 color = computeAtmosphereColor(v_outerPositionWC, lightDirection, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n    #ifndef HDR\\n\\\n        color.rgb = czm_pbrNeutralTonemapping(color.rgb);\\n\\\n        color.rgb = czm_inverseGamma(color.rgb);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef COLOR_CORRECT\\n\\\n        const bool ignoreBlackPixels = true;\\n\\\n        color.rgb = czm_applyHSBShift(color.rgb, u_hsbShift, ignoreBlackPixels);\\n\\\n    #endif\\n\\\n\\n\\\n    // For the parts of the sky atmosphere that are not behind a translucent globe,\\n\\\n    // we mix in the default opacity so that the sky atmosphere still appears at distance.\\n\\\n    // This is needed because the opacity in the sky atmosphere is initially adjusted based\\n\\\n    // on the camera height.\\n\\\n    if (translucent == 0.0) {\\n\\\n        color.a = mix(color.b, 1.0, color.a) * smoothstep(0.0, 1.0, czm_morphTime);\\n\\\n    }\\n\\\n\\n\\\n    out_FragColor = color;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/SkyAtmosphereFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec3 v_outerPositionWC;\\n\\\n\\n\\\nuniform vec3 u_hsbShift;\\n\\\n\\n\\\n#ifndef PER_FRAGMENT_ATMOSPHERE\\n\\\nin vec3 v_mieColor;\\n\\\nin vec3 v_rayleighColor;\\n\\\nin float v_opacity;\\n\\\nin float v_translucent;\\n\\\n#endif\\n\\\n\\n\\\nvoid main (void)\\n\\\n{\\n\\\n    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;\\n\\\n    vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(v_outerPositionWC, lightEnum);\\n\\\n\\n\\\n    vec3 mieColor;\\n\\\n    vec3 rayleighColor;\\n\\\n    float opacity;\\n\\\n    float translucent;\\n\\\n\\n\\\n    #ifdef PER_FRAGMENT_ATMOSPHERE\\n\\\n        computeAtmosphereScattering(\\n\\\n            v_outerPositionWC,\\n\\\n            lightDirection,\\n\\\n            rayleighColor,\\n\\\n            mieColor,\\n\\\n            opacity,\\n\\\n            translucent\\n\\\n        );\\n\\\n    #else\\n\\\n        mieColor = v_mieColor;\\n\\\n        rayleighColor = v_rayleighColor;\\n\\\n        opacity = v_opacity;\\n\\\n        translucent = v_translucent;\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 color = computeAtmosphereColor(v_outerPositionWC, lightDirection, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n    #ifndef HDR\\n\\\n        color.rgb = czm_pbrNeutralTonemapping(color.rgb);\\n\\\n        color.rgb = czm_inverseGamma(color.rgb);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef COLOR_CORRECT\\n\\\n        const bool ignoreBlackPixels = true;\\n\\\n        color.rgb = czm_applyHSBShift(color.rgb, u_hsbShift, ignoreBlackPixels);\\n\\\n    #endif\\n\\\n\\n\\\n    // For the parts of the sky atmosphere that are not behind a translucent globe,\\n\\\n    // we mix in the default opacity so that the sky atmosphere still appears at distance.\\n\\\n    // This is needed because the opacity in the sky atmosphere is initially adjusted based\\n\\\n    // on the camera height.\\n\\\n    if (translucent == 0.0) {\\n\\\n        color.a = mix(color.b, 1.0, color.a) * smoothstep(0.0, 1.0, czm_morphTime);\\n\\\n    }\\n\\\n\\n\\\n    out_FragColor = color;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}