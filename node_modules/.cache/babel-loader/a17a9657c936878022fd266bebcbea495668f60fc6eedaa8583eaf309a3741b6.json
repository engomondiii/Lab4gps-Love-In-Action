{"ast":null,"code":"import Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport srgbToLinear from \"../Core/srgbToLinear.js\";\n\n/**\n * This class implements an I3S symbology for I3S Layers.\n * <p>\n * Do not construct this directly, instead access symbology through {@link I3SLayer}.\n * </p>\n * @alias I3SSymbology\n * @internalConstructor\n */\nfunction I3SSymbology(layer) {\n  this._layer = layer;\n  this._defaultSymbology = undefined;\n  this._valueFields = [];\n  this._uniqueValueHash = undefined;\n  this._classBreaksHash = undefined;\n  this._parseLayerSymbology();\n}\nObject.defineProperties(I3SSymbology.prototype, {\n  /**\n   * Gets the default symbology data.\n   * @memberof I3SSymbology.prototype\n   * @type {object}\n   * @readonly\n   */\n  defaultSymbology: {\n    get: function () {\n      return this._defaultSymbology;\n    }\n  }\n});\nfunction convertColor(color, transparency) {\n  // color is represented as a three or four-element array, values range from 0 through 255.\n  // transparency value has to lie between 100 (full transparency) and 0 (full opacity).\n  const convertedColor = [];\n  for (let i = 0; i < color.length; i++) {\n    const floatColor = Color.byteToFloat(color[i]);\n    if (i < 3) {\n      convertedColor.push(srgbToLinear(floatColor));\n    } else {\n      convertedColor.push(floatColor);\n    }\n  }\n  if (convertedColor.length === 3) {\n    if (defined(transparency)) {\n      convertedColor.push(1.0 - transparency / 100.0);\n    } else {\n      convertedColor.push(1.0);\n    }\n  }\n  return convertedColor;\n}\nfunction parseSymbol(symbol, isColorCaptured) {\n  const symbology = {\n    edges: undefined,\n    material: undefined\n  };\n  if (defined(symbol) && defined(symbol.symbolLayers)) {\n    for (let i = 0; i < symbol.symbolLayers.length; i++) {\n      const symbolLayer = symbol.symbolLayers[i];\n      if (symbolLayer.type === \"Fill\") {\n        const edges = symbolLayer.edges;\n        const outline = symbolLayer.outline;\n        if (defined(edges)) {\n          symbology.edges = {};\n          if (defined(edges.color)) {\n            symbology.edges.color = convertColor(edges.color, edges.transparency);\n          }\n        } else if (defined(outline)) {\n          symbology.edges = {};\n          if (defined(outline.color)) {\n            symbology.edges.color = convertColor(outline.color, outline.transparency);\n          }\n        }\n        if (!isColorCaptured) {\n          const material = symbolLayer.material;\n          if (defined(material)) {\n            symbology.material = {\n              colorMixMode: material.colorMixMode\n            };\n            if (defined(material.color)) {\n              symbology.material.color = convertColor(material.color, material.transparency);\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n  return symbology;\n}\nfunction buildUniqueValueHash(renderer, isColorCaptured) {\n  if (defined(renderer.uniqueValueGroups)) {\n    const valueHash = {};\n    for (let groupIndex = 0; groupIndex < renderer.uniqueValueGroups.length; groupIndex++) {\n      const classes = renderer.uniqueValueGroups[groupIndex].classes;\n      if (defined(classes)) {\n        for (let classIndex = 0; classIndex < classes.length; classIndex++) {\n          const classSymbology = parseSymbol(classes[classIndex].symbol, isColorCaptured);\n          const values = classes[classIndex].values;\n          for (let valueIndex = 0; valueIndex < values.length; valueIndex++) {\n            const fieldValues = values[valueIndex];\n            let hash = valueHash;\n            for (let fieldIndex = 0; fieldIndex < fieldValues.length; fieldIndex++) {\n              const fieldValue = fieldValues[fieldIndex];\n              if (fieldIndex === fieldValues.length - 1) {\n                hash[fieldValue] = classSymbology;\n              } else {\n                if (!defined(hash[fieldValue])) {\n                  hash[fieldValue] = {};\n                }\n                hash = hash[fieldValue];\n              }\n            }\n          }\n        }\n      }\n    }\n    return valueHash;\n  }\n  if (defined(renderer.uniqueValueInfos)) {\n    const valueHash = {};\n    for (let infoIndex = 0; infoIndex < renderer.uniqueValueInfos.length; infoIndex++) {\n      const info = renderer.uniqueValueInfos[infoIndex];\n      valueHash[info.value] = parseSymbol(info.symbol, isColorCaptured);\n    }\n    return valueHash;\n  }\n  return undefined;\n}\nfunction buildClassBreaksHash(renderer, isColorCaptured) {\n  if (defined(renderer.classBreakInfos)) {\n    const classBreakInfos = [...renderer.classBreakInfos];\n    classBreakInfos.sort(function (a, b) {\n      const aMax = defaultValue(a.classMaxValue, a.classMinValue);\n      const bMax = defaultValue(b.classMaxValue, b.classMinValue);\n      return aMax - bMax;\n    });\n    const valueHash = {\n      ranges: [],\n      symbols: []\n    };\n    if (defined(renderer.minValue)) {\n      valueHash.ranges.push(renderer.minValue);\n      valueHash.symbols.push(undefined);\n    }\n    for (let infoIndex = 0; infoIndex < classBreakInfos.length; infoIndex++) {\n      const info = classBreakInfos[infoIndex];\n      if (defined(info.classMinValue)) {\n        if (valueHash.ranges.length === 0 || info.classMinValue > valueHash.ranges[valueHash.ranges.length - 1]) {\n          valueHash.ranges.push(info.classMinValue);\n          valueHash.symbols.push(undefined);\n        }\n      }\n      if (defined(info.classMaxValue)) {\n        if (valueHash.ranges.length === 0 || info.classMaxValue > valueHash.ranges[valueHash.ranges.length - 1]) {\n          valueHash.ranges.push(info.classMaxValue);\n          valueHash.symbols.push(parseSymbol(info.symbol, isColorCaptured));\n        }\n      }\n    }\n    valueHash.symbols.push(undefined);\n    return valueHash;\n  }\n  return undefined;\n}\n\n/**\n * @private\n */\nI3SSymbology.prototype._parseLayerSymbology = function () {\n  const drawingInfo = this._layer.data.drawingInfo;\n  if (defined(drawingInfo) && defined(drawingInfo.renderer)) {\n    const cachedDrawingInfo = this._layer.data.cachedDrawingInfo;\n    const isColorCaptured = defined(cachedDrawingInfo) && cachedDrawingInfo.color === true;\n    const renderer = drawingInfo.renderer;\n    if (renderer.type === \"simple\") {\n      this._defaultSymbology = parseSymbol(renderer.symbol, isColorCaptured);\n    } else if (renderer.type === \"uniqueValue\") {\n      this._defaultSymbology = parseSymbol(renderer.defaultSymbol, isColorCaptured);\n      this._valueFields.push(renderer.field1);\n      if (defined(renderer.field2)) {\n        this._valueFields.push(renderer.field2);\n      }\n      if (defined(renderer.field3)) {\n        this._valueFields.push(renderer.field3);\n      }\n      this._uniqueValueHash = buildUniqueValueHash(renderer, isColorCaptured);\n    } else if (renderer.type === \"classBreaks\") {\n      this._defaultSymbology = parseSymbol(renderer.defaultSymbol, isColorCaptured);\n      this._valueFields.push(renderer.field);\n      this._classBreaksHash = buildClassBreaksHash(renderer, isColorCaptured);\n    }\n  }\n};\nfunction findHashForUniqueValues(hash, values, hashLevel, valueIndex) {\n  const levelValues = values[hashLevel];\n  if (valueIndex < levelValues.length) {\n    const hashValue = levelValues[valueIndex];\n    const innerHash = hash[hashValue];\n    if (defined(innerHash) && ++hashLevel < values.length) {\n      return findHashForUniqueValues(innerHash, values, hashLevel, valueIndex);\n    }\n    return innerHash;\n  }\n  return undefined;\n}\nfunction bisect(array, value) {\n  let low = 0;\n  let high = array.length;\n  if (low < high) {\n    do {\n      const mid = low + high >>> 1;\n      if (array[mid] < value) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    } while (low < high);\n  }\n  return low;\n}\nfunction findHashForClassBreaks(hash, values, valueIndex) {\n  const value = values[valueIndex];\n  const range = bisect(hash.ranges, value);\n  return hash.symbols[range];\n}\n\n/**\n * @private\n */\nI3SSymbology.prototype._getSymbology = async function (node) {\n  const symbology = {\n    default: this._defaultSymbology\n  };\n  if (this._valueFields.length > 0) {\n    const promises = [];\n    for (let i = 0; i < this._valueFields.length; i++) {\n      promises.push(node.loadField(this._valueFields[i]));\n    }\n    await Promise.all(promises);\n    const fieldsValues = [];\n    for (let i = 0; i < this._valueFields.length; i++) {\n      fieldsValues.push(node.fields[this._valueFields[i]].values);\n    }\n    let featureHashFn;\n    if (defined(this._uniqueValueHash)) {\n      featureHashFn = featureIndex => findHashForUniqueValues(this._uniqueValueHash, fieldsValues, 0, featureIndex);\n    } else if (defined(this._classBreaksHash)) {\n      featureHashFn = featureIndex => findHashForClassBreaks(this._classBreaksHash, fieldsValues[0], featureIndex);\n    }\n    if (defined(featureHashFn)) {\n      const firstFieldValues = fieldsValues[0];\n      for (let featureIndex = 0; featureIndex < firstFieldValues.length; featureIndex++) {\n        const featureSymbology = featureHashFn(featureIndex);\n        if (defined(featureSymbology)) {\n          symbology[featureIndex] = featureSymbology;\n        }\n      }\n    }\n  }\n  return symbology;\n};\nexport default I3SSymbology;","map":{"version":3,"names":["Color","defaultValue","defined","srgbToLinear","I3SSymbology","layer","_layer","_defaultSymbology","undefined","_valueFields","_uniqueValueHash","_classBreaksHash","_parseLayerSymbology","Object","defineProperties","prototype","defaultSymbology","get","convertColor","color","transparency","convertedColor","i","length","floatColor","byteToFloat","push","parseSymbol","symbol","isColorCaptured","symbology","edges","material","symbolLayers","symbolLayer","type","outline","colorMixMode","buildUniqueValueHash","renderer","uniqueValueGroups","valueHash","groupIndex","classes","classIndex","classSymbology","values","valueIndex","fieldValues","hash","fieldIndex","fieldValue","uniqueValueInfos","infoIndex","info","value","buildClassBreaksHash","classBreakInfos","sort","a","b","aMax","classMaxValue","classMinValue","bMax","ranges","symbols","minValue","drawingInfo","data","cachedDrawingInfo","defaultSymbol","field1","field2","field3","field","findHashForUniqueValues","hashLevel","levelValues","hashValue","innerHash","bisect","array","low","high","mid","findHashForClassBreaks","range","_getSymbology","node","default","promises","loadField","Promise","all","fieldsValues","fields","featureHashFn","featureIndex","firstFieldValues","featureSymbology"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/I3SSymbology.js"],"sourcesContent":["import Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport srgbToLinear from \"../Core/srgbToLinear.js\";\n\n/**\n * This class implements an I3S symbology for I3S Layers.\n * <p>\n * Do not construct this directly, instead access symbology through {@link I3SLayer}.\n * </p>\n * @alias I3SSymbology\n * @internalConstructor\n */\nfunction I3SSymbology(layer) {\n  this._layer = layer;\n  this._defaultSymbology = undefined;\n  this._valueFields = [];\n  this._uniqueValueHash = undefined;\n  this._classBreaksHash = undefined;\n\n  this._parseLayerSymbology();\n}\n\nObject.defineProperties(I3SSymbology.prototype, {\n  /**\n   * Gets the default symbology data.\n   * @memberof I3SSymbology.prototype\n   * @type {object}\n   * @readonly\n   */\n  defaultSymbology: {\n    get: function () {\n      return this._defaultSymbology;\n    },\n  },\n});\n\nfunction convertColor(color, transparency) {\n  // color is represented as a three or four-element array, values range from 0 through 255.\n  // transparency value has to lie between 100 (full transparency) and 0 (full opacity).\n  const convertedColor = [];\n  for (let i = 0; i < color.length; i++) {\n    const floatColor = Color.byteToFloat(color[i]);\n    if (i < 3) {\n      convertedColor.push(srgbToLinear(floatColor));\n    } else {\n      convertedColor.push(floatColor);\n    }\n  }\n  if (convertedColor.length === 3) {\n    if (defined(transparency)) {\n      convertedColor.push(1.0 - transparency / 100.0);\n    } else {\n      convertedColor.push(1.0);\n    }\n  }\n  return convertedColor;\n}\n\nfunction parseSymbol(symbol, isColorCaptured) {\n  const symbology = {\n    edges: undefined,\n    material: undefined,\n  };\n  if (defined(symbol) && defined(symbol.symbolLayers)) {\n    for (let i = 0; i < symbol.symbolLayers.length; i++) {\n      const symbolLayer = symbol.symbolLayers[i];\n      if (symbolLayer.type === \"Fill\") {\n        const edges = symbolLayer.edges;\n        const outline = symbolLayer.outline;\n        if (defined(edges)) {\n          symbology.edges = {};\n          if (defined(edges.color)) {\n            symbology.edges.color = convertColor(\n              edges.color,\n              edges.transparency,\n            );\n          }\n        } else if (defined(outline)) {\n          symbology.edges = {};\n          if (defined(outline.color)) {\n            symbology.edges.color = convertColor(\n              outline.color,\n              outline.transparency,\n            );\n          }\n        }\n\n        if (!isColorCaptured) {\n          const material = symbolLayer.material;\n          if (defined(material)) {\n            symbology.material = {\n              colorMixMode: material.colorMixMode,\n            };\n            if (defined(material.color)) {\n              symbology.material.color = convertColor(\n                material.color,\n                material.transparency,\n              );\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n  return symbology;\n}\n\nfunction buildUniqueValueHash(renderer, isColorCaptured) {\n  if (defined(renderer.uniqueValueGroups)) {\n    const valueHash = {};\n    for (\n      let groupIndex = 0;\n      groupIndex < renderer.uniqueValueGroups.length;\n      groupIndex++\n    ) {\n      const classes = renderer.uniqueValueGroups[groupIndex].classes;\n      if (defined(classes)) {\n        for (let classIndex = 0; classIndex < classes.length; classIndex++) {\n          const classSymbology = parseSymbol(\n            classes[classIndex].symbol,\n            isColorCaptured,\n          );\n          const values = classes[classIndex].values;\n          for (let valueIndex = 0; valueIndex < values.length; valueIndex++) {\n            const fieldValues = values[valueIndex];\n            let hash = valueHash;\n            for (\n              let fieldIndex = 0;\n              fieldIndex < fieldValues.length;\n              fieldIndex++\n            ) {\n              const fieldValue = fieldValues[fieldIndex];\n              if (fieldIndex === fieldValues.length - 1) {\n                hash[fieldValue] = classSymbology;\n              } else {\n                if (!defined(hash[fieldValue])) {\n                  hash[fieldValue] = {};\n                }\n                hash = hash[fieldValue];\n              }\n            }\n          }\n        }\n      }\n    }\n    return valueHash;\n  }\n  if (defined(renderer.uniqueValueInfos)) {\n    const valueHash = {};\n    for (\n      let infoIndex = 0;\n      infoIndex < renderer.uniqueValueInfos.length;\n      infoIndex++\n    ) {\n      const info = renderer.uniqueValueInfos[infoIndex];\n      valueHash[info.value] = parseSymbol(info.symbol, isColorCaptured);\n    }\n    return valueHash;\n  }\n  return undefined;\n}\n\nfunction buildClassBreaksHash(renderer, isColorCaptured) {\n  if (defined(renderer.classBreakInfos)) {\n    const classBreakInfos = [...renderer.classBreakInfos];\n    classBreakInfos.sort(function (a, b) {\n      const aMax = defaultValue(a.classMaxValue, a.classMinValue);\n      const bMax = defaultValue(b.classMaxValue, b.classMinValue);\n      return aMax - bMax;\n    });\n    const valueHash = {\n      ranges: [],\n      symbols: [],\n    };\n\n    if (defined(renderer.minValue)) {\n      valueHash.ranges.push(renderer.minValue);\n      valueHash.symbols.push(undefined);\n    }\n    for (let infoIndex = 0; infoIndex < classBreakInfos.length; infoIndex++) {\n      const info = classBreakInfos[infoIndex];\n      if (defined(info.classMinValue)) {\n        if (\n          valueHash.ranges.length === 0 ||\n          info.classMinValue > valueHash.ranges[valueHash.ranges.length - 1]\n        ) {\n          valueHash.ranges.push(info.classMinValue);\n          valueHash.symbols.push(undefined);\n        }\n      }\n      if (defined(info.classMaxValue)) {\n        if (\n          valueHash.ranges.length === 0 ||\n          info.classMaxValue > valueHash.ranges[valueHash.ranges.length - 1]\n        ) {\n          valueHash.ranges.push(info.classMaxValue);\n          valueHash.symbols.push(parseSymbol(info.symbol, isColorCaptured));\n        }\n      }\n    }\n    valueHash.symbols.push(undefined);\n\n    return valueHash;\n  }\n  return undefined;\n}\n\n/**\n * @private\n */\nI3SSymbology.prototype._parseLayerSymbology = function () {\n  const drawingInfo = this._layer.data.drawingInfo;\n  if (defined(drawingInfo) && defined(drawingInfo.renderer)) {\n    const cachedDrawingInfo = this._layer.data.cachedDrawingInfo;\n    const isColorCaptured =\n      defined(cachedDrawingInfo) && cachedDrawingInfo.color === true;\n    const renderer = drawingInfo.renderer;\n    if (renderer.type === \"simple\") {\n      this._defaultSymbology = parseSymbol(renderer.symbol, isColorCaptured);\n    } else if (renderer.type === \"uniqueValue\") {\n      this._defaultSymbology = parseSymbol(\n        renderer.defaultSymbol,\n        isColorCaptured,\n      );\n      this._valueFields.push(renderer.field1);\n      if (defined(renderer.field2)) {\n        this._valueFields.push(renderer.field2);\n      }\n      if (defined(renderer.field3)) {\n        this._valueFields.push(renderer.field3);\n      }\n      this._uniqueValueHash = buildUniqueValueHash(renderer, isColorCaptured);\n    } else if (renderer.type === \"classBreaks\") {\n      this._defaultSymbology = parseSymbol(\n        renderer.defaultSymbol,\n        isColorCaptured,\n      );\n      this._valueFields.push(renderer.field);\n      this._classBreaksHash = buildClassBreaksHash(renderer, isColorCaptured);\n    }\n  }\n};\n\nfunction findHashForUniqueValues(hash, values, hashLevel, valueIndex) {\n  const levelValues = values[hashLevel];\n  if (valueIndex < levelValues.length) {\n    const hashValue = levelValues[valueIndex];\n    const innerHash = hash[hashValue];\n    if (defined(innerHash) && ++hashLevel < values.length) {\n      return findHashForUniqueValues(innerHash, values, hashLevel, valueIndex);\n    }\n    return innerHash;\n  }\n  return undefined;\n}\n\nfunction bisect(array, value) {\n  let low = 0;\n  let high = array.length;\n  if (low < high) {\n    do {\n      const mid = (low + high) >>> 1;\n      if (array[mid] < value) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    } while (low < high);\n  }\n  return low;\n}\n\nfunction findHashForClassBreaks(hash, values, valueIndex) {\n  const value = values[valueIndex];\n  const range = bisect(hash.ranges, value);\n  return hash.symbols[range];\n}\n\n/**\n * @private\n */\nI3SSymbology.prototype._getSymbology = async function (node) {\n  const symbology = {\n    default: this._defaultSymbology,\n  };\n\n  if (this._valueFields.length > 0) {\n    const promises = [];\n    for (let i = 0; i < this._valueFields.length; i++) {\n      promises.push(node.loadField(this._valueFields[i]));\n    }\n    await Promise.all(promises);\n\n    const fieldsValues = [];\n    for (let i = 0; i < this._valueFields.length; i++) {\n      fieldsValues.push(node.fields[this._valueFields[i]].values);\n    }\n\n    let featureHashFn;\n    if (defined(this._uniqueValueHash)) {\n      featureHashFn = (featureIndex) =>\n        findHashForUniqueValues(\n          this._uniqueValueHash,\n          fieldsValues,\n          0,\n          featureIndex,\n        );\n    } else if (defined(this._classBreaksHash)) {\n      featureHashFn = (featureIndex) =>\n        findHashForClassBreaks(\n          this._classBreaksHash,\n          fieldsValues[0],\n          featureIndex,\n        );\n    }\n\n    if (defined(featureHashFn)) {\n      const firstFieldValues = fieldsValues[0];\n      for (\n        let featureIndex = 0;\n        featureIndex < firstFieldValues.length;\n        featureIndex++\n      ) {\n        const featureSymbology = featureHashFn(featureIndex);\n        if (defined(featureSymbology)) {\n          symbology[featureIndex] = featureSymbology;\n        }\n      }\n    }\n  }\n\n  return symbology;\n};\n\nexport default I3SSymbology;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}