{"ast":null,"code":"import { alphaNumericAndMarksRe, letterRe, digitRe } from '../regex-lib';\nimport { tldRegex } from './tld-regex';\n/**\n * A regular expression that is simply the character class of the characters\n * that may be used in a domain name, minus the '-' or '.'\n */\nexport var domainNameCharRegex = alphaNumericAndMarksRe;\n/**\n * The set of characters that will start a URL suffix (i.e. the path, query, and\n * hash part of the URL)\n */\nexport var urlSuffixStartCharsRe = /[\\/?#]/;\n/**\n * The set of characters that are allowed in the URL suffix (i.e. the path,\n * query, and hash part of the URL) which may also form the ending character of\n * the URL.\n *\n * The {@link #urlSuffixNotAllowedAsLastCharRe} are additional allowed URL\n * suffix characters, but (generally) should not be the last character of a URL.\n */\nexport var urlSuffixAllowedSpecialCharsRe = /[-+&@#/%=~_()|'$*\\[\\]{}\\u2713]/;\n/**\n * URL suffix characters (i.e. path, query, and has part of the URL) that are\n * not allowed as the *last character* in the URL suffix as they would normally\n * form the end of a sentence.\n *\n * The {@link #urlSuffixAllowedSpecialCharsRe} contains additional allowed URL\n * suffix characters which are allowed as the last character.\n */\nexport var urlSuffixNotAllowedAsLastCharRe = /[?!:,.;^]/;\n/**\n * Regular expression to match an http:// or https:// scheme.\n */\nexport var httpSchemeRe = /https?:\\/\\//i;\n/**\n * Regular expression to match an http:// or https:// scheme as the prefix of\n * a string.\n */\nexport var httpSchemePrefixRe = new RegExp('^' + httpSchemeRe.source, 'i');\nexport var urlSuffixedCharsNotAllowedAtEndRe = new RegExp(urlSuffixNotAllowedAsLastCharRe.source + '$');\n/**\n * A regular expression used to determine the schemes we should not autolink\n */\nexport var invalidSchemeRe = /^(javascript|vbscript):/i;\n// A regular expression used to determine if the URL is a scheme match (such as\n// 'http://google.com', and as opposed to a \"TLD match\"). This regular\n// expression is used to parse out the host along with if the URL has an\n// authority component (i.e. '//')\n//\n// Capturing groups:\n//    1. '//' if the URL has an authority component, empty string otherwise\n//    2. The host (if one exists). Ex: 'google.com'\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport var schemeUrlRe = /^[A-Za-z][-.+A-Za-z0-9]*:(\\/\\/)?([^:/]*)/;\n// A regular expression used to determine if the URL is a TLD match (such as\n// 'google.com', and as opposed to a \"scheme match\"). This regular\n// expression is used to help parse out the TLD (top-level domain) of the host.\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport var tldUrlHostRe = /^(?:\\/\\/)?([^/#?:]+)/; // optionally prefixed with protocol-relative '//' chars\n/**\n * Determines if the given character may start a scheme (ex: 'http').\n */\nexport function isSchemeStartChar(char) {\n  return letterRe.test(char);\n}\n/**\n * Determines if the given character is a valid character in a scheme (such as\n * 'http' or 'ssh+git'), but only after the start char (which is handled by\n * {@link isSchemeStartChar}.\n */\nexport function isSchemeChar(char) {\n  return letterRe.test(char) || digitRe.test(char) || char === '+' || char === '-' || char === '.';\n}\n/**\n * Determines if the character can begin a domain label, which must be an\n * alphanumeric character and not an underscore or dash.\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelStartChar(char) {\n  return alphaNumericAndMarksRe.test(char);\n}\n/**\n * Determines if the character is part of a domain label (but not a domain label\n * start character).\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelChar(char) {\n  return char === '_' || isDomainLabelStartChar(char);\n}\n/**\n * Determines if the character is a path character (\"pchar\") as defined by\n * https://tools.ietf.org/html/rfc3986#appendix-A\n *\n *     pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *\n *     unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *     pct-encoded   = \"%\" HEXDIG HEXDIG\n *     sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n *\n * Note that this implementation doesn't follow the spec exactly, but rather\n * follows URL path characters found out in the wild (spec might be out of date?)\n */\nexport function isPathChar(char) {\n  return alphaNumericAndMarksRe.test(char) || urlSuffixAllowedSpecialCharsRe.test(char) || urlSuffixNotAllowedAsLastCharRe.test(char);\n}\n/**\n * Determines if the character given may begin the \"URL Suffix\" section of a\n * URI (i.e. the path, query, or hash section). These are the '/', '?' and '#'\n * characters.\n *\n * See https://tools.ietf.org/html/rfc3986#appendix-A\n */\nexport function isUrlSuffixStartChar(char) {\n  return urlSuffixStartCharsRe.test(char);\n}\n/**\n * Determines if the TLD read in the host is a known TLD (Top-Level Domain).\n *\n * Example: 'com' would be a known TLD (for a host of 'google.com'), but\n * 'local' would not (for a domain name of 'my-computer.local').\n */\nexport function isKnownTld(tld) {\n  return tldRegex.test(tld.toLowerCase()); // make sure the tld is lowercase for the regex\n}\n/**\n * Determines if the given `url` is a valid scheme-prefixed URL.\n */\nexport function isValidSchemeUrl(url) {\n  // If the scheme is 'javascript:' or 'vbscript:', these link\n  // types can be dangerous. Don't link them.\n  if (invalidSchemeRe.test(url)) {\n    return false;\n  }\n  var schemeMatch = url.match(schemeUrlRe);\n  if (!schemeMatch) {\n    return false;\n  }\n  var isAuthorityMatch = !!schemeMatch[1];\n  var host = schemeMatch[2];\n  if (isAuthorityMatch) {\n    // Any match that has an authority ('//' chars) after the scheme is\n    // valid, such as 'http://anything'\n    return true;\n  }\n  // If there's no authority ('//' chars), check that we have a hostname\n  // that looks valid.\n  //\n  // The host must contain at least one '.' char and have a domain label\n  // with at least one letter to be considered valid.\n  //\n  // Accept:\n  //   - git:domain.com (scheme followed by a host\n  // Do not accept:\n  //   - git:something ('something' doesn't look like a host)\n  //   - version:1.0   ('1.0' doesn't look like a host)\n  if (host.indexOf('.') === -1 || !letterRe.test(host)) {\n    return false;\n  }\n  return true;\n}\n/**\n * Determines if the given `url` is a match with a valid TLD.\n */\nexport function isValidTldMatch(url) {\n  // TLD URL such as 'google.com', we need to confirm that we have a valid\n  // top-level domain\n  var tldUrlHostMatch = url.match(tldUrlHostRe);\n  if (!tldUrlHostMatch) {\n    // At this point, if the URL didn't match our TLD re, it must be invalid\n    // (highly unlikely to happen, but just in case)\n    return false;\n  }\n  var host = tldUrlHostMatch[0];\n  var hostLabels = host.split('.');\n  if (hostLabels.length < 2) {\n    // 0 or 1 host label, there's no TLD. Ex: 'localhost'\n    return false;\n  }\n  var tld = hostLabels[hostLabels.length - 1];\n  if (!isKnownTld(tld)) {\n    return false;\n  }\n  // TODO: Implement these conditions for TLD matcher:\n  // (\n  //     this.longestDomainLabelLength <= 63 &&\n  //     this.domainNameLength <= 255\n  // );\n  return true;\n}\n// Regular expression to confirm a valid IPv4 address (ex: '192.168.0.1')\nvar ipV4Re = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n// Regular expression used to split the IPv4 address itself from any port/path/query/hash\nvar ipV4PartRe = /[:/?#]/;\n/**\n * Determines if the given URL is a valid IPv4-prefixed URL.\n */\nexport function isValidIpV4Address(url) {\n  // Grab just the IP address\n  var ipV4Part = url.split(ipV4PartRe, 1)[0]; // only 1 result needed\n  return ipV4Re.test(ipV4Part);\n}","map":{"version":3,"names":["alphaNumericAndMarksRe","letterRe","digitRe","tldRegex","domainNameCharRegex","urlSuffixStartCharsRe","urlSuffixAllowedSpecialCharsRe","urlSuffixNotAllowedAsLastCharRe","httpSchemeRe","httpSchemePrefixRe","RegExp","source","urlSuffixedCharsNotAllowedAtEndRe","invalidSchemeRe","schemeUrlRe","tldUrlHostRe","isSchemeStartChar","char","test","isSchemeChar","isDomainLabelStartChar","isDomainLabelChar","isPathChar","isUrlSuffixStartChar","isKnownTld","tld","toLowerCase","isValidSchemeUrl","url","schemeMatch","match","isAuthorityMatch","host","indexOf","isValidTldMatch","tldUrlHostMatch","hostLabels","split","length","ipV4Re","ipV4PartRe","isValidIpV4Address","ipV4Part"],"sources":["../../../src/parser/uri-utils.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}