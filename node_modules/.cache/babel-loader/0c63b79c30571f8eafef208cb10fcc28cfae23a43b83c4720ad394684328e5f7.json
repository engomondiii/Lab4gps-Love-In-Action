{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\n/**\n * A tile bounding volume specified as a sphere.\n * @alias TileBoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {number} [radius=0.0] The radius of the bounding sphere.\n *\n * @private\n */\nfunction TileBoundingSphere(center, radius) {\n  if (radius === 0) {\n    radius = CesiumMath.EPSILON7;\n  }\n  this._boundingSphere = new BoundingSphere(center, radius);\n}\nObject.defineProperties(TileBoundingSphere.prototype, {\n  /**\n   * The center of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  center: {\n    get: function () {\n      return this._boundingSphere.center;\n    }\n  },\n  /**\n   * The radius of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  radius: {\n    get: function () {\n      return this._boundingSphere.radius;\n    }\n  },\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\n\n/**\n * Computes the distance between this bounding sphere and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {number} The distance between the camera and the bounding sphere in meters. Returns 0 if the camera is inside the bounding volume.\n *\n */\nTileBoundingSphere.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  const boundingSphere = this._boundingSphere;\n  return Math.max(0.0, Cartesian3.distance(boundingSphere.center, frameState.camera.positionWC) - boundingSphere.radius);\n};\n\n/**\n * Determines which side of a plane this sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nTileBoundingSphere.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return BoundingSphere.intersectPlane(this._boundingSphere, plane);\n};\n\n/**\n * Update the bounding sphere after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the bounding sphere.\n * @param {number} radius The radius of the bounding sphere.\n */\nTileBoundingSphere.prototype.update = function (center, radius) {\n  Cartesian3.clone(center, this._boundingSphere.center);\n  this._boundingSphere.radius = radius;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the sphere.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingSphere.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n  const geometry = new SphereOutlineGeometry({\n    radius: this.radius\n  });\n  const modelMatrix = Matrix4.fromTranslation(this.center, new Matrix4.clone(Matrix4.IDENTITY));\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\nexport default TileBoundingSphere;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","ColorGeometryInstanceAttribute","GeometryInstance","CesiumMath","Matrix4","SphereOutlineGeometry","PerInstanceColorAppearance","Primitive","TileBoundingSphere","center","radius","EPSILON7","_boundingSphere","Object","defineProperties","prototype","get","boundingVolume","boundingSphere","distanceToCamera","frameState","defined","Math","max","distance","camera","positionWC","intersectPlane","plane","update","clone","createDebugVolume","color","geometry","modelMatrix","fromTranslation","IDENTITY","instance","id","attributes","fromColor","geometryInstances","appearance","translucent","flat","asynchronous"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TileBoundingSphere.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\n/**\n * A tile bounding volume specified as a sphere.\n * @alias TileBoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {number} [radius=0.0] The radius of the bounding sphere.\n *\n * @private\n */\nfunction TileBoundingSphere(center, radius) {\n  if (radius === 0) {\n    radius = CesiumMath.EPSILON7;\n  }\n  this._boundingSphere = new BoundingSphere(center, radius);\n}\n\nObject.defineProperties(TileBoundingSphere.prototype, {\n  /**\n   * The center of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  center: {\n    get: function () {\n      return this._boundingSphere.center;\n    },\n  },\n\n  /**\n   * The radius of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  radius: {\n    get: function () {\n      return this._boundingSphere.radius;\n    },\n  },\n\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\n/**\n * Computes the distance between this bounding sphere and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {number} The distance between the camera and the bounding sphere in meters. Returns 0 if the camera is inside the bounding volume.\n *\n */\nTileBoundingSphere.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  const boundingSphere = this._boundingSphere;\n  return Math.max(\n    0.0,\n    Cartesian3.distance(boundingSphere.center, frameState.camera.positionWC) -\n      boundingSphere.radius,\n  );\n};\n\n/**\n * Determines which side of a plane this sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nTileBoundingSphere.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return BoundingSphere.intersectPlane(this._boundingSphere, plane);\n};\n\n/**\n * Update the bounding sphere after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the bounding sphere.\n * @param {number} radius The radius of the bounding sphere.\n */\nTileBoundingSphere.prototype.update = function (center, radius) {\n  Cartesian3.clone(center, this._boundingSphere.center);\n  this._boundingSphere.radius = radius;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the sphere.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingSphere.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n  const geometry = new SphereOutlineGeometry({\n    radius: this.radius,\n  });\n  const modelMatrix = Matrix4.fromTranslation(\n    this.center,\n    new Matrix4.clone(Matrix4.IDENTITY),\n  );\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileBoundingSphere;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}