{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport ManagedArray from \"../Core/ManagedArray.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport Cesium3DTilesetTraversal from \"./Cesium3DTilesetTraversal.js\";\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * Allows for skipping levels of the tree and rendering children and parent tiles simultaneously.\n *\n * @alias Cesium3DTilesetSkipTraversal\n * @constructor\n *\n * @private\n */\nfunction Cesium3DTilesetSkipTraversal() {}\nconst traversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\nconst descendantTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\nconst selectionTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n  ancestorStack: new ManagedArray(),\n  ancestorStackMaximumLength: 0\n};\nconst descendantSelectionDepth = 2;\n\n/**\n * Traverses a {@link Cesium3DTileset} to determine which tiles to load and render.\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n */\nCesium3DTilesetSkipTraversal.selectTiles = function (tileset, frameState) {\n  tileset._requestedTiles.length = 0;\n  if (tileset.debugFreezeFrame) {\n    return;\n  }\n  tileset._selectedTiles.length = 0;\n  tileset._selectedTilesToStyle.length = 0;\n  tileset._emptyTiles.length = 0;\n  tileset.hasMixedContent = false;\n  const root = tileset.root;\n  Cesium3DTilesetTraversal.updateTile(root, frameState);\n  if (!root.isVisible) {\n    return;\n  }\n  if (root.getScreenSpaceError(frameState, true) <= tileset.memoryAdjustedScreenSpaceError) {\n    return;\n  }\n  executeTraversal(root, frameState);\n  traverseAndSelect(root, frameState);\n  traversal.stack.trim(traversal.stackMaximumLength);\n  descendantTraversal.stack.trim(descendantTraversal.stackMaximumLength);\n  selectionTraversal.stack.trim(selectionTraversal.stackMaximumLength);\n  selectionTraversal.ancestorStack.trim(selectionTraversal.ancestorStackMaximumLength);\n\n  // Update the priority for any requests found during traversal\n  // Update after traversal so that min and max values can be used to normalize priority values\n  const requestedTiles = tileset._requestedTiles;\n  for (let i = 0; i < requestedTiles.length; ++i) {\n    requestedTiles[i].updatePriority();\n  }\n};\n\n/**\n * Mark descendant tiles for rendering, and update as needed\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction selectDescendants(root, frameState) {\n  const {\n    updateTile,\n    touchTile,\n    selectTile\n  } = Cesium3DTilesetTraversal;\n  const stack = descendantTraversal.stack;\n  stack.push(root);\n  while (stack.length > 0) {\n    descendantTraversal.stackMaximumLength = Math.max(descendantTraversal.stackMaximumLength, stack.length);\n    const tile = stack.pop();\n    const children = tile.children;\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n      if (child.isVisible) {\n        if (child.contentAvailable) {\n          updateTile(child, frameState);\n          touchTile(child, frameState);\n          selectTile(child, frameState);\n        } else if (child._depth - root._depth < descendantSelectionDepth) {\n          // Continue traversing, but not too far\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Mark a tile as selected if it has content available.\n * If its content is not available, and we are skipping levels of detail,\n * select an ancestor or descendant tile instead\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n */\nfunction selectDesiredTile(tile, frameState) {\n  // If this tile is not loaded attempt to select its ancestor instead\n  const loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;\n  if (defined(loadedTile)) {\n    // Tiles will actually be selected in traverseAndSelect\n    loadedTile._shouldSelect = true;\n  } else {\n    // If no ancestors are ready traverse down and select tiles to minimize empty regions.\n    // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles are not necessarily loaded before zooming out.\n    selectDescendants(tile, frameState);\n  }\n}\n\n/**\n * Update links to the ancestor tiles that have content\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n */\nfunction updateTileAncestorContentLinks(tile, frameState) {\n  tile._ancestorWithContent = undefined;\n  tile._ancestorWithContentAvailable = undefined;\n  const {\n    parent\n  } = tile;\n  if (!defined(parent)) {\n    return;\n  }\n  const parentHasContent = !parent.hasUnloadedRenderableContent || parent._requestedFrame === frameState.frameNumber;\n\n  // ancestorWithContent is an ancestor that has content or has the potential to have\n  // content. Used in conjunction with tileset.skipLevels to know when to skip a tile.\n  tile._ancestorWithContent = parentHasContent ? parent : parent._ancestorWithContent;\n\n  // ancestorWithContentAvailable is an ancestor that is rendered if a desired tile is not loaded\n  tile._ancestorWithContentAvailable = parent.contentAvailable ? parent : parent._ancestorWithContentAvailable;\n}\n\n/**\n * Determine if a tile has reached the limit of level of detail skipping.\n * If so, it should _not_ be skipped: it should be loaded and rendered\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {Cesium3DTile} tile\n * @returns {boolean} true if this tile should not be skipped\n */\nfunction reachedSkippingThreshold(tileset, tile) {\n  const ancestor = tile._ancestorWithContent;\n  return !tileset.immediatelyLoadDesiredLevelOfDetail && (tile._priorityProgressiveResolutionScreenSpaceErrorLeaf || defined(ancestor) && tile._screenSpaceError < ancestor._screenSpaceError / tileset.skipScreenSpaceErrorFactor && tile._depth > ancestor._depth + tileset.skipLevels);\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {ManagedArray} stack\n * @param {FrameState} frameState\n * @returns {boolean}\n */\nfunction updateAndPushChildren(tile, stack, frameState) {\n  const {\n    tileset,\n    children\n  } = tile;\n  const {\n    updateTile,\n    loadTile,\n    touchTile\n  } = Cesium3DTilesetTraversal;\n  for (let i = 0; i < children.length; ++i) {\n    updateTile(children[i], frameState);\n  }\n\n  // Sort by distance to take advantage of early Z and reduce artifacts\n  children.sort(Cesium3DTilesetTraversal.sortChildrenByDistanceToCamera);\n  let anyChildrenVisible = false;\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    if (child.isVisible) {\n      stack.push(child);\n      anyChildrenVisible = true;\n    } else if (tileset.loadSiblings) {\n      loadTile(child, frameState);\n      touchTile(child, frameState);\n    }\n  }\n  return anyChildrenVisible;\n}\n\n/**\n * Determine if a tile is part of the base traversal.\n * If not, this tile could be considered for level of detail skipping\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {number} baseScreenSpaceError\n * @returns {boolean}\n */\nfunction inBaseTraversal(tile, baseScreenSpaceError) {\n  const {\n    tileset\n  } = tile;\n  if (tileset.immediatelyLoadDesiredLevelOfDetail) {\n    return false;\n  }\n  if (!defined(tile._ancestorWithContent)) {\n    // Include root or near-root tiles in the base traversal so there is something to select up to\n    return true;\n  }\n  if (tile._screenSpaceError === 0.0) {\n    // If a leaf, use parent's SSE\n    return tile.parent._screenSpaceError > baseScreenSpaceError;\n  }\n  return tile._screenSpaceError > baseScreenSpaceError;\n}\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n * and rendering children and parent tiles simultaneously.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction executeTraversal(root, frameState) {\n  const {\n    tileset\n  } = root;\n  const baseScreenSpaceError = tileset.immediatelyLoadDesiredLevelOfDetail ? Number.MAX_VALUE : Math.max(tileset.baseScreenSpaceError, tileset.memoryAdjustedScreenSpaceError);\n  const {\n    canTraverse,\n    loadTile,\n    visitTile,\n    touchTile\n  } = Cesium3DTilesetTraversal;\n  const stack = traversal.stack;\n  stack.push(root);\n  while (stack.length > 0) {\n    traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);\n    const tile = stack.pop();\n    updateTileAncestorContentLinks(tile, frameState);\n    const parent = tile.parent;\n    const parentRefines = !defined(parent) || parent._refines;\n    tile._refines = canTraverse(tile) ? updateAndPushChildren(tile, stack, frameState) && parentRefines : false;\n    const stoppedRefining = !tile._refines && parentRefines;\n    if (!tile.hasRenderableContent) {\n      // Add empty tile just to show its debug bounding volume\n      // If the tile has tileset content load the external tileset\n      // If the tile cannot refine further select its nearest loaded ancestor\n      tileset._emptyTiles.push(tile);\n      loadTile(tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tile, frameState);\n      }\n    } else if (tile.refine === Cesium3DTileRefine.ADD) {\n      // Additive tiles are always loaded and selected\n      selectDesiredTile(tile, frameState);\n      loadTile(tile, frameState);\n    } else if (tile.refine === Cesium3DTileRefine.REPLACE) {\n      if (inBaseTraversal(tile, baseScreenSpaceError)) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        loadTile(tile, frameState);\n        if (stoppedRefining) {\n          selectDesiredTile(tile, frameState);\n        }\n      } else if (stoppedRefining) {\n        // In skip traversal, load and select tiles that can't refine further\n        selectDesiredTile(tile, frameState);\n        loadTile(tile, frameState);\n      } else if (reachedSkippingThreshold(tileset, tile)) {\n        // In skip traversal, load tiles that aren't skipped\n        loadTile(tile, frameState);\n      }\n    }\n    visitTile(tile, frameState);\n    touchTile(tile, frameState);\n  }\n}\n\n/**\n * Traverse the tree and check if their selected frame is the current frame. If so, add it to a selection queue.\n * This is a preorder traversal so children tiles are selected before ancestor tiles.\n *\n * The reason for the preorder traversal is so that tiles can easily be marked with their\n * selection depth. A tile's _selectionDepth is its depth in the tree where all non-selected tiles are removed.\n * This property is important for use in the stencil test because we want to render deeper tiles on top of their\n * ancestors. If a tileset is very deep, the depth is unlikely to fit into the stencil buffer.\n *\n * We want to select children before their ancestors because there is no guarantee on the relationship between\n * the children's z-depth and the ancestor's z-depth. We cannot rely on Z because we want the child to appear on top\n * of ancestor regardless of true depth. The stencil tests used require children to be drawn first.\n *\n * NOTE: 3D Tiles uses 3 bits from the stencil buffer meaning this will not work when there is a chain of\n * selected tiles that is deeper than 7. This is not very likely.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction traverseAndSelect(root, frameState) {\n  const {\n    selectTile,\n    canTraverse\n  } = Cesium3DTilesetTraversal;\n  const {\n    stack,\n    ancestorStack\n  } = selectionTraversal;\n  let lastAncestor;\n  stack.push(root);\n  while (stack.length > 0 || ancestorStack.length > 0) {\n    selectionTraversal.stackMaximumLength = Math.max(selectionTraversal.stackMaximumLength, stack.length);\n    selectionTraversal.ancestorStackMaximumLength = Math.max(selectionTraversal.ancestorStackMaximumLength, ancestorStack.length);\n    if (ancestorStack.length > 0) {\n      const waitingTile = ancestorStack.peek();\n      if (waitingTile._stackLength === stack.length) {\n        ancestorStack.pop();\n        if (waitingTile !== lastAncestor) {\n          waitingTile._finalResolution = false;\n        }\n        selectTile(waitingTile, frameState);\n        continue;\n      }\n    }\n    const tile = stack.pop();\n    if (!defined(tile)) {\n      // stack is empty but ancestorStack isn't\n      continue;\n    }\n    const traverse = canTraverse(tile);\n    if (tile._shouldSelect) {\n      if (tile.refine === Cesium3DTileRefine.ADD) {\n        selectTile(tile, frameState);\n      } else {\n        tile._selectionDepth = ancestorStack.length;\n        if (tile._selectionDepth > 0) {\n          tile.tileset.hasMixedContent = true;\n        }\n        lastAncestor = tile;\n        if (!traverse) {\n          selectTile(tile, frameState);\n          continue;\n        }\n        ancestorStack.push(tile);\n        tile._stackLength = stack.length;\n      }\n    }\n    if (traverse) {\n      const children = tile.children;\n      for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        if (child.isVisible) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\nexport default Cesium3DTilesetSkipTraversal;","map":{"version":3,"names":["defined","ManagedArray","Cesium3DTileRefine","Cesium3DTilesetTraversal","Cesium3DTilesetSkipTraversal","traversal","stack","stackMaximumLength","descendantTraversal","selectionTraversal","ancestorStack","ancestorStackMaximumLength","descendantSelectionDepth","selectTiles","tileset","frameState","_requestedTiles","length","debugFreezeFrame","_selectedTiles","_selectedTilesToStyle","_emptyTiles","hasMixedContent","root","updateTile","isVisible","getScreenSpaceError","memoryAdjustedScreenSpaceError","executeTraversal","traverseAndSelect","trim","requestedTiles","i","updatePriority","selectDescendants","touchTile","selectTile","push","Math","max","tile","pop","children","child","contentAvailable","_depth","selectDesiredTile","loadedTile","_ancestorWithContentAvailable","_shouldSelect","updateTileAncestorContentLinks","_ancestorWithContent","undefined","parent","parentHasContent","hasUnloadedRenderableContent","_requestedFrame","frameNumber","reachedSkippingThreshold","ancestor","immediatelyLoadDesiredLevelOfDetail","_priorityProgressiveResolutionScreenSpaceErrorLeaf","_screenSpaceError","skipScreenSpaceErrorFactor","skipLevels","updateAndPushChildren","loadTile","sort","sortChildrenByDistanceToCamera","anyChildrenVisible","loadSiblings","inBaseTraversal","baseScreenSpaceError","Number","MAX_VALUE","canTraverse","visitTile","parentRefines","_refines","stoppedRefining","hasRenderableContent","refine","ADD","REPLACE","lastAncestor","waitingTile","peek","_stackLength","_finalResolution","traverse","_selectionDepth"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Cesium3DTilesetSkipTraversal.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport ManagedArray from \"../Core/ManagedArray.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport Cesium3DTilesetTraversal from \"./Cesium3DTilesetTraversal.js\";\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * Allows for skipping levels of the tree and rendering children and parent tiles simultaneously.\n *\n * @alias Cesium3DTilesetSkipTraversal\n * @constructor\n *\n * @private\n */\nfunction Cesium3DTilesetSkipTraversal() {}\n\nconst traversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\nconst descendantTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\nconst selectionTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n  ancestorStack: new ManagedArray(),\n  ancestorStackMaximumLength: 0,\n};\n\nconst descendantSelectionDepth = 2;\n\n/**\n * Traverses a {@link Cesium3DTileset} to determine which tiles to load and render.\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n */\nCesium3DTilesetSkipTraversal.selectTiles = function (tileset, frameState) {\n  tileset._requestedTiles.length = 0;\n\n  if (tileset.debugFreezeFrame) {\n    return;\n  }\n\n  tileset._selectedTiles.length = 0;\n  tileset._selectedTilesToStyle.length = 0;\n  tileset._emptyTiles.length = 0;\n  tileset.hasMixedContent = false;\n\n  const root = tileset.root;\n  Cesium3DTilesetTraversal.updateTile(root, frameState);\n\n  if (!root.isVisible) {\n    return;\n  }\n\n  if (\n    root.getScreenSpaceError(frameState, true) <=\n    tileset.memoryAdjustedScreenSpaceError\n  ) {\n    return;\n  }\n\n  executeTraversal(root, frameState);\n  traverseAndSelect(root, frameState);\n\n  traversal.stack.trim(traversal.stackMaximumLength);\n  descendantTraversal.stack.trim(descendantTraversal.stackMaximumLength);\n  selectionTraversal.stack.trim(selectionTraversal.stackMaximumLength);\n  selectionTraversal.ancestorStack.trim(\n    selectionTraversal.ancestorStackMaximumLength,\n  );\n\n  // Update the priority for any requests found during traversal\n  // Update after traversal so that min and max values can be used to normalize priority values\n  const requestedTiles = tileset._requestedTiles;\n  for (let i = 0; i < requestedTiles.length; ++i) {\n    requestedTiles[i].updatePriority();\n  }\n};\n\n/**\n * Mark descendant tiles for rendering, and update as needed\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction selectDescendants(root, frameState) {\n  const { updateTile, touchTile, selectTile } = Cesium3DTilesetTraversal;\n  const stack = descendantTraversal.stack;\n  stack.push(root);\n  while (stack.length > 0) {\n    descendantTraversal.stackMaximumLength = Math.max(\n      descendantTraversal.stackMaximumLength,\n      stack.length,\n    );\n    const tile = stack.pop();\n    const children = tile.children;\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n      if (child.isVisible) {\n        if (child.contentAvailable) {\n          updateTile(child, frameState);\n          touchTile(child, frameState);\n          selectTile(child, frameState);\n        } else if (child._depth - root._depth < descendantSelectionDepth) {\n          // Continue traversing, but not too far\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Mark a tile as selected if it has content available.\n * If its content is not available, and we are skipping levels of detail,\n * select an ancestor or descendant tile instead\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n */\nfunction selectDesiredTile(tile, frameState) {\n  // If this tile is not loaded attempt to select its ancestor instead\n  const loadedTile = tile.contentAvailable\n    ? tile\n    : tile._ancestorWithContentAvailable;\n  if (defined(loadedTile)) {\n    // Tiles will actually be selected in traverseAndSelect\n    loadedTile._shouldSelect = true;\n  } else {\n    // If no ancestors are ready traverse down and select tiles to minimize empty regions.\n    // This happens often for immediatelyLoadDesiredLevelOfDetail where parent tiles are not necessarily loaded before zooming out.\n    selectDescendants(tile, frameState);\n  }\n}\n\n/**\n * Update links to the ancestor tiles that have content\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n */\nfunction updateTileAncestorContentLinks(tile, frameState) {\n  tile._ancestorWithContent = undefined;\n  tile._ancestorWithContentAvailable = undefined;\n\n  const { parent } = tile;\n  if (!defined(parent)) {\n    return;\n  }\n  const parentHasContent =\n    !parent.hasUnloadedRenderableContent ||\n    parent._requestedFrame === frameState.frameNumber;\n\n  // ancestorWithContent is an ancestor that has content or has the potential to have\n  // content. Used in conjunction with tileset.skipLevels to know when to skip a tile.\n  tile._ancestorWithContent = parentHasContent\n    ? parent\n    : parent._ancestorWithContent;\n\n  // ancestorWithContentAvailable is an ancestor that is rendered if a desired tile is not loaded\n  tile._ancestorWithContentAvailable = parent.contentAvailable\n    ? parent\n    : parent._ancestorWithContentAvailable;\n}\n\n/**\n * Determine if a tile has reached the limit of level of detail skipping.\n * If so, it should _not_ be skipped: it should be loaded and rendered\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {Cesium3DTile} tile\n * @returns {boolean} true if this tile should not be skipped\n */\nfunction reachedSkippingThreshold(tileset, tile) {\n  const ancestor = tile._ancestorWithContent;\n  return (\n    !tileset.immediatelyLoadDesiredLevelOfDetail &&\n    (tile._priorityProgressiveResolutionScreenSpaceErrorLeaf ||\n      (defined(ancestor) &&\n        tile._screenSpaceError <\n          ancestor._screenSpaceError / tileset.skipScreenSpaceErrorFactor &&\n        tile._depth > ancestor._depth + tileset.skipLevels))\n  );\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {ManagedArray} stack\n * @param {FrameState} frameState\n * @returns {boolean}\n */\nfunction updateAndPushChildren(tile, stack, frameState) {\n  const { tileset, children } = tile;\n  const { updateTile, loadTile, touchTile } = Cesium3DTilesetTraversal;\n\n  for (let i = 0; i < children.length; ++i) {\n    updateTile(children[i], frameState);\n  }\n\n  // Sort by distance to take advantage of early Z and reduce artifacts\n  children.sort(Cesium3DTilesetTraversal.sortChildrenByDistanceToCamera);\n\n  let anyChildrenVisible = false;\n\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    if (child.isVisible) {\n      stack.push(child);\n      anyChildrenVisible = true;\n    } else if (tileset.loadSiblings) {\n      loadTile(child, frameState);\n      touchTile(child, frameState);\n    }\n  }\n\n  return anyChildrenVisible;\n}\n\n/**\n * Determine if a tile is part of the base traversal.\n * If not, this tile could be considered for level of detail skipping\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {number} baseScreenSpaceError\n * @returns {boolean}\n */\nfunction inBaseTraversal(tile, baseScreenSpaceError) {\n  const { tileset } = tile;\n  if (tileset.immediatelyLoadDesiredLevelOfDetail) {\n    return false;\n  }\n  if (!defined(tile._ancestorWithContent)) {\n    // Include root or near-root tiles in the base traversal so there is something to select up to\n    return true;\n  }\n  if (tile._screenSpaceError === 0.0) {\n    // If a leaf, use parent's SSE\n    return tile.parent._screenSpaceError > baseScreenSpaceError;\n  }\n  return tile._screenSpaceError > baseScreenSpaceError;\n}\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n * and rendering children and parent tiles simultaneously.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction executeTraversal(root, frameState) {\n  const { tileset } = root;\n  const baseScreenSpaceError = tileset.immediatelyLoadDesiredLevelOfDetail\n    ? Number.MAX_VALUE\n    : Math.max(\n        tileset.baseScreenSpaceError,\n        tileset.memoryAdjustedScreenSpaceError,\n      );\n  const { canTraverse, loadTile, visitTile, touchTile } =\n    Cesium3DTilesetTraversal;\n  const stack = traversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    traversal.stackMaximumLength = Math.max(\n      traversal.stackMaximumLength,\n      stack.length,\n    );\n\n    const tile = stack.pop();\n\n    updateTileAncestorContentLinks(tile, frameState);\n    const parent = tile.parent;\n    const parentRefines = !defined(parent) || parent._refines;\n\n    tile._refines = canTraverse(tile)\n      ? updateAndPushChildren(tile, stack, frameState) && parentRefines\n      : false;\n\n    const stoppedRefining = !tile._refines && parentRefines;\n\n    if (!tile.hasRenderableContent) {\n      // Add empty tile just to show its debug bounding volume\n      // If the tile has tileset content load the external tileset\n      // If the tile cannot refine further select its nearest loaded ancestor\n      tileset._emptyTiles.push(tile);\n      loadTile(tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tile, frameState);\n      }\n    } else if (tile.refine === Cesium3DTileRefine.ADD) {\n      // Additive tiles are always loaded and selected\n      selectDesiredTile(tile, frameState);\n      loadTile(tile, frameState);\n    } else if (tile.refine === Cesium3DTileRefine.REPLACE) {\n      if (inBaseTraversal(tile, baseScreenSpaceError)) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        loadTile(tile, frameState);\n        if (stoppedRefining) {\n          selectDesiredTile(tile, frameState);\n        }\n      } else if (stoppedRefining) {\n        // In skip traversal, load and select tiles that can't refine further\n        selectDesiredTile(tile, frameState);\n        loadTile(tile, frameState);\n      } else if (reachedSkippingThreshold(tileset, tile)) {\n        // In skip traversal, load tiles that aren't skipped\n        loadTile(tile, frameState);\n      }\n    }\n\n    visitTile(tile, frameState);\n    touchTile(tile, frameState);\n  }\n}\n\n/**\n * Traverse the tree and check if their selected frame is the current frame. If so, add it to a selection queue.\n * This is a preorder traversal so children tiles are selected before ancestor tiles.\n *\n * The reason for the preorder traversal is so that tiles can easily be marked with their\n * selection depth. A tile's _selectionDepth is its depth in the tree where all non-selected tiles are removed.\n * This property is important for use in the stencil test because we want to render deeper tiles on top of their\n * ancestors. If a tileset is very deep, the depth is unlikely to fit into the stencil buffer.\n *\n * We want to select children before their ancestors because there is no guarantee on the relationship between\n * the children's z-depth and the ancestor's z-depth. We cannot rely on Z because we want the child to appear on top\n * of ancestor regardless of true depth. The stencil tests used require children to be drawn first.\n *\n * NOTE: 3D Tiles uses 3 bits from the stencil buffer meaning this will not work when there is a chain of\n * selected tiles that is deeper than 7. This is not very likely.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction traverseAndSelect(root, frameState) {\n  const { selectTile, canTraverse } = Cesium3DTilesetTraversal;\n  const { stack, ancestorStack } = selectionTraversal;\n  let lastAncestor;\n\n  stack.push(root);\n\n  while (stack.length > 0 || ancestorStack.length > 0) {\n    selectionTraversal.stackMaximumLength = Math.max(\n      selectionTraversal.stackMaximumLength,\n      stack.length,\n    );\n    selectionTraversal.ancestorStackMaximumLength = Math.max(\n      selectionTraversal.ancestorStackMaximumLength,\n      ancestorStack.length,\n    );\n\n    if (ancestorStack.length > 0) {\n      const waitingTile = ancestorStack.peek();\n      if (waitingTile._stackLength === stack.length) {\n        ancestorStack.pop();\n        if (waitingTile !== lastAncestor) {\n          waitingTile._finalResolution = false;\n        }\n        selectTile(waitingTile, frameState);\n        continue;\n      }\n    }\n\n    const tile = stack.pop();\n    if (!defined(tile)) {\n      // stack is empty but ancestorStack isn't\n      continue;\n    }\n\n    const traverse = canTraverse(tile);\n\n    if (tile._shouldSelect) {\n      if (tile.refine === Cesium3DTileRefine.ADD) {\n        selectTile(tile, frameState);\n      } else {\n        tile._selectionDepth = ancestorStack.length;\n        if (tile._selectionDepth > 0) {\n          tile.tileset.hasMixedContent = true;\n        }\n        lastAncestor = tile;\n        if (!traverse) {\n          selectTile(tile, frameState);\n          continue;\n        }\n        ancestorStack.push(tile);\n        tile._stackLength = stack.length;\n      }\n    }\n\n    if (traverse) {\n      const children = tile.children;\n      for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        if (child.isVisible) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n}\n\nexport default Cesium3DTilesetSkipTraversal;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}