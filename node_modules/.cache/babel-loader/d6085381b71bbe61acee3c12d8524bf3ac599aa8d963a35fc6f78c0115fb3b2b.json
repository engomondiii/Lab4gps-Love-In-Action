{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport MersenneTwister from \"mersenne-twister\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport PntsParser from \"./PntsParser.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport Splitter from \"./Splitter.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nconst DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3\n};\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see TimeDynamicPointCloud\n *\n * @private\n */\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer);\n  //>>includeEnd('debug');\n\n  // Hold onto the payload until the render resources are created\n  this._parsedContent = undefined;\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined;\n\n  // These values are used to regenerate the shader when the style changes\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false;\n\n  // Draco\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0;\n\n  // Use per-point normals to hide back-facing points.\n  this.backFaceCulling = false;\n  this._backFaceCulling = false;\n\n  // Whether to enable normal shading\n  this.normalShading = true;\n  this._normalShading = true;\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n  this._mode = undefined;\n  this._ready = false;\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this.time = 0.0; // For styling\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false;\n  // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n  this.clippingPlanesOriginMatrix = undefined;\n  this.attenuation = false;\n  this._attenuation = false;\n\n  // Options for geometric error based attenuation\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n\n  /**\n   * The {@link SplitDirection} to apply to this point cloud.\n   *\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  this.splitDirection = defaultValue(options.splitDirection, SplitDirection.NONE);\n  this._splittingEnabled = false;\n  this._error = undefined;\n  initialize(this, options);\n}\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  color: {\n    get: function () {\n      return Color.clone(this._highlightColor);\n    },\n    set: function (value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    }\n  },\n  boundingSphere: {\n    get: function () {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n      return undefined;\n    },\n    set: function (value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    }\n  }\n});\nfunction initialize(pointCloud, options) {\n  const parsedContent = PntsParser.parse(options.arrayBuffer, options.byteOffset);\n  pointCloud._parsedContent = parsedContent;\n  pointCloud._rtcCenter = parsedContent.rtcCenter;\n  pointCloud._hasNormals = parsedContent.hasNormals;\n  pointCloud._hasColors = parsedContent.hasColors;\n  pointCloud._hasBatchIds = parsedContent.hasBatchIds;\n  pointCloud._isTranslucent = parsedContent.isTranslucent;\n\n  // If points are not batched and there are per-point properties, use the\n  // properties as metadata for styling purposes.\n  if (!parsedContent.hasBatchIds && defined(parsedContent.batchTableBinary)) {\n    parsedContent.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(parsedContent.pointsLength, parsedContent.batchTableJson, parsedContent.batchTableBinary);\n  }\n  if (defined(parsedContent.draco)) {\n    const draco = parsedContent.draco;\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n    draco.dequantizeInShader = pointCloud._dequantizeInShader;\n  }\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    pointCloud._isQuantized = positions.isQuantized;\n    pointCloud._quantizedVolumeScale = positions.quantizedVolumeScale;\n    pointCloud._quantizedVolumeOffset = positions.quantizedVolumeOffset;\n    pointCloud._quantizedRange = positions.quantizedRange;\n  }\n  const normals = parsedContent.normals;\n  if (defined(normals)) {\n    pointCloud._isOctEncoded16P = normals.octEncoded;\n  }\n  const colors = parsedContent.colors;\n  if (defined(colors)) {\n    if (defined(colors.constantColor)) {\n      pointCloud._constantColor = Color.clone(colors.constantColor, pointCloud._constantColor);\n\n      // Constant colors are handled as a uniform rather than a vertex\n      // attribute.\n      pointCloud._hasColors = false;\n    }\n    pointCloud._isRGB565 = colors.isRGB565;\n  }\n\n  // PntsParser parses BATCH_ID as _FEATURE_ID_0 for EXT_mesh_features.\n  // These properties aren't used but rename them to BATCH_ID to avoid\n  // confusion when debugging.\n  const batchIds = parsedContent.batchIds;\n  if (defined(parsedContent.batchIds)) {\n    batchIds.name = \"BATCH_ID\";\n    batchIds.semantic = \"BATCH_ID\";\n    batchIds.setIndex = undefined;\n  }\n  if (parsedContent.hasBatchIds) {\n    pointCloud._batchTableLoaded(parsedContent.batchLength, parsedContent.batchTableJson, parsedContent.batchTableBinary);\n  }\n  pointCloud._pointsLength = parsedContent.pointsLength;\n}\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\n\n// Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n// See https://github.com/CesiumGS/cesium/issues/9730\nlet randomNumberGenerator;\nlet randomValues;\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  const maximumSamplesLength = 20;\n  const pointsLength = positions.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  const min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  const max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  for (let i = 0; i < samplesLength; ++i) {\n    const index = Math.floor(randomValues[i] * pointsLength);\n    const position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n  const boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n  return boundingSphere;\n}\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  const componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n  if (componentDatatype === ComponentDatatype.INT || componentDatatype === ComponentDatatype.UNSIGNED_INT || componentDatatype === ComponentDatatype.DOUBLE) {\n    oneTimeWarning(\"Cast pnts property to floats\", `Point cloud property \"${name}\" will be cast to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.`);\n    return new Float32Array(typedArray);\n  }\n  return typedArray;\n}\nconst scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier = new Cartesian4();\nconst scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nconst scratchColor = new Color();\nconst positionLocation = 0;\nconst colorLocation = 1;\nconst normalLocation = 2;\nconst batchIdLocation = 3;\nconst numberOfAttributes = 4;\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\nfunction createResources(pointCloud, frameState) {\n  const context = frameState.context;\n  const parsedContent = pointCloud._parsedContent;\n  const pointsLength = pointCloud._pointsLength;\n  const positions = parsedContent.positions;\n  const colors = parsedContent.colors;\n  const normals = parsedContent.normals;\n  const batchIds = parsedContent.batchIds;\n  const styleableProperties = parsedContent.styleableProperties;\n  const hasStyleableProperties = defined(styleableProperties);\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncoded16P = pointCloud._isOctEncoded16P;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  const quantizedRange = pointCloud._quantizedRange;\n  const octEncodedRange = pointCloud._octEncodedRange;\n  const isRGB565 = pointCloud._isRGB565;\n  const isTranslucent = pointCloud._isTranslucent;\n  const hasColors = pointCloud._hasColors;\n  const hasNormals = pointCloud._hasNormals;\n  const hasBatchIds = pointCloud._hasBatchIds;\n  let componentsPerAttribute;\n  let componentDatatype;\n  const styleableVertexAttributes = [];\n  const styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n  if (hasStyleableProperties) {\n    let attributeLocation = numberOfAttributes;\n    for (const name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        const property = styleableProperties[name];\n        const typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        const vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW\n        });\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n        const vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0\n        };\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n  const positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions.typedArray,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n  let colorsVertexBuffer;\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors.typedArray,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n  let normalsVertexBuffer;\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals.typedArray,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n  let batchIdsVertexBuffer;\n  if (hasBatchIds) {\n    batchIds.typedArray = prepareVertexAttribute(batchIds.typedArray, \"batchIds\");\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds.typedArray,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n  let attributes = [];\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype = quantizedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0\n  });\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.ZERO, pointCloud._quantizedVolumeScale);\n    } else {\n      pointCloud._boundingSphere = computeApproximateBoundingSphereFromPositions(positions.typedArray);\n    }\n  }\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0\n      });\n    } else {\n      const colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0\n      });\n    }\n  }\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype = octEncodedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0\n    });\n  }\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds.typedArray),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0\n    });\n  }\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n  const vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes\n  });\n  const opaqueRenderState = {\n    depthTest: {\n      enabled: true\n    }\n  };\n  const translucentRenderState = {\n    depthTest: {\n      enabled: true\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND\n  };\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n    translucentRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    translucentRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n  pointCloud._translucentRenderState = RenderState.fromCache(translucentRenderState);\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined,\n    // Updated in createShaders\n    uniformMap: undefined,\n    // Updated in createShaders\n    renderState: isTranslucent ? pointCloud._translucentRenderState : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded()\n  });\n}\nfunction createUniformMap(pointCloud, frameState) {\n  const context = frameState.context;\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  let uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () {\n      const scratch = scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation ? pointCloud.maximumAttenuation : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n      scratch.y = pointCloud.time;\n      if (pointCloud._attenuation) {\n        const frustum = frameState.camera.frustum;\n        let depthMultiplier;\n        // Attenuation is maximumAttenuation in 2D/ortho\n        if (frameState.mode === SceneMode.SCENE2D || frustum instanceof OrthographicFrustum) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier = context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n        }\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n      return scratch;\n    },\n    u_highlightColor: function () {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function () {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      const isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n      const style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n      const clippingPlanesOriginMatrix = defaultValue(pointCloud.clippingPlanesOriginMatrix, pointCloud._modelMatrix);\n      Matrix4.multiply(context.uniformState.view3D, clippingPlanesOriginMatrix, scratchClippingPlanesMatrix);\n      const transform = Matrix4.multiply(scratchClippingPlanesMatrix, clippingPlanes.modelMatrix, scratchClippingPlanesMatrix);\n      return Matrix4.inverseTranspose(transform, scratchInverseTransposeClippingPlanesMatrix);\n    }\n  };\n  Splitter.addUniforms(pointCloud, uniformMap);\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function () {\n        const scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          const scale = Cartesian3.clone(pointCloud._quantizedVolumeScale, scratch);\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      }\n    });\n  }\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\nfunction getStyleablePropertyIds(source, propertyIds) {\n  // Get all the property IDs used by this style\n  const regex = /czm_3dtiles_property_(\\d+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const id = parseInt(matches[1]);\n    if (propertyIds.indexOf(id) === -1) {\n      propertyIds.push(id);\n    }\n    matches = regex.exec(source);\n  }\n}\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  // Get all the builtin property names used by this style, ignoring the function signature\n  source = source.slice(source.indexOf(\"\\n\"));\n  const regex = /czm_3dtiles_builtin_property_(\\w+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const name = matches[1];\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\nfunction getVertexAttribute(vertexArray, index) {\n  const numberOfAttributes = vertexArray.numberOfAttributes;\n  for (let i = 0; i < numberOfAttributes; ++i) {\n    const attribute = vertexArray.getAttribute(i);\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\nconst builtinVariableSubstitutionMap = {\n  POSITION: \"czm_3dtiles_builtin_property_POSITION\",\n  POSITION_ABSOLUTE: \"czm_3dtiles_builtin_property_POSITION_ABSOLUTE\",\n  COLOR: \"czm_3dtiles_builtin_property_COLOR\",\n  NORMAL: \"czm_3dtiles_builtin_property_NORMAL\"\n};\nfunction createShaders(pointCloud, frameState, style) {\n  let i;\n  let name;\n  let attribute;\n  const context = frameState.context;\n  const hasStyle = defined(style);\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncoded16P = pointCloud._isOctEncoded16P;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  const isRGB565 = pointCloud._isRGB565;\n  const isTranslucent = pointCloud._isTranslucent;\n  const hasColors = pointCloud._hasColors;\n  const hasNormals = pointCloud._hasNormals;\n  const hasBatchIds = pointCloud._hasBatchIds;\n  const backFaceCulling = pointCloud._backFaceCulling;\n  const normalShading = pointCloud._normalShading;\n  const vertexArray = pointCloud._drawCommand.vertexArray;\n  const clippingPlanes = pointCloud.clippingPlanes;\n  const attenuation = pointCloud._attenuation;\n  let colorStyleFunction;\n  let showStyleFunction;\n  let pointSizeStyleFunction;\n  let styleTranslucent = isTranslucent;\n  const variableSubstitutionMap = clone(builtinVariableSubstitutionMap);\n  const propertyIdToAttributeMap = {};\n  const styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      variableSubstitutionMap[name] = `czm_3dtiles_property_${attribute.location}`;\n      propertyIdToAttributeMap[attribute.location] = attribute;\n    }\n  }\n  if (hasStyle) {\n    const shaderState = {\n      translucent: false\n    };\n    const parameterList = \"(\" + \"vec3 czm_3dtiles_builtin_property_POSITION, \" + \"vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, \" + \"vec4 czm_3dtiles_builtin_property_COLOR, \" + \"vec3 czm_3dtiles_builtin_property_NORMAL\" + \")\";\n    colorStyleFunction = style.getColorShaderFunction(`getColorFromStyle${parameterList}`, variableSubstitutionMap, shaderState);\n    showStyleFunction = style.getShowShaderFunction(`getShowFromStyle${parameterList}`, variableSubstitutionMap, shaderState);\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(`getPointSizeFromStyle${parameterList}`, variableSubstitutionMap, shaderState);\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n  pointCloud._styleTranslucent = styleTranslucent;\n  const hasColorStyle = defined(colorStyleFunction);\n  const hasShowStyle = defined(showStyleFunction);\n  const hasPointSizeStyle = defined(pointSizeStyleFunction);\n  const hasClippedContent = pointCloud.isClipped;\n\n  // Get the properties in use by the style\n  const styleablePropertyIds = [];\n  const builtinPropertyNames = [];\n  if (hasColorStyle) {\n    getStyleablePropertyIds(colorStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n  }\n  if (hasShowStyle) {\n    getStyleablePropertyIds(showStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n  }\n  if (hasPointSizeStyle) {\n    getStyleablePropertyIds(pointSizeStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n  }\n  const usesColorSemantic = builtinPropertyNames.indexOf(\"COLOR\") >= 0;\n  const usesNormalSemantic = builtinPropertyNames.indexOf(\"NORMAL\") >= 0;\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\"Style references the NORMAL semantic but the point cloud does not have normals\");\n  }\n\n  // Disable vertex attributes that aren't used in the style, enable attributes that are\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      const enabled = styleablePropertyIds.indexOf(attribute.location) >= 0;\n      const vertexAttribute = getVertexAttribute(vertexArray, attribute.location);\n      vertexAttribute.enabled = enabled;\n    }\n  }\n  const usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    const colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n  const usesNormals = hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    const normalVertexAttribute = getVertexAttribute(vertexArray, normalLocation);\n    normalVertexAttribute.enabled = usesNormals;\n  }\n  const attributeLocations = {\n    a_position: positionLocation\n  };\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n  let attributeDeclarations = \"\";\n  const length = styleablePropertyIds.length;\n  for (i = 0; i < length; ++i) {\n    const propertyId = styleablePropertyIds[i];\n    attribute = propertyIdToAttributeMap[propertyId];\n    const componentCount = attribute.componentCount;\n    const attributeName = `czm_3dtiles_property_${propertyId}`;\n    let attributeType;\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = `vec${componentCount}`;\n    }\n    attributeDeclarations += `in ${attributeType} ${attributeName}; \\n`;\n    attributeLocations[attributeName] = attribute.location;\n  }\n  createUniformMap(pointCloud, frameState);\n  let vs = \"in vec3 a_position; \\n\" + \"out vec4 v_color; \\n\" + \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" + \"uniform vec4 u_constantColor; \\n\" + \"uniform vec4 u_highlightColor; \\n\";\n\n  // The time variable is named differently for compatibility with custom\n  // shaders in Model.\n  vs += \"float u_pointSize; \\n\" + \"float tiles3d_tileset_time; \\n\";\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n  vs += attributeDeclarations;\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"in vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs += \"in float a_color; \\n\" + \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" + \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" + \"const float SHIFT_LEFT_11 = 2048.0; \\n\" + \"const float SHIFT_LEFT_5 = 32.0; \\n\" + \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" + \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"in vec3 a_color; \\n\";\n    }\n  }\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"in vec2 a_normal; \\n\";\n    } else {\n      vs += \"in vec3 a_normal; \\n\";\n    }\n  }\n  if (hasBatchIds) {\n    vs += \"in float a_batchId; \\n\";\n  }\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n  vs += \"void main() \\n\" + \"{ \\n\" + \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" + \"    tiles3d_tileset_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n  if (attenuation) {\n    vs += \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" + \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs += \"    float compressed = a_color; \\n\" + \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" + \"    compressed -= r * SHIFT_LEFT_11; \\n\" + \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" + \"    compressed -= g * SHIFT_LEFT_5; \\n\" + \"    float b = compressed; \\n\" + \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" + \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n  if (isQuantized || isQuantizedDraco) {\n    vs += \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n  vs += \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs += \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n  if (hasColorStyle) {\n    vs += \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n  if (hasShowStyle) {\n    vs += \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n  if (hasPointSizeStyle) {\n    vs += \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs += \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" + \"    float depth = -positionEC.z; \\n\" +\n    // compute SSE for this point\n    \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n  vs += \"    color = color * u_highlightColor; \\n\";\n  if (usesNormals && normalShading) {\n    vs += \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" + \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" +\n    // Apply some ambient lighting\n    \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n  vs += \"    v_color = color; \\n\" + \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n  if (usesNormals && backFaceCulling) {\n    vs += \"    float visible = step(-normalEC.z, 0.0); \\n\" + \"    gl_Position *= visible; \\n\" + \"    gl_PointSize *= visible; \\n\";\n  }\n  if (hasShowStyle) {\n    vs += \"    gl_Position.w *= float(show); \\n\" + \"    gl_PointSize *= float(show); \\n\";\n  }\n  vs += \"} \\n\";\n  let fs = \"in vec4 v_color; \\n\";\n  if (hasClippedContent) {\n    fs += \"uniform highp sampler2D u_clippingPlanes; \\n\" + \"uniform mat4 u_clippingPlanesMatrix; \\n\" + \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n  fs += \"void main() \\n\" + \"{ \\n\" + \"    out_FragColor = czm_gammaCorrect(v_color); \\n\";\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\"u_clippingPlanes\", \"u_clippingPlanesMatrix\", \"u_clippingPlanesEdgeStyle\");\n  }\n  fs += \"} \\n\";\n  if (pointCloud.splitDirection !== SplitDirection.NONE) {\n    fs = Splitter.modifyFragmentShader(fs);\n  }\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n  const drawCommand = pointCloud._drawCommand;\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\");\n  }\n}\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    const parsedContent = pointCloud._parsedContent;\n    const draco = parsedContent.draco;\n    const decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise.then(function (result) {\n        pointCloud._decodingState = DecodingState.READY;\n        const decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        const decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        const decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        const decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        const decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        const isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        const isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          const quantization = result.POSITION.data.quantization;\n          const range = quantization.range;\n          pointCloud._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          pointCloud._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          pointCloud._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          pointCloud._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          pointCloud._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          pointCloud._isOctEncodedDraco = true;\n        }\n        let styleableProperties = parsedContent.styleableProperties;\n        const batchTableProperties = draco.batchTableProperties;\n        for (const name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            const property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray: property.array,\n              componentCount: property.data.componentsPerAttribute\n            };\n          }\n        }\n        if (defined(decodedPositions)) {\n          parsedContent.positions = {\n            typedArray: decodedPositions\n          };\n        }\n        const decodedColors = defaultValue(decodedRgba, decodedRgb);\n        if (defined(decodedColors)) {\n          parsedContent.colors = {\n            typedArray: decodedColors\n          };\n        }\n        if (defined(decodedNormals)) {\n          parsedContent.normals = {\n            typedArray: decodedNormals\n          };\n        }\n        if (defined(decodedBatchIds)) {\n          parsedContent.batchIds = {\n            typedArray: decodedBatchIds\n          };\n        }\n        parsedContent.styleableProperties = styleableProperties;\n      }).catch(function (error) {\n        pointCloud._decodingState = DecodingState.FAILED;\n        pointCloud._error = error;\n      });\n    }\n  }\n  return true;\n}\nconst scratchComputedTranslation = new Cartesian4();\nconst scratchScale = new Cartesian3();\nPointCloud.prototype.update = function (frameState) {\n  const context = frameState.context;\n  if (defined(this._error)) {\n    const error = this._error;\n    this._error = undefined;\n    throw error;\n  }\n  const decoding = decodeDraco(this, context);\n  if (decoding) {\n    return;\n  }\n  let shadersDirty = false;\n  let modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._ready = true;\n    this._parsedContent = undefined; // Unload\n  }\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    const modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._quantizedVolumeOffset, modelMatrix);\n    }\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      const projection = frameState.mapProjection;\n      const translation = Matrix4.getColumn(modelMatrix, 3, scratchComputedTranslation);\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n    const boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n    if (this._cull) {\n      const center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      const scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n  const splittingEnabled = this.splitDirection !== SplitDirection.NONE;\n  if (this._splittingEnabled !== splittingEnabled) {\n    this._splittingEnabled = splittingEnabled;\n    shadersDirty = true;\n  }\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows);\n\n  // Update the render state\n  const isTranslucent = this._highlightColor.alpha < 1.0 || this._constantColor.alpha < 1.0 || this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent ? this._translucentRenderState : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n  const commandList = frameState.commandList;\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\nPointCloud.prototype.destroy = function () {\n  const command = this._drawCommand;\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\nexport default PointCloud;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Cartesian4","Check","clone","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","CesiumMath","Matrix4","oneTimeWarning","OrthographicFrustum","PrimitiveType","RuntimeError","Transforms","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","VertexArray","MersenneTwister","BlendingState","Cesium3DTileBatchTable","DracoLoader","getClipAndStyleCode","getClippingFunction","PntsParser","SceneMode","ShadowMode","SplitDirection","Splitter","StencilConstants","DecodingState","NEEDS_DECODE","DECODING","READY","FAILED","PointCloud","options","typeOf","object","arrayBuffer","_parsedContent","undefined","_drawCommand","_isTranslucent","_styleTranslucent","_constantColor","DARKGRAY","_highlightColor","WHITE","_pointSize","_rtcCenter","_quantizedVolumeScale","_quantizedVolumeOffset","_styleableShaderAttributes","_isQuantized","_isOctEncoded16P","_isRGB565","_hasColors","_hasNormals","_hasBatchIds","_decodingState","_dequantizeInShader","_isQuantizedDraco","_isOctEncodedDraco","_quantizedRange","_octEncodedRange","backFaceCulling","_backFaceCulling","normalShading","_normalShading","_opaqueRenderState","_translucentRenderState","_mode","_ready","_pointsLength","_geometryByteLength","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_batchTableLoaded","batchTableLoaded","_pickIdLoaded","pickIdLoaded","_opaquePass","opaquePass","OPAQUE","_cull","cull","style","_style","styleDirty","modelMatrix","IDENTITY","_modelMatrix","time","shadows","ENABLED","_boundingSphere","clippingPlanes","isClipped","clippingPlanesDirty","clippingPlanesOriginMatrix","attenuation","_attenuation","geometricError","geometricErrorScale","maximumAttenuation","splitDirection","NONE","_splittingEnabled","_error","initialize","Object","defineProperties","prototype","pointsLength","get","geometryByteLength","ready","color","set","value","boundingSphere","boundingVolume","pointCloud","parsedContent","parse","byteOffset","rtcCenter","hasNormals","hasColors","hasBatchIds","isTranslucent","batchTableBinary","styleableProperties","getBinaryProperties","batchTableJson","draco","dequantizeInShader","positions","isQuantized","quantizedVolumeScale","quantizedVolumeOffset","quantizedRange","normals","octEncoded","colors","constantColor","isRGB565","batchIds","name","semantic","setIndex","batchLength","scratchMin","scratchMax","scratchPosition","randomNumberGenerator","randomValues","getRandomValues","samplesLength","Array","i","random","computeApproximateBoundingSphereFromPositions","maximumSamplesLength","length","Math","min","maxValue","Number","MAX_VALUE","minValue","fromElements","max","index","floor","position","unpack","minimumByComponent","maximumByComponent","fromCornerPoints","radius","EPSILON2","prepareVertexAttribute","typedArray","componentDatatype","fromTypedArray","INT","UNSIGNED_INT","DOUBLE","Float32Array","scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratchQuantizedVolumeScaleAndOctEncodedRange","scratchColor","positionLocation","colorLocation","normalLocation","batchIdLocation","numberOfAttributes","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createResources","frameState","context","hasStyleableProperties","isQuantizedDraco","isOctEncoded16P","isOctEncodedDraco","octEncodedRange","componentsPerAttribute","styleableVertexAttributes","styleableShaderAttributes","attributeLocation","hasOwnProperty","property","componentCount","vertexBuffer","createVertexBuffer","usage","STATIC_DRAW","sizeInBytes","vertexAttribute","normalize","offsetInBytes","strideInBytes","push","location","positionsVertexBuffer","colorsVertexBuffer","normalsVertexBuffer","batchIdsVertexBuffer","attributes","UNSIGNED_SHORT","UNSIGNED_BYTE","FLOAT","ZERO","colorComponentsPerAttribute","concat","vertexArray","opaqueRenderState","depthTest","enabled","translucentRenderState","depthMask","blending","ALPHA_BLEND","CESIUM_3D_TILE","stencilTest","setCesium3DTileBit","stencilMask","CESIUM_3D_TILE_MASK","fromCache","primitiveType","POINTS","count","shaderProgram","uniformMap","renderState","pass","TRANSLUCENT","owner","castShadows","receiveShadows","pickId","createUniformMap","u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratch","x","pixelRatio","y","frustum","camera","depthMultiplier","mode","SCENE2D","POSITIVE_INFINITY","drawingBufferHeight","sseDenominator","z","w","u_highlightColor","u_constantColor","u_clippingPlanes","texture","defaultTexture","u_clippingPlanesEdgeStyle","TRANSPARENT","edgeColor","alpha","edgeWidth","u_clippingPlanesMatrix","multiply","uniformState","view3D","transform","inverseTranspose","addUniforms","u_quantizedVolumeScaleAndOctEncodedRange","scale","divideByScalar","getStyleablePropertyIds","source","propertyIds","regex","matches","exec","id","parseInt","indexOf","getBuiltinPropertyNames","propertyNames","slice","getVertexAttribute","attribute","getAttribute","builtinVariableSubstitutionMap","POSITION","POSITION_ABSOLUTE","COLOR","NORMAL","createShaders","hasStyle","colorStyleFunction","showStyleFunction","pointSizeStyleFunction","styleTranslucent","variableSubstitutionMap","propertyIdToAttributeMap","shaderState","translucent","parameterList","getColorShaderFunction","getShowShaderFunction","getPointSizeShaderFunction","hasColorStyle","hasShowStyle","hasPointSizeStyle","hasClippedContent","styleablePropertyIds","builtinPropertyNames","usesColorSemantic","usesNormalSemantic","usesColors","colorVertexAttribute","usesNormals","normalVertexAttribute","attributeLocations","a_position","a_color","a_normal","a_batchId","attributeDeclarations","propertyId","attributeName","attributeType","vs","fs","modifyFragmentShader","drawCommand","destroy","vertexShaderSource","fragmentShaderSource","_bind","error","decodeDraco","decodePromise","decodePointCloud","then","result","decodedPositions","array","decodedRgb","RGB","decodedRgba","RGBA","decodedNormals","decodedBatchIds","BATCH_ID","data","quantization","range","minValues","quantizationBits","batchTableProperties","decodedColors","catch","scratchComputedTranslation","scratchScale","update","decoding","shadersDirty","modelMatrixDirty","equals","multiplyByTranslation","SCENE3D","projection","mapProjection","translation","getColumn","UNIT_W","basisTo2D","center","multiplyByPoint","getScale","maximumComponent","splittingEnabled","commandList","passes","render","pick","isDestroyed","command"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PointCloud.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport MersenneTwister from \"mersenne-twister\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport PntsParser from \"./PntsParser.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport Splitter from \"./Splitter.js\";\nimport StencilConstants from \"./StencilConstants.js\";\n\nconst DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3,\n};\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see TimeDynamicPointCloud\n *\n * @private\n */\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer);\n  //>>includeEnd('debug');\n\n  // Hold onto the payload until the render resources are created\n  this._parsedContent = undefined;\n\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined;\n\n  // These values are used to regenerate the shader when the style changes\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false;\n\n  // Draco\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0;\n\n  // Use per-point normals to hide back-facing points.\n  this.backFaceCulling = false;\n  this._backFaceCulling = false;\n\n  // Whether to enable normal shading\n  this.normalShading = true;\n  this._normalShading = true;\n\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n\n  this._mode = undefined;\n\n  this._ready = false;\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  this.time = 0.0; // For styling\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false;\n  // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n  this.clippingPlanesOriginMatrix = undefined;\n\n  this.attenuation = false;\n  this._attenuation = false;\n\n  // Options for geometric error based attenuation\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n\n  /**\n   * The {@link SplitDirection} to apply to this point cloud.\n   *\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    SplitDirection.NONE,\n  );\n  this._splittingEnabled = false;\n\n  this._error = undefined;\n  initialize(this, options);\n}\n\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  color: {\n    get: function () {\n      return Color.clone(this._highlightColor);\n    },\n    set: function (value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    },\n  },\n\n  boundingSphere: {\n    get: function () {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n      return undefined;\n    },\n    set: function (value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    },\n  },\n});\n\nfunction initialize(pointCloud, options) {\n  const parsedContent = PntsParser.parse(\n    options.arrayBuffer,\n    options.byteOffset,\n  );\n  pointCloud._parsedContent = parsedContent;\n  pointCloud._rtcCenter = parsedContent.rtcCenter;\n  pointCloud._hasNormals = parsedContent.hasNormals;\n  pointCloud._hasColors = parsedContent.hasColors;\n  pointCloud._hasBatchIds = parsedContent.hasBatchIds;\n  pointCloud._isTranslucent = parsedContent.isTranslucent;\n\n  // If points are not batched and there are per-point properties, use the\n  // properties as metadata for styling purposes.\n  if (!parsedContent.hasBatchIds && defined(parsedContent.batchTableBinary)) {\n    parsedContent.styleableProperties =\n      Cesium3DTileBatchTable.getBinaryProperties(\n        parsedContent.pointsLength,\n        parsedContent.batchTableJson,\n        parsedContent.batchTableBinary,\n      );\n  }\n\n  if (defined(parsedContent.draco)) {\n    const draco = parsedContent.draco;\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n    draco.dequantizeInShader = pointCloud._dequantizeInShader;\n  }\n\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    pointCloud._isQuantized = positions.isQuantized;\n    pointCloud._quantizedVolumeScale = positions.quantizedVolumeScale;\n    pointCloud._quantizedVolumeOffset = positions.quantizedVolumeOffset;\n    pointCloud._quantizedRange = positions.quantizedRange;\n  }\n\n  const normals = parsedContent.normals;\n  if (defined(normals)) {\n    pointCloud._isOctEncoded16P = normals.octEncoded;\n  }\n\n  const colors = parsedContent.colors;\n  if (defined(colors)) {\n    if (defined(colors.constantColor)) {\n      pointCloud._constantColor = Color.clone(\n        colors.constantColor,\n        pointCloud._constantColor,\n      );\n\n      // Constant colors are handled as a uniform rather than a vertex\n      // attribute.\n      pointCloud._hasColors = false;\n    }\n    pointCloud._isRGB565 = colors.isRGB565;\n  }\n\n  // PntsParser parses BATCH_ID as _FEATURE_ID_0 for EXT_mesh_features.\n  // These properties aren't used but rename them to BATCH_ID to avoid\n  // confusion when debugging.\n  const batchIds = parsedContent.batchIds;\n  if (defined(parsedContent.batchIds)) {\n    batchIds.name = \"BATCH_ID\";\n    batchIds.semantic = \"BATCH_ID\";\n    batchIds.setIndex = undefined;\n  }\n\n  if (parsedContent.hasBatchIds) {\n    pointCloud._batchTableLoaded(\n      parsedContent.batchLength,\n      parsedContent.batchTableJson,\n      parsedContent.batchTableBinary,\n    );\n  }\n\n  pointCloud._pointsLength = parsedContent.pointsLength;\n}\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\n\n// Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n// See https://github.com/CesiumGS/cesium/issues/9730\nlet randomNumberGenerator;\nlet randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\n\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  const maximumSamplesLength = 20;\n  const pointsLength = positions.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  const min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  const max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  for (let i = 0; i < samplesLength; ++i) {\n    const index = Math.floor(randomValues[i] * pointsLength);\n    const position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n\n  const boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n  return boundingSphere;\n}\n\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  const componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n  if (\n    componentDatatype === ComponentDatatype.INT ||\n    componentDatatype === ComponentDatatype.UNSIGNED_INT ||\n    componentDatatype === ComponentDatatype.DOUBLE\n  ) {\n    oneTimeWarning(\n      \"Cast pnts property to floats\",\n      `Point cloud property \"${name}\" will be cast to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.`,\n    );\n    return new Float32Array(typedArray);\n  }\n  return typedArray;\n}\n\nconst scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier =\n  new Cartesian4();\nconst scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nconst scratchColor = new Color();\n\nconst positionLocation = 0;\nconst colorLocation = 1;\nconst normalLocation = 2;\nconst batchIdLocation = 3;\nconst numberOfAttributes = 4;\n\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\n\nfunction createResources(pointCloud, frameState) {\n  const context = frameState.context;\n  const parsedContent = pointCloud._parsedContent;\n  const pointsLength = pointCloud._pointsLength;\n  const positions = parsedContent.positions;\n  const colors = parsedContent.colors;\n  const normals = parsedContent.normals;\n  const batchIds = parsedContent.batchIds;\n  const styleableProperties = parsedContent.styleableProperties;\n  const hasStyleableProperties = defined(styleableProperties);\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncoded16P = pointCloud._isOctEncoded16P;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  const quantizedRange = pointCloud._quantizedRange;\n  const octEncodedRange = pointCloud._octEncodedRange;\n  const isRGB565 = pointCloud._isRGB565;\n  const isTranslucent = pointCloud._isTranslucent;\n  const hasColors = pointCloud._hasColors;\n  const hasNormals = pointCloud._hasNormals;\n  const hasBatchIds = pointCloud._hasBatchIds;\n\n  let componentsPerAttribute;\n  let componentDatatype;\n\n  const styleableVertexAttributes = [];\n  const styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n\n  if (hasStyleableProperties) {\n    let attributeLocation = numberOfAttributes;\n\n    for (const name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        const property = styleableProperties[name];\n        const typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n\n        const vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW,\n        });\n\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n\n        const vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0,\n        };\n\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute,\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n\n  const positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions.typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n\n  let colorsVertexBuffer;\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors.typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n\n  let normalsVertexBuffer;\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals.typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n\n  let batchIdsVertexBuffer;\n  if (hasBatchIds) {\n    batchIds.typedArray = prepareVertexAttribute(\n      batchIds.typedArray,\n      \"batchIds\",\n    );\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds.typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n\n  let attributes = [];\n\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype =\n      quantizedRange <= 255\n        ? ComponentDatatype.UNSIGNED_BYTE\n        : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0,\n  });\n\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.ZERO,\n        pointCloud._quantizedVolumeScale,\n      );\n    } else {\n      pointCloud._boundingSphere =\n        computeApproximateBoundingSphereFromPositions(positions.typedArray);\n    }\n  }\n\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    } else {\n      const colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    }\n  }\n\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype =\n        octEncodedRange <= 255\n          ? ComponentDatatype.UNSIGNED_BYTE\n          : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds.typedArray),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n\n  const vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes,\n  });\n\n  const opaqueRenderState = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  const translucentRenderState = {\n    depthTest: {\n      enabled: true,\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND,\n  };\n\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n    translucentRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    translucentRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n  pointCloud._translucentRenderState = RenderState.fromCache(\n    translucentRenderState,\n  );\n\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined, // Updated in createShaders\n    uniformMap: undefined, // Updated in createShaders\n    renderState: isTranslucent\n      ? pointCloud._translucentRenderState\n      : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded(),\n  });\n}\n\nfunction createUniformMap(pointCloud, frameState) {\n  const context = frameState.context;\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n\n  let uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () {\n      const scratch =\n        scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation\n        ? pointCloud.maximumAttenuation\n        : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n\n      scratch.y = pointCloud.time;\n\n      if (pointCloud._attenuation) {\n        const frustum = frameState.camera.frustum;\n        let depthMultiplier;\n        // Attenuation is maximumAttenuation in 2D/ortho\n        if (\n          frameState.mode === SceneMode.SCENE2D ||\n          frustum instanceof OrthographicFrustum\n        ) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier =\n            context.drawingBufferHeight /\n            frameState.camera.frustum.sseDenominator;\n        }\n\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n\n      return scratch;\n    },\n    u_highlightColor: function () {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function () {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      const isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n\n      const style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n\n      const clippingPlanesOriginMatrix = defaultValue(\n        pointCloud.clippingPlanesOriginMatrix,\n        pointCloud._modelMatrix,\n      );\n      Matrix4.multiply(\n        context.uniformState.view3D,\n        clippingPlanesOriginMatrix,\n        scratchClippingPlanesMatrix,\n      );\n      const transform = Matrix4.multiply(\n        scratchClippingPlanesMatrix,\n        clippingPlanes.modelMatrix,\n        scratchClippingPlanesMatrix,\n      );\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix,\n      );\n    },\n  };\n\n  Splitter.addUniforms(pointCloud, uniformMap);\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function () {\n        const scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          const scale = Cartesian3.clone(\n            pointCloud._quantizedVolumeScale,\n            scratch,\n          );\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      },\n    });\n  }\n\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\n\nfunction getStyleablePropertyIds(source, propertyIds) {\n  // Get all the property IDs used by this style\n  const regex = /czm_3dtiles_property_(\\d+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const id = parseInt(matches[1]);\n    if (propertyIds.indexOf(id) === -1) {\n      propertyIds.push(id);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  // Get all the builtin property names used by this style, ignoring the function signature\n  source = source.slice(source.indexOf(\"\\n\"));\n  const regex = /czm_3dtiles_builtin_property_(\\w+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const name = matches[1];\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getVertexAttribute(vertexArray, index) {\n  const numberOfAttributes = vertexArray.numberOfAttributes;\n  for (let i = 0; i < numberOfAttributes; ++i) {\n    const attribute = vertexArray.getAttribute(i);\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\n\nconst builtinVariableSubstitutionMap = {\n  POSITION: \"czm_3dtiles_builtin_property_POSITION\",\n  POSITION_ABSOLUTE: \"czm_3dtiles_builtin_property_POSITION_ABSOLUTE\",\n  COLOR: \"czm_3dtiles_builtin_property_COLOR\",\n  NORMAL: \"czm_3dtiles_builtin_property_NORMAL\",\n};\n\nfunction createShaders(pointCloud, frameState, style) {\n  let i;\n  let name;\n  let attribute;\n\n  const context = frameState.context;\n  const hasStyle = defined(style);\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncoded16P = pointCloud._isOctEncoded16P;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  const isRGB565 = pointCloud._isRGB565;\n  const isTranslucent = pointCloud._isTranslucent;\n  const hasColors = pointCloud._hasColors;\n  const hasNormals = pointCloud._hasNormals;\n  const hasBatchIds = pointCloud._hasBatchIds;\n  const backFaceCulling = pointCloud._backFaceCulling;\n  const normalShading = pointCloud._normalShading;\n  const vertexArray = pointCloud._drawCommand.vertexArray;\n  const clippingPlanes = pointCloud.clippingPlanes;\n  const attenuation = pointCloud._attenuation;\n\n  let colorStyleFunction;\n  let showStyleFunction;\n  let pointSizeStyleFunction;\n  let styleTranslucent = isTranslucent;\n\n  const variableSubstitutionMap = clone(builtinVariableSubstitutionMap);\n  const propertyIdToAttributeMap = {};\n  const styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      variableSubstitutionMap[name] =\n        `czm_3dtiles_property_${attribute.location}`;\n      propertyIdToAttributeMap[attribute.location] = attribute;\n    }\n  }\n\n  if (hasStyle) {\n    const shaderState = {\n      translucent: false,\n    };\n    const parameterList =\n      \"(\" +\n      \"vec3 czm_3dtiles_builtin_property_POSITION, \" +\n      \"vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, \" +\n      \"vec4 czm_3dtiles_builtin_property_COLOR, \" +\n      \"vec3 czm_3dtiles_builtin_property_NORMAL\" +\n      \")\";\n    colorStyleFunction = style.getColorShaderFunction(\n      `getColorFromStyle${parameterList}`,\n      variableSubstitutionMap,\n      shaderState,\n    );\n    showStyleFunction = style.getShowShaderFunction(\n      `getShowFromStyle${parameterList}`,\n      variableSubstitutionMap,\n      shaderState,\n    );\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(\n      `getPointSizeFromStyle${parameterList}`,\n      variableSubstitutionMap,\n      shaderState,\n    );\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n\n  pointCloud._styleTranslucent = styleTranslucent;\n\n  const hasColorStyle = defined(colorStyleFunction);\n  const hasShowStyle = defined(showStyleFunction);\n  const hasPointSizeStyle = defined(pointSizeStyleFunction);\n  const hasClippedContent = pointCloud.isClipped;\n\n  // Get the properties in use by the style\n  const styleablePropertyIds = [];\n  const builtinPropertyNames = [];\n\n  if (hasColorStyle) {\n    getStyleablePropertyIds(colorStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n  }\n  if (hasShowStyle) {\n    getStyleablePropertyIds(showStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n  }\n  if (hasPointSizeStyle) {\n    getStyleablePropertyIds(pointSizeStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n  }\n\n  const usesColorSemantic = builtinPropertyNames.indexOf(\"COLOR\") >= 0;\n  const usesNormalSemantic = builtinPropertyNames.indexOf(\"NORMAL\") >= 0;\n\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\n      \"Style references the NORMAL semantic but the point cloud does not have normals\",\n    );\n  }\n\n  // Disable vertex attributes that aren't used in the style, enable attributes that are\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      const enabled = styleablePropertyIds.indexOf(attribute.location) >= 0;\n      const vertexAttribute = getVertexAttribute(\n        vertexArray,\n        attribute.location,\n      );\n      vertexAttribute.enabled = enabled;\n    }\n  }\n\n  const usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    const colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n\n  const usesNormals =\n    hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    const normalVertexAttribute = getVertexAttribute(\n      vertexArray,\n      normalLocation,\n    );\n    normalVertexAttribute.enabled = usesNormals;\n  }\n\n  const attributeLocations = {\n    a_position: positionLocation,\n  };\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n\n  let attributeDeclarations = \"\";\n\n  const length = styleablePropertyIds.length;\n  for (i = 0; i < length; ++i) {\n    const propertyId = styleablePropertyIds[i];\n    attribute = propertyIdToAttributeMap[propertyId];\n    const componentCount = attribute.componentCount;\n    const attributeName = `czm_3dtiles_property_${propertyId}`;\n    let attributeType;\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = `vec${componentCount}`;\n    }\n\n    attributeDeclarations += `in ${attributeType} ${attributeName}; \\n`;\n    attributeLocations[attributeName] = attribute.location;\n  }\n\n  createUniformMap(pointCloud, frameState);\n\n  let vs =\n    \"in vec3 a_position; \\n\" +\n    \"out vec4 v_color; \\n\" +\n    \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" +\n    \"uniform vec4 u_constantColor; \\n\" +\n    \"uniform vec4 u_highlightColor; \\n\";\n\n  // The time variable is named differently for compatibility with custom\n  // shaders in Model.\n  vs += \"float u_pointSize; \\n\" + \"float tiles3d_tileset_time; \\n\";\n\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n\n  vs += attributeDeclarations;\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"in vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"in float a_color; \\n\" +\n        \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" +\n        \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" +\n        \"const float SHIFT_LEFT_11 = 2048.0; \\n\" +\n        \"const float SHIFT_LEFT_5 = 32.0; \\n\" +\n        \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" +\n        \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"in vec3 a_color; \\n\";\n    }\n  }\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"in vec2 a_normal; \\n\";\n    } else {\n      vs += \"in vec3 a_normal; \\n\";\n    }\n  }\n\n  if (hasBatchIds) {\n    vs += \"in float a_batchId; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n\n  vs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" +\n    \"    tiles3d_tileset_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n\n  if (attenuation) {\n    vs +=\n      \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" +\n      \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"    float compressed = a_color; \\n\" +\n        \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" +\n        \"    compressed -= r * SHIFT_LEFT_11; \\n\" +\n        \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" +\n        \"    compressed -= g * SHIFT_LEFT_5; \\n\" +\n        \"    float b = compressed; \\n\" +\n        \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" +\n        \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco) {\n    vs +=\n      \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n  vs +=\n    \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs +=\n        \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs +=\n      \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n\n  if (hasPointSizeStyle) {\n    vs +=\n      \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs +=\n      \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" +\n      \"    float depth = -positionEC.z; \\n\" +\n      // compute SSE for this point\n      \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n\n  vs += \"    color = color * u_highlightColor; \\n\";\n\n  if (usesNormals && normalShading) {\n    vs +=\n      \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" +\n      \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" + // Apply some ambient lighting\n      \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n\n  vs +=\n    \"    v_color = color; \\n\" +\n    \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n\n  if (usesNormals && backFaceCulling) {\n    vs +=\n      \"    float visible = step(-normalEC.z, 0.0); \\n\" +\n      \"    gl_Position *= visible; \\n\" +\n      \"    gl_PointSize *= visible; \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    gl_Position.w *= float(show); \\n\" +\n      \"    gl_PointSize *= float(show); \\n\";\n  }\n\n  vs += \"} \\n\";\n\n  let fs = \"in vec4 v_color; \\n\";\n\n  if (hasClippedContent) {\n    fs +=\n      \"uniform highp sampler2D u_clippingPlanes; \\n\" +\n      \"uniform mat4 u_clippingPlanesMatrix; \\n\" +\n      \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n\n  fs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    out_FragColor = czm_gammaCorrect(v_color); \\n\";\n\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\n      \"u_clippingPlanes\",\n      \"u_clippingPlanesMatrix\",\n      \"u_clippingPlanesEdgeStyle\",\n    );\n  }\n\n  fs += \"} \\n\";\n\n  if (pointCloud.splitDirection !== SplitDirection.NONE) {\n    fs = Splitter.modifyFragmentShader(fs);\n  }\n\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n\n  const drawCommand = pointCloud._drawCommand;\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\n      \"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\",\n    );\n  }\n}\n\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    const parsedContent = pointCloud._parsedContent;\n    const draco = parsedContent.draco;\n    const decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise\n        .then(function (result) {\n          pointCloud._decodingState = DecodingState.READY;\n          const decodedPositions = defined(result.POSITION)\n            ? result.POSITION.array\n            : undefined;\n          const decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n          const decodedRgba = defined(result.RGBA)\n            ? result.RGBA.array\n            : undefined;\n          const decodedNormals = defined(result.NORMAL)\n            ? result.NORMAL.array\n            : undefined;\n          const decodedBatchIds = defined(result.BATCH_ID)\n            ? result.BATCH_ID.array\n            : undefined;\n          const isQuantizedDraco =\n            defined(decodedPositions) &&\n            defined(result.POSITION.data.quantization);\n          const isOctEncodedDraco =\n            defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n          if (isQuantizedDraco) {\n            // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n            // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n            const quantization = result.POSITION.data.quantization;\n            const range = quantization.range;\n            pointCloud._quantizedVolumeScale = Cartesian3.fromElements(\n              range,\n              range,\n              range,\n            );\n            pointCloud._quantizedVolumeOffset = Cartesian3.unpack(\n              quantization.minValues,\n            );\n            pointCloud._quantizedRange =\n              (1 << quantization.quantizationBits) - 1.0;\n            pointCloud._isQuantizedDraco = true;\n          }\n          if (isOctEncodedDraco) {\n            pointCloud._octEncodedRange =\n              (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n            pointCloud._isOctEncodedDraco = true;\n          }\n          let styleableProperties = parsedContent.styleableProperties;\n          const batchTableProperties = draco.batchTableProperties;\n          for (const name in batchTableProperties) {\n            if (batchTableProperties.hasOwnProperty(name)) {\n              const property = result[name];\n              if (!defined(styleableProperties)) {\n                styleableProperties = {};\n              }\n              styleableProperties[name] = {\n                typedArray: property.array,\n                componentCount: property.data.componentsPerAttribute,\n              };\n            }\n          }\n\n          if (defined(decodedPositions)) {\n            parsedContent.positions = {\n              typedArray: decodedPositions,\n            };\n          }\n\n          const decodedColors = defaultValue(decodedRgba, decodedRgb);\n          if (defined(decodedColors)) {\n            parsedContent.colors = {\n              typedArray: decodedColors,\n            };\n          }\n\n          if (defined(decodedNormals)) {\n            parsedContent.normals = {\n              typedArray: decodedNormals,\n            };\n          }\n\n          if (defined(decodedBatchIds)) {\n            parsedContent.batchIds = {\n              typedArray: decodedBatchIds,\n            };\n          }\n\n          parsedContent.styleableProperties = styleableProperties;\n        })\n        .catch(function (error) {\n          pointCloud._decodingState = DecodingState.FAILED;\n          pointCloud._error = error;\n        });\n    }\n  }\n  return true;\n}\n\nconst scratchComputedTranslation = new Cartesian4();\nconst scratchScale = new Cartesian3();\n\nPointCloud.prototype.update = function (frameState) {\n  const context = frameState.context;\n\n  if (defined(this._error)) {\n    const error = this._error;\n    this._error = undefined;\n    throw error;\n  }\n\n  const decoding = decodeDraco(this, context);\n  if (decoding) {\n    return;\n  }\n\n  let shadersDirty = false;\n  let modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._ready = true;\n    this._parsedContent = undefined; // Unload\n  }\n\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    const modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(\n        modelMatrix,\n        this._quantizedVolumeOffset,\n        modelMatrix,\n      );\n    }\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      const projection = frameState.mapProjection;\n      const translation = Matrix4.getColumn(\n        modelMatrix,\n        3,\n        scratchComputedTranslation,\n      );\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n\n    const boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n\n    if (this._cull) {\n      const center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      const scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n\n  const splittingEnabled = this.splitDirection !== SplitDirection.NONE;\n  if (this._splittingEnabled !== splittingEnabled) {\n    this._splittingEnabled = splittingEnabled;\n    shadersDirty = true;\n  }\n\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows);\n\n  // Update the render state\n  const isTranslucent =\n    this._highlightColor.alpha < 1.0 ||\n    this._constantColor.alpha < 1.0 ||\n    this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent\n    ? this._translucentRenderState\n    : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n\n  const commandList = frameState.commandList;\n\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\n\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud.prototype.destroy = function () {\n  const command = this._drawCommand;\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\nexport default PointCloud;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}