{"ast":null,"code":"import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\nconst scratchModelMatrix = new Matrix4();\nconst scratchModelView2D = new Matrix4();\n\n/**\n * The scene mode 2D stage generates resources for rendering a primitive in 2D / CV mode.\n *\n * @namespace SceneMode2DPipelineStage\n *\n * @private\n */\nconst SceneMode2DPipelineStage = {\n  name: \"SceneMode2DPipelineStage\" // Helps with debugging\n};\n\n/**\n * This pipeline stage processes the position attribute of a primitive and adds the relevant\n * define and uniform matrix to the shader. It also generates new resources for the primitive\n * in 2D. These resources persist in the runtime primitive so that the typed array used to\n * store the positional data can be freed.\n *\n * This stage must go before the GeometryPipelineStage in the primitive pipeline.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> creates a vertex buffer for the positions of the primitive projected to 2D\n *  <li> creates the bounding sphere for the primitive in 2D\n *  <li> adds a flag to the shader to use 2D positions\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\n\nSceneMode2DPipelineStage.process = function (renderResources, primitive, frameState) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.POSITION);\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const modelMatrix = model.sceneGraph.computedModelMatrix;\n  const nodeComputedTransform = renderResources.runtimeNode.computedTransform;\n  const computedModelMatrix = Matrix4.multiplyTransformation(modelMatrix, nodeComputedTransform, scratchModelMatrix);\n  const boundingSphere2D = computeBoundingSphere2D(renderResources, computedModelMatrix, frameState);\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  runtimePrimitive.boundingSphere2D = boundingSphere2D;\n\n  // If the model is instanced, 2D projection will be handled in the\n  // InstancingPipelineStage.\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    return;\n  }\n\n  // If the typed array of the position attribute exists, then\n  // the positions haven't been projected to 2D yet.\n  if (defined(positionAttribute.typedArray)) {\n    const buffer2D = createPositionBufferFor2D(positionAttribute, computedModelMatrix, boundingSphere2D, frameState);\n\n    // Since this buffer will persist even if the pipeline is re-run,\n    // its memory will be counted in PrimitiveStatisticsPipelineStage\n    runtimePrimitive.positionBuffer2D = buffer2D;\n    model._modelResources.push(buffer2D);\n\n    // Unload the typed array. This is just a pointer to the array in\n    // the vertex buffer loader, so if the typed array is shared by\n    // multiple primitives (i.e. multiple instances of the same mesh),\n    // this will not affect the other primitives.\n    positionAttribute.typedArray = undefined;\n  }\n  shaderBuilder.addDefine(\"USE_2D_POSITIONS\", undefined, ShaderDestination.VERTEX);\n  shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n  const modelMatrix2D = Matrix4.fromTranslation(boundingSphere2D.center, new Matrix4());\n  const context = frameState.context;\n  const uniformMap = {\n    u_modelView2D: function () {\n      return Matrix4.multiplyTransformation(context.uniformState.view, modelMatrix2D, scratchModelView2D);\n    }\n  };\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\nfunction computeBoundingSphere2D(renderResources, modelMatrix, frameState) {\n  // Compute the bounding sphere in 2D.\n  const transformedPositionMin = Matrix4.multiplyByPoint(modelMatrix, renderResources.positionMin, scratchProjectedMin);\n  const projectedMin = SceneTransforms.computeActualEllipsoidPosition(frameState, transformedPositionMin, transformedPositionMin);\n  const transformedPositionMax = Matrix4.multiplyByPoint(modelMatrix, renderResources.positionMax, scratchProjectedMax);\n  const projectedMax = SceneTransforms.computeActualEllipsoidPosition(frameState, transformedPositionMax, transformedPositionMax);\n  return BoundingSphere.fromCornerPoints(projectedMin, projectedMax, new BoundingSphere());\n}\nconst scratchPosition = new Cartesian3();\nfunction dequantizePositionsTypedArray(typedArray, quantization) {\n  // Draco compression is normally handled in the dequantization stage\n  // in the shader, but it must be decoded here in order to project\n  // the positions to 2D / CV.\n  const length = typedArray.length;\n  const dequantizedArray = new Float32Array(length);\n  const quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n  const quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n  for (let i = 0; i < length; i += 3) {\n    const initialPosition = Cartesian3.fromArray(typedArray, i, scratchPosition);\n    const scaledPosition = Cartesian3.multiplyComponents(initialPosition, quantizedVolumeStepSize, initialPosition);\n    const dequantizedPosition = Cartesian3.add(scaledPosition, quantizedVolumeOffset, scaledPosition);\n    dequantizedArray[i] = dequantizedPosition.x;\n    dequantizedArray[i + 1] = dequantizedPosition.y;\n    dequantizedArray[i + 2] = dequantizedPosition.z;\n  }\n  return dequantizedArray;\n}\nfunction createPositionsTypedArrayFor2D(attribute, modelMatrix, referencePoint, frameState) {\n  let result;\n  if (defined(attribute.quantization)) {\n    // Dequantize the positions if necessary.\n    result = dequantizePositionsTypedArray(attribute.typedArray, attribute.quantization);\n  } else {\n    result = attribute.typedArray.slice();\n  }\n  const startIndex = attribute.byteOffset / Float32Array.BYTES_PER_ELEMENT;\n  const length = result.length;\n  const stride = defined(attribute.byteStride) ? attribute.byteStride / Float32Array.BYTES_PER_ELEMENT : 3;\n  for (let i = startIndex; i < length; i += stride) {\n    const initialPosition = Cartesian3.fromArray(result, i, scratchPosition);\n    if (isNaN(initialPosition.x) || isNaN(initialPosition.y) || isNaN(initialPosition.z)) {\n      continue;\n    }\n    const transformedPosition = Matrix4.multiplyByPoint(modelMatrix, initialPosition, initialPosition);\n    const projectedPosition = SceneTransforms.computeActualEllipsoidPosition(frameState, transformedPosition, transformedPosition);\n    const relativePosition = Cartesian3.subtract(projectedPosition, referencePoint, projectedPosition);\n    result[i] = relativePosition.x;\n    result[i + 1] = relativePosition.y;\n    result[i + 2] = relativePosition.z;\n  }\n  return result;\n}\nfunction createPositionBufferFor2D(positionAttribute, modelMatrix, boundingSphere2D, frameState) {\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the\n  // primitive's bounding sphere in 2D.\n  const referencePoint = boundingSphere2D.center;\n  const projectedPositions = createPositionsTypedArrayFor2D(positionAttribute, modelMatrix, referencePoint, frameStateCV);\n\n  // Put the resulting data in a GPU buffer.\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: projectedPositions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\nexport default SceneMode2DPipelineStage;","map":{"version":3,"names":["BoundingSphere","Buffer","BufferUsage","Cartesian3","clone","combine","defined","Matrix4","ModelUtility","SceneMode","ShaderDestination","VertexAttributeSemantic","SceneTransforms","scratchModelMatrix","scratchModelView2D","SceneMode2DPipelineStage","name","process","renderResources","primitive","frameState","positionAttribute","getAttributeBySemantic","POSITION","shaderBuilder","model","modelMatrix","sceneGraph","computedModelMatrix","nodeComputedTransform","runtimeNode","computedTransform","multiplyTransformation","boundingSphere2D","computeBoundingSphere2D","runtimePrimitive","instances","node","typedArray","buffer2D","createPositionBufferFor2D","positionBuffer2D","_modelResources","push","undefined","addDefine","VERTEX","addUniform","modelMatrix2D","fromTranslation","center","context","uniformMap","u_modelView2D","uniformState","view","scratchProjectedMin","scratchProjectedMax","transformedPositionMin","multiplyByPoint","positionMin","projectedMin","computeActualEllipsoidPosition","transformedPositionMax","positionMax","projectedMax","fromCornerPoints","scratchPosition","dequantizePositionsTypedArray","quantization","length","dequantizedArray","Float32Array","quantizedVolumeOffset","quantizedVolumeStepSize","i","initialPosition","fromArray","scaledPosition","multiplyComponents","dequantizedPosition","add","x","y","z","createPositionsTypedArrayFor2D","attribute","referencePoint","result","slice","startIndex","byteOffset","BYTES_PER_ELEMENT","stride","byteStride","isNaN","transformedPosition","projectedPosition","relativePosition","subtract","frameStateCV","mode","COLUMBUS_VIEW","projectedPositions","buffer","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/SceneMode2DPipelineStage.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\n\nconst scratchModelMatrix = new Matrix4();\nconst scratchModelView2D = new Matrix4();\n\n/**\n * The scene mode 2D stage generates resources for rendering a primitive in 2D / CV mode.\n *\n * @namespace SceneMode2DPipelineStage\n *\n * @private\n */\nconst SceneMode2DPipelineStage = {\n  name: \"SceneMode2DPipelineStage\", // Helps with debugging\n};\n\n/**\n * This pipeline stage processes the position attribute of a primitive and adds the relevant\n * define and uniform matrix to the shader. It also generates new resources for the primitive\n * in 2D. These resources persist in the runtime primitive so that the typed array used to\n * store the positional data can be freed.\n *\n * This stage must go before the GeometryPipelineStage in the primitive pipeline.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> creates a vertex buffer for the positions of the primitive projected to 2D\n *  <li> creates the bounding sphere for the primitive in 2D\n *  <li> adds a flag to the shader to use 2D positions\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\n\nSceneMode2DPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const modelMatrix = model.sceneGraph.computedModelMatrix;\n  const nodeComputedTransform = renderResources.runtimeNode.computedTransform;\n  const computedModelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    nodeComputedTransform,\n    scratchModelMatrix,\n  );\n\n  const boundingSphere2D = computeBoundingSphere2D(\n    renderResources,\n    computedModelMatrix,\n    frameState,\n  );\n\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  runtimePrimitive.boundingSphere2D = boundingSphere2D;\n\n  // If the model is instanced, 2D projection will be handled in the\n  // InstancingPipelineStage.\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    return;\n  }\n\n  // If the typed array of the position attribute exists, then\n  // the positions haven't been projected to 2D yet.\n  if (defined(positionAttribute.typedArray)) {\n    const buffer2D = createPositionBufferFor2D(\n      positionAttribute,\n      computedModelMatrix,\n      boundingSphere2D,\n      frameState,\n    );\n\n    // Since this buffer will persist even if the pipeline is re-run,\n    // its memory will be counted in PrimitiveStatisticsPipelineStage\n    runtimePrimitive.positionBuffer2D = buffer2D;\n    model._modelResources.push(buffer2D);\n\n    // Unload the typed array. This is just a pointer to the array in\n    // the vertex buffer loader, so if the typed array is shared by\n    // multiple primitives (i.e. multiple instances of the same mesh),\n    // this will not affect the other primitives.\n    positionAttribute.typedArray = undefined;\n  }\n\n  shaderBuilder.addDefine(\n    \"USE_2D_POSITIONS\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n\n  const modelMatrix2D = Matrix4.fromTranslation(\n    boundingSphere2D.center,\n    new Matrix4(),\n  );\n\n  const context = frameState.context;\n  const uniformMap = {\n    u_modelView2D: function () {\n      return Matrix4.multiplyTransformation(\n        context.uniformState.view,\n        modelMatrix2D,\n        scratchModelView2D,\n      );\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\n\nfunction computeBoundingSphere2D(renderResources, modelMatrix, frameState) {\n  // Compute the bounding sphere in 2D.\n  const transformedPositionMin = Matrix4.multiplyByPoint(\n    modelMatrix,\n    renderResources.positionMin,\n    scratchProjectedMin,\n  );\n\n  const projectedMin = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMin,\n    transformedPositionMin,\n  );\n\n  const transformedPositionMax = Matrix4.multiplyByPoint(\n    modelMatrix,\n    renderResources.positionMax,\n    scratchProjectedMax,\n  );\n\n  const projectedMax = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMax,\n    transformedPositionMax,\n  );\n\n  return BoundingSphere.fromCornerPoints(\n    projectedMin,\n    projectedMax,\n    new BoundingSphere(),\n  );\n}\n\nconst scratchPosition = new Cartesian3();\n\nfunction dequantizePositionsTypedArray(typedArray, quantization) {\n  // Draco compression is normally handled in the dequantization stage\n  // in the shader, but it must be decoded here in order to project\n  // the positions to 2D / CV.\n  const length = typedArray.length;\n  const dequantizedArray = new Float32Array(length);\n  const quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n  const quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n  for (let i = 0; i < length; i += 3) {\n    const initialPosition = Cartesian3.fromArray(\n      typedArray,\n      i,\n      scratchPosition,\n    );\n    const scaledPosition = Cartesian3.multiplyComponents(\n      initialPosition,\n      quantizedVolumeStepSize,\n      initialPosition,\n    );\n    const dequantizedPosition = Cartesian3.add(\n      scaledPosition,\n      quantizedVolumeOffset,\n      scaledPosition,\n    );\n\n    dequantizedArray[i] = dequantizedPosition.x;\n    dequantizedArray[i + 1] = dequantizedPosition.y;\n    dequantizedArray[i + 2] = dequantizedPosition.z;\n  }\n\n  return dequantizedArray;\n}\n\nfunction createPositionsTypedArrayFor2D(\n  attribute,\n  modelMatrix,\n  referencePoint,\n  frameState,\n) {\n  let result;\n  if (defined(attribute.quantization)) {\n    // Dequantize the positions if necessary.\n    result = dequantizePositionsTypedArray(\n      attribute.typedArray,\n      attribute.quantization,\n    );\n  } else {\n    result = attribute.typedArray.slice();\n  }\n\n  const startIndex = attribute.byteOffset / Float32Array.BYTES_PER_ELEMENT;\n  const length = result.length;\n  const stride = defined(attribute.byteStride)\n    ? attribute.byteStride / Float32Array.BYTES_PER_ELEMENT\n    : 3;\n\n  for (let i = startIndex; i < length; i += stride) {\n    const initialPosition = Cartesian3.fromArray(result, i, scratchPosition);\n    if (\n      isNaN(initialPosition.x) ||\n      isNaN(initialPosition.y) ||\n      isNaN(initialPosition.z)\n    ) {\n      continue;\n    }\n\n    const transformedPosition = Matrix4.multiplyByPoint(\n      modelMatrix,\n      initialPosition,\n      initialPosition,\n    );\n\n    const projectedPosition = SceneTransforms.computeActualEllipsoidPosition(\n      frameState,\n      transformedPosition,\n      transformedPosition,\n    );\n\n    const relativePosition = Cartesian3.subtract(\n      projectedPosition,\n      referencePoint,\n      projectedPosition,\n    );\n\n    result[i] = relativePosition.x;\n    result[i + 1] = relativePosition.y;\n    result[i + 2] = relativePosition.z;\n  }\n\n  return result;\n}\n\nfunction createPositionBufferFor2D(\n  positionAttribute,\n  modelMatrix,\n  boundingSphere2D,\n  frameState,\n) {\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the\n  // primitive's bounding sphere in 2D.\n  const referencePoint = boundingSphere2D.center;\n  const projectedPositions = createPositionsTypedArrayFor2D(\n    positionAttribute,\n    modelMatrix,\n    referencePoint,\n    frameStateCV,\n  );\n\n  // Put the resulting data in a GPU buffer.\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: projectedPositions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  buffer.vertexArrayDestroyable = false;\n\n  return buffer;\n}\n\nexport default SceneMode2DPipelineStage;\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,8BAA8B;AACzD,OAAOC,MAAM,MAAM,0BAA0B;AAC7C,OAAOC,WAAW,MAAM,+BAA+B;AACvD,OAAOC,UAAU,MAAM,0BAA0B;AACjD,OAAOC,KAAK,MAAM,qBAAqB;AACvC,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,iBAAiB,MAAM,qCAAqC;AACnE,OAAOC,uBAAuB,MAAM,+BAA+B;AACnE,OAAOC,eAAe,MAAM,uBAAuB;AAEnD,MAAMC,kBAAkB,GAAG,IAAIN,OAAO,CAAC,CAAC;AACxC,MAAMO,kBAAkB,GAAG,IAAIP,OAAO,CAAC,CAAC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,wBAAwB,GAAG;EAC/BC,IAAI,EAAE,0BAA0B,CAAE;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAD,wBAAwB,CAACE,OAAO,GAAG,UACjCC,eAAe,EACfC,SAAS,EACTC,UAAU,EACV;EACA,MAAMC,iBAAiB,GAAGb,YAAY,CAACc,sBAAsB,CAC3DH,SAAS,EACTR,uBAAuB,CAACY,QAC1B,CAAC;EAED,MAAMC,aAAa,GAAGN,eAAe,CAACM,aAAa;EACnD,MAAMC,KAAK,GAAGP,eAAe,CAACO,KAAK;EACnC,MAAMC,WAAW,GAAGD,KAAK,CAACE,UAAU,CAACC,mBAAmB;EACxD,MAAMC,qBAAqB,GAAGX,eAAe,CAACY,WAAW,CAACC,iBAAiB;EAC3E,MAAMH,mBAAmB,GAAGrB,OAAO,CAACyB,sBAAsB,CACxDN,WAAW,EACXG,qBAAqB,EACrBhB,kBACF,CAAC;EAED,MAAMoB,gBAAgB,GAAGC,uBAAuB,CAC9ChB,eAAe,EACfU,mBAAmB,EACnBR,UACF,CAAC;EAED,MAAMe,gBAAgB,GAAGjB,eAAe,CAACiB,gBAAgB;EACzDA,gBAAgB,CAACF,gBAAgB,GAAGA,gBAAgB;;EAEpD;EACA;EACA,MAAMG,SAAS,GAAGlB,eAAe,CAACY,WAAW,CAACO,IAAI,CAACD,SAAS;EAC5D,IAAI9B,OAAO,CAAC8B,SAAS,CAAC,EAAE;IACtB;EACF;;EAEA;EACA;EACA,IAAI9B,OAAO,CAACe,iBAAiB,CAACiB,UAAU,CAAC,EAAE;IACzC,MAAMC,QAAQ,GAAGC,yBAAyB,CACxCnB,iBAAiB,EACjBO,mBAAmB,EACnBK,gBAAgB,EAChBb,UACF,CAAC;;IAED;IACA;IACAe,gBAAgB,CAACM,gBAAgB,GAAGF,QAAQ;IAC5Cd,KAAK,CAACiB,eAAe,CAACC,IAAI,CAACJ,QAAQ,CAAC;;IAEpC;IACA;IACA;IACA;IACAlB,iBAAiB,CAACiB,UAAU,GAAGM,SAAS;EAC1C;EAEApB,aAAa,CAACqB,SAAS,CACrB,kBAAkB,EAClBD,SAAS,EACTlC,iBAAiB,CAACoC,MACpB,CAAC;EAEDtB,aAAa,CAACuB,UAAU,CAAC,MAAM,EAAE,eAAe,EAAErC,iBAAiB,CAACoC,MAAM,CAAC;EAE3E,MAAME,aAAa,GAAGzC,OAAO,CAAC0C,eAAe,CAC3ChB,gBAAgB,CAACiB,MAAM,EACvB,IAAI3C,OAAO,CAAC,CACd,CAAC;EAED,MAAM4C,OAAO,GAAG/B,UAAU,CAAC+B,OAAO;EAClC,MAAMC,UAAU,GAAG;IACjBC,aAAa,EAAE,SAAAA,CAAA,EAAY;MACzB,OAAO9C,OAAO,CAACyB,sBAAsB,CACnCmB,OAAO,CAACG,YAAY,CAACC,IAAI,EACzBP,aAAa,EACblC,kBACF,CAAC;IACH;EACF,CAAC;EAEDI,eAAe,CAACkC,UAAU,GAAG/C,OAAO,CAAC+C,UAAU,EAAElC,eAAe,CAACkC,UAAU,CAAC;AAC9E,CAAC;AAED,MAAMI,mBAAmB,GAAG,IAAIrD,UAAU,CAAC,CAAC;AAC5C,MAAMsD,mBAAmB,GAAG,IAAItD,UAAU,CAAC,CAAC;AAE5C,SAAS+B,uBAAuBA,CAAChB,eAAe,EAAEQ,WAAW,EAAEN,UAAU,EAAE;EACzE;EACA,MAAMsC,sBAAsB,GAAGnD,OAAO,CAACoD,eAAe,CACpDjC,WAAW,EACXR,eAAe,CAAC0C,WAAW,EAC3BJ,mBACF,CAAC;EAED,MAAMK,YAAY,GAAGjD,eAAe,CAACkD,8BAA8B,CACjE1C,UAAU,EACVsC,sBAAsB,EACtBA,sBACF,CAAC;EAED,MAAMK,sBAAsB,GAAGxD,OAAO,CAACoD,eAAe,CACpDjC,WAAW,EACXR,eAAe,CAAC8C,WAAW,EAC3BP,mBACF,CAAC;EAED,MAAMQ,YAAY,GAAGrD,eAAe,CAACkD,8BAA8B,CACjE1C,UAAU,EACV2C,sBAAsB,EACtBA,sBACF,CAAC;EAED,OAAO/D,cAAc,CAACkE,gBAAgB,CACpCL,YAAY,EACZI,YAAY,EACZ,IAAIjE,cAAc,CAAC,CACrB,CAAC;AACH;AAEA,MAAMmE,eAAe,GAAG,IAAIhE,UAAU,CAAC,CAAC;AAExC,SAASiE,6BAA6BA,CAAC9B,UAAU,EAAE+B,YAAY,EAAE;EAC/D;EACA;EACA;EACA,MAAMC,MAAM,GAAGhC,UAAU,CAACgC,MAAM;EAChC,MAAMC,gBAAgB,GAAG,IAAIC,YAAY,CAACF,MAAM,CAAC;EACjD,MAAMG,qBAAqB,GAAGJ,YAAY,CAACI,qBAAqB;EAChE,MAAMC,uBAAuB,GAAGL,YAAY,CAACK,uBAAuB;EACpE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,EAAEK,CAAC,IAAI,CAAC,EAAE;IAClC,MAAMC,eAAe,GAAGzE,UAAU,CAAC0E,SAAS,CAC1CvC,UAAU,EACVqC,CAAC,EACDR,eACF,CAAC;IACD,MAAMW,cAAc,GAAG3E,UAAU,CAAC4E,kBAAkB,CAClDH,eAAe,EACfF,uBAAuB,EACvBE,eACF,CAAC;IACD,MAAMI,mBAAmB,GAAG7E,UAAU,CAAC8E,GAAG,CACxCH,cAAc,EACdL,qBAAqB,EACrBK,cACF,CAAC;IAEDP,gBAAgB,CAACI,CAAC,CAAC,GAAGK,mBAAmB,CAACE,CAAC;IAC3CX,gBAAgB,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGK,mBAAmB,CAACG,CAAC;IAC/CZ,gBAAgB,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGK,mBAAmB,CAACI,CAAC;EACjD;EAEA,OAAOb,gBAAgB;AACzB;AAEA,SAASc,8BAA8BA,CACrCC,SAAS,EACT5D,WAAW,EACX6D,cAAc,EACdnE,UAAU,EACV;EACA,IAAIoE,MAAM;EACV,IAAIlF,OAAO,CAACgF,SAAS,CAACjB,YAAY,CAAC,EAAE;IACnC;IACAmB,MAAM,GAAGpB,6BAA6B,CACpCkB,SAAS,CAAChD,UAAU,EACpBgD,SAAS,CAACjB,YACZ,CAAC;EACH,CAAC,MAAM;IACLmB,MAAM,GAAGF,SAAS,CAAChD,UAAU,CAACmD,KAAK,CAAC,CAAC;EACvC;EAEA,MAAMC,UAAU,GAAGJ,SAAS,CAACK,UAAU,GAAGnB,YAAY,CAACoB,iBAAiB;EACxE,MAAMtB,MAAM,GAAGkB,MAAM,CAAClB,MAAM;EAC5B,MAAMuB,MAAM,GAAGvF,OAAO,CAACgF,SAAS,CAACQ,UAAU,CAAC,GACxCR,SAAS,CAACQ,UAAU,GAAGtB,YAAY,CAACoB,iBAAiB,GACrD,CAAC;EAEL,KAAK,IAAIjB,CAAC,GAAGe,UAAU,EAAEf,CAAC,GAAGL,MAAM,EAAEK,CAAC,IAAIkB,MAAM,EAAE;IAChD,MAAMjB,eAAe,GAAGzE,UAAU,CAAC0E,SAAS,CAACW,MAAM,EAAEb,CAAC,EAAER,eAAe,CAAC;IACxE,IACE4B,KAAK,CAACnB,eAAe,CAACM,CAAC,CAAC,IACxBa,KAAK,CAACnB,eAAe,CAACO,CAAC,CAAC,IACxBY,KAAK,CAACnB,eAAe,CAACQ,CAAC,CAAC,EACxB;MACA;IACF;IAEA,MAAMY,mBAAmB,GAAGzF,OAAO,CAACoD,eAAe,CACjDjC,WAAW,EACXkD,eAAe,EACfA,eACF,CAAC;IAED,MAAMqB,iBAAiB,GAAGrF,eAAe,CAACkD,8BAA8B,CACtE1C,UAAU,EACV4E,mBAAmB,EACnBA,mBACF,CAAC;IAED,MAAME,gBAAgB,GAAG/F,UAAU,CAACgG,QAAQ,CAC1CF,iBAAiB,EACjBV,cAAc,EACdU,iBACF,CAAC;IAEDT,MAAM,CAACb,CAAC,CAAC,GAAGuB,gBAAgB,CAAChB,CAAC;IAC9BM,MAAM,CAACb,CAAC,GAAG,CAAC,CAAC,GAAGuB,gBAAgB,CAACf,CAAC;IAClCK,MAAM,CAACb,CAAC,GAAG,CAAC,CAAC,GAAGuB,gBAAgB,CAACd,CAAC;EACpC;EAEA,OAAOI,MAAM;AACf;AAEA,SAAShD,yBAAyBA,CAChCnB,iBAAiB,EACjBK,WAAW,EACXO,gBAAgB,EAChBb,UAAU,EACV;EACA;EACA;EACA;EACA,MAAMgF,YAAY,GAAGhG,KAAK,CAACgB,UAAU,CAAC;EACtCgF,YAAY,CAACC,IAAI,GAAG5F,SAAS,CAAC6F,aAAa;;EAE3C;EACA;EACA;EACA,MAAMf,cAAc,GAAGtD,gBAAgB,CAACiB,MAAM;EAC9C,MAAMqD,kBAAkB,GAAGlB,8BAA8B,CACvDhE,iBAAiB,EACjBK,WAAW,EACX6D,cAAc,EACda,YACF,CAAC;;EAED;EACA,MAAMI,MAAM,GAAGvG,MAAM,CAACwG,kBAAkB,CAAC;IACvCtD,OAAO,EAAE/B,UAAU,CAAC+B,OAAO;IAC3Bb,UAAU,EAAEiE,kBAAkB;IAC9BG,KAAK,EAAExG,WAAW,CAACyG;EACrB,CAAC,CAAC;EACFH,MAAM,CAACI,sBAAsB,GAAG,KAAK;EAErC,OAAOJ,MAAM;AACf;AAEA,eAAezF,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}