{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT,\\n\\\n// RayShapeIntersection\\n\\\n\\n\\\nvec4 intersectLongitude(in Ray ray, in float angle, in bool positiveNormal) {\\n\\\n    float normalSign = positiveNormal ? 1.0 : -1.0;\\n\\\n    vec2 planeNormal = vec2(-sin(angle), cos(angle)) * normalSign;\\n\\\n\\n\\\n    vec2 position = ray.pos.xy;\\n\\\n    vec2 direction = ray.dir.xy;\\n\\\n    float approachRate = dot(direction, planeNormal);\\n\\\n    float distance = -dot(position, planeNormal);\\n\\\n\\n\\\n    float t = (approachRate == 0.0)\\n\\\n        ? NO_HIT\\n\\\n        : distance / approachRate;\\n\\\n\\n\\\n    return vec4(planeNormal, 0.0, t);\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectHalfSpace(in Ray ray, in float angle, in bool positiveNormal)\\n\\\n{\\n\\\n    vec4 intersection = intersectLongitude(ray, angle, positiveNormal);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    bool hitFront = (intersection.w > 0.0) == (dot(ray.pos.xy, intersection.xy) > 0.0);\\n\\\n    if (!hitFront) {\\n\\\n        return RayShapeIntersection(intersection, farSide);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(-1.0 * farSide, intersection);\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid intersectFlippedWedge(in Ray ray, in vec2 minMaxAngle, out RayShapeIntersection intersections[2])\\n\\\n{\\n\\\n    intersections[0] = intersectHalfSpace(ray, minMaxAngle.x, false);\\n\\\n    intersections[1] = intersectHalfSpace(ray, minMaxAngle.y, true);\\n\\\n}\\n\\\n\\n\\\nbool hitPositiveHalfPlane(in Ray ray, in vec4 intersection, in bool positiveNormal) {\\n\\\n    float normalSign = positiveNormal ? 1.0 : -1.0;\\n\\\n    vec2 planeDirection = vec2(intersection.y, -intersection.x) * normalSign;\\n\\\n    vec2 hit = ray.pos.xy + intersection.w * ray.dir.xy;\\n\\\n    return dot(hit, planeDirection) > 0.0;\\n\\\n}\\n\\\n\\n\\\nvoid intersectHalfPlane(in Ray ray, in float angle, out RayShapeIntersection intersections[2]) {\\n\\\n    vec4 intersection = intersectLongitude(ray, angle, true);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    if (hitPositiveHalfPlane(ray, intersection, true)) {\\n\\\n        intersections[0].entry = -1.0 * farSide;\\n\\\n        intersections[0].exit = vec4(-1.0 * intersection.xy, 0.0, intersection.w);\\n\\\n        intersections[1].entry = intersection;\\n\\\n        intersections[1].exit = farSide;\\n\\\n    } else {\\n\\\n        vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n        intersections[0].entry = -1.0 * farSide;\\n\\\n        intersections[0].exit = farSide;\\n\\\n        intersections[1].entry = miss;\\n\\\n        intersections[1].exit = miss;\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectRegularWedge(in Ray ray, in vec2 minMaxAngle)\\n\\\n{\\n\\\n    // Note: works for maxAngle > minAngle + pi, where the \\\"regular wedge\\\"\\n\\\n    // is actually a negative volume.\\n\\\n    // Compute intersections with the two planes.\\n\\\n    // Normals will point toward the \\\"outside\\\" (negative space)\\n\\\n    vec4 intersect1 = intersectLongitude(ray, minMaxAngle.x, false);\\n\\\n    vec4 intersect2 = intersectLongitude(ray, minMaxAngle.y, true);\\n\\\n\\n\\\n    // Choose intersection with smallest T as the \\\"first\\\", the other as \\\"last\\\"\\n\\\n    // Note: first or last could be in the \\\"shadow\\\" wedge, beyond the tip\\n\\\n    bool inOrder = intersect1.w <= intersect2.w;\\n\\\n    vec4 first = inOrder ? intersect1 : intersect2;\\n\\\n    vec4 last = inOrder ? intersect2 : intersect1;\\n\\\n\\n\\\n    bool firstIsAhead = first.w >= 0.0;\\n\\\n    bool startedInsideFirst = dot(ray.pos.xy, first.xy) < 0.0;\\n\\\n    bool exitFromInside = firstIsAhead == startedInsideFirst;\\n\\\n    bool lastIsAhead = last.w > 0.0;\\n\\\n    bool startedOutsideLast = dot(ray.pos.xy, last.xy) >= 0.0;\\n\\\n    bool enterFromOutside = lastIsAhead == startedOutsideLast;\\n\\\n\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n    vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n\\n\\\n    if (exitFromInside && enterFromOutside) {\\n\\\n        // Ray crosses both faces of negative wedge, exiting then entering the positive shape\\n\\\n        return RayShapeIntersection(first, last);\\n\\\n    } else if (!exitFromInside && enterFromOutside) {\\n\\\n        // Ray starts inside wedge. last is in shadow wedge, and first is actually the entry\\n\\\n        return RayShapeIntersection(-1.0 * farSide, first);\\n\\\n    } else if (exitFromInside && !enterFromOutside) {\\n\\\n        // First intersection was in the shadow wedge, so last is actually the exit\\n\\\n        return RayShapeIntersection(last, farSide);\\n\\\n    } else { // !exitFromInside && !enterFromOutside\\n\\\n        // Both intersections were in the shadow wedge\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/IntersectLongitude.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT,\\n\\\n// RayShapeIntersection\\n\\\n\\n\\\nvec4 intersectLongitude(in Ray ray, in float angle, in bool positiveNormal) {\\n\\\n    float normalSign = positiveNormal ? 1.0 : -1.0;\\n\\\n    vec2 planeNormal = vec2(-sin(angle), cos(angle)) * normalSign;\\n\\\n\\n\\\n    vec2 position = ray.pos.xy;\\n\\\n    vec2 direction = ray.dir.xy;\\n\\\n    float approachRate = dot(direction, planeNormal);\\n\\\n    float distance = -dot(position, planeNormal);\\n\\\n\\n\\\n    float t = (approachRate == 0.0)\\n\\\n        ? NO_HIT\\n\\\n        : distance / approachRate;\\n\\\n\\n\\\n    return vec4(planeNormal, 0.0, t);\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectHalfSpace(in Ray ray, in float angle, in bool positiveNormal)\\n\\\n{\\n\\\n    vec4 intersection = intersectLongitude(ray, angle, positiveNormal);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    bool hitFront = (intersection.w > 0.0) == (dot(ray.pos.xy, intersection.xy) > 0.0);\\n\\\n    if (!hitFront) {\\n\\\n        return RayShapeIntersection(intersection, farSide);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(-1.0 * farSide, intersection);\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid intersectFlippedWedge(in Ray ray, in vec2 minMaxAngle, out RayShapeIntersection intersections[2])\\n\\\n{\\n\\\n    intersections[0] = intersectHalfSpace(ray, minMaxAngle.x, false);\\n\\\n    intersections[1] = intersectHalfSpace(ray, minMaxAngle.y, true);\\n\\\n}\\n\\\n\\n\\\nbool hitPositiveHalfPlane(in Ray ray, in vec4 intersection, in bool positiveNormal) {\\n\\\n    float normalSign = positiveNormal ? 1.0 : -1.0;\\n\\\n    vec2 planeDirection = vec2(intersection.y, -intersection.x) * normalSign;\\n\\\n    vec2 hit = ray.pos.xy + intersection.w * ray.dir.xy;\\n\\\n    return dot(hit, planeDirection) > 0.0;\\n\\\n}\\n\\\n\\n\\\nvoid intersectHalfPlane(in Ray ray, in float angle, out RayShapeIntersection intersections[2]) {\\n\\\n    vec4 intersection = intersectLongitude(ray, angle, true);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    if (hitPositiveHalfPlane(ray, intersection, true)) {\\n\\\n        intersections[0].entry = -1.0 * farSide;\\n\\\n        intersections[0].exit = vec4(-1.0 * intersection.xy, 0.0, intersection.w);\\n\\\n        intersections[1].entry = intersection;\\n\\\n        intersections[1].exit = farSide;\\n\\\n    } else {\\n\\\n        vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n        intersections[0].entry = -1.0 * farSide;\\n\\\n        intersections[0].exit = farSide;\\n\\\n        intersections[1].entry = miss;\\n\\\n        intersections[1].exit = miss;\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectRegularWedge(in Ray ray, in vec2 minMaxAngle)\\n\\\n{\\n\\\n    // Note: works for maxAngle > minAngle + pi, where the \\\"regular wedge\\\"\\n\\\n    // is actually a negative volume.\\n\\\n    // Compute intersections with the two planes.\\n\\\n    // Normals will point toward the \\\"outside\\\" (negative space)\\n\\\n    vec4 intersect1 = intersectLongitude(ray, minMaxAngle.x, false);\\n\\\n    vec4 intersect2 = intersectLongitude(ray, minMaxAngle.y, true);\\n\\\n\\n\\\n    // Choose intersection with smallest T as the \\\"first\\\", the other as \\\"last\\\"\\n\\\n    // Note: first or last could be in the \\\"shadow\\\" wedge, beyond the tip\\n\\\n    bool inOrder = intersect1.w <= intersect2.w;\\n\\\n    vec4 first = inOrder ? intersect1 : intersect2;\\n\\\n    vec4 last = inOrder ? intersect2 : intersect1;\\n\\\n\\n\\\n    bool firstIsAhead = first.w >= 0.0;\\n\\\n    bool startedInsideFirst = dot(ray.pos.xy, first.xy) < 0.0;\\n\\\n    bool exitFromInside = firstIsAhead == startedInsideFirst;\\n\\\n    bool lastIsAhead = last.w > 0.0;\\n\\\n    bool startedOutsideLast = dot(ray.pos.xy, last.xy) >= 0.0;\\n\\\n    bool enterFromOutside = lastIsAhead == startedOutsideLast;\\n\\\n\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n    vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n\\n\\\n    if (exitFromInside && enterFromOutside) {\\n\\\n        // Ray crosses both faces of negative wedge, exiting then entering the positive shape\\n\\\n        return RayShapeIntersection(first, last);\\n\\\n    } else if (!exitFromInside && enterFromOutside) {\\n\\\n        // Ray starts inside wedge. last is in shadow wedge, and first is actually the entry\\n\\\n        return RayShapeIntersection(-1.0 * farSide, first);\\n\\\n    } else if (exitFromInside && !enterFromOutside) {\\n\\\n        // First intersection was in the shadow wedge, so last is actually the exit\\n\\\n        return RayShapeIntersection(last, farSide);\\n\\\n    } else { // !exitFromInside && !enterFromOutside\\n\\\n        // Both intersections were in the shadow wedge\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}