{"ast":null,"code":"import AttributeCompression from \"./AttributeCompression.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nimport getJsonFromTypedArray from \"./getJsonFromTypedArray.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport IonResource from \"./IonResource.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Request from \"./Request.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nfunction LayerInformation(layer) {\n  this.resource = layer.resource;\n  this.version = layer.version;\n  this.isHeightmap = layer.isHeightmap;\n  this.tileUrlTemplates = layer.tileUrlTemplates;\n  this.availability = layer.availability;\n  this.hasVertexNormals = layer.hasVertexNormals;\n  this.hasWaterMask = layer.hasWaterMask;\n  this.hasMetadata = layer.hasMetadata;\n  this.availabilityLevels = layer.availabilityLevels;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  this.availabilityPromiseCache = {};\n}\n\n/**\n * @typedef {Object} CesiumTerrainProvider.ConstructorOptions\n *\n * Initialization options for the CesiumTerrainProvider constructor\n *\n * @property {boolean} [requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.\n * @property {boolean} [requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server, if available.\n * @property {boolean} [requestMetadata=true] Flag that indicates if the client should request per tile metadata from the server, if available.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} options An object describing initialization options\n */\nfunction TerrainProviderBuilder(options) {\n  this.requestVertexNormals = defaultValue(options.requestVertexNormals, false);\n  this.requestWaterMask = defaultValue(options.requestWaterMask, false);\n  this.requestMetadata = defaultValue(options.requestMetadata, true);\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this.heightmapWidth = 65;\n  this.heightmapStructure = undefined;\n  this.hasWaterMask = false;\n  this.hasMetadata = false;\n  this.hasVertexNormals = false;\n  this.scheme = undefined;\n  this.lastResource = undefined;\n  this.layerJsonResource = undefined;\n  this.previousError = undefined;\n  this.availability = undefined;\n  this.tilingScheme = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.heightmapStructure = undefined;\n  this.layers = [];\n  this.attribution = \"\";\n  this.overallAvailability = [];\n  this.overallMaxZoom = 0;\n  this.tileCredits = [];\n}\n\n/**\n * Complete CesiumTerrainProvider creation based on builder values.\n *\n * @private\n *\n * @param {CesiumTerrainProvider} provider\n */\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._heightmapWidth = this.heightmapWidth;\n  provider._scheme = this.scheme;\n\n  // ion resources have a credits property we can use for additional attribution.\n  const credits = defined(this.lastResource.credits) ? this.lastResource.credits : [];\n  provider._tileCredits = credits.concat(this.tileCredits);\n  provider._availability = this.availability;\n  provider._tilingScheme = this.tilingScheme;\n  provider._requestWaterMask = this.requestWaterMask;\n  provider._levelZeroMaximumGeometricError = this.levelZeroMaximumGeometricError;\n  provider._heightmapStructure = this.heightmapStructure;\n  provider._layers = this.layers;\n  provider._hasWaterMask = this.hasWaterMask;\n  provider._hasVertexNormals = this.hasVertexNormals;\n  provider._hasMetadata = this.hasMetadata;\n};\nasync function parseMetadataSuccess(terrainProviderBuilder, data, provider) {\n  if (!data.format) {\n    const message = \"The tile format is not specified in the layer.json file.\";\n    terrainProviderBuilder.previousError = TileProviderError.reportError(terrainProviderBuilder.previousError, provider, defined(provider) ? provider._errorEvent : undefined, message);\n    throw new RuntimeError(message);\n  }\n  if (!data.tiles || data.tiles.length === 0) {\n    const message = \"The layer.json file does not specify any tile URL templates.\";\n    terrainProviderBuilder.previousError = TileProviderError.reportError(terrainProviderBuilder.previousError, provider, defined(provider) ? provider._errorEvent : undefined, message);\n    throw new RuntimeError(message);\n  }\n  let hasVertexNormals = false;\n  let hasWaterMask = false;\n  let hasMetadata = false;\n  let littleEndianExtensionSize = true;\n  let isHeightmap = false;\n  if (data.format === \"heightmap-1.0\") {\n    isHeightmap = true;\n    if (!defined(terrainProviderBuilder.heightmapStructure)) {\n      terrainProviderBuilder.heightmapStructure = {\n        heightScale: 1.0 / 5.0,\n        heightOffset: -1000.0,\n        elementsPerHeight: 1,\n        stride: 1,\n        elementMultiplier: 256.0,\n        isBigEndian: false,\n        lowestEncodedHeight: 0,\n        highestEncodedHeight: 256 * 256 - 1\n      };\n    }\n    hasWaterMask = true;\n    terrainProviderBuilder.requestWaterMask = true;\n  } else if (data.format.indexOf(\"quantized-mesh-1.\") !== 0) {\n    const message = `The tile format \"${data.format}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(terrainProviderBuilder.previousError, provider, defined(provider) ? provider._errorEvent : undefined, message);\n    throw new RuntimeError(message);\n  }\n  const tileUrlTemplates = data.tiles;\n  const maxZoom = data.maxzoom;\n  terrainProviderBuilder.overallMaxZoom = Math.max(terrainProviderBuilder.overallMaxZoom, maxZoom);\n\n  // Keeps track of which of the availability containing tiles have been loaded\n  if (!data.projection || data.projection === \"EPSG:4326\") {\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({\n      numberOfLevelZeroTilesX: 2,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: terrainProviderBuilder.ellipsoid\n    });\n  } else if (data.projection === \"EPSG:3857\") {\n    terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme({\n      numberOfLevelZeroTilesX: 1,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: terrainProviderBuilder.ellipsoid\n    });\n  } else {\n    const message = `The projection \"${data.projection}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(terrainProviderBuilder.previousError, provider, defined(provider) ? provider._errorEvent : undefined, message);\n    throw new RuntimeError(message);\n  }\n  terrainProviderBuilder.levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(terrainProviderBuilder.tilingScheme.ellipsoid, terrainProviderBuilder.heightmapWidth, terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0));\n  if (!data.scheme || data.scheme === \"tms\" || data.scheme === \"slippyMap\") {\n    terrainProviderBuilder.scheme = data.scheme;\n  } else {\n    const message = `The scheme \"${data.scheme}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(terrainProviderBuilder.previousError, provider, defined(provider) ? provider._errorEvent : undefined, message);\n    throw new RuntimeError(message);\n  }\n  let availabilityTilesLoaded;\n\n  // The vertex normals defined in the 'octvertexnormals' extension is identical to the original\n  // contents of the original 'vertexnormals' extension.  'vertexnormals' extension is now\n  // deprecated, as the extensionLength for this extension was incorrectly using big endian.\n  // We maintain backwards compatibility with the legacy 'vertexnormal' implementation\n  // by setting the _littleEndianExtensionSize to false. Always prefer 'octvertexnormals'\n  // over 'vertexnormals' if both extensions are supported by the server.\n  if (defined(data.extensions) && data.extensions.indexOf(\"octvertexnormals\") !== -1) {\n    hasVertexNormals = true;\n  } else if (defined(data.extensions) && data.extensions.indexOf(\"vertexnormals\") !== -1) {\n    hasVertexNormals = true;\n    littleEndianExtensionSize = false;\n  }\n  if (defined(data.extensions) && data.extensions.indexOf(\"watermask\") !== -1) {\n    hasWaterMask = true;\n  }\n  if (defined(data.extensions) && data.extensions.indexOf(\"metadata\") !== -1) {\n    hasMetadata = true;\n  }\n  const availabilityLevels = data.metadataAvailability;\n  const availableTiles = data.available;\n  let availability;\n  if (defined(availableTiles) && !defined(availabilityLevels)) {\n    availability = new TileAvailability(terrainProviderBuilder.tilingScheme, availableTiles.length);\n    for (let level = 0; level < availableTiles.length; ++level) {\n      const rangesAtLevel = availableTiles[level];\n      const yTiles = terrainProviderBuilder.tilingScheme.getNumberOfYTilesAtLevel(level);\n      if (!defined(terrainProviderBuilder.overallAvailability[level])) {\n        terrainProviderBuilder.overallAvailability[level] = [];\n      }\n      for (let rangeIndex = 0; rangeIndex < rangesAtLevel.length; ++rangeIndex) {\n        const range = rangesAtLevel[rangeIndex];\n        const yStart = yTiles - range.endY - 1;\n        const yEnd = yTiles - range.startY - 1;\n        terrainProviderBuilder.overallAvailability[level].push([range.startX, yStart, range.endX, yEnd]);\n        availability.addAvailableTileRange(level, range.startX, yStart, range.endX, yEnd);\n      }\n    }\n  } else if (defined(availabilityLevels)) {\n    availabilityTilesLoaded = new TileAvailability(terrainProviderBuilder.tilingScheme, maxZoom);\n    availability = new TileAvailability(terrainProviderBuilder.tilingScheme, maxZoom);\n    terrainProviderBuilder.overallAvailability[0] = [[0, 0, 1, 0]];\n    availability.addAvailableTileRange(0, 0, 0, 1, 0);\n  }\n  terrainProviderBuilder.hasWaterMask = terrainProviderBuilder.hasWaterMask || hasWaterMask;\n  terrainProviderBuilder.hasVertexNormals = terrainProviderBuilder.hasVertexNormals || hasVertexNormals;\n  terrainProviderBuilder.hasMetadata = terrainProviderBuilder.hasMetadata || hasMetadata;\n  if (defined(data.attribution)) {\n    if (terrainProviderBuilder.attribution.length > 0) {\n      terrainProviderBuilder.attribution += \" \";\n    }\n    terrainProviderBuilder.attribution += data.attribution;\n  }\n  terrainProviderBuilder.layers.push(new LayerInformation({\n    resource: terrainProviderBuilder.lastResource,\n    version: data.version,\n    isHeightmap: isHeightmap,\n    tileUrlTemplates: tileUrlTemplates,\n    availability: availability,\n    hasVertexNormals: hasVertexNormals,\n    hasWaterMask: hasWaterMask,\n    hasMetadata: hasMetadata,\n    availabilityLevels: availabilityLevels,\n    availabilityTilesLoaded: availabilityTilesLoaded,\n    littleEndianExtensionSize: littleEndianExtensionSize\n  }));\n  const parentUrl = data.parentUrl;\n  if (defined(parentUrl)) {\n    if (!defined(availability)) {\n      console.log(\"A layer.json can't have a parentUrl if it does't have an available array.\");\n      return true;\n    }\n    terrainProviderBuilder.lastResource = terrainProviderBuilder.lastResource.getDerivedResource({\n      url: parentUrl\n    });\n    terrainProviderBuilder.lastResource.appendForwardSlash(); // Terrain always expects a directory\n    terrainProviderBuilder.layerJsonResource = terrainProviderBuilder.lastResource.getDerivedResource({\n      url: \"layer.json\"\n    });\n    await requestLayerJson(terrainProviderBuilder);\n    return true;\n  }\n  return true;\n}\nfunction parseMetadataFailure(terrainProviderBuilder, error, provider) {\n  let message = `An error occurred while accessing ${terrainProviderBuilder.layerJsonResource.url}.`;\n  if (defined(error)) {\n    message += `\\n${error.message}`;\n  }\n  terrainProviderBuilder.previousError = TileProviderError.reportError(terrainProviderBuilder.previousError, provider, defined(provider) ? provider._errorEvent : undefined, message);\n\n  // If we can retry, do so. Otherwise throw the error.\n  if (terrainProviderBuilder.previousError.retry) {\n    return requestLayerJson(terrainProviderBuilder, provider);\n  }\n  throw new RuntimeError(message);\n}\nasync function metadataSuccess(terrainProviderBuilder, data, provider) {\n  await parseMetadataSuccess(terrainProviderBuilder, data, provider);\n  const length = terrainProviderBuilder.overallAvailability.length;\n  if (length > 0) {\n    const availability = terrainProviderBuilder.availability = new TileAvailability(terrainProviderBuilder.tilingScheme, terrainProviderBuilder.overallMaxZoom);\n    for (let level = 0; level < length; ++level) {\n      const levelRanges = terrainProviderBuilder.overallAvailability[level];\n      for (let i = 0; i < levelRanges.length; ++i) {\n        const range = levelRanges[i];\n        availability.addAvailableTileRange(level, range[0], range[1], range[2], range[3]);\n      }\n    }\n  }\n  if (terrainProviderBuilder.attribution.length > 0) {\n    const layerJsonCredit = new Credit(terrainProviderBuilder.attribution);\n    terrainProviderBuilder.tileCredits.push(layerJsonCredit);\n  }\n  return true;\n}\nasync function requestLayerJson(terrainProviderBuilder, provider) {\n  try {\n    const data = await terrainProviderBuilder.layerJsonResource.fetchJson();\n    return metadataSuccess(terrainProviderBuilder, data, provider);\n  } catch (error) {\n    // If the metadata is not found, assume this is a pre-metadata heightmap tileset.\n    if (defined(error) && error.statusCode === 404) {\n      await parseMetadataSuccess(terrainProviderBuilder, {\n        tilejson: \"2.1.0\",\n        format: \"heightmap-1.0\",\n        version: \"1.0.0\",\n        scheme: \"tms\",\n        tiles: [\"{z}/{x}/{y}.terrain?v={version}\"]\n      }, provider);\n      return true;\n    }\n    return parseMetadataFailure(terrainProviderBuilder, error, provider);\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a CesiumTerrainProvider, call {@link CesiumTerrainProvider.fromIonAssetId} or {@link CesiumTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @alias CesiumTerrainProvider\n * @constructor\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *       requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @see createWorldTerrain\n * @see CesiumTerrainProvider.fromUrl\n * @see CesiumTerrainProvider.fromIonAssetId\n * @see TerrainProvider\n */\nfunction CesiumTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._heightmapWidth = undefined;\n  this._heightmapStructure = undefined;\n  this._hasWaterMask = false;\n  this._hasVertexNormals = false;\n  this._hasMetadata = false;\n  this._scheme = undefined;\n  this._ellipsoid = options.ellipsoid;\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  this._requestVertexNormals = defaultValue(options.requestVertexNormals, false);\n\n  /**\n   * Boolean flag that indicates if the client should request tile watermasks from the server.\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  this._requestWaterMask = defaultValue(options.requestWaterMask, false);\n\n  /**\n   * Boolean flag that indicates if the client should request tile metadata from the server.\n   * @type {boolean}\n   * @default true\n   * @private\n   */\n  this._requestMetadata = defaultValue(options.requestMetadata, true);\n  this._errorEvent = new Event();\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n  this._availability = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._layers = undefined;\n  this._tileCredits = undefined;\n}\n\n/**\n * When using the Quantized-Mesh format, a tile may be returned that includes additional extensions, such as PerVertexNormals, watermask, etc.\n * This enumeration defines the unique identifiers for each type of extension data that has been appended to the standard mesh data.\n *\n * @namespace QuantizedMeshExtensionIds\n * @see CesiumTerrainProvider\n * @private\n */\nconst QuantizedMeshExtensionIds = {\n  /**\n   * Oct-Encoded Per-Vertex Normals are included as an extension to the tile mesh\n   *\n   * @type {number}\n   * @constant\n   * @default 1\n   */\n  OCT_VERTEX_NORMALS: 1,\n  /**\n   * A watermask is included as an extension to the tile mesh\n   *\n   * @type {number}\n   * @constant\n   * @default 2\n   */\n  WATER_MASK: 2,\n  /**\n   * A json object contain metadata about the tile\n   *\n   * @type {number}\n   * @constant\n   * @default 4\n   */\n  METADATA: 4\n};\nfunction getRequestHeader(extensionsList) {\n  if (!defined(extensionsList) || extensionsList.length === 0) {\n    return {\n      Accept: \"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01\"\n    };\n  }\n  const extensions = extensionsList.join(\"-\");\n  return {\n    Accept: `application/vnd.quantized-mesh;extensions=${extensions},application/octet-stream;q=0.9,*/*;q=0.01`\n  };\n}\nfunction createHeightmapTerrainData(provider, buffer, level, x, y) {\n  const heightBuffer = new Uint16Array(buffer, 0, provider._heightmapWidth * provider._heightmapWidth);\n  return new HeightmapTerrainData({\n    buffer: heightBuffer,\n    childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],\n    waterMask: new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1),\n    width: provider._heightmapWidth,\n    height: provider._heightmapWidth,\n    structure: provider._heightmapStructure,\n    credits: provider._tileCredits\n  });\n}\nfunction createQuantizedMeshTerrainData(provider, buffer, level, x, y, layer) {\n  const littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  let pos = 0;\n  const cartesian3Elements = 3;\n  const boundingSphereElements = cartesian3Elements + 1;\n  const cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;\n  const boundingSphereLength = Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;\n  const encodedVertexElements = 3;\n  const encodedVertexLength = Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;\n  const triangleElements = 3;\n  let bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;\n  let triangleLength = bytesPerIndex * triangleElements;\n  const view = new DataView(buffer);\n  const center = new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));\n  pos += cartesian3Length;\n  const minimumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  const maximumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  const boundingSphere = new BoundingSphere(new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true)), view.getFloat64(pos + cartesian3Length, true));\n  pos += boundingSphereLength;\n  const horizonOcclusionPoint = new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));\n  pos += cartesian3Length;\n  const vertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);\n  pos += vertexCount * encodedVertexLength;\n  if (vertexCount > 64 * 1024) {\n    // More than 64k vertices, so indices are 32-bit.\n    bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;\n    triangleLength = bytesPerIndex * triangleElements;\n  }\n\n  // Decode the vertex buffer.\n  const uBuffer = encodedVertexBuffer.subarray(0, vertexCount);\n  const vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);\n  const heightBuffer = encodedVertexBuffer.subarray(vertexCount * 2, 3 * vertexCount);\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  // skip over any additional padding that was added for 2/4 byte alignment\n  if (pos % bytesPerIndex !== 0) {\n    pos += bytesPerIndex - pos % bytesPerIndex;\n  }\n  const triangleCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const indices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, triangleCount * triangleElements);\n  pos += triangleCount * triangleLength;\n\n  // High water mark decoding based on decompressIndices_ in webgl-loader's loader.js.\n  // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n  // Copyright 2012 Google Inc., Apache 2.0 license.\n  let highest = 0;\n  const length = indices.length;\n  for (let i = 0; i < length; ++i) {\n    const code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n  const westVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const westIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, westVertexCount);\n  pos += westVertexCount * bytesPerIndex;\n  const southVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const southIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, southVertexCount);\n  pos += southVertexCount * bytesPerIndex;\n  const eastVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const eastIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, eastVertexCount);\n  pos += eastVertexCount * bytesPerIndex;\n  const northVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const northIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, northVertexCount);\n  pos += northVertexCount * bytesPerIndex;\n  let encodedNormalBuffer;\n  let waterMaskBuffer;\n  while (pos < view.byteLength) {\n    const extensionId = view.getUint8(pos, true);\n    pos += Uint8Array.BYTES_PER_ELEMENT;\n    const extensionLength = view.getUint32(pos, littleEndianExtensionSize);\n    pos += Uint32Array.BYTES_PER_ELEMENT;\n    if (extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS && provider._requestVertexNormals) {\n      encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);\n    } else if (extensionId === QuantizedMeshExtensionIds.WATER_MASK && provider._requestWaterMask) {\n      waterMaskBuffer = new Uint8Array(buffer, pos, extensionLength);\n    } else if (extensionId === QuantizedMeshExtensionIds.METADATA && provider._requestMetadata) {\n      const stringLength = view.getUint32(pos, true);\n      if (stringLength > 0) {\n        const metadata = getJsonFromTypedArray(new Uint8Array(buffer), pos + Uint32Array.BYTES_PER_ELEMENT, stringLength);\n        const availableTiles = metadata.available;\n        if (defined(availableTiles)) {\n          for (let offset = 0; offset < availableTiles.length; ++offset) {\n            const availableLevel = level + offset + 1;\n            const rangesAtLevel = availableTiles[offset];\n            const yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(availableLevel);\n            for (let rangeIndex = 0; rangeIndex < rangesAtLevel.length; ++rangeIndex) {\n              const range = rangesAtLevel[rangeIndex];\n              const yStart = yTiles - range.endY - 1;\n              const yEnd = yTiles - range.startY - 1;\n              provider.availability.addAvailableTileRange(availableLevel, range.startX, yStart, range.endX, yEnd);\n              layer.availability.addAvailableTileRange(availableLevel, range.startX, yStart, range.endX, yEnd);\n            }\n          }\n        }\n      }\n      layer.availabilityTilesLoaded.addAvailableTileRange(level, x, y, x, y);\n    }\n    pos += extensionLength;\n  }\n  const skirtHeight = provider.getLevelMaximumGeometricError(level) * 5.0;\n\n  // The skirt is not included in the OBB computation. If this ever\n  // causes any rendering artifacts (cracks), they are expected to be\n  // minor and in the corners of the screen. It's possible that this\n  // might need to be changed - just change to `minimumHeight - skirtHeight`\n  // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.\n  const rectangle = provider._tilingScheme.tileXYToRectangle(x, y, level);\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, provider._tilingScheme.ellipsoid);\n  return new QuantizedMeshTerrainData({\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    horizonOcclusionPoint: horizonOcclusionPoint,\n    quantizedVertices: encodedVertexBuffer,\n    encodedNormals: encodedNormalBuffer,\n    indices: indices,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices,\n    westSkirtHeight: skirtHeight,\n    southSkirtHeight: skirtHeight,\n    eastSkirtHeight: skirtHeight,\n    northSkirtHeight: skirtHeight,\n    childTileMask: provider.availability.computeChildMaskForTile(level, x, y),\n    waterMask: waterMaskBuffer,\n    credits: provider._tileCredits\n  });\n}\n\n/**\n * Requests the geometry for a given tile. The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n */\nCesiumTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  const layers = this._layers;\n  let layerToUse;\n  const layerCount = layers.length;\n  let unknownAvailability = false;\n  let availabilityPromise = Promise.resolve();\n  if (layerCount === 1) {\n    // Optimized path for single layers\n    layerToUse = layers[0];\n  } else {\n    for (let i = 0; i < layerCount; ++i) {\n      const layer = layers[i];\n      if (!defined(layer.availability) || layer.availability.isTileAvailable(level, x, y)) {\n        layerToUse = layer;\n        break;\n      }\n      const availabilityUnloaded = checkLayer(this, x, y, level, layer, i === 0);\n      if (availabilityUnloaded.result) {\n        // We can't know yet since the availability is not yet loaded\n        unknownAvailability = true;\n        availabilityPromise = availabilityPromise.then(() => availabilityUnloaded.promise);\n      }\n    }\n  }\n  if (!defined(layerToUse) && unknownAvailability) {\n    // Try again when availability data is ready– Otherwise the tile will be marked as failed and never re-requested\n    return availabilityPromise.then(() => {\n      // handle promise or undefined return\n      return new Promise(resolve => {\n        // defer execution to the next event loop\n        setTimeout(() => {\n          const promise = this.requestTileGeometry(x, y, level, request);\n          resolve(promise);\n        }, 0); // next tick\n      });\n    });\n  }\n  // call overridden function below\n  return requestTileGeometry(this, x, y, level, layerToUse, request);\n};\nfunction requestTileGeometry(provider, x, y, level, layerToUse, request) {\n  if (!defined(layerToUse)) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n  const urlTemplates = layerToUse.tileUrlTemplates;\n  if (urlTemplates.length === 0) {\n    return undefined;\n  }\n\n  // The TileMapService scheme counts from the bottom left\n  let terrainY;\n  if (!provider._scheme || provider._scheme === \"tms\") {\n    const yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);\n    terrainY = yTiles - y - 1;\n  } else {\n    terrainY = y;\n  }\n  const extensionList = [];\n  if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {\n    extensionList.push(layerToUse.littleEndianExtensionSize ? \"octvertexnormals\" : \"vertexnormals\");\n  }\n  if (provider._requestWaterMask && layerToUse.hasWaterMask) {\n    extensionList.push(\"watermask\");\n  }\n  if (provider._requestMetadata && layerToUse.hasMetadata) {\n    extensionList.push(\"metadata\");\n  }\n  let headers;\n  let query;\n  const url = urlTemplates[(x + terrainY + level) % urlTemplates.length];\n  const resource = layerToUse.resource;\n  if (defined(resource._ionEndpoint) && !defined(resource._ionEndpoint.externalType)) {\n    // ion uses query parameters to request extensions\n    if (extensionList.length !== 0) {\n      query = {\n        extensions: extensionList.join(\"-\")\n      };\n    }\n    headers = getRequestHeader(undefined);\n  } else {\n    //All other terrain servers\n    headers = getRequestHeader(extensionList);\n  }\n  const promise = resource.getDerivedResource({\n    url: url,\n    templateValues: {\n      version: layerToUse.version,\n      z: level,\n      x: x,\n      y: terrainY\n    },\n    queryParameters: query,\n    headers: headers,\n    request: request\n  }).fetchArrayBuffer();\n  if (!defined(promise)) {\n    return undefined;\n  }\n  return promise.then(function (buffer) {\n    if (!defined(buffer)) {\n      return Promise.reject(new RuntimeError(\"Mesh buffer doesn't exist.\"));\n    }\n    if (defined(provider._heightmapStructure)) {\n      return createHeightmapTerrainData(provider, buffer, level, x, y);\n    }\n    return createQuantizedMeshTerrainData(provider, buffer, level, x, y, layerToUse);\n  });\n}\nObject.defineProperties(CesiumTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return this._hasWaterMask && this._requestWaterMask;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      // returns true if we can request vertex normals from the server\n      return this._hasVertexNormals && this._requestVertexNormals;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the requested tiles include metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasMetadata: {\n    get: function () {\n      // returns true if we can request metadata from the server\n      return this._hasMetadata && this._requestMetadata;\n    }\n  },\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and\n   * if the server provides vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestVertexNormals: {\n    get: function () {\n      return this._requestVertexNormals;\n    }\n  },\n  /**\n   * Boolean flag that indicates if the client should request a watermask from the server.\n   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and\n   * if the server provides a watermask.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestWaterMask: {\n    get: function () {\n      return this._requestWaterMask;\n    }\n  },\n  /**\n   * Boolean flag that indicates if the client should request metadata from the server.\n   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and\n   * if the server provides a metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestMetadata: {\n    get: function () {\n      return this._requestMetadata;\n    }\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available. Note that this reflects tiles that are known to be available currently.\n   * Additional tiles may be discovered to be available in the future, e.g. if availability information\n   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that\n   * is available now will not become unavailable in the future.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return this._availability;\n    }\n  }\n});\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nCesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium terrain format\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @param {number} assetId The Cesium ion asset id.\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<CesiumTerrainProvider>}\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @exception {RuntimeError} layer.json does not specify a format\n * @exception {RuntimeError} layer.json specifies an unknown format\n * @exception {RuntimeError} layer.json specifies an unsupported quantized-mesh version\n * @exception {RuntimeError} layer.json does not specify a tiles property, or specifies an empty array\n * @exception {RuntimeError} layer.json does not specify any tile URL templates\n */\nCesiumTerrainProvider.fromIonAssetId = async function (assetId, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"assetId\", assetId);\n  //>>includeEnd('debug');\n\n  const resource = await IonResource.fromAssetId(assetId);\n  return CesiumTerrainProvider.fromUrl(resource, options);\n};\n\n/**\n * Creates a {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @param {Resource|String|Promise<Resource>|Promise<String>} url The URL of the Cesium terrain server.\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<CesiumTerrainProvider>}\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @exception {RuntimeError} layer.json does not specify a format\n * @exception {RuntimeError} layer.json specifies an unknown format\n * @exception {RuntimeError} layer.json specifies an unsupported quantized-mesh version\n * @exception {RuntimeError} layer.json does not specify a tiles property, or specifies an empty array\n * @exception {RuntimeError} layer.json does not specify any tile URL templates\n */\nCesiumTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  url = await Promise.resolve(url);\n  const resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  terrainProviderBuilder.lastResource = resource;\n  terrainProviderBuilder.layerJsonResource = terrainProviderBuilder.lastResource.getDerivedResource({\n    url: \"layer.json\"\n  });\n  await requestLayerJson(terrainProviderBuilder);\n  const provider = new CesiumTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n  return provider;\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported or availability is unknown, otherwise true or false.\n */\nCesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!defined(this._availability)) {\n    return undefined;\n  }\n  if (level > this._availability._maximumLevel) {\n    return false;\n  }\n  if (this._availability.isTileAvailable(level, x, y)) {\n    // If the tile is listed as available, then we are done\n    return true;\n  }\n  if (!this._hasMetadata) {\n    // If we don't have any layers with the metadata extension then we don't have this tile\n    return false;\n  }\n  const layers = this._layers;\n  const count = layers.length;\n  for (let i = 0; i < count; ++i) {\n    const layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (layerResult.result) {\n      // There is a layer that may or may not have the tile\n      return undefined;\n    }\n  }\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nCesiumTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  if (!defined(this._availability) || level > this._availability._maximumLevel || this._availability.isTileAvailable(level, x, y) || !this._hasMetadata) {\n    // We know the tile is either available or not available so nothing to wait on\n    return undefined;\n  }\n  const layers = this._layers;\n  const count = layers.length;\n  for (let i = 0; i < count; ++i) {\n    const layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (defined(layerResult.promise)) {\n      return layerResult.promise;\n    }\n  }\n};\nfunction getAvailabilityTile(layer, x, y, level) {\n  if (level === 0) {\n    return;\n  }\n  const availabilityLevels = layer.availabilityLevels;\n  const parentLevel = level % availabilityLevels === 0 ? level - availabilityLevels : (level / availabilityLevels | 0) * availabilityLevels;\n  const divisor = 1 << level - parentLevel;\n  const parentX = x / divisor | 0;\n  const parentY = y / divisor | 0;\n  return {\n    level: parentLevel,\n    x: parentX,\n    y: parentY\n  };\n}\nfunction checkLayer(provider, x, y, level, layer, topLayer) {\n  if (!defined(layer.availabilityLevels)) {\n    // It's definitely not in this layer\n    return {\n      result: false\n    };\n  }\n  let cacheKey;\n  const deleteFromCache = function () {\n    delete layer.availabilityPromiseCache[cacheKey];\n  };\n  const availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  const availability = layer.availability;\n  let tile = getAvailabilityTile(layer, x, y, level);\n  while (defined(tile)) {\n    if (availability.isTileAvailable(tile.level, tile.x, tile.y) && !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)) {\n      let requestPromise;\n      if (!topLayer) {\n        cacheKey = `${tile.level}-${tile.x}-${tile.y}`;\n        requestPromise = layer.availabilityPromiseCache[cacheKey];\n        if (!defined(requestPromise)) {\n          // For cutout terrain, if this isn't the top layer the availability tiles\n          //  may never get loaded, so request it here.\n          const request = new Request({\n            throttle: false,\n            throttleByServer: true,\n            type: RequestType.TERRAIN\n          });\n          requestPromise = requestTileGeometry(provider, tile.x, tile.y, tile.level, layer, request);\n          if (defined(requestPromise)) {\n            layer.availabilityPromiseCache[cacheKey] = requestPromise;\n            requestPromise.then(deleteFromCache);\n          }\n        }\n      }\n\n      // The availability tile is available, but not loaded, so there\n      //  is still a chance that it may become available at some point\n      return {\n        result: true,\n        promise: requestPromise\n      };\n    }\n    tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);\n  }\n  return {\n    result: false\n  };\n}\n\n// Used for testing\nCesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;\nexport default CesiumTerrainProvider;","map":{"version":3,"names":["AttributeCompression","BoundingSphere","Cartesian3","Check","Credit","defaultValue","defined","Ellipsoid","Event","GeographicTilingScheme","WebMercatorTilingScheme","getJsonFromTypedArray","HeightmapTerrainData","IndexDatatype","IonResource","OrientedBoundingBox","QuantizedMeshTerrainData","Request","RequestType","Resource","RuntimeError","TerrainProvider","TileAvailability","TileProviderError","LayerInformation","layer","resource","version","isHeightmap","tileUrlTemplates","availability","hasVertexNormals","hasWaterMask","hasMetadata","availabilityLevels","availabilityTilesLoaded","littleEndianExtensionSize","availabilityPromiseCache","TerrainProviderBuilder","options","requestVertexNormals","requestWaterMask","requestMetadata","ellipsoid","default","heightmapWidth","heightmapStructure","undefined","scheme","lastResource","layerJsonResource","previousError","tilingScheme","levelZeroMaximumGeometricError","layers","attribution","overallAvailability","overallMaxZoom","tileCredits","prototype","build","provider","_heightmapWidth","_scheme","credits","_tileCredits","concat","_availability","_tilingScheme","_requestWaterMask","_levelZeroMaximumGeometricError","_heightmapStructure","_layers","_hasWaterMask","_hasVertexNormals","_hasMetadata","parseMetadataSuccess","terrainProviderBuilder","data","format","message","reportError","_errorEvent","tiles","length","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","lowestEncodedHeight","highestEncodedHeight","indexOf","maxZoom","maxzoom","Math","max","projection","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","extensions","metadataAvailability","availableTiles","available","level","rangesAtLevel","yTiles","getNumberOfYTilesAtLevel","rangeIndex","range","yStart","endY","yEnd","startY","push","startX","endX","addAvailableTileRange","parentUrl","console","log","getDerivedResource","url","appendForwardSlash","requestLayerJson","parseMetadataFailure","error","retry","metadataSuccess","levelRanges","i","layerJsonCredit","fetchJson","statusCode","tilejson","CesiumTerrainProvider","EMPTY_OBJECT","_ellipsoid","_requestVertexNormals","_requestMetadata","credit","_credit","QuantizedMeshExtensionIds","OCT_VERTEX_NORMALS","WATER_MASK","METADATA","getRequestHeader","extensionsList","Accept","join","createHeightmapTerrainData","buffer","x","y","heightBuffer","Uint16Array","childTileMask","Uint8Array","byteLength","waterMask","width","height","structure","createQuantizedMeshTerrainData","pos","cartesian3Elements","boundingSphereElements","cartesian3Length","Float64Array","BYTES_PER_ELEMENT","boundingSphereLength","encodedVertexElements","encodedVertexLength","triangleElements","bytesPerIndex","triangleLength","view","DataView","center","getFloat64","minimumHeight","getFloat32","Float32Array","maximumHeight","boundingSphere","horizonOcclusionPoint","vertexCount","getUint32","Uint32Array","encodedVertexBuffer","uBuffer","subarray","vBuffer","zigZagDeltaDecode","triangleCount","indices","createTypedArrayFromArrayBuffer","highest","code","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","encodedNormalBuffer","waterMaskBuffer","extensionId","getUint8","extensionLength","stringLength","metadata","offset","availableLevel","skirtHeight","getLevelMaximumGeometricError","rectangle","tileXYToRectangle","orientedBoundingBox","fromRectangle","quantizedVertices","encodedNormals","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","computeChildMaskForTile","requestTileGeometry","request","layerToUse","layerCount","unknownAvailability","availabilityPromise","Promise","resolve","isTileAvailable","availabilityUnloaded","checkLayer","result","then","promise","setTimeout","reject","urlTemplates","terrainY","extensionList","headers","query","_ionEndpoint","externalType","templateValues","z","queryParameters","fetchArrayBuffer","Object","defineProperties","errorEvent","get","fromIonAssetId","assetId","fromAssetId","fromUrl","createIfNeeded","getTileDataAvailable","_maximumLevel","count","layerResult","loadTileDataAvailability","getAvailabilityTile","parentLevel","divisor","parentX","parentY","topLayer","cacheKey","deleteFromCache","tile","requestPromise","throttle","throttleByServer","type","TERRAIN","_getAvailabilityTile"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CesiumTerrainProvider.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nimport getJsonFromTypedArray from \"./getJsonFromTypedArray.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport IonResource from \"./IonResource.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Request from \"./Request.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nfunction LayerInformation(layer) {\n  this.resource = layer.resource;\n  this.version = layer.version;\n  this.isHeightmap = layer.isHeightmap;\n  this.tileUrlTemplates = layer.tileUrlTemplates;\n  this.availability = layer.availability;\n  this.hasVertexNormals = layer.hasVertexNormals;\n  this.hasWaterMask = layer.hasWaterMask;\n  this.hasMetadata = layer.hasMetadata;\n  this.availabilityLevels = layer.availabilityLevels;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  this.availabilityPromiseCache = {};\n}\n\n/**\n * @typedef {Object} CesiumTerrainProvider.ConstructorOptions\n *\n * Initialization options for the CesiumTerrainProvider constructor\n *\n * @property {boolean} [requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.\n * @property {boolean} [requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server, if available.\n * @property {boolean} [requestMetadata=true] Flag that indicates if the client should request per tile metadata from the server, if available.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} options An object describing initialization options\n */\nfunction TerrainProviderBuilder(options) {\n  this.requestVertexNormals = defaultValue(options.requestVertexNormals, false);\n  this.requestWaterMask = defaultValue(options.requestWaterMask, false);\n  this.requestMetadata = defaultValue(options.requestMetadata, true);\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n\n  this.heightmapWidth = 65;\n  this.heightmapStructure = undefined;\n  this.hasWaterMask = false;\n  this.hasMetadata = false;\n  this.hasVertexNormals = false;\n  this.scheme = undefined;\n\n  this.lastResource = undefined;\n  this.layerJsonResource = undefined;\n  this.previousError = undefined;\n  this.availability = undefined;\n  this.tilingScheme = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.heightmapStructure = undefined;\n  this.layers = [];\n  this.attribution = \"\";\n  this.overallAvailability = [];\n  this.overallMaxZoom = 0;\n  this.tileCredits = [];\n}\n\n/**\n * Complete CesiumTerrainProvider creation based on builder values.\n *\n * @private\n *\n * @param {CesiumTerrainProvider} provider\n */\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._heightmapWidth = this.heightmapWidth;\n  provider._scheme = this.scheme;\n\n  // ion resources have a credits property we can use for additional attribution.\n  const credits = defined(this.lastResource.credits)\n    ? this.lastResource.credits\n    : [];\n  provider._tileCredits = credits.concat(this.tileCredits);\n  provider._availability = this.availability;\n  provider._tilingScheme = this.tilingScheme;\n  provider._requestWaterMask = this.requestWaterMask;\n  provider._levelZeroMaximumGeometricError =\n    this.levelZeroMaximumGeometricError;\n  provider._heightmapStructure = this.heightmapStructure;\n  provider._layers = this.layers;\n\n  provider._hasWaterMask = this.hasWaterMask;\n  provider._hasVertexNormals = this.hasVertexNormals;\n  provider._hasMetadata = this.hasMetadata;\n};\n\nasync function parseMetadataSuccess(terrainProviderBuilder, data, provider) {\n  if (!data.format) {\n    const message = \"The tile format is not specified in the layer.json file.\";\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  if (!data.tiles || data.tiles.length === 0) {\n    const message =\n      \"The layer.json file does not specify any tile URL templates.\";\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  let hasVertexNormals = false;\n  let hasWaterMask = false;\n  let hasMetadata = false;\n  let littleEndianExtensionSize = true;\n  let isHeightmap = false;\n  if (data.format === \"heightmap-1.0\") {\n    isHeightmap = true;\n    if (!defined(terrainProviderBuilder.heightmapStructure)) {\n      terrainProviderBuilder.heightmapStructure = {\n        heightScale: 1.0 / 5.0,\n        heightOffset: -1000.0,\n        elementsPerHeight: 1,\n        stride: 1,\n        elementMultiplier: 256.0,\n        isBigEndian: false,\n        lowestEncodedHeight: 0,\n        highestEncodedHeight: 256 * 256 - 1,\n      };\n    }\n    hasWaterMask = true;\n    terrainProviderBuilder.requestWaterMask = true;\n  } else if (data.format.indexOf(\"quantized-mesh-1.\") !== 0) {\n    const message = `The tile format \"${data.format}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  const tileUrlTemplates = data.tiles;\n\n  const maxZoom = data.maxzoom;\n  terrainProviderBuilder.overallMaxZoom = Math.max(\n    terrainProviderBuilder.overallMaxZoom,\n    maxZoom,\n  );\n\n  // Keeps track of which of the availability containing tiles have been loaded\n  if (!data.projection || data.projection === \"EPSG:4326\") {\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({\n      numberOfLevelZeroTilesX: 2,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: terrainProviderBuilder.ellipsoid,\n    });\n  } else if (data.projection === \"EPSG:3857\") {\n    terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme({\n      numberOfLevelZeroTilesX: 1,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: terrainProviderBuilder.ellipsoid,\n    });\n  } else {\n    const message = `The projection \"${data.projection}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  terrainProviderBuilder.levelZeroMaximumGeometricError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      terrainProviderBuilder.tilingScheme.ellipsoid,\n      terrainProviderBuilder.heightmapWidth,\n      terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n  if (!data.scheme || data.scheme === \"tms\" || data.scheme === \"slippyMap\") {\n    terrainProviderBuilder.scheme = data.scheme;\n  } else {\n    const message = `The scheme \"${data.scheme}\" is invalid or not supported.`;\n    terrainProviderBuilder.previousError = TileProviderError.reportError(\n      terrainProviderBuilder.previousError,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw new RuntimeError(message);\n  }\n\n  let availabilityTilesLoaded;\n\n  // The vertex normals defined in the 'octvertexnormals' extension is identical to the original\n  // contents of the original 'vertexnormals' extension.  'vertexnormals' extension is now\n  // deprecated, as the extensionLength for this extension was incorrectly using big endian.\n  // We maintain backwards compatibility with the legacy 'vertexnormal' implementation\n  // by setting the _littleEndianExtensionSize to false. Always prefer 'octvertexnormals'\n  // over 'vertexnormals' if both extensions are supported by the server.\n  if (\n    defined(data.extensions) &&\n    data.extensions.indexOf(\"octvertexnormals\") !== -1\n  ) {\n    hasVertexNormals = true;\n  } else if (\n    defined(data.extensions) &&\n    data.extensions.indexOf(\"vertexnormals\") !== -1\n  ) {\n    hasVertexNormals = true;\n    littleEndianExtensionSize = false;\n  }\n  if (defined(data.extensions) && data.extensions.indexOf(\"watermask\") !== -1) {\n    hasWaterMask = true;\n  }\n  if (defined(data.extensions) && data.extensions.indexOf(\"metadata\") !== -1) {\n    hasMetadata = true;\n  }\n\n  const availabilityLevels = data.metadataAvailability;\n  const availableTiles = data.available;\n  let availability;\n  if (defined(availableTiles) && !defined(availabilityLevels)) {\n    availability = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      availableTiles.length,\n    );\n    for (let level = 0; level < availableTiles.length; ++level) {\n      const rangesAtLevel = availableTiles[level];\n      const yTiles =\n        terrainProviderBuilder.tilingScheme.getNumberOfYTilesAtLevel(level);\n      if (!defined(terrainProviderBuilder.overallAvailability[level])) {\n        terrainProviderBuilder.overallAvailability[level] = [];\n      }\n\n      for (\n        let rangeIndex = 0;\n        rangeIndex < rangesAtLevel.length;\n        ++rangeIndex\n      ) {\n        const range = rangesAtLevel[rangeIndex];\n        const yStart = yTiles - range.endY - 1;\n        const yEnd = yTiles - range.startY - 1;\n        terrainProviderBuilder.overallAvailability[level].push([\n          range.startX,\n          yStart,\n          range.endX,\n          yEnd,\n        ]);\n        availability.addAvailableTileRange(\n          level,\n          range.startX,\n          yStart,\n          range.endX,\n          yEnd,\n        );\n      }\n    }\n  } else if (defined(availabilityLevels)) {\n    availabilityTilesLoaded = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      maxZoom,\n    );\n    availability = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      maxZoom,\n    );\n    terrainProviderBuilder.overallAvailability[0] = [[0, 0, 1, 0]];\n    availability.addAvailableTileRange(0, 0, 0, 1, 0);\n  }\n\n  terrainProviderBuilder.hasWaterMask =\n    terrainProviderBuilder.hasWaterMask || hasWaterMask;\n  terrainProviderBuilder.hasVertexNormals =\n    terrainProviderBuilder.hasVertexNormals || hasVertexNormals;\n  terrainProviderBuilder.hasMetadata =\n    terrainProviderBuilder.hasMetadata || hasMetadata;\n\n  if (defined(data.attribution)) {\n    if (terrainProviderBuilder.attribution.length > 0) {\n      terrainProviderBuilder.attribution += \" \";\n    }\n    terrainProviderBuilder.attribution += data.attribution;\n  }\n\n  terrainProviderBuilder.layers.push(\n    new LayerInformation({\n      resource: terrainProviderBuilder.lastResource,\n      version: data.version,\n      isHeightmap: isHeightmap,\n      tileUrlTemplates: tileUrlTemplates,\n      availability: availability,\n      hasVertexNormals: hasVertexNormals,\n      hasWaterMask: hasWaterMask,\n      hasMetadata: hasMetadata,\n      availabilityLevels: availabilityLevels,\n      availabilityTilesLoaded: availabilityTilesLoaded,\n      littleEndianExtensionSize: littleEndianExtensionSize,\n    }),\n  );\n\n  const parentUrl = data.parentUrl;\n  if (defined(parentUrl)) {\n    if (!defined(availability)) {\n      console.log(\n        \"A layer.json can't have a parentUrl if it does't have an available array.\",\n      );\n      return true;\n    }\n\n    terrainProviderBuilder.lastResource =\n      terrainProviderBuilder.lastResource.getDerivedResource({\n        url: parentUrl,\n      });\n    terrainProviderBuilder.lastResource.appendForwardSlash(); // Terrain always expects a directory\n    terrainProviderBuilder.layerJsonResource =\n      terrainProviderBuilder.lastResource.getDerivedResource({\n        url: \"layer.json\",\n      });\n    await requestLayerJson(terrainProviderBuilder);\n    return true;\n  }\n\n  return true;\n}\n\nfunction parseMetadataFailure(terrainProviderBuilder, error, provider) {\n  let message = `An error occurred while accessing ${terrainProviderBuilder.layerJsonResource.url}.`;\n  if (defined(error)) {\n    message += `\\n${error.message}`;\n  }\n\n  terrainProviderBuilder.previousError = TileProviderError.reportError(\n    terrainProviderBuilder.previousError,\n    provider,\n    defined(provider) ? provider._errorEvent : undefined,\n    message,\n  );\n\n  // If we can retry, do so. Otherwise throw the error.\n  if (terrainProviderBuilder.previousError.retry) {\n    return requestLayerJson(terrainProviderBuilder, provider);\n  }\n\n  throw new RuntimeError(message);\n}\n\nasync function metadataSuccess(terrainProviderBuilder, data, provider) {\n  await parseMetadataSuccess(terrainProviderBuilder, data, provider);\n\n  const length = terrainProviderBuilder.overallAvailability.length;\n  if (length > 0) {\n    const availability = (terrainProviderBuilder.availability =\n      new TileAvailability(\n        terrainProviderBuilder.tilingScheme,\n        terrainProviderBuilder.overallMaxZoom,\n      ));\n    for (let level = 0; level < length; ++level) {\n      const levelRanges = terrainProviderBuilder.overallAvailability[level];\n      for (let i = 0; i < levelRanges.length; ++i) {\n        const range = levelRanges[i];\n        availability.addAvailableTileRange(\n          level,\n          range[0],\n          range[1],\n          range[2],\n          range[3],\n        );\n      }\n    }\n  }\n\n  if (terrainProviderBuilder.attribution.length > 0) {\n    const layerJsonCredit = new Credit(terrainProviderBuilder.attribution);\n    terrainProviderBuilder.tileCredits.push(layerJsonCredit);\n  }\n\n  return true;\n}\n\nasync function requestLayerJson(terrainProviderBuilder, provider) {\n  try {\n    const data = await terrainProviderBuilder.layerJsonResource.fetchJson();\n    return metadataSuccess(terrainProviderBuilder, data, provider);\n  } catch (error) {\n    // If the metadata is not found, assume this is a pre-metadata heightmap tileset.\n    if (defined(error) && error.statusCode === 404) {\n      await parseMetadataSuccess(\n        terrainProviderBuilder,\n        {\n          tilejson: \"2.1.0\",\n          format: \"heightmap-1.0\",\n          version: \"1.0.0\",\n          scheme: \"tms\",\n          tiles: [\"{z}/{x}/{y}.terrain?v={version}\"],\n        },\n        provider,\n      );\n\n      return true;\n    }\n\n    return parseMetadataFailure(terrainProviderBuilder, error, provider);\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a CesiumTerrainProvider, call {@link CesiumTerrainProvider.fromIonAssetId} or {@link CesiumTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @alias CesiumTerrainProvider\n * @constructor\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *       requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @see createWorldTerrain\n * @see CesiumTerrainProvider.fromUrl\n * @see CesiumTerrainProvider.fromIonAssetId\n * @see TerrainProvider\n */\nfunction CesiumTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._heightmapWidth = undefined;\n  this._heightmapStructure = undefined;\n  this._hasWaterMask = false;\n  this._hasVertexNormals = false;\n  this._hasMetadata = false;\n  this._scheme = undefined;\n  this._ellipsoid = options.ellipsoid;\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  this._requestVertexNormals = defaultValue(\n    options.requestVertexNormals,\n    false,\n  );\n\n  /**\n   * Boolean flag that indicates if the client should request tile watermasks from the server.\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  this._requestWaterMask = defaultValue(options.requestWaterMask, false);\n\n  /**\n   * Boolean flag that indicates if the client should request tile metadata from the server.\n   * @type {boolean}\n   * @default true\n   * @private\n   */\n  this._requestMetadata = defaultValue(options.requestMetadata, true);\n\n  this._errorEvent = new Event();\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._availability = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._layers = undefined;\n  this._tileCredits = undefined;\n}\n\n/**\n * When using the Quantized-Mesh format, a tile may be returned that includes additional extensions, such as PerVertexNormals, watermask, etc.\n * This enumeration defines the unique identifiers for each type of extension data that has been appended to the standard mesh data.\n *\n * @namespace QuantizedMeshExtensionIds\n * @see CesiumTerrainProvider\n * @private\n */\nconst QuantizedMeshExtensionIds = {\n  /**\n   * Oct-Encoded Per-Vertex Normals are included as an extension to the tile mesh\n   *\n   * @type {number}\n   * @constant\n   * @default 1\n   */\n  OCT_VERTEX_NORMALS: 1,\n  /**\n   * A watermask is included as an extension to the tile mesh\n   *\n   * @type {number}\n   * @constant\n   * @default 2\n   */\n  WATER_MASK: 2,\n  /**\n   * A json object contain metadata about the tile\n   *\n   * @type {number}\n   * @constant\n   * @default 4\n   */\n  METADATA: 4,\n};\n\nfunction getRequestHeader(extensionsList) {\n  if (!defined(extensionsList) || extensionsList.length === 0) {\n    return {\n      Accept:\n        \"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01\",\n    };\n  }\n  const extensions = extensionsList.join(\"-\");\n  return {\n    Accept: `application/vnd.quantized-mesh;extensions=${extensions},application/octet-stream;q=0.9,*/*;q=0.01`,\n  };\n}\n\nfunction createHeightmapTerrainData(provider, buffer, level, x, y) {\n  const heightBuffer = new Uint16Array(\n    buffer,\n    0,\n    provider._heightmapWidth * provider._heightmapWidth,\n  );\n  return new HeightmapTerrainData({\n    buffer: heightBuffer,\n    childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],\n    waterMask: new Uint8Array(\n      buffer,\n      heightBuffer.byteLength + 1,\n      buffer.byteLength - heightBuffer.byteLength - 1,\n    ),\n    width: provider._heightmapWidth,\n    height: provider._heightmapWidth,\n    structure: provider._heightmapStructure,\n    credits: provider._tileCredits,\n  });\n}\n\nfunction createQuantizedMeshTerrainData(provider, buffer, level, x, y, layer) {\n  const littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  let pos = 0;\n  const cartesian3Elements = 3;\n  const boundingSphereElements = cartesian3Elements + 1;\n  const cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;\n  const boundingSphereLength =\n    Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;\n  const encodedVertexElements = 3;\n  const encodedVertexLength =\n    Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;\n  const triangleElements = 3;\n  let bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;\n  let triangleLength = bytesPerIndex * triangleElements;\n\n  const view = new DataView(buffer);\n  const center = new Cartesian3(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true),\n  );\n  pos += cartesian3Length;\n\n  const minimumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  const maximumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n\n  const boundingSphere = new BoundingSphere(\n    new Cartesian3(\n      view.getFloat64(pos, true),\n      view.getFloat64(pos + 8, true),\n      view.getFloat64(pos + 16, true),\n    ),\n    view.getFloat64(pos + cartesian3Length, true),\n  );\n  pos += boundingSphereLength;\n\n  const horizonOcclusionPoint = new Cartesian3(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true),\n  );\n  pos += cartesian3Length;\n\n  const vertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);\n  pos += vertexCount * encodedVertexLength;\n\n  if (vertexCount > 64 * 1024) {\n    // More than 64k vertices, so indices are 32-bit.\n    bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;\n    triangleLength = bytesPerIndex * triangleElements;\n  }\n\n  // Decode the vertex buffer.\n  const uBuffer = encodedVertexBuffer.subarray(0, vertexCount);\n  const vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);\n  const heightBuffer = encodedVertexBuffer.subarray(\n    vertexCount * 2,\n    3 * vertexCount,\n  );\n\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  // skip over any additional padding that was added for 2/4 byte alignment\n  if (pos % bytesPerIndex !== 0) {\n    pos += bytesPerIndex - (pos % bytesPerIndex);\n  }\n\n  const triangleCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const indices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    triangleCount * triangleElements,\n  );\n  pos += triangleCount * triangleLength;\n\n  // High water mark decoding based on decompressIndices_ in webgl-loader's loader.js.\n  // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n  // Copyright 2012 Google Inc., Apache 2.0 license.\n  let highest = 0;\n  const length = indices.length;\n  for (let i = 0; i < length; ++i) {\n    const code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  const westVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const westIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    westVertexCount,\n  );\n  pos += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const southIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    southVertexCount,\n  );\n  pos += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const eastIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    eastVertexCount,\n  );\n  pos += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  const northIndices = IndexDatatype.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    northVertexCount,\n  );\n  pos += northVertexCount * bytesPerIndex;\n\n  let encodedNormalBuffer;\n  let waterMaskBuffer;\n  while (pos < view.byteLength) {\n    const extensionId = view.getUint8(pos, true);\n    pos += Uint8Array.BYTES_PER_ELEMENT;\n    const extensionLength = view.getUint32(pos, littleEndianExtensionSize);\n    pos += Uint32Array.BYTES_PER_ELEMENT;\n\n    if (\n      extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS &&\n      provider._requestVertexNormals\n    ) {\n      encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.WATER_MASK &&\n      provider._requestWaterMask\n    ) {\n      waterMaskBuffer = new Uint8Array(buffer, pos, extensionLength);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.METADATA &&\n      provider._requestMetadata\n    ) {\n      const stringLength = view.getUint32(pos, true);\n      if (stringLength > 0) {\n        const metadata = getJsonFromTypedArray(\n          new Uint8Array(buffer),\n          pos + Uint32Array.BYTES_PER_ELEMENT,\n          stringLength,\n        );\n        const availableTiles = metadata.available;\n        if (defined(availableTiles)) {\n          for (let offset = 0; offset < availableTiles.length; ++offset) {\n            const availableLevel = level + offset + 1;\n            const rangesAtLevel = availableTiles[offset];\n            const yTiles =\n              provider._tilingScheme.getNumberOfYTilesAtLevel(availableLevel);\n\n            for (\n              let rangeIndex = 0;\n              rangeIndex < rangesAtLevel.length;\n              ++rangeIndex\n            ) {\n              const range = rangesAtLevel[rangeIndex];\n              const yStart = yTiles - range.endY - 1;\n              const yEnd = yTiles - range.startY - 1;\n              provider.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd,\n              );\n              layer.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd,\n              );\n            }\n          }\n        }\n      }\n      layer.availabilityTilesLoaded.addAvailableTileRange(level, x, y, x, y);\n    }\n    pos += extensionLength;\n  }\n\n  const skirtHeight = provider.getLevelMaximumGeometricError(level) * 5.0;\n\n  // The skirt is not included in the OBB computation. If this ever\n  // causes any rendering artifacts (cracks), they are expected to be\n  // minor and in the corners of the screen. It's possible that this\n  // might need to be changed - just change to `minimumHeight - skirtHeight`\n  // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.\n  const rectangle = provider._tilingScheme.tileXYToRectangle(x, y, level);\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    provider._tilingScheme.ellipsoid,\n  );\n\n  return new QuantizedMeshTerrainData({\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    horizonOcclusionPoint: horizonOcclusionPoint,\n    quantizedVertices: encodedVertexBuffer,\n    encodedNormals: encodedNormalBuffer,\n    indices: indices,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices,\n    westSkirtHeight: skirtHeight,\n    southSkirtHeight: skirtHeight,\n    eastSkirtHeight: skirtHeight,\n    northSkirtHeight: skirtHeight,\n    childTileMask: provider.availability.computeChildMaskForTile(level, x, y),\n    waterMask: waterMaskBuffer,\n    credits: provider._tileCredits,\n  });\n}\n\n/**\n * Requests the geometry for a given tile. The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n */\nCesiumTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const layers = this._layers;\n  let layerToUse;\n  const layerCount = layers.length;\n  let unknownAvailability = false;\n  let availabilityPromise = Promise.resolve();\n\n  if (layerCount === 1) {\n    // Optimized path for single layers\n    layerToUse = layers[0];\n  } else {\n    for (let i = 0; i < layerCount; ++i) {\n      const layer = layers[i];\n      if (\n        !defined(layer.availability) ||\n        layer.availability.isTileAvailable(level, x, y)\n      ) {\n        layerToUse = layer;\n        break;\n      }\n\n      const availabilityUnloaded = checkLayer(\n        this,\n        x,\n        y,\n        level,\n        layer,\n        i === 0,\n      );\n      if (availabilityUnloaded.result) {\n        // We can't know yet since the availability is not yet loaded\n        unknownAvailability = true;\n        availabilityPromise = availabilityPromise.then(\n          () => availabilityUnloaded.promise,\n        );\n      }\n    }\n  }\n\n  if (!defined(layerToUse) && unknownAvailability) {\n    // Try again when availability data is ready– Otherwise the tile will be marked as failed and never re-requested\n    return availabilityPromise.then(() => {\n      // handle promise or undefined return\n      return new Promise((resolve) => {\n        // defer execution to the next event loop\n        setTimeout(() => {\n          const promise = this.requestTileGeometry(x, y, level, request);\n          resolve(promise);\n        }, 0); // next tick\n      });\n    });\n  }\n  // call overridden function below\n  return requestTileGeometry(this, x, y, level, layerToUse, request);\n};\n\nfunction requestTileGeometry(provider, x, y, level, layerToUse, request) {\n  if (!defined(layerToUse)) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  const urlTemplates = layerToUse.tileUrlTemplates;\n  if (urlTemplates.length === 0) {\n    return undefined;\n  }\n\n  // The TileMapService scheme counts from the bottom left\n  let terrainY;\n  if (!provider._scheme || provider._scheme === \"tms\") {\n    const yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);\n    terrainY = yTiles - y - 1;\n  } else {\n    terrainY = y;\n  }\n\n  const extensionList = [];\n  if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {\n    extensionList.push(\n      layerToUse.littleEndianExtensionSize\n        ? \"octvertexnormals\"\n        : \"vertexnormals\",\n    );\n  }\n  if (provider._requestWaterMask && layerToUse.hasWaterMask) {\n    extensionList.push(\"watermask\");\n  }\n  if (provider._requestMetadata && layerToUse.hasMetadata) {\n    extensionList.push(\"metadata\");\n  }\n\n  let headers;\n  let query;\n  const url = urlTemplates[(x + terrainY + level) % urlTemplates.length];\n\n  const resource = layerToUse.resource;\n  if (\n    defined(resource._ionEndpoint) &&\n    !defined(resource._ionEndpoint.externalType)\n  ) {\n    // ion uses query parameters to request extensions\n    if (extensionList.length !== 0) {\n      query = { extensions: extensionList.join(\"-\") };\n    }\n    headers = getRequestHeader(undefined);\n  } else {\n    //All other terrain servers\n    headers = getRequestHeader(extensionList);\n  }\n\n  const promise = resource\n    .getDerivedResource({\n      url: url,\n      templateValues: {\n        version: layerToUse.version,\n        z: level,\n        x: x,\n        y: terrainY,\n      },\n      queryParameters: query,\n      headers: headers,\n      request: request,\n    })\n    .fetchArrayBuffer();\n\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (buffer) {\n    if (!defined(buffer)) {\n      return Promise.reject(new RuntimeError(\"Mesh buffer doesn't exist.\"));\n    }\n    if (defined(provider._heightmapStructure)) {\n      return createHeightmapTerrainData(provider, buffer, level, x, y);\n    }\n    return createQuantizedMeshTerrainData(\n      provider,\n      buffer,\n      level,\n      x,\n      y,\n      layerToUse,\n    );\n  });\n}\n\nObject.defineProperties(CesiumTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return this._hasWaterMask && this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      // returns true if we can request vertex normals from the server\n      return this._hasVertexNormals && this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasMetadata: {\n    get: function () {\n      // returns true if we can request metadata from the server\n      return this._hasMetadata && this._requestMetadata;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and\n   * if the server provides vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestVertexNormals: {\n    get: function () {\n      return this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request a watermask from the server.\n   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and\n   * if the server provides a watermask.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestWaterMask: {\n    get: function () {\n      return this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request metadata from the server.\n   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and\n   * if the server provides a metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  requestMetadata: {\n    get: function () {\n      return this._requestMetadata;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available. Note that this reflects tiles that are known to be available currently.\n   * Additional tiles may be discovered to be available in the future, e.g. if availability information\n   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that\n   * is available now will not become unavailable in the future.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return this._availability;\n    },\n  },\n});\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nCesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level,\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium terrain format\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @param {number} assetId The Cesium ion asset id.\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<CesiumTerrainProvider>}\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @exception {RuntimeError} layer.json does not specify a format\n * @exception {RuntimeError} layer.json specifies an unknown format\n * @exception {RuntimeError} layer.json specifies an unsupported quantized-mesh version\n * @exception {RuntimeError} layer.json does not specify a tiles property, or specifies an empty array\n * @exception {RuntimeError} layer.json does not specify any tile URL templates\n */\nCesiumTerrainProvider.fromIonAssetId = async function (assetId, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"assetId\", assetId);\n  //>>includeEnd('debug');\n\n  const resource = await IonResource.fromAssetId(assetId);\n  return CesiumTerrainProvider.fromUrl(resource, options);\n};\n\n/**\n * Creates a {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n * Terrain formats can be one of the following:\n * <ul>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>\n * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>\n * </ul>\n *\n * @param {Resource|String|Promise<Resource>|Promise<String>} url The URL of the Cesium terrain server.\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n * @returns {Promise<CesiumTerrainProvider>}\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * try {\n *   const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *     terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(\n *       Cesium.IonResource.fromAssetId(3956), {\n *         requestVertexNormals: true\n *     })\n *   });\n * } catch (error) {\n *   console.log(error);\n * }\n *\n * @exception {RuntimeError} layer.json does not specify a format\n * @exception {RuntimeError} layer.json specifies an unknown format\n * @exception {RuntimeError} layer.json specifies an unsupported quantized-mesh version\n * @exception {RuntimeError} layer.json does not specify a tiles property, or specifies an empty array\n * @exception {RuntimeError} layer.json does not specify any tile URL templates\n */\nCesiumTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  url = await Promise.resolve(url);\n  const resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  terrainProviderBuilder.lastResource = resource;\n  terrainProviderBuilder.layerJsonResource =\n    terrainProviderBuilder.lastResource.getDerivedResource({\n      url: \"layer.json\",\n    });\n\n  await requestLayerJson(terrainProviderBuilder);\n\n  const provider = new CesiumTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n\n  return provider;\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported or availability is unknown, otherwise true or false.\n */\nCesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!defined(this._availability)) {\n    return undefined;\n  }\n  if (level > this._availability._maximumLevel) {\n    return false;\n  }\n\n  if (this._availability.isTileAvailable(level, x, y)) {\n    // If the tile is listed as available, then we are done\n    return true;\n  }\n  if (!this._hasMetadata) {\n    // If we don't have any layers with the metadata extension then we don't have this tile\n    return false;\n  }\n\n  const layers = this._layers;\n  const count = layers.length;\n  for (let i = 0; i < count; ++i) {\n    const layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (layerResult.result) {\n      // There is a layer that may or may not have the tile\n      return undefined;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nCesiumTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level,\n) {\n  if (\n    !defined(this._availability) ||\n    level > this._availability._maximumLevel ||\n    this._availability.isTileAvailable(level, x, y) ||\n    !this._hasMetadata\n  ) {\n    // We know the tile is either available or not available so nothing to wait on\n    return undefined;\n  }\n\n  const layers = this._layers;\n  const count = layers.length;\n  for (let i = 0; i < count; ++i) {\n    const layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (defined(layerResult.promise)) {\n      return layerResult.promise;\n    }\n  }\n};\n\nfunction getAvailabilityTile(layer, x, y, level) {\n  if (level === 0) {\n    return;\n  }\n\n  const availabilityLevels = layer.availabilityLevels;\n  const parentLevel =\n    level % availabilityLevels === 0\n      ? level - availabilityLevels\n      : ((level / availabilityLevels) | 0) * availabilityLevels;\n  const divisor = 1 << (level - parentLevel);\n  const parentX = (x / divisor) | 0;\n  const parentY = (y / divisor) | 0;\n\n  return {\n    level: parentLevel,\n    x: parentX,\n    y: parentY,\n  };\n}\n\nfunction checkLayer(provider, x, y, level, layer, topLayer) {\n  if (!defined(layer.availabilityLevels)) {\n    // It's definitely not in this layer\n    return {\n      result: false,\n    };\n  }\n\n  let cacheKey;\n  const deleteFromCache = function () {\n    delete layer.availabilityPromiseCache[cacheKey];\n  };\n  const availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  const availability = layer.availability;\n\n  let tile = getAvailabilityTile(layer, x, y, level);\n  while (defined(tile)) {\n    if (\n      availability.isTileAvailable(tile.level, tile.x, tile.y) &&\n      !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)\n    ) {\n      let requestPromise;\n      if (!topLayer) {\n        cacheKey = `${tile.level}-${tile.x}-${tile.y}`;\n        requestPromise = layer.availabilityPromiseCache[cacheKey];\n        if (!defined(requestPromise)) {\n          // For cutout terrain, if this isn't the top layer the availability tiles\n          //  may never get loaded, so request it here.\n          const request = new Request({\n            throttle: false,\n            throttleByServer: true,\n            type: RequestType.TERRAIN,\n          });\n          requestPromise = requestTileGeometry(\n            provider,\n            tile.x,\n            tile.y,\n            tile.level,\n            layer,\n            request,\n          );\n          if (defined(requestPromise)) {\n            layer.availabilityPromiseCache[cacheKey] = requestPromise;\n            requestPromise.then(deleteFromCache);\n          }\n        }\n      }\n\n      // The availability tile is available, but not loaded, so there\n      //  is still a chance that it may become available at some point\n      return {\n        result: true,\n        promise: requestPromise,\n      };\n    }\n\n    tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);\n  }\n\n  return {\n    result: false,\n  };\n}\n\n// Used for testing\nCesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;\nexport default CesiumTerrainProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}