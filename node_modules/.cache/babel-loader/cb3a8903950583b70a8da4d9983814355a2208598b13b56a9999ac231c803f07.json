{"ast":null,"code":"import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Axis from \"../Axis.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport CullFace from \"../CullFace.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * Utility functions for {@link Model}.\n *\n * @private\n */\nfunction ModelUtility() {}\n\n/**\n * Create a function for reporting when a model fails to load\n *\n * @param {string} type The type of object to report about\n * @param {string} path The URI of the model file\n * @param {Error} [error] The error which caused the failure\n * @returns {RuntimeError} An error for the failed model\n *\n * @private\n */\nModelUtility.getError = function (type, path, error) {\n  let message = `Failed to load ${type}: ${path}`;\n  if (defined(error) && defined(error.message)) {\n    message += `\\n${error.message}`;\n  }\n  const runtimeError = new RuntimeError(message);\n  if (defined(error)) {\n    // the original call stack is often more useful than the new error's stack,\n    // so add the information here\n    runtimeError.stack = `Original stack:\\n${error.stack}\\nHandler stack:\\n${runtimeError.stack}`;\n  }\n  return runtimeError;\n};\n\n/**\n * Get a transformation matrix from a node in the model.\n *\n * @param {ModelComponents.Node} node The node components\n * @returns {Matrix4} The computed transformation matrix. If no transformation matrix or parameters are specified, this will be the identity matrix.\n *\n * @private\n */\nModelUtility.getNodeTransform = function (node) {\n  if (defined(node.matrix)) {\n    return node.matrix;\n  }\n  return Matrix4.fromTranslationQuaternionRotationScale(defined(node.translation) ? node.translation : Cartesian3.ZERO, defined(node.rotation) ? node.rotation : Quaternion.IDENTITY, defined(node.scale) ? node.scale : Cartesian3.ONE);\n};\n\n/**\n * Find an attribute by semantic such as POSITION or TANGENT.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {VertexAttributeSemantic|InstanceAttributeSemantic} semantic The semantic to search for\n * @param {number} [setIndex] The set index of the semantic. May be undefined for some semantics (POSITION, NORMAL, TRANSLATION, ROTATION, for example)\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelUtility.getAttributeBySemantic = function (object, semantic, setIndex) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const matchesSetIndex = defined(setIndex) ? attribute.setIndex === setIndex : true;\n    if (attribute.semantic === semantic && matchesSetIndex) {\n      return attribute;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Similar to getAttributeBySemantic, but search using the name field only,\n * as custom attributes do not have a semantic.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {string} name The name of the attribute as it appears in the model file.\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelUtility.getAttributeByName = function (object, name) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    if (attribute.name === name) {\n      return attribute;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Find a feature ID from an array with label or positionalLabel matching the\n * given label\n * @param {ModelComponents.FeatureIdAttribute[]|ModelComponents.FeatureIdImplicitRange[]|ModelComponents.FeatureIdTexture[]} featureIds\n * @param {string} label the label to search for\n * @returns {ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange|ModelComponents.FeatureIdTexture} The feature ID set if found, otherwise <code>undefined</code>\n *\n * @private\n */\nModelUtility.getFeatureIdsByLabel = function (featureIds, label) {\n  for (let i = 0; i < featureIds.length; i++) {\n    const featureIdSet = featureIds[i];\n    if (featureIdSet.positionalLabel === label || featureIdSet.label === label) {\n      return featureIdSet;\n    }\n  }\n  return undefined;\n};\nModelUtility.hasQuantizedAttributes = function (attributes) {\n  if (!defined(attributes)) {\n    return false;\n  }\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.quantization)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {ModelComponents.Attribute} attribute\n *\n * @private\n */\nModelUtility.getAttributeInfo = function (attribute) {\n  const semantic = attribute.semantic;\n  const setIndex = attribute.setIndex;\n  let variableName;\n  let hasSemantic = false;\n  if (defined(semantic)) {\n    variableName = VertexAttributeSemantic.getVariableName(semantic, setIndex);\n    hasSemantic = true;\n  } else {\n    variableName = attribute.name;\n    // According to the glTF 2.0 spec, custom attributes must be prepended with\n    // an underscore.\n    variableName = variableName.replace(/^_/, \"\");\n    variableName = variableName.toLowerCase();\n  }\n  const isVertexColor = /^color_\\d+$/.test(variableName);\n  const attributeType = attribute.type;\n  let glslType = AttributeType.getGlslType(attributeType);\n\n  // color_n can be either a vec3 or a vec4. But in GLSL we can always use\n  // attribute vec4 since GLSL promotes vec3 attribute data to vec4 with\n  // the .a channel set to 1.0.\n  if (isVertexColor) {\n    glslType = \"vec4\";\n  }\n  const isQuantized = defined(attribute.quantization);\n  let quantizedGlslType;\n  if (isQuantized) {\n    // The quantized color_n attribute also is promoted to a vec4 in the shader\n    quantizedGlslType = isVertexColor ? \"vec4\" : AttributeType.getGlslType(attribute.quantization.type);\n  }\n  return {\n    attribute: attribute,\n    isQuantized: isQuantized,\n    variableName: variableName,\n    hasSemantic: hasSemantic,\n    glslType: glslType,\n    quantizedGlslType: quantizedGlslType\n  };\n};\nconst cartesianMaxScratch = new Cartesian3();\nconst cartesianMinScratch = new Cartesian3();\n\n/**\n * Get the minimum and maximum values for a primitive's POSITION attribute.\n * This is used to compute the bounding sphere of the primitive, as well as\n * the bounding sphere of the whole model.\n *\n * @param {ModelComponents.Primitive} primitive The primitive components.\n * @param {Cartesian3} [instancingTranslationMin] The component-wise minimum value of the instancing translation attribute.\n * @param {Cartesian3} [instancingTranslationMax] The component-wise maximum value of the instancing translation attribute.\n *\n * @returns {object} An object containing the minimum and maximum position values.\n *\n * @private\n */\nModelUtility.getPositionMinMax = function (primitive, instancingTranslationMin, instancingTranslationMax) {\n  const positionGltfAttribute = ModelUtility.getAttributeBySemantic(primitive, \"POSITION\");\n  let positionMax = positionGltfAttribute.max;\n  let positionMin = positionGltfAttribute.min;\n  if (defined(instancingTranslationMax) && defined(instancingTranslationMin)) {\n    positionMin = Cartesian3.add(positionMin, instancingTranslationMin, cartesianMinScratch);\n    positionMax = Cartesian3.add(positionMax, instancingTranslationMax, cartesianMaxScratch);\n  }\n  return {\n    min: positionMin,\n    max: positionMax\n  };\n};\n\n/**\n * Model matrices in a model file (e.g. glTF) are typically in a different\n * coordinate system, such as with y-up instead of z-up in 3D Tiles.\n * This function returns a matrix that will correct this such that z is up,\n * and x is forward.\n *\n * @param {Axis} upAxis The original up direction\n * @param {Axis} forwardAxis The original forward direction\n * @param {Matrix4} result The matrix in which to store the result.\n * @returns {Matrix4} The axis correction matrix\n *\n * @private\n */\nModelUtility.getAxisCorrectionMatrix = function (upAxis, forwardAxis, result) {\n  result = Matrix4.clone(Matrix4.IDENTITY, result);\n  if (upAxis === Axis.Y) {\n    result = Matrix4.clone(Axis.Y_UP_TO_Z_UP, result);\n  } else if (upAxis === Axis.X) {\n    result = Matrix4.clone(Axis.X_UP_TO_Z_UP, result);\n  }\n  if (forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    result = Matrix4.multiplyTransformation(result, Axis.Z_UP_TO_X_UP, result);\n  }\n  return result;\n};\nconst scratchMatrix3 = new Matrix3();\n\n/**\n * Get the cull face to use in the command's render state.\n * <p>\n * From the glTF spec section 3.7.4:\n * When a mesh primitive uses any triangle-based topology (i.e., triangles,\n * triangle strip, or triangle fan), the determinant of the nodeâ€™s global\n * transform defines the winding order of that primitive. If the determinant\n * is a positive value, the winding order triangle faces is counterclockwise;\n * in the opposite case, the winding order is clockwise.\n * </p>\n *\n * @param {Matrix4} modelMatrix The model matrix\n * @param {PrimitiveType} primitiveType The primitive type\n * @returns {CullFace} The cull face\n *\n * @private\n */\nModelUtility.getCullFace = function (modelMatrix, primitiveType) {\n  if (!PrimitiveType.isTriangles(primitiveType)) {\n    return CullFace.BACK;\n  }\n  const matrix3 = Matrix4.getMatrix3(modelMatrix, scratchMatrix3);\n  return Matrix3.determinant(matrix3) < 0.0 ? CullFace.FRONT : CullFace.BACK;\n};\n\n/**\n * Sanitize the identifier to be used in a GLSL shader. The identifier\n * is sanitized as follows:\n * - Replace all sequences of non-alphanumeric characters with a single `_`.\n * - If the gl_ prefix is present, remove it. The prefix is reserved in GLSL.\n * - If the identifier starts with a digit, prefix it with an underscore.\n *\n * @example\n * // Returns \"customProperty\"\n * ModelUtility.sanitizeGlslIdentifier(\"gl_customProperty\");\n *\n * @example\n * // Returns \"_1234\"\n * ModelUtility.sanitizeGlslIdentifier(\"1234\");\n *\n * @param {string} identifier The original identifier.\n *\n * @returns {string} The sanitized version of the identifier.\n */\nModelUtility.sanitizeGlslIdentifier = function (identifier) {\n  // Remove non-alphanumeric characters and replace with a single underscore.\n  // This regex is designed so that the result won't have multiple underscores\n  // in a row.\n  let sanitizedIdentifier = identifier.replaceAll(/[^A-Za-z0-9]+/g, \"_\");\n  // Remove the gl_ prefix if present.\n  sanitizedIdentifier = sanitizedIdentifier.replace(/^gl_/, \"\");\n  // Add an underscore if first character is a digit.\n  if (/^\\d/.test(sanitizedIdentifier)) {\n    sanitizedIdentifier = `_${sanitizedIdentifier}`;\n  }\n  return sanitizedIdentifier;\n};\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_primitive_outline: true,\n  CESIUM_RTC: true,\n  EXT_feature_metadata: true,\n  EXT_instance_features: true,\n  EXT_mesh_features: true,\n  EXT_mesh_gpu_instancing: true,\n  EXT_meshopt_compression: true,\n  EXT_structural_metadata: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_draco_mesh_compression: true,\n  KHR_techniques_webgl: true,\n  KHR_materials_common: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_materials_specular: true,\n  KHR_materials_anisotropy: true,\n  KHR_materials_clearcoat: true,\n  KHR_materials_unlit: true,\n  KHR_mesh_quantization: true,\n  KHR_texture_basisu: true,\n  KHR_texture_transform: true,\n  WEB3D_quantized_attributes: true\n};\n\n/**\n * Checks whether or not the extensions required by the glTF are\n * supported. If an unsupported extension is found, this throws\n * a {@link RuntimeError} with the extension name.\n *\n * @param {string[]} extensionsRequired The extensionsRequired array in the glTF.\n *\n * @exception {RuntimeError} Unsupported glTF Extension\n */\nModelUtility.checkSupportedExtensions = function (extensionsRequired) {\n  const length = extensionsRequired.length;\n  for (let i = 0; i < length; i++) {\n    const extension = extensionsRequired[i];\n    if (!ModelUtility.supportedExtensions[extension]) {\n      throw new RuntimeError(`Unsupported glTF Extension: ${extension}`);\n    }\n  }\n};\nexport default ModelUtility;","map":{"version":3,"names":["Cartesian3","defined","Matrix4","Quaternion","RuntimeError","Axis","AttributeType","VertexAttributeSemantic","CullFace","PrimitiveType","Matrix3","ModelUtility","getError","type","path","error","message","runtimeError","stack","getNodeTransform","node","matrix","fromTranslationQuaternionRotationScale","translation","ZERO","rotation","IDENTITY","scale","ONE","getAttributeBySemantic","object","semantic","setIndex","attributes","attributesLength","length","i","attribute","matchesSetIndex","undefined","getAttributeByName","name","getFeatureIdsByLabel","featureIds","label","featureIdSet","positionalLabel","hasQuantizedAttributes","quantization","getAttributeInfo","variableName","hasSemantic","getVariableName","replace","toLowerCase","isVertexColor","test","attributeType","glslType","getGlslType","isQuantized","quantizedGlslType","cartesianMaxScratch","cartesianMinScratch","getPositionMinMax","primitive","instancingTranslationMin","instancingTranslationMax","positionGltfAttribute","positionMax","max","positionMin","min","add","getAxisCorrectionMatrix","upAxis","forwardAxis","result","clone","Y","Y_UP_TO_Z_UP","X","X_UP_TO_Z_UP","Z","multiplyTransformation","Z_UP_TO_X_UP","scratchMatrix3","getCullFace","modelMatrix","primitiveType","isTriangles","BACK","matrix3","getMatrix3","determinant","FRONT","sanitizeGlslIdentifier","identifier","sanitizedIdentifier","replaceAll","supportedExtensions","AGI_articulations","CESIUM_primitive_outline","CESIUM_RTC","EXT_feature_metadata","EXT_instance_features","EXT_mesh_features","EXT_mesh_gpu_instancing","EXT_meshopt_compression","EXT_structural_metadata","EXT_texture_webp","KHR_blend","KHR_draco_mesh_compression","KHR_techniques_webgl","KHR_materials_common","KHR_materials_pbrSpecularGlossiness","KHR_materials_specular","KHR_materials_anisotropy","KHR_materials_clearcoat","KHR_materials_unlit","KHR_mesh_quantization","KHR_texture_basisu","KHR_texture_transform","WEB3D_quantized_attributes","checkSupportedExtensions","extensionsRequired","extension"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelUtility.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Axis from \"../Axis.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport CullFace from \"../CullFace.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * Utility functions for {@link Model}.\n *\n * @private\n */\nfunction ModelUtility() {}\n\n/**\n * Create a function for reporting when a model fails to load\n *\n * @param {string} type The type of object to report about\n * @param {string} path The URI of the model file\n * @param {Error} [error] The error which caused the failure\n * @returns {RuntimeError} An error for the failed model\n *\n * @private\n */\nModelUtility.getError = function (type, path, error) {\n  let message = `Failed to load ${type}: ${path}`;\n  if (defined(error) && defined(error.message)) {\n    message += `\\n${error.message}`;\n  }\n\n  const runtimeError = new RuntimeError(message);\n  if (defined(error)) {\n    // the original call stack is often more useful than the new error's stack,\n    // so add the information here\n    runtimeError.stack = `Original stack:\\n${error.stack}\\nHandler stack:\\n${runtimeError.stack}`;\n  }\n\n  return runtimeError;\n};\n\n/**\n * Get a transformation matrix from a node in the model.\n *\n * @param {ModelComponents.Node} node The node components\n * @returns {Matrix4} The computed transformation matrix. If no transformation matrix or parameters are specified, this will be the identity matrix.\n *\n * @private\n */\nModelUtility.getNodeTransform = function (node) {\n  if (defined(node.matrix)) {\n    return node.matrix;\n  }\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    defined(node.translation) ? node.translation : Cartesian3.ZERO,\n    defined(node.rotation) ? node.rotation : Quaternion.IDENTITY,\n    defined(node.scale) ? node.scale : Cartesian3.ONE,\n  );\n};\n\n/**\n * Find an attribute by semantic such as POSITION or TANGENT.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {VertexAttributeSemantic|InstanceAttributeSemantic} semantic The semantic to search for\n * @param {number} [setIndex] The set index of the semantic. May be undefined for some semantics (POSITION, NORMAL, TRANSLATION, ROTATION, for example)\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelUtility.getAttributeBySemantic = function (object, semantic, setIndex) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const matchesSetIndex = defined(setIndex)\n      ? attribute.setIndex === setIndex\n      : true;\n    if (attribute.semantic === semantic && matchesSetIndex) {\n      return attribute;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Similar to getAttributeBySemantic, but search using the name field only,\n * as custom attributes do not have a semantic.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {string} name The name of the attribute as it appears in the model file.\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelUtility.getAttributeByName = function (object, name) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    if (attribute.name === name) {\n      return attribute;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Find a feature ID from an array with label or positionalLabel matching the\n * given label\n * @param {ModelComponents.FeatureIdAttribute[]|ModelComponents.FeatureIdImplicitRange[]|ModelComponents.FeatureIdTexture[]} featureIds\n * @param {string} label the label to search for\n * @returns {ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange|ModelComponents.FeatureIdTexture} The feature ID set if found, otherwise <code>undefined</code>\n *\n * @private\n */\nModelUtility.getFeatureIdsByLabel = function (featureIds, label) {\n  for (let i = 0; i < featureIds.length; i++) {\n    const featureIdSet = featureIds[i];\n    if (\n      featureIdSet.positionalLabel === label ||\n      featureIdSet.label === label\n    ) {\n      return featureIdSet;\n    }\n  }\n\n  return undefined;\n};\n\nModelUtility.hasQuantizedAttributes = function (attributes) {\n  if (!defined(attributes)) {\n    return false;\n  }\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.quantization)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {ModelComponents.Attribute} attribute\n *\n * @private\n */\nModelUtility.getAttributeInfo = function (attribute) {\n  const semantic = attribute.semantic;\n  const setIndex = attribute.setIndex;\n\n  let variableName;\n  let hasSemantic = false;\n  if (defined(semantic)) {\n    variableName = VertexAttributeSemantic.getVariableName(semantic, setIndex);\n    hasSemantic = true;\n  } else {\n    variableName = attribute.name;\n    // According to the glTF 2.0 spec, custom attributes must be prepended with\n    // an underscore.\n    variableName = variableName.replace(/^_/, \"\");\n    variableName = variableName.toLowerCase();\n  }\n\n  const isVertexColor = /^color_\\d+$/.test(variableName);\n  const attributeType = attribute.type;\n  let glslType = AttributeType.getGlslType(attributeType);\n\n  // color_n can be either a vec3 or a vec4. But in GLSL we can always use\n  // attribute vec4 since GLSL promotes vec3 attribute data to vec4 with\n  // the .a channel set to 1.0.\n  if (isVertexColor) {\n    glslType = \"vec4\";\n  }\n\n  const isQuantized = defined(attribute.quantization);\n  let quantizedGlslType;\n  if (isQuantized) {\n    // The quantized color_n attribute also is promoted to a vec4 in the shader\n    quantizedGlslType = isVertexColor\n      ? \"vec4\"\n      : AttributeType.getGlslType(attribute.quantization.type);\n  }\n\n  return {\n    attribute: attribute,\n    isQuantized: isQuantized,\n    variableName: variableName,\n    hasSemantic: hasSemantic,\n    glslType: glslType,\n    quantizedGlslType: quantizedGlslType,\n  };\n};\n\nconst cartesianMaxScratch = new Cartesian3();\nconst cartesianMinScratch = new Cartesian3();\n\n/**\n * Get the minimum and maximum values for a primitive's POSITION attribute.\n * This is used to compute the bounding sphere of the primitive, as well as\n * the bounding sphere of the whole model.\n *\n * @param {ModelComponents.Primitive} primitive The primitive components.\n * @param {Cartesian3} [instancingTranslationMin] The component-wise minimum value of the instancing translation attribute.\n * @param {Cartesian3} [instancingTranslationMax] The component-wise maximum value of the instancing translation attribute.\n *\n * @returns {object} An object containing the minimum and maximum position values.\n *\n * @private\n */\nModelUtility.getPositionMinMax = function (\n  primitive,\n  instancingTranslationMin,\n  instancingTranslationMax,\n) {\n  const positionGltfAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    \"POSITION\",\n  );\n\n  let positionMax = positionGltfAttribute.max;\n  let positionMin = positionGltfAttribute.min;\n\n  if (defined(instancingTranslationMax) && defined(instancingTranslationMin)) {\n    positionMin = Cartesian3.add(\n      positionMin,\n      instancingTranslationMin,\n      cartesianMinScratch,\n    );\n    positionMax = Cartesian3.add(\n      positionMax,\n      instancingTranslationMax,\n      cartesianMaxScratch,\n    );\n  }\n\n  return {\n    min: positionMin,\n    max: positionMax,\n  };\n};\n\n/**\n * Model matrices in a model file (e.g. glTF) are typically in a different\n * coordinate system, such as with y-up instead of z-up in 3D Tiles.\n * This function returns a matrix that will correct this such that z is up,\n * and x is forward.\n *\n * @param {Axis} upAxis The original up direction\n * @param {Axis} forwardAxis The original forward direction\n * @param {Matrix4} result The matrix in which to store the result.\n * @returns {Matrix4} The axis correction matrix\n *\n * @private\n */\nModelUtility.getAxisCorrectionMatrix = function (upAxis, forwardAxis, result) {\n  result = Matrix4.clone(Matrix4.IDENTITY, result);\n\n  if (upAxis === Axis.Y) {\n    result = Matrix4.clone(Axis.Y_UP_TO_Z_UP, result);\n  } else if (upAxis === Axis.X) {\n    result = Matrix4.clone(Axis.X_UP_TO_Z_UP, result);\n  }\n\n  if (forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    result = Matrix4.multiplyTransformation(result, Axis.Z_UP_TO_X_UP, result);\n  }\n\n  return result;\n};\n\nconst scratchMatrix3 = new Matrix3();\n\n/**\n * Get the cull face to use in the command's render state.\n * <p>\n * From the glTF spec section 3.7.4:\n * When a mesh primitive uses any triangle-based topology (i.e., triangles,\n * triangle strip, or triangle fan), the determinant of the nodeâ€™s global\n * transform defines the winding order of that primitive. If the determinant\n * is a positive value, the winding order triangle faces is counterclockwise;\n * in the opposite case, the winding order is clockwise.\n * </p>\n *\n * @param {Matrix4} modelMatrix The model matrix\n * @param {PrimitiveType} primitiveType The primitive type\n * @returns {CullFace} The cull face\n *\n * @private\n */\nModelUtility.getCullFace = function (modelMatrix, primitiveType) {\n  if (!PrimitiveType.isTriangles(primitiveType)) {\n    return CullFace.BACK;\n  }\n\n  const matrix3 = Matrix4.getMatrix3(modelMatrix, scratchMatrix3);\n  return Matrix3.determinant(matrix3) < 0.0 ? CullFace.FRONT : CullFace.BACK;\n};\n\n/**\n * Sanitize the identifier to be used in a GLSL shader. The identifier\n * is sanitized as follows:\n * - Replace all sequences of non-alphanumeric characters with a single `_`.\n * - If the gl_ prefix is present, remove it. The prefix is reserved in GLSL.\n * - If the identifier starts with a digit, prefix it with an underscore.\n *\n * @example\n * // Returns \"customProperty\"\n * ModelUtility.sanitizeGlslIdentifier(\"gl_customProperty\");\n *\n * @example\n * // Returns \"_1234\"\n * ModelUtility.sanitizeGlslIdentifier(\"1234\");\n *\n * @param {string} identifier The original identifier.\n *\n * @returns {string} The sanitized version of the identifier.\n */\nModelUtility.sanitizeGlslIdentifier = function (identifier) {\n  // Remove non-alphanumeric characters and replace with a single underscore.\n  // This regex is designed so that the result won't have multiple underscores\n  // in a row.\n  let sanitizedIdentifier = identifier.replaceAll(/[^A-Za-z0-9]+/g, \"_\");\n  // Remove the gl_ prefix if present.\n  sanitizedIdentifier = sanitizedIdentifier.replace(/^gl_/, \"\");\n  // Add an underscore if first character is a digit.\n  if (/^\\d/.test(sanitizedIdentifier)) {\n    sanitizedIdentifier = `_${sanitizedIdentifier}`;\n  }\n\n  return sanitizedIdentifier;\n};\n\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_primitive_outline: true,\n  CESIUM_RTC: true,\n  EXT_feature_metadata: true,\n  EXT_instance_features: true,\n  EXT_mesh_features: true,\n  EXT_mesh_gpu_instancing: true,\n  EXT_meshopt_compression: true,\n  EXT_structural_metadata: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_draco_mesh_compression: true,\n  KHR_techniques_webgl: true,\n  KHR_materials_common: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_materials_specular: true,\n  KHR_materials_anisotropy: true,\n  KHR_materials_clearcoat: true,\n  KHR_materials_unlit: true,\n  KHR_mesh_quantization: true,\n  KHR_texture_basisu: true,\n  KHR_texture_transform: true,\n  WEB3D_quantized_attributes: true,\n};\n\n/**\n * Checks whether or not the extensions required by the glTF are\n * supported. If an unsupported extension is found, this throws\n * a {@link RuntimeError} with the extension name.\n *\n * @param {string[]} extensionsRequired The extensionsRequired array in the glTF.\n *\n * @exception {RuntimeError} Unsupported glTF Extension\n */\nModelUtility.checkSupportedExtensions = function (extensionsRequired) {\n  const length = extensionsRequired.length;\n  for (let i = 0; i < length; i++) {\n    const extension = extensionsRequired[i];\n    if (!ModelUtility.supportedExtensions[extension]) {\n      throw new RuntimeError(`Unsupported glTF Extension: ${extension}`);\n    }\n  }\n};\n\nexport default ModelUtility;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}