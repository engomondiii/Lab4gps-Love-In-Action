{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport Iau2000Orientation from \"./Iau2000Orientation.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * The Axes representing the orientation of a Globe as represented by the data\n * from the IAU/IAG Working Group reports on rotational elements.\n * @alias IauOrientationAxes\n * @constructor\n *\n * @param {IauOrientationAxes.ComputeFunction} [computeFunction] The function that computes the {@link IauOrientationParameters} given a {@link JulianDate}.\n *\n * @see Iau2000Orientation\n *\n * @private\n */\nfunction IauOrientationAxes(computeFunction) {\n  if (!defined(computeFunction) || typeof computeFunction !== \"function\") {\n    computeFunction = Iau2000Orientation.ComputeMoon;\n  }\n  this._computeFunction = computeFunction;\n}\nconst xAxisScratch = new Cartesian3();\nconst yAxisScratch = new Cartesian3();\nconst zAxisScratch = new Cartesian3();\nfunction computeRotationMatrix(alpha, delta, result) {\n  const xAxis = xAxisScratch;\n  xAxis.x = Math.cos(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.y = Math.sin(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.z = 0.0;\n  const cosDec = Math.cos(delta);\n  const zAxis = zAxisScratch;\n  zAxis.x = cosDec * Math.cos(alpha);\n  zAxis.y = cosDec * Math.sin(alpha);\n  zAxis.z = Math.sin(delta);\n  const yAxis = Cartesian3.cross(zAxis, xAxis, yAxisScratch);\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n  result[0] = xAxis.x;\n  result[1] = yAxis.x;\n  result[2] = zAxis.x;\n  result[3] = xAxis.y;\n  result[4] = yAxis.y;\n  result[5] = zAxis.y;\n  result[6] = xAxis.z;\n  result[7] = yAxis.z;\n  result[8] = zAxis.z;\n  return result;\n}\nconst rotMtxScratch = new Matrix3();\nconst quatScratch = new Quaternion();\n\n/**\n * Computes a rotation from ICRF to a Globe's Fixed axes.\n *\n * @param {JulianDate} date The date to evaluate the matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new instance of the rotation from ICRF to Fixed.\n */\nIauOrientationAxes.prototype.evaluate = function (date, result) {\n  if (!defined(date)) {\n    date = JulianDate.now();\n  }\n  const alphaDeltaW = this._computeFunction(date);\n  const precMtx = computeRotationMatrix(alphaDeltaW.rightAscension, alphaDeltaW.declination, result);\n  const rot = CesiumMath.zeroToTwoPi(alphaDeltaW.rotation);\n  const quat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, rot, quatScratch);\n  const rotMtx = Matrix3.fromQuaternion(Quaternion.conjugate(quat, quat), rotMtxScratch);\n  const cbi2cbf = Matrix3.multiply(rotMtx, precMtx, precMtx);\n  return cbi2cbf;\n};\n\n/**\n * A function that computes the {@link IauOrientationParameters} for a {@link JulianDate}.\n * @callback IauOrientationAxes.ComputeFunction\n * @param {JulianDate} date The date to evaluate the parameters.\n * @returns {IauOrientationParameters} The orientation parameters.\n * @private\n */\nexport default IauOrientationAxes;","map":{"version":3,"names":["Cartesian3","defined","Iau2000Orientation","JulianDate","CesiumMath","Matrix3","Quaternion","IauOrientationAxes","computeFunction","ComputeMoon","_computeFunction","xAxisScratch","yAxisScratch","zAxisScratch","computeRotationMatrix","alpha","delta","result","xAxis","x","Math","cos","PI_OVER_TWO","y","sin","z","cosDec","zAxis","yAxis","cross","rotMtxScratch","quatScratch","prototype","evaluate","date","now","alphaDeltaW","precMtx","rightAscension","declination","rot","zeroToTwoPi","rotation","quat","fromAxisAngle","UNIT_Z","rotMtx","fromQuaternion","conjugate","cbi2cbf","multiply"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/IauOrientationAxes.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport Iau2000Orientation from \"./Iau2000Orientation.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * The Axes representing the orientation of a Globe as represented by the data\n * from the IAU/IAG Working Group reports on rotational elements.\n * @alias IauOrientationAxes\n * @constructor\n *\n * @param {IauOrientationAxes.ComputeFunction} [computeFunction] The function that computes the {@link IauOrientationParameters} given a {@link JulianDate}.\n *\n * @see Iau2000Orientation\n *\n * @private\n */\nfunction IauOrientationAxes(computeFunction) {\n  if (!defined(computeFunction) || typeof computeFunction !== \"function\") {\n    computeFunction = Iau2000Orientation.ComputeMoon;\n  }\n\n  this._computeFunction = computeFunction;\n}\n\nconst xAxisScratch = new Cartesian3();\nconst yAxisScratch = new Cartesian3();\nconst zAxisScratch = new Cartesian3();\n\nfunction computeRotationMatrix(alpha, delta, result) {\n  const xAxis = xAxisScratch;\n  xAxis.x = Math.cos(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.y = Math.sin(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.z = 0.0;\n\n  const cosDec = Math.cos(delta);\n\n  const zAxis = zAxisScratch;\n  zAxis.x = cosDec * Math.cos(alpha);\n  zAxis.y = cosDec * Math.sin(alpha);\n  zAxis.z = Math.sin(delta);\n\n  const yAxis = Cartesian3.cross(zAxis, xAxis, yAxisScratch);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = xAxis.x;\n  result[1] = yAxis.x;\n  result[2] = zAxis.x;\n  result[3] = xAxis.y;\n  result[4] = yAxis.y;\n  result[5] = zAxis.y;\n  result[6] = xAxis.z;\n  result[7] = yAxis.z;\n  result[8] = zAxis.z;\n\n  return result;\n}\n\nconst rotMtxScratch = new Matrix3();\nconst quatScratch = new Quaternion();\n\n/**\n * Computes a rotation from ICRF to a Globe's Fixed axes.\n *\n * @param {JulianDate} date The date to evaluate the matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new instance of the rotation from ICRF to Fixed.\n */\nIauOrientationAxes.prototype.evaluate = function (date, result) {\n  if (!defined(date)) {\n    date = JulianDate.now();\n  }\n\n  const alphaDeltaW = this._computeFunction(date);\n  const precMtx = computeRotationMatrix(\n    alphaDeltaW.rightAscension,\n    alphaDeltaW.declination,\n    result,\n  );\n\n  const rot = CesiumMath.zeroToTwoPi(alphaDeltaW.rotation);\n  const quat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, rot, quatScratch);\n  const rotMtx = Matrix3.fromQuaternion(\n    Quaternion.conjugate(quat, quat),\n    rotMtxScratch,\n  );\n\n  const cbi2cbf = Matrix3.multiply(rotMtx, precMtx, precMtx);\n  return cbi2cbf;\n};\n\n/**\n * A function that computes the {@link IauOrientationParameters} for a {@link JulianDate}.\n * @callback IauOrientationAxes.ComputeFunction\n * @param {JulianDate} date The date to evaluate the parameters.\n * @returns {IauOrientationParameters} The orientation parameters.\n * @private\n */\nexport default IauOrientationAxes;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}