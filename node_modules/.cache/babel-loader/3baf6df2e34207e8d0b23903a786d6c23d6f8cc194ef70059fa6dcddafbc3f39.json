{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport Property from \"./Property.js\";\n\n/**\n * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the\n * data property of each {@link TimeInterval} represents the value at time.\n *\n * @alias TimeIntervalCollectionProperty\n * @constructor\n *\n * @example\n * //Create a Cartesian2 interval property which contains data on August 1st, 2012\n * //and uses a different value every 6 hours.\n * const composite = new Cesium.TimeIntervalCollectionProperty();\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(2.0, 3.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(12.0, 2.7)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(5.0, 12.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : true,\n *     data : new Cesium.Cartesian2(85.0, 4.1)\n * }));\n */\nfunction TimeIntervalCollectionProperty() {\n  this._definitionChanged = new Event();\n  this._intervals = new TimeIntervalCollection();\n  this._intervals.changedEvent.addEventListener(TimeIntervalCollectionProperty.prototype._intervalsChanged, this);\n}\nObject.defineProperties(TimeIntervalCollectionProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof TimeIntervalCollectionProperty.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._intervals.isEmpty;\n    }\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is changed whenever setValue is called with data different\n   * than the current value.\n   * @memberof TimeIntervalCollectionProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n  /**\n   * Gets the interval collection.\n   * @memberof TimeIntervalCollectionProperty.prototype\n   *\n   * @type {TimeIntervalCollection}\n   * @readonly\n   */\n  intervals: {\n    get: function () {\n      return this._intervals;\n    }\n  }\n});\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nTimeIntervalCollectionProperty.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  const value = this._intervals.findDataForIntervalContainingDate(time);\n  if (defined(value) && typeof value.clone === \"function\") {\n    return value.clone(result);\n  }\n  return value;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nTimeIntervalCollectionProperty.prototype.equals = function (other) {\n  return this === other ||\n  //\n  other instanceof TimeIntervalCollectionProperty &&\n  //\n  this._intervals.equals(other._intervals, Property.equals);\n};\n\n/**\n * @private\n */\nTimeIntervalCollectionProperty.prototype._intervalsChanged = function () {\n  this._definitionChanged.raiseEvent(this);\n};\nexport default TimeIntervalCollectionProperty;","map":{"version":3,"names":["defined","Event","JulianDate","TimeIntervalCollection","Property","TimeIntervalCollectionProperty","_definitionChanged","_intervals","changedEvent","addEventListener","prototype","_intervalsChanged","Object","defineProperties","isConstant","get","isEmpty","definitionChanged","intervals","timeScratch","getValue","time","result","now","value","findDataForIntervalContainingDate","clone","equals","other","raiseEvent"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/TimeIntervalCollectionProperty.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport Property from \"./Property.js\";\n\n/**\n * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the\n * data property of each {@link TimeInterval} represents the value at time.\n *\n * @alias TimeIntervalCollectionProperty\n * @constructor\n *\n * @example\n * //Create a Cartesian2 interval property which contains data on August 1st, 2012\n * //and uses a different value every 6 hours.\n * const composite = new Cesium.TimeIntervalCollectionProperty();\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(2.0, 3.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(12.0, 2.7)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : new Cesium.Cartesian2(5.0, 12.4)\n * }));\n * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',\n *     isStartIncluded : true,\n *     isStopIncluded : true,\n *     data : new Cesium.Cartesian2(85.0, 4.1)\n * }));\n */\nfunction TimeIntervalCollectionProperty() {\n  this._definitionChanged = new Event();\n  this._intervals = new TimeIntervalCollection();\n  this._intervals.changedEvent.addEventListener(\n    TimeIntervalCollectionProperty.prototype._intervalsChanged,\n    this,\n  );\n}\n\nObject.defineProperties(TimeIntervalCollectionProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof TimeIntervalCollectionProperty.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._intervals.isEmpty;\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is changed whenever setValue is called with data different\n   * than the current value.\n   * @memberof TimeIntervalCollectionProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n  /**\n   * Gets the interval collection.\n   * @memberof TimeIntervalCollectionProperty.prototype\n   *\n   * @type {TimeIntervalCollection}\n   * @readonly\n   */\n  intervals: {\n    get: function () {\n      return this._intervals;\n    },\n  },\n});\n\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nTimeIntervalCollectionProperty.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n\n  const value = this._intervals.findDataForIntervalContainingDate(time);\n  if (defined(value) && typeof value.clone === \"function\") {\n    return value.clone(result);\n  }\n  return value;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nTimeIntervalCollectionProperty.prototype.equals = function (other) {\n  return (\n    this === other || //\n    (other instanceof TimeIntervalCollectionProperty && //\n      this._intervals.equals(other._intervals, Property.equals))\n  );\n};\n\n/**\n * @private\n */\nTimeIntervalCollectionProperty.prototype._intervalsChanged = function () {\n  this._definitionChanged.raiseEvent(this);\n};\nexport default TimeIntervalCollectionProperty;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,oBAAoB;AACxC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,sBAAsB,MAAM,mCAAmC;AACtE,OAAOC,QAAQ,MAAM,eAAe;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,8BAA8BA,CAAA,EAAG;EACxC,IAAI,CAACC,kBAAkB,GAAG,IAAIL,KAAK,CAAC,CAAC;EACrC,IAAI,CAACM,UAAU,GAAG,IAAIJ,sBAAsB,CAAC,CAAC;EAC9C,IAAI,CAACI,UAAU,CAACC,YAAY,CAACC,gBAAgB,CAC3CJ,8BAA8B,CAACK,SAAS,CAACC,iBAAiB,EAC1D,IACF,CAAC;AACH;AAEAC,MAAM,CAACC,gBAAgB,CAACR,8BAA8B,CAACK,SAAS,EAAE;EAChE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,UAAU,EAAE;IACVC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACR,UAAU,CAACS,OAAO;IAChC;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,iBAAiB,EAAE;IACjBF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,kBAAkB;IAChC;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEY,SAAS,EAAE;IACTH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACR,UAAU;IACxB;EACF;AACF,CAAC,CAAC;AAEF,MAAMY,WAAW,GAAG,IAAIjB,UAAU,CAAC,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACAG,8BAA8B,CAACK,SAAS,CAACU,QAAQ,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAE;EAC1E,IAAI,CAACtB,OAAO,CAACqB,IAAI,CAAC,EAAE;IAClBA,IAAI,GAAGnB,UAAU,CAACqB,GAAG,CAACJ,WAAW,CAAC;EACpC;EAEA,MAAMK,KAAK,GAAG,IAAI,CAACjB,UAAU,CAACkB,iCAAiC,CAACJ,IAAI,CAAC;EACrE,IAAIrB,OAAO,CAACwB,KAAK,CAAC,IAAI,OAAOA,KAAK,CAACE,KAAK,KAAK,UAAU,EAAE;IACvD,OAAOF,KAAK,CAACE,KAAK,CAACJ,MAAM,CAAC;EAC5B;EACA,OAAOE,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,8BAA8B,CAACK,SAAS,CAACiB,MAAM,GAAG,UAAUC,KAAK,EAAE;EACjE,OACE,IAAI,KAAKA,KAAK;EAAI;EACjBA,KAAK,YAAYvB,8BAA8B;EAAI;EAClD,IAAI,CAACE,UAAU,CAACoB,MAAM,CAACC,KAAK,CAACrB,UAAU,EAAEH,QAAQ,CAACuB,MAAM,CAAE;AAEhE,CAAC;;AAED;AACA;AACA;AACAtB,8BAA8B,CAACK,SAAS,CAACC,iBAAiB,GAAG,YAAY;EACvE,IAAI,CAACL,kBAAkB,CAACuB,UAAU,CAAC,IAAI,CAAC;AAC1C,CAAC;AACD,eAAexB,8BAA8B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}