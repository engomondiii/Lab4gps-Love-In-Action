{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nconst scratchU = new Cartesian3();\nconst scratchV = new Cartesian3();\nconst scratchW = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nfunction computeMissingVector(a, b, result) {\n  result = Cartesian3.cross(a, b, result);\n  const magnitude = Cartesian3.magnitude(result);\n  return Cartesian3.multiplyByScalar(result, CesiumMath.EPSILON7 / magnitude, result);\n}\nfunction findOrthogonalVector(a, result) {\n  const temp = Cartesian3.normalize(a, scratchCartesian);\n  const b = Cartesian3.equalsEpsilon(temp, Cartesian3.UNIT_X, CesiumMath.EPSILON6) ? Cartesian3.UNIT_Y : Cartesian3.UNIT_X;\n  return computeMissingVector(a, b, result);\n}\nfunction checkHalfAxes(halfAxes) {\n  let u = Matrix3.getColumn(halfAxes, 0, scratchU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchW);\n  const uZero = Cartesian3.equals(u, Cartesian3.ZERO);\n  const vZero = Cartesian3.equals(v, Cartesian3.ZERO);\n  const wZero = Cartesian3.equals(w, Cartesian3.ZERO);\n  if (!uZero && !vZero && !wZero) {\n    return halfAxes;\n  }\n  if (uZero && vZero && wZero) {\n    halfAxes[0] = CesiumMath.EPSILON7;\n    halfAxes[4] = CesiumMath.EPSILON7;\n    halfAxes[8] = CesiumMath.EPSILON7;\n    return halfAxes;\n  }\n  if (uZero && !vZero && !wZero) {\n    u = computeMissingVector(v, w, u);\n  } else if (!uZero && vZero && !wZero) {\n    v = computeMissingVector(u, w, v);\n  } else if (!uZero && !vZero && wZero) {\n    w = computeMissingVector(v, u, w);\n  } else if (!uZero) {\n    v = findOrthogonalVector(u, v);\n    w = computeMissingVector(v, u, w);\n  } else if (!vZero) {\n    u = findOrthogonalVector(v, u);\n    w = computeMissingVector(v, u, w);\n  } else if (!wZero) {\n    u = findOrthogonalVector(w, u);\n    v = computeMissingVector(w, u, v);\n  }\n  Matrix3.setColumn(halfAxes, 0, u, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, v, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, w, halfAxes);\n  return halfAxes;\n}\n\n/**\n * A tile bounding volume specified as an oriented bounding box.\n * @alias TileOrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n * @private\n */\nfunction TileOrientedBoundingBox(center, halfAxes) {\n  halfAxes = checkHalfAxes(halfAxes);\n  this._orientedBoundingBox = new OrientedBoundingBox(center, halfAxes);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox);\n}\nObject.defineProperties(TileOrientedBoundingBox.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    }\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\n\n/**\n * Computes the distance between this bounding box and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {number} The distance between the camera and the bounding box in meters. Returns 0 if the camera is inside the bounding volume.\n */\nTileOrientedBoundingBox.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  return Math.sqrt(this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC));\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Update the bounding box after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the box.\n * @param {Matrix3} halfAxes The three orthogonal half-axes of the bounding box.\n *                           Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                           cube centered at the origin.\n */\nTileOrientedBoundingBox.prototype.update = function (center, halfAxes) {\n  Cartesian3.clone(center, this._orientedBoundingBox.center);\n  halfAxes = checkHalfAxes(halfAxes);\n  Matrix3.clone(halfAxes, this._orientedBoundingBox.halfAxes);\n  BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox, this._boundingSphere);\n};\n\n/**\n * Creates a debug primitive that shows the outline of the box.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileOrientedBoundingBox.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const geometry = new BoxOutlineGeometry({\n    // Make a 2x2x2 cube\n    minimum: new Cartesian3(-1.0, -1.0, -1.0),\n    maximum: new Cartesian3(1.0, 1.0, 1.0)\n  });\n  const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\nexport default TileOrientedBoundingBox;","map":{"version":3,"names":["BoundingSphere","BoxOutlineGeometry","Cartesian3","Check","ColorGeometryInstanceAttribute","GeometryInstance","Matrix3","Matrix4","CesiumMath","OrientedBoundingBox","PerInstanceColorAppearance","Primitive","scratchU","scratchV","scratchW","scratchCartesian","computeMissingVector","a","b","result","cross","magnitude","multiplyByScalar","EPSILON7","findOrthogonalVector","temp","normalize","equalsEpsilon","UNIT_X","EPSILON6","UNIT_Y","checkHalfAxes","halfAxes","u","getColumn","v","w","uZero","equals","ZERO","vZero","wZero","setColumn","TileOrientedBoundingBox","center","_orientedBoundingBox","_boundingSphere","fromOrientedBoundingBox","Object","defineProperties","prototype","boundingVolume","get","boundingSphere","distanceToCamera","frameState","defined","Math","sqrt","distanceSquaredTo","camera","positionWC","intersectPlane","plane","update","clone","createDebugVolume","color","geometry","minimum","maximum","modelMatrix","fromRotationTranslation","instance","id","attributes","fromColor","geometryInstances","appearance","translucent","flat","asynchronous"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TileOrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\nconst scratchU = new Cartesian3();\nconst scratchV = new Cartesian3();\nconst scratchW = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\n\nfunction computeMissingVector(a, b, result) {\n  result = Cartesian3.cross(a, b, result);\n  const magnitude = Cartesian3.magnitude(result);\n  return Cartesian3.multiplyByScalar(\n    result,\n    CesiumMath.EPSILON7 / magnitude,\n    result,\n  );\n}\n\nfunction findOrthogonalVector(a, result) {\n  const temp = Cartesian3.normalize(a, scratchCartesian);\n  const b = Cartesian3.equalsEpsilon(\n    temp,\n    Cartesian3.UNIT_X,\n    CesiumMath.EPSILON6,\n  )\n    ? Cartesian3.UNIT_Y\n    : Cartesian3.UNIT_X;\n  return computeMissingVector(a, b, result);\n}\n\nfunction checkHalfAxes(halfAxes) {\n  let u = Matrix3.getColumn(halfAxes, 0, scratchU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchW);\n\n  const uZero = Cartesian3.equals(u, Cartesian3.ZERO);\n  const vZero = Cartesian3.equals(v, Cartesian3.ZERO);\n  const wZero = Cartesian3.equals(w, Cartesian3.ZERO);\n\n  if (!uZero && !vZero && !wZero) {\n    return halfAxes;\n  }\n  if (uZero && vZero && wZero) {\n    halfAxes[0] = CesiumMath.EPSILON7;\n    halfAxes[4] = CesiumMath.EPSILON7;\n    halfAxes[8] = CesiumMath.EPSILON7;\n    return halfAxes;\n  }\n  if (uZero && !vZero && !wZero) {\n    u = computeMissingVector(v, w, u);\n  } else if (!uZero && vZero && !wZero) {\n    v = computeMissingVector(u, w, v);\n  } else if (!uZero && !vZero && wZero) {\n    w = computeMissingVector(v, u, w);\n  } else if (!uZero) {\n    v = findOrthogonalVector(u, v);\n    w = computeMissingVector(v, u, w);\n  } else if (!vZero) {\n    u = findOrthogonalVector(v, u);\n    w = computeMissingVector(v, u, w);\n  } else if (!wZero) {\n    u = findOrthogonalVector(w, u);\n    v = computeMissingVector(w, u, v);\n  }\n\n  Matrix3.setColumn(halfAxes, 0, u, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, v, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, w, halfAxes);\n\n  return halfAxes;\n}\n\n/**\n * A tile bounding volume specified as an oriented bounding box.\n * @alias TileOrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n * @private\n */\nfunction TileOrientedBoundingBox(center, halfAxes) {\n  halfAxes = checkHalfAxes(halfAxes);\n  this._orientedBoundingBox = new OrientedBoundingBox(center, halfAxes);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n  );\n}\n\nObject.defineProperties(TileOrientedBoundingBox.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\n/**\n * Computes the distance between this bounding box and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {number} The distance between the camera and the bounding box in meters. Returns 0 if the camera is inside the bounding volume.\n */\nTileOrientedBoundingBox.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  return Math.sqrt(\n    this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC),\n  );\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Update the bounding box after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the box.\n * @param {Matrix3} halfAxes The three orthogonal half-axes of the bounding box.\n *                           Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                           cube centered at the origin.\n */\nTileOrientedBoundingBox.prototype.update = function (center, halfAxes) {\n  Cartesian3.clone(center, this._orientedBoundingBox.center);\n  halfAxes = checkHalfAxes(halfAxes);\n  Matrix3.clone(halfAxes, this._orientedBoundingBox.halfAxes);\n  BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n    this._boundingSphere,\n  );\n};\n\n/**\n * Creates a debug primitive that shows the outline of the box.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileOrientedBoundingBox.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const geometry = new BoxOutlineGeometry({\n    // Make a 2x2x2 cube\n    minimum: new Cartesian3(-1.0, -1.0, -1.0),\n    maximum: new Cartesian3(1.0, 1.0, 1.0),\n  });\n  const modelMatrix = Matrix4.fromRotationTranslation(\n    this.boundingVolume.halfAxes,\n    this.boundingVolume.center,\n  );\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileOrientedBoundingBox;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}