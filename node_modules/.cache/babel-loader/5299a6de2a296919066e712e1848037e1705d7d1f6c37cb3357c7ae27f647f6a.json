{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\n\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n * @param {number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\nlet fromAxisAngleScratch = new Cartesian3();\n\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"axis\", axis);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const halfAngle = angle / 2.0;\n  const s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n  const x = fromAxisAngleScratch.x * s;\n  const y = fromAxisAngleScratch.y * s;\n  const z = fromAxisAngleScratch.z * s;\n  const w = Math.cos(halfAngle);\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\nconst fromRotationMatrixNext = [1, 2, 0];\nconst fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  let root;\n  let x;\n  let y;\n  let z;\n  let w;\n  const m00 = matrix[Matrix3.COLUMN0ROW0];\n  const m11 = matrix[Matrix3.COLUMN1ROW1];\n  const m22 = matrix[Matrix3.COLUMN2ROW2];\n  const trace = m00 + m11 + m22;\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    const next = fromRotationMatrixNext;\n    let i = 0;\n    if (m11 > m00) {\n      i = 1;\n    }\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n    const j = next[i];\n    const k = next[j];\n    root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);\n    const quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;\n    quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;\n    quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\nconst scratchHPRQuaternion = new Quaternion();\nlet scratchHeadingQuaternion = new Quaternion();\nlet scratchPitchQuaternion = new Quaternion();\nlet scratchRollQuaternion = new Quaternion();\n\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, headingPitchRoll.roll, scratchHPRQuaternion);\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -headingPitchRoll.pitch, result);\n  result = Quaternion.multiply(scratchPitchQuaternion, scratchRollQuaternion, scratchPitchQuaternion);\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -headingPitchRoll.heading, scratchHPRQuaternion);\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\nconst sampledQuaternionAxis = new Cartesian3();\nconst sampledQuaternionRotation = new Cartesian3();\nconst sampledQuaternionTempQuaternion = new Quaternion();\nconst sampledQuaternionQuaternion0 = new Quaternion();\nconst sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nQuaternion.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {number}\n */\nQuaternion.packedInterpolationLength = 3;\n\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {number[]} packedArray The packed array.\n * @param {number} [startingIndex=0] The index of the first element to be converted.\n * @param {number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {number[]} [result] The object into which to store the result.\n */\nQuaternion.convertPackedArrayForInterpolation = function (packedArray, startingIndex, lastIndex, result) {\n  Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);\n  Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);\n  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    const offset = i * 3;\n    Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);\n    Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);\n    }\n    Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);\n    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    if (!defined(result)) {\n      result = [];\n    }\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {number[]} array The array previously packed for interpolation.\n * @param {number[]} sourceArray The original packed array.\n * @param {number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpackInterpolationResult = function (array, sourceArray, firstIndex, lastIndex, result) {\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  const magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);\n  }\n  return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);\n};\n\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\nQuaternion.clone = function (quaternion, result) {\n  if (!defined(quaternion)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  }\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {number} The magnitude squared.\n */\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;\n};\n\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {number} The magnitude.\n */\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  const x = quaternion.x * inverseMagnitude;\n  const y = quaternion.y * inverseMagnitude;\n  const z = quaternion.z * inverseMagnitude;\n  const w = quaternion.w * inverseMagnitude;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {number} The dot product.\n */\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n};\n\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const leftW = left.w;\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n  const rightW = right.w;\n  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const w = quaternion.w;\n  if (Math.abs(w - 1.0) < CesiumMath.EPSILON6 || Math.abs(w + 1.0) < CesiumMath.EPSILON6) {\n    result.x = 1;\n    result.y = result.z = 0;\n    return result;\n  }\n  const scalar = 1.0 / Math.sqrt(1.0 - w * w);\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {number} The angle of rotation.\n */\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n    return 0.0;\n  }\n  return 2.0 * Math.acos(quaternion.w);\n};\nlet lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(lerpScratch, result, result);\n};\nlet slerpEndNegated = new Quaternion();\nlet slerpScaledP = new Quaternion();\nlet slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let dot = Quaternion.dot(start, end);\n\n  // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n  let r = end;\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  }\n\n  // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n  if (1.0 - dot < CesiumMath.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n  const theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);\n  slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = CesiumMath.acosClamped(quaternion.w);\n  let thetaOverSinTheta = 0.0;\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = Cartesian3.magnitude(cartesian);\n  let sinThetaOverTheta = 0.0;\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n  return result;\n};\nconst squadScratchCartesian0 = new Cartesian3();\nconst squadScratchCartesian1 = new Cartesian3();\nconst squadScratchQuaternion0 = new Quaternion();\nconst squadScratchQuaternion1 = new Quaternion();\n\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"q2\", q2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n  Cartesian3.add(cart0, cart1, cart0);\n  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\nconst fastSlerpScratchQuaternion = new Quaternion();\n// eslint-disable-next-line no-loss-of-precision\nconst opmu = 1.90110745351730037;\nconst u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nfor (let i = 0; i < 7; ++i) {\n  const s = i + 1.0;\n  const t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\nu[7] = opmu / (8.0 * 17.0);\nv[7] = opmu * 8.0 / 17.0;\n\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let x = Quaternion.dot(start, end);\n  let sign;\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n  const xm1 = x - 1.0;\n  const d = 1.0 - t;\n  const sqrT = t * t;\n  const sqrD = d * d;\n  for (let i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n  const cT = sign * t * (1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  const cD = d * (1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n  const temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return left === right || defined(left) && defined(right) && Math.abs(left.x - right.x) <= epsilon && Math.abs(left.y - right.y) <= epsilon && Math.abs(left.z - right.z) <= epsilon && Math.abs(left.w - right.w) <= epsilon;\n};\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {string} A string representing this Quaternion.\n */\nQuaternion.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\nexport default Quaternion;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","FeatureDetection","CesiumMath","Matrix3","Quaternion","x","y","z","w","fromAxisAngleScratch","fromAxisAngle","axis","angle","result","typeOf","object","number","halfAngle","s","Math","sin","normalize","cos","fromRotationMatrixNext","fromRotationMatrixQuat","Array","fromRotationMatrix","matrix","root","m00","COLUMN0ROW0","m11","COLUMN1ROW1","m22","COLUMN2ROW2","trace","sqrt","COLUMN1ROW2","COLUMN2ROW1","COLUMN2ROW0","COLUMN0ROW2","COLUMN0ROW1","COLUMN1ROW0","next","i","j","k","getElementIndex","quat","scratchHPRQuaternion","scratchHeadingQuaternion","scratchPitchQuaternion","scratchRollQuaternion","fromHeadingPitchRoll","headingPitchRoll","UNIT_X","roll","UNIT_Y","pitch","multiply","UNIT_Z","heading","sampledQuaternionAxis","sampledQuaternionRotation","sampledQuaternionTempQuaternion","sampledQuaternionQuaternion0","sampledQuaternionQuaternion0Conjugate","packedLength","pack","value","array","startingIndex","unpack","packedInterpolationLength","convertPackedArrayForInterpolation","packedArray","lastIndex","conjugate","len","offset","negate","computeAxis","computeAngle","unpackInterpolationResult","sourceArray","firstIndex","fromArray","magnitude","clone","IDENTITY","quaternion","undefined","magnitudeSquared","inverseMagnitude","inverse","multiplyByScalar","add","left","right","subtract","dot","leftX","leftY","leftZ","leftW","rightX","rightY","rightZ","rightW","scalar","divideByScalar","abs","EPSILON6","acos","lerpScratch","lerp","start","end","t","slerpEndNegated","slerpScaledP","slerpScaledR","slerp","r","theta","log","acosClamped","thetaOverSinTheta","exp","cartesian","sinThetaOverTheta","squadScratchCartesian0","squadScratchCartesian1","squadScratchQuaternion0","squadScratchQuaternion1","computeInnerQuadrangle","q0","q1","q2","qInv","cart0","cart1","squad","s0","s1","slerp0","slerp1","fastSlerpScratchQuaternion","opmu","u","supportsTypedArrays","Float32Array","v","bT","bD","fastSlerp","sign","xm1","d","sqrT","sqrD","cT","cD","temp","fastSquad","equals","equalsEpsilon","epsilon","ZERO","Object","freeze","prototype","toString"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Quaternion.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\n\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n * @param {number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\nlet fromAxisAngleScratch = new Cartesian3();\n\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"axis\", axis);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const halfAngle = angle / 2.0;\n  const s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n\n  const x = fromAxisAngleScratch.x * s;\n  const y = fromAxisAngleScratch.y * s;\n  const z = fromAxisAngleScratch.z * s;\n  const w = Math.cos(halfAngle);\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst fromRotationMatrixNext = [1, 2, 0];\nconst fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  let root;\n  let x;\n  let y;\n  let z;\n  let w;\n\n  const m00 = matrix[Matrix3.COLUMN0ROW0];\n  const m11 = matrix[Matrix3.COLUMN1ROW1];\n  const m22 = matrix[Matrix3.COLUMN2ROW2];\n  const trace = m00 + m11 + m22;\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    const next = fromRotationMatrixNext;\n\n    let i = 0;\n    if (m11 > m00) {\n      i = 1;\n    }\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n    const j = next[i];\n    const k = next[j];\n\n    root = Math.sqrt(\n      matrix[Matrix3.getElementIndex(i, i)] -\n        matrix[Matrix3.getElementIndex(j, j)] -\n        matrix[Matrix3.getElementIndex(k, k)] +\n        1.0,\n    );\n\n    const quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w =\n      (matrix[Matrix3.getElementIndex(k, j)] -\n        matrix[Matrix3.getElementIndex(j, k)]) *\n      root;\n    quat[j] =\n      (matrix[Matrix3.getElementIndex(j, i)] +\n        matrix[Matrix3.getElementIndex(i, j)]) *\n      root;\n    quat[k] =\n      (matrix[Matrix3.getElementIndex(k, i)] +\n        matrix[Matrix3.getElementIndex(i, k)]) *\n      root;\n\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst scratchHPRQuaternion = new Quaternion();\nlet scratchHeadingQuaternion = new Quaternion();\nlet scratchPitchQuaternion = new Quaternion();\nlet scratchRollQuaternion = new Quaternion();\n\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_X,\n    headingPitchRoll.roll,\n    scratchHPRQuaternion,\n  );\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -headingPitchRoll.pitch,\n    result,\n  );\n  result = Quaternion.multiply(\n    scratchPitchQuaternion,\n    scratchRollQuaternion,\n    scratchPitchQuaternion,\n  );\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -headingPitchRoll.heading,\n    scratchHPRQuaternion,\n  );\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\n\nconst sampledQuaternionAxis = new Cartesian3();\nconst sampledQuaternionRotation = new Cartesian3();\nconst sampledQuaternionTempQuaternion = new Quaternion();\nconst sampledQuaternionQuaternion0 = new Quaternion();\nconst sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nQuaternion.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {number}\n */\nQuaternion.packedInterpolationLength = 3;\n\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {number[]} packedArray The packed array.\n * @param {number} [startingIndex=0] The index of the first element to be converted.\n * @param {number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {number[]} [result] The object into which to store the result.\n */\nQuaternion.convertPackedArrayForInterpolation = function (\n  packedArray,\n  startingIndex,\n  lastIndex,\n  result,\n) {\n  Quaternion.unpack(\n    packedArray,\n    lastIndex * 4,\n    sampledQuaternionQuaternion0Conjugate,\n  );\n  Quaternion.conjugate(\n    sampledQuaternionQuaternion0Conjugate,\n    sampledQuaternionQuaternion0Conjugate,\n  );\n\n  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    const offset = i * 3;\n    Quaternion.unpack(\n      packedArray,\n      (startingIndex + i) * 4,\n      sampledQuaternionTempQuaternion,\n    );\n\n    Quaternion.multiply(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionQuaternion0Conjugate,\n      sampledQuaternionTempQuaternion,\n    );\n\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(\n        sampledQuaternionTempQuaternion,\n        sampledQuaternionTempQuaternion,\n      );\n    }\n\n    Quaternion.computeAxis(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionAxis,\n    );\n    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    if (!defined(result)) {\n      result = [];\n    }\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {number[]} array The array previously packed for interpolation.\n * @param {number[]} sourceArray The original packed array.\n * @param {number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpackInterpolationResult = function (\n  array,\n  sourceArray,\n  firstIndex,\n  lastIndex,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  const magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(\n      sampledQuaternionRotation,\n      magnitude,\n      sampledQuaternionTempQuaternion,\n    );\n  }\n\n  return Quaternion.multiply(\n    sampledQuaternionTempQuaternion,\n    sampledQuaternionQuaternion0,\n    result,\n  );\n};\n\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\nQuaternion.clone = function (quaternion, result) {\n  if (!defined(quaternion)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w,\n    );\n  }\n\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {number} The magnitude squared.\n */\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  return (\n    quaternion.x * quaternion.x +\n    quaternion.y * quaternion.y +\n    quaternion.z * quaternion.z +\n    quaternion.w * quaternion.w\n  );\n};\n\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {number} The magnitude.\n */\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  const x = quaternion.x * inverseMagnitude;\n  const y = quaternion.y * inverseMagnitude;\n  const z = quaternion.z * inverseMagnitude;\n  const w = quaternion.w * inverseMagnitude;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {number} The dot product.\n */\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const leftW = left.w;\n\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n  const rightW = right.w;\n\n  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const w = quaternion.w;\n  if (\n    Math.abs(w - 1.0) < CesiumMath.EPSILON6 ||\n    Math.abs(w + 1.0) < CesiumMath.EPSILON6\n  ) {\n    result.x = 1;\n    result.y = result.z = 0;\n    return result;\n  }\n\n  const scalar = 1.0 / Math.sqrt(1.0 - w * w);\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {number} The angle of rotation.\n */\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n    return 0.0;\n  }\n  return 2.0 * Math.acos(quaternion.w);\n};\n\nlet lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(lerpScratch, result, result);\n};\n\nlet slerpEndNegated = new Quaternion();\nlet slerpScaledP = new Quaternion();\nlet slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let dot = Quaternion.dot(start, end);\n\n  // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n  let r = end;\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  }\n\n  // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n  if (1.0 - dot < CesiumMath.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n\n  const theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(\n    start,\n    Math.sin((1 - t) * theta),\n    slerpScaledP,\n  );\n  slerpScaledR = Quaternion.multiplyByScalar(\n    r,\n    Math.sin(t * theta),\n    slerpScaledR,\n  );\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = CesiumMath.acosClamped(quaternion.w);\n  let thetaOverSinTheta = 0.0;\n\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n\n  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = Cartesian3.magnitude(cartesian);\n  let sinThetaOverTheta = 0.0;\n\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n\n  return result;\n};\n\nconst squadScratchCartesian0 = new Cartesian3();\nconst squadScratchCartesian1 = new Cartesian3();\nconst squadScratchQuaternion0 = new Quaternion();\nconst squadScratchQuaternion1 = new Quaternion();\n\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"q2\", q2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n\n  Cartesian3.add(cart0, cart1, cart0);\n  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\nconst fastSlerpScratchQuaternion = new Quaternion();\n// eslint-disable-next-line no-loss-of-precision\nconst opmu = 1.90110745351730037;\nconst u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\nfor (let i = 0; i < 7; ++i) {\n  const s = i + 1.0;\n  const t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\n\nu[7] = opmu / (8.0 * 17.0);\nv[7] = (opmu * 8.0) / 17.0;\n\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let x = Quaternion.dot(start, end);\n\n  let sign;\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n\n  const xm1 = x - 1.0;\n  const d = 1.0 - t;\n  const sqrT = t * t;\n  const sqrD = d * d;\n\n  for (let i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n\n  const cT =\n    sign *\n    t *\n    (1.0 +\n      bT[0] *\n        (1.0 +\n          bT[1] *\n            (1.0 +\n              bT[2] *\n                (1.0 +\n                  bT[3] *\n                    (1.0 +\n                      bT[4] *\n                        (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  const cD =\n    d *\n    (1.0 +\n      bD[0] *\n        (1.0 +\n          bD[1] *\n            (1.0 +\n              bD[2] *\n                (1.0 +\n                  bD[3] *\n                    (1.0 +\n                      bD[4] *\n                        (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n\n  const temp = Quaternion.multiplyByScalar(\n    start,\n    cD,\n    fastSlerpScratchQuaternion,\n  );\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.x - right.x) <= epsilon &&\n      Math.abs(left.y - right.y) <= epsilon &&\n      Math.abs(left.z - right.z) <= epsilon &&\n      Math.abs(left.w - right.w) <= epsilon)\n  );\n};\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {string} A string representing this Quaternion.\n */\nQuaternion.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\nexport default Quaternion;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}