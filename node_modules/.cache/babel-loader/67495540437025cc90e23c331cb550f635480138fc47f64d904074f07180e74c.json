{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport MetadataPicking from \"./MetadataPicking.js\";\nimport PickDepth from \"./PickDepth.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport View from \"./View.js\";\nconst offscreenDefaultWidth = 0.1;\nconst mostDetailedPreloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PRELOAD\n});\nconst mostDetailedPickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PICK\n});\nconst pickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PICK\n});\n\n/**\n * @private\n */\nfunction Picking(scene) {\n  this._mostDetailedRayPicks = [];\n  this.pickRenderStateCache = {};\n  this._pickPositionCache = {};\n  this._pickPositionCacheDirty = false;\n  const pickOffscreenViewport = new BoundingRectangle(0, 0, 1, 1);\n  const pickOffscreenCamera = new Camera(scene);\n  pickOffscreenCamera.frustum = new OrthographicFrustum({\n    width: offscreenDefaultWidth,\n    aspectRatio: 1.0,\n    near: 0.1\n  });\n  this._pickOffscreenView = new View(scene, pickOffscreenCamera, pickOffscreenViewport);\n}\nPicking.prototype.update = function () {\n  this._pickPositionCacheDirty = true;\n};\nPicking.prototype.getPickDepth = function (scene, index) {\n  const pickDepths = scene.view.pickDepths;\n  let pickDepth = pickDepths[index];\n  if (!defined(pickDepth)) {\n    pickDepth = new PickDepth();\n    pickDepths[index] = pickDepth;\n  }\n  return pickDepth;\n};\nconst scratchOrthoPickingFrustum = new OrthographicOffCenterFrustum();\nconst scratchOrthoOrigin = new Cartesian3();\nconst scratchOrthoDirection = new Cartesian3();\nconst scratchOrthoPixelSize = new Cartesian2();\nconst scratchOrthoPickVolumeMatrix4 = new Matrix4();\nfunction getPickOrthographicCullingVolume(scene, drawingBufferPosition, width, height, viewport) {\n  const camera = scene.camera;\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  let x = 2.0 * (drawingBufferPosition.x - viewport.x) / viewport.width - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y = 2.0 * (viewport.height - drawingBufferPosition.y - viewport.y) / viewport.height - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n  const transform = Matrix4.clone(camera.transform, scratchOrthoPickVolumeMatrix4);\n  camera._setTransform(Matrix4.IDENTITY);\n  const origin = Cartesian3.clone(camera.position, scratchOrthoOrigin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n  camera._setTransform(transform);\n  if (scene.mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(origin.z, origin.x, origin.y, origin);\n  }\n  const pixelSize = frustum.getPixelDimensions(viewport.width, viewport.height, 1.0, 1.0, scratchOrthoPixelSize);\n  const ortho = scratchOrthoPickingFrustum;\n  ortho.right = pixelSize.x * 0.5;\n  ortho.left = -ortho.right;\n  ortho.top = pixelSize.y * 0.5;\n  ortho.bottom = -ortho.top;\n  ortho.near = frustum.near;\n  ortho.far = frustum.far;\n  return ortho.computeCullingVolume(origin, camera.directionWC, camera.upWC);\n}\nconst scratchPerspPickingFrustum = new PerspectiveOffCenterFrustum();\nconst scratchPerspPixelSize = new Cartesian2();\nfunction getPickPerspectiveCullingVolume(scene, drawingBufferPosition, width, height, viewport) {\n  const camera = scene.camera;\n  const frustum = camera.frustum;\n  const near = frustum.near;\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n  const x = 2.0 * (drawingBufferPosition.x - viewport.x) / viewport.width - 1.0;\n  const y = 2.0 * (viewport.height - drawingBufferPosition.y - viewport.y) / viewport.height - 1.0;\n  const xDir = x * near * tanTheta;\n  const yDir = y * near * tanPhi;\n  const pixelSize = frustum.getPixelDimensions(viewport.width, viewport.height, 1.0, 1.0, scratchPerspPixelSize);\n  const pickWidth = pixelSize.x * width * 0.5;\n  const pickHeight = pixelSize.y * height * 0.5;\n  const offCenter = scratchPerspPickingFrustum;\n  offCenter.top = yDir + pickHeight;\n  offCenter.bottom = yDir - pickHeight;\n  offCenter.right = xDir + pickWidth;\n  offCenter.left = xDir - pickWidth;\n  offCenter.near = near;\n  offCenter.far = frustum.far;\n  return offCenter.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n}\nfunction getPickCullingVolume(scene, drawingBufferPosition, width, height, viewport) {\n  const frustum = scene.camera.frustum;\n  if (frustum instanceof OrthographicFrustum || frustum instanceof OrthographicOffCenterFrustum) {\n    return getPickOrthographicCullingVolume(scene, drawingBufferPosition, width, height, viewport);\n  }\n  return getPickPerspectiveCullingVolume(scene, drawingBufferPosition, width, height, viewport);\n}\n\n// Pick position and rectangle, used in all picking functions,\n// filled in computePickingDrawingBufferRectangle and passed\n// the the FrameBuffer begin/end methods\nconst scratchRectangle = new BoundingRectangle(0.0, 0.0, 3.0, 3.0);\nconst scratchPosition = new Cartesian2();\n\n// Dummy color that is passed to updateAndExecuteCommands in\n// all picking functions, used as the \"background color\"\nconst scratchColorZero = new Color(0.0, 0.0, 0.0, 0.0);\n\n/**\n * Compute the rectangle that describes the part of the drawing buffer\n * that is relevant for picking.\n *\n * @param {number} drawingBufferHeight The height of the drawing buffer\n * @param {Cartesian2} position The position inside the drawing buffer\n * @param {number|undefined} width The width of the rectangle, assumed to\n * be an odd integer number, default : 3.0\n * @param {number|undefined} height The height of the rectangle. If unspecified,\n * height will default to the value of <code>width</code>\n * @param {BoundingRectangle} result The result rectangle\n * @returns {BoundingRectangle} The result rectangle\n */\nfunction computePickingDrawingBufferRectangle(drawingBufferHeight, position, width, height, result) {\n  result.width = defaultValue(width, 3.0);\n  result.height = defaultValue(height, result.width);\n  result.x = position.x - (result.width - 1.0) * 0.5;\n  result.y = drawingBufferHeight - position.y - (result.height - 1.0) * 0.5;\n  return result;\n}\n\n/**\n * Returns an object with a <code>primitive</code> property that contains the first (top) primitive in the scene\n * at a particular window coordinate or undefined if nothing is at the location. Other properties may\n * potentially be set depending on the type of primitive and may be used to further identify the picked object.\n * <p>\n * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.\n * </p>\n * @param {Scene} scene\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {number} [width=3] Width of the pick rectangle.\n * @param {number} [height=3] Height of the pick rectangle.\n * @returns {object} Object containing the picked primitive.\n */\nPicking.prototype.pick = function (scene, windowPosition, width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"windowPosition\", windowPosition);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    frameState,\n    defaultView\n  } = scene;\n  const {\n    viewport,\n    pickFramebuffer\n  } = defaultView;\n  scene.view = defaultView;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(scene, windowPosition, scratchPosition);\n  const drawingBufferRectangle = computePickingDrawingBufferRectangle(context.drawingBufferHeight, drawingBufferPosition, width, height, scratchRectangle);\n  scene.jobScheduler.disableThisFrame();\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(scene, drawingBufferPosition, drawingBufferRectangle.width, drawingBufferRectangle.height, viewport);\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n  context.uniformState.update(frameState);\n  scene.updateEnvironment();\n  passState = pickFramebuffer.begin(drawingBufferRectangle, viewport);\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  const object = pickFramebuffer.end(drawingBufferRectangle);\n  context.endFrame();\n  return object;\n};\n\n/**\n * Returns an object with information about the voxel sample rendered at\n * a particular window coordinate. Returns <code>undefined</code> if there is no\n * voxel at that position.\n *\n * @param {Scene} scene\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {number} [width=3] Width of the pick rectangle.\n * @param {number} [height=3] Height of the pick rectangle.\n * @returns {object|undefined} Object containing the picked primitive.\n */\nPicking.prototype.pickVoxelCoordinate = function (scene, windowPosition, width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"windowPosition\", windowPosition);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    frameState,\n    defaultView\n  } = scene;\n  const {\n    viewport,\n    pickFramebuffer\n  } = defaultView;\n  scene.view = defaultView;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(scene, windowPosition, scratchPosition);\n  const drawingBufferRectangle = computePickingDrawingBufferRectangle(context.drawingBufferHeight, drawingBufferPosition, width, height, scratchRectangle);\n  scene.jobScheduler.disableThisFrame();\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(scene, drawingBufferPosition, drawingBufferRectangle.width, drawingBufferRectangle.height, viewport);\n  frameState.invertClassification = false;\n  frameState.passes.pickVoxel = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n  context.uniformState.update(frameState);\n  scene.updateEnvironment();\n  passState = pickFramebuffer.begin(drawingBufferRectangle, viewport);\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  const voxelInfo = pickFramebuffer.readCenterPixel(drawingBufferRectangle);\n  context.endFrame();\n  return voxelInfo;\n};\n\n/**\n * Pick a metadata value at the given window position.\n *\n * The given `pickedMetadataInfo` defines the metadata value that is\n * supposed to be picked.\n *\n * The return type will depend on the type of the metadata property\n * that is picked. Given the current limitations of the types that\n * are supported for metadata picking, the return type will be one\n * of the following:\n *\n * - For `SCALAR`, the return type will be a `number`\n * - For `SCALAR` arrays, the return type will be a `number[]`\n * - For `VEC2`, the return type will be a `Cartesian2`\n * - For `VEC3`, the return type will be a `Cartesian3`\n * - For `VEC4`, the return type will be a `Cartesian4`\n *\n * Future implementations may additionally return `string`- or\n * `boolean` types, and `MATn` values as `MatrixN` objects,\n * and arrays of the respective types.\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {PickedMetadataInfo} pickedMetadataInfo Information about the picked metadata.\n * @returns {MetadataValue|undefined} The metadata value, or `undefined`\n * when no matching metadata value could be picked at the given position\n *\n * @private\n */\nPicking.prototype.pickMetadata = function (scene, windowPosition, pickedMetadataInfo) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"windowPosition\", windowPosition);\n  Check.typeOf.object(\"pickedMetadataInfo\", pickedMetadataInfo);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    frameState,\n    defaultView\n  } = scene;\n  const {\n    viewport,\n    pickFramebuffer\n  } = defaultView;\n  scene.view = defaultView;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(scene, windowPosition, scratchPosition);\n  const drawingBufferRectangle = computePickingDrawingBufferRectangle(context.drawingBufferHeight, drawingBufferPosition, 1.0, 1.0, scratchRectangle);\n  scene.jobScheduler.disableThisFrame();\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(scene, drawingBufferPosition, drawingBufferRectangle.width, drawingBufferRectangle.height, viewport);\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  // Insert the information about the picked metadata property\n  // into the frame state, so that the `Scene.updateDerivedCommands`\n  // call can detect any changes in the picked metadata description,\n  // and update the derived commands for the new picked metadata\n  // property\n  frameState.pickingMetadata = true;\n  frameState.pickedMetadataInfo = pickedMetadataInfo;\n  context.uniformState.update(frameState);\n  scene.updateEnvironment();\n  passState = pickFramebuffer.begin(drawingBufferRectangle, viewport);\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n\n  // When OIT is enabled, then the resolveFrameBuffers function\n  // will juggle around several frame buffers, and eventually use\n  // the \"environmentState.originalFramebuffer\" instead of the\n  // picking frame buffer. Skipping a million questions, just\n  // switch OIT off here:\n  const oldOIT = scene._environmentState.useOIT;\n  scene._environmentState.useOIT = false;\n  scene.resolveFramebuffers(passState);\n  scene._environmentState.useOIT = oldOIT;\n  const rawMetadataPixel = pickFramebuffer.readCenterPixel(drawingBufferRectangle);\n  context.endFrame();\n  frameState.pickingMetadata = false;\n  const metadataValue = MetadataPicking.decodeMetadataValues(pickedMetadataInfo.classProperty, pickedMetadataInfo.metadataProperty, rawMetadataPixel);\n  return metadataValue;\n};\n\n/**\n * @typedef {object} PickedMetadataInfo\n *\n * Information about metadata that is supposed to be picked\n *\n * @property {string|undefined} schemaId The optional ID of the metadata schema\n * @property {string} className The name of the metadata class\n * @property {string} propertyName The name of the metadata property\n * @property {MetadataClassProperty} classProperty The metadata class property\n */\n\nfunction renderTranslucentDepthForPick(scene, drawingBufferPosition) {\n  // PERFORMANCE_IDEA: render translucent only and merge with the previous frame\n  const {\n    defaultView,\n    context,\n    frameState,\n    environmentState\n  } = scene;\n  const {\n    viewport,\n    pickDepthFramebuffer\n  } = defaultView;\n  scene.view = defaultView;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n  scene.clearPasses(frameState.passes);\n  frameState.passes.pick = true;\n  frameState.passes.depth = true;\n  frameState.cullingVolume = getPickCullingVolume(scene, drawingBufferPosition, 1, 1, viewport);\n  frameState.tilesetPassState = pickTilesetPassState;\n  scene.updateEnvironment();\n  environmentState.renderTranslucentDepthForPick = true;\n  passState = pickDepthFramebuffer.update(context, drawingBufferPosition, viewport);\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  context.endFrame();\n}\nconst scratchPerspectiveFrustum = new PerspectiveFrustum();\nconst scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nconst scratchOrthographicFrustum = new OrthographicFrustum();\nconst scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\nPicking.prototype.pickPositionWorldCoordinates = function (scene, windowPosition, result) {\n  if (!scene.useDepthPicking) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"windowPosition\", windowPosition);\n  if (!scene.context.depthTexture) {\n    throw new DeveloperError(\"Picking from the depth buffer is not supported. Check pickPositionSupported.\");\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = windowPosition.toString();\n  if (this._pickPositionCacheDirty) {\n    this._pickPositionCache = {};\n    this._pickPositionCacheDirty = false;\n  } else if (this._pickPositionCache.hasOwnProperty(cacheKey)) {\n    return Cartesian3.clone(this._pickPositionCache[cacheKey], result);\n  }\n  const {\n    context,\n    frameState,\n    camera,\n    defaultView\n  } = scene;\n  const {\n    uniformState\n  } = context;\n  scene.view = defaultView;\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(scene, windowPosition, scratchPosition);\n  if (scene.pickTranslucentDepth) {\n    renderTranslucentDepthForPick(scene, drawingBufferPosition);\n  } else {\n    scene.updateFrameState();\n    uniformState.update(frameState);\n    scene.updateEnvironment();\n  }\n  drawingBufferPosition.y = scene.drawingBufferHeight - drawingBufferPosition.y;\n\n  // Create a working frustum from the original camera frustum.\n  let frustum;\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n  const {\n    frustumCommandsList\n  } = defaultView;\n  const numFrustums = frustumCommandsList.length;\n  for (let i = 0; i < numFrustums; ++i) {\n    const pickDepth = this.getPickDepth(scene, i);\n    const depth = pickDepth.getDepth(context, drawingBufferPosition.x, drawingBufferPosition.y);\n    if (!defined(depth)) {\n      continue;\n    }\n    if (depth > 0.0 && depth < 1.0) {\n      const renderedFrustum = frustumCommandsList[i];\n      let height2D;\n      if (scene.mode === SceneMode.SCENE2D) {\n        height2D = camera.position.z;\n        camera.position.z = height2D - renderedFrustum.near + 1.0;\n        frustum.far = Math.max(1.0, renderedFrustum.far - renderedFrustum.near);\n        frustum.near = 1.0;\n        uniformState.update(frameState);\n        uniformState.updateFrustum(frustum);\n      } else {\n        frustum.near = renderedFrustum.near * (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        frustum.far = renderedFrustum.far;\n        uniformState.updateFrustum(frustum);\n      }\n      result = SceneTransforms.drawingBufferToWorldCoordinates(scene, drawingBufferPosition, depth, result);\n      if (scene.mode === SceneMode.SCENE2D) {\n        camera.position.z = height2D;\n        uniformState.update(frameState);\n      }\n      this._pickPositionCache[cacheKey] = Cartesian3.clone(result);\n      return result;\n    }\n  }\n  this._pickPositionCache[cacheKey] = undefined;\n  return undefined;\n};\nconst scratchPickPositionCartographic = new Cartographic();\nPicking.prototype.pickPosition = function (scene, windowPosition, result) {\n  result = this.pickPositionWorldCoordinates(scene, windowPosition, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n    const projection = scene.mapProjection;\n    const ellipsoid = projection.ellipsoid;\n    const cart = projection.unproject(result, scratchPickPositionCartographic);\n    ellipsoid.cartographicToCartesian(cart, result);\n  }\n  return result;\n};\nfunction drillPick(limit, pickCallback) {\n  // PERFORMANCE_IDEA: This function calls each primitive's update for each pass. Instead\n  // we could update the primitive once, and then just execute their commands for each pass,\n  // and cull commands for picked primitives.  e.g., base on the command's owner.\n  let i;\n  let attributes;\n  const result = [];\n  const pickedPrimitives = [];\n  const pickedAttributes = [];\n  const pickedFeatures = [];\n  if (!defined(limit)) {\n    limit = Number.MAX_VALUE;\n  }\n  let pickedResult = pickCallback();\n  while (defined(pickedResult)) {\n    const object = pickedResult.object;\n    const position = pickedResult.position;\n    const exclude = pickedResult.exclude;\n    if (defined(position) && !defined(object)) {\n      result.push(pickedResult);\n      break;\n    }\n    if (!defined(object) || !defined(object.primitive)) {\n      break;\n    }\n    if (!exclude) {\n      result.push(pickedResult);\n      if (0 >= --limit) {\n        break;\n      }\n    }\n    const primitive = object.primitive;\n    let hasShowAttribute = false;\n\n    // If the picked object has a show attribute, use it.\n    if (typeof primitive.getGeometryInstanceAttributes === \"function\") {\n      if (defined(object.id)) {\n        attributes = primitive.getGeometryInstanceAttributes(object.id);\n        if (defined(attributes) && defined(attributes.show)) {\n          hasShowAttribute = true;\n          attributes.show = ShowGeometryInstanceAttribute.toValue(false, attributes.show);\n          pickedAttributes.push(attributes);\n        }\n      }\n    }\n    if (object instanceof Cesium3DTileFeature) {\n      hasShowAttribute = true;\n      object.show = false;\n      pickedFeatures.push(object);\n    }\n\n    // Otherwise, hide the entire primitive\n    if (!hasShowAttribute) {\n      primitive.show = false;\n      pickedPrimitives.push(primitive);\n    }\n    pickedResult = pickCallback();\n  }\n\n  // Unhide everything we hid while drill picking\n  for (i = 0; i < pickedPrimitives.length; ++i) {\n    pickedPrimitives[i].show = true;\n  }\n  for (i = 0; i < pickedAttributes.length; ++i) {\n    attributes = pickedAttributes[i];\n    attributes.show = ShowGeometryInstanceAttribute.toValue(true, attributes.show);\n  }\n  for (i = 0; i < pickedFeatures.length; ++i) {\n    pickedFeatures[i].show = true;\n  }\n  return result;\n}\nPicking.prototype.drillPick = function (scene, windowPosition, limit, width, height) {\n  const that = this;\n  const pickCallback = function () {\n    const object = that.pick(scene, windowPosition, width, height);\n    if (defined(object)) {\n      return {\n        object: object,\n        position: undefined,\n        exclude: false\n      };\n    }\n  };\n  const objects = drillPick(limit, pickCallback);\n  return objects.map(function (element) {\n    return element.object;\n  });\n};\nconst scratchRight = new Cartesian3();\nconst scratchUp = new Cartesian3();\nfunction MostDetailedRayPick(ray, width, tilesets) {\n  this.ray = ray;\n  this.width = width;\n  this.tilesets = tilesets;\n  this.ready = false;\n  const pick = this;\n  this.promise = new Promise(resolve => {\n    pick._completePick = () => {\n      resolve();\n    };\n  });\n}\nfunction updateOffscreenCameraFromRay(picking, ray, width, camera) {\n  const direction = ray.direction;\n  const orthogonalAxis = Cartesian3.mostOrthogonalAxis(direction, scratchRight);\n  const right = Cartesian3.cross(direction, orthogonalAxis, scratchRight);\n  const up = Cartesian3.cross(direction, right, scratchUp);\n  camera.position = ray.origin;\n  camera.direction = direction;\n  camera.up = up;\n  camera.right = right;\n  camera.frustum.width = defaultValue(width, offscreenDefaultWidth);\n  return camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);\n}\nfunction updateMostDetailedRayPick(picking, scene, rayPick) {\n  const frameState = scene.frameState;\n  const {\n    ray,\n    width,\n    tilesets\n  } = rayPick;\n  const camera = picking._pickOffscreenView.camera;\n  const cullingVolume = updateOffscreenCameraFromRay(picking, ray, width, camera);\n  const tilesetPassState = mostDetailedPreloadTilesetPassState;\n  tilesetPassState.camera = camera;\n  tilesetPassState.cullingVolume = cullingVolume;\n  let ready = true;\n  const tilesetsLength = tilesets.length;\n  for (let i = 0; i < tilesetsLength; ++i) {\n    const tileset = tilesets[i];\n    if (tileset.show && scene.primitives.contains(tileset)) {\n      // Only update tilesets that are still contained in the scene's primitive collection and are still visible\n      // Update tilesets continually until all tilesets are ready. This way tiles are never removed from the cache.\n      tileset.updateForPass(frameState, tilesetPassState);\n      ready = ready && tilesetPassState.ready;\n    }\n  }\n  if (ready) {\n    rayPick._completePick();\n  }\n  return ready;\n}\nPicking.prototype.updateMostDetailedRayPicks = function (scene) {\n  // Modifies array during iteration\n  const rayPicks = this._mostDetailedRayPicks;\n  for (let i = 0; i < rayPicks.length; ++i) {\n    if (updateMostDetailedRayPick(this, scene, rayPicks[i])) {\n      rayPicks.splice(i--, 1);\n    }\n  }\n};\nfunction getTilesets(primitives, objectsToExclude, tilesets) {\n  for (let i = 0; i < primitives.length; ++i) {\n    const primitive = primitives.get(i);\n    if (primitive.show) {\n      if (defined(primitive.isCesium3DTileset)) {\n        if (!defined(objectsToExclude) || objectsToExclude.indexOf(primitive) === -1) {\n          tilesets.push(primitive);\n        }\n      } else if (primitive instanceof PrimitiveCollection) {\n        getTilesets(primitive, objectsToExclude, tilesets);\n      }\n    }\n  }\n}\nfunction launchMostDetailedRayPick(picking, scene, ray, objectsToExclude, width, callback) {\n  const tilesets = [];\n  getTilesets(scene.primitives, objectsToExclude, tilesets);\n  if (tilesets.length === 0) {\n    return Promise.resolve(callback());\n  }\n  const rayPick = new MostDetailedRayPick(ray, width, tilesets);\n  picking._mostDetailedRayPicks.push(rayPick);\n  return rayPick.promise.then(function () {\n    return callback();\n  });\n}\nfunction isExcluded(object, objectsToExclude) {\n  if (!defined(object) || !defined(objectsToExclude) || objectsToExclude.length === 0) {\n    return false;\n  }\n  return objectsToExclude.indexOf(object) > -1 || objectsToExclude.indexOf(object.primitive) > -1 || objectsToExclude.indexOf(object.id) > -1;\n}\nfunction getRayIntersection(picking, scene, ray, objectsToExclude, width, requirePosition, mostDetailed) {\n  const {\n    context,\n    frameState\n  } = scene;\n  const uniformState = context.uniformState;\n  const view = picking._pickOffscreenView;\n  scene.view = view;\n  updateOffscreenCameraFromRay(picking, ray, width, view.camera);\n  const drawingBufferRectangle = BoundingRectangle.clone(view.viewport, scratchRectangle);\n  const passState = view.pickFramebuffer.begin(drawingBufferRectangle, view.viewport);\n  scene.jobScheduler.disableThisFrame();\n  scene.updateFrameState();\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.passes.offscreen = true;\n  if (mostDetailed) {\n    frameState.tilesetPassState = mostDetailedPickTilesetPassState;\n  } else {\n    frameState.tilesetPassState = pickTilesetPassState;\n  }\n  uniformState.update(frameState);\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n  let position;\n  const object = view.pickFramebuffer.end(drawingBufferRectangle);\n  if (scene.context.depthTexture) {\n    const {\n      frustumCommandsList\n    } = view;\n    const numFrustums = frustumCommandsList.length;\n    for (let i = 0; i < numFrustums; ++i) {\n      const pickDepth = picking.getPickDepth(scene, i);\n      const depth = pickDepth.getDepth(context, 0, 0);\n      if (!defined(depth)) {\n        continue;\n      }\n      if (depth > 0.0 && depth < 1.0) {\n        const renderedFrustum = frustumCommandsList[i];\n        const near = renderedFrustum.near * (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        const far = renderedFrustum.far;\n        const distance = near + depth * (far - near);\n        position = Ray.getPoint(ray, distance);\n        break;\n      }\n    }\n  }\n  scene.view = scene.defaultView;\n  context.endFrame();\n  if (defined(object) || defined(position)) {\n    return {\n      object: object,\n      position: position,\n      exclude: !defined(position) && requirePosition || isExcluded(object, objectsToExclude)\n    };\n  }\n}\nfunction getRayIntersections(picking, scene, ray, limit, objectsToExclude, width, requirePosition, mostDetailed) {\n  const pickCallback = function () {\n    return getRayIntersection(picking, scene, ray, objectsToExclude, width, requirePosition, mostDetailed);\n  };\n  return drillPick(limit, pickCallback);\n}\nfunction pickFromRay(picking, scene, ray, objectsToExclude, width, requirePosition, mostDetailed) {\n  const results = getRayIntersections(picking, scene, ray, 1, objectsToExclude, width, requirePosition, mostDetailed);\n  if (results.length > 0) {\n    return results[0];\n  }\n}\nfunction drillPickFromRay(picking, scene, ray, limit, objectsToExclude, width, requirePosition, mostDetailed) {\n  return getRayIntersections(picking, scene, ray, limit, objectsToExclude, width, requirePosition, mostDetailed);\n}\nfunction deferPromiseUntilPostRender(scene, promise) {\n  // Resolve promise after scene's postRender in case entities are created when the promise resolves.\n  // Entities can't be created between viewer._onTick and viewer._postRender.\n  return new Promise((resolve, reject) => {\n    promise.then(function (result) {\n      const removeCallback = scene.postRender.addEventListener(function () {\n        removeCallback();\n        resolve(result);\n      });\n      scene.requestRender();\n    }).catch(function (error) {\n      reject(error);\n    });\n  });\n}\nPicking.prototype.pickFromRay = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  }\n  //>>includeEnd('debug');\n\n  return pickFromRay(this, scene, ray, objectsToExclude, width, false, false);\n};\nPicking.prototype.drillPickFromRay = function (scene, ray, limit, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  }\n  //>>includeEnd('debug');\n\n  return drillPickFromRay(this, scene, ray, limit, objectsToExclude, width, false, false);\n};\nPicking.prototype.pickFromRayMostDetailed = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  }\n  //>>includeEnd('debug');\n\n  const that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  return deferPromiseUntilPostRender(scene, launchMostDetailedRayPick(that, scene, ray, objectsToExclude, width, function () {\n    return pickFromRay(that, scene, ray, objectsToExclude, width, false, true);\n  }));\n};\nPicking.prototype.drillPickFromRayMostDetailed = function (scene, ray, limit, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"Ray intersections are only supported in 3D mode.\");\n  }\n  //>>includeEnd('debug');\n\n  const that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  return deferPromiseUntilPostRender(scene, launchMostDetailedRayPick(that, scene, ray, objectsToExclude, width, function () {\n    return drillPickFromRay(that, scene, ray, limit, objectsToExclude, width, false, true);\n  }));\n};\nconst scratchSurfacePosition = new Cartesian3();\nconst scratchSurfaceNormal = new Cartesian3();\nconst scratchSurfaceRay = new Ray();\nconst scratchCartographic = new Cartographic();\nfunction getRayForSampleHeight(scene, cartographic) {\n  const ellipsoid = scene.ellipsoid;\n  const height = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  const surfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(cartographic, scratchSurfaceNormal);\n  const surfacePosition = Cartographic.toCartesian(cartographic, ellipsoid, scratchSurfacePosition);\n  const surfaceRay = scratchSurfaceRay;\n  surfaceRay.origin = surfacePosition;\n  surfaceRay.direction = surfaceNormal;\n  const ray = new Ray();\n  Ray.getPoint(surfaceRay, height, ray.origin);\n  Cartesian3.negate(surfaceNormal, ray.direction);\n  return ray;\n}\nfunction getRayForClampToHeight(scene, cartesian) {\n  const ellipsoid = scene.ellipsoid;\n  const cartographic = Cartographic.fromCartesian(cartesian, ellipsoid, scratchCartographic);\n  return getRayForSampleHeight(scene, cartographic);\n}\nfunction getHeightFromCartesian(scene, cartesian) {\n  const ellipsoid = scene.ellipsoid;\n  const cartographic = Cartographic.fromCartesian(cartesian, ellipsoid, scratchCartographic);\n  return cartographic.height;\n}\nfunction sampleHeightMostDetailed(picking, scene, cartographic, objectsToExclude, width) {\n  const ray = getRayForSampleHeight(scene, cartographic);\n  return launchMostDetailedRayPick(picking, scene, ray, objectsToExclude, width, function () {\n    const pickResult = pickFromRay(picking, scene, ray, objectsToExclude, width, true, true);\n    if (defined(pickResult)) {\n      return getHeightFromCartesian(scene, pickResult.position);\n    }\n  });\n}\nfunction clampToHeightMostDetailed(picking, scene, cartesian, objectsToExclude, width, result) {\n  const ray = getRayForClampToHeight(scene, cartesian);\n  return launchMostDetailedRayPick(picking, scene, ray, objectsToExclude, width, function () {\n    const pickResult = pickFromRay(picking, scene, ray, objectsToExclude, width, true, true);\n    if (defined(pickResult)) {\n      return Cartesian3.clone(pickResult.position, result);\n    }\n  });\n}\nPicking.prototype.sampleHeight = function (scene, position, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"position\", position);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeight is only supported in 3D mode.\");\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\"sampleHeight requires depth texture support. Check sampleHeightSupported.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = getRayForSampleHeight(scene, position);\n  const pickResult = pickFromRay(this, scene, ray, objectsToExclude, width, true, false);\n  if (defined(pickResult)) {\n    return getHeightFromCartesian(scene, pickResult.position);\n  }\n};\nPicking.prototype.clampToHeight = function (scene, cartesian, objectsToExclude, width, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeight is only supported in 3D mode.\");\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\"clampToHeight requires depth texture support. Check clampToHeightSupported.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = getRayForClampToHeight(scene, cartesian);\n  const pickResult = pickFromRay(this, scene, ray, objectsToExclude, width, true, false);\n  if (defined(pickResult)) {\n    return Cartesian3.clone(pickResult.position, result);\n  }\n};\nPicking.prototype.sampleHeightMostDetailed = function (scene, positions, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeightMostDetailed is only supported in 3D mode.\");\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\"sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\");\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  const length = positions.length;\n  const promises = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    promises[i] = sampleHeightMostDetailed(this, scene, positions[i], objectsToExclude, width);\n  }\n  return deferPromiseUntilPostRender(scene, Promise.all(promises).then(function (heights) {\n    const length = heights.length;\n    for (let i = 0; i < length; ++i) {\n      positions[i].height = heights[i];\n    }\n    return positions;\n  }));\n};\nPicking.prototype.clampToHeightMostDetailed = function (scene, cartesians, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeightMostDetailed is only supported in 3D mode.\");\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\"clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\");\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude) ? objectsToExclude.slice() : objectsToExclude;\n  const length = cartesians.length;\n  const promises = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    promises[i] = clampToHeightMostDetailed(this, scene, cartesians[i], objectsToExclude, width, cartesians[i]);\n  }\n  return deferPromiseUntilPostRender(scene, Promise.all(promises).then(function (clampedCartesians) {\n    const length = clampedCartesians.length;\n    for (let i = 0; i < length; ++i) {\n      cartesians[i] = clampedCartesians[i];\n    }\n    return cartesians;\n  }));\n};\nPicking.prototype.destroy = function () {\n  this._pickOffscreenView = this._pickOffscreenView && this._pickOffscreenView.destroy();\n};\nexport default Picking;","map":{"version":3,"names":["ApproximateTerrainHeights","BoundingRectangle","Cartesian2","Cartesian3","Cartographic","Check","Color","defaultValue","defined","DeveloperError","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","PerspectiveOffCenterFrustum","Ray","ShowGeometryInstanceAttribute","Camera","Cesium3DTileFeature","Cesium3DTilePass","Cesium3DTilePassState","MetadataPicking","PickDepth","PrimitiveCollection","SceneMode","SceneTransforms","View","offscreenDefaultWidth","mostDetailedPreloadTilesetPassState","pass","MOST_DETAILED_PRELOAD","mostDetailedPickTilesetPassState","MOST_DETAILED_PICK","pickTilesetPassState","PICK","Picking","scene","_mostDetailedRayPicks","pickRenderStateCache","_pickPositionCache","_pickPositionCacheDirty","pickOffscreenViewport","pickOffscreenCamera","frustum","width","aspectRatio","near","_pickOffscreenView","prototype","update","getPickDepth","index","pickDepths","view","pickDepth","scratchOrthoPickingFrustum","scratchOrthoOrigin","scratchOrthoDirection","scratchOrthoPixelSize","scratchOrthoPickVolumeMatrix4","getPickOrthographicCullingVolume","drawingBufferPosition","height","viewport","camera","offCenterFrustum","x","right","left","y","top","bottom","transform","clone","_setTransform","IDENTITY","origin","position","multiplyByScalar","add","up","mode","SCENE2D","fromElements","z","pixelSize","getPixelDimensions","ortho","far","computeCullingVolume","directionWC","upWC","scratchPerspPickingFrustum","scratchPerspPixelSize","getPickPerspectiveCullingVolume","tanPhi","Math","tan","fovy","tanTheta","xDir","yDir","pickWidth","pickHeight","offCenter","positionWC","getPickCullingVolume","scratchRectangle","scratchPosition","scratchColorZero","computePickingDrawingBufferRectangle","drawingBufferHeight","result","pick","windowPosition","context","frameState","defaultView","pickFramebuffer","drawingBufferWidth","passState","transformWindowToDrawingBuffer","drawingBufferRectangle","jobScheduler","disableThisFrame","updateFrameState","cullingVolume","invertClassification","passes","tilesetPassState","uniformState","updateEnvironment","begin","updateAndExecuteCommands","resolveFramebuffers","object","end","endFrame","pickVoxelCoordinate","pickVoxel","voxelInfo","readCenterPixel","pickMetadata","pickedMetadataInfo","typeOf","pickingMetadata","oldOIT","_environmentState","useOIT","rawMetadataPixel","metadataValue","decodeMetadataValues","classProperty","metadataProperty","renderTranslucentDepthForPick","environmentState","pickDepthFramebuffer","clearPasses","depth","scratchPerspectiveFrustum","scratchPerspectiveOffCenterFrustum","scratchOrthographicFrustum","scratchOrthographicOffCenterFrustum","pickPositionWorldCoordinates","useDepthPicking","undefined","depthTexture","cacheKey","toString","hasOwnProperty","pickTranslucentDepth","fov","infiniteProjectionMatrix","frustumCommandsList","numFrustums","length","i","getDepth","renderedFrustum","height2D","max","updateFrustum","opaqueFrustumNearOffset","drawingBufferToWorldCoordinates","scratchPickPositionCartographic","pickPosition","SCENE3D","projection","mapProjection","ellipsoid","cart","unproject","cartographicToCartesian","drillPick","limit","pickCallback","attributes","pickedPrimitives","pickedAttributes","pickedFeatures","Number","MAX_VALUE","pickedResult","exclude","push","primitive","hasShowAttribute","getGeometryInstanceAttributes","id","show","toValue","that","objects","map","element","scratchRight","scratchUp","MostDetailedRayPick","ray","tilesets","ready","promise","Promise","resolve","_completePick","updateOffscreenCameraFromRay","picking","direction","orthogonalAxis","mostOrthogonalAxis","cross","updateMostDetailedRayPick","rayPick","tilesetsLength","tileset","primitives","contains","updateForPass","updateMostDetailedRayPicks","rayPicks","splice","getTilesets","objectsToExclude","get","isCesium3DTileset","indexOf","launchMostDetailedRayPick","callback","then","isExcluded","getRayIntersection","requirePosition","mostDetailed","offscreen","distance","getPoint","getRayIntersections","pickFromRay","results","drillPickFromRay","deferPromiseUntilPostRender","reject","removeCallback","postRender","addEventListener","requestRender","catch","error","pickFromRayMostDetailed","slice","drillPickFromRayMostDetailed","scratchSurfacePosition","scratchSurfaceNormal","scratchSurfaceRay","scratchCartographic","getRayForSampleHeight","cartographic","_defaultMaxTerrainHeight","surfaceNormal","geodeticSurfaceNormalCartographic","surfacePosition","toCartesian","surfaceRay","negate","getRayForClampToHeight","cartesian","fromCartesian","getHeightFromCartesian","sampleHeightMostDetailed","pickResult","clampToHeightMostDetailed","sampleHeight","sampleHeightSupported","clampToHeight","clampToHeightSupported","positions","promises","Array","all","heights","cartesians","clampedCartesians","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Picking.js"],"sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport MetadataPicking from \"./MetadataPicking.js\";\nimport PickDepth from \"./PickDepth.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport View from \"./View.js\";\n\nconst offscreenDefaultWidth = 0.1;\n\nconst mostDetailedPreloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PRELOAD,\n});\n\nconst mostDetailedPickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PICK,\n});\n\nconst pickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PICK,\n});\n\n/**\n * @private\n */\nfunction Picking(scene) {\n  this._mostDetailedRayPicks = [];\n  this.pickRenderStateCache = {};\n  this._pickPositionCache = {};\n  this._pickPositionCacheDirty = false;\n\n  const pickOffscreenViewport = new BoundingRectangle(0, 0, 1, 1);\n  const pickOffscreenCamera = new Camera(scene);\n  pickOffscreenCamera.frustum = new OrthographicFrustum({\n    width: offscreenDefaultWidth,\n    aspectRatio: 1.0,\n    near: 0.1,\n  });\n\n  this._pickOffscreenView = new View(\n    scene,\n    pickOffscreenCamera,\n    pickOffscreenViewport,\n  );\n}\n\nPicking.prototype.update = function () {\n  this._pickPositionCacheDirty = true;\n};\n\nPicking.prototype.getPickDepth = function (scene, index) {\n  const pickDepths = scene.view.pickDepths;\n  let pickDepth = pickDepths[index];\n  if (!defined(pickDepth)) {\n    pickDepth = new PickDepth();\n    pickDepths[index] = pickDepth;\n  }\n  return pickDepth;\n};\n\nconst scratchOrthoPickingFrustum = new OrthographicOffCenterFrustum();\nconst scratchOrthoOrigin = new Cartesian3();\nconst scratchOrthoDirection = new Cartesian3();\nconst scratchOrthoPixelSize = new Cartesian2();\nconst scratchOrthoPickVolumeMatrix4 = new Matrix4();\n\nfunction getPickOrthographicCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport,\n) {\n  const camera = scene.camera;\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n\n  let x = (2.0 * (drawingBufferPosition.x - viewport.x)) / viewport.width - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y =\n    (2.0 * (viewport.height - drawingBufferPosition.y - viewport.y)) /\n      viewport.height -\n    1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  const transform = Matrix4.clone(\n    camera.transform,\n    scratchOrthoPickVolumeMatrix4,\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  const origin = Cartesian3.clone(camera.position, scratchOrthoOrigin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n\n  camera._setTransform(transform);\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(origin.z, origin.x, origin.y, origin);\n  }\n\n  const pixelSize = frustum.getPixelDimensions(\n    viewport.width,\n    viewport.height,\n    1.0,\n    1.0,\n    scratchOrthoPixelSize,\n  );\n\n  const ortho = scratchOrthoPickingFrustum;\n  ortho.right = pixelSize.x * 0.5;\n  ortho.left = -ortho.right;\n  ortho.top = pixelSize.y * 0.5;\n  ortho.bottom = -ortho.top;\n  ortho.near = frustum.near;\n  ortho.far = frustum.far;\n\n  return ortho.computeCullingVolume(origin, camera.directionWC, camera.upWC);\n}\n\nconst scratchPerspPickingFrustum = new PerspectiveOffCenterFrustum();\nconst scratchPerspPixelSize = new Cartesian2();\n\nfunction getPickPerspectiveCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport,\n) {\n  const camera = scene.camera;\n  const frustum = camera.frustum;\n  const near = frustum.near;\n\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n\n  const x =\n    (2.0 * (drawingBufferPosition.x - viewport.x)) / viewport.width - 1.0;\n  const y =\n    (2.0 * (viewport.height - drawingBufferPosition.y - viewport.y)) /\n      viewport.height -\n    1.0;\n\n  const xDir = x * near * tanTheta;\n  const yDir = y * near * tanPhi;\n\n  const pixelSize = frustum.getPixelDimensions(\n    viewport.width,\n    viewport.height,\n    1.0,\n    1.0,\n    scratchPerspPixelSize,\n  );\n  const pickWidth = pixelSize.x * width * 0.5;\n  const pickHeight = pixelSize.y * height * 0.5;\n\n  const offCenter = scratchPerspPickingFrustum;\n  offCenter.top = yDir + pickHeight;\n  offCenter.bottom = yDir - pickHeight;\n  offCenter.right = xDir + pickWidth;\n  offCenter.left = xDir - pickWidth;\n  offCenter.near = near;\n  offCenter.far = frustum.far;\n\n  return offCenter.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC,\n  );\n}\n\nfunction getPickCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport,\n) {\n  const frustum = scene.camera.frustum;\n  if (\n    frustum instanceof OrthographicFrustum ||\n    frustum instanceof OrthographicOffCenterFrustum\n  ) {\n    return getPickOrthographicCullingVolume(\n      scene,\n      drawingBufferPosition,\n      width,\n      height,\n      viewport,\n    );\n  }\n\n  return getPickPerspectiveCullingVolume(\n    scene,\n    drawingBufferPosition,\n    width,\n    height,\n    viewport,\n  );\n}\n\n// Pick position and rectangle, used in all picking functions,\n// filled in computePickingDrawingBufferRectangle and passed\n// the the FrameBuffer begin/end methods\nconst scratchRectangle = new BoundingRectangle(0.0, 0.0, 3.0, 3.0);\nconst scratchPosition = new Cartesian2();\n\n// Dummy color that is passed to updateAndExecuteCommands in\n// all picking functions, used as the \"background color\"\nconst scratchColorZero = new Color(0.0, 0.0, 0.0, 0.0);\n\n/**\n * Compute the rectangle that describes the part of the drawing buffer\n * that is relevant for picking.\n *\n * @param {number} drawingBufferHeight The height of the drawing buffer\n * @param {Cartesian2} position The position inside the drawing buffer\n * @param {number|undefined} width The width of the rectangle, assumed to\n * be an odd integer number, default : 3.0\n * @param {number|undefined} height The height of the rectangle. If unspecified,\n * height will default to the value of <code>width</code>\n * @param {BoundingRectangle} result The result rectangle\n * @returns {BoundingRectangle} The result rectangle\n */\nfunction computePickingDrawingBufferRectangle(\n  drawingBufferHeight,\n  position,\n  width,\n  height,\n  result,\n) {\n  result.width = defaultValue(width, 3.0);\n  result.height = defaultValue(height, result.width);\n  result.x = position.x - (result.width - 1.0) * 0.5;\n  result.y = drawingBufferHeight - position.y - (result.height - 1.0) * 0.5;\n  return result;\n}\n\n/**\n * Returns an object with a <code>primitive</code> property that contains the first (top) primitive in the scene\n * at a particular window coordinate or undefined if nothing is at the location. Other properties may\n * potentially be set depending on the type of primitive and may be used to further identify the picked object.\n * <p>\n * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.\n * </p>\n * @param {Scene} scene\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {number} [width=3] Width of the pick rectangle.\n * @param {number} [height=3] Height of the pick rectangle.\n * @returns {object} Object containing the picked primitive.\n */\nPicking.prototype.pick = function (scene, windowPosition, width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"windowPosition\", windowPosition);\n  //>>includeEnd('debug');\n\n  const { context, frameState, defaultView } = scene;\n  const { viewport, pickFramebuffer } = defaultView;\n\n  scene.view = defaultView;\n\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition,\n  );\n  const drawingBufferRectangle = computePickingDrawingBufferRectangle(\n    context.drawingBufferHeight,\n    drawingBufferPosition,\n    width,\n    height,\n    scratchRectangle,\n  );\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    drawingBufferRectangle.width,\n    drawingBufferRectangle.height,\n    viewport,\n  );\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  context.uniformState.update(frameState);\n\n  scene.updateEnvironment();\n\n  passState = pickFramebuffer.begin(drawingBufferRectangle, viewport);\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  const object = pickFramebuffer.end(drawingBufferRectangle);\n  context.endFrame();\n  return object;\n};\n\n/**\n * Returns an object with information about the voxel sample rendered at\n * a particular window coordinate. Returns <code>undefined</code> if there is no\n * voxel at that position.\n *\n * @param {Scene} scene\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {number} [width=3] Width of the pick rectangle.\n * @param {number} [height=3] Height of the pick rectangle.\n * @returns {object|undefined} Object containing the picked primitive.\n */\nPicking.prototype.pickVoxelCoordinate = function (\n  scene,\n  windowPosition,\n  width,\n  height,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"windowPosition\", windowPosition);\n  //>>includeEnd('debug');\n\n  const { context, frameState, defaultView } = scene;\n  const { viewport, pickFramebuffer } = defaultView;\n\n  scene.view = defaultView;\n\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition,\n  );\n  const drawingBufferRectangle = computePickingDrawingBufferRectangle(\n    context.drawingBufferHeight,\n    drawingBufferPosition,\n    width,\n    height,\n    scratchRectangle,\n  );\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    drawingBufferRectangle.width,\n    drawingBufferRectangle.height,\n    viewport,\n  );\n  frameState.invertClassification = false;\n  frameState.passes.pickVoxel = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  context.uniformState.update(frameState);\n\n  scene.updateEnvironment();\n\n  passState = pickFramebuffer.begin(drawingBufferRectangle, viewport);\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  const voxelInfo = pickFramebuffer.readCenterPixel(drawingBufferRectangle);\n  context.endFrame();\n  return voxelInfo;\n};\n\n/**\n * Pick a metadata value at the given window position.\n *\n * The given `pickedMetadataInfo` defines the metadata value that is\n * supposed to be picked.\n *\n * The return type will depend on the type of the metadata property\n * that is picked. Given the current limitations of the types that\n * are supported for metadata picking, the return type will be one\n * of the following:\n *\n * - For `SCALAR`, the return type will be a `number`\n * - For `SCALAR` arrays, the return type will be a `number[]`\n * - For `VEC2`, the return type will be a `Cartesian2`\n * - For `VEC3`, the return type will be a `Cartesian3`\n * - For `VEC4`, the return type will be a `Cartesian4`\n *\n * Future implementations may additionally return `string`- or\n * `boolean` types, and `MATn` values as `MatrixN` objects,\n * and arrays of the respective types.\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {PickedMetadataInfo} pickedMetadataInfo Information about the picked metadata.\n * @returns {MetadataValue|undefined} The metadata value, or `undefined`\n * when no matching metadata value could be picked at the given position\n *\n * @private\n */\nPicking.prototype.pickMetadata = function (\n  scene,\n  windowPosition,\n  pickedMetadataInfo,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"windowPosition\", windowPosition);\n  Check.typeOf.object(\"pickedMetadataInfo\", pickedMetadataInfo);\n  //>>includeEnd('debug');\n\n  const { context, frameState, defaultView } = scene;\n  const { viewport, pickFramebuffer } = defaultView;\n\n  scene.view = defaultView;\n\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition,\n  );\n  const drawingBufferRectangle = computePickingDrawingBufferRectangle(\n    context.drawingBufferHeight,\n    drawingBufferPosition,\n    1.0,\n    1.0,\n    scratchRectangle,\n  );\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    drawingBufferRectangle.width,\n    drawingBufferRectangle.height,\n    viewport,\n  );\n  frameState.invertClassification = false;\n\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  // Insert the information about the picked metadata property\n  // into the frame state, so that the `Scene.updateDerivedCommands`\n  // call can detect any changes in the picked metadata description,\n  // and update the derived commands for the new picked metadata\n  // property\n  frameState.pickingMetadata = true;\n  frameState.pickedMetadataInfo = pickedMetadataInfo;\n  context.uniformState.update(frameState);\n\n  scene.updateEnvironment();\n\n  passState = pickFramebuffer.begin(drawingBufferRectangle, viewport);\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n\n  // When OIT is enabled, then the resolveFrameBuffers function\n  // will juggle around several frame buffers, and eventually use\n  // the \"environmentState.originalFramebuffer\" instead of the\n  // picking frame buffer. Skipping a million questions, just\n  // switch OIT off here:\n  const oldOIT = scene._environmentState.useOIT;\n  scene._environmentState.useOIT = false;\n  scene.resolveFramebuffers(passState);\n  scene._environmentState.useOIT = oldOIT;\n\n  const rawMetadataPixel = pickFramebuffer.readCenterPixel(\n    drawingBufferRectangle,\n  );\n  context.endFrame();\n\n  frameState.pickingMetadata = false;\n\n  const metadataValue = MetadataPicking.decodeMetadataValues(\n    pickedMetadataInfo.classProperty,\n    pickedMetadataInfo.metadataProperty,\n    rawMetadataPixel,\n  );\n\n  return metadataValue;\n};\n\n/**\n * @typedef {object} PickedMetadataInfo\n *\n * Information about metadata that is supposed to be picked\n *\n * @property {string|undefined} schemaId The optional ID of the metadata schema\n * @property {string} className The name of the metadata class\n * @property {string} propertyName The name of the metadata property\n * @property {MetadataClassProperty} classProperty The metadata class property\n */\n\nfunction renderTranslucentDepthForPick(scene, drawingBufferPosition) {\n  // PERFORMANCE_IDEA: render translucent only and merge with the previous frame\n  const { defaultView, context, frameState, environmentState } = scene;\n  const { viewport, pickDepthFramebuffer } = defaultView;\n\n  scene.view = defaultView;\n\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  let passState = defaultView.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  scene.clearPasses(frameState.passes);\n  frameState.passes.pick = true;\n  frameState.passes.depth = true;\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    1,\n    1,\n    viewport,\n  );\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  scene.updateEnvironment();\n  environmentState.renderTranslucentDepthForPick = true;\n  passState = pickDepthFramebuffer.update(\n    context,\n    drawingBufferPosition,\n    viewport,\n  );\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  context.endFrame();\n}\n\nconst scratchPerspectiveFrustum = new PerspectiveFrustum();\nconst scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nconst scratchOrthographicFrustum = new OrthographicFrustum();\nconst scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nPicking.prototype.pickPositionWorldCoordinates = function (\n  scene,\n  windowPosition,\n  result,\n) {\n  if (!scene.useDepthPicking) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"windowPosition\", windowPosition);\n  if (!scene.context.depthTexture) {\n    throw new DeveloperError(\n      \"Picking from the depth buffer is not supported. Check pickPositionSupported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = windowPosition.toString();\n\n  if (this._pickPositionCacheDirty) {\n    this._pickPositionCache = {};\n    this._pickPositionCacheDirty = false;\n  } else if (this._pickPositionCache.hasOwnProperty(cacheKey)) {\n    return Cartesian3.clone(this._pickPositionCache[cacheKey], result);\n  }\n\n  const { context, frameState, camera, defaultView } = scene;\n  const { uniformState } = context;\n\n  scene.view = defaultView;\n\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition,\n  );\n  if (scene.pickTranslucentDepth) {\n    renderTranslucentDepthForPick(scene, drawingBufferPosition);\n  } else {\n    scene.updateFrameState();\n    uniformState.update(frameState);\n    scene.updateEnvironment();\n  }\n  drawingBufferPosition.y = scene.drawingBufferHeight - drawingBufferPosition.y;\n\n  // Create a working frustum from the original camera frustum.\n  let frustum;\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n\n  const { frustumCommandsList } = defaultView;\n  const numFrustums = frustumCommandsList.length;\n  for (let i = 0; i < numFrustums; ++i) {\n    const pickDepth = this.getPickDepth(scene, i);\n    const depth = pickDepth.getDepth(\n      context,\n      drawingBufferPosition.x,\n      drawingBufferPosition.y,\n    );\n    if (!defined(depth)) {\n      continue;\n    }\n    if (depth > 0.0 && depth < 1.0) {\n      const renderedFrustum = frustumCommandsList[i];\n      let height2D;\n      if (scene.mode === SceneMode.SCENE2D) {\n        height2D = camera.position.z;\n        camera.position.z = height2D - renderedFrustum.near + 1.0;\n        frustum.far = Math.max(1.0, renderedFrustum.far - renderedFrustum.near);\n        frustum.near = 1.0;\n        uniformState.update(frameState);\n        uniformState.updateFrustum(frustum);\n      } else {\n        frustum.near =\n          renderedFrustum.near *\n          (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        frustum.far = renderedFrustum.far;\n        uniformState.updateFrustum(frustum);\n      }\n\n      result = SceneTransforms.drawingBufferToWorldCoordinates(\n        scene,\n        drawingBufferPosition,\n        depth,\n        result,\n      );\n\n      if (scene.mode === SceneMode.SCENE2D) {\n        camera.position.z = height2D;\n        uniformState.update(frameState);\n      }\n\n      this._pickPositionCache[cacheKey] = Cartesian3.clone(result);\n      return result;\n    }\n  }\n\n  this._pickPositionCache[cacheKey] = undefined;\n  return undefined;\n};\n\nconst scratchPickPositionCartographic = new Cartographic();\n\nPicking.prototype.pickPosition = function (scene, windowPosition, result) {\n  result = this.pickPositionWorldCoordinates(scene, windowPosition, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n\n    const projection = scene.mapProjection;\n    const ellipsoid = projection.ellipsoid;\n\n    const cart = projection.unproject(result, scratchPickPositionCartographic);\n    ellipsoid.cartographicToCartesian(cart, result);\n  }\n\n  return result;\n};\n\nfunction drillPick(limit, pickCallback) {\n  // PERFORMANCE_IDEA: This function calls each primitive's update for each pass. Instead\n  // we could update the primitive once, and then just execute their commands for each pass,\n  // and cull commands for picked primitives.  e.g., base on the command's owner.\n  let i;\n  let attributes;\n  const result = [];\n  const pickedPrimitives = [];\n  const pickedAttributes = [];\n  const pickedFeatures = [];\n  if (!defined(limit)) {\n    limit = Number.MAX_VALUE;\n  }\n\n  let pickedResult = pickCallback();\n  while (defined(pickedResult)) {\n    const object = pickedResult.object;\n    const position = pickedResult.position;\n    const exclude = pickedResult.exclude;\n\n    if (defined(position) && !defined(object)) {\n      result.push(pickedResult);\n      break;\n    }\n\n    if (!defined(object) || !defined(object.primitive)) {\n      break;\n    }\n\n    if (!exclude) {\n      result.push(pickedResult);\n      if (0 >= --limit) {\n        break;\n      }\n    }\n\n    const primitive = object.primitive;\n    let hasShowAttribute = false;\n\n    // If the picked object has a show attribute, use it.\n    if (typeof primitive.getGeometryInstanceAttributes === \"function\") {\n      if (defined(object.id)) {\n        attributes = primitive.getGeometryInstanceAttributes(object.id);\n        if (defined(attributes) && defined(attributes.show)) {\n          hasShowAttribute = true;\n          attributes.show = ShowGeometryInstanceAttribute.toValue(\n            false,\n            attributes.show,\n          );\n          pickedAttributes.push(attributes);\n        }\n      }\n    }\n\n    if (object instanceof Cesium3DTileFeature) {\n      hasShowAttribute = true;\n      object.show = false;\n      pickedFeatures.push(object);\n    }\n\n    // Otherwise, hide the entire primitive\n    if (!hasShowAttribute) {\n      primitive.show = false;\n      pickedPrimitives.push(primitive);\n    }\n\n    pickedResult = pickCallback();\n  }\n\n  // Unhide everything we hid while drill picking\n  for (i = 0; i < pickedPrimitives.length; ++i) {\n    pickedPrimitives[i].show = true;\n  }\n\n  for (i = 0; i < pickedAttributes.length; ++i) {\n    attributes = pickedAttributes[i];\n    attributes.show = ShowGeometryInstanceAttribute.toValue(\n      true,\n      attributes.show,\n    );\n  }\n\n  for (i = 0; i < pickedFeatures.length; ++i) {\n    pickedFeatures[i].show = true;\n  }\n\n  return result;\n}\n\nPicking.prototype.drillPick = function (\n  scene,\n  windowPosition,\n  limit,\n  width,\n  height,\n) {\n  const that = this;\n  const pickCallback = function () {\n    const object = that.pick(scene, windowPosition, width, height);\n    if (defined(object)) {\n      return {\n        object: object,\n        position: undefined,\n        exclude: false,\n      };\n    }\n  };\n  const objects = drillPick(limit, pickCallback);\n  return objects.map(function (element) {\n    return element.object;\n  });\n};\n\nconst scratchRight = new Cartesian3();\nconst scratchUp = new Cartesian3();\n\nfunction MostDetailedRayPick(ray, width, tilesets) {\n  this.ray = ray;\n  this.width = width;\n  this.tilesets = tilesets;\n  this.ready = false;\n  const pick = this;\n  this.promise = new Promise((resolve) => {\n    pick._completePick = () => {\n      resolve();\n    };\n  });\n}\n\nfunction updateOffscreenCameraFromRay(picking, ray, width, camera) {\n  const direction = ray.direction;\n  const orthogonalAxis = Cartesian3.mostOrthogonalAxis(direction, scratchRight);\n  const right = Cartesian3.cross(direction, orthogonalAxis, scratchRight);\n  const up = Cartesian3.cross(direction, right, scratchUp);\n\n  camera.position = ray.origin;\n  camera.direction = direction;\n  camera.up = up;\n  camera.right = right;\n\n  camera.frustum.width = defaultValue(width, offscreenDefaultWidth);\n  return camera.frustum.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC,\n  );\n}\n\nfunction updateMostDetailedRayPick(picking, scene, rayPick) {\n  const frameState = scene.frameState;\n\n  const { ray, width, tilesets } = rayPick;\n\n  const camera = picking._pickOffscreenView.camera;\n  const cullingVolume = updateOffscreenCameraFromRay(\n    picking,\n    ray,\n    width,\n    camera,\n  );\n\n  const tilesetPassState = mostDetailedPreloadTilesetPassState;\n  tilesetPassState.camera = camera;\n  tilesetPassState.cullingVolume = cullingVolume;\n\n  let ready = true;\n  const tilesetsLength = tilesets.length;\n  for (let i = 0; i < tilesetsLength; ++i) {\n    const tileset = tilesets[i];\n    if (tileset.show && scene.primitives.contains(tileset)) {\n      // Only update tilesets that are still contained in the scene's primitive collection and are still visible\n      // Update tilesets continually until all tilesets are ready. This way tiles are never removed from the cache.\n      tileset.updateForPass(frameState, tilesetPassState);\n      ready = ready && tilesetPassState.ready;\n    }\n  }\n\n  if (ready) {\n    rayPick._completePick();\n  }\n\n  return ready;\n}\n\nPicking.prototype.updateMostDetailedRayPicks = function (scene) {\n  // Modifies array during iteration\n  const rayPicks = this._mostDetailedRayPicks;\n  for (let i = 0; i < rayPicks.length; ++i) {\n    if (updateMostDetailedRayPick(this, scene, rayPicks[i])) {\n      rayPicks.splice(i--, 1);\n    }\n  }\n};\n\nfunction getTilesets(primitives, objectsToExclude, tilesets) {\n  for (let i = 0; i < primitives.length; ++i) {\n    const primitive = primitives.get(i);\n    if (primitive.show) {\n      if (defined(primitive.isCesium3DTileset)) {\n        if (\n          !defined(objectsToExclude) ||\n          objectsToExclude.indexOf(primitive) === -1\n        ) {\n          tilesets.push(primitive);\n        }\n      } else if (primitive instanceof PrimitiveCollection) {\n        getTilesets(primitive, objectsToExclude, tilesets);\n      }\n    }\n  }\n}\n\nfunction launchMostDetailedRayPick(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  callback,\n) {\n  const tilesets = [];\n  getTilesets(scene.primitives, objectsToExclude, tilesets);\n  if (tilesets.length === 0) {\n    return Promise.resolve(callback());\n  }\n\n  const rayPick = new MostDetailedRayPick(ray, width, tilesets);\n  picking._mostDetailedRayPicks.push(rayPick);\n  return rayPick.promise.then(function () {\n    return callback();\n  });\n}\n\nfunction isExcluded(object, objectsToExclude) {\n  if (\n    !defined(object) ||\n    !defined(objectsToExclude) ||\n    objectsToExclude.length === 0\n  ) {\n    return false;\n  }\n  return (\n    objectsToExclude.indexOf(object) > -1 ||\n    objectsToExclude.indexOf(object.primitive) > -1 ||\n    objectsToExclude.indexOf(object.id) > -1\n  );\n}\n\nfunction getRayIntersection(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed,\n) {\n  const { context, frameState } = scene;\n  const uniformState = context.uniformState;\n\n  const view = picking._pickOffscreenView;\n  scene.view = view;\n\n  updateOffscreenCameraFromRay(picking, ray, width, view.camera);\n\n  const drawingBufferRectangle = BoundingRectangle.clone(\n    view.viewport,\n    scratchRectangle,\n  );\n\n  const passState = view.pickFramebuffer.begin(\n    drawingBufferRectangle,\n    view.viewport,\n  );\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.passes.offscreen = true;\n\n  if (mostDetailed) {\n    frameState.tilesetPassState = mostDetailedPickTilesetPassState;\n  } else {\n    frameState.tilesetPassState = pickTilesetPassState;\n  }\n\n  uniformState.update(frameState);\n\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  let position;\n  const object = view.pickFramebuffer.end(drawingBufferRectangle);\n\n  if (scene.context.depthTexture) {\n    const { frustumCommandsList } = view;\n    const numFrustums = frustumCommandsList.length;\n    for (let i = 0; i < numFrustums; ++i) {\n      const pickDepth = picking.getPickDepth(scene, i);\n      const depth = pickDepth.getDepth(context, 0, 0);\n      if (!defined(depth)) {\n        continue;\n      }\n      if (depth > 0.0 && depth < 1.0) {\n        const renderedFrustum = frustumCommandsList[i];\n        const near =\n          renderedFrustum.near *\n          (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        const far = renderedFrustum.far;\n        const distance = near + depth * (far - near);\n        position = Ray.getPoint(ray, distance);\n        break;\n      }\n    }\n  }\n\n  scene.view = scene.defaultView;\n  context.endFrame();\n\n  if (defined(object) || defined(position)) {\n    return {\n      object: object,\n      position: position,\n      exclude:\n        (!defined(position) && requirePosition) ||\n        isExcluded(object, objectsToExclude),\n    };\n  }\n}\n\nfunction getRayIntersections(\n  picking,\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed,\n) {\n  const pickCallback = function () {\n    return getRayIntersection(\n      picking,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      requirePosition,\n      mostDetailed,\n    );\n  };\n  return drillPick(limit, pickCallback);\n}\n\nfunction pickFromRay(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed,\n) {\n  const results = getRayIntersections(\n    picking,\n    scene,\n    ray,\n    1,\n    objectsToExclude,\n    width,\n    requirePosition,\n    mostDetailed,\n  );\n  if (results.length > 0) {\n    return results[0];\n  }\n}\n\nfunction drillPickFromRay(\n  picking,\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed,\n) {\n  return getRayIntersections(\n    picking,\n    scene,\n    ray,\n    limit,\n    objectsToExclude,\n    width,\n    requirePosition,\n    mostDetailed,\n  );\n}\n\nfunction deferPromiseUntilPostRender(scene, promise) {\n  // Resolve promise after scene's postRender in case entities are created when the promise resolves.\n  // Entities can't be created between viewer._onTick and viewer._postRender.\n  return new Promise((resolve, reject) => {\n    promise\n      .then(function (result) {\n        const removeCallback = scene.postRender.addEventListener(function () {\n          removeCallback();\n          resolve(result);\n        });\n        scene.requestRender();\n      })\n      .catch(function (error) {\n        reject(error);\n      });\n  });\n}\n\nPicking.prototype.pickFromRay = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return pickFromRay(this, scene, ray, objectsToExclude, width, false, false);\n};\n\nPicking.prototype.drillPickFromRay = function (\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return drillPickFromRay(\n    this,\n    scene,\n    ray,\n    limit,\n    objectsToExclude,\n    width,\n    false,\n    false,\n  );\n};\n\nPicking.prototype.pickFromRayMostDetailed = function (\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  return deferPromiseUntilPostRender(\n    scene,\n    launchMostDetailedRayPick(\n      that,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      function () {\n        return pickFromRay(\n          that,\n          scene,\n          ray,\n          objectsToExclude,\n          width,\n          false,\n          true,\n        );\n      },\n    ),\n  );\n};\n\nPicking.prototype.drillPickFromRayMostDetailed = function (\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  return deferPromiseUntilPostRender(\n    scene,\n    launchMostDetailedRayPick(\n      that,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      function () {\n        return drillPickFromRay(\n          that,\n          scene,\n          ray,\n          limit,\n          objectsToExclude,\n          width,\n          false,\n          true,\n        );\n      },\n    ),\n  );\n};\n\nconst scratchSurfacePosition = new Cartesian3();\nconst scratchSurfaceNormal = new Cartesian3();\nconst scratchSurfaceRay = new Ray();\nconst scratchCartographic = new Cartographic();\n\nfunction getRayForSampleHeight(scene, cartographic) {\n  const ellipsoid = scene.ellipsoid;\n  const height = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  const surfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n    cartographic,\n    scratchSurfaceNormal,\n  );\n  const surfacePosition = Cartographic.toCartesian(\n    cartographic,\n    ellipsoid,\n    scratchSurfacePosition,\n  );\n  const surfaceRay = scratchSurfaceRay;\n  surfaceRay.origin = surfacePosition;\n  surfaceRay.direction = surfaceNormal;\n  const ray = new Ray();\n  Ray.getPoint(surfaceRay, height, ray.origin);\n  Cartesian3.negate(surfaceNormal, ray.direction);\n  return ray;\n}\n\nfunction getRayForClampToHeight(scene, cartesian) {\n  const ellipsoid = scene.ellipsoid;\n  const cartographic = Cartographic.fromCartesian(\n    cartesian,\n    ellipsoid,\n    scratchCartographic,\n  );\n  return getRayForSampleHeight(scene, cartographic);\n}\n\nfunction getHeightFromCartesian(scene, cartesian) {\n  const ellipsoid = scene.ellipsoid;\n  const cartographic = Cartographic.fromCartesian(\n    cartesian,\n    ellipsoid,\n    scratchCartographic,\n  );\n  return cartographic.height;\n}\n\nfunction sampleHeightMostDetailed(\n  picking,\n  scene,\n  cartographic,\n  objectsToExclude,\n  width,\n) {\n  const ray = getRayForSampleHeight(scene, cartographic);\n  return launchMostDetailedRayPick(\n    picking,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    function () {\n      const pickResult = pickFromRay(\n        picking,\n        scene,\n        ray,\n        objectsToExclude,\n        width,\n        true,\n        true,\n      );\n      if (defined(pickResult)) {\n        return getHeightFromCartesian(scene, pickResult.position);\n      }\n    },\n  );\n}\n\nfunction clampToHeightMostDetailed(\n  picking,\n  scene,\n  cartesian,\n  objectsToExclude,\n  width,\n  result,\n) {\n  const ray = getRayForClampToHeight(scene, cartesian);\n  return launchMostDetailedRayPick(\n    picking,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    function () {\n      const pickResult = pickFromRay(\n        picking,\n        scene,\n        ray,\n        objectsToExclude,\n        width,\n        true,\n        true,\n      );\n      if (defined(pickResult)) {\n        return Cartesian3.clone(pickResult.position, result);\n      }\n    },\n  );\n}\n\nPicking.prototype.sampleHeight = function (\n  scene,\n  position,\n  objectsToExclude,\n  width,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"position\", position);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeight is only supported in 3D mode.\");\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\n      \"sampleHeight requires depth texture support. Check sampleHeightSupported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ray = getRayForSampleHeight(scene, position);\n  const pickResult = pickFromRay(\n    this,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    true,\n    false,\n  );\n  if (defined(pickResult)) {\n    return getHeightFromCartesian(scene, pickResult.position);\n  }\n};\n\nPicking.prototype.clampToHeight = function (\n  scene,\n  cartesian,\n  objectsToExclude,\n  width,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeight is only supported in 3D mode.\");\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\n      \"clampToHeight requires depth texture support. Check clampToHeightSupported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ray = getRayForClampToHeight(scene, cartesian);\n  const pickResult = pickFromRay(\n    this,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    true,\n    false,\n  );\n  if (defined(pickResult)) {\n    return Cartesian3.clone(pickResult.position, result);\n  }\n};\n\nPicking.prototype.sampleHeightMostDetailed = function (\n  scene,\n  positions,\n  objectsToExclude,\n  width,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"sampleHeightMostDetailed is only supported in 3D mode.\",\n    );\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\n      \"sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  const length = positions.length;\n  const promises = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    promises[i] = sampleHeightMostDetailed(\n      this,\n      scene,\n      positions[i],\n      objectsToExclude,\n      width,\n    );\n  }\n  return deferPromiseUntilPostRender(\n    scene,\n    Promise.all(promises).then(function (heights) {\n      const length = heights.length;\n      for (let i = 0; i < length; ++i) {\n        positions[i].height = heights[i];\n      }\n      return positions;\n    }),\n  );\n};\n\nPicking.prototype.clampToHeightMostDetailed = function (\n  scene,\n  cartesians,\n  objectsToExclude,\n  width,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"clampToHeightMostDetailed is only supported in 3D mode.\",\n    );\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\n      \"clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  const length = cartesians.length;\n  const promises = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    promises[i] = clampToHeightMostDetailed(\n      this,\n      scene,\n      cartesians[i],\n      objectsToExclude,\n      width,\n      cartesians[i],\n    );\n  }\n  return deferPromiseUntilPostRender(\n    scene,\n    Promise.all(promises).then(function (clampedCartesians) {\n      const length = clampedCartesians.length;\n      for (let i = 0; i < length; ++i) {\n        cartesians[i] = clampedCartesians[i];\n      }\n      return cartesians;\n    }),\n  );\n};\n\nPicking.prototype.destroy = function () {\n  this._pickOffscreenView =\n    this._pickOffscreenView && this._pickOffscreenView.destroy();\n};\nexport default Picking;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}