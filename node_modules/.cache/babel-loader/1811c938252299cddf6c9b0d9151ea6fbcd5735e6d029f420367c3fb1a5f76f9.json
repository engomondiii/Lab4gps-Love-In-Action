{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef DIFFUSE_IBL\\n\\\nvec3 sampleDiffuseEnvironment(vec3 cubeDir)\\n\\\n{\\n\\\n    #ifdef CUSTOM_SPHERICAL_HARMONICS\\n\\\n        return czm_sphericalHarmonics(cubeDir, model_sphericalHarmonicCoefficients); \\n\\\n    #else\\n\\\n        return czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \\n\\\n    #endif\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SPECULAR_IBL\\n\\\nvec3 sampleSpecularEnvironment(vec3 cubeDir, float roughness)\\n\\\n{\\n\\\n    #ifdef CUSTOM_SPECULAR_IBL\\n\\\n        float lod = roughness * model_specularEnvironmentMapsMaximumLOD;\\n\\\n        return czm_textureCube(model_specularEnvironmentMaps, cubeDir, lod).rgb;\\n\\\n    #else\\n\\\n        float lod = roughness * czm_specularEnvironmentMapsMaximumLOD;\\n\\\n        return czm_textureCube(czm_specularEnvironmentMaps, cubeDir, lod).rgb;\\n\\\n    #endif\\n\\\n}\\n\\\nvec3 computeSpecularIBL(vec3 cubeDir, float NdotV, vec3 f0, float roughness)\\n\\\n{\\n\\\n    // see https://bruop.github.io/ibl/ at Single Scattering Results\\n\\\n    // Roughness dependent fresnel, from Fdez-Aguera\\n\\\n    vec3 f90 = max(vec3(1.0 - roughness), f0);\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, NdotV);\\n\\\n\\n\\\n    vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\\\n    vec3 specularSample = sampleSpecularEnvironment(cubeDir, roughness);\\n\\\n\\n\\\n    return specularSample * (F * brdfLut.x + brdfLut.y);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL)\\n\\\n/**\\n\\\n * Compute the light contributions from environment maps and spherical harmonic coefficients.\\n\\\n * See Fdez-Aguera, https://www.jcgt.org/published/0008/01/03/paper.pdf, for explanation\\n\\\n * of the single- and multi-scattering terms.\\n\\\n *\\n\\\n * @param {vec3} viewDirectionEC Unit vector pointing from the fragment to the eye position.\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates.\\n\\\n * @param {czm_modelMaterial} The material properties.\\n\\\n * @return {vec3} The computed HDR color.\\n\\\n */\\n\\\nvec3 textureIBL(vec3 viewDirectionEC, vec3 normalEC, czm_modelMaterial material) {\\n\\\n    vec3 f0 = material.specular;\\n\\\n    float roughness = material.roughness;\\n\\\n    float specularWeight = 1.0;\\n\\\n    #ifdef USE_SPECULAR\\n\\\n        specularWeight = material.specularWeight;\\n\\\n    #endif\\n\\\n    float NdotV = clamp(dot(normalEC, viewDirectionEC), 0.0, 1.0);\\n\\\n\\n\\\n    // see https://bruop.github.io/ibl/ at Single Scattering Results\\n\\\n    // Roughness dependent fresnel, from Fdez-Aguera\\n\\\n    vec3 f90 = max(vec3(1.0 - roughness), f0);\\n\\\n    vec3 singleScatterFresnel = fresnelSchlick2(f0, f90, NdotV);\\n\\\n\\n\\\n    vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\\\n    vec3 FssEss = specularWeight * (singleScatterFresnel * brdfLut.x + brdfLut.y);\\n\\\n\\n\\\n    #ifdef DIFFUSE_IBL\\n\\\n        vec3 normalMC = normalize(model_iblReferenceFrameMatrix * normalEC);\\n\\\n        vec3 irradiance = sampleDiffuseEnvironment(normalMC);\\n\\\n\\n\\\n        vec3 averageFresnel = f0 + (1.0 - f0) / 21.0;\\n\\\n        float Ems = specularWeight * (1.0 - brdfLut.x - brdfLut.y);\\n\\\n        vec3 FmsEms = FssEss * averageFresnel * Ems / (1.0 - averageFresnel * Ems);\\n\\\n        vec3 dielectricScattering = (1.0 - FssEss - FmsEms) * material.diffuse;\\n\\\n        vec3 diffuseContribution = irradiance * (FmsEms + dielectricScattering) * model_iblFactor.x;\\n\\\n    #else\\n\\\n        vec3 diffuseContribution = vec3(0.0);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_ANISOTROPY\\n\\\n        // Bend normal to account for anisotropic distortion of specular reflection\\n\\\n        vec3 anisotropyDirection = material.anisotropicB;\\n\\\n        vec3 anisotropicTangent = cross(anisotropyDirection, viewDirectionEC);\\n\\\n        vec3 anisotropicNormal = cross(anisotropicTangent, anisotropyDirection);\\n\\\n        float bendFactor = 1.0 - material.anisotropyStrength * (1.0 - roughness);\\n\\\n        float bendFactorPow4 = bendFactor * bendFactor * bendFactor * bendFactor;\\n\\\n        vec3 bentNormal = normalize(mix(anisotropicNormal, normalEC, bendFactorPow4));\\n\\\n        vec3 reflectEC = reflect(-viewDirectionEC, bentNormal);\\n\\\n    #else\\n\\\n        vec3 reflectEC = reflect(-viewDirectionEC, normalEC);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef SPECULAR_IBL\\n\\\n        vec3 reflectMC = normalize(model_iblReferenceFrameMatrix * reflectEC);\\n\\\n        vec3 radiance = sampleSpecularEnvironment(reflectMC, roughness);\\n\\\n        vec3 specularContribution = radiance * FssEss * model_iblFactor.y;\\n\\\n    #else\\n\\\n        vec3 specularContribution = vec3(0.0);\\n\\\n    #endif\\n\\\n\\n\\\n    return diffuseContribution + specularContribution;\\n\\\n}\\n\\\n#endif\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Model/ImageBasedLightingStageFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef DIFFUSE_IBL\\n\\\nvec3 sampleDiffuseEnvironment(vec3 cubeDir)\\n\\\n{\\n\\\n    #ifdef CUSTOM_SPHERICAL_HARMONICS\\n\\\n        return czm_sphericalHarmonics(cubeDir, model_sphericalHarmonicCoefficients); \\n\\\n    #else\\n\\\n        return czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \\n\\\n    #endif\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SPECULAR_IBL\\n\\\nvec3 sampleSpecularEnvironment(vec3 cubeDir, float roughness)\\n\\\n{\\n\\\n    #ifdef CUSTOM_SPECULAR_IBL\\n\\\n        float lod = roughness * model_specularEnvironmentMapsMaximumLOD;\\n\\\n        return czm_textureCube(model_specularEnvironmentMaps, cubeDir, lod).rgb;\\n\\\n    #else\\n\\\n        float lod = roughness * czm_specularEnvironmentMapsMaximumLOD;\\n\\\n        return czm_textureCube(czm_specularEnvironmentMaps, cubeDir, lod).rgb;\\n\\\n    #endif\\n\\\n}\\n\\\nvec3 computeSpecularIBL(vec3 cubeDir, float NdotV, vec3 f0, float roughness)\\n\\\n{\\n\\\n    // see https://bruop.github.io/ibl/ at Single Scattering Results\\n\\\n    // Roughness dependent fresnel, from Fdez-Aguera\\n\\\n    vec3 f90 = max(vec3(1.0 - roughness), f0);\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, NdotV);\\n\\\n\\n\\\n    vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\\\n    vec3 specularSample = sampleSpecularEnvironment(cubeDir, roughness);\\n\\\n\\n\\\n    return specularSample * (F * brdfLut.x + brdfLut.y);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL)\\n\\\n/**\\n\\\n * Compute the light contributions from environment maps and spherical harmonic coefficients.\\n\\\n * See Fdez-Aguera, https://www.jcgt.org/published/0008/01/03/paper.pdf, for explanation\\n\\\n * of the single- and multi-scattering terms.\\n\\\n *\\n\\\n * @param {vec3} viewDirectionEC Unit vector pointing from the fragment to the eye position.\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates.\\n\\\n * @param {czm_modelMaterial} The material properties.\\n\\\n * @return {vec3} The computed HDR color.\\n\\\n */\\n\\\nvec3 textureIBL(vec3 viewDirectionEC, vec3 normalEC, czm_modelMaterial material) {\\n\\\n    vec3 f0 = material.specular;\\n\\\n    float roughness = material.roughness;\\n\\\n    float specularWeight = 1.0;\\n\\\n    #ifdef USE_SPECULAR\\n\\\n        specularWeight = material.specularWeight;\\n\\\n    #endif\\n\\\n    float NdotV = clamp(dot(normalEC, viewDirectionEC), 0.0, 1.0);\\n\\\n\\n\\\n    // see https://bruop.github.io/ibl/ at Single Scattering Results\\n\\\n    // Roughness dependent fresnel, from Fdez-Aguera\\n\\\n    vec3 f90 = max(vec3(1.0 - roughness), f0);\\n\\\n    vec3 singleScatterFresnel = fresnelSchlick2(f0, f90, NdotV);\\n\\\n\\n\\\n    vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;\\n\\\n    vec3 FssEss = specularWeight * (singleScatterFresnel * brdfLut.x + brdfLut.y);\\n\\\n\\n\\\n    #ifdef DIFFUSE_IBL\\n\\\n        vec3 normalMC = normalize(model_iblReferenceFrameMatrix * normalEC);\\n\\\n        vec3 irradiance = sampleDiffuseEnvironment(normalMC);\\n\\\n\\n\\\n        vec3 averageFresnel = f0 + (1.0 - f0) / 21.0;\\n\\\n        float Ems = specularWeight * (1.0 - brdfLut.x - brdfLut.y);\\n\\\n        vec3 FmsEms = FssEss * averageFresnel * Ems / (1.0 - averageFresnel * Ems);\\n\\\n        vec3 dielectricScattering = (1.0 - FssEss - FmsEms) * material.diffuse;\\n\\\n        vec3 diffuseContribution = irradiance * (FmsEms + dielectricScattering) * model_iblFactor.x;\\n\\\n    #else\\n\\\n        vec3 diffuseContribution = vec3(0.0);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_ANISOTROPY\\n\\\n        // Bend normal to account for anisotropic distortion of specular reflection\\n\\\n        vec3 anisotropyDirection = material.anisotropicB;\\n\\\n        vec3 anisotropicTangent = cross(anisotropyDirection, viewDirectionEC);\\n\\\n        vec3 anisotropicNormal = cross(anisotropicTangent, anisotropyDirection);\\n\\\n        float bendFactor = 1.0 - material.anisotropyStrength * (1.0 - roughness);\\n\\\n        float bendFactorPow4 = bendFactor * bendFactor * bendFactor * bendFactor;\\n\\\n        vec3 bentNormal = normalize(mix(anisotropicNormal, normalEC, bendFactorPow4));\\n\\\n        vec3 reflectEC = reflect(-viewDirectionEC, bentNormal);\\n\\\n    #else\\n\\\n        vec3 reflectEC = reflect(-viewDirectionEC, normalEC);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef SPECULAR_IBL\\n\\\n        vec3 reflectMC = normalize(model_iblReferenceFrameMatrix * reflectEC);\\n\\\n        vec3 radiance = sampleSpecularEnvironment(reflectMC, roughness);\\n\\\n        vec3 specularContribution = radiance * FssEss * model_iblFactor.y;\\n\\\n    #else\\n\\\n        vec3 specularContribution = vec3(0.0);\\n\\\n    #endif\\n\\\n\\n\\\n    return diffuseContribution + specularContribution;\\n\\\n}\\n\\\n#endif\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}