{"ast":null,"code":"import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n */\nfunction TerrainProvider() {\n  DeveloperError.throwInstantiationError();\n}\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event<TerrainProvider.ErrorEvent>}\n   * @readonly\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError\n  },\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError\n  },\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError\n  },\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof TerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: DeveloperError.throwInstantiationError\n  },\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof TerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: DeveloperError.throwInstantiationError\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: DeveloperError.throwInstantiationError\n  }\n});\nconst regularGridIndicesCache = [];\n\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\"The total number of vertices (width * height) must be less than 4,294,967,296.\");\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n  let indices = byWidth[height];\n  if (!defined(indices)) {\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array((width - 1) * (height - 1) * 6);\n    } else {\n      indices = byWidth[height] = new Uint32Array((width - 1) * (height - 1) * 6);\n    }\n    addRegularGridIndices(width, height, indices, 0);\n  }\n  return indices;\n};\nconst regularGridAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\"The total number of vertices (width * height) must be less than 4,294,967,296.\");\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n  let indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    const indices = TerrainProvider.getRegularGridIndices(width, height);\n    const edgeIndices = getEdgeIndices(width, height);\n    const westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    const southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    const eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    const northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast\n    };\n  }\n  return indicesAndEdges;\n};\nconst regularGridAndSkirtAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\"The total number of vertices (width * height) must be less than 4,294,967,296.\");\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n  let indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    const gridVertexCount = width * height;\n    const gridIndexCount = (width - 1) * (height - 1) * 6;\n    const edgeVertexCount = width * 2 + height * 2;\n    const edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    const vertexCount = gridVertexCount + edgeVertexCount;\n    const indexCount = gridIndexCount + edgeIndexCount;\n    const edgeIndices = getEdgeIndices(width, height);\n    const westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    const southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    const eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    const northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n    const indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, gridVertexCount, indices, gridIndexCount);\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount\n    };\n  }\n  return indicesAndEdges;\n};\n\n/**\n * @private\n */\nTerrainProvider.addSkirtIndices = function (westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast, vertexCount, indices, offset) {\n  let vertexIndex = vertexCount;\n  offset = addSkirtIndices(westIndicesSouthToNorth, vertexIndex, indices, offset);\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(southIndicesEastToWest, vertexIndex, indices, offset);\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(eastIndicesNorthToSouth, vertexIndex, indices, offset);\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\nfunction getEdgeIndices(width, height) {\n  const westIndicesSouthToNorth = new Array(height);\n  const southIndicesEastToWest = new Array(width);\n  const eastIndicesNorthToSouth = new Array(height);\n  const northIndicesWestToEast = new Array(width);\n  let i;\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast\n  };\n}\nfunction addRegularGridIndices(width, height, indices, offset) {\n  let index = 0;\n  for (let j = 0; j < height - 1; ++j) {\n    for (let i = 0; i < width - 1; ++i) {\n      const upperLeft = index;\n      const lowerLeft = upperLeft + width;\n      const lowerRight = lowerLeft + 1;\n      const upperRight = upperLeft + 1;\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n      ++index;\n    }\n    ++index;\n  }\n}\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  let previousIndex = edgeIndices[0];\n  const length = edgeIndices.length;\n  for (let i = 1; i < length; ++i) {\n    const index = edgeIndices[i];\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n    previousIndex = index;\n    ++vertexIndex;\n  }\n  return offset;\n}\n\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {number}\n */\nTerrainProvider.heightmapTerrainQuality = 0.25;\n\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {number} An estimated geometric error.\n */\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {\n  return ellipsoid.maximumRadius * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);\n};\n\n/**\n * Requests the geometry for a given tile. The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nTerrainProvider.prototype.requestTileGeometry = DeveloperError.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n * @function\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nTerrainProvider.prototype.getLevelMaximumGeometricError = DeveloperError.throwInstantiationError;\n\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported by the terrain provider, otherwise true or false.\n */\nTerrainProvider.prototype.getTileDataAvailable = DeveloperError.throwInstantiationError;\n\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nTerrainProvider.prototype.loadTileDataAvailability = DeveloperError.throwInstantiationError;\nexport default TerrainProvider;\n\n/**\n * A function that is called when an error occurs.\n * @callback TerrainProvider.ErrorEvent\n *\n * @this TerrainProvider\n * @param {TileProviderError} err An object holding details about the error that occurred.\n */","map":{"version":3,"names":["defined","DeveloperError","IndexDatatype","CesiumMath","TerrainProvider","throwInstantiationError","Object","defineProperties","prototype","errorEvent","get","credit","tilingScheme","hasWaterMask","hasVertexNormals","availability","regularGridIndicesCache","getRegularGridIndices","width","height","FOUR_GIGABYTES","byWidth","indices","SIXTY_FOUR_KILOBYTES","Uint16Array","Uint32Array","addRegularGridIndices","regularGridAndEdgeIndicesCache","getRegularGridIndicesAndEdgeIndices","indicesAndEdges","edgeIndices","getEdgeIndices","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","regularGridAndSkirtAndEdgeIndicesCache","getRegularGridAndSkirtIndicesAndEdgeIndices","gridVertexCount","gridIndexCount","edgeVertexCount","edgeIndexCount","Math","max","vertexCount","indexCount","createTypedArray","addSkirtIndices","indexCountWithoutSkirts","offset","vertexIndex","length","Array","i","index","j","upperLeft","lowerLeft","lowerRight","upperRight","previousIndex","heightmapTerrainQuality","getEstimatedLevelZeroGeometricErrorForAHeightmap","ellipsoid","tileImageWidth","numberOfTilesAtLevelZero","maximumRadius","PI","requestTileGeometry","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/TerrainProvider.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n */\nfunction TerrainProvider() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event<TerrainProvider.ErrorEvent>}\n   * @readonly\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof TerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof TerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\nconst regularGridIndicesCache = [];\n\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n\n  let indices = byWidth[height];\n  if (!defined(indices)) {\n    if (width * height < CesiumMath.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array(\n        (width - 1) * (height - 1) * 6,\n      );\n    } else {\n      indices = byWidth[height] = new Uint32Array(\n        (width - 1) * (height - 1) * 6,\n      );\n    }\n    addRegularGridIndices(width, height, indices, 0);\n  }\n\n  return indices;\n};\n\nconst regularGridAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  let indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    const indices = TerrainProvider.getRegularGridIndices(width, height);\n\n    const edgeIndices = getEdgeIndices(width, height);\n    const westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    const southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    const eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    const northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\nconst regularGridAndSkirtAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (\n  width,\n  height,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (width * height >= CesiumMath.FOUR_GIGABYTES) {\n    throw new DeveloperError(\n      \"The total number of vertices (width * height) must be less than 4,294,967,296.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n  if (!defined(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  let indicesAndEdges = byWidth[height];\n  if (!defined(indicesAndEdges)) {\n    const gridVertexCount = width * height;\n    const gridIndexCount = (width - 1) * (height - 1) * 6;\n    const edgeVertexCount = width * 2 + height * 2;\n    const edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    const vertexCount = gridVertexCount + edgeVertexCount;\n    const indexCount = gridIndexCount + edgeIndexCount;\n\n    const edgeIndices = getEdgeIndices(width, height);\n    const westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    const southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    const eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    const northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    const indices = IndexDatatype.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast,\n      gridVertexCount,\n      indices,\n      gridIndexCount,\n    );\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\n/**\n * @private\n */\nTerrainProvider.addSkirtIndices = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n  vertexCount,\n  indices,\n  offset,\n) {\n  let vertexIndex = vertexCount;\n  offset = addSkirtIndices(\n    westIndicesSouthToNorth,\n    vertexIndex,\n    indices,\n    offset,\n  );\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(\n    southIndicesEastToWest,\n    vertexIndex,\n    indices,\n    offset,\n  );\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(\n    eastIndicesNorthToSouth,\n    vertexIndex,\n    indices,\n    offset,\n  );\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\n\nfunction getEdgeIndices(width, height) {\n  const westIndicesSouthToNorth = new Array(height);\n  const southIndicesEastToWest = new Array(width);\n  const eastIndicesNorthToSouth = new Array(height);\n  const northIndicesWestToEast = new Array(width);\n\n  let i;\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addRegularGridIndices(width, height, indices, offset) {\n  let index = 0;\n  for (let j = 0; j < height - 1; ++j) {\n    for (let i = 0; i < width - 1; ++i) {\n      const upperLeft = index;\n      const lowerLeft = upperLeft + width;\n      const lowerRight = lowerLeft + 1;\n      const upperRight = upperLeft + 1;\n\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n\n      ++index;\n    }\n    ++index;\n  }\n}\n\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  let previousIndex = edgeIndices[0];\n\n  const length = edgeIndices.length;\n  for (let i = 1; i < length; ++i) {\n    const index = edgeIndices[i];\n\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n\n    previousIndex = index;\n    ++vertexIndex;\n  }\n\n  return offset;\n}\n\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {number}\n */\nTerrainProvider.heightmapTerrainQuality = 0.25;\n\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {number} An estimated geometric error.\n */\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (\n  ellipsoid,\n  tileImageWidth,\n  numberOfTilesAtLevelZero,\n) {\n  return (\n    (ellipsoid.maximumRadius *\n      2 *\n      Math.PI *\n      TerrainProvider.heightmapTerrainQuality) /\n    (tileImageWidth * numberOfTilesAtLevelZero)\n  );\n};\n\n/**\n * Requests the geometry for a given tile. The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nTerrainProvider.prototype.requestTileGeometry =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n * @function\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nTerrainProvider.prototype.getLevelMaximumGeometricError =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported by the terrain provider, otherwise true or false.\n */\nTerrainProvider.prototype.getTileDataAvailable =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nTerrainProvider.prototype.loadTileDataAvailability =\n  DeveloperError.throwInstantiationError;\nexport default TerrainProvider;\n\n/**\n * A function that is called when an error occurs.\n * @callback TerrainProvider.ErrorEvent\n *\n * @this TerrainProvider\n * @param {TileProviderError} err An object holding details about the error that occurred.\n */\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,UAAU,MAAM,WAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAAA,EAAG;EACzBH,cAAc,CAACI,uBAAuB,CAAC,CAAC;AAC1C;AAEAC,MAAM,CAACC,gBAAgB,CAACH,eAAe,CAACI,SAAS,EAAE;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAU,EAAE;IACVC,GAAG,EAAET,cAAc,CAACI;EACtB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEM,MAAM,EAAE;IACND,GAAG,EAAET,cAAc,CAACI;EACtB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEO,YAAY,EAAE;IACZF,GAAG,EAAET,cAAc,CAACI;EACtB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEQ,YAAY,EAAE;IACZH,GAAG,EAAET,cAAc,CAACI;EACtB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACES,gBAAgB,EAAE;IAChBJ,GAAG,EAAET,cAAc,CAACI;EACtB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,YAAY,EAAE;IACZL,GAAG,EAAET,cAAc,CAACI;EACtB;AACF,CAAC,CAAC;AAEF,MAAMW,uBAAuB,GAAG,EAAE;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,eAAe,CAACa,qBAAqB,GAAG,UAAUC,KAAK,EAAEC,MAAM,EAAE;EAC/D;EACA,IAAID,KAAK,GAAGC,MAAM,IAAIhB,UAAU,CAACiB,cAAc,EAAE;IAC/C,MAAM,IAAInB,cAAc,CACtB,gFACF,CAAC;EACH;EACA;;EAEA,IAAIoB,OAAO,GAAGL,uBAAuB,CAACE,KAAK,CAAC;EAC5C,IAAI,CAAClB,OAAO,CAACqB,OAAO,CAAC,EAAE;IACr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,EACTC,cAAc,EACdC,wBAAwB,EACxB;EACA,OACGF,SAAS,CAACG,aAAa,GACtB,CAAC,GACDxB,IAAI,CAACyB,EAAE,GACP/D,eAAe,CAACyD,uBAAuB,IACxCG,cAAc,GAAGC,wBAAwB,CAAC;AAE/C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7D,eAAe,CAACI,SAAS,CAAC4D,mBAAmB,GAC3CnE,cAAc,CAACI,uBAAuB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,eAAe,CAACI,SAAS,CAAC6D,6BAA6B,GACrDpE,cAAc,CAACI,uBAAuB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,eAAe,CAACI,SAAS,CAAC8D,oBAAoB,GAC5CrE,cAAc,CAACI,uBAAuB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,eAAe,CAACI,SAAS,CAAC+D,wBAAwB,GAChDtE,cAAc,CAACI,uBAAuB;AACxC,eAAeD,eAAe;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}