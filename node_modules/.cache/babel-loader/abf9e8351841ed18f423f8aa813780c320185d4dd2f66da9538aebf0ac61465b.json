{"ast":null,"code":"import Check from \"../../../../Core/Check.js\";\nimport defaultValue from \"../../../../Core/defaultValue.js\";\nimport defined from \"../../../../Core/defined.js\";\nimport ResourceCache from \"../../../ResourceCache.js\";\nimport ResourceLoader from \"../../../ResourceLoader.js\";\nimport ResourceLoaderState from \"../../../ResourceLoaderState.js\";\nimport PropertyTexture from \"../../../PropertyTexture.js\";\nimport StructuralMetadata from \"../../../StructuralMetadata.js\";\nimport MetadataSchema from \"../../../MetadataSchema.js\";\nimport PpeTexture from \"./PpeTexture.js\";\nimport PpeMetadata from \"./PpeMetadata.js\";\nimport MeshPrimitiveGpmLocal from \"./MeshPrimitiveGpmLocal.js\";\n\n/**\n * Loads glTF NGA_gpm_local from a glTF mesh primitive.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n * This loads the \"ppeTextures\" of the NGA_gpm_local extension of a mesh primitive\n * and stores them in a `MeshPrimitiveGpmLocal` object.\n *\n * This object will be converted into a `StructuralMetadata` object, which may\n * override any `StructuralMetadata` that was read directly from the glTF.\n *\n * @alias GltfMeshPrimitiveGpmLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {string} [options.extension] The <code>NGA_gpm_local</code> extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n */\nfunction GltfMeshPrimitiveGpmLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const extension = options.extension;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const frameState = options.frameState;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._extension = extension;\n  this._supportedImageFormats = supportedImageFormats;\n  this._frameState = frameState;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._textureLoaders = [];\n  this._textureIds = [];\n  this._meshPrimitiveGpmLocal = undefined;\n  this._structuralMetadata = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfMeshPrimitiveGpmLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfMeshPrimitiveGpmLoader.prototype.constructor = GltfMeshPrimitiveGpmLoader;\n}\nObject.defineProperties(GltfMeshPrimitiveGpmLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The parsed GPM extension information from the mesh primitive\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {MeshPrimitiveGpmLocal}\n   * @readonly\n   * @private\n   */\n  meshPrimitiveGpmLocal: {\n    get: function () {\n      return this._meshPrimitiveGpmLocal;\n    }\n  },\n  /**\n   * Returns the result of converting the parsed 'MeshPrimitiveGpmLocal'\n   * into a 'StructuralMetadata'.\n   *\n   * Some details about the translation are intentionally not specified here.\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._structuralMetadata;\n    }\n  }\n});\nGltfMeshPrimitiveGpmLoader.prototype._loadResources = async function () {\n  try {\n    const texturesPromise = this._loadTextures();\n    await texturesPromise;\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._gltf = undefined; // No longer need to hold onto the glTF\n\n    this._state = ResourceLoaderState.LOADED;\n    return this;\n  } catch (error) {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this.unload();\n    this._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load GPM data\";\n    throw this.getError(errorMessage, error);\n  }\n};\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfMeshPrimitiveGpmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = this._loadResources(this);\n  return this._promise;\n};\nfunction gatherUsedTextureIds(gpmExtension) {\n  // Gather the used textures\n  const textureIds = {};\n  const ppeTextures = gpmExtension.ppeTextures;\n  if (defined(ppeTextures)) {\n    for (let i = 0; i < ppeTextures.length; i++) {\n      const ppeTexture = ppeTextures[i];\n      // The texture is a valid textureInfo.\n      textureIds[ppeTexture.index] = ppeTexture;\n    }\n  }\n  return textureIds;\n}\nGltfMeshPrimitiveGpmLoader.prototype._loadTextures = function () {\n  let textureIds;\n  if (defined(this._extension)) {\n    textureIds = gatherUsedTextureIds(this._extension);\n  }\n  const gltf = this._gltf;\n  const gltfResource = this._gltfResource;\n  const baseResource = this._baseResource;\n  const supportedImageFormats = this._supportedImageFormats;\n  const frameState = this._frameState;\n  const asynchronous = this._asynchronous;\n\n  // Load the textures\n  const texturePromises = [];\n  for (const textureId in textureIds) {\n    if (textureIds.hasOwnProperty(textureId)) {\n      const textureLoader = ResourceCache.getTextureLoader({\n        gltf: gltf,\n        textureInfo: textureIds[textureId],\n        gltfResource: gltfResource,\n        baseResource: baseResource,\n        supportedImageFormats: supportedImageFormats,\n        frameState: frameState,\n        asynchronous: asynchronous\n      });\n      this._textureLoaders.push(textureLoader);\n      this._textureIds.push(textureId);\n      texturePromises.push(textureLoader.load());\n    }\n  }\n  return Promise.all(texturePromises);\n};\n\n/**\n * A static mapping from PPE texture property identifier keys\n * to `MetadataSchema` instances. This is used to create each\n * schema (with a certain structure) only ONCE in\n * _obtainPpeTexturesMetadataSchema\n *\n * @private\n */\nGltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache = new Map();\n\n/**\n * Create the JSON description of a metadata class that treats\n * the given PPE texture as a property texture property.\n *\n * @param {PpeTexture} ppeTexture - The PPE texture\n * @param {number} index - The index of the texture in the extension\n * @returns The class JSON\n */\nGltfMeshPrimitiveGpmLoader._createPpeTextureClassJson = function (ppeTexture, index) {\n  const traits = ppeTexture.traits;\n  const ppePropertyName = traits.source;\n\n  // The ppeTexture will have a structure like this:\n  //\n  //\"ppeTextures\" : [\n  //  {\n  //    \"traits\" : {\n  //      \"source\" : \"SIGZ\",\n  //      \"min\" : 0.0,\n  //      \"max\" : 16.0\n  //    },\n  //    \"index\" : 2,\n  //    \"noData\" : 255,\n  //    \"offset\" : 0.0,\n  //    \"scale\" : 0.06274509803921569,\n  //    \"texCoord\" : 1\n  //  },\n  //\n  // This is translated into a single class property here, that defines\n  // the structure of the property texture property.\n  //\n  // Given that `offset` and `scale` may only be applied to integer\n  // property values when they are `normalized`, the values will be\n  // declared as `normalized` here.\n  // The normalization factor will later have to be cancelled out,\n  // with the `scale` being multiplied by 255.\n  const offset = ppeTexture.offset ?? 0.0;\n  const scale = (ppeTexture.scale ?? 1.0) * 255.0;\n  const classJson = {\n    name: `PPE texture class ${index}`,\n    properties: {\n      [ppePropertyName]: {\n        name: \"PPE\",\n        type: \"SCALAR\",\n        componentType: \"UINT8\",\n        normalized: true,\n        offset: offset,\n        scale: scale,\n        min: traits.min,\n        max: traits.max\n      }\n    }\n  };\n  return classJson;\n};\n\n/**\n * Returns the `MetadataSchema` for the PPE textures in the given\n * `MeshPrimitiveGpmLocal` instance.\n *\n * This method will return a (statically/globally) cached metadata\n * schema that reflects the structure of the PPE textures in the\n * given instance, creating and caching it if necessary.\n *\n * For details on the cache key, see `_collectPpeTexturePropertyIdentifiers`\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @returns The `MetadataSchema`\n */\nGltfMeshPrimitiveGpmLoader._obtainPpeTexturesMetadataSchema = function (meshPrimitiveGpmLocal) {\n  const ppeTexturePropertyIdentifiers = GltfMeshPrimitiveGpmLoader._collectPpeTexturePropertyIdentifiers(meshPrimitiveGpmLocal);\n  const key = ppeTexturePropertyIdentifiers.toString();\n  let ppeTexturesMetadataSchema = GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.get(key);\n  if (defined(ppeTexturesMetadataSchema)) {\n    return ppeTexturesMetadataSchema;\n  }\n  const schemaId = `PPE_TEXTURE_SCHEMA_${GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.size}`;\n  const ppeTexturesMetadataSchemaJson = {\n    id: schemaId,\n    classes: {}\n  };\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    const classId = `ppeTexture_${i}`;\n    const classJson = GltfMeshPrimitiveGpmLoader._createPpeTextureClassJson(ppeTexture, i);\n    ppeTexturesMetadataSchemaJson.classes[classId] = classJson;\n  }\n  ppeTexturesMetadataSchema = MetadataSchema.fromJson(ppeTexturesMetadataSchemaJson);\n  GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.set(key, ppeTexturesMetadataSchema);\n  return ppeTexturesMetadataSchema;\n};\n\n/**\n * Creates an array of strings that serve as identifiers for PPE textures.\n *\n * Each glTF may define multiple `ppeTexture` objects within the\n * `NGA_gpm_local` extensions. Each of these textures corresponds\n * to one 'property texture property' in a metadata schema.\n *\n * This method will create an array where each element is a (JSON)\n * string representation of the parts of a GPM PPE texture definition\n * that are relevant for distinguishing two PPE textures in terms\n * of their structure within a `StructuralMetadata`.\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @returns The identifiers\n */\nGltfMeshPrimitiveGpmLoader._collectPpeTexturePropertyIdentifiers = function (meshPrimitiveGpmLocal) {\n  const ppeTexturePropertyIdentifiers = [];\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    // The following will create an identifier that can be used\n    // to define two PPE textures as \"representing the same\n    // property texture property\" within a structural metadata\n    // schema.\n    const classJson = GltfMeshPrimitiveGpmLoader._createPpeTextureClassJson(ppeTexture, i);\n    const ppeTexturePropertyIdentifier = JSON.stringify(classJson);\n    ppeTexturePropertyIdentifiers.push(ppeTexturePropertyIdentifier);\n  }\n  return ppeTexturePropertyIdentifiers;\n};\n\n/**\n * Converts the given `MeshPrimitiveGpmLocal` object into a `StructuralMetadata`\n * object.\n *\n * This will translate the PPE textures from the given object into property\n * texture properties. The schema will be created based on the the structure\n * of the PPE textures.\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @param {object} textures The mapping from texture ID to texture objects\n * @returns The `StructuralMetadata` object\n */\nGltfMeshPrimitiveGpmLoader._convertToStructuralMetadata = function (meshPrimitiveGpmLocal, textures) {\n  const propertyTextures = [];\n  const ppeTexturesMetadataSchema = GltfMeshPrimitiveGpmLoader._obtainPpeTexturesMetadataSchema(meshPrimitiveGpmLocal);\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    const classId = `ppeTexture_${i}`;\n    const traits = ppeTexture.traits;\n    const ppePropertyName = traits.source;\n    const metadataClass = ppeTexturesMetadataSchema.classes[classId];\n    const ppeTextureAsPropertyTexture = {\n      class: classId,\n      properties: {\n        [ppePropertyName]: {\n          index: ppeTexture.index,\n          texCoord: ppeTexture.texCoord\n        }\n      }\n    };\n    propertyTextures.push(new PropertyTexture({\n      id: i,\n      name: ppeTexture.name,\n      propertyTexture: ppeTextureAsPropertyTexture,\n      class: metadataClass,\n      textures: textures\n    }));\n  }\n  const structuralMetadata = new StructuralMetadata({\n    schema: ppeTexturesMetadataSchema,\n    propertyTables: [],\n    propertyTextures: propertyTextures,\n    propertyAttributes: []\n  });\n  return structuralMetadata;\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED) {\n    return false;\n  }\n\n  // The standard process of loading textures\n  // (from GltfStructuralMetadataLoader)\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  let ready = true;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    const textureLoader = textureLoaders[i];\n    const textureReady = textureLoader.process(frameState);\n    ready = ready && textureReady;\n  }\n  if (!ready) {\n    return false;\n  }\n\n  // More of the standard process of loading textures\n  // (from GltfStructuralMetadataLoader)\n  const textures = {};\n  for (let i = 0; i < this._textureIds.length; ++i) {\n    const textureId = this._textureIds[i];\n    const textureLoader = textureLoaders[i];\n    if (!textureLoader.isDestroyed()) {\n      textures[textureId] = textureLoader.texture;\n    }\n  }\n\n  // Convert the JSON representation of the `ppeTextures` that\n  // are found in the extensjon JSON into `PpeTexture` objects\n  const ppeTextures = [];\n  const extension = this._extension;\n  if (defined(extension.ppeTextures)) {\n    const ppeTexturesJson = extension.ppeTextures;\n    for (const ppeTextureJson of ppeTexturesJson) {\n      const traitsJson = ppeTextureJson.traits;\n      const traits = new PpeMetadata({\n        min: traitsJson.min,\n        max: traitsJson.max,\n        source: traitsJson.source\n      });\n      const ppeTexture = new PpeTexture({\n        traits: traits,\n        noData: ppeTextureJson.noData,\n        offset: ppeTextureJson.offset,\n        scale: ppeTextureJson.scale,\n        index: ppeTextureJson.index,\n        texCoord: ppeTextureJson.texCoord\n      });\n      ppeTextures.push(ppeTexture);\n    }\n  }\n  const meshPrimitiveGpmLocal = new MeshPrimitiveGpmLocal(ppeTextures);\n  this._meshPrimitiveGpmLocal = meshPrimitiveGpmLocal;\n  const structuralMetadata = GltfMeshPrimitiveGpmLoader._convertToStructuralMetadata(meshPrimitiveGpmLocal, textures);\n  this._structuralMetadata = structuralMetadata;\n  this._state = ResourceLoaderState.READY;\n  return true;\n};\nGltfMeshPrimitiveGpmLoader.prototype._unloadTextures = function () {\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  this._textureLoaders.length = 0;\n  this._textureIds.length = 0;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.unload = function () {\n  this._unloadTextures();\n  this._gltf = undefined;\n  this._extension = undefined;\n  this._structuralMetadata = undefined;\n};\nexport default GltfMeshPrimitiveGpmLoader;","map":{"version":3,"names":["Check","defaultValue","defined","ResourceCache","ResourceLoader","ResourceLoaderState","PropertyTexture","StructuralMetadata","MetadataSchema","PpeTexture","PpeMetadata","MeshPrimitiveGpmLocal","GltfMeshPrimitiveGpmLoader","options","EMPTY_OBJECT","gltf","extension","gltfResource","baseResource","supportedImageFormats","frameState","cacheKey","asynchronous","typeOf","object","_gltfResource","_baseResource","_gltf","_extension","_supportedImageFormats","_frameState","_cacheKey","_asynchronous","_textureLoaders","_textureIds","_meshPrimitiveGpmLocal","undefined","_structuralMetadata","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","meshPrimitiveGpmLocal","structuralMetadata","_loadResources","texturesPromise","_loadTextures","isDestroyed","LOADED","error","unload","FAILED","errorMessage","getError","load","LOADING","gatherUsedTextureIds","gpmExtension","textureIds","ppeTextures","i","length","ppeTexture","index","texturePromises","textureId","hasOwnProperty","textureLoader","getTextureLoader","textureInfo","push","Promise","all","ppeTexturesMetadataSchemaCache","Map","_createPpeTextureClassJson","traits","ppePropertyName","source","offset","scale","classJson","name","properties","type","componentType","normalized","min","max","_obtainPpeTexturesMetadataSchema","ppeTexturePropertyIdentifiers","_collectPpeTexturePropertyIdentifiers","key","toString","ppeTexturesMetadataSchema","schemaId","size","ppeTexturesMetadataSchemaJson","id","classes","classId","fromJson","set","ppeTexturePropertyIdentifier","JSON","stringify","_convertToStructuralMetadata","textures","propertyTextures","metadataClass","ppeTextureAsPropertyTexture","class","texCoord","propertyTexture","schema","propertyTables","propertyAttributes","process","READY","textureLoaders","textureLoadersLength","ready","textureReady","texture","ppeTexturesJson","ppeTextureJson","traitsJson","noData","_unloadTextures"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/Extensions/Gpm/GltfMeshPrimitiveGpmLoader.js"],"sourcesContent":["import Check from \"../../../../Core/Check.js\";\nimport defaultValue from \"../../../../Core/defaultValue.js\";\nimport defined from \"../../../../Core/defined.js\";\nimport ResourceCache from \"../../../ResourceCache.js\";\nimport ResourceLoader from \"../../../ResourceLoader.js\";\nimport ResourceLoaderState from \"../../../ResourceLoaderState.js\";\nimport PropertyTexture from \"../../../PropertyTexture.js\";\nimport StructuralMetadata from \"../../../StructuralMetadata.js\";\nimport MetadataSchema from \"../../../MetadataSchema.js\";\nimport PpeTexture from \"./PpeTexture.js\";\nimport PpeMetadata from \"./PpeMetadata.js\";\nimport MeshPrimitiveGpmLocal from \"./MeshPrimitiveGpmLocal.js\";\n\n/**\n * Loads glTF NGA_gpm_local from a glTF mesh primitive.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n * This loads the \"ppeTextures\" of the NGA_gpm_local extension of a mesh primitive\n * and stores them in a `MeshPrimitiveGpmLocal` object.\n *\n * This object will be converted into a `StructuralMetadata` object, which may\n * override any `StructuralMetadata` that was read directly from the glTF.\n *\n * @alias GltfMeshPrimitiveGpmLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {string} [options.extension] The <code>NGA_gpm_local</code> extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n */\nfunction GltfMeshPrimitiveGpmLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const extension = options.extension;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const frameState = options.frameState;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._extension = extension;\n  this._supportedImageFormats = supportedImageFormats;\n  this._frameState = frameState;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._textureLoaders = [];\n  this._textureIds = [];\n  this._meshPrimitiveGpmLocal = undefined;\n  this._structuralMetadata = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfMeshPrimitiveGpmLoader.prototype = Object.create(\n    ResourceLoader.prototype,\n  );\n  GltfMeshPrimitiveGpmLoader.prototype.constructor = GltfMeshPrimitiveGpmLoader;\n}\n\nObject.defineProperties(GltfMeshPrimitiveGpmLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n\n  /**\n   * The parsed GPM extension information from the mesh primitive\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {MeshPrimitiveGpmLocal}\n   * @readonly\n   * @private\n   */\n  meshPrimitiveGpmLocal: {\n    get: function () {\n      return this._meshPrimitiveGpmLocal;\n    },\n  },\n\n  /**\n   * Returns the result of converting the parsed 'MeshPrimitiveGpmLocal'\n   * into a 'StructuralMetadata'.\n   *\n   * Some details about the translation are intentionally not specified here.\n   *\n   * @memberof GltfMeshPrimitiveGpmLoader.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._structuralMetadata;\n    },\n  },\n});\n\nGltfMeshPrimitiveGpmLoader.prototype._loadResources = async function () {\n  try {\n    const texturesPromise = this._loadTextures();\n    await texturesPromise;\n\n    if (this.isDestroyed()) {\n      return;\n    }\n\n    this._gltf = undefined; // No longer need to hold onto the glTF\n\n    this._state = ResourceLoaderState.LOADED;\n    return this;\n  } catch (error) {\n    if (this.isDestroyed()) {\n      return;\n    }\n\n    this.unload();\n    this._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load GPM data\";\n    throw this.getError(errorMessage, error);\n  }\n};\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfMeshPrimitiveGpmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = this._loadResources(this);\n  return this._promise;\n};\n\nfunction gatherUsedTextureIds(gpmExtension) {\n  // Gather the used textures\n  const textureIds = {};\n  const ppeTextures = gpmExtension.ppeTextures;\n  if (defined(ppeTextures)) {\n    for (let i = 0; i < ppeTextures.length; i++) {\n      const ppeTexture = ppeTextures[i];\n      // The texture is a valid textureInfo.\n      textureIds[ppeTexture.index] = ppeTexture;\n    }\n  }\n  return textureIds;\n}\n\nGltfMeshPrimitiveGpmLoader.prototype._loadTextures = function () {\n  let textureIds;\n  if (defined(this._extension)) {\n    textureIds = gatherUsedTextureIds(this._extension);\n  }\n\n  const gltf = this._gltf;\n  const gltfResource = this._gltfResource;\n  const baseResource = this._baseResource;\n  const supportedImageFormats = this._supportedImageFormats;\n  const frameState = this._frameState;\n  const asynchronous = this._asynchronous;\n\n  // Load the textures\n  const texturePromises = [];\n  for (const textureId in textureIds) {\n    if (textureIds.hasOwnProperty(textureId)) {\n      const textureLoader = ResourceCache.getTextureLoader({\n        gltf: gltf,\n        textureInfo: textureIds[textureId],\n        gltfResource: gltfResource,\n        baseResource: baseResource,\n        supportedImageFormats: supportedImageFormats,\n        frameState: frameState,\n        asynchronous: asynchronous,\n      });\n      this._textureLoaders.push(textureLoader);\n      this._textureIds.push(textureId);\n      texturePromises.push(textureLoader.load());\n    }\n  }\n\n  return Promise.all(texturePromises);\n};\n\n/**\n * A static mapping from PPE texture property identifier keys\n * to `MetadataSchema` instances. This is used to create each\n * schema (with a certain structure) only ONCE in\n * _obtainPpeTexturesMetadataSchema\n *\n * @private\n */\nGltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache = new Map();\n\n/**\n * Create the JSON description of a metadata class that treats\n * the given PPE texture as a property texture property.\n *\n * @param {PpeTexture} ppeTexture - The PPE texture\n * @param {number} index - The index of the texture in the extension\n * @returns The class JSON\n */\nGltfMeshPrimitiveGpmLoader._createPpeTextureClassJson = function (\n  ppeTexture,\n  index,\n) {\n  const traits = ppeTexture.traits;\n  const ppePropertyName = traits.source;\n\n  // The ppeTexture will have a structure like this:\n  //\n  //\"ppeTextures\" : [\n  //  {\n  //    \"traits\" : {\n  //      \"source\" : \"SIGZ\",\n  //      \"min\" : 0.0,\n  //      \"max\" : 16.0\n  //    },\n  //    \"index\" : 2,\n  //    \"noData\" : 255,\n  //    \"offset\" : 0.0,\n  //    \"scale\" : 0.06274509803921569,\n  //    \"texCoord\" : 1\n  //  },\n  //\n  // This is translated into a single class property here, that defines\n  // the structure of the property texture property.\n  //\n  // Given that `offset` and `scale` may only be applied to integer\n  // property values when they are `normalized`, the values will be\n  // declared as `normalized` here.\n  // The normalization factor will later have to be cancelled out,\n  // with the `scale` being multiplied by 255.\n  const offset = ppeTexture.offset ?? 0.0;\n  const scale = (ppeTexture.scale ?? 1.0) * 255.0;\n  const classJson = {\n    name: `PPE texture class ${index}`,\n    properties: {\n      [ppePropertyName]: {\n        name: \"PPE\",\n        type: \"SCALAR\",\n        componentType: \"UINT8\",\n        normalized: true,\n        offset: offset,\n        scale: scale,\n        min: traits.min,\n        max: traits.max,\n      },\n    },\n  };\n  return classJson;\n};\n\n/**\n * Returns the `MetadataSchema` for the PPE textures in the given\n * `MeshPrimitiveGpmLocal` instance.\n *\n * This method will return a (statically/globally) cached metadata\n * schema that reflects the structure of the PPE textures in the\n * given instance, creating and caching it if necessary.\n *\n * For details on the cache key, see `_collectPpeTexturePropertyIdentifiers`\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @returns The `MetadataSchema`\n */\nGltfMeshPrimitiveGpmLoader._obtainPpeTexturesMetadataSchema = function (\n  meshPrimitiveGpmLocal,\n) {\n  const ppeTexturePropertyIdentifiers =\n    GltfMeshPrimitiveGpmLoader._collectPpeTexturePropertyIdentifiers(\n      meshPrimitiveGpmLocal,\n    );\n  const key = ppeTexturePropertyIdentifiers.toString();\n  let ppeTexturesMetadataSchema =\n    GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.get(key);\n  if (defined(ppeTexturesMetadataSchema)) {\n    return ppeTexturesMetadataSchema;\n  }\n\n  const schemaId = `PPE_TEXTURE_SCHEMA_${GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.size}`;\n  const ppeTexturesMetadataSchemaJson = {\n    id: schemaId,\n    classes: {},\n  };\n\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    const classId = `ppeTexture_${i}`;\n    const classJson = GltfMeshPrimitiveGpmLoader._createPpeTextureClassJson(\n      ppeTexture,\n      i,\n    );\n    ppeTexturesMetadataSchemaJson.classes[classId] = classJson;\n  }\n\n  ppeTexturesMetadataSchema = MetadataSchema.fromJson(\n    ppeTexturesMetadataSchemaJson,\n  );\n  GltfMeshPrimitiveGpmLoader.ppeTexturesMetadataSchemaCache.set(\n    key,\n    ppeTexturesMetadataSchema,\n  );\n  return ppeTexturesMetadataSchema;\n};\n\n/**\n * Creates an array of strings that serve as identifiers for PPE textures.\n *\n * Each glTF may define multiple `ppeTexture` objects within the\n * `NGA_gpm_local` extensions. Each of these textures corresponds\n * to one 'property texture property' in a metadata schema.\n *\n * This method will create an array where each element is a (JSON)\n * string representation of the parts of a GPM PPE texture definition\n * that are relevant for distinguishing two PPE textures in terms\n * of their structure within a `StructuralMetadata`.\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @returns The identifiers\n */\nGltfMeshPrimitiveGpmLoader._collectPpeTexturePropertyIdentifiers = function (\n  meshPrimitiveGpmLocal,\n) {\n  const ppeTexturePropertyIdentifiers = [];\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    // The following will create an identifier that can be used\n    // to define two PPE textures as \"representing the same\n    // property texture property\" within a structural metadata\n    // schema.\n    const classJson = GltfMeshPrimitiveGpmLoader._createPpeTextureClassJson(\n      ppeTexture,\n      i,\n    );\n    const ppeTexturePropertyIdentifier = JSON.stringify(classJson);\n    ppeTexturePropertyIdentifiers.push(ppeTexturePropertyIdentifier);\n  }\n  return ppeTexturePropertyIdentifiers;\n};\n\n/**\n * Converts the given `MeshPrimitiveGpmLocal` object into a `StructuralMetadata`\n * object.\n *\n * This will translate the PPE textures from the given object into property\n * texture properties. The schema will be created based on the the structure\n * of the PPE textures.\n *\n * @param {MeshPrimitiveGpmLocal} meshPrimitiveGpmLocal The extension object\n * @param {object} textures The mapping from texture ID to texture objects\n * @returns The `StructuralMetadata` object\n */\nGltfMeshPrimitiveGpmLoader._convertToStructuralMetadata = function (\n  meshPrimitiveGpmLocal,\n  textures,\n) {\n  const propertyTextures = [];\n  const ppeTexturesMetadataSchema =\n    GltfMeshPrimitiveGpmLoader._obtainPpeTexturesMetadataSchema(\n      meshPrimitiveGpmLocal,\n    );\n  const ppeTextures = meshPrimitiveGpmLocal.ppeTextures;\n  for (let i = 0; i < ppeTextures.length; i++) {\n    const ppeTexture = ppeTextures[i];\n    const classId = `ppeTexture_${i}`;\n    const traits = ppeTexture.traits;\n    const ppePropertyName = traits.source;\n    const metadataClass = ppeTexturesMetadataSchema.classes[classId];\n\n    const ppeTextureAsPropertyTexture = {\n      class: classId,\n      properties: {\n        [ppePropertyName]: {\n          index: ppeTexture.index,\n          texCoord: ppeTexture.texCoord,\n        },\n      },\n    };\n    propertyTextures.push(\n      new PropertyTexture({\n        id: i,\n        name: ppeTexture.name,\n        propertyTexture: ppeTextureAsPropertyTexture,\n        class: metadataClass,\n        textures: textures,\n      }),\n    );\n  }\n  const structuralMetadata = new StructuralMetadata({\n    schema: ppeTexturesMetadataSchema,\n    propertyTables: [],\n    propertyTextures: propertyTextures,\n    propertyAttributes: [],\n  });\n  return structuralMetadata;\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state !== ResourceLoaderState.LOADED) {\n    return false;\n  }\n\n  // The standard process of loading textures\n  // (from GltfStructuralMetadataLoader)\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  let ready = true;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    const textureLoader = textureLoaders[i];\n    const textureReady = textureLoader.process(frameState);\n    ready = ready && textureReady;\n  }\n\n  if (!ready) {\n    return false;\n  }\n\n  // More of the standard process of loading textures\n  // (from GltfStructuralMetadataLoader)\n  const textures = {};\n  for (let i = 0; i < this._textureIds.length; ++i) {\n    const textureId = this._textureIds[i];\n    const textureLoader = textureLoaders[i];\n    if (!textureLoader.isDestroyed()) {\n      textures[textureId] = textureLoader.texture;\n    }\n  }\n\n  // Convert the JSON representation of the `ppeTextures` that\n  // are found in the extensjon JSON into `PpeTexture` objects\n  const ppeTextures = [];\n  const extension = this._extension;\n  if (defined(extension.ppeTextures)) {\n    const ppeTexturesJson = extension.ppeTextures;\n    for (const ppeTextureJson of ppeTexturesJson) {\n      const traitsJson = ppeTextureJson.traits;\n      const traits = new PpeMetadata({\n        min: traitsJson.min,\n        max: traitsJson.max,\n        source: traitsJson.source,\n      });\n      const ppeTexture = new PpeTexture({\n        traits: traits,\n        noData: ppeTextureJson.noData,\n        offset: ppeTextureJson.offset,\n        scale: ppeTextureJson.scale,\n        index: ppeTextureJson.index,\n        texCoord: ppeTextureJson.texCoord,\n      });\n      ppeTextures.push(ppeTexture);\n    }\n  }\n  const meshPrimitiveGpmLocal = new MeshPrimitiveGpmLocal(ppeTextures);\n  this._meshPrimitiveGpmLocal = meshPrimitiveGpmLocal;\n\n  const structuralMetadata =\n    GltfMeshPrimitiveGpmLoader._convertToStructuralMetadata(\n      meshPrimitiveGpmLocal,\n      textures,\n    );\n  this._structuralMetadata = structuralMetadata;\n\n  this._state = ResourceLoaderState.READY;\n  return true;\n};\n\nGltfMeshPrimitiveGpmLoader.prototype._unloadTextures = function () {\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  this._textureLoaders.length = 0;\n  this._textureIds.length = 0;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfMeshPrimitiveGpmLoader.prototype.unload = function () {\n  this._unloadTextures();\n  this._gltf = undefined;\n  this._extension = undefined;\n  this._structuralMetadata = undefined;\n};\n\nexport default GltfMeshPrimitiveGpmLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}