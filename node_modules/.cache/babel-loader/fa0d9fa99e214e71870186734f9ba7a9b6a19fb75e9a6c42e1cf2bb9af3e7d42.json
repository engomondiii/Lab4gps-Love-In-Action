{"ast":null,"code":"import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../../Core/IntersectionTests.js\";\nimport Ray from \"../../Core/Ray.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport VerticalExaggeration from \"../../Core/VerticalExaggeration.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\nconst scratchNodeComputedTransform = new Matrix4();\nconst scratchModelMatrix = new Matrix4();\nconst scratchcomputedModelMatrix = new Matrix4();\nconst scratchPickCartographic = new Cartographic();\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Find an intersection between a ray and the model surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Model} model The model to pick.\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {number} [verticalExaggeration=1.0] A scalar used to exaggerate the height of a position relative to the ellipsoid. If the value is 1.0 there will be no effect.\n * @param {number} [relativeHeight=0.0] The ellipsoid height relative to which a position is exaggerated. If the value is 0.0 the position will be exaggerated relative to the ellipsoid surface.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to which the exaggerated position is relative.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nexport default function pickModel(model, ray, frameState, verticalExaggeration, relativeHeight, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"model\", model);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (!model._ready || frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n  let minT = Number.MAX_VALUE;\n  const sceneGraph = model.sceneGraph;\n  const nodes = sceneGraph._runtimeNodes;\n  for (let i = 0; i < nodes.length; i++) {\n    const runtimeNode = nodes[i];\n    const node = runtimeNode.node;\n    let nodeComputedTransform = Matrix4.clone(runtimeNode.computedTransform, scratchNodeComputedTransform);\n    let modelMatrix = Matrix4.clone(sceneGraph.computedModelMatrix, scratchModelMatrix);\n    const instances = node.instances;\n    if (defined(instances)) {\n      if (instances.transformInWorldSpace) {\n        // Replicate the multiplication order in LegacyInstancingStageVS.\n        modelMatrix = Matrix4.multiplyTransformation(model.modelMatrix, sceneGraph.components.transform, modelMatrix);\n        nodeComputedTransform = Matrix4.multiplyTransformation(sceneGraph.axisCorrectionMatrix, runtimeNode.computedTransform, nodeComputedTransform);\n      }\n    }\n    let computedModelMatrix = Matrix4.multiplyTransformation(modelMatrix, nodeComputedTransform, scratchcomputedModelMatrix);\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      computedModelMatrix = Transforms.basisTo2D(frameState.mapProjection, computedModelMatrix, computedModelMatrix);\n    }\n    const transforms = [];\n    if (defined(instances)) {\n      const transformsCount = instances.attributes[0].count;\n      const instanceComponentDatatype = instances.attributes[0].componentDatatype;\n      const transformElements = 12;\n      let transformsTypedArray = runtimeNode.transformsTypedArray;\n      if (!defined(transformsTypedArray)) {\n        const instanceTransformsBuffer = runtimeNode.instancingTransformsBuffer;\n        if (defined(instanceTransformsBuffer) && frameState.context.webgl2) {\n          transformsTypedArray = ComponentDatatype.createTypedArray(instanceComponentDatatype, transformsCount * transformElements);\n          instanceTransformsBuffer.getBufferData(transformsTypedArray);\n        }\n      }\n      if (defined(transformsTypedArray)) {\n        for (let i = 0; i < transformsCount; i++) {\n          const index = i * transformElements;\n          const transform = new Matrix4(transformsTypedArray[index], transformsTypedArray[index + 1], transformsTypedArray[index + 2], transformsTypedArray[index + 3], transformsTypedArray[index + 4], transformsTypedArray[index + 5], transformsTypedArray[index + 6], transformsTypedArray[index + 7], transformsTypedArray[index + 8], transformsTypedArray[index + 9], transformsTypedArray[index + 10], transformsTypedArray[index + 11], 0, 0, 0, 1);\n          if (instances.transformInWorldSpace) {\n            Matrix4.multiplyTransformation(transform, nodeComputedTransform, transform);\n            Matrix4.multiplyTransformation(modelMatrix, transform, transform);\n          } else {\n            Matrix4.multiplyTransformation(transform, computedModelMatrix, transform);\n          }\n          transforms.push(transform);\n        }\n      }\n    }\n    if (transforms.length === 0) {\n      transforms.push(computedModelMatrix);\n    }\n    const primitivesLength = runtimeNode.runtimePrimitives.length;\n    for (let j = 0; j < primitivesLength; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      const primitive = runtimePrimitive.primitive;\n      if (defined(runtimePrimitive.boundingSphere) && !defined(instances)) {\n        const boundingSphere = BoundingSphere.transform(runtimePrimitive.boundingSphere, computedModelMatrix, scratchBoundingSphere);\n        const boundsIntersection = IntersectionTests.raySphere(ray, boundingSphere);\n        if (!defined(boundsIntersection)) {\n          continue;\n        }\n      }\n      const positionAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.POSITION);\n      const byteOffset = positionAttribute.byteOffset;\n      const byteStride = positionAttribute.byteStride;\n      const vertexCount = positionAttribute.count;\n      if (!defined(primitive.indices)) {\n        // Point clouds\n        continue;\n      }\n      let indices = primitive.indices.typedArray;\n      if (!defined(indices)) {\n        const indicesBuffer = primitive.indices.buffer;\n        const indicesCount = primitive.indices.count;\n        const indexDatatype = primitive.indices.indexDatatype;\n        if (defined(indicesBuffer) && frameState.context.webgl2) {\n          if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n            indices = new Uint8Array(indicesCount);\n          } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n            indices = new Uint16Array(indicesCount);\n          } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n            indices = new Uint32Array(indicesCount);\n          }\n          indicesBuffer.getBufferData(indices);\n        }\n      }\n      let vertices = positionAttribute.typedArray;\n      let componentDatatype = positionAttribute.componentDatatype;\n      let attributeType = positionAttribute.type;\n      const quantization = positionAttribute.quantization;\n      if (defined(quantization)) {\n        componentDatatype = positionAttribute.quantization.componentDatatype;\n        attributeType = positionAttribute.quantization.type;\n      }\n      const numComponents = AttributeType.getNumberOfComponents(attributeType);\n      const bytes = ComponentDatatype.getSizeInBytes(componentDatatype);\n      const isInterleaved = !defined(vertices) && defined(byteStride) && byteStride !== numComponents * bytes;\n      let elementStride = numComponents;\n      let offset = 0;\n      if (isInterleaved) {\n        elementStride = byteStride / bytes;\n        offset = byteOffset / bytes;\n      }\n      const elementCount = vertexCount * elementStride;\n      if (!defined(vertices)) {\n        const verticesBuffer = positionAttribute.buffer;\n        if (defined(verticesBuffer) && frameState.context.webgl2) {\n          vertices = ComponentDatatype.createTypedArray(componentDatatype, elementCount);\n          verticesBuffer.getBufferData(vertices, isInterleaved ? 0 : byteOffset, 0, elementCount);\n        }\n        if (quantization && positionAttribute.normalized) {\n          vertices = AttributeCompression.dequantize(vertices, componentDatatype, attributeType, vertexCount);\n        }\n      }\n      if (!defined(indices) || !defined(vertices)) {\n        return;\n      }\n      ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n      verticalExaggeration = defaultValue(verticalExaggeration, 1.0);\n      relativeHeight = defaultValue(relativeHeight, 0.0);\n      const indicesLength = indices.length;\n      for (let i = 0; i < indicesLength; i += 3) {\n        const i0 = indices[i];\n        const i1 = indices[i + 1];\n        const i2 = indices[i + 2];\n        for (const instanceTransform of transforms) {\n          const v0 = getVertexPosition(vertices, i0, offset, elementStride, quantization, instanceTransform, verticalExaggeration, relativeHeight, ellipsoid, scratchV0);\n          const v1 = getVertexPosition(vertices, i1, offset, elementStride, quantization, instanceTransform, verticalExaggeration, relativeHeight, ellipsoid, scratchV1);\n          const v2 = getVertexPosition(vertices, i2, offset, elementStride, quantization, instanceTransform, verticalExaggeration, relativeHeight, ellipsoid, scratchV2);\n          const t = IntersectionTests.rayTriangleParametric(ray, v0, v1, v2, defaultValue(model.backFaceCulling, true));\n          if (defined(t)) {\n            if (t < minT && t >= 0.0) {\n              minT = t;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (minT === Number.MAX_VALUE) {\n    return undefined;\n  }\n  result = Ray.getPoint(ray, minT, result);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n    const projection = frameState.mapProjection;\n    const ellipsoid = projection.ellipsoid;\n    const cartographic = projection.unproject(result, scratchPickCartographic);\n    ellipsoid.cartographicToCartesian(cartographic, result);\n  }\n  return result;\n}\nfunction getVertexPosition(vertices, index, offset, numElements, quantization, instanceTransform, verticalExaggeration, relativeHeight, ellipsoid, result) {\n  const i = offset + index * numElements;\n  result.x = vertices[i];\n  result.y = vertices[i + 1];\n  result.z = vertices[i + 2];\n  if (defined(quantization)) {\n    if (quantization.octEncoded) {\n      result = AttributeCompression.octDecodeInRange(result, quantization.normalizationRange, result);\n      if (quantization.octEncodedZXY) {\n        const x = result.x;\n        result.x = result.z;\n        result.z = result.y;\n        result.y = x;\n      }\n    } else {\n      result = Cartesian3.multiplyComponents(result, quantization.quantizedVolumeStepSize, result);\n      result = Cartesian3.add(result, quantization.quantizedVolumeOffset, result);\n    }\n  }\n  result = Matrix4.multiplyByPoint(instanceTransform, result, result);\n  if (verticalExaggeration !== 1.0) {\n    VerticalExaggeration.getPosition(result, ellipsoid, verticalExaggeration, relativeHeight, result);\n  }\n  return result;\n}","map":{"version":3,"names":["AttributeCompression","BoundingSphere","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","Ellipsoid","IndexDatatype","IntersectionTests","Ray","Matrix4","Transforms","VerticalExaggeration","AttributeType","SceneMode","VertexAttributeSemantic","ModelUtility","scratchV0","scratchV1","scratchV2","scratchNodeComputedTransform","scratchModelMatrix","scratchcomputedModelMatrix","scratchPickCartographic","scratchBoundingSphere","pickModel","model","ray","frameState","verticalExaggeration","relativeHeight","ellipsoid","result","typeOf","object","_ready","mode","MORPHING","minT","Number","MAX_VALUE","sceneGraph","nodes","_runtimeNodes","i","length","runtimeNode","node","nodeComputedTransform","clone","computedTransform","modelMatrix","computedModelMatrix","instances","transformInWorldSpace","multiplyTransformation","components","transform","axisCorrectionMatrix","SCENE3D","basisTo2D","mapProjection","transforms","transformsCount","attributes","count","instanceComponentDatatype","componentDatatype","transformElements","transformsTypedArray","instanceTransformsBuffer","instancingTransformsBuffer","context","webgl2","createTypedArray","getBufferData","index","push","primitivesLength","runtimePrimitives","j","runtimePrimitive","primitive","boundingSphere","boundsIntersection","raySphere","positionAttribute","getAttributeBySemantic","POSITION","byteOffset","byteStride","vertexCount","indices","typedArray","indicesBuffer","buffer","indicesCount","indexDatatype","UNSIGNED_BYTE","Uint8Array","UNSIGNED_SHORT","Uint16Array","UNSIGNED_INT","Uint32Array","vertices","attributeType","type","quantization","numComponents","getNumberOfComponents","bytes","getSizeInBytes","isInterleaved","elementStride","offset","elementCount","verticesBuffer","normalized","dequantize","default","indicesLength","i0","i1","i2","instanceTransform","v0","getVertexPosition","v1","v2","t","rayTriangleParametric","backFaceCulling","undefined","getPoint","fromElements","y","z","x","projection","cartographic","unproject","cartographicToCartesian","numElements","octEncoded","octDecodeInRange","normalizationRange","octEncodedZXY","multiplyComponents","quantizedVolumeStepSize","add","quantizedVolumeOffset","multiplyByPoint","getPosition"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/pickModel.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../../Core/IntersectionTests.js\";\nimport Ray from \"../../Core/Ray.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport VerticalExaggeration from \"../../Core/VerticalExaggeration.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\nconst scratchNodeComputedTransform = new Matrix4();\nconst scratchModelMatrix = new Matrix4();\nconst scratchcomputedModelMatrix = new Matrix4();\nconst scratchPickCartographic = new Cartographic();\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Find an intersection between a ray and the model surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Model} model The model to pick.\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {number} [verticalExaggeration=1.0] A scalar used to exaggerate the height of a position relative to the ellipsoid. If the value is 1.0 there will be no effect.\n * @param {number} [relativeHeight=0.0] The ellipsoid height relative to which a position is exaggerated. If the value is 0.0 the position will be exaggerated relative to the ellipsoid surface.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to which the exaggerated position is relative.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nexport default function pickModel(\n  model,\n  ray,\n  frameState,\n  verticalExaggeration,\n  relativeHeight,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"model\", model);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (!model._ready || frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  let minT = Number.MAX_VALUE;\n  const sceneGraph = model.sceneGraph;\n\n  const nodes = sceneGraph._runtimeNodes;\n  for (let i = 0; i < nodes.length; i++) {\n    const runtimeNode = nodes[i];\n    const node = runtimeNode.node;\n\n    let nodeComputedTransform = Matrix4.clone(\n      runtimeNode.computedTransform,\n      scratchNodeComputedTransform,\n    );\n    let modelMatrix = Matrix4.clone(\n      sceneGraph.computedModelMatrix,\n      scratchModelMatrix,\n    );\n\n    const instances = node.instances;\n    if (defined(instances)) {\n      if (instances.transformInWorldSpace) {\n        // Replicate the multiplication order in LegacyInstancingStageVS.\n        modelMatrix = Matrix4.multiplyTransformation(\n          model.modelMatrix,\n          sceneGraph.components.transform,\n          modelMatrix,\n        );\n\n        nodeComputedTransform = Matrix4.multiplyTransformation(\n          sceneGraph.axisCorrectionMatrix,\n          runtimeNode.computedTransform,\n          nodeComputedTransform,\n        );\n      }\n    }\n\n    let computedModelMatrix = Matrix4.multiplyTransformation(\n      modelMatrix,\n      nodeComputedTransform,\n      scratchcomputedModelMatrix,\n    );\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      computedModelMatrix = Transforms.basisTo2D(\n        frameState.mapProjection,\n        computedModelMatrix,\n        computedModelMatrix,\n      );\n    }\n\n    const transforms = [];\n    if (defined(instances)) {\n      const transformsCount = instances.attributes[0].count;\n      const instanceComponentDatatype =\n        instances.attributes[0].componentDatatype;\n\n      const transformElements = 12;\n      let transformsTypedArray = runtimeNode.transformsTypedArray;\n      if (!defined(transformsTypedArray)) {\n        const instanceTransformsBuffer = runtimeNode.instancingTransformsBuffer;\n        if (defined(instanceTransformsBuffer) && frameState.context.webgl2) {\n          transformsTypedArray = ComponentDatatype.createTypedArray(\n            instanceComponentDatatype,\n            transformsCount * transformElements,\n          );\n          instanceTransformsBuffer.getBufferData(transformsTypedArray);\n        }\n      }\n\n      if (defined(transformsTypedArray)) {\n        for (let i = 0; i < transformsCount; i++) {\n          const index = i * transformElements;\n\n          const transform = new Matrix4(\n            transformsTypedArray[index],\n            transformsTypedArray[index + 1],\n            transformsTypedArray[index + 2],\n            transformsTypedArray[index + 3],\n            transformsTypedArray[index + 4],\n            transformsTypedArray[index + 5],\n            transformsTypedArray[index + 6],\n            transformsTypedArray[index + 7],\n            transformsTypedArray[index + 8],\n            transformsTypedArray[index + 9],\n            transformsTypedArray[index + 10],\n            transformsTypedArray[index + 11],\n            0,\n            0,\n            0,\n            1,\n          );\n\n          if (instances.transformInWorldSpace) {\n            Matrix4.multiplyTransformation(\n              transform,\n              nodeComputedTransform,\n              transform,\n            );\n            Matrix4.multiplyTransformation(modelMatrix, transform, transform);\n          } else {\n            Matrix4.multiplyTransformation(\n              transform,\n              computedModelMatrix,\n              transform,\n            );\n          }\n          transforms.push(transform);\n        }\n      }\n    }\n\n    if (transforms.length === 0) {\n      transforms.push(computedModelMatrix);\n    }\n\n    const primitivesLength = runtimeNode.runtimePrimitives.length;\n    for (let j = 0; j < primitivesLength; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      const primitive = runtimePrimitive.primitive;\n\n      if (defined(runtimePrimitive.boundingSphere) && !defined(instances)) {\n        const boundingSphere = BoundingSphere.transform(\n          runtimePrimitive.boundingSphere,\n          computedModelMatrix,\n          scratchBoundingSphere,\n        );\n        const boundsIntersection = IntersectionTests.raySphere(\n          ray,\n          boundingSphere,\n        );\n        if (!defined(boundsIntersection)) {\n          continue;\n        }\n      }\n\n      const positionAttribute = ModelUtility.getAttributeBySemantic(\n        primitive,\n        VertexAttributeSemantic.POSITION,\n      );\n      const byteOffset = positionAttribute.byteOffset;\n      const byteStride = positionAttribute.byteStride;\n      const vertexCount = positionAttribute.count;\n\n      if (!defined(primitive.indices)) {\n        // Point clouds\n        continue;\n      }\n\n      let indices = primitive.indices.typedArray;\n      if (!defined(indices)) {\n        const indicesBuffer = primitive.indices.buffer;\n        const indicesCount = primitive.indices.count;\n        const indexDatatype = primitive.indices.indexDatatype;\n        if (defined(indicesBuffer) && frameState.context.webgl2) {\n          if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n            indices = new Uint8Array(indicesCount);\n          } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n            indices = new Uint16Array(indicesCount);\n          } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n            indices = new Uint32Array(indicesCount);\n          }\n\n          indicesBuffer.getBufferData(indices);\n        }\n      }\n\n      let vertices = positionAttribute.typedArray;\n      let componentDatatype = positionAttribute.componentDatatype;\n      let attributeType = positionAttribute.type;\n\n      const quantization = positionAttribute.quantization;\n      if (defined(quantization)) {\n        componentDatatype = positionAttribute.quantization.componentDatatype;\n        attributeType = positionAttribute.quantization.type;\n      }\n\n      const numComponents = AttributeType.getNumberOfComponents(attributeType);\n      const bytes = ComponentDatatype.getSizeInBytes(componentDatatype);\n      const isInterleaved =\n        !defined(vertices) &&\n        defined(byteStride) &&\n        byteStride !== numComponents * bytes;\n\n      let elementStride = numComponents;\n      let offset = 0;\n      if (isInterleaved) {\n        elementStride = byteStride / bytes;\n        offset = byteOffset / bytes;\n      }\n      const elementCount = vertexCount * elementStride;\n\n      if (!defined(vertices)) {\n        const verticesBuffer = positionAttribute.buffer;\n\n        if (defined(verticesBuffer) && frameState.context.webgl2) {\n          vertices = ComponentDatatype.createTypedArray(\n            componentDatatype,\n            elementCount,\n          );\n          verticesBuffer.getBufferData(\n            vertices,\n            isInterleaved ? 0 : byteOffset,\n            0,\n            elementCount,\n          );\n        }\n\n        if (quantization && positionAttribute.normalized) {\n          vertices = AttributeCompression.dequantize(\n            vertices,\n            componentDatatype,\n            attributeType,\n            vertexCount,\n          );\n        }\n      }\n\n      if (!defined(indices) || !defined(vertices)) {\n        return;\n      }\n\n      ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n      verticalExaggeration = defaultValue(verticalExaggeration, 1.0);\n      relativeHeight = defaultValue(relativeHeight, 0.0);\n\n      const indicesLength = indices.length;\n      for (let i = 0; i < indicesLength; i += 3) {\n        const i0 = indices[i];\n        const i1 = indices[i + 1];\n        const i2 = indices[i + 2];\n\n        for (const instanceTransform of transforms) {\n          const v0 = getVertexPosition(\n            vertices,\n            i0,\n            offset,\n            elementStride,\n            quantization,\n            instanceTransform,\n            verticalExaggeration,\n            relativeHeight,\n            ellipsoid,\n            scratchV0,\n          );\n          const v1 = getVertexPosition(\n            vertices,\n            i1,\n            offset,\n            elementStride,\n            quantization,\n            instanceTransform,\n            verticalExaggeration,\n            relativeHeight,\n            ellipsoid,\n            scratchV1,\n          );\n          const v2 = getVertexPosition(\n            vertices,\n            i2,\n            offset,\n            elementStride,\n            quantization,\n            instanceTransform,\n            verticalExaggeration,\n            relativeHeight,\n            ellipsoid,\n            scratchV2,\n          );\n\n          const t = IntersectionTests.rayTriangleParametric(\n            ray,\n            v0,\n            v1,\n            v2,\n            defaultValue(model.backFaceCulling, true),\n          );\n\n          if (defined(t)) {\n            if (t < minT && t >= 0.0) {\n              minT = t;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (minT === Number.MAX_VALUE) {\n    return undefined;\n  }\n\n  result = Ray.getPoint(ray, minT, result);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n\n    const projection = frameState.mapProjection;\n    const ellipsoid = projection.ellipsoid;\n\n    const cartographic = projection.unproject(result, scratchPickCartographic);\n    ellipsoid.cartographicToCartesian(cartographic, result);\n  }\n\n  return result;\n}\n\nfunction getVertexPosition(\n  vertices,\n  index,\n  offset,\n  numElements,\n  quantization,\n  instanceTransform,\n  verticalExaggeration,\n  relativeHeight,\n  ellipsoid,\n  result,\n) {\n  const i = offset + index * numElements;\n  result.x = vertices[i];\n  result.y = vertices[i + 1];\n  result.z = vertices[i + 2];\n\n  if (defined(quantization)) {\n    if (quantization.octEncoded) {\n      result = AttributeCompression.octDecodeInRange(\n        result,\n        quantization.normalizationRange,\n        result,\n      );\n\n      if (quantization.octEncodedZXY) {\n        const x = result.x;\n        result.x = result.z;\n        result.z = result.y;\n        result.y = x;\n      }\n    } else {\n      result = Cartesian3.multiplyComponents(\n        result,\n        quantization.quantizedVolumeStepSize,\n        result,\n      );\n\n      result = Cartesian3.add(\n        result,\n        quantization.quantizedVolumeOffset,\n        result,\n      );\n    }\n  }\n\n  result = Matrix4.multiplyByPoint(instanceTransform, result, result);\n\n  if (verticalExaggeration !== 1.0) {\n    VerticalExaggeration.getPosition(\n      result,\n      ellipsoid,\n      verticalExaggeration,\n      relativeHeight,\n      result,\n    );\n  }\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}