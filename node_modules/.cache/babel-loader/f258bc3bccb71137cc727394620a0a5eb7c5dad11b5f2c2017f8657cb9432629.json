{"ast":null,"code":"import { computeFlyToLocationForRectangle, defaultValue, defined, DeveloperError, destroyObject, Event, GeocoderService, GeocodeType, getElement, IonGeocoderService, Math as CesiumMath, Matrix4, Rectangle, sampleTerrainMostDetailed } from \"@cesium/engine\";\nimport knockout from \"../ThirdParty/knockout.js\";\nimport createCommand from \"../createCommand.js\";\n\n// The height we use if geocoding to a specific point instead of an rectangle.\nconst DEFAULT_HEIGHT = 1000;\n\n/**\n * The view model for the {@link Geocoder} widget.\n * @alias GeocoderViewModel\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.scene The Scene instance to use.\n * @param {GeocoderService[]} [options.geocoderServices] Geocoder services to use for geocoding queries.\n *        If more than one are supplied, suggestions will be gathered for the geocoders that support it,\n *        and if no suggestion is selected the result from the first geocoder service wil be used.\n * @param {number} [options.flightDuration] The duration of the camera flight to an entered location, in seconds.\n * @param {Geocoder.DestinationFoundFunction} [options.destinationFound=GeocoderViewModel.flyToDestination] A callback function that is called after a successful geocode.  If not supplied, the default behavior is to fly the camera to the result destination.\n */\nfunction GeocoderViewModel(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.scene)) {\n    throw new DeveloperError(\"options.scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(options.geocoderServices)) {\n    this._geocoderServices = options.geocoderServices;\n  } else {\n    this._geocoderServices = [new IonGeocoderService({\n      scene: options.scene\n    })];\n  }\n  this._viewContainer = options.container;\n  this._scene = options.scene;\n  this._flightDuration = options.flightDuration;\n  this._searchText = \"\";\n  this._isSearchInProgress = false;\n  this._wasGeocodeCancelled = false;\n  this._previousCredits = [];\n  this._complete = new Event();\n  this._suggestions = [];\n  this._selectedSuggestion = undefined;\n  this._showSuggestions = true;\n  this._handleArrowDown = handleArrowDown;\n  this._handleArrowUp = handleArrowUp;\n  const that = this;\n  this._suggestionsVisible = knockout.pureComputed(function () {\n    const suggestions = knockout.getObservable(that, \"_suggestions\");\n    const suggestionsNotEmpty = suggestions().length > 0;\n    const showSuggestions = knockout.getObservable(that, \"_showSuggestions\")();\n    return suggestionsNotEmpty && showSuggestions;\n  });\n  this._searchCommand = createCommand(function (geocodeType) {\n    geocodeType = defaultValue(geocodeType, GeocodeType.SEARCH);\n    that._focusTextbox = false;\n    if (defined(that._selectedSuggestion)) {\n      that.activateSuggestion(that._selectedSuggestion);\n      return false;\n    }\n    that.hideSuggestions();\n    if (that.isSearchInProgress) {\n      cancelGeocode(that);\n    } else {\n      return geocode(that, that._geocoderServices, geocodeType);\n    }\n  });\n  this.deselectSuggestion = function () {\n    that._selectedSuggestion = undefined;\n  };\n  this.handleKeyDown = function (data, event) {\n    const downKey = event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    const upKey = event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    if (downKey || upKey) {\n      event.preventDefault();\n    }\n    return true;\n  };\n  this.handleKeyUp = function (data, event) {\n    const downKey = event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    const upKey = event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    const enterKey = event.key === \"Enter\" || event.keyCode === 13;\n    if (upKey) {\n      handleArrowUp(that);\n    } else if (downKey) {\n      handleArrowDown(that);\n    } else if (enterKey) {\n      that._searchCommand();\n    }\n    return true;\n  };\n  this.activateSuggestion = function (data) {\n    that.hideSuggestions();\n    that._searchText = data.displayName;\n    const destination = data.destination;\n    clearSuggestions(that);\n    that.destinationFound(that, destination);\n  };\n  this.hideSuggestions = function () {\n    that._showSuggestions = false;\n    that._selectedSuggestion = undefined;\n  };\n  this.showSuggestions = function () {\n    that._showSuggestions = true;\n  };\n  this.handleMouseover = function (data, event) {\n    if (data !== that._selectedSuggestion) {\n      that._selectedSuggestion = data;\n    }\n  };\n\n  /**\n   * Gets or sets a value indicating if this instance should always show its text input field.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.keepExpanded = false;\n\n  /**\n   * True if the geocoder should query as the user types to autocomplete\n   * @type {boolean}\n   * @default true\n   */\n  this.autoComplete = defaultValue(options.autocomplete, true);\n\n  /**\n   * Gets and sets the command called when a geocode destination is found\n   * @type {Geocoder.DestinationFoundFunction}\n   */\n  this.destinationFound = defaultValue(options.destinationFound, GeocoderViewModel.flyToDestination);\n  this._focusTextbox = false;\n  knockout.track(this, [\"_searchText\", \"_isSearchInProgress\", \"keepExpanded\", \"_suggestions\", \"_selectedSuggestion\", \"_showSuggestions\", \"_focusTextbox\"]);\n  const searchTextObservable = knockout.getObservable(this, \"_searchText\");\n  searchTextObservable.extend({\n    rateLimit: {\n      timeout: 500\n    }\n  });\n  this._suggestionSubscription = searchTextObservable.subscribe(function () {\n    GeocoderViewModel._updateSearchSuggestions(that);\n  });\n  /**\n   * Gets a value indicating whether a search is currently in progress.  This property is observable.\n   *\n   * @type {boolean}\n   */\n  this.isSearchInProgress = undefined;\n  knockout.defineProperty(this, \"isSearchInProgress\", {\n    get: function () {\n      return this._isSearchInProgress;\n    }\n  });\n\n  /**\n   * Gets or sets the text to search for.  The text can be an address, or longitude, latitude,\n   * and optional height, where longitude and latitude are in degrees and height is in meters.\n   *\n   * @type {string}\n   */\n  this.searchText = undefined;\n  knockout.defineProperty(this, \"searchText\", {\n    get: function () {\n      if (this.isSearchInProgress) {\n        return \"Searching...\";\n      }\n      return this._searchText;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (typeof value !== \"string\") {\n        throw new DeveloperError(\"value must be a valid string.\");\n      }\n      //>>includeEnd('debug');\n      this._searchText = value;\n    }\n  });\n\n  /**\n   * Gets or sets the the duration of the camera flight in seconds.\n   * A value of zero causes the camera to instantly switch to the geocoding location.\n   * The duration will be computed based on the distance when undefined.\n   *\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.flightDuration = undefined;\n  knockout.defineProperty(this, \"flightDuration\", {\n    get: function () {\n      return this._flightDuration;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value < 0) {\n        throw new DeveloperError(\"value must be positive.\");\n      }\n      //>>includeEnd('debug');\n\n      this._flightDuration = value;\n    }\n  });\n}\nObject.defineProperties(GeocoderViewModel.prototype, {\n  /**\n   * Gets the event triggered on flight completion.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Event}\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    }\n  },\n  /**\n   * Gets the scene to control.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Scene}\n   */\n  scene: {\n    get: function () {\n      return this._scene;\n    }\n  },\n  /**\n   * Gets the Command that is executed when the button is clicked.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Command}\n   */\n  search: {\n    get: function () {\n      return this._searchCommand;\n    }\n  },\n  /**\n   * Gets the currently selected geocoder search suggestion\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {object}\n   */\n  selectedSuggestion: {\n    get: function () {\n      return this._selectedSuggestion;\n    }\n  },\n  /**\n   * Gets the list of geocoder search suggestions\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Object[]}\n   */\n  suggestions: {\n    get: function () {\n      return this._suggestions;\n    }\n  }\n});\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nGeocoderViewModel.prototype.destroy = function () {\n  this._suggestionSubscription.dispose();\n};\nfunction handleArrowUp(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n  const currentIndex = viewModel._suggestions.indexOf(viewModel._selectedSuggestion);\n  if (currentIndex === -1 || currentIndex === 0) {\n    viewModel._selectedSuggestion = undefined;\n    return;\n  }\n  const next = currentIndex - 1;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\nfunction handleArrowDown(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n  const numberOfSuggestions = viewModel._suggestions.length;\n  const currentIndex = viewModel._suggestions.indexOf(viewModel._selectedSuggestion);\n  const next = (currentIndex + 1) % numberOfSuggestions;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\nfunction computeFlyToLocationForCartographic(cartographic, terrainProvider) {\n  const availability = defined(terrainProvider) ? terrainProvider.availability : undefined;\n  if (!defined(availability)) {\n    cartographic.height += DEFAULT_HEIGHT;\n    return Promise.resolve(cartographic);\n  }\n  return sampleTerrainMostDetailed(terrainProvider, [cartographic]).then(function (positionOnTerrain) {\n    cartographic = positionOnTerrain[0];\n    cartographic.height += DEFAULT_HEIGHT;\n    return cartographic;\n  });\n}\nfunction flyToDestination(viewModel, destination) {\n  const scene = viewModel._scene;\n  const ellipsoid = scene.ellipsoid;\n  const camera = scene.camera;\n  const terrainProvider = scene.terrainProvider;\n  let finalDestination = destination;\n  let promise;\n  if (destination instanceof Rectangle) {\n    // Some geocoders return a Rectangle of zero width/height, treat it like a point instead.\n    if (CesiumMath.equalsEpsilon(destination.south, destination.north, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(destination.east, destination.west, CesiumMath.EPSILON7)) {\n      // destination is now a Cartographic\n      destination = Rectangle.center(destination);\n    } else {\n      promise = computeFlyToLocationForRectangle(destination, scene);\n    }\n  } else {\n    // destination is a Cartesian3\n    destination = ellipsoid.cartesianToCartographic(destination);\n  }\n  if (!defined(promise)) {\n    promise = computeFlyToLocationForCartographic(destination, terrainProvider);\n  }\n  return promise.then(function (result) {\n    finalDestination = ellipsoid.cartographicToCartesian(result);\n  }).finally(function () {\n    // Whether terrain querying succeeded or not, fly to the destination.\n    camera.flyTo({\n      destination: finalDestination,\n      complete: function () {\n        viewModel._complete.raiseEvent();\n      },\n      duration: viewModel._flightDuration,\n      endTransform: Matrix4.IDENTITY\n    });\n  });\n}\nasync function attemptGeocode(geocoderService, query, geocodeType) {\n  try {\n    const result = await geocoderService.geocode(query, geocodeType);\n    return {\n      state: \"fulfilled\",\n      value: result,\n      credits: geocoderService.credit\n    };\n  } catch (error) {\n    return {\n      state: \"rejected\",\n      reason: error\n    };\n  }\n}\nasync function geocode(viewModel, geocoderServices, geocodeType) {\n  const query = viewModel._searchText;\n  if (hasOnlyWhitespace(query)) {\n    viewModel.showSuggestions();\n    return;\n  }\n  viewModel._isSearchInProgress = true;\n  viewModel._wasGeocodeCancelled = false;\n  let i;\n  let result;\n  for (i = 0; i < geocoderServices.length; i++) {\n    if (viewModel._wasGeocodeCancelled) {\n      return;\n    }\n    result = await attemptGeocode(geocoderServices[i], query, geocodeType);\n    if (defined(result) && result.state === \"fulfilled\" && result.value.length > 0) {\n      break;\n    }\n  }\n  if (viewModel._wasGeocodeCancelled) {\n    return;\n  }\n  viewModel._isSearchInProgress = false;\n  clearCredits(viewModel);\n  const geocoderResults = result.value;\n  if (result.state === \"fulfilled\" && defined(geocoderResults) && geocoderResults.length > 0) {\n    viewModel._searchText = geocoderResults[0].displayName;\n    viewModel.destinationFound(viewModel, geocoderResults[0].destination);\n    const credits = updateCredits(viewModel, GeocoderService.getCreditsFromResult(geocoderResults[0]));\n    // If the result does not contain any credits, default to the service credit.\n    if (!defined(credits)) {\n      updateCredit(viewModel, geocoderServices[i].credit);\n    }\n    return;\n  }\n  viewModel._searchText = `${query} (not found)`;\n}\nfunction updateCredit(viewModel, credit) {\n  if (defined(credit) && !viewModel._scene.isDestroyed() && !viewModel._scene.frameState.creditDisplay.isDestroyed()) {\n    viewModel._scene.frameState.creditDisplay.addStaticCredit(credit);\n    viewModel._previousCredits.push(credit);\n  }\n}\nfunction updateCredits(viewModel, credits) {\n  if (defined(credits)) {\n    credits.forEach(credit => updateCredit(viewModel, credit));\n  }\n  return credits;\n}\nfunction clearCredits(viewModel) {\n  if (!viewModel._scene.isDestroyed() && !viewModel._scene.frameState.creditDisplay.isDestroyed()) {\n    viewModel._previousCredits.forEach(credit => {\n      viewModel._scene.frameState.creditDisplay.removeStaticCredit(credit);\n    });\n  }\n  viewModel._previousCredits.length = 0;\n}\nfunction adjustSuggestionsScroll(viewModel, focusedItemIndex) {\n  const container = getElement(viewModel._viewContainer);\n  const searchResults = container.getElementsByClassName(\"search-results\")[0];\n  const listItems = container.getElementsByTagName(\"li\");\n  const element = listItems[focusedItemIndex];\n  if (focusedItemIndex === 0) {\n    searchResults.scrollTop = 0;\n    return;\n  }\n  const offsetTop = element.offsetTop;\n  if (offsetTop + element.clientHeight > searchResults.clientHeight) {\n    searchResults.scrollTop = offsetTop + element.clientHeight;\n  } else if (offsetTop < searchResults.scrollTop) {\n    searchResults.scrollTop = offsetTop;\n  }\n}\nfunction cancelGeocode(viewModel) {\n  if (viewModel._isSearchInProgress) {\n    viewModel._isSearchInProgress = false;\n    viewModel._wasGeocodeCancelled = true;\n  }\n}\nfunction hasOnlyWhitespace(string) {\n  return /^\\s*$/.test(string);\n}\nfunction clearSuggestions(viewModel) {\n  knockout.getObservable(viewModel, \"_suggestions\").removeAll();\n}\nasync function updateSearchSuggestions(viewModel) {\n  if (!viewModel.autoComplete) {\n    return;\n  }\n  const query = viewModel._searchText;\n  clearSuggestions(viewModel);\n  clearCredits(viewModel);\n  if (hasOnlyWhitespace(query)) {\n    return;\n  }\n  for (const service of viewModel._geocoderServices) {\n    const newResults = await service.geocode(query, GeocodeType.AUTOCOMPLETE);\n    viewModel._suggestions = viewModel._suggestions.concat(newResults);\n    if (newResults.length > 0) {\n      let useDefaultCredit = true;\n      newResults.forEach(result => {\n        const credits = GeocoderService.getCreditsFromResult(result);\n        useDefaultCredit = useDefaultCredit && !defined(credits);\n        updateCredits(viewModel, credits);\n      });\n\n      // Use the service credit if there were no attributions in the results\n      if (useDefaultCredit) {\n        updateCredit(viewModel, service.credit);\n      }\n    }\n    if (viewModel._suggestions.length >= 5) {\n      return;\n    }\n  }\n}\n\n/**\n * A function to fly to the destination found by a successful geocode.\n * @type {Geocoder.DestinationFoundFunction}\n */\nGeocoderViewModel.flyToDestination = flyToDestination;\n\n//exposed for testing\nGeocoderViewModel._updateSearchSuggestions = updateSearchSuggestions;\nGeocoderViewModel._adjustSuggestionsScroll = adjustSuggestionsScroll;\n\n/**\n * @returns {boolean} true if the object has been destroyed, false otherwise.\n */\nGeocoderViewModel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nGeocoderViewModel.prototype.destroy = function () {\n  clearCredits(this);\n  return destroyObject(this);\n};\nexport default GeocoderViewModel;","map":{"version":3,"names":["computeFlyToLocationForRectangle","defaultValue","defined","DeveloperError","destroyObject","Event","GeocoderService","GeocodeType","getElement","IonGeocoderService","Math","CesiumMath","Matrix4","Rectangle","sampleTerrainMostDetailed","knockout","createCommand","DEFAULT_HEIGHT","GeocoderViewModel","options","scene","geocoderServices","_geocoderServices","_viewContainer","container","_scene","_flightDuration","flightDuration","_searchText","_isSearchInProgress","_wasGeocodeCancelled","_previousCredits","_complete","_suggestions","_selectedSuggestion","undefined","_showSuggestions","_handleArrowDown","handleArrowDown","_handleArrowUp","handleArrowUp","that","_suggestionsVisible","pureComputed","suggestions","getObservable","suggestionsNotEmpty","length","showSuggestions","_searchCommand","geocodeType","SEARCH","_focusTextbox","activateSuggestion","hideSuggestions","isSearchInProgress","cancelGeocode","geocode","deselectSuggestion","handleKeyDown","data","event","downKey","key","keyCode","upKey","preventDefault","handleKeyUp","enterKey","displayName","destination","clearSuggestions","destinationFound","handleMouseover","keepExpanded","autoComplete","autocomplete","flyToDestination","track","searchTextObservable","extend","rateLimit","timeout","_suggestionSubscription","subscribe","_updateSearchSuggestions","defineProperty","get","searchText","set","value","Object","defineProperties","prototype","complete","search","selectedSuggestion","destroy","dispose","viewModel","currentIndex","indexOf","next","_adjustSuggestionsScroll","numberOfSuggestions","computeFlyToLocationForCartographic","cartographic","terrainProvider","availability","height","Promise","resolve","then","positionOnTerrain","ellipsoid","camera","finalDestination","promise","equalsEpsilon","south","north","EPSILON7","east","west","center","cartesianToCartographic","result","cartographicToCartesian","finally","flyTo","raiseEvent","duration","endTransform","IDENTITY","attemptGeocode","geocoderService","query","state","credits","credit","error","reason","hasOnlyWhitespace","i","clearCredits","geocoderResults","updateCredits","getCreditsFromResult","updateCredit","isDestroyed","frameState","creditDisplay","addStaticCredit","push","forEach","removeStaticCredit","adjustSuggestionsScroll","focusedItemIndex","searchResults","getElementsByClassName","listItems","getElementsByTagName","element","scrollTop","offsetTop","clientHeight","string","test","removeAll","updateSearchSuggestions","service","newResults","AUTOCOMPLETE","concat","useDefaultCredit"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/widgets/Source/Geocoder/GeocoderViewModel.js"],"sourcesContent":["import {\n  computeFlyToLocationForRectangle,\n  defaultValue,\n  defined,\n  DeveloperError,\n  destroyObject,\n  Event,\n  GeocoderService,\n  GeocodeType,\n  getElement,\n  IonGeocoderService,\n  Math as CesiumMath,\n  Matrix4,\n  Rectangle,\n  sampleTerrainMostDetailed,\n} from \"@cesium/engine\";\nimport knockout from \"../ThirdParty/knockout.js\";\nimport createCommand from \"../createCommand.js\";\n\n// The height we use if geocoding to a specific point instead of an rectangle.\nconst DEFAULT_HEIGHT = 1000;\n\n/**\n * The view model for the {@link Geocoder} widget.\n * @alias GeocoderViewModel\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.scene The Scene instance to use.\n * @param {GeocoderService[]} [options.geocoderServices] Geocoder services to use for geocoding queries.\n *        If more than one are supplied, suggestions will be gathered for the geocoders that support it,\n *        and if no suggestion is selected the result from the first geocoder service wil be used.\n * @param {number} [options.flightDuration] The duration of the camera flight to an entered location, in seconds.\n * @param {Geocoder.DestinationFoundFunction} [options.destinationFound=GeocoderViewModel.flyToDestination] A callback function that is called after a successful geocode.  If not supplied, the default behavior is to fly the camera to the result destination.\n */\nfunction GeocoderViewModel(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.scene)) {\n    throw new DeveloperError(\"options.scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(options.geocoderServices)) {\n    this._geocoderServices = options.geocoderServices;\n  } else {\n    this._geocoderServices = [new IonGeocoderService({ scene: options.scene })];\n  }\n\n  this._viewContainer = options.container;\n  this._scene = options.scene;\n  this._flightDuration = options.flightDuration;\n  this._searchText = \"\";\n  this._isSearchInProgress = false;\n  this._wasGeocodeCancelled = false;\n  this._previousCredits = [];\n  this._complete = new Event();\n  this._suggestions = [];\n  this._selectedSuggestion = undefined;\n  this._showSuggestions = true;\n\n  this._handleArrowDown = handleArrowDown;\n  this._handleArrowUp = handleArrowUp;\n\n  const that = this;\n\n  this._suggestionsVisible = knockout.pureComputed(function () {\n    const suggestions = knockout.getObservable(that, \"_suggestions\");\n    const suggestionsNotEmpty = suggestions().length > 0;\n    const showSuggestions = knockout.getObservable(that, \"_showSuggestions\")();\n    return suggestionsNotEmpty && showSuggestions;\n  });\n\n  this._searchCommand = createCommand(function (geocodeType) {\n    geocodeType = defaultValue(geocodeType, GeocodeType.SEARCH);\n    that._focusTextbox = false;\n    if (defined(that._selectedSuggestion)) {\n      that.activateSuggestion(that._selectedSuggestion);\n      return false;\n    }\n    that.hideSuggestions();\n    if (that.isSearchInProgress) {\n      cancelGeocode(that);\n    } else {\n      return geocode(that, that._geocoderServices, geocodeType);\n    }\n  });\n\n  this.deselectSuggestion = function () {\n    that._selectedSuggestion = undefined;\n  };\n\n  this.handleKeyDown = function (data, event) {\n    const downKey =\n      event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    const upKey =\n      event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    if (downKey || upKey) {\n      event.preventDefault();\n    }\n\n    return true;\n  };\n\n  this.handleKeyUp = function (data, event) {\n    const downKey =\n      event.key === \"ArrowDown\" || event.key === \"Down\" || event.keyCode === 40;\n    const upKey =\n      event.key === \"ArrowUp\" || event.key === \"Up\" || event.keyCode === 38;\n    const enterKey = event.key === \"Enter\" || event.keyCode === 13;\n    if (upKey) {\n      handleArrowUp(that);\n    } else if (downKey) {\n      handleArrowDown(that);\n    } else if (enterKey) {\n      that._searchCommand();\n    }\n    return true;\n  };\n\n  this.activateSuggestion = function (data) {\n    that.hideSuggestions();\n    that._searchText = data.displayName;\n    const destination = data.destination;\n    clearSuggestions(that);\n    that.destinationFound(that, destination);\n  };\n\n  this.hideSuggestions = function () {\n    that._showSuggestions = false;\n    that._selectedSuggestion = undefined;\n  };\n\n  this.showSuggestions = function () {\n    that._showSuggestions = true;\n  };\n\n  this.handleMouseover = function (data, event) {\n    if (data !== that._selectedSuggestion) {\n      that._selectedSuggestion = data;\n    }\n  };\n\n  /**\n   * Gets or sets a value indicating if this instance should always show its text input field.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.keepExpanded = false;\n\n  /**\n   * True if the geocoder should query as the user types to autocomplete\n   * @type {boolean}\n   * @default true\n   */\n  this.autoComplete = defaultValue(options.autocomplete, true);\n\n  /**\n   * Gets and sets the command called when a geocode destination is found\n   * @type {Geocoder.DestinationFoundFunction}\n   */\n  this.destinationFound = defaultValue(\n    options.destinationFound,\n    GeocoderViewModel.flyToDestination,\n  );\n\n  this._focusTextbox = false;\n\n  knockout.track(this, [\n    \"_searchText\",\n    \"_isSearchInProgress\",\n    \"keepExpanded\",\n    \"_suggestions\",\n    \"_selectedSuggestion\",\n    \"_showSuggestions\",\n    \"_focusTextbox\",\n  ]);\n\n  const searchTextObservable = knockout.getObservable(this, \"_searchText\");\n  searchTextObservable.extend({ rateLimit: { timeout: 500 } });\n  this._suggestionSubscription = searchTextObservable.subscribe(function () {\n    GeocoderViewModel._updateSearchSuggestions(that);\n  });\n  /**\n   * Gets a value indicating whether a search is currently in progress.  This property is observable.\n   *\n   * @type {boolean}\n   */\n  this.isSearchInProgress = undefined;\n  knockout.defineProperty(this, \"isSearchInProgress\", {\n    get: function () {\n      return this._isSearchInProgress;\n    },\n  });\n\n  /**\n   * Gets or sets the text to search for.  The text can be an address, or longitude, latitude,\n   * and optional height, where longitude and latitude are in degrees and height is in meters.\n   *\n   * @type {string}\n   */\n  this.searchText = undefined;\n  knockout.defineProperty(this, \"searchText\", {\n    get: function () {\n      if (this.isSearchInProgress) {\n        return \"Searching...\";\n      }\n\n      return this._searchText;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (typeof value !== \"string\") {\n        throw new DeveloperError(\"value must be a valid string.\");\n      }\n      //>>includeEnd('debug');\n      this._searchText = value;\n    },\n  });\n\n  /**\n   * Gets or sets the the duration of the camera flight in seconds.\n   * A value of zero causes the camera to instantly switch to the geocoding location.\n   * The duration will be computed based on the distance when undefined.\n   *\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.flightDuration = undefined;\n  knockout.defineProperty(this, \"flightDuration\", {\n    get: function () {\n      return this._flightDuration;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value < 0) {\n        throw new DeveloperError(\"value must be positive.\");\n      }\n      //>>includeEnd('debug');\n\n      this._flightDuration = value;\n    },\n  });\n}\n\nObject.defineProperties(GeocoderViewModel.prototype, {\n  /**\n   * Gets the event triggered on flight completion.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Event}\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    },\n  },\n\n  /**\n   * Gets the scene to control.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Scene}\n   */\n  scene: {\n    get: function () {\n      return this._scene;\n    },\n  },\n\n  /**\n   * Gets the Command that is executed when the button is clicked.\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Command}\n   */\n  search: {\n    get: function () {\n      return this._searchCommand;\n    },\n  },\n\n  /**\n   * Gets the currently selected geocoder search suggestion\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {object}\n   */\n  selectedSuggestion: {\n    get: function () {\n      return this._selectedSuggestion;\n    },\n  },\n\n  /**\n   * Gets the list of geocoder search suggestions\n   * @memberof GeocoderViewModel.prototype\n   *\n   * @type {Object[]}\n   */\n  suggestions: {\n    get: function () {\n      return this._suggestions;\n    },\n  },\n});\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nGeocoderViewModel.prototype.destroy = function () {\n  this._suggestionSubscription.dispose();\n};\n\nfunction handleArrowUp(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n  const currentIndex = viewModel._suggestions.indexOf(\n    viewModel._selectedSuggestion,\n  );\n  if (currentIndex === -1 || currentIndex === 0) {\n    viewModel._selectedSuggestion = undefined;\n    return;\n  }\n  const next = currentIndex - 1;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\n\nfunction handleArrowDown(viewModel) {\n  if (viewModel._suggestions.length === 0) {\n    return;\n  }\n  const numberOfSuggestions = viewModel._suggestions.length;\n  const currentIndex = viewModel._suggestions.indexOf(\n    viewModel._selectedSuggestion,\n  );\n  const next = (currentIndex + 1) % numberOfSuggestions;\n  viewModel._selectedSuggestion = viewModel._suggestions[next];\n\n  GeocoderViewModel._adjustSuggestionsScroll(viewModel, next);\n}\n\nfunction computeFlyToLocationForCartographic(cartographic, terrainProvider) {\n  const availability = defined(terrainProvider)\n    ? terrainProvider.availability\n    : undefined;\n\n  if (!defined(availability)) {\n    cartographic.height += DEFAULT_HEIGHT;\n    return Promise.resolve(cartographic);\n  }\n\n  return sampleTerrainMostDetailed(terrainProvider, [cartographic]).then(\n    function (positionOnTerrain) {\n      cartographic = positionOnTerrain[0];\n      cartographic.height += DEFAULT_HEIGHT;\n      return cartographic;\n    },\n  );\n}\n\nfunction flyToDestination(viewModel, destination) {\n  const scene = viewModel._scene;\n  const ellipsoid = scene.ellipsoid;\n\n  const camera = scene.camera;\n  const terrainProvider = scene.terrainProvider;\n  let finalDestination = destination;\n\n  let promise;\n  if (destination instanceof Rectangle) {\n    // Some geocoders return a Rectangle of zero width/height, treat it like a point instead.\n    if (\n      CesiumMath.equalsEpsilon(\n        destination.south,\n        destination.north,\n        CesiumMath.EPSILON7,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        destination.east,\n        destination.west,\n        CesiumMath.EPSILON7,\n      )\n    ) {\n      // destination is now a Cartographic\n      destination = Rectangle.center(destination);\n    } else {\n      promise = computeFlyToLocationForRectangle(destination, scene);\n    }\n  } else {\n    // destination is a Cartesian3\n    destination = ellipsoid.cartesianToCartographic(destination);\n  }\n\n  if (!defined(promise)) {\n    promise = computeFlyToLocationForCartographic(destination, terrainProvider);\n  }\n\n  return promise\n    .then(function (result) {\n      finalDestination = ellipsoid.cartographicToCartesian(result);\n    })\n    .finally(function () {\n      // Whether terrain querying succeeded or not, fly to the destination.\n      camera.flyTo({\n        destination: finalDestination,\n        complete: function () {\n          viewModel._complete.raiseEvent();\n        },\n        duration: viewModel._flightDuration,\n        endTransform: Matrix4.IDENTITY,\n      });\n    });\n}\n\nasync function attemptGeocode(geocoderService, query, geocodeType) {\n  try {\n    const result = await geocoderService.geocode(query, geocodeType);\n    return {\n      state: \"fulfilled\",\n      value: result,\n      credits: geocoderService.credit,\n    };\n  } catch (error) {\n    return { state: \"rejected\", reason: error };\n  }\n}\n\nasync function geocode(viewModel, geocoderServices, geocodeType) {\n  const query = viewModel._searchText;\n\n  if (hasOnlyWhitespace(query)) {\n    viewModel.showSuggestions();\n    return;\n  }\n\n  viewModel._isSearchInProgress = true;\n  viewModel._wasGeocodeCancelled = false;\n\n  let i;\n  let result;\n  for (i = 0; i < geocoderServices.length; i++) {\n    if (viewModel._wasGeocodeCancelled) {\n      return;\n    }\n\n    result = await attemptGeocode(geocoderServices[i], query, geocodeType);\n    if (\n      defined(result) &&\n      result.state === \"fulfilled\" &&\n      result.value.length > 0\n    ) {\n      break;\n    }\n  }\n\n  if (viewModel._wasGeocodeCancelled) {\n    return;\n  }\n\n  viewModel._isSearchInProgress = false;\n  clearCredits(viewModel);\n\n  const geocoderResults = result.value;\n  if (\n    result.state === \"fulfilled\" &&\n    defined(geocoderResults) &&\n    geocoderResults.length > 0\n  ) {\n    viewModel._searchText = geocoderResults[0].displayName;\n    viewModel.destinationFound(viewModel, geocoderResults[0].destination);\n    const credits = updateCredits(\n      viewModel,\n      GeocoderService.getCreditsFromResult(geocoderResults[0]),\n    );\n    // If the result does not contain any credits, default to the service credit.\n    if (!defined(credits)) {\n      updateCredit(viewModel, geocoderServices[i].credit);\n    }\n    return;\n  }\n\n  viewModel._searchText = `${query} (not found)`;\n}\n\nfunction updateCredit(viewModel, credit) {\n  if (\n    defined(credit) &&\n    !viewModel._scene.isDestroyed() &&\n    !viewModel._scene.frameState.creditDisplay.isDestroyed()\n  ) {\n    viewModel._scene.frameState.creditDisplay.addStaticCredit(credit);\n    viewModel._previousCredits.push(credit);\n  }\n}\n\nfunction updateCredits(viewModel, credits) {\n  if (defined(credits)) {\n    credits.forEach((credit) => updateCredit(viewModel, credit));\n  }\n\n  return credits;\n}\n\nfunction clearCredits(viewModel) {\n  if (\n    !viewModel._scene.isDestroyed() &&\n    !viewModel._scene.frameState.creditDisplay.isDestroyed()\n  ) {\n    viewModel._previousCredits.forEach((credit) => {\n      viewModel._scene.frameState.creditDisplay.removeStaticCredit(credit);\n    });\n  }\n\n  viewModel._previousCredits.length = 0;\n}\n\nfunction adjustSuggestionsScroll(viewModel, focusedItemIndex) {\n  const container = getElement(viewModel._viewContainer);\n  const searchResults = container.getElementsByClassName(\"search-results\")[0];\n  const listItems = container.getElementsByTagName(\"li\");\n  const element = listItems[focusedItemIndex];\n\n  if (focusedItemIndex === 0) {\n    searchResults.scrollTop = 0;\n    return;\n  }\n\n  const offsetTop = element.offsetTop;\n  if (offsetTop + element.clientHeight > searchResults.clientHeight) {\n    searchResults.scrollTop = offsetTop + element.clientHeight;\n  } else if (offsetTop < searchResults.scrollTop) {\n    searchResults.scrollTop = offsetTop;\n  }\n}\n\nfunction cancelGeocode(viewModel) {\n  if (viewModel._isSearchInProgress) {\n    viewModel._isSearchInProgress = false;\n    viewModel._wasGeocodeCancelled = true;\n  }\n}\n\nfunction hasOnlyWhitespace(string) {\n  return /^\\s*$/.test(string);\n}\n\nfunction clearSuggestions(viewModel) {\n  knockout.getObservable(viewModel, \"_suggestions\").removeAll();\n}\n\nasync function updateSearchSuggestions(viewModel) {\n  if (!viewModel.autoComplete) {\n    return;\n  }\n\n  const query = viewModel._searchText;\n\n  clearSuggestions(viewModel);\n  clearCredits(viewModel);\n\n  if (hasOnlyWhitespace(query)) {\n    return;\n  }\n\n  for (const service of viewModel._geocoderServices) {\n    const newResults = await service.geocode(query, GeocodeType.AUTOCOMPLETE);\n    viewModel._suggestions = viewModel._suggestions.concat(newResults);\n    if (newResults.length > 0) {\n      let useDefaultCredit = true;\n      newResults.forEach((result) => {\n        const credits = GeocoderService.getCreditsFromResult(result);\n        useDefaultCredit = useDefaultCredit && !defined(credits);\n        updateCredits(viewModel, credits);\n      });\n\n      // Use the service credit if there were no attributions in the results\n      if (useDefaultCredit) {\n        updateCredit(viewModel, service.credit);\n      }\n    }\n\n    if (viewModel._suggestions.length >= 5) {\n      return;\n    }\n  }\n}\n\n/**\n * A function to fly to the destination found by a successful geocode.\n * @type {Geocoder.DestinationFoundFunction}\n */\nGeocoderViewModel.flyToDestination = flyToDestination;\n\n//exposed for testing\nGeocoderViewModel._updateSearchSuggestions = updateSearchSuggestions;\nGeocoderViewModel._adjustSuggestionsScroll = adjustSuggestionsScroll;\n\n/**\n * @returns {boolean} true if the object has been destroyed, false otherwise.\n */\nGeocoderViewModel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nGeocoderViewModel.prototype.destroy = function () {\n  clearCredits(this);\n  return destroyObject(this);\n};\nexport default GeocoderViewModel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}