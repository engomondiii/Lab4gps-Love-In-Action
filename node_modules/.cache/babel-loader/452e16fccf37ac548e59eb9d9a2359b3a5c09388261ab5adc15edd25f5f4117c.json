{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nconst diffScratch = new Cartesian3();\n\n/**\n * A description of the outline of a cube centered at the origin.\n *\n * @alias BoxOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n *\n * @see BoxOutlineGeometry.fromDimensions\n * @see BoxOutlineGeometry.createGeometry\n * @see Packable\n *\n * @example\n * const box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n */\nfunction BoxOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const min = options.minimum;\n  const max = options.maximum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  this._min = Cartesian3.clone(min);\n  this._max = Cartesian3.clone(max);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxOutlineGeometry\";\n}\n\n/**\n * Creates an outline of a cube centered at the origin given its dimensions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @returns {BoxOutlineGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * const box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n * @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromDimensions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const dimensions = options.dimensions;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0);\n  //>>includeEnd('debug');\n\n  const corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n  return new BoxOutlineGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    offsetAttribute: options.offsetAttribute\n  });\n};\n\n/**\n * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxOutlineGeometry}\n *\n *\n *\n * @example\n * const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *  @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundindBox\", boundingBox);\n  //>>includeEnd('debug');\n\n  return new BoxOutlineGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum\n  });\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 1;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoxOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._min, array, startingIndex);\n  Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);\n  array[startingIndex + Cartesian3.packedLength * 2] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxOutlineGeometry} [result] The object into which to store the result.\n * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.\n */\nBoxOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  const max = Cartesian3.unpack(array, startingIndex + Cartesian3.packedLength, scratchMax);\n  const offsetAttribute = array[startingIndex + Cartesian3.packedLength * 2];\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxOutlineGeometry(scratchOptions);\n  }\n  result._min = Cartesian3.clone(min, result._min);\n  result._max = Cartesian3.clone(max, result._max);\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nBoxOutlineGeometry.createGeometry = function (boxGeometry) {\n  const min = boxGeometry._min;\n  const max = boxGeometry._max;\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n  const attributes = new GeometryAttributes();\n  const indices = new Uint16Array(12 * 2);\n  const positions = new Float64Array(8 * 3);\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n  positions[12] = min.x;\n  positions[13] = min.y;\n  positions[14] = max.z;\n  positions[15] = max.x;\n  positions[16] = min.y;\n  positions[17] = max.z;\n  positions[18] = max.x;\n  positions[19] = max.y;\n  positions[20] = max.z;\n  positions[21] = min.x;\n  positions[22] = max.y;\n  positions[23] = max.z;\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions\n  });\n\n  // top\n  indices[0] = 4;\n  indices[1] = 5;\n  indices[2] = 5;\n  indices[3] = 6;\n  indices[4] = 6;\n  indices[5] = 7;\n  indices[6] = 7;\n  indices[7] = 4;\n\n  // bottom\n  indices[8] = 0;\n  indices[9] = 1;\n  indices[10] = 1;\n  indices[11] = 2;\n  indices[12] = 2;\n  indices[13] = 3;\n  indices[14] = 3;\n  indices[15] = 0;\n\n  // left\n  indices[16] = 0;\n  indices[17] = 4;\n  indices[18] = 1;\n  indices[19] = 5;\n\n  //right\n  indices[20] = 2;\n  indices[21] = 6;\n  indices[22] = 3;\n  indices[23] = 7;\n  const diff = Cartesian3.subtract(max, min, diffScratch);\n  const radius = Cartesian3.magnitude(diff) * 0.5;\n  if (defined(boxGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue = boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute\n  });\n};\nexport default BoxOutlineGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","PrimitiveType","diffScratch","BoxOutlineGeometry","options","EMPTY_OBJECT","min","minimum","max","maximum","typeOf","object","offsetAttribute","TOP","_min","clone","_max","_offsetAttribute","_workerName","fromDimensions","dimensions","number","greaterThanOrEquals","x","y","z","corner","multiplyByScalar","negate","fromAxisAlignedBoundingBox","boundingBox","packedLength","pack","value","array","startingIndex","scratchMin","scratchMax","scratchOptions","undefined","unpack","result","createGeometry","boxGeometry","equals","attributes","indices","Uint16Array","positions","Float64Array","position","componentDatatype","DOUBLE","componentsPerAttribute","values","diff","subtract","radius","magnitude","length","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","LINES","boundingSphere","ZERO"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/BoxOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst diffScratch = new Cartesian3();\n\n/**\n * A description of the outline of a cube centered at the origin.\n *\n * @alias BoxOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.\n * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.\n *\n * @see BoxOutlineGeometry.fromDimensions\n * @see BoxOutlineGeometry.createGeometry\n * @see Packable\n *\n * @example\n * const box = new Cesium.BoxOutlineGeometry({\n *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),\n *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n */\nfunction BoxOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const min = options.minimum;\n  const max = options.maximum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._min = Cartesian3.clone(min);\n  this._max = Cartesian3.clone(max);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createBoxOutlineGeometry\";\n}\n\n/**\n * Creates an outline of a cube centered at the origin given its dimensions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.\n * @returns {BoxOutlineGeometry}\n *\n * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.\n *\n *\n * @example\n * const box = Cesium.BoxOutlineGeometry.fromDimensions({\n *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);\n *\n * @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromDimensions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const dimensions = options.dimensions;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0);\n  //>>includeEnd('debug');\n\n  const corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());\n\n  return new BoxOutlineGeometry({\n    minimum: Cartesian3.negate(corner, new Cartesian3()),\n    maximum: corner,\n    offsetAttribute: options.offsetAttribute,\n  });\n};\n\n/**\n * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.\n *\n * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.\n * @returns {BoxOutlineGeometry}\n *\n *\n *\n * @example\n * const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([\n *      -72.0, 40.0,\n *      -70.0, 35.0,\n *      -75.0, 30.0,\n *      -70.0, 30.0,\n *      -68.0, 40.0\n * ]));\n * const box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);\n *\n *  @see BoxOutlineGeometry.createGeometry\n */\nBoxOutlineGeometry.fromAxisAlignedBoundingBox = function (boundingBox) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundindBox\", boundingBox);\n  //>>includeEnd('debug');\n\n  return new BoxOutlineGeometry({\n    minimum: boundingBox.minimum,\n    maximum: boundingBox.maximum,\n  });\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 1;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoxOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoxOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._min, array, startingIndex);\n  Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);\n  array[startingIndex + Cartesian3.packedLength * 2] = defaultValue(\n    value._offsetAttribute,\n    -1,\n  );\n\n  return array;\n};\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchOptions = {\n  minimum: scratchMin,\n  maximum: scratchMax,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoxOutlineGeometry} [result] The object into which to store the result.\n * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.\n */\nBoxOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const min = Cartesian3.unpack(array, startingIndex, scratchMin);\n  const max = Cartesian3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    scratchMax,\n  );\n  const offsetAttribute = array[startingIndex + Cartesian3.packedLength * 2];\n\n  if (!defined(result)) {\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new BoxOutlineGeometry(scratchOptions);\n  }\n\n  result._min = Cartesian3.clone(min, result._min);\n  result._max = Cartesian3.clone(max, result._max);\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.\n *\n * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nBoxOutlineGeometry.createGeometry = function (boxGeometry) {\n  const min = boxGeometry._min;\n  const max = boxGeometry._max;\n\n  if (Cartesian3.equals(min, max)) {\n    return;\n  }\n\n  const attributes = new GeometryAttributes();\n  const indices = new Uint16Array(12 * 2);\n  const positions = new Float64Array(8 * 3);\n\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n\n  positions[12] = min.x;\n  positions[13] = min.y;\n  positions[14] = max.z;\n  positions[15] = max.x;\n  positions[16] = min.y;\n  positions[17] = max.z;\n  positions[18] = max.x;\n  positions[19] = max.y;\n  positions[20] = max.z;\n  positions[21] = min.x;\n  positions[22] = max.y;\n  positions[23] = max.z;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  // top\n  indices[0] = 4;\n  indices[1] = 5;\n  indices[2] = 5;\n  indices[3] = 6;\n  indices[4] = 6;\n  indices[5] = 7;\n  indices[6] = 7;\n  indices[7] = 4;\n\n  // bottom\n  indices[8] = 0;\n  indices[9] = 1;\n  indices[10] = 1;\n  indices[11] = 2;\n  indices[12] = 2;\n  indices[13] = 3;\n  indices[14] = 3;\n  indices[15] = 0;\n\n  // left\n  indices[16] = 0;\n  indices[17] = 4;\n  indices[18] = 1;\n  indices[19] = 5;\n\n  //right\n  indices[20] = 2;\n  indices[21] = 6;\n  indices[22] = 3;\n  indices[23] = 7;\n\n  const diff = Cartesian3.subtract(max, min, diffScratch);\n  const radius = Cartesian3.magnitude(diff) * 0.5;\n\n  if (defined(boxGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue =\n      boxGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius),\n    offsetAttribute: boxGeometry._offsetAttribute,\n  });\n};\nexport default BoxOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}