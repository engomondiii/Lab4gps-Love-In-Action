{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * A geodesic polygon to be used with {@link ClippingPlaneCollection} for selectively hiding regions in a model, a 3D tileset, or the globe.\n * @alias ClippingPolygon\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions A list of three or more Cartesian coordinates defining the outer ring of the clipping polygon.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default]\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n */\nfunction ClippingPolygon(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.positions\", options.positions);\n  Check.typeOf.number.greaterThanOrEquals(\"options.positions.length\", options.positions.length, 3);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this._positions = [...options.positions];\n}\nObject.defineProperties(ClippingPolygon.prototype, {\n  /**\n   * Returns the total number of positions in the polygon, include any holes.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._positions.length;\n    }\n  },\n  /**\n   * Returns the outer ring of positions.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  positions: {\n    get: function () {\n      return this._positions;\n    }\n  },\n  /**\n   * Returns the ellipsoid used to project the polygon onto surfaces when clipping.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  }\n});\n\n/**\n * Clones the ClippingPolygon without setting its ownership.\n * @param {ClippingPolygon} polygon The ClippingPolygon to be cloned\n * @param {ClippingPolygon} [result] The object on which to store the cloned parameters.\n * @returns {ClippingPolygon} a clone of the input ClippingPolygon\n */\nClippingPolygon.clone = function (polygon, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new ClippingPolygon({\n      positions: polygon.positions,\n      ellipsoid: polygon.ellipsoid\n    });\n  }\n  result._ellipsoid = polygon.ellipsoid;\n  result._positions.length = 0;\n  result._positions.push(...polygon.positions);\n  return result;\n};\n\n/**\n * Compares the provided ClippingPolygons and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first polygon.\n * @param {Plane} right The second polygon.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nClippingPolygon.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.ellipsoid.equals(right.ellipsoid) && left.positions === right.positions;\n};\n\n/**\n * Computes a cartographic rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle\n */\nClippingPolygon.prototype.computeRectangle = function (result) {\n  return PolygonGeometry.computeRectangleFromPositions(this.positions, this.ellipsoid, undefined, result);\n};\nconst scratchRectangle = new Rectangle();\nconst spherePointScratch = new Cartesian3();\n/**\n * Computes a rectangle with the spherical extents that encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @private\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle with spherical extents.\n */\nClippingPolygon.prototype.computeSphericalExtents = function (result) {\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  const rectangle = this.computeRectangle(scratchRectangle);\n  let spherePoint = Cartographic.toCartesian(Rectangle.southwest(rectangle), this.ellipsoid, spherePointScratch);\n\n  // Project into plane with vertical for latitude\n  let magXY = Math.sqrt(spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y);\n\n  // Use fastApproximateAtan2 for alignment with shader\n  let sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  let sphereLongitude = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n  result.south = sphereLatitude;\n  result.west = sphereLongitude;\n  spherePoint = Cartographic.toCartesian(Rectangle.northeast(rectangle), this.ellipsoid, spherePointScratch);\n\n  // Project into plane with vertical for latitude\n  magXY = Math.sqrt(spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y);\n\n  // Use fastApproximateAtan2 for alignment with shader\n  sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  sphereLongitude = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n  result.north = sphereLatitude;\n  result.east = sphereLongitude;\n  return result;\n};\nexport default ClippingPolygon;","map":{"version":3,"names":["Check","Cartesian3","Cartographic","defaultValue","defined","Ellipsoid","CesiumMath","PolygonGeometry","Rectangle","ClippingPolygon","options","typeOf","object","positions","number","greaterThanOrEquals","length","_ellipsoid","ellipsoid","default","_positions","Object","defineProperties","prototype","get","clone","polygon","result","push","equals","left","right","computeRectangle","computeRectangleFromPositions","undefined","scratchRectangle","spherePointScratch","computeSphericalExtents","rectangle","spherePoint","toCartesian","southwest","magXY","Math","sqrt","x","y","sphereLatitude","fastApproximateAtan2","z","sphereLongitude","south","west","northeast","north","east"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ClippingPolygon.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * A geodesic polygon to be used with {@link ClippingPlaneCollection} for selectively hiding regions in a model, a 3D tileset, or the globe.\n * @alias ClippingPolygon\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions A list of three or more Cartesian coordinates defining the outer ring of the clipping polygon.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default]\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n */\nfunction ClippingPolygon(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.positions\", options.positions);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"options.positions.length\",\n    options.positions.length,\n    3,\n  );\n  //>>includeEnd('debug');\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this._positions = [...options.positions];\n}\n\nObject.defineProperties(ClippingPolygon.prototype, {\n  /**\n   * Returns the total number of positions in the polygon, include any holes.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._positions.length;\n    },\n  },\n  /**\n   * Returns the outer ring of positions.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  positions: {\n    get: function () {\n      return this._positions;\n    },\n  },\n  /**\n   * Returns the ellipsoid used to project the polygon onto surfaces when clipping.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Clones the ClippingPolygon without setting its ownership.\n * @param {ClippingPolygon} polygon The ClippingPolygon to be cloned\n * @param {ClippingPolygon} [result] The object on which to store the cloned parameters.\n * @returns {ClippingPolygon} a clone of the input ClippingPolygon\n */\nClippingPolygon.clone = function (polygon, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new ClippingPolygon({\n      positions: polygon.positions,\n      ellipsoid: polygon.ellipsoid,\n    });\n  }\n\n  result._ellipsoid = polygon.ellipsoid;\n  result._positions.length = 0;\n  result._positions.push(...polygon.positions);\n  return result;\n};\n\n/**\n * Compares the provided ClippingPolygons and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first polygon.\n * @param {Plane} right The second polygon.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nClippingPolygon.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.ellipsoid.equals(right.ellipsoid) && left.positions === right.positions\n  );\n};\n\n/**\n * Computes a cartographic rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle\n */\nClippingPolygon.prototype.computeRectangle = function (result) {\n  return PolygonGeometry.computeRectangleFromPositions(\n    this.positions,\n    this.ellipsoid,\n    undefined,\n    result,\n  );\n};\n\nconst scratchRectangle = new Rectangle();\nconst spherePointScratch = new Cartesian3();\n/**\n * Computes a rectangle with the spherical extents that encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @private\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle with spherical extents.\n */\nClippingPolygon.prototype.computeSphericalExtents = function (result) {\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  const rectangle = this.computeRectangle(scratchRectangle);\n\n  let spherePoint = Cartographic.toCartesian(\n    Rectangle.southwest(rectangle),\n    this.ellipsoid,\n    spherePointScratch,\n  );\n\n  // Project into plane with vertical for latitude\n  let magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y,\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  let sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  let sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y,\n  );\n\n  result.south = sphereLatitude;\n  result.west = sphereLongitude;\n\n  spherePoint = Cartographic.toCartesian(\n    Rectangle.northeast(rectangle),\n    this.ellipsoid,\n    spherePointScratch,\n  );\n\n  // Project into plane with vertical for latitude\n  magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y,\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y,\n  );\n\n  result.north = sphereLatitude;\n  result.east = sphereLongitude;\n\n  return result;\n};\n\nexport default ClippingPolygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}