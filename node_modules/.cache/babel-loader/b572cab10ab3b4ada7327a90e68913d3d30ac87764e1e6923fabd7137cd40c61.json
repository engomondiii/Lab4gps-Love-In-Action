{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @namespace Intersections2D\n */\nconst Intersections2D = {};\n\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (threshold, keepAbove, u0, u1, u2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(threshold)) {\n    throw new DeveloperError(\"threshold is required.\");\n  }\n  if (!defined(keepAbove)) {\n    throw new DeveloperError(\"keepAbove is required.\");\n  }\n  if (!defined(u0)) {\n    throw new DeveloperError(\"u0 is required.\");\n  }\n  if (!defined(u1)) {\n    throw new DeveloperError(\"u1 is required.\");\n  }\n  if (!defined(u2)) {\n    throw new DeveloperError(\"u2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n  let u0Behind;\n  let u1Behind;\n  let u2Behind;\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n  const numBehind = u0Behind + u1Behind + u2Behind;\n  let u01Ratio;\n  let u02Ratio;\n  let u12Ratio;\n  let u10Ratio;\n  let u20Ratio;\n  let u21Ratio;\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      result.push(1);\n      result.push(2);\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      result.push(2);\n      result.push(0);\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      result.push(0);\n      result.push(1);\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      result.push(0);\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      result.push(1);\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      result.push(2);\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  }\n  // else Completely behind threshold\n\n  return result;\n};\n\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {number} x1 The x coordinate of the triangle's first vertex.\n * @param {number} y1 The y coordinate of the triangle's first vertex.\n * @param {number} x2 The x coordinate of the triangle's second vertex.\n * @param {number} y2 The y coordinate of the triangle's second vertex.\n * @param {number} x3 The x coordinate of the triangle's third vertex.\n * @param {number} y3 The y coordinate of the triangle's third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\nIntersections2D.computeBarycentricCoordinates = function (x, y, x1, y1, x2, y2, x3, y3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(x1)) {\n    throw new DeveloperError(\"x1 is required.\");\n  }\n  if (!defined(y1)) {\n    throw new DeveloperError(\"y1 is required.\");\n  }\n  if (!defined(x2)) {\n    throw new DeveloperError(\"x2 is required.\");\n  }\n  if (!defined(y2)) {\n    throw new DeveloperError(\"y2 is required.\");\n  }\n  if (!defined(x3)) {\n    throw new DeveloperError(\"x3 is required.\");\n  }\n  if (!defined(y3)) {\n    throw new DeveloperError(\"y3 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const x1mx3 = x1 - x3;\n  const x3mx2 = x3 - x2;\n  const y2my3 = y2 - y3;\n  const y1my3 = y1 - y3;\n  const inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  const ymy3 = y - y3;\n  const xmx3 = x - x3;\n  const l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  const l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  const l3 = 1.0 - l1 - l2;\n  if (defined(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n  return new Cartesian3(l1, l2, l3);\n};\n\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {number} x00 The x coordinate of the first line's first vertex.\n * @param {number} y00 The y coordinate of the first line's first vertex.\n * @param {number} x01 The x coordinate of the first line's second vertex.\n * @param {number} y01 The y coordinate of the first line's second vertex.\n * @param {number} x10 The x coordinate of the second line's first vertex.\n * @param {number} y10 The y coordinate of the second line's first vertex.\n * @param {number} x11 The x coordinate of the second line's second vertex.\n * @param {number} y11 The y coordinate of the second line's second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (x00, y00, x01, y01, x10, y10, x11, y11, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x00\", x00);\n  Check.typeOf.number(\"y00\", y00);\n  Check.typeOf.number(\"x01\", x01);\n  Check.typeOf.number(\"y01\", y01);\n  Check.typeOf.number(\"x10\", x10);\n  Check.typeOf.number(\"y10\", y10);\n  Check.typeOf.number(\"x11\", x11);\n  Check.typeOf.number(\"y11\", y11);\n  //>>includeEnd('debug');\n\n  const numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  const numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  const denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\n\n  // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n  if (denominator1 === 0) {\n    return;\n  }\n  const ua1 = numerator1A / denominator1;\n  const ub1 = numerator1B / denominator1;\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!defined(result)) {\n      result = new Cartesian2();\n    }\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n    return result;\n  }\n};\nexport default Intersections2D;","map":{"version":3,"names":["Cartesian2","Cartesian3","Check","defined","DeveloperError","Intersections2D","clipTriangleAtAxisAlignedThreshold","threshold","keepAbove","u0","u1","u2","result","length","u0Behind","u1Behind","u2Behind","numBehind","u01Ratio","u02Ratio","u12Ratio","u10Ratio","u20Ratio","u21Ratio","push","computeBarycentricCoordinates","x","y","x1","y1","x2","y2","x3","y3","x1mx3","x3mx2","y2my3","y1my3","inverseDeterminant","ymy3","xmx3","l1","l2","l3","z","computeLineSegmentLineSegmentIntersection","x00","y00","x01","y01","x10","y10","x11","y11","typeOf","number","numerator1A","numerator1B","denominator1","ua1","ub1"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Intersections2D.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @namespace Intersections2D\n */\nconst Intersections2D = {};\n\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (\n  threshold,\n  keepAbove,\n  u0,\n  u1,\n  u2,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(threshold)) {\n    throw new DeveloperError(\"threshold is required.\");\n  }\n  if (!defined(keepAbove)) {\n    throw new DeveloperError(\"keepAbove is required.\");\n  }\n  if (!defined(u0)) {\n    throw new DeveloperError(\"u0 is required.\");\n  }\n  if (!defined(u1)) {\n    throw new DeveloperError(\"u1 is required.\");\n  }\n  if (!defined(u2)) {\n    throw new DeveloperError(\"u2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n\n  let u0Behind;\n  let u1Behind;\n  let u2Behind;\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n\n  const numBehind = u0Behind + u1Behind + u2Behind;\n\n  let u01Ratio;\n  let u02Ratio;\n  let u12Ratio;\n  let u10Ratio;\n  let u20Ratio;\n  let u21Ratio;\n\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n\n      result.push(1);\n\n      result.push(2);\n\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n\n      result.push(2);\n\n      result.push(0);\n\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n\n      result.push(0);\n\n      result.push(1);\n\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n\n      result.push(0);\n\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n\n      result.push(1);\n\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n\n      result.push(2);\n\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  }\n  // else Completely behind threshold\n\n  return result;\n};\n\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {number} x1 The x coordinate of the triangle's first vertex.\n * @param {number} y1 The y coordinate of the triangle's first vertex.\n * @param {number} x2 The x coordinate of the triangle's second vertex.\n * @param {number} y2 The y coordinate of the triangle's second vertex.\n * @param {number} x3 The x coordinate of the triangle's third vertex.\n * @param {number} y3 The y coordinate of the triangle's third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\nIntersections2D.computeBarycentricCoordinates = function (\n  x,\n  y,\n  x1,\n  y1,\n  x2,\n  y2,\n  x3,\n  y3,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(x1)) {\n    throw new DeveloperError(\"x1 is required.\");\n  }\n  if (!defined(y1)) {\n    throw new DeveloperError(\"y1 is required.\");\n  }\n  if (!defined(x2)) {\n    throw new DeveloperError(\"x2 is required.\");\n  }\n  if (!defined(y2)) {\n    throw new DeveloperError(\"y2 is required.\");\n  }\n  if (!defined(x3)) {\n    throw new DeveloperError(\"x3 is required.\");\n  }\n  if (!defined(y3)) {\n    throw new DeveloperError(\"y3 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const x1mx3 = x1 - x3;\n  const x3mx2 = x3 - x2;\n  const y2my3 = y2 - y3;\n  const y1my3 = y1 - y3;\n  const inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  const ymy3 = y - y3;\n  const xmx3 = x - x3;\n  const l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  const l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  const l3 = 1.0 - l1 - l2;\n\n  if (defined(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n  return new Cartesian3(l1, l2, l3);\n};\n\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {number} x00 The x coordinate of the first line's first vertex.\n * @param {number} y00 The y coordinate of the first line's first vertex.\n * @param {number} x01 The x coordinate of the first line's second vertex.\n * @param {number} y01 The y coordinate of the first line's second vertex.\n * @param {number} x10 The x coordinate of the second line's first vertex.\n * @param {number} y10 The y coordinate of the second line's first vertex.\n * @param {number} x11 The x coordinate of the second line's second vertex.\n * @param {number} y11 The y coordinate of the second line's second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (\n  x00,\n  y00,\n  x01,\n  y01,\n  x10,\n  y10,\n  x11,\n  y11,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x00\", x00);\n  Check.typeOf.number(\"y00\", y00);\n  Check.typeOf.number(\"x01\", x01);\n  Check.typeOf.number(\"y01\", y01);\n  Check.typeOf.number(\"x10\", x10);\n  Check.typeOf.number(\"y10\", y10);\n  Check.typeOf.number(\"x11\", x11);\n  Check.typeOf.number(\"y11\", y11);\n  //>>includeEnd('debug');\n\n  const numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  const numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  const denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\n\n  // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n  if (denominator1 === 0) {\n    return;\n  }\n\n  const ua1 = numerator1A / denominator1;\n  const ub1 = numerator1B / denominator1;\n\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!defined(result)) {\n      result = new Cartesian2();\n    }\n\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n\n    return result;\n  }\n};\nexport default Intersections2D;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}