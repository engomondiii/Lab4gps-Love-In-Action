{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport ClassificationPrimitive from \"./ClassificationPrimitive.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\nconst GroundPrimitiveUniformMap = {\n  u_globeMinimumAltitude: function () {\n    return 55000.0;\n  }\n};\n\n/**\n * A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors\n * or materials besides PerInstanceColorAppearance.\n * </p>\n * <p>\n * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping\n * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.\n * </p>\n *\n * @alias GroundPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @example\n * // Example 1: Create primitive with a single instance\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * const ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n * @see Primitive\n * @see ClassificationPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction GroundPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let appearance = options.appearance;\n  const geometryInstances = options.geometryInstances;\n  if (!defined(appearance) && defined(geometryInstances)) {\n    const geometryInstancesArray = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];\n    const geometryInstanceCount = geometryInstancesArray.length;\n    for (let i = 0; i < geometryInstanceCount; i++) {\n      const attributes = geometryInstancesArray[i].attributes;\n      if (defined(attributes) && defined(attributes.color)) {\n        appearance = new PerInstanceColorAppearance({\n          flat: true\n        });\n        break;\n      }\n    }\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = defaultValue(options.debugShowShadowVolume, false);\n  this._boundingVolumes = [];\n  this._boundingVolumes2D = [];\n  this._ready = false;\n  this._primitive = undefined;\n  this._maxHeight = undefined;\n  this._minHeight = undefined;\n  this._maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  this._minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  this._boundingSpheresKeys = [];\n  this._boundingSpheres = [];\n  this._useFragmentCulling = false;\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n  const that = this;\n  this._classificationPrimitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(options.releaseGeometryInstances, true),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _pickPrimitive: that,\n    _extruded: true,\n    _uniformMap: GroundPrimitiveUniformMap\n  };\n}\nObject.defineProperties(GroundPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._classificationPrimitiveOptions.vertexCacheOptimize;\n    }\n  },\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._classificationPrimitiveOptions.interleave;\n    }\n  },\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._classificationPrimitiveOptions.releaseGeometryInstances;\n    }\n  },\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._classificationPrimitiveOptions.allowPicking;\n    }\n  },\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._classificationPrimitiveOptions.asynchronous;\n    }\n  },\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._classificationPrimitiveOptions.compressVertices;\n    }\n  },\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  }\n});\n\n/**\n * Determines if GroundPrimitive rendering is supported.\n *\n * @function\n * @param {Scene} scene The scene.\n * @returns {boolean} <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>\n */\nGroundPrimitive.isSupported = ClassificationPrimitive.isSupported;\nfunction getComputeMaximumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    const r = ellipsoid.maximumRadius;\n    const delta = r / Math.cos(granularity * 0.5) - r;\n    return primitive._maxHeight + delta;\n  };\n}\nfunction getComputeMinimumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    return primitive._minHeight;\n  };\n}\nconst scratchBVCartesianHigh = new Cartesian3();\nconst scratchBVCartesianLow = new Cartesian3();\nconst scratchBVCartesian = new Cartesian3();\nconst scratchBVCartographic = new Cartographic();\nconst scratchBVRectangle = new Rectangle();\nfunction getRectangle(frameState, geometry) {\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n  if (!defined(geometry.attributes) || !defined(geometry.attributes.position3DHigh)) {\n    if (defined(geometry.rectangle)) {\n      return geometry.rectangle;\n    }\n    return undefined;\n  }\n  const highPositions = geometry.attributes.position3DHigh.values;\n  const lowPositions = geometry.attributes.position3DLow.values;\n  const length = highPositions.length;\n  let minLat = Number.POSITIVE_INFINITY;\n  let minLon = Number.POSITIVE_INFINITY;\n  let maxLat = Number.NEGATIVE_INFINITY;\n  let maxLon = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < length; i += 3) {\n    const highPosition = Cartesian3.unpack(highPositions, i, scratchBVCartesianHigh);\n    const lowPosition = Cartesian3.unpack(lowPositions, i, scratchBVCartesianLow);\n    const position = Cartesian3.add(highPosition, lowPosition, scratchBVCartesian);\n    const cartographic = ellipsoid.cartesianToCartographic(position, scratchBVCartographic);\n    const latitude = cartographic.latitude;\n    const longitude = cartographic.longitude;\n    minLat = Math.min(minLat, latitude);\n    minLon = Math.min(minLon, longitude);\n    maxLat = Math.max(maxLat, latitude);\n    maxLon = Math.max(maxLon, longitude);\n  }\n  const rectangle = scratchBVRectangle;\n  rectangle.north = maxLat;\n  rectangle.south = minLat;\n  rectangle.east = maxLon;\n  rectangle.west = minLon;\n  return rectangle;\n}\nfunction setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {\n  const result = ApproximateTerrainHeights.getMinimumMaximumHeights(rectangle, ellipsoid);\n  primitive._minTerrainHeight = result.minimumTerrainHeight;\n  primitive._maxTerrainHeight = result.maximumTerrainHeight;\n}\nfunction createBoundingVolume(groundPrimitive, frameState, geometry) {\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n  const rectangle = getRectangle(frameState, geometry);\n  const obb = OrientedBoundingBox.fromRectangle(rectangle, groundPrimitive._minHeight, groundPrimitive._maxHeight, ellipsoid);\n  groundPrimitive._boundingVolumes.push(obb);\n  if (!frameState.scene3DOnly) {\n    const projection = frameState.mapProjection;\n    const boundingVolume = BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, groundPrimitive._maxHeight, groundPrimitive._minHeight);\n    Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n    groundPrimitive._boundingVolumes2D.push(boundingVolume);\n  }\n}\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor(commandIndex % length / 2);\n}\nfunction updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {\n  // Use derived appearance command for 2D if needed\n  const classificationPrimitive = groundPrimitive._primitive;\n  if (frameState.mode !== SceneMode.SCENE3D && command.shaderProgram === classificationPrimitive._spColor && classificationPrimitive._needs2DShader) {\n    command = command.derivedCommands.appearance2D;\n  }\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n  frameState.commandList.push(command);\n}\nfunction updateAndQueuePickCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume) {\n  // Use derived pick command for 2D if needed\n  const classificationPrimitive = groundPrimitive._primitive;\n  if (frameState.mode !== SceneMode.SCENE3D && command.shaderProgram === classificationPrimitive._spPick && classificationPrimitive._needs2DShader) {\n    command = command.derivedCommands.pick2D;\n  }\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  frameState.commandList.push(command);\n}\nfunction updateAndQueueCommands(groundPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  let boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = groundPrimitive._boundingVolumes;\n  } else {\n    boundingVolumes = groundPrimitive._boundingVolumes2D;\n  }\n  const classificationType = groundPrimitive.classificationType;\n  const queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  const passes = frameState.passes;\n  const classificationPrimitive = groundPrimitive._primitive;\n  let i;\n  let boundingVolume;\n  let command;\n  if (passes.render) {\n    const colorLength = colorCommands.length;\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n    if (frameState.invertClassification) {\n      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      const ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[i];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n  }\n  if (passes.pick) {\n    const pickLength = pickCommands.length;\n    let pickOffsets;\n    if (!groundPrimitive._useFragmentCulling) {\n      // Must be using pick offsets\n      pickOffsets = classificationPrimitive._primitive._pickOffsets;\n    }\n    for (i = 0; i < pickLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, pickLength)];\n      if (!groundPrimitive._useFragmentCulling) {\n        const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n        boundingVolume = boundingVolumes[pickOffset.index];\n      }\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume);\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(groundPrimitive, command, frameState, modelMatrix, cull, boundingVolume);\n      }\n    }\n  }\n}\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPrimitive synchronously.\n *\n * @returns {Promise<void>} A promise that will resolve once the terrain heights have been loaded.\n *\n */\nGroundPrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPrimitive, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n */\nGroundPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\"For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\");\n    }\n    //>>includeEnd('debug');\n\n    GroundPrimitive.initializeTerrainHeights();\n    return;\n  }\n  const that = this;\n  const primitiveOptions = this._classificationPrimitiveOptions;\n  if (!defined(this._primitive)) {\n    const ellipsoid = frameState.mapProjection.ellipsoid;\n    let instance;\n    let geometry;\n    let instanceType;\n    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];\n    const length = instances.length;\n    const groundInstances = new Array(length);\n    let i;\n    let rectangle;\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometry = instance.geometry;\n      const instanceRectangle = getRectangle(frameState, geometry);\n      if (!defined(rectangle)) {\n        rectangle = Rectangle.clone(instanceRectangle);\n      } else if (defined(instanceRectangle)) {\n        Rectangle.union(rectangle, instanceRectangle, rectangle);\n      }\n      const id = instance.id;\n      if (defined(id) && defined(instanceRectangle)) {\n        const boundingSphere = ApproximateTerrainHeights.getBoundingSphere(instanceRectangle, ellipsoid);\n        this._boundingSpheresKeys.push(id);\n        this._boundingSpheres.push(boundingSphere);\n      }\n      instanceType = geometry.constructor;\n      if (!defined(instanceType) || !defined(instanceType.createShadowVolume)) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\"Not all of the geometry instances have GroundPrimitive support.\");\n        //>>includeEnd('debug');\n      }\n    }\n\n    // Now compute the min/max heights for the primitive\n    setMinMaxTerrainHeights(this, rectangle, ellipsoid);\n    const exaggeration = frameState.verticalExaggeration;\n    const exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n    this._minHeight = VerticalExaggeration.getHeight(this._minTerrainHeight, exaggeration, exaggerationRelativeHeight);\n    this._maxHeight = VerticalExaggeration.getHeight(this._maxTerrainHeight, exaggeration, exaggerationRelativeHeight);\n    const useFragmentCulling = GroundPrimitive._supportsMaterials(frameState.context);\n    this._useFragmentCulling = useFragmentCulling;\n    if (useFragmentCulling) {\n      // Determine whether to add spherical or planar extent attributes for computing texture coordinates.\n      // This depends on the size of the GeometryInstances.\n      let attributes;\n      let usePlanarExtents = true;\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        rectangle = getRectangle(frameState, geometry);\n        if (ShadowVolumeAppearance.shouldUseSphericalCoordinates(rectangle)) {\n          usePlanarExtents = false;\n          break;\n        }\n      }\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        const boundingRectangle = getRectangle(frameState, geometry);\n        const textureCoordinateRotationPoints = geometry.textureCoordinateRotationPoints;\n        if (usePlanarExtents) {\n          attributes = ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, frameState.mapProjection, this._maxHeight);\n        } else {\n          attributes = ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes(boundingRectangle, textureCoordinateRotationPoints, ellipsoid, frameState.mapProjection);\n        }\n        const instanceAttributes = instance.attributes;\n        for (const attributeKey in instanceAttributes) {\n          if (instanceAttributes.hasOwnProperty(attributeKey)) {\n            attributes[attributeKey] = instanceAttributes[attributeKey];\n          }\n        }\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(geometry, getComputeMinimumHeightFunction(this), getComputeMaximumHeightFunction(this)),\n          attributes: attributes,\n          id: instance.id\n        });\n      }\n    } else {\n      // ClassificationPrimitive will check if the colors are all the same if it detects lack of fragment culling attributes\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(geometry, getComputeMinimumHeightFunction(this), getComputeMaximumHeightFunction(this)),\n          attributes: instance.attributes,\n          id: instance.id\n        });\n      }\n    }\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n    primitiveOptions._createBoundingVolumeFunction = function (frameState, geometry) {\n      createBoundingVolume(that, frameState, geometry);\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n      updateAndQueueCommands(that, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses);\n    };\n    this._primitive = new ClassificationPrimitive(primitiveOptions);\n  }\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n  frameState.afterRender.push(() => {\n    if (!this._ready && defined(this._primitive) && this._primitive.ready) {\n      this._ready = true;\n      if (this.releaseGeometryInstances) {\n        this.geometryInstances = undefined;\n      }\n    }\n  });\n};\n\n/**\n * @private\n */\nGroundPrimitive.prototype.getBoundingSphere = function (id) {\n  const index = this._boundingSpheresKeys.indexOf(id);\n  if (index !== -1) {\n    return this._boundingSpheres[index];\n  }\n  return undefined;\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPrimitive#destroy\n */\nGroundPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPrimitive#isDestroyed\n */\nGroundPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\n/**\n * Exposed for testing.\n *\n * @param {Context} context Rendering context\n * @returns {boolean} Whether or not the current context supports materials on GroundPrimitives.\n * @private\n */\nGroundPrimitive._supportsMaterials = function (context) {\n  return context.depthTexture;\n};\n\n/**\n * Checks if the given Scene supports materials on GroundPrimitives.\n * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {boolean} Whether or not the current scene supports materials on GroundPrimitives.\n */\nGroundPrimitive.supportsMaterials = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  return GroundPrimitive._supportsMaterials(scene.frameState.context);\n};\nexport default GroundPrimitive;","map":{"version":3,"names":["ApproximateTerrainHeights","BoundingSphere","Cartesian3","Cartographic","Check","defaultValue","defined","destroyObject","DeveloperError","GeometryInstance","OrientedBoundingBox","Rectangle","VerticalExaggeration","ClassificationPrimitive","ClassificationType","PerInstanceColorAppearance","SceneMode","ShadowVolumeAppearance","GroundPrimitiveUniformMap","u_globeMinimumAltitude","GroundPrimitive","options","EMPTY_OBJECT","appearance","geometryInstances","geometryInstancesArray","Array","isArray","geometryInstanceCount","length","i","attributes","color","flat","show","classificationType","BOTH","debugShowBoundingVolume","debugShowShadowVolume","_boundingVolumes","_boundingVolumes2D","_ready","_primitive","undefined","_maxHeight","_minHeight","_maxTerrainHeight","_defaultMaxTerrainHeight","_minTerrainHeight","_defaultMinTerrainHeight","_boundingSpheresKeys","_boundingSpheres","_useFragmentCulling","_zIndex","that","_classificationPrimitiveOptions","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","asynchronous","compressVertices","_createBoundingVolumeFunction","_updateAndQueueCommandsFunction","_pickPrimitive","_extruded","_uniformMap","Object","defineProperties","prototype","get","ready","isSupported","getComputeMaximumHeightFunction","primitive","granularity","ellipsoid","r","maximumRadius","delta","Math","cos","getComputeMinimumHeightFunction","scratchBVCartesianHigh","scratchBVCartesianLow","scratchBVCartesian","scratchBVCartographic","scratchBVRectangle","getRectangle","frameState","geometry","mapProjection","position3DHigh","rectangle","highPositions","values","lowPositions","position3DLow","minLat","Number","POSITIVE_INFINITY","minLon","maxLat","NEGATIVE_INFINITY","maxLon","highPosition","unpack","lowPosition","position","add","cartographic","cartesianToCartographic","latitude","longitude","min","max","north","south","east","west","setMinMaxTerrainHeights","result","getMinimumMaximumHeights","minimumTerrainHeight","maximumTerrainHeight","createBoundingVolume","groundPrimitive","obb","fromRectangle","push","scene3DOnly","projection","boundingVolume","fromRectangleWithHeights2D","fromElements","center","z","x","y","boundingVolumeIndex","commandIndex","floor","updateAndQueueRenderCommand","command","modelMatrix","cull","classificationPrimitive","mode","SCENE3D","shaderProgram","_spColor","_needs2DShader","derivedCommands","appearance2D","owner","commandList","updateAndQueuePickCommand","_spPick","pick2D","updateAndQueueCommands","colorCommands","pickCommands","twoPasses","boundingVolumes","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","TERRAIN","passes","render","colorLength","tileset","invertClassification","ignoreShowCommands","_commandsIgnoreShow","ignoreShowCommandsLength","pick","pickLength","pickOffsets","_pickOffsets","pickOffset","index","initializeTerrainHeights","initialize","update","initialized","primitiveOptions","instance","instanceType","instances","groundInstances","instanceRectangle","clone","union","id","boundingSphere","getBoundingSphere","constructor","createShadowVolume","exaggeration","verticalExaggeration","exaggerationRelativeHeight","verticalExaggerationRelativeHeight","getHeight","useFragmentCulling","_supportsMaterials","context","usePlanarExtents","shouldUseSphericalCoordinates","boundingRectangle","textureCoordinateRotationPoints","getPlanarTextureCoordinateAttributes","getSphericalExtentGeometryInstanceAttributes","instanceAttributes","attributeKey","hasOwnProperty","afterRender","indexOf","getGeometryInstanceAttributes","isDestroyed","destroy","depthTexture","supportsMaterials","scene","typeOf","object"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GroundPrimitive.js"],"sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport ClassificationPrimitive from \"./ClassificationPrimitive.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\n\nconst GroundPrimitiveUniformMap = {\n  u_globeMinimumAltitude: function () {\n    return 55000.0;\n  },\n};\n\n/**\n * A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors\n * or materials besides PerInstanceColorAppearance.\n * </p>\n * <p>\n * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping\n * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.\n * </p>\n *\n * @alias GroundPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @example\n * // Example 1: Create primitive with a single instance\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * const ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n * @see Primitive\n * @see ClassificationPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction GroundPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  let appearance = options.appearance;\n  const geometryInstances = options.geometryInstances;\n  if (!defined(appearance) && defined(geometryInstances)) {\n    const geometryInstancesArray = Array.isArray(geometryInstances)\n      ? geometryInstances\n      : [geometryInstances];\n    const geometryInstanceCount = geometryInstancesArray.length;\n    for (let i = 0; i < geometryInstanceCount; i++) {\n      const attributes = geometryInstancesArray[i].attributes;\n      if (defined(attributes) && defined(attributes.color)) {\n        appearance = new PerInstanceColorAppearance({\n          flat: true,\n        });\n        break;\n      }\n    }\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH,\n  );\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false,\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false,\n  );\n\n  this._boundingVolumes = [];\n  this._boundingVolumes2D = [];\n\n  this._ready = false;\n  this._primitive = undefined;\n\n  this._maxHeight = undefined;\n  this._minHeight = undefined;\n\n  this._maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  this._minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n\n  this._boundingSpheresKeys = [];\n  this._boundingSpheres = [];\n\n  this._useFragmentCulling = false;\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n\n  const that = this;\n  this._classificationPrimitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true,\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _pickPrimitive: that,\n    _extruded: true,\n    _uniformMap: GroundPrimitiveUniformMap,\n  };\n}\n\nObject.defineProperties(GroundPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._classificationPrimitiveOptions.vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._classificationPrimitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._classificationPrimitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._classificationPrimitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._classificationPrimitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._classificationPrimitiveOptions.compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\n/**\n * Determines if GroundPrimitive rendering is supported.\n *\n * @function\n * @param {Scene} scene The scene.\n * @returns {boolean} <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>\n */\nGroundPrimitive.isSupported = ClassificationPrimitive.isSupported;\n\nfunction getComputeMaximumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    const r = ellipsoid.maximumRadius;\n    const delta = r / Math.cos(granularity * 0.5) - r;\n    return primitive._maxHeight + delta;\n  };\n}\n\nfunction getComputeMinimumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    return primitive._minHeight;\n  };\n}\n\nconst scratchBVCartesianHigh = new Cartesian3();\nconst scratchBVCartesianLow = new Cartesian3();\nconst scratchBVCartesian = new Cartesian3();\nconst scratchBVCartographic = new Cartographic();\nconst scratchBVRectangle = new Rectangle();\n\nfunction getRectangle(frameState, geometry) {\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n\n  if (\n    !defined(geometry.attributes) ||\n    !defined(geometry.attributes.position3DHigh)\n  ) {\n    if (defined(geometry.rectangle)) {\n      return geometry.rectangle;\n    }\n\n    return undefined;\n  }\n\n  const highPositions = geometry.attributes.position3DHigh.values;\n  const lowPositions = geometry.attributes.position3DLow.values;\n  const length = highPositions.length;\n\n  let minLat = Number.POSITIVE_INFINITY;\n  let minLon = Number.POSITIVE_INFINITY;\n  let maxLat = Number.NEGATIVE_INFINITY;\n  let maxLon = Number.NEGATIVE_INFINITY;\n\n  for (let i = 0; i < length; i += 3) {\n    const highPosition = Cartesian3.unpack(\n      highPositions,\n      i,\n      scratchBVCartesianHigh,\n    );\n    const lowPosition = Cartesian3.unpack(\n      lowPositions,\n      i,\n      scratchBVCartesianLow,\n    );\n\n    const position = Cartesian3.add(\n      highPosition,\n      lowPosition,\n      scratchBVCartesian,\n    );\n    const cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      scratchBVCartographic,\n    );\n\n    const latitude = cartographic.latitude;\n    const longitude = cartographic.longitude;\n\n    minLat = Math.min(minLat, latitude);\n    minLon = Math.min(minLon, longitude);\n    maxLat = Math.max(maxLat, latitude);\n    maxLon = Math.max(maxLon, longitude);\n  }\n\n  const rectangle = scratchBVRectangle;\n  rectangle.north = maxLat;\n  rectangle.south = minLat;\n  rectangle.east = maxLon;\n  rectangle.west = minLon;\n\n  return rectangle;\n}\n\nfunction setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {\n  const result = ApproximateTerrainHeights.getMinimumMaximumHeights(\n    rectangle,\n    ellipsoid,\n  );\n\n  primitive._minTerrainHeight = result.minimumTerrainHeight;\n  primitive._maxTerrainHeight = result.maximumTerrainHeight;\n}\n\nfunction createBoundingVolume(groundPrimitive, frameState, geometry) {\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n  const rectangle = getRectangle(frameState, geometry);\n\n  const obb = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    groundPrimitive._minHeight,\n    groundPrimitive._maxHeight,\n    ellipsoid,\n  );\n  groundPrimitive._boundingVolumes.push(obb);\n\n  if (!frameState.scene3DOnly) {\n    const projection = frameState.mapProjection;\n    const boundingVolume = BoundingSphere.fromRectangleWithHeights2D(\n      rectangle,\n      projection,\n      groundPrimitive._maxHeight,\n      groundPrimitive._minHeight,\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center,\n    );\n\n    groundPrimitive._boundingVolumes2D.push(boundingVolume);\n  }\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor((commandIndex % length) / 2);\n}\n\nfunction updateAndQueueRenderCommand(\n  groundPrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume,\n) {\n  // Use derived appearance command for 2D if needed\n  const classificationPrimitive = groundPrimitive._primitive;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    command.shaderProgram === classificationPrimitive._spColor &&\n    classificationPrimitive._needs2DShader\n  ) {\n    command = command.derivedCommands.appearance2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(\n  groundPrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n) {\n  // Use derived pick command for 2D if needed\n  const classificationPrimitive = groundPrimitive._primitive;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    command.shaderProgram === classificationPrimitive._spPick &&\n    classificationPrimitive._needs2DShader\n  ) {\n    command = command.derivedCommands.pick2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  groundPrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses,\n) {\n  let boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = groundPrimitive._boundingVolumes;\n  } else {\n    boundingVolumes = groundPrimitive._boundingVolumes2D;\n  }\n\n  const classificationType = groundPrimitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN;\n\n  const passes = frameState.passes;\n  const classificationPrimitive = groundPrimitive._primitive;\n\n  let i;\n  let boundingVolume;\n  let command;\n\n  if (passes.render) {\n    const colorLength = colorCommands.length;\n\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n    }\n\n    if (frameState.invertClassification) {\n      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      const ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[i];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n    }\n  }\n\n  if (passes.pick) {\n    const pickLength = pickCommands.length;\n\n    let pickOffsets;\n    if (!groundPrimitive._useFragmentCulling) {\n      // Must be using pick offsets\n      pickOffsets = classificationPrimitive._primitive._pickOffsets;\n    }\n    for (i = 0; i < pickLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, pickLength)];\n      if (!groundPrimitive._useFragmentCulling) {\n        const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n        boundingVolume = boundingVolumes[pickOffset.index];\n      }\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPrimitive synchronously.\n *\n * @returns {Promise<void>} A promise that will resolve once the terrain heights have been loaded.\n *\n */\nGroundPrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPrimitive, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n */\nGroundPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\n        \"For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    GroundPrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  const that = this;\n  const primitiveOptions = this._classificationPrimitiveOptions;\n\n  if (!defined(this._primitive)) {\n    const ellipsoid = frameState.mapProjection.ellipsoid;\n\n    let instance;\n    let geometry;\n    let instanceType;\n\n    const instances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    const length = instances.length;\n    const groundInstances = new Array(length);\n\n    let i;\n    let rectangle;\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometry = instance.geometry;\n      const instanceRectangle = getRectangle(frameState, geometry);\n      if (!defined(rectangle)) {\n        rectangle = Rectangle.clone(instanceRectangle);\n      } else if (defined(instanceRectangle)) {\n        Rectangle.union(rectangle, instanceRectangle, rectangle);\n      }\n\n      const id = instance.id;\n      if (defined(id) && defined(instanceRectangle)) {\n        const boundingSphere = ApproximateTerrainHeights.getBoundingSphere(\n          instanceRectangle,\n          ellipsoid,\n        );\n        this._boundingSpheresKeys.push(id);\n        this._boundingSpheres.push(boundingSphere);\n      }\n\n      instanceType = geometry.constructor;\n      if (!defined(instanceType) || !defined(instanceType.createShadowVolume)) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\n          \"Not all of the geometry instances have GroundPrimitive support.\",\n        );\n        //>>includeEnd('debug');\n      }\n    }\n\n    // Now compute the min/max heights for the primitive\n    setMinMaxTerrainHeights(this, rectangle, ellipsoid);\n    const exaggeration = frameState.verticalExaggeration;\n    const exaggerationRelativeHeight =\n      frameState.verticalExaggerationRelativeHeight;\n    this._minHeight = VerticalExaggeration.getHeight(\n      this._minTerrainHeight,\n      exaggeration,\n      exaggerationRelativeHeight,\n    );\n    this._maxHeight = VerticalExaggeration.getHeight(\n      this._maxTerrainHeight,\n      exaggeration,\n      exaggerationRelativeHeight,\n    );\n\n    const useFragmentCulling = GroundPrimitive._supportsMaterials(\n      frameState.context,\n    );\n    this._useFragmentCulling = useFragmentCulling;\n\n    if (useFragmentCulling) {\n      // Determine whether to add spherical or planar extent attributes for computing texture coordinates.\n      // This depends on the size of the GeometryInstances.\n      let attributes;\n      let usePlanarExtents = true;\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        rectangle = getRectangle(frameState, geometry);\n        if (ShadowVolumeAppearance.shouldUseSphericalCoordinates(rectangle)) {\n          usePlanarExtents = false;\n          break;\n        }\n      }\n\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n\n        const boundingRectangle = getRectangle(frameState, geometry);\n        const textureCoordinateRotationPoints =\n          geometry.textureCoordinateRotationPoints;\n\n        if (usePlanarExtents) {\n          attributes =\n            ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes(\n              boundingRectangle,\n              textureCoordinateRotationPoints,\n              ellipsoid,\n              frameState.mapProjection,\n              this._maxHeight,\n            );\n        } else {\n          attributes =\n            ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes(\n              boundingRectangle,\n              textureCoordinateRotationPoints,\n              ellipsoid,\n              frameState.mapProjection,\n            );\n        }\n\n        const instanceAttributes = instance.attributes;\n        for (const attributeKey in instanceAttributes) {\n          if (instanceAttributes.hasOwnProperty(attributeKey)) {\n            attributes[attributeKey] = instanceAttributes[attributeKey];\n          }\n        }\n\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(\n            geometry,\n            getComputeMinimumHeightFunction(this),\n            getComputeMaximumHeightFunction(this),\n          ),\n          attributes: attributes,\n          id: instance.id,\n        });\n      }\n    } else {\n      // ClassificationPrimitive will check if the colors are all the same if it detects lack of fragment culling attributes\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(\n            geometry,\n            getComputeMinimumHeightFunction(this),\n            getComputeMaximumHeightFunction(this),\n          ),\n          attributes: instance.attributes,\n          id: instance.id,\n        });\n      }\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createBoundingVolumeFunction = function (\n      frameState,\n      geometry,\n    ) {\n      createBoundingVolume(that, frameState, geometry);\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (\n      primitive,\n      frameState,\n      colorCommands,\n      pickCommands,\n      modelMatrix,\n      cull,\n      debugShowBoundingVolume,\n      twoPasses,\n    ) {\n      updateAndQueueCommands(\n        that,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses,\n      );\n    };\n\n    this._primitive = new ClassificationPrimitive(primitiveOptions);\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n\n  frameState.afterRender.push(() => {\n    if (!this._ready && defined(this._primitive) && this._primitive.ready) {\n      this._ready = true;\n\n      if (this.releaseGeometryInstances) {\n        this.geometryInstances = undefined;\n      }\n    }\n  });\n};\n\n/**\n * @private\n */\nGroundPrimitive.prototype.getBoundingSphere = function (id) {\n  const index = this._boundingSpheresKeys.indexOf(id);\n  if (index !== -1) {\n    return this._boundingSpheres[index];\n  }\n\n  return undefined;\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\",\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPrimitive#destroy\n */\nGroundPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPrimitive#isDestroyed\n */\nGroundPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\n/**\n * Exposed for testing.\n *\n * @param {Context} context Rendering context\n * @returns {boolean} Whether or not the current context supports materials on GroundPrimitives.\n * @private\n */\nGroundPrimitive._supportsMaterials = function (context) {\n  return context.depthTexture;\n};\n\n/**\n * Checks if the given Scene supports materials on GroundPrimitives.\n * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {boolean} Whether or not the current scene supports materials on GroundPrimitives.\n */\nGroundPrimitive.supportsMaterials = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  return GroundPrimitive._supportsMaterials(scene.frameState.context);\n};\nexport default GroundPrimitive;\n"],"mappings":"AAAA,OAAOA,yBAAyB,MAAM,sCAAsC;AAC5E,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,mBAAmB,MAAM,gCAAgC;AAChE,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,oBAAoB,MAAM,iCAAiC;AAClE,OAAOC,uBAAuB,MAAM,8BAA8B;AAClE,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,0BAA0B,MAAM,iCAAiC;AACxE,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,sBAAsB,MAAM,6BAA6B;AAEhE,MAAMC,yBAAyB,GAAG;EAChCC,sBAAsB,EAAE,SAAAA,CAAA,EAAY;IAClC,OAAO,OAAO;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,OAAO,EAAE;EAChCA,OAAO,GAAGhB,YAAY,CAACgB,OAAO,EAAEhB,YAAY,CAACiB,YAAY,CAAC;EAE1D,IAAIC,UAAU,GAAGF,OAAO,CAACE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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEb,mBAAmB,EAAE;IACnBc,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,+BAA+B,CAACC,mBAAmB;IACjE;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAU,EAAE;IACVa,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,+BAA+B,CAACE,UAAU;IACxD;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,wBAAwB,EAAE;IACxBY,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,+BAA+B,CAACG,wBAAwB;IACtE;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,YAAY,EAAE;IACZW,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,+BAA+B,CAACI,YAAY;IAC1D;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,YAAY,EAAE;IACZU,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,+BAA+B,CAACK,YAAY;IAC1D;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,gBAAgB,EAAE;IAChBS,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,+BAA+B,CAACM,gBAAgB;IAC9D;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,KAAK,EAAE;IACLD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC7B,MAAM;IACpB;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,eAAe,CAACoD,WAAW,GAAG3D,uBAAuB,CAAC2D,WAAW;AAEjE,SAASC,+BAA+BA,CAACC,SAAS,EAAE;EACl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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}