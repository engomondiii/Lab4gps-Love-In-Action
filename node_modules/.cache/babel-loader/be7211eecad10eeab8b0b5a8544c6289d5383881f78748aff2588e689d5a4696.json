{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {object} [options.structure] An object describing the structure of the height data.\n * @param {number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * const buffer = ...\n * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * const terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n  const defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  let structure = options.structure;\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(structure.heightScale, defaultStructure.heightScale);\n    structure.heightOffset = defaultValue(structure.heightOffset, defaultStructure.heightOffset);\n    structure.elementsPerHeight = defaultValue(structure.elementsPerHeight, defaultStructure.elementsPerHeight);\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(structure.elementMultiplier, defaultStructure.elementMultiplier);\n    structure.isBigEndian = defaultValue(structure.isBigEndian, defaultStructure.isBigEndian);\n  }\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n  this._skirtHeight = undefined;\n  this._bufferType = this._encoding === HeightmapEncoding.LERC ? Float32Array : this._buffer.constructor;\n  this._mesh = undefined;\n}\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    }\n  },\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    }\n  }\n});\nconst createMeshTaskName = \"createVerticesFromHeightmap\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(createMeshTaskName, TerrainData.maximumAsynchronousTasks);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(options.exaggerationRelativeHeight, 0.0);\n  const throttle = defaultValue(options.throttle, true);\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n  const structure = this._structure;\n  const levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n  const createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    encoding: this._encoding\n  });\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    let indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(result.gridWidth, result.gridHeight);\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(result.gridWidth, result.gridHeight);\n    }\n    const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), indicesAndEdges.indices, indicesAndEdges.indexCountWithoutSkirts, vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, BoundingSphere.clone(result.boundingSphere3D), Cartesian3.clone(result.occludeePointInScaledSpace), result.numberOfAttributes, OrientedBoundingBox.clone(result.orientedBoundingBox), TerrainEncoding.clone(result.encoding), indicesAndEdges.westIndicesSouthToNorth, indicesAndEdges.southIndicesEastToWest, indicesAndEdges.eastIndicesNorthToSouth, indicesAndEdges.northIndicesWestToEast);\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n *\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(options.exaggerationRelativeHeight, 0.0);\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n  const structure = this._structure;\n  const levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n  const result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n  let indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width, this._height);\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(this._width, this._height);\n  }\n  const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  this._mesh = new TerrainMesh(center, result.vertices, indicesAndEdges.indices, indicesAndEdges.indexCountWithoutSkirts, vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, result.boundingSphere3D, result.occludeePointInScaledSpace, result.encoding.stride, result.orientedBoundingBox, result.encoding, indicesAndEdges.westIndicesSouthToNorth, indicesAndEdges.southIndicesEastToWest, indicesAndEdges.eastIndicesNorthToSouth, indicesAndEdges.northIndicesWestToEast);\n  return this._mesh;\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  const width = this._width;\n  const height = this._height;\n  const structure = this._structure;\n  const stride = structure.stride;\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n  const isMeshCreated = defined(this._mesh);\n  const isLERCEncoding = this._encoding === HeightmapEncoding.LERC;\n  const isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n  if (isInterpolationImpossible) {\n    // We can't interpolate using the buffer because it's LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n  let heightSample;\n  if (isMeshCreated) {\n    const buffer = this._mesh.vertices;\n    const encoding = this._mesh.encoding;\n    heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, rectangle, width, height, longitude, latitude);\n  } else {\n    heightSample = interpolateHeight(this._buffer, elementsPerHeight, elementMultiplier, stride, isBigEndian, rectangle, width, height, longitude, latitude);\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if the mesh is unavailable.\n */\nHeightmapTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  }\n  //>>includeEnd('debug');\n\n  const meshData = this._mesh;\n  if (!defined(meshData)) {\n    return undefined;\n  }\n  const width = this._width;\n  const height = this._height;\n  const structure = this._structure;\n  const stride = structure.stride;\n  const heights = new this._bufferType(width * height * stride);\n  const buffer = meshData.vertices;\n  const encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n  const sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);\n  const destinationRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n  const divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n  for (let j = 0; j < height; ++j) {\n    const latitude = CesiumMath.lerp(destinationRectangle.north, destinationRectangle.south, j / (height - 1));\n    for (let i = 0; i < width; ++i) {\n      const longitude = CesiumMath.lerp(destinationRectangle.west, destinationRectangle.east, i / (width - 1));\n      let heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude);\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample = heightSample < structure.lowestEncodedHeight ? structure.lowestEncodedHeight : heightSample;\n      heightSample = heightSample > structure.highestEncodedHeight ? structure.highestEncodedHeight : heightSample;\n      setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, j * width + i, heightSample);\n    }\n  }\n  return Promise.resolve(new HeightmapTerrainData({\n    buffer: heights,\n    width: width,\n    height: height,\n    childTileMask: 0,\n    structure: this._structure,\n    createdByUpsampling: true\n  }));\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nfunction interpolateHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {\n  const fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n  const southwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + westInteger);\n  const southeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + eastInteger);\n  const northwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + westInteger);\n  const northeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + eastInteger);\n  return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n}\nfunction interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  const fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n  const southwestHeight = (encoding.decodeHeight(buffer, southInteger * width + westInteger) - heightOffset) / heightScale;\n  const southeastHeight = (encoding.decodeHeight(buffer, southInteger * width + eastInteger) - heightOffset) / heightScale;\n  const northwestHeight = (encoding.decodeHeight(buffer, northInteger * width + westInteger) - heightOffset) / heightScale;\n  const northeastHeight = (encoding.decodeHeight(buffer, northInteger * width + eastInteger) - heightOffset) / heightScale;\n  return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n}\nfunction triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return southwestHeight + dX * (southeastHeight - southwestHeight) + dY * (northeastHeight - southeastHeight);\n  }\n\n  // Upper left triangle\n  return southwestHeight + dX * (northeastHeight - northwestHeight) + dY * (northwestHeight - southwestHeight);\n}\nfunction getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {\n  index *= stride;\n  let height = 0;\n  let i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n  return height;\n}\nfunction setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {\n  index *= stride;\n  let i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = height / divisor | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = height / divisor | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\nexport default HeightmapTerrainData;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","defaultValue","defined","DeveloperError","GeographicProjection","HeightmapEncoding","HeightmapTessellator","CesiumMath","OrientedBoundingBox","Rectangle","TaskProcessor","TerrainData","TerrainEncoding","TerrainMesh","TerrainProvider","HeightmapTerrainData","options","buffer","width","height","_buffer","_width","_height","_childTileMask","childTileMask","_encoding","encoding","NONE","defaultStructure","DEFAULT_STRUCTURE","structure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","_structure","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_skirtHeight","undefined","_bufferType","LERC","Float32Array","constructor","_mesh","Object","defineProperties","prototype","credits","get","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","createMesh","EMPTY_OBJECT","typeOf","object","tilingScheme","number","x","y","level","exaggeration","exaggerationRelativeHeight","throttle","ellipsoid","nativeRectangle","tileXYToNativeRectangle","rectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","thisLevelMaxError","Math","min","createMeshTaskProcessor","verticesPromise","scheduleTask","heightmap","includeWebMercatorT","relativeToCenter","skirtHeight","isGeographic","projection","that","Promise","resolve","then","result","indicesAndEdges","getRegularGridAndSkirtIndicesAndEdgeIndices","gridWidth","gridHeight","getRegularGridIndicesAndEdgeIndices","vertexCountWithoutSkirts","vertices","indices","indexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","_createMeshSync","computeVertices","interpolateHeight","longitude","latitude","isMeshCreated","isLERCEncoding","isInterpolationImpossible","heightSample","interpolateMeshHeight","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","meshData","heights","sourceRectangle","destinationRectangle","divisor","pow","j","lerp","north","south","i","west","east","lowestEncodedHeight","highestEncodedHeight","setHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","sourceHeights","fromWest","fromSouth","westInteger","eastInteger","southInteger","northInteger","dx","dy","southwestHeight","getHeight","southeastHeight","northwestHeight","northeastHeight","triangleInterpolateHeight","decodeHeight","dX","dY","index"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/HeightmapTerrainData.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {object} [options.structure] An object describing the structure of the height data.\n * @param {number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * const buffer = ...\n * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * const terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n\n  const defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  let structure = options.structure;\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(\n      structure.heightScale,\n      defaultStructure.heightScale,\n    );\n    structure.heightOffset = defaultValue(\n      structure.heightOffset,\n      defaultStructure.heightOffset,\n    );\n    structure.elementsPerHeight = defaultValue(\n      structure.elementsPerHeight,\n      defaultStructure.elementsPerHeight,\n    );\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(\n      structure.elementMultiplier,\n      defaultStructure.elementMultiplier,\n    );\n    structure.isBigEndian = defaultValue(\n      structure.isBigEndian,\n      defaultStructure.isBigEndian,\n    );\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._skirtHeight = undefined;\n  this._bufferType =\n    this._encoding === HeightmapEncoding.LERC\n      ? Float32Array\n      : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n});\n\nconst createMeshTaskName = \"createVerticesFromHeightmap\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0,\n  );\n  const throttle = defaultValue(options.throttle, true);\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  const structure = this._structure;\n\n  const levelZeroMaxError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      ellipsoid,\n      this._width,\n      tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    encoding: this._encoding,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    let indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges =\n        TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n          result.gridWidth,\n          result.gridHeight,\n        );\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight,\n      );\n    }\n\n    const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      indicesAndEdges.indices,\n      indicesAndEdges.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      indicesAndEdges.westIndicesSouthToNorth,\n      indicesAndEdges.southIndicesEastToWest,\n      indicesAndEdges.eastIndicesNorthToSouth,\n      indicesAndEdges.northIndicesWestToEast,\n    );\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n *\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0,\n  );\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  const structure = this._structure;\n\n  const levelZeroMaxError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      ellipsoid,\n      this._width,\n      tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  const result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n\n  let indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges =\n      TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n        this._width,\n        this._height,\n      );\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n      this._width,\n      this._height,\n    );\n  }\n\n  const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  this._mesh = new TerrainMesh(\n    center,\n    result.vertices,\n    indicesAndEdges.indices,\n    indicesAndEdges.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts,\n    result.minimumHeight,\n    result.maximumHeight,\n    result.boundingSphere3D,\n    result.occludeePointInScaledSpace,\n    result.encoding.stride,\n    result.orientedBoundingBox,\n    result.encoding,\n    indicesAndEdges.westIndicesSouthToNorth,\n    indicesAndEdges.southIndicesEastToWest,\n    indicesAndEdges.eastIndicesNorthToSouth,\n    indicesAndEdges.northIndicesWestToEast,\n  );\n\n  return this._mesh;\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude,\n) {\n  const width = this._width;\n  const height = this._height;\n\n  const structure = this._structure;\n  const stride = structure.stride;\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n\n  const isMeshCreated = defined(this._mesh);\n  const isLERCEncoding = this._encoding === HeightmapEncoding.LERC;\n  const isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n  if (isInterpolationImpossible) {\n    // We can't interpolate using the buffer because it's LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n\n  let heightSample;\n  if (isMeshCreated) {\n    const buffer = this._mesh.vertices;\n    const encoding = this._mesh.encoding;\n    heightSample = interpolateMeshHeight(\n      buffer,\n      encoding,\n      heightOffset,\n      heightScale,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude,\n    );\n  } else {\n    heightSample = interpolateHeight(\n      this._buffer,\n      elementsPerHeight,\n      elementMultiplier,\n      stride,\n      isBigEndian,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude,\n    );\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if the mesh is unavailable.\n */\nHeightmapTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const meshData = this._mesh;\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  const width = this._width;\n  const height = this._height;\n  const structure = this._structure;\n  const stride = structure.stride;\n\n  const heights = new this._bufferType(width * height * stride);\n\n  const buffer = meshData.vertices;\n  const encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n  const sourceRectangle = tilingScheme.tileXYToRectangle(\n    thisX,\n    thisY,\n    thisLevel,\n  );\n  const destinationRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel,\n  );\n\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n\n  const divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (let j = 0; j < height; ++j) {\n    const latitude = CesiumMath.lerp(\n      destinationRectangle.north,\n      destinationRectangle.south,\n      j / (height - 1),\n    );\n    for (let i = 0; i < width; ++i) {\n      const longitude = CesiumMath.lerp(\n        destinationRectangle.west,\n        destinationRectangle.east,\n        i / (width - 1),\n      );\n      let heightSample = interpolateMeshHeight(\n        buffer,\n        encoding,\n        heightOffset,\n        heightScale,\n        sourceRectangle,\n        width,\n        height,\n        longitude,\n        latitude,\n      );\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample =\n        heightSample < structure.lowestEncodedHeight\n          ? structure.lowestEncodedHeight\n          : heightSample;\n      heightSample =\n        heightSample > structure.highestEncodedHeight\n          ? structure.highestEncodedHeight\n          : heightSample;\n\n      setHeight(\n        heights,\n        elementsPerHeight,\n        elementMultiplier,\n        divisor,\n        stride,\n        isBigEndian,\n        j * width + i,\n        heightSample,\n      );\n    }\n  }\n\n  return Promise.resolve(\n    new HeightmapTerrainData({\n      buffer: heights,\n      width: width,\n      height: height,\n      childTileMask: 0,\n      structure: this._structure,\n      createdByUpsampling: true,\n    }),\n  );\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(\n  sourceHeights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude,\n) {\n  const fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  const southwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + westInteger,\n  );\n  const southeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + eastInteger,\n  );\n  const northwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + westInteger,\n  );\n  const northeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + eastInteger,\n  );\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight,\n  );\n}\n\nfunction interpolateMeshHeight(\n  buffer,\n  encoding,\n  heightOffset,\n  heightScale,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude,\n) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  const fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  const southwestHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  const southeastHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n  const northwestHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  const northeastHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight,\n  );\n}\n\nfunction triangleInterpolateHeight(\n  dX,\n  dY,\n  southwestHeight,\n  southeastHeight,\n  northwestHeight,\n  northeastHeight,\n) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return (\n      southwestHeight +\n      dX * (southeastHeight - southwestHeight) +\n      dY * (northeastHeight - southeastHeight)\n    );\n  }\n\n  // Upper left triangle\n  return (\n    southwestHeight +\n    dX * (northeastHeight - northwestHeight) +\n    dY * (northwestHeight - southwestHeight)\n  );\n}\n\nfunction getHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  index,\n) {\n  index *= stride;\n\n  let height = 0;\n  let i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  divisor,\n  stride,\n  isBigEndian,\n  index,\n  height,\n) {\n  index *= stride;\n\n  let i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\nexport default HeightmapTerrainData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}