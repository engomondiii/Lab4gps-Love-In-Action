{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RequestErrorEvent from \"../Core/RequestErrorEvent.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\n\n/**\n * @typedef {object} TileMapServiceImageryProvider.ConstructorOptions\n *\n * Initialization options for the TileMapServiceImageryProvider constructor\n *\n * @property {string} [fileExtension='png'] The file extension for images on the server.\n * @property {Credit|string} [credit=''] A credit for the data source, which is displayed on the canvas.\n * @property {number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {TilingScheme} [tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}\n * is used.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {number} [tileWidth=256] Pixel width of image tiles.\n * @property {number} [tileHeight=256] Pixel height of image tiles.\n * @property {boolean} [flipXY] Older versions of gdal2tiles.py flipped X and Y values in tilemapresource.xml.\n * @property {TileDiscardPolicy} [tileDiscardPolicy] A policy for discarding tile images according to some criteria\n * Specifying this option will do the same, allowing for loading of these incorrect tilesets.\n */\n\n/**\n * <div class=\"notice\">\n * To construct a TileMapServiceImageryProvider, call {@link TileMapServiceImageryProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * An imagery provider that provides tiled imagery as generated by\n * {@link http://www.maptiler.org/|MapTiler}, {@link http://www.klokan.cz/projects/gdal2tiles/|GDAL2Tiles}, etc.\n *\n * @alias TileMapServiceImageryProvider\n * @constructor\n * @extends UrlTemplateImageryProvider\n *\n * @param {TileMapServiceImageryProvider.ConstructorOptions} [options] Object describing initialization options\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n * @example\n * const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    \"../images/cesium_maptiler/Cesium_Logo_Color\", {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n */\nfunction TileMapServiceImageryProvider(options) {\n  UrlTemplateImageryProvider.call(this, options);\n}\nTileMapServiceImageryProvider._requestMetadata = async function (options, tmsResource, xmlResource, provider) {\n  // Try to load remaining parameters from XML\n  try {\n    const xml = await xmlResource.fetchXML();\n    return TileMapServiceImageryProvider._metadataSuccess(xml, options, tmsResource, xmlResource, provider);\n  } catch (e) {\n    if (e instanceof RequestErrorEvent) {\n      return TileMapServiceImageryProvider._metadataFailure(options, tmsResource);\n    }\n    throw e;\n  }\n};\n/**\n * Creates a TileMapServiceImageryProvider from the specified url.\n *\n * @param {Resource|String} url Path to image tiles on server.\n * @param {TileMapServiceImageryProvider.ConstructorOptions} [options] Object describing initialization options.\n * @returns {Promise<TileMapServiceImageryProvider>} A promise that resolves to the created TileMapServiceImageryProvider.\n *\n * @example\n * const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    '../images/cesium_maptiler/Cesium_Logo_Color', {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n *\n * @exception {RuntimeError} Unable to find expected tilesets or bbox attributes in tilemapresource.xml\n * @exception {RuntimeError} tilemapresource.xml specifies an unsupported profile attribute\n */\nTileMapServiceImageryProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n  const tmsResource = resource;\n  const xmlResource = resource.getDerivedResource({\n    url: \"tilemapresource.xml\"\n  });\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const metadata = await TileMapServiceImageryProvider._requestMetadata(options, tmsResource, xmlResource);\n  return new TileMapServiceImageryProvider(metadata);\n};\nif (defined(Object.create)) {\n  TileMapServiceImageryProvider.prototype = Object.create(UrlTemplateImageryProvider.prototype);\n  TileMapServiceImageryProvider.prototype.constructor = TileMapServiceImageryProvider;\n}\n\n/**\n * Mutates the properties of a given rectangle so it does not extend outside of the given tiling scheme's rectangle\n * @private\n */\nfunction confineRectangleToTilingScheme(rectangle, tilingScheme) {\n  if (rectangle.west < tilingScheme.rectangle.west) {\n    rectangle.west = tilingScheme.rectangle.west;\n  }\n  if (rectangle.east > tilingScheme.rectangle.east) {\n    rectangle.east = tilingScheme.rectangle.east;\n  }\n  if (rectangle.south < tilingScheme.rectangle.south) {\n    rectangle.south = tilingScheme.rectangle.south;\n  }\n  if (rectangle.north > tilingScheme.rectangle.north) {\n    rectangle.north = tilingScheme.rectangle.north;\n  }\n  return rectangle;\n}\nfunction calculateSafeMinimumDetailLevel(tilingScheme, rectangle, minimumLevel) {\n  // Check the number of tiles at the minimum level.  If it's more than four,\n  // try requesting the lower levels anyway, because starting at the higher minimum\n  // level will cause too many tiles to be downloaded and rendered.\n  const swTile = tilingScheme.positionToTileXY(Rectangle.southwest(rectangle), minimumLevel);\n  const neTile = tilingScheme.positionToTileXY(Rectangle.northeast(rectangle), minimumLevel);\n  const tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);\n  if (tileCount > 4) {\n    return 0;\n  }\n  return minimumLevel;\n}\n\n/**\n * Parses the results of a successful xml request\n * @private\n *\n * @param {Object} xml\n * @param {TileMapServiceImageryProvider.ConstructorOptions} options\n * @param {Resource} tmsResource\n * @param {Resource} xmlResource\n * @returns {UrlTemplateImageryProvider.ConstructorOptions}\n */\nTileMapServiceImageryProvider._metadataSuccess = function (xml, options, tmsResource, xmlResource, provider) {\n  const tileFormatRegex = /tileformat/i;\n  const tileSetRegex = /tileset/i;\n  const tileSetsRegex = /tilesets/i;\n  const bboxRegex = /boundingbox/i;\n  let format, bbox, tilesets;\n  const tilesetsList = []; //list of TileSets\n\n  // Allowing options properties (already copied to that) to override XML values\n\n  // Iterate XML Document nodes for properties\n  const nodeList = xml.childNodes[0].childNodes;\n  for (let i = 0; i < nodeList.length; i++) {\n    if (tileFormatRegex.test(nodeList.item(i).nodeName)) {\n      format = nodeList.item(i);\n    } else if (tileSetsRegex.test(nodeList.item(i).nodeName)) {\n      tilesets = nodeList.item(i); // Node list of TileSets\n      const tileSetNodes = nodeList.item(i).childNodes;\n      // Iterate the nodes to find all TileSets\n      for (let j = 0; j < tileSetNodes.length; j++) {\n        if (tileSetRegex.test(tileSetNodes.item(j).nodeName)) {\n          // Add them to tilesets list\n          tilesetsList.push(tileSetNodes.item(j));\n        }\n      }\n    } else if (bboxRegex.test(nodeList.item(i).nodeName)) {\n      bbox = nodeList.item(i);\n    }\n  }\n  let message;\n  if (!defined(tilesets) || !defined(bbox)) {\n    message = `Unable to find expected tilesets or bbox attributes in ${xmlResource.url}.`;\n    if (defined(provider)) {\n      TileProviderError.reportError(undefined, provider, provider.errorEvent, message);\n    }\n    throw new RuntimeError(message);\n  }\n  const fileExtension = defaultValue(options.fileExtension, format.getAttribute(\"extension\"));\n  const tileWidth = defaultValue(options.tileWidth, parseInt(format.getAttribute(\"width\"), 10));\n  const tileHeight = defaultValue(options.tileHeight, parseInt(format.getAttribute(\"height\"), 10));\n  let minimumLevel = defaultValue(options.minimumLevel, parseInt(tilesetsList[0].getAttribute(\"order\"), 10));\n  const maximumLevel = defaultValue(options.maximumLevel, parseInt(tilesetsList[tilesetsList.length - 1].getAttribute(\"order\"), 10));\n  const tilingSchemeName = tilesets.getAttribute(\"profile\");\n  let tilingScheme = options.tilingScheme;\n  if (!defined(tilingScheme)) {\n    if (tilingSchemeName === \"geodetic\" || tilingSchemeName === \"global-geodetic\") {\n      tilingScheme = new GeographicTilingScheme({\n        ellipsoid: options.ellipsoid\n      });\n    } else if (tilingSchemeName === \"mercator\" || tilingSchemeName === \"global-mercator\") {\n      tilingScheme = new WebMercatorTilingScheme({\n        ellipsoid: options.ellipsoid\n      });\n    } else {\n      message = `${xmlResource.url} specifies an unsupported profile attribute, ${tilingSchemeName}.`;\n      if (defined(provider)) {\n        TileProviderError.reportError(undefined, provider, provider.errorEvent, message);\n      }\n      throw new RuntimeError(message);\n    }\n  }\n\n  // rectangle handling\n  let rectangle = Rectangle.clone(options.rectangle);\n  if (!defined(rectangle)) {\n    let sw;\n    let ne;\n    let swXY;\n    let neXY;\n\n    // In older versions of gdal x and y values were flipped, which is why we check for an option to flip\n    // the values here as well. Unfortunately there is no way to autodetect whether flipping is needed.\n    const flipXY = defaultValue(options.flipXY, false);\n    if (flipXY) {\n      swXY = new Cartesian2(parseFloat(bbox.getAttribute(\"miny\")), parseFloat(bbox.getAttribute(\"minx\")));\n      neXY = new Cartesian2(parseFloat(bbox.getAttribute(\"maxy\")), parseFloat(bbox.getAttribute(\"maxx\")));\n    } else {\n      swXY = new Cartesian2(parseFloat(bbox.getAttribute(\"minx\")), parseFloat(bbox.getAttribute(\"miny\")));\n      neXY = new Cartesian2(parseFloat(bbox.getAttribute(\"maxx\")), parseFloat(bbox.getAttribute(\"maxy\")));\n    }\n\n    // Determine based on the profile attribute if this tileset was generated by gdal2tiles.py, which\n    // uses 'mercator' and 'geodetic' profiles, or by a tool compliant with the TMS standard, which is\n    // 'global-mercator' and 'global-geodetic' profiles. In the gdal2Tiles case, X and Y are always in\n    // geodetic degrees.\n    const isGdal2tiles = tilingSchemeName === \"geodetic\" || tilingSchemeName === \"mercator\";\n    if (tilingScheme.projection instanceof GeographicProjection || isGdal2tiles) {\n      sw = Cartographic.fromDegrees(swXY.x, swXY.y);\n      ne = Cartographic.fromDegrees(neXY.x, neXY.y);\n    } else {\n      const projection = tilingScheme.projection;\n      sw = projection.unproject(swXY);\n      ne = projection.unproject(neXY);\n    }\n    rectangle = new Rectangle(sw.longitude, sw.latitude, ne.longitude, ne.latitude);\n  }\n\n  // The rectangle must not be outside the bounds allowed by the tiling scheme.\n  rectangle = confineRectangleToTilingScheme(rectangle, tilingScheme);\n  // clamp our minimum detail level to something that isn't going to request a ridiculous number of tiles\n  minimumLevel = calculateSafeMinimumDetailLevel(tilingScheme, rectangle, minimumLevel);\n  const templateResource = tmsResource.getDerivedResource({\n    url: `{z}/{x}/{reverseY}.${fileExtension}`\n  });\n  return {\n    url: templateResource,\n    tilingScheme: tilingScheme,\n    rectangle: rectangle,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    tileDiscardPolicy: options.tileDiscardPolicy,\n    credit: options.credit\n  };\n};\n\n/**\n * Handle xml request failure by providing the default values\n * @private\n *\n * @param {TileMapServiceImageryProvider.ConstructorOptions} options\n * @param {Resource} tmsResource\n * @returns {UrlTemplateImageryProvider.ConstructorOptions}\n */\nTileMapServiceImageryProvider._metadataFailure = function (options, tmsResource) {\n  // Can't load XML, still allow options and defaults\n  const fileExtension = defaultValue(options.fileExtension, \"png\");\n  const tileWidth = defaultValue(options.tileWidth, 256);\n  const tileHeight = defaultValue(options.tileHeight, 256);\n  const maximumLevel = options.maximumLevel;\n  const tilingScheme = defined(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme({\n    ellipsoid: options.ellipsoid\n  });\n  let rectangle = defaultValue(options.rectangle, tilingScheme.rectangle);\n  // The rectangle must not be outside the bounds allowed by the tiling scheme.\n  rectangle = confineRectangleToTilingScheme(rectangle, tilingScheme);\n\n  // make sure we use a safe minimum detail level, so we don't request a ridiculous number of tiles\n  const minimumLevel = calculateSafeMinimumDetailLevel(tilingScheme, rectangle, options.minimumLevel);\n  const templateResource = tmsResource.getDerivedResource({\n    url: `{z}/{x}/{reverseY}.${fileExtension}`\n  });\n  return {\n    url: templateResource,\n    tilingScheme: tilingScheme,\n    rectangle: rectangle,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    tileDiscardPolicy: options.tileDiscardPolicy,\n    credit: options.credit\n  };\n};\nexport default TileMapServiceImageryProvider;","map":{"version":3,"names":["Cartesian2","Cartographic","Check","defaultValue","defined","GeographicProjection","GeographicTilingScheme","Rectangle","RequestErrorEvent","Resource","RuntimeError","TileProviderError","WebMercatorTilingScheme","UrlTemplateImageryProvider","TileMapServiceImageryProvider","options","call","_requestMetadata","tmsResource","xmlResource","provider","xml","fetchXML","_metadataSuccess","e","_metadataFailure","fromUrl","url","resource","createIfNeeded","appendForwardSlash","getDerivedResource","EMPTY_OBJECT","metadata","Object","create","prototype","constructor","confineRectangleToTilingScheme","rectangle","tilingScheme","west","east","south","north","calculateSafeMinimumDetailLevel","minimumLevel","swTile","positionToTileXY","southwest","neTile","northeast","tileCount","Math","abs","x","y","tileFormatRegex","tileSetRegex","tileSetsRegex","bboxRegex","format","bbox","tilesets","tilesetsList","nodeList","childNodes","i","length","test","item","nodeName","tileSetNodes","j","push","message","reportError","undefined","errorEvent","fileExtension","getAttribute","tileWidth","parseInt","tileHeight","maximumLevel","tilingSchemeName","ellipsoid","clone","sw","ne","swXY","neXY","flipXY","parseFloat","isGdal2tiles","projection","fromDegrees","unproject","longitude","latitude","templateResource","tileDiscardPolicy","credit"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TileMapServiceImageryProvider.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RequestErrorEvent from \"../Core/RequestErrorEvent.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\n\n/**\n * @typedef {object} TileMapServiceImageryProvider.ConstructorOptions\n *\n * Initialization options for the TileMapServiceImageryProvider constructor\n *\n * @property {string} [fileExtension='png'] The file extension for images on the server.\n * @property {Credit|string} [credit=''] A credit for the data source, which is displayed on the canvas.\n * @property {number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {TilingScheme} [tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}\n * is used.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {number} [tileWidth=256] Pixel width of image tiles.\n * @property {number} [tileHeight=256] Pixel height of image tiles.\n * @property {boolean} [flipXY] Older versions of gdal2tiles.py flipped X and Y values in tilemapresource.xml.\n * @property {TileDiscardPolicy} [tileDiscardPolicy] A policy for discarding tile images according to some criteria\n * Specifying this option will do the same, allowing for loading of these incorrect tilesets.\n */\n\n/**\n * <div class=\"notice\">\n * To construct a TileMapServiceImageryProvider, call {@link TileMapServiceImageryProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * An imagery provider that provides tiled imagery as generated by\n * {@link http://www.maptiler.org/|MapTiler}, {@link http://www.klokan.cz/projects/gdal2tiles/|GDAL2Tiles}, etc.\n *\n * @alias TileMapServiceImageryProvider\n * @constructor\n * @extends UrlTemplateImageryProvider\n *\n * @param {TileMapServiceImageryProvider.ConstructorOptions} [options] Object describing initialization options\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n * @example\n * const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    \"../images/cesium_maptiler/Cesium_Logo_Color\", {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n */\nfunction TileMapServiceImageryProvider(options) {\n  UrlTemplateImageryProvider.call(this, options);\n}\n\nTileMapServiceImageryProvider._requestMetadata = async function (\n  options,\n  tmsResource,\n  xmlResource,\n  provider,\n) {\n  // Try to load remaining parameters from XML\n  try {\n    const xml = await xmlResource.fetchXML();\n    return TileMapServiceImageryProvider._metadataSuccess(\n      xml,\n      options,\n      tmsResource,\n      xmlResource,\n      provider,\n    );\n  } catch (e) {\n    if (e instanceof RequestErrorEvent) {\n      return TileMapServiceImageryProvider._metadataFailure(\n        options,\n        tmsResource,\n      );\n    }\n\n    throw e;\n  }\n};\n/**\n * Creates a TileMapServiceImageryProvider from the specified url.\n *\n * @param {Resource|String} url Path to image tiles on server.\n * @param {TileMapServiceImageryProvider.ConstructorOptions} [options] Object describing initialization options.\n * @returns {Promise<TileMapServiceImageryProvider>} A promise that resolves to the created TileMapServiceImageryProvider.\n *\n * @example\n * const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(\n *    '../images/cesium_maptiler/Cesium_Logo_Color', {\n *      fileExtension: 'png',\n *      maximumLevel: 4,\n *      rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n *\n * @exception {RuntimeError} Unable to find expected tilesets or bbox attributes in tilemapresource.xml\n * @exception {RuntimeError} tilemapresource.xml specifies an unsupported profile attribute\n */\nTileMapServiceImageryProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n\n  const tmsResource = resource;\n  const xmlResource = resource.getDerivedResource({\n    url: \"tilemapresource.xml\",\n  });\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const metadata = await TileMapServiceImageryProvider._requestMetadata(\n    options,\n    tmsResource,\n    xmlResource,\n  );\n\n  return new TileMapServiceImageryProvider(metadata);\n};\n\nif (defined(Object.create)) {\n  TileMapServiceImageryProvider.prototype = Object.create(\n    UrlTemplateImageryProvider.prototype,\n  );\n  TileMapServiceImageryProvider.prototype.constructor =\n    TileMapServiceImageryProvider;\n}\n\n/**\n * Mutates the properties of a given rectangle so it does not extend outside of the given tiling scheme's rectangle\n * @private\n */\nfunction confineRectangleToTilingScheme(rectangle, tilingScheme) {\n  if (rectangle.west < tilingScheme.rectangle.west) {\n    rectangle.west = tilingScheme.rectangle.west;\n  }\n  if (rectangle.east > tilingScheme.rectangle.east) {\n    rectangle.east = tilingScheme.rectangle.east;\n  }\n  if (rectangle.south < tilingScheme.rectangle.south) {\n    rectangle.south = tilingScheme.rectangle.south;\n  }\n  if (rectangle.north > tilingScheme.rectangle.north) {\n    rectangle.north = tilingScheme.rectangle.north;\n  }\n  return rectangle;\n}\n\nfunction calculateSafeMinimumDetailLevel(\n  tilingScheme,\n  rectangle,\n  minimumLevel,\n) {\n  // Check the number of tiles at the minimum level.  If it's more than four,\n  // try requesting the lower levels anyway, because starting at the higher minimum\n  // level will cause too many tiles to be downloaded and rendered.\n  const swTile = tilingScheme.positionToTileXY(\n    Rectangle.southwest(rectangle),\n    minimumLevel,\n  );\n  const neTile = tilingScheme.positionToTileXY(\n    Rectangle.northeast(rectangle),\n    minimumLevel,\n  );\n  const tileCount =\n    (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);\n  if (tileCount > 4) {\n    return 0;\n  }\n  return minimumLevel;\n}\n\n/**\n * Parses the results of a successful xml request\n * @private\n *\n * @param {Object} xml\n * @param {TileMapServiceImageryProvider.ConstructorOptions} options\n * @param {Resource} tmsResource\n * @param {Resource} xmlResource\n * @returns {UrlTemplateImageryProvider.ConstructorOptions}\n */\nTileMapServiceImageryProvider._metadataSuccess = function (\n  xml,\n  options,\n  tmsResource,\n  xmlResource,\n  provider,\n) {\n  const tileFormatRegex = /tileformat/i;\n  const tileSetRegex = /tileset/i;\n  const tileSetsRegex = /tilesets/i;\n  const bboxRegex = /boundingbox/i;\n  let format, bbox, tilesets;\n  const tilesetsList = []; //list of TileSets\n\n  // Allowing options properties (already copied to that) to override XML values\n\n  // Iterate XML Document nodes for properties\n  const nodeList = xml.childNodes[0].childNodes;\n  for (let i = 0; i < nodeList.length; i++) {\n    if (tileFormatRegex.test(nodeList.item(i).nodeName)) {\n      format = nodeList.item(i);\n    } else if (tileSetsRegex.test(nodeList.item(i).nodeName)) {\n      tilesets = nodeList.item(i); // Node list of TileSets\n      const tileSetNodes = nodeList.item(i).childNodes;\n      // Iterate the nodes to find all TileSets\n      for (let j = 0; j < tileSetNodes.length; j++) {\n        if (tileSetRegex.test(tileSetNodes.item(j).nodeName)) {\n          // Add them to tilesets list\n          tilesetsList.push(tileSetNodes.item(j));\n        }\n      }\n    } else if (bboxRegex.test(nodeList.item(i).nodeName)) {\n      bbox = nodeList.item(i);\n    }\n  }\n\n  let message;\n  if (!defined(tilesets) || !defined(bbox)) {\n    message = `Unable to find expected tilesets or bbox attributes in ${xmlResource.url}.`;\n    if (defined(provider)) {\n      TileProviderError.reportError(\n        undefined,\n        provider,\n        provider.errorEvent,\n        message,\n      );\n    }\n\n    throw new RuntimeError(message);\n  }\n\n  const fileExtension = defaultValue(\n    options.fileExtension,\n    format.getAttribute(\"extension\"),\n  );\n  const tileWidth = defaultValue(\n    options.tileWidth,\n    parseInt(format.getAttribute(\"width\"), 10),\n  );\n  const tileHeight = defaultValue(\n    options.tileHeight,\n    parseInt(format.getAttribute(\"height\"), 10),\n  );\n  let minimumLevel = defaultValue(\n    options.minimumLevel,\n    parseInt(tilesetsList[0].getAttribute(\"order\"), 10),\n  );\n  const maximumLevel = defaultValue(\n    options.maximumLevel,\n    parseInt(tilesetsList[tilesetsList.length - 1].getAttribute(\"order\"), 10),\n  );\n  const tilingSchemeName = tilesets.getAttribute(\"profile\");\n  let tilingScheme = options.tilingScheme;\n\n  if (!defined(tilingScheme)) {\n    if (\n      tilingSchemeName === \"geodetic\" ||\n      tilingSchemeName === \"global-geodetic\"\n    ) {\n      tilingScheme = new GeographicTilingScheme({\n        ellipsoid: options.ellipsoid,\n      });\n    } else if (\n      tilingSchemeName === \"mercator\" ||\n      tilingSchemeName === \"global-mercator\"\n    ) {\n      tilingScheme = new WebMercatorTilingScheme({\n        ellipsoid: options.ellipsoid,\n      });\n    } else {\n      message = `${xmlResource.url} specifies an unsupported profile attribute, ${tilingSchemeName}.`;\n      if (defined(provider)) {\n        TileProviderError.reportError(\n          undefined,\n          provider,\n          provider.errorEvent,\n          message,\n        );\n      }\n\n      throw new RuntimeError(message);\n    }\n  }\n\n  // rectangle handling\n  let rectangle = Rectangle.clone(options.rectangle);\n\n  if (!defined(rectangle)) {\n    let sw;\n    let ne;\n    let swXY;\n    let neXY;\n\n    // In older versions of gdal x and y values were flipped, which is why we check for an option to flip\n    // the values here as well. Unfortunately there is no way to autodetect whether flipping is needed.\n    const flipXY = defaultValue(options.flipXY, false);\n    if (flipXY) {\n      swXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"miny\")),\n        parseFloat(bbox.getAttribute(\"minx\")),\n      );\n      neXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"maxy\")),\n        parseFloat(bbox.getAttribute(\"maxx\")),\n      );\n    } else {\n      swXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"minx\")),\n        parseFloat(bbox.getAttribute(\"miny\")),\n      );\n      neXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"maxx\")),\n        parseFloat(bbox.getAttribute(\"maxy\")),\n      );\n    }\n\n    // Determine based on the profile attribute if this tileset was generated by gdal2tiles.py, which\n    // uses 'mercator' and 'geodetic' profiles, or by a tool compliant with the TMS standard, which is\n    // 'global-mercator' and 'global-geodetic' profiles. In the gdal2Tiles case, X and Y are always in\n    // geodetic degrees.\n    const isGdal2tiles =\n      tilingSchemeName === \"geodetic\" || tilingSchemeName === \"mercator\";\n    if (\n      tilingScheme.projection instanceof GeographicProjection ||\n      isGdal2tiles\n    ) {\n      sw = Cartographic.fromDegrees(swXY.x, swXY.y);\n      ne = Cartographic.fromDegrees(neXY.x, neXY.y);\n    } else {\n      const projection = tilingScheme.projection;\n      sw = projection.unproject(swXY);\n      ne = projection.unproject(neXY);\n    }\n\n    rectangle = new Rectangle(\n      sw.longitude,\n      sw.latitude,\n      ne.longitude,\n      ne.latitude,\n    );\n  }\n\n  // The rectangle must not be outside the bounds allowed by the tiling scheme.\n  rectangle = confineRectangleToTilingScheme(rectangle, tilingScheme);\n  // clamp our minimum detail level to something that isn't going to request a ridiculous number of tiles\n  minimumLevel = calculateSafeMinimumDetailLevel(\n    tilingScheme,\n    rectangle,\n    minimumLevel,\n  );\n\n  const templateResource = tmsResource.getDerivedResource({\n    url: `{z}/{x}/{reverseY}.${fileExtension}`,\n  });\n\n  return {\n    url: templateResource,\n    tilingScheme: tilingScheme,\n    rectangle: rectangle,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    tileDiscardPolicy: options.tileDiscardPolicy,\n    credit: options.credit,\n  };\n};\n\n/**\n * Handle xml request failure by providing the default values\n * @private\n *\n * @param {TileMapServiceImageryProvider.ConstructorOptions} options\n * @param {Resource} tmsResource\n * @returns {UrlTemplateImageryProvider.ConstructorOptions}\n */\nTileMapServiceImageryProvider._metadataFailure = function (\n  options,\n  tmsResource,\n) {\n  // Can't load XML, still allow options and defaults\n  const fileExtension = defaultValue(options.fileExtension, \"png\");\n  const tileWidth = defaultValue(options.tileWidth, 256);\n  const tileHeight = defaultValue(options.tileHeight, 256);\n  const maximumLevel = options.maximumLevel;\n  const tilingScheme = defined(options.tilingScheme)\n    ? options.tilingScheme\n    : new WebMercatorTilingScheme({ ellipsoid: options.ellipsoid });\n\n  let rectangle = defaultValue(options.rectangle, tilingScheme.rectangle);\n  // The rectangle must not be outside the bounds allowed by the tiling scheme.\n  rectangle = confineRectangleToTilingScheme(rectangle, tilingScheme);\n\n  // make sure we use a safe minimum detail level, so we don't request a ridiculous number of tiles\n  const minimumLevel = calculateSafeMinimumDetailLevel(\n    tilingScheme,\n    rectangle,\n    options.minimumLevel,\n  );\n\n  const templateResource = tmsResource.getDerivedResource({\n    url: `{z}/{x}/{reverseY}.${fileExtension}`,\n  });\n\n  return {\n    url: templateResource,\n    tilingScheme: tilingScheme,\n    rectangle: rectangle,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    tileDiscardPolicy: options.tileDiscardPolicy,\n    credit: options.credit,\n  };\n};\n\nexport default TileMapServiceImageryProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}