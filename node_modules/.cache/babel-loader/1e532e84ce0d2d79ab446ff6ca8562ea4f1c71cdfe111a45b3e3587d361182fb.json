{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid whose surface is being tiled. Defaults to\n * the default ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);\n  this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);\n}\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    }\n  },\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    }\n  }\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const west = CesiumMath.toDegrees(rectangle.west);\n  const south = CesiumMath.toDegrees(rectangle.south);\n  const east = CesiumMath.toDegrees(rectangle.east);\n  const north = CesiumMath.toDegrees(rectangle.north);\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (x, y, level, result) {\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (x, y, level, result) {\n  const rectangle = this._rectangle;\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n  const xTileWidth = rectangle.width / xTiles;\n  const west = x * xTileWidth + rectangle.west;\n  const east = (x + 1) * xTileWidth + rectangle.west;\n  const yTileHeight = rectangle.height / yTiles;\n  const north = rectangle.north - y * yTileHeight;\n  const south = rectangle.north - (y + 1) * yTileHeight;\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (position, level, result) {\n  const rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n  const xTileWidth = rectangle.width / xTiles;\n  const yTileHeight = rectangle.height / yTiles;\n  let longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n  let xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n  let yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;","map":{"version":3,"names":["Cartesian2","Check","defaultValue","defined","Ellipsoid","GeographicProjection","CesiumMath","Rectangle","GeographicTilingScheme","options","EMPTY_OBJECT","_ellipsoid","ellipsoid","default","_rectangle","rectangle","MAX_VALUE","_projection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","Object","defineProperties","prototype","get","projection","getNumberOfXTilesAtLevel","level","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","result","west","toDegrees","south","east","north","tileXYToNativeRectangle","x","y","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","width","yTileHeight","height","positionToTileXY","position","contains","undefined","longitude","TWO_PI","xTileCoordinate","yTileCoordinate","latitude"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/GeographicTilingScheme.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid whose surface is being tiled. Defaults to\n * the default ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(\n    options.numberOfLevelZeroTilesX,\n    2,\n  );\n  this._numberOfLevelZeroTilesY = defaultValue(\n    options.numberOfLevelZeroTilesY,\n    1,\n  );\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {number} level The level-of-detail.\n * @returns {number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const west = CesiumMath.toDegrees(rectangle.west);\n  const south = CesiumMath.toDegrees(rectangle.south);\n  const east = CesiumMath.toDegrees(rectangle.east);\n  const north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result,\n) {\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {number} x The integer x coordinate of the tile.\n * @param {number} y The integer y coordinate of the tile.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result,\n) {\n  const rectangle = this._rectangle;\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const west = x * xTileWidth + rectangle.west;\n  const east = (x + 1) * xTileWidth + rectangle.west;\n\n  const yTileHeight = rectangle.height / yTiles;\n  const north = rectangle.north - y * yTileHeight;\n  const south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result,\n) {\n  const rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const yTileHeight = rectangle.height / yTiles;\n\n  let longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  let xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  let yTileCoordinate =\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}