{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DoubleEndedPriorityQueue from \"../Core/DoubleEndedPriorityQueue.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport KeyframeNode from \"./KeyframeNode.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport Megatexture from \"./Megatexture.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport SpatialNode from \"./SpatialNode.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\n\n/**\n * Handles tileset traversal, tile requests, and GPU resources. Intended to be\n * private and paired with a {@link VoxelPrimitive}, which has a user-facing API.\n *\n * @alias VoxelTraversal\n * @constructor\n *\n * @param {VoxelPrimitive} primitive\n * @param {Context} context\n * @param {Cartesian3} dimensions\n * @param {MetadataType[]} types\n * @param {MetadataComponentType[]} componentTypes\n * @param {number} keyframeCount\n * @param {number} [maximumTextureMemoryByteLength]\n *\n * @private\n */\nfunction VoxelTraversal(primitive, context, dimensions, types, componentTypes, keyframeCount, maximumTextureMemoryByteLength) {\n  /**\n   * TODO: maybe this shouldn't be stored or passed into update function?\n   * @type {VoxelPrimitive}\n   * @private\n   */\n  this._primitive = primitive;\n\n  /**\n   * @type {Megatexture[]}\n   * @readonly\n   */\n  this.megatextures = new Array(types.length);\n\n  // TODO make sure to split the maximumTextureMemoryByteLength across all the megatextures\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const componentCount = MetadataType.getComponentCount(type);\n    const componentType = componentTypes[i];\n    this.megatextures[i] = new Megatexture(context, dimensions, componentCount, componentType, maximumTextureMemoryByteLength);\n  }\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._simultaneousRequestCount = 0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugPrint = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._frameNumber = 0;\n  const shape = primitive._shape;\n\n  /**\n   * @type {SpatialNode}\n   * @readonly\n   */\n  this.rootNode = new SpatialNode(0, 0, 0, 0, undefined, shape, dimensions);\n\n  /**\n   * @type {DoubleEndedPriorityQueue}\n   * @private\n   */\n  this._priorityQueue = new DoubleEndedPriorityQueue({\n    maximumLength: maximumTileCount,\n    comparator: KeyframeNode.priorityComparator\n  });\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._highPriorityKeyframeNodes = new Array(maximumTileCount);\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._keyframeNodesInMegatexture = new Array(maximumTileCount);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeCount = keyframeCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._sampleCount = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeLocation = 0;\n\n  /**\n   * @type {number[]}\n   * @private\n   */\n  this._binaryTreeKeyframeWeighting = new Array(keyframeCount);\n  const binaryTreeKeyframeWeighting = this._binaryTreeKeyframeWeighting;\n  binaryTreeKeyframeWeighting[0] = 0;\n  binaryTreeKeyframeWeighting[keyframeCount - 1] = 0;\n  binaryTreeWeightingRecursive(binaryTreeKeyframeWeighting, 1, keyframeCount - 2, 0);\n  const internalNodeTexelCount = 9;\n  const internalNodeTextureDimensionX = 2048;\n  const internalNodeTilesPerRow = Math.floor(internalNodeTextureDimensionX / internalNodeTexelCount);\n  const internalNodeTextureDimensionY = Math.ceil(maximumTileCount / internalNodeTilesPerRow);\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.internalNodeTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    flipY: false,\n    width: internalNodeTextureDimensionX,\n    height: internalNodeTextureDimensionY,\n    sampler: new Sampler({\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST\n    })\n  });\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.internalNodeTilesPerRow = internalNodeTilesPerRow;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.internalNodeTexelSizeUv = new Cartesian2(1.0 / internalNodeTextureDimensionX, 1.0 / internalNodeTextureDimensionY);\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Texture}\n   * @readonly\n   */\n  this.leafNodeTexture = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {number}\n   * @readonly\n   */\n  this.leafNodeTilesPerRow = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.leafNodeTexelSizeUv = new Cartesian2();\n}\n\n/**\n * Finds a keyframe node in the traversal\n *\n * @param {number} megatextureIndex\n * @returns {KeyframeNode}\n */\nVoxelTraversal.prototype.findKeyframeNode = function (megatextureIndex) {\n  return this._keyframeNodesInMegatexture.find(function (keyframeNode) {\n    return keyframeNode.megatextureIndex === megatextureIndex;\n  });\n};\nfunction binaryTreeWeightingRecursive(arr, start, end, depth) {\n  if (start > end) {\n    return;\n  }\n  const mid = Math.floor((start + end) / 2);\n  arr[mid] = depth;\n  binaryTreeWeightingRecursive(arr, start, mid - 1, depth + 1);\n  binaryTreeWeightingRecursive(arr, mid + 1, end, depth + 1);\n}\nVoxelTraversal.simultaneousRequestCountMaximum = 50;\n\n/**\n * @param {FrameState} frameState\n * @param {number} keyframeLocation\n * @param {boolean} recomputeBoundingVolumes\n * @param {boolean} pauseUpdate\n */\nVoxelTraversal.prototype.update = function (frameState, keyframeLocation, recomputeBoundingVolumes, pauseUpdate) {\n  const primitive = this._primitive;\n  const context = frameState.context;\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n  const keyframeCount = this._keyframeCount;\n  const levelBlendFactor = primitive._levelBlendFactor;\n  const hasLevelBlendFactor = levelBlendFactor > 0.0;\n  const hasKeyframes = keyframeCount > 1;\n  const sampleCount = (hasLevelBlendFactor ? 2 : 1) * (hasKeyframes ? 2 : 1);\n  this._sampleCount = sampleCount;\n  const useLeafNodes = sampleCount >= 2;\n  if (useLeafNodes && !defined(this.leafNodeTexture)) {\n    const leafNodeTexelCount = 2;\n    const leafNodeTextureDimensionX = 1024;\n    const leafNodeTilesPerRow = Math.floor(leafNodeTextureDimensionX / leafNodeTexelCount);\n    const leafNodeTextureDimensionY = Math.ceil(maximumTileCount / leafNodeTilesPerRow);\n    this.leafNodeTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      flipY: false,\n      width: leafNodeTextureDimensionX,\n      height: leafNodeTextureDimensionY,\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST\n      })\n    });\n    this.leafNodeTexelSizeUv = Cartesian2.fromElements(1.0 / leafNodeTextureDimensionX, 1.0 / leafNodeTextureDimensionY, this.leafNodeTexelSizeUv);\n    this.leafNodeTilesPerRow = leafNodeTilesPerRow;\n  } else if (!useLeafNodes && defined(this.leafNodeTexture)) {\n    this.leafNodeTexture = this.leafNodeTexture.destroy();\n  }\n  this._keyframeLocation = CesiumMath.clamp(keyframeLocation, 0.0, keyframeCount - 1);\n  if (recomputeBoundingVolumes) {\n    recomputeBoundingVolumesRecursive(this, this.rootNode);\n  }\n  if (pauseUpdate) {\n    return;\n  }\n  this._frameNumber = frameState.frameNumber;\n  const timestamp0 = getTimestamp();\n  loadAndUnload(this, frameState);\n  const timestamp1 = getTimestamp();\n  generateOctree(this, sampleCount, levelBlendFactor);\n  const timestamp2 = getTimestamp();\n  if (this._debugPrint) {\n    const loadAndUnloadTimeMs = timestamp1 - timestamp0;\n    const generateOctreeTimeMs = timestamp2 - timestamp1;\n    const totalTimeMs = timestamp2 - timestamp0;\n    printDebugInformation(this, loadAndUnloadTimeMs, generateOctreeTimeMs, totalTimeMs);\n  }\n};\n\n/**\n * Check if a node is renderable.\n * @param {SpatialNode} tile\n * @returns {boolean}\n */\nVoxelTraversal.prototype.isRenderable = function (tile) {\n  return tile.isRenderable(this._frameNumber);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelTraversal#destroy\n */\nVoxelTraversal.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelTraversal#isDestroyed\n *\n * @example\n * voxelTraversal = voxelTraversal && voxelTraversal.destroy();\n */\nVoxelTraversal.prototype.destroy = function () {\n  const megatextures = this.megatextures;\n  const megatextureLength = megatextures.length;\n  for (let i = 0; i < megatextureLength; i++) {\n    megatextures[i] = megatextures[i] && megatextures[i].destroy();\n  }\n  this.internalNodeTexture = this.internalNodeTexture && this.internalNodeTexture.destroy();\n  this.leafNodeTexture = this.leafNodeTexture && this.leafNodeTexture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {SpatialNode} node\n *\n * @private\n */\nfunction recomputeBoundingVolumesRecursive(that, node) {\n  node.computeBoundingVolumes(that._primitive._shape);\n  if (defined(node.children)) {\n    for (let i = 0; i < 8; i++) {\n      const child = node.children[i];\n      recomputeBoundingVolumesRecursive(that, child);\n    }\n  }\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {KeyframeNode} keyframeNode\n *\n * @private\n */\nfunction requestData(that, keyframeNode) {\n  if (that._simultaneousRequestCount >= VoxelTraversal.simultaneousRequestCountMaximum) {\n    return;\n  }\n  const provider = that._primitive._provider;\n  function postRequestSuccess(result) {\n    that._simultaneousRequestCount--;\n    const length = provider.types.length;\n    if (!defined(result)) {\n      keyframeNode.state = KeyframeNode.LoadState.UNAVAILABLE;\n    } else if (result === KeyframeNode.LoadState.FAILED) {\n      keyframeNode.state = KeyframeNode.LoadState.FAILED;\n    } else if (!Array.isArray(result) || result.length !== length) {\n      // TODO should this throw runtime error?\n      keyframeNode.state = KeyframeNode.LoadState.FAILED;\n    } else {\n      const megatextures = that.megatextures;\n      for (let i = 0; i < length; i++) {\n        const {\n          voxelCountPerTile,\n          channelCount\n        } = megatextures[i];\n        const {\n          x,\n          y,\n          z\n        } = voxelCountPerTile;\n        const tileVoxelCount = x * y * z;\n        const data = result[i];\n        const expectedLength = tileVoxelCount * channelCount;\n        if (data.length === expectedLength) {\n          keyframeNode.metadata[i] = data;\n          // State is received only when all metadata requests have been received\n          keyframeNode.state = KeyframeNode.LoadState.RECEIVED;\n        } else {\n          keyframeNode.state = KeyframeNode.LoadState.FAILED;\n          break;\n        }\n      }\n    }\n  }\n  function postRequestFailure() {\n    that._simultaneousRequestCount--;\n    keyframeNode.state = KeyframeNode.LoadState.FAILED;\n  }\n  const {\n    keyframe,\n    spatialNode\n  } = keyframeNode;\n  const promise = provider.requestData({\n    tileLevel: spatialNode.level,\n    tileX: spatialNode.x,\n    tileY: spatialNode.y,\n    tileZ: spatialNode.z,\n    keyframe: keyframe\n  });\n  if (defined(promise)) {\n    that._simultaneousRequestCount++;\n    keyframeNode.state = KeyframeNode.LoadState.RECEIVING;\n    promise.then(postRequestSuccess).catch(postRequestFailure);\n  } else {\n    keyframeNode.state = KeyframeNode.LoadState.FAILED;\n  }\n}\n\n/**\n * @function\n *\n * @param {number} x\n * @returns {number}\n *\n * @private\n */\nfunction mapInfiniteRangeToZeroOne(x) {\n  return x / (1.0 + x);\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction loadAndUnload(that, frameState) {\n  const frameNumber = that._frameNumber;\n  const primitive = that._primitive;\n  const shape = primitive._shape;\n  const targetScreenSpaceError = primitive.screenSpaceError;\n  const priorityQueue = that._priorityQueue;\n  const keyframeCount = that._keyframeCount;\n  const previousKeyframe = CesiumMath.clamp(Math.floor(that._keyframeLocation), 0, keyframeCount - 2);\n  const nextKeyframe = previousKeyframe + 1;\n  const {\n    camera,\n    context,\n    pixelRatio\n  } = frameState;\n  const {\n    positionWC,\n    frustum\n  } = camera;\n  const screenHeight = context.drawingBufferHeight / pixelRatio;\n  const screenSpaceErrorMultiplier = screenHeight / frustum.sseDenominator;\n\n  /**\n   * @ignore\n   * @param {SpatialNode} spatialNode\n   * @param {number} visibilityPlaneMask\n   */\n  function addToQueueRecursive(spatialNode, visibilityPlaneMask) {\n    spatialNode.computeScreenSpaceError(positionWC, screenSpaceErrorMultiplier);\n    visibilityPlaneMask = spatialNode.visibility(frameState, visibilityPlaneMask);\n    if (visibilityPlaneMask === CullingVolume.MASK_OUTSIDE) {\n      return;\n    }\n    spatialNode.visitedFrameNumber = frameNumber;\n\n    // Create keyframe nodes at the playhead.\n    // If they already exist, nothing will be created.\n    if (keyframeCount === 1) {\n      spatialNode.createKeyframeNode(0);\n    } else if (spatialNode.keyframeNodes.length !== keyframeCount) {\n      for (let k = 0; k < keyframeCount; k++) {\n        spatialNode.createKeyframeNode(k);\n      }\n    }\n    const {\n      screenSpaceError,\n      keyframeNodes\n    } = spatialNode;\n    const ssePriority = mapInfiniteRangeToZeroOne(screenSpaceError);\n    let hasLoadedKeyframe = false;\n    for (let i = 0; i < keyframeNodes.length; i++) {\n      const keyframeNode = keyframeNodes[i];\n      keyframeNode.priority = 10.0 * ssePriority + keyframePriority(previousKeyframe, keyframeNode.keyframe, nextKeyframe, that);\n      if (keyframeNode.state !== KeyframeNode.LoadState.UNAVAILABLE && keyframeNode.state !== KeyframeNode.LoadState.FAILED && keyframeNode.priority !== -Number.MAX_VALUE) {\n        priorityQueue.insert(keyframeNode);\n      }\n      if (keyframeNode.state === KeyframeNode.LoadState.LOADED) {\n        hasLoadedKeyframe = true;\n      }\n    }\n    if (screenSpaceError < targetScreenSpaceError || !hasLoadedKeyframe) {\n      // Free up memory\n      spatialNode.children = undefined;\n      return;\n    }\n    if (!defined(spatialNode.children)) {\n      spatialNode.constructChildNodes(shape);\n    }\n    for (let childIndex = 0; childIndex < 8; childIndex++) {\n      const child = spatialNode.children[childIndex];\n      addToQueueRecursive(child, visibilityPlaneMask);\n    }\n  }\n\n  // Add all the nodes to the queue, to sort them by priority.\n  priorityQueue.reset();\n  addToQueueRecursive(that.rootNode, CullingVolume.MASK_INDETERMINATE);\n\n  // Move the nodes from the queue to array of high priority nodes.\n  const highPriorityKeyframeNodes = that._highPriorityKeyframeNodes;\n  let highPriorityKeyframeNodeCount = 0;\n  let highPriorityKeyframeNode;\n  while (priorityQueue.length > 0) {\n    highPriorityKeyframeNode = priorityQueue.removeMaximum();\n    highPriorityKeyframeNode.highPriorityFrameNumber = frameNumber;\n    highPriorityKeyframeNodes[highPriorityKeyframeNodeCount] = highPriorityKeyframeNode;\n    highPriorityKeyframeNodeCount++;\n  }\n\n  // Sort the list of keyframe nodes in the megatexture by priority, so\n  // we can remove the lowest priority nodes if we need space.\n  const keyframeNodesInMegatexture = that._keyframeNodesInMegatexture;\n  // TODO: some of the megatexture state should be stored once, not duplicate for each megatexture\n  const megatexture = that.megatextures[0];\n  const keyframeNodesInMegatextureCount = megatexture.occupiedCount;\n  keyframeNodesInMegatexture.length = keyframeNodesInMegatextureCount;\n  keyframeNodesInMegatexture.sort(function (a, b) {\n    if (a.highPriorityFrameNumber === b.highPriorityFrameNumber) {\n      return b.priority - a.priority;\n    }\n    return b.highPriorityFrameNumber - a.highPriorityFrameNumber;\n  });\n\n  // Add the high priority nodes to the megatexture,\n  // removing existing lower-priority nodes if necessary.\n  let destroyedCount = 0;\n  let addedCount = 0;\n  for (let highPriorityKeyframeNodeIndex = 0; highPriorityKeyframeNodeIndex < highPriorityKeyframeNodeCount; highPriorityKeyframeNodeIndex++) {\n    highPriorityKeyframeNode = highPriorityKeyframeNodes[highPriorityKeyframeNodeIndex];\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.LOADED || highPriorityKeyframeNode.spatialNode === undefined) {\n      // Already loaded, so nothing to do.\n      // Or destroyed when adding a higher priority node\n      continue;\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.UNLOADED) {\n      requestData(that, highPriorityKeyframeNode);\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.RECEIVED) {\n      let addNodeIndex = 0;\n      if (megatexture.isFull()) {\n        // If the megatexture is full, try removing a discardable node with the lowest priority.\n        addNodeIndex = keyframeNodesInMegatextureCount - 1 - destroyedCount;\n        destroyedCount++;\n        const discardNode = keyframeNodesInMegatexture[addNodeIndex];\n        discardNode.spatialNode.destroyKeyframeNode(discardNode, that.megatextures);\n      } else {\n        addNodeIndex = keyframeNodesInMegatextureCount + addedCount;\n        addedCount++;\n      }\n      highPriorityKeyframeNode.spatialNode.addKeyframeNodeToMegatextures(highPriorityKeyframeNode, that.megatextures);\n      keyframeNodesInMegatexture[addNodeIndex] = highPriorityKeyframeNode;\n    }\n  }\n}\n\n/**\n * Compute a priority for a keyframe node.\n *\n * @private\n * @param {number} previousKeyframe\n * @param {number} keyframe\n * @param {number} nextKeyframe\n * @param {VoxelTraversal} traversal\n * @returns {number} The computed priority\n */\nfunction keyframePriority(previousKeyframe, keyframe, nextKeyframe, traversal) {\n  const keyframeDifference = Math.min(Math.abs(keyframe - previousKeyframe), Math.abs(keyframe - nextKeyframe));\n  const maxKeyframeDifference = Math.max(previousKeyframe, traversal._keyframeCount - nextKeyframe - 1, 1);\n  const keyframeFactor = Math.pow(1.0 - keyframeDifference / maxKeyframeDifference, 4.0);\n  const binaryTreeFactor = Math.exp(-traversal._binaryTreeKeyframeWeighting[keyframe]);\n  return CesiumMath.lerp(binaryTreeFactor, keyframeFactor, 0.15 + 0.85 * keyframeFactor);\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n *\n * @private\n */\nfunction printDebugInformation(that, loadAndUnloadTimeMs, generateOctreeTimeMs, totalTimeMs) {\n  const keyframeCount = that._keyframeCount;\n  const rootNode = that.rootNode;\n  const loadStateCount = Object.keys(KeyframeNode.LoadState).length;\n  const loadStatesByKeyframe = new Array(loadStateCount);\n  const loadStateByCount = new Array(loadStateCount);\n  let nodeCountTotal = 0;\n  for (let loadStateIndex = 0; loadStateIndex < loadStateCount; loadStateIndex++) {\n    const keyframeArray = new Array(keyframeCount);\n    loadStatesByKeyframe[loadStateIndex] = keyframeArray;\n    for (let i = 0; i < keyframeCount; i++) {\n      keyframeArray[i] = 0;\n    }\n    loadStateByCount[loadStateIndex] = 0;\n  }\n\n  /**\n   * @ignore\n   * @param {SpatialNode} node\n   */\n  function traverseRecursive(node) {\n    const keyframeNodes = node.keyframeNodes;\n    for (let keyframeIndex = 0; keyframeIndex < keyframeNodes.length; keyframeIndex++) {\n      const keyframeNode = keyframeNodes[keyframeIndex];\n      const keyframe = keyframeNode.keyframe;\n      const state = keyframeNode.state;\n      loadStatesByKeyframe[state][keyframe] += 1;\n      loadStateByCount[state] += 1;\n      nodeCountTotal++;\n    }\n    if (defined(node.children)) {\n      for (let childIndex = 0; childIndex < 8; childIndex++) {\n        const child = node.children[childIndex];\n        traverseRecursive(child);\n      }\n    }\n  }\n  traverseRecursive(rootNode);\n  const loadedKeyframeStatistics = `KEYFRAMES: ${loadStatesByKeyframe[KeyframeNode.LoadState.LOADED]}`;\n  const loadStateStatistics = `UNLOADED: ${loadStateByCount[KeyframeNode.LoadState.UNLOADED]} | ` + `RECEIVING: ${loadStateByCount[KeyframeNode.LoadState.RECEIVING]} | ` + `RECEIVED: ${loadStateByCount[KeyframeNode.LoadState.RECEIVED]} | ` + `LOADED: ${loadStateByCount[KeyframeNode.LoadState.LOADED]} | ` + `FAILED: ${loadStateByCount[KeyframeNode.LoadState.FAILED]} | ` + `UNAVAILABLE: ${loadStateByCount[KeyframeNode.LoadState.UNAVAILABLE]} | ` + `TOTAL: ${nodeCountTotal}`;\n  const loadAndUnloadTimeMsRounded = Math.round(loadAndUnloadTimeMs * 100) / 100;\n  const generateOctreeTimeMsRounded = Math.round(generateOctreeTimeMs * 100) / 100;\n  const totalTimeMsRounded = Math.round(totalTimeMs * 100) / 100;\n  const timerStatistics = `LOAD: ${loadAndUnloadTimeMsRounded} | ` + `OCT: ${generateOctreeTimeMsRounded} | ` + `ALL: ${totalTimeMsRounded}`;\n  console.log(`${loadedKeyframeStatistics} || ${loadStateStatistics} || ${timerStatistics}`);\n}\n\n// GPU Octree Layout\n// (shown as binary tree instead of octree for demonstration purposes)\n//\n// Tree representation:\n//           0\n//          / \\\n//         /   \\\n//        /     \\\n//       1       3\n//      / \\     / \\\n//     L0  2   L3 L4\n//        / \\\n//       L1 L2\n//\n//\n// Array representation:\n// L = leaf index\n// * = index to parent node\n// index:   0_______  1________  2________  3_________\n// array:  [*0, 1, 3, *0, L0, 2, *1 L1, L2, *0, L3, L4]\n//\n// The array is generated from a depth-first traversal. The end result could be an unbalanced tree,\n// so the parent index is stored at each node to make it possible to traverse upwards.\n\nconst GpuOctreeFlag = {\n  // Data is an octree index.\n  INTERNAL: 0,\n  // Data is a leaf node.\n  LEAF: 1,\n  // When leaf data is packed in the octree and there's a node that is forced to\n  // render but has no data of its own (such as when its siblings are renderable but it\n  // is not), signal that it's using its parent's data.\n  PACKED_LEAF_FROM_PARENT: 2\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n * @param {number} sampleCount\n * @param {number} levelBlendFactor\n * @private\n */\nfunction generateOctree(that, sampleCount, levelBlendFactor) {\n  const targetSse = that._primitive._screenSpaceError;\n  const keyframeLocation = that._keyframeLocation;\n  const frameNumber = that._frameNumber;\n  const useLeafNodes = sampleCount >= 2;\n  let internalNodeCount = 0;\n  let leafNodeCount = 0;\n  const internalNodeOctreeData = [];\n  const leafNodeOctreeData = [];\n\n  /**\n   * @ignore\n   * @param {SpatialNode} node\n   * @param {number} childOctreeIndex\n   * @param {number} childEntryIndex\n   * @param {number} parentOctreeIndex\n   * @param {number} parentEntryIndex\n   */\n  function buildOctree(node, childOctreeIndex, childEntryIndex, parentOctreeIndex, parentEntryIndex) {\n    let hasRenderableChildren = false;\n    if (defined(node.children)) {\n      for (let c = 0; c < 8; c++) {\n        const childNode = node.children[c];\n        childNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n        if (childNode.isRenderable(frameNumber)) {\n          hasRenderableChildren = true;\n        }\n      }\n    }\n    if (hasRenderableChildren) {\n      // Point the parent and child octree indexes at each other\n      internalNodeOctreeData[parentEntryIndex] = GpuOctreeFlag.INTERNAL << 16 | childOctreeIndex;\n      internalNodeOctreeData[childEntryIndex] = parentOctreeIndex;\n      internalNodeCount++;\n\n      // Recurse over children\n      parentOctreeIndex = childOctreeIndex;\n      parentEntryIndex = parentOctreeIndex * 9 + 1;\n      for (let cc = 0; cc < 8; cc++) {\n        const child = node.children[cc];\n        childOctreeIndex = internalNodeCount;\n        childEntryIndex = childOctreeIndex * 9 + 0;\n        buildOctree(child, childOctreeIndex, childEntryIndex, parentOctreeIndex, parentEntryIndex + cc);\n      }\n    } else {\n      // Store the leaf node information instead\n      // Recursion stops here because there are no renderable children\n      if (useLeafNodes) {\n        const baseIdx = leafNodeCount * 5;\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n        const parentNode = keyframeNode.spatialNode.parent;\n        const parentKeyframeNode = defined(parentNode) ? parentNode.renderableKeyframeNodePrevious : keyframeNode;\n        const lodLerp = getLodLerp(node, targetSse, levelBlendFactor);\n        const levelDifferenceChild = levelDifference;\n        const levelDifferenceParent = 1;\n        const megatextureIndexChild = keyframeNode.megatextureIndex;\n        const megatextureIndexParent = parentKeyframeNode.megatextureIndex;\n        leafNodeOctreeData[baseIdx + 0] = lodLerp;\n        leafNodeOctreeData[baseIdx + 1] = levelDifferenceChild;\n        leafNodeOctreeData[baseIdx + 2] = levelDifferenceParent;\n        leafNodeOctreeData[baseIdx + 3] = megatextureIndexChild;\n        leafNodeOctreeData[baseIdx + 4] = megatextureIndexParent;\n        internalNodeOctreeData[parentEntryIndex] = GpuOctreeFlag.LEAF << 16 | leafNodeCount;\n      } else {\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n        const flag = levelDifference === 0 ? GpuOctreeFlag.LEAF : GpuOctreeFlag.PACKED_LEAF_FROM_PARENT;\n        internalNodeOctreeData[parentEntryIndex] = flag << 16 | keyframeNode.megatextureIndex;\n      }\n      leafNodeCount++;\n    }\n  }\n  const rootNode = that.rootNode;\n  rootNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n  if (rootNode.isRenderable(frameNumber)) {\n    buildOctree(rootNode, 0, 0, 0, 0);\n  }\n  copyToInternalNodeTexture(internalNodeOctreeData, 9, that.internalNodeTilesPerRow, that.internalNodeTexture);\n  if (useLeafNodes) {\n    copyToLeafNodeTexture(leafNodeOctreeData, 2, that.leafNodeTilesPerRow, that.leafNodeTexture);\n  }\n}\n\n/**\n * Compute an interpolation factor between a node and its parent\n * @param {SpatialNode} node\n * @param {number} targetSse\n * @param {number} levelBlendFactor\n * @returns {number}\n * @private\n */\nfunction getLodLerp(node, targetSse, levelBlendFactor) {\n  if (node.parent === undefined) {\n    return 0.0;\n  }\n  const sse = node.screenSpaceError;\n  const parentSse = node.parent.screenSpaceError;\n  const lodLerp = (targetSse - sse) / (parentSse - sse);\n  const blended = (lodLerp + levelBlendFactor - 1.0) / levelBlendFactor;\n  return CesiumMath.clamp(blended, 0.0, 1.0);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToInternalNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const tileCount = Math.ceil(data.length / texelsPerTile);\n  const copyWidth = Math.max(1, texelsPerTile * Math.min(tileCount, tilesPerRow));\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let i = 0; i < data.length; i++) {\n    const val = data[i];\n    const startIndex = i * channelCount;\n    for (let j = 0; j < channelCount; j++) {\n      textureData[startIndex + j] = val >>> j * 8 & 0xff;\n    }\n  }\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight\n  };\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0\n  };\n  texture.copyFrom(copyOptions);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToLeafNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const datasPerTile = 5;\n  const tileCount = Math.ceil(data.length / datasPerTile);\n  const copyWidth = Math.max(1, texelsPerTile * Math.min(tileCount, tilesPerRow));\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let tileIndex = 0; tileIndex < tileCount; tileIndex++) {\n    const timeLerp = data[tileIndex * datasPerTile + 0];\n    const previousKeyframeLevelsAbove = data[tileIndex * datasPerTile + 1];\n    const nextKeyframeLevelsAbove = data[tileIndex * datasPerTile + 2];\n    const previousKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 3];\n    const nextKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 4];\n    const timeLerpCompressed = CesiumMath.clamp(Math.floor(65536 * timeLerp), 0, 65535);\n    textureData[tileIndex * 8 + 0] = timeLerpCompressed >>> 0 & 0xff;\n    textureData[tileIndex * 8 + 1] = timeLerpCompressed >>> 8 & 0xff;\n    textureData[tileIndex * 8 + 2] = previousKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 3] = nextKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 4] = previousKeyframeMegatextureIndex >>> 0 & 0xff;\n    textureData[tileIndex * 8 + 5] = previousKeyframeMegatextureIndex >>> 8 & 0xff;\n    textureData[tileIndex * 8 + 6] = nextKeyframeMegatextureIndex >>> 0 & 0xff;\n    textureData[tileIndex * 8 + 7] = nextKeyframeMegatextureIndex >>> 8 & 0xff;\n  }\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight\n  };\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0\n  };\n  texture.copyFrom(copyOptions);\n}\n\n/**\n * @param {number} tileCount\n * @param {Cartesian3} dimensions\n * @param {MetadataType[]} types\n * @param {MetadataComponentType[]} componentTypes\n */\nVoxelTraversal.getApproximateTextureMemoryByteLength = function (tileCount, dimensions, types, componentTypes) {\n  let textureMemoryByteLength = 0;\n  const length = types.length;\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    const componentType = componentTypes[i];\n    const componentCount = MetadataType.getComponentCount(type);\n    textureMemoryByteLength += Megatexture.getApproximateTextureMemoryByteLength(tileCount, dimensions, componentCount, componentType);\n  }\n  return textureMemoryByteLength;\n};\nexport default VoxelTraversal;","map":{"version":3,"names":["Cartesian2","CesiumMath","CullingVolume","defined","destroyObject","DoubleEndedPriorityQueue","getTimestamp","KeyframeNode","MetadataType","Megatexture","PixelFormat","PixelDatatype","Sampler","SpatialNode","Texture","TextureMagnificationFilter","TextureMinificationFilter","VoxelTraversal","primitive","context","dimensions","types","componentTypes","keyframeCount","maximumTextureMemoryByteLength","_primitive","megatextures","Array","length","i","type","componentCount","getComponentCount","componentType","maximumTileCount","_simultaneousRequestCount","_debugPrint","_frameNumber","shape","_shape","rootNode","undefined","_priorityQueue","maximumLength","comparator","priorityComparator","_highPriorityKeyframeNodes","_keyframeNodesInMegatexture","_keyframeCount","_sampleCount","_keyframeLocation","_binaryTreeKeyframeWeighting","binaryTreeKeyframeWeighting","binaryTreeWeightingRecursive","internalNodeTexelCount","internalNodeTextureDimensionX","internalNodeTilesPerRow","Math","floor","internalNodeTextureDimensionY","ceil","internalNodeTexture","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","flipY","width","height","sampler","minificationFilter","NEAREST","magnificationFilter","internalNodeTexelSizeUv","leafNodeTexture","leafNodeTilesPerRow","leafNodeTexelSizeUv","prototype","findKeyframeNode","megatextureIndex","find","keyframeNode","arr","start","end","depth","mid","simultaneousRequestCountMaximum","update","frameState","keyframeLocation","recomputeBoundingVolumes","pauseUpdate","levelBlendFactor","_levelBlendFactor","hasLevelBlendFactor","hasKeyframes","sampleCount","useLeafNodes","leafNodeTexelCount","leafNodeTextureDimensionX","leafNodeTextureDimensionY","fromElements","destroy","clamp","recomputeBoundingVolumesRecursive","frameNumber","timestamp0","loadAndUnload","timestamp1","generateOctree","timestamp2","loadAndUnloadTimeMs","generateOctreeTimeMs","totalTimeMs","printDebugInformation","isRenderable","tile","isDestroyed","megatextureLength","that","node","computeBoundingVolumes","children","child","requestData","provider","_provider","postRequestSuccess","result","state","LoadState","UNAVAILABLE","FAILED","isArray","voxelCountPerTile","channelCount","x","y","z","tileVoxelCount","data","expectedLength","metadata","RECEIVED","postRequestFailure","keyframe","spatialNode","promise","tileLevel","level","tileX","tileY","tileZ","RECEIVING","then","catch","mapInfiniteRangeToZeroOne","targetScreenSpaceError","screenSpaceError","priorityQueue","previousKeyframe","nextKeyframe","camera","pixelRatio","positionWC","frustum","screenHeight","drawingBufferHeight","screenSpaceErrorMultiplier","sseDenominator","addToQueueRecursive","visibilityPlaneMask","computeScreenSpaceError","visibility","MASK_OUTSIDE","visitedFrameNumber","createKeyframeNode","keyframeNodes","k","ssePriority","hasLoadedKeyframe","priority","keyframePriority","Number","MAX_VALUE","insert","LOADED","constructChildNodes","childIndex","reset","MASK_INDETERMINATE","highPriorityKeyframeNodes","highPriorityKeyframeNodeCount","highPriorityKeyframeNode","removeMaximum","highPriorityFrameNumber","keyframeNodesInMegatexture","megatexture","keyframeNodesInMegatextureCount","occupiedCount","sort","a","b","destroyedCount","addedCount","highPriorityKeyframeNodeIndex","UNLOADED","addNodeIndex","isFull","discardNode","destroyKeyframeNode","addKeyframeNodeToMegatextures","traversal","keyframeDifference","min","abs","maxKeyframeDifference","max","keyframeFactor","pow","binaryTreeFactor","exp","lerp","loadStateCount","Object","keys","loadStatesByKeyframe","loadStateByCount","nodeCountTotal","loadStateIndex","keyframeArray","traverseRecursive","keyframeIndex","loadedKeyframeStatistics","loadStateStatistics","loadAndUnloadTimeMsRounded","round","generateOctreeTimeMsRounded","totalTimeMsRounded","timerStatistics","console","log","GpuOctreeFlag","INTERNAL","LEAF","PACKED_LEAF_FROM_PARENT","targetSse","_screenSpaceError","internalNodeCount","leafNodeCount","internalNodeOctreeData","leafNodeOctreeData","buildOctree","childOctreeIndex","childEntryIndex","parentOctreeIndex","parentEntryIndex","hasRenderableChildren","c","childNode","computeSurroundingRenderableKeyframeNodes","cc","baseIdx","renderableKeyframeNodePrevious","levelDifference","parentNode","parent","parentKeyframeNode","lodLerp","getLodLerp","levelDifferenceChild","levelDifferenceParent","megatextureIndexChild","megatextureIndexParent","flag","copyToInternalNodeTexture","copyToLeafNodeTexture","sse","parentSse","blended","texelsPerTile","tilesPerRow","texture","componentsLength","tileCount","copyWidth","copyHeight","textureData","Uint8Array","val","startIndex","j","source","arrayBufferView","copyOptions","xOffset","yOffset","copyFrom","datasPerTile","tileIndex","timeLerp","previousKeyframeLevelsAbove","nextKeyframeLevelsAbove","previousKeyframeMegatextureIndex","nextKeyframeMegatextureIndex","timeLerpCompressed","getApproximateTextureMemoryByteLength","textureMemoryByteLength"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelTraversal.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DoubleEndedPriorityQueue from \"../Core/DoubleEndedPriorityQueue.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport KeyframeNode from \"./KeyframeNode.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport Megatexture from \"./Megatexture.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport SpatialNode from \"./SpatialNode.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\n\n/**\n * Handles tileset traversal, tile requests, and GPU resources. Intended to be\n * private and paired with a {@link VoxelPrimitive}, which has a user-facing API.\n *\n * @alias VoxelTraversal\n * @constructor\n *\n * @param {VoxelPrimitive} primitive\n * @param {Context} context\n * @param {Cartesian3} dimensions\n * @param {MetadataType[]} types\n * @param {MetadataComponentType[]} componentTypes\n * @param {number} keyframeCount\n * @param {number} [maximumTextureMemoryByteLength]\n *\n * @private\n */\nfunction VoxelTraversal(\n  primitive,\n  context,\n  dimensions,\n  types,\n  componentTypes,\n  keyframeCount,\n  maximumTextureMemoryByteLength,\n) {\n  /**\n   * TODO: maybe this shouldn't be stored or passed into update function?\n   * @type {VoxelPrimitive}\n   * @private\n   */\n  this._primitive = primitive;\n\n  /**\n   * @type {Megatexture[]}\n   * @readonly\n   */\n  this.megatextures = new Array(types.length);\n\n  // TODO make sure to split the maximumTextureMemoryByteLength across all the megatextures\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const componentCount = MetadataType.getComponentCount(type);\n    const componentType = componentTypes[i];\n\n    this.megatextures[i] = new Megatexture(\n      context,\n      dimensions,\n      componentCount,\n      componentType,\n      maximumTextureMemoryByteLength,\n    );\n  }\n\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._simultaneousRequestCount = 0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugPrint = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._frameNumber = 0;\n\n  const shape = primitive._shape;\n\n  /**\n   * @type {SpatialNode}\n   * @readonly\n   */\n  this.rootNode = new SpatialNode(0, 0, 0, 0, undefined, shape, dimensions);\n\n  /**\n   * @type {DoubleEndedPriorityQueue}\n   * @private\n   */\n  this._priorityQueue = new DoubleEndedPriorityQueue({\n    maximumLength: maximumTileCount,\n    comparator: KeyframeNode.priorityComparator,\n  });\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._highPriorityKeyframeNodes = new Array(maximumTileCount);\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._keyframeNodesInMegatexture = new Array(maximumTileCount);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeCount = keyframeCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._sampleCount = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeLocation = 0;\n\n  /**\n   * @type {number[]}\n   * @private\n   */\n  this._binaryTreeKeyframeWeighting = new Array(keyframeCount);\n\n  const binaryTreeKeyframeWeighting = this._binaryTreeKeyframeWeighting;\n  binaryTreeKeyframeWeighting[0] = 0;\n  binaryTreeKeyframeWeighting[keyframeCount - 1] = 0;\n  binaryTreeWeightingRecursive(\n    binaryTreeKeyframeWeighting,\n    1,\n    keyframeCount - 2,\n    0,\n  );\n\n  const internalNodeTexelCount = 9;\n  const internalNodeTextureDimensionX = 2048;\n  const internalNodeTilesPerRow = Math.floor(\n    internalNodeTextureDimensionX / internalNodeTexelCount,\n  );\n  const internalNodeTextureDimensionY = Math.ceil(\n    maximumTileCount / internalNodeTilesPerRow,\n  );\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.internalNodeTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    flipY: false,\n    width: internalNodeTextureDimensionX,\n    height: internalNodeTextureDimensionY,\n    sampler: new Sampler({\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST,\n    }),\n  });\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.internalNodeTilesPerRow = internalNodeTilesPerRow;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.internalNodeTexelSizeUv = new Cartesian2(\n    1.0 / internalNodeTextureDimensionX,\n    1.0 / internalNodeTextureDimensionY,\n  );\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Texture}\n   * @readonly\n   */\n  this.leafNodeTexture = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {number}\n   * @readonly\n   */\n  this.leafNodeTilesPerRow = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.leafNodeTexelSizeUv = new Cartesian2();\n}\n\n/**\n * Finds a keyframe node in the traversal\n *\n * @param {number} megatextureIndex\n * @returns {KeyframeNode}\n */\nVoxelTraversal.prototype.findKeyframeNode = function (megatextureIndex) {\n  return this._keyframeNodesInMegatexture.find(function (keyframeNode) {\n    return keyframeNode.megatextureIndex === megatextureIndex;\n  });\n};\n\nfunction binaryTreeWeightingRecursive(arr, start, end, depth) {\n  if (start > end) {\n    return;\n  }\n  const mid = Math.floor((start + end) / 2);\n  arr[mid] = depth;\n  binaryTreeWeightingRecursive(arr, start, mid - 1, depth + 1);\n  binaryTreeWeightingRecursive(arr, mid + 1, end, depth + 1);\n}\n\nVoxelTraversal.simultaneousRequestCountMaximum = 50;\n\n/**\n * @param {FrameState} frameState\n * @param {number} keyframeLocation\n * @param {boolean} recomputeBoundingVolumes\n * @param {boolean} pauseUpdate\n */\nVoxelTraversal.prototype.update = function (\n  frameState,\n  keyframeLocation,\n  recomputeBoundingVolumes,\n  pauseUpdate,\n) {\n  const primitive = this._primitive;\n  const context = frameState.context;\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n  const keyframeCount = this._keyframeCount;\n\n  const levelBlendFactor = primitive._levelBlendFactor;\n  const hasLevelBlendFactor = levelBlendFactor > 0.0;\n  const hasKeyframes = keyframeCount > 1;\n  const sampleCount = (hasLevelBlendFactor ? 2 : 1) * (hasKeyframes ? 2 : 1);\n  this._sampleCount = sampleCount;\n\n  const useLeafNodes = sampleCount >= 2;\n  if (useLeafNodes && !defined(this.leafNodeTexture)) {\n    const leafNodeTexelCount = 2;\n    const leafNodeTextureDimensionX = 1024;\n    const leafNodeTilesPerRow = Math.floor(\n      leafNodeTextureDimensionX / leafNodeTexelCount,\n    );\n    const leafNodeTextureDimensionY = Math.ceil(\n      maximumTileCount / leafNodeTilesPerRow,\n    );\n\n    this.leafNodeTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      flipY: false,\n      width: leafNodeTextureDimensionX,\n      height: leafNodeTextureDimensionY,\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST,\n      }),\n    });\n    this.leafNodeTexelSizeUv = Cartesian2.fromElements(\n      1.0 / leafNodeTextureDimensionX,\n      1.0 / leafNodeTextureDimensionY,\n      this.leafNodeTexelSizeUv,\n    );\n    this.leafNodeTilesPerRow = leafNodeTilesPerRow;\n  } else if (!useLeafNodes && defined(this.leafNodeTexture)) {\n    this.leafNodeTexture = this.leafNodeTexture.destroy();\n  }\n\n  this._keyframeLocation = CesiumMath.clamp(\n    keyframeLocation,\n    0.0,\n    keyframeCount - 1,\n  );\n\n  if (recomputeBoundingVolumes) {\n    recomputeBoundingVolumesRecursive(this, this.rootNode);\n  }\n\n  if (pauseUpdate) {\n    return;\n  }\n\n  this._frameNumber = frameState.frameNumber;\n  const timestamp0 = getTimestamp();\n  loadAndUnload(this, frameState);\n  const timestamp1 = getTimestamp();\n  generateOctree(this, sampleCount, levelBlendFactor);\n  const timestamp2 = getTimestamp();\n\n  if (this._debugPrint) {\n    const loadAndUnloadTimeMs = timestamp1 - timestamp0;\n    const generateOctreeTimeMs = timestamp2 - timestamp1;\n    const totalTimeMs = timestamp2 - timestamp0;\n    printDebugInformation(\n      this,\n      loadAndUnloadTimeMs,\n      generateOctreeTimeMs,\n      totalTimeMs,\n    );\n  }\n};\n\n/**\n * Check if a node is renderable.\n * @param {SpatialNode} tile\n * @returns {boolean}\n */\nVoxelTraversal.prototype.isRenderable = function (tile) {\n  return tile.isRenderable(this._frameNumber);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelTraversal#destroy\n */\nVoxelTraversal.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelTraversal#isDestroyed\n *\n * @example\n * voxelTraversal = voxelTraversal && voxelTraversal.destroy();\n */\nVoxelTraversal.prototype.destroy = function () {\n  const megatextures = this.megatextures;\n  const megatextureLength = megatextures.length;\n  for (let i = 0; i < megatextureLength; i++) {\n    megatextures[i] = megatextures[i] && megatextures[i].destroy();\n  }\n\n  this.internalNodeTexture =\n    this.internalNodeTexture && this.internalNodeTexture.destroy();\n\n  this.leafNodeTexture = this.leafNodeTexture && this.leafNodeTexture.destroy();\n\n  return destroyObject(this);\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {SpatialNode} node\n *\n * @private\n */\nfunction recomputeBoundingVolumesRecursive(that, node) {\n  node.computeBoundingVolumes(that._primitive._shape);\n  if (defined(node.children)) {\n    for (let i = 0; i < 8; i++) {\n      const child = node.children[i];\n      recomputeBoundingVolumesRecursive(that, child);\n    }\n  }\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {KeyframeNode} keyframeNode\n *\n * @private\n */\nfunction requestData(that, keyframeNode) {\n  if (\n    that._simultaneousRequestCount >=\n    VoxelTraversal.simultaneousRequestCountMaximum\n  ) {\n    return;\n  }\n\n  const provider = that._primitive._provider;\n\n  function postRequestSuccess(result) {\n    that._simultaneousRequestCount--;\n    const length = provider.types.length;\n\n    if (!defined(result)) {\n      keyframeNode.state = KeyframeNode.LoadState.UNAVAILABLE;\n    } else if (result === KeyframeNode.LoadState.FAILED) {\n      keyframeNode.state = KeyframeNode.LoadState.FAILED;\n    } else if (!Array.isArray(result) || result.length !== length) {\n      // TODO should this throw runtime error?\n      keyframeNode.state = KeyframeNode.LoadState.FAILED;\n    } else {\n      const megatextures = that.megatextures;\n      for (let i = 0; i < length; i++) {\n        const { voxelCountPerTile, channelCount } = megatextures[i];\n        const { x, y, z } = voxelCountPerTile;\n        const tileVoxelCount = x * y * z;\n\n        const data = result[i];\n        const expectedLength = tileVoxelCount * channelCount;\n        if (data.length === expectedLength) {\n          keyframeNode.metadata[i] = data;\n          // State is received only when all metadata requests have been received\n          keyframeNode.state = KeyframeNode.LoadState.RECEIVED;\n        } else {\n          keyframeNode.state = KeyframeNode.LoadState.FAILED;\n          break;\n        }\n      }\n    }\n  }\n\n  function postRequestFailure() {\n    that._simultaneousRequestCount--;\n    keyframeNode.state = KeyframeNode.LoadState.FAILED;\n  }\n\n  const { keyframe, spatialNode } = keyframeNode;\n  const promise = provider.requestData({\n    tileLevel: spatialNode.level,\n    tileX: spatialNode.x,\n    tileY: spatialNode.y,\n    tileZ: spatialNode.z,\n    keyframe: keyframe,\n  });\n\n  if (defined(promise)) {\n    that._simultaneousRequestCount++;\n    keyframeNode.state = KeyframeNode.LoadState.RECEIVING;\n    promise.then(postRequestSuccess).catch(postRequestFailure);\n  } else {\n    keyframeNode.state = KeyframeNode.LoadState.FAILED;\n  }\n}\n\n/**\n * @function\n *\n * @param {number} x\n * @returns {number}\n *\n * @private\n */\nfunction mapInfiniteRangeToZeroOne(x) {\n  return x / (1.0 + x);\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction loadAndUnload(that, frameState) {\n  const frameNumber = that._frameNumber;\n  const primitive = that._primitive;\n  const shape = primitive._shape;\n  const targetScreenSpaceError = primitive.screenSpaceError;\n  const priorityQueue = that._priorityQueue;\n  const keyframeCount = that._keyframeCount;\n\n  const previousKeyframe = CesiumMath.clamp(\n    Math.floor(that._keyframeLocation),\n    0,\n    keyframeCount - 2,\n  );\n  const nextKeyframe = previousKeyframe + 1;\n\n  const { camera, context, pixelRatio } = frameState;\n  const { positionWC, frustum } = camera;\n  const screenHeight = context.drawingBufferHeight / pixelRatio;\n  const screenSpaceErrorMultiplier = screenHeight / frustum.sseDenominator;\n\n  /**\n   * @ignore\n   * @param {SpatialNode} spatialNode\n   * @param {number} visibilityPlaneMask\n   */\n  function addToQueueRecursive(spatialNode, visibilityPlaneMask) {\n    spatialNode.computeScreenSpaceError(positionWC, screenSpaceErrorMultiplier);\n\n    visibilityPlaneMask = spatialNode.visibility(\n      frameState,\n      visibilityPlaneMask,\n    );\n    if (visibilityPlaneMask === CullingVolume.MASK_OUTSIDE) {\n      return;\n    }\n    spatialNode.visitedFrameNumber = frameNumber;\n\n    // Create keyframe nodes at the playhead.\n    // If they already exist, nothing will be created.\n    if (keyframeCount === 1) {\n      spatialNode.createKeyframeNode(0);\n    } else if (spatialNode.keyframeNodes.length !== keyframeCount) {\n      for (let k = 0; k < keyframeCount; k++) {\n        spatialNode.createKeyframeNode(k);\n      }\n    }\n    const { screenSpaceError, keyframeNodes } = spatialNode;\n    const ssePriority = mapInfiniteRangeToZeroOne(screenSpaceError);\n\n    let hasLoadedKeyframe = false;\n    for (let i = 0; i < keyframeNodes.length; i++) {\n      const keyframeNode = keyframeNodes[i];\n\n      keyframeNode.priority =\n        10.0 * ssePriority +\n        keyframePriority(\n          previousKeyframe,\n          keyframeNode.keyframe,\n          nextKeyframe,\n          that,\n        );\n\n      if (\n        keyframeNode.state !== KeyframeNode.LoadState.UNAVAILABLE &&\n        keyframeNode.state !== KeyframeNode.LoadState.FAILED &&\n        keyframeNode.priority !== -Number.MAX_VALUE\n      ) {\n        priorityQueue.insert(keyframeNode);\n      }\n      if (keyframeNode.state === KeyframeNode.LoadState.LOADED) {\n        hasLoadedKeyframe = true;\n      }\n    }\n\n    if (screenSpaceError < targetScreenSpaceError || !hasLoadedKeyframe) {\n      // Free up memory\n      spatialNode.children = undefined;\n      return;\n    }\n\n    if (!defined(spatialNode.children)) {\n      spatialNode.constructChildNodes(shape);\n    }\n    for (let childIndex = 0; childIndex < 8; childIndex++) {\n      const child = spatialNode.children[childIndex];\n      addToQueueRecursive(child, visibilityPlaneMask);\n    }\n  }\n\n  // Add all the nodes to the queue, to sort them by priority.\n  priorityQueue.reset();\n  addToQueueRecursive(that.rootNode, CullingVolume.MASK_INDETERMINATE);\n\n  // Move the nodes from the queue to array of high priority nodes.\n  const highPriorityKeyframeNodes = that._highPriorityKeyframeNodes;\n  let highPriorityKeyframeNodeCount = 0;\n  let highPriorityKeyframeNode;\n  while (priorityQueue.length > 0) {\n    highPriorityKeyframeNode = priorityQueue.removeMaximum();\n    highPriorityKeyframeNode.highPriorityFrameNumber = frameNumber;\n    highPriorityKeyframeNodes[highPriorityKeyframeNodeCount] =\n      highPriorityKeyframeNode;\n    highPriorityKeyframeNodeCount++;\n  }\n\n  // Sort the list of keyframe nodes in the megatexture by priority, so\n  // we can remove the lowest priority nodes if we need space.\n  const keyframeNodesInMegatexture = that._keyframeNodesInMegatexture;\n  // TODO: some of the megatexture state should be stored once, not duplicate for each megatexture\n  const megatexture = that.megatextures[0];\n  const keyframeNodesInMegatextureCount = megatexture.occupiedCount;\n  keyframeNodesInMegatexture.length = keyframeNodesInMegatextureCount;\n  keyframeNodesInMegatexture.sort(function (a, b) {\n    if (a.highPriorityFrameNumber === b.highPriorityFrameNumber) {\n      return b.priority - a.priority;\n    }\n    return b.highPriorityFrameNumber - a.highPriorityFrameNumber;\n  });\n\n  // Add the high priority nodes to the megatexture,\n  // removing existing lower-priority nodes if necessary.\n  let destroyedCount = 0;\n  let addedCount = 0;\n\n  for (\n    let highPriorityKeyframeNodeIndex = 0;\n    highPriorityKeyframeNodeIndex < highPriorityKeyframeNodeCount;\n    highPriorityKeyframeNodeIndex++\n  ) {\n    highPriorityKeyframeNode =\n      highPriorityKeyframeNodes[highPriorityKeyframeNodeIndex];\n\n    if (\n      highPriorityKeyframeNode.state === KeyframeNode.LoadState.LOADED ||\n      highPriorityKeyframeNode.spatialNode === undefined\n    ) {\n      // Already loaded, so nothing to do.\n      // Or destroyed when adding a higher priority node\n      continue;\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.UNLOADED) {\n      requestData(that, highPriorityKeyframeNode);\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.RECEIVED) {\n      let addNodeIndex = 0;\n      if (megatexture.isFull()) {\n        // If the megatexture is full, try removing a discardable node with the lowest priority.\n        addNodeIndex = keyframeNodesInMegatextureCount - 1 - destroyedCount;\n        destroyedCount++;\n\n        const discardNode = keyframeNodesInMegatexture[addNodeIndex];\n        discardNode.spatialNode.destroyKeyframeNode(\n          discardNode,\n          that.megatextures,\n        );\n      } else {\n        addNodeIndex = keyframeNodesInMegatextureCount + addedCount;\n        addedCount++;\n      }\n      highPriorityKeyframeNode.spatialNode.addKeyframeNodeToMegatextures(\n        highPriorityKeyframeNode,\n        that.megatextures,\n      );\n      keyframeNodesInMegatexture[addNodeIndex] = highPriorityKeyframeNode;\n    }\n  }\n}\n\n/**\n * Compute a priority for a keyframe node.\n *\n * @private\n * @param {number} previousKeyframe\n * @param {number} keyframe\n * @param {number} nextKeyframe\n * @param {VoxelTraversal} traversal\n * @returns {number} The computed priority\n */\nfunction keyframePriority(previousKeyframe, keyframe, nextKeyframe, traversal) {\n  const keyframeDifference = Math.min(\n    Math.abs(keyframe - previousKeyframe),\n    Math.abs(keyframe - nextKeyframe),\n  );\n  const maxKeyframeDifference = Math.max(\n    previousKeyframe,\n    traversal._keyframeCount - nextKeyframe - 1,\n    1,\n  );\n  const keyframeFactor = Math.pow(\n    1.0 - keyframeDifference / maxKeyframeDifference,\n    4.0,\n  );\n  const binaryTreeFactor = Math.exp(\n    -traversal._binaryTreeKeyframeWeighting[keyframe],\n  );\n  return CesiumMath.lerp(\n    binaryTreeFactor,\n    keyframeFactor,\n    0.15 + 0.85 * keyframeFactor,\n  );\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n *\n * @private\n */\nfunction printDebugInformation(\n  that,\n  loadAndUnloadTimeMs,\n  generateOctreeTimeMs,\n  totalTimeMs,\n) {\n  const keyframeCount = that._keyframeCount;\n  const rootNode = that.rootNode;\n\n  const loadStateCount = Object.keys(KeyframeNode.LoadState).length;\n  const loadStatesByKeyframe = new Array(loadStateCount);\n  const loadStateByCount = new Array(loadStateCount);\n  let nodeCountTotal = 0;\n\n  for (\n    let loadStateIndex = 0;\n    loadStateIndex < loadStateCount;\n    loadStateIndex++\n  ) {\n    const keyframeArray = new Array(keyframeCount);\n    loadStatesByKeyframe[loadStateIndex] = keyframeArray;\n    for (let i = 0; i < keyframeCount; i++) {\n      keyframeArray[i] = 0;\n    }\n    loadStateByCount[loadStateIndex] = 0;\n  }\n\n  /**\n   * @ignore\n   * @param {SpatialNode} node\n   */\n  function traverseRecursive(node) {\n    const keyframeNodes = node.keyframeNodes;\n    for (\n      let keyframeIndex = 0;\n      keyframeIndex < keyframeNodes.length;\n      keyframeIndex++\n    ) {\n      const keyframeNode = keyframeNodes[keyframeIndex];\n      const keyframe = keyframeNode.keyframe;\n      const state = keyframeNode.state;\n      loadStatesByKeyframe[state][keyframe] += 1;\n      loadStateByCount[state] += 1;\n      nodeCountTotal++;\n    }\n\n    if (defined(node.children)) {\n      for (let childIndex = 0; childIndex < 8; childIndex++) {\n        const child = node.children[childIndex];\n        traverseRecursive(child);\n      }\n    }\n  }\n  traverseRecursive(rootNode);\n\n  const loadedKeyframeStatistics = `KEYFRAMES: ${\n    loadStatesByKeyframe[KeyframeNode.LoadState.LOADED]\n  }`;\n  const loadStateStatistics =\n    `UNLOADED: ${loadStateByCount[KeyframeNode.LoadState.UNLOADED]} | ` +\n    `RECEIVING: ${loadStateByCount[KeyframeNode.LoadState.RECEIVING]} | ` +\n    `RECEIVED: ${loadStateByCount[KeyframeNode.LoadState.RECEIVED]} | ` +\n    `LOADED: ${loadStateByCount[KeyframeNode.LoadState.LOADED]} | ` +\n    `FAILED: ${loadStateByCount[KeyframeNode.LoadState.FAILED]} | ` +\n    `UNAVAILABLE: ${loadStateByCount[KeyframeNode.LoadState.UNAVAILABLE]} | ` +\n    `TOTAL: ${nodeCountTotal}`;\n\n  const loadAndUnloadTimeMsRounded =\n    Math.round(loadAndUnloadTimeMs * 100) / 100;\n  const generateOctreeTimeMsRounded =\n    Math.round(generateOctreeTimeMs * 100) / 100;\n  const totalTimeMsRounded = Math.round(totalTimeMs * 100) / 100;\n\n  const timerStatistics =\n    `LOAD: ${loadAndUnloadTimeMsRounded} | ` +\n    `OCT: ${generateOctreeTimeMsRounded} | ` +\n    `ALL: ${totalTimeMsRounded}`;\n\n  console.log(\n    `${loadedKeyframeStatistics} || ${loadStateStatistics} || ${timerStatistics}`,\n  );\n}\n\n// GPU Octree Layout\n// (shown as binary tree instead of octree for demonstration purposes)\n//\n// Tree representation:\n//           0\n//          / \\\n//         /   \\\n//        /     \\\n//       1       3\n//      / \\     / \\\n//     L0  2   L3 L4\n//        / \\\n//       L1 L2\n//\n//\n// Array representation:\n// L = leaf index\n// * = index to parent node\n// index:   0_______  1________  2________  3_________\n// array:  [*0, 1, 3, *0, L0, 2, *1 L1, L2, *0, L3, L4]\n//\n// The array is generated from a depth-first traversal. The end result could be an unbalanced tree,\n// so the parent index is stored at each node to make it possible to traverse upwards.\n\nconst GpuOctreeFlag = {\n  // Data is an octree index.\n  INTERNAL: 0,\n  // Data is a leaf node.\n  LEAF: 1,\n  // When leaf data is packed in the octree and there's a node that is forced to\n  // render but has no data of its own (such as when its siblings are renderable but it\n  // is not), signal that it's using its parent's data.\n  PACKED_LEAF_FROM_PARENT: 2,\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n * @param {number} sampleCount\n * @param {number} levelBlendFactor\n * @private\n */\nfunction generateOctree(that, sampleCount, levelBlendFactor) {\n  const targetSse = that._primitive._screenSpaceError;\n  const keyframeLocation = that._keyframeLocation;\n  const frameNumber = that._frameNumber;\n  const useLeafNodes = sampleCount >= 2;\n\n  let internalNodeCount = 0;\n  let leafNodeCount = 0;\n  const internalNodeOctreeData = [];\n  const leafNodeOctreeData = [];\n\n  /**\n   * @ignore\n   * @param {SpatialNode} node\n   * @param {number} childOctreeIndex\n   * @param {number} childEntryIndex\n   * @param {number} parentOctreeIndex\n   * @param {number} parentEntryIndex\n   */\n  function buildOctree(\n    node,\n    childOctreeIndex,\n    childEntryIndex,\n    parentOctreeIndex,\n    parentEntryIndex,\n  ) {\n    let hasRenderableChildren = false;\n    if (defined(node.children)) {\n      for (let c = 0; c < 8; c++) {\n        const childNode = node.children[c];\n        childNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n        if (childNode.isRenderable(frameNumber)) {\n          hasRenderableChildren = true;\n        }\n      }\n    }\n\n    if (hasRenderableChildren) {\n      // Point the parent and child octree indexes at each other\n      internalNodeOctreeData[parentEntryIndex] =\n        (GpuOctreeFlag.INTERNAL << 16) | childOctreeIndex;\n      internalNodeOctreeData[childEntryIndex] = parentOctreeIndex;\n      internalNodeCount++;\n\n      // Recurse over children\n      parentOctreeIndex = childOctreeIndex;\n      parentEntryIndex = parentOctreeIndex * 9 + 1;\n      for (let cc = 0; cc < 8; cc++) {\n        const child = node.children[cc];\n        childOctreeIndex = internalNodeCount;\n        childEntryIndex = childOctreeIndex * 9 + 0;\n        buildOctree(\n          child,\n          childOctreeIndex,\n          childEntryIndex,\n          parentOctreeIndex,\n          parentEntryIndex + cc,\n        );\n      }\n    } else {\n      // Store the leaf node information instead\n      // Recursion stops here because there are no renderable children\n      if (useLeafNodes) {\n        const baseIdx = leafNodeCount * 5;\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n\n        const parentNode = keyframeNode.spatialNode.parent;\n        const parentKeyframeNode = defined(parentNode)\n          ? parentNode.renderableKeyframeNodePrevious\n          : keyframeNode;\n\n        const lodLerp = getLodLerp(node, targetSse, levelBlendFactor);\n        const levelDifferenceChild = levelDifference;\n        const levelDifferenceParent = 1;\n        const megatextureIndexChild = keyframeNode.megatextureIndex;\n        const megatextureIndexParent = parentKeyframeNode.megatextureIndex;\n\n        leafNodeOctreeData[baseIdx + 0] = lodLerp;\n        leafNodeOctreeData[baseIdx + 1] = levelDifferenceChild;\n        leafNodeOctreeData[baseIdx + 2] = levelDifferenceParent;\n        leafNodeOctreeData[baseIdx + 3] = megatextureIndexChild;\n        leafNodeOctreeData[baseIdx + 4] = megatextureIndexParent;\n\n        internalNodeOctreeData[parentEntryIndex] =\n          (GpuOctreeFlag.LEAF << 16) | leafNodeCount;\n      } else {\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n        const flag =\n          levelDifference === 0\n            ? GpuOctreeFlag.LEAF\n            : GpuOctreeFlag.PACKED_LEAF_FROM_PARENT;\n        internalNodeOctreeData[parentEntryIndex] =\n          (flag << 16) | keyframeNode.megatextureIndex;\n      }\n      leafNodeCount++;\n    }\n  }\n\n  const rootNode = that.rootNode;\n  rootNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n  if (rootNode.isRenderable(frameNumber)) {\n    buildOctree(rootNode, 0, 0, 0, 0);\n  }\n\n  copyToInternalNodeTexture(\n    internalNodeOctreeData,\n    9,\n    that.internalNodeTilesPerRow,\n    that.internalNodeTexture,\n  );\n  if (useLeafNodes) {\n    copyToLeafNodeTexture(\n      leafNodeOctreeData,\n      2,\n      that.leafNodeTilesPerRow,\n      that.leafNodeTexture,\n    );\n  }\n}\n\n/**\n * Compute an interpolation factor between a node and its parent\n * @param {SpatialNode} node\n * @param {number} targetSse\n * @param {number} levelBlendFactor\n * @returns {number}\n * @private\n */\nfunction getLodLerp(node, targetSse, levelBlendFactor) {\n  if (node.parent === undefined) {\n    return 0.0;\n  }\n  const sse = node.screenSpaceError;\n  const parentSse = node.parent.screenSpaceError;\n  const lodLerp = (targetSse - sse) / (parentSse - sse);\n  const blended = (lodLerp + levelBlendFactor - 1.0) / levelBlendFactor;\n\n  return CesiumMath.clamp(blended, 0.0, 1.0);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToInternalNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const tileCount = Math.ceil(data.length / texelsPerTile);\n  const copyWidth = Math.max(\n    1,\n    texelsPerTile * Math.min(tileCount, tilesPerRow),\n  );\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let i = 0; i < data.length; i++) {\n    const val = data[i];\n    const startIndex = i * channelCount;\n    for (let j = 0; j < channelCount; j++) {\n      textureData[startIndex + j] = (val >>> (j * 8)) & 0xff;\n    }\n  }\n\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight,\n  };\n\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0,\n  };\n\n  texture.copyFrom(copyOptions);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToLeafNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const datasPerTile = 5;\n  const tileCount = Math.ceil(data.length / datasPerTile);\n  const copyWidth = Math.max(\n    1,\n    texelsPerTile * Math.min(tileCount, tilesPerRow),\n  );\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let tileIndex = 0; tileIndex < tileCount; tileIndex++) {\n    const timeLerp = data[tileIndex * datasPerTile + 0];\n    const previousKeyframeLevelsAbove = data[tileIndex * datasPerTile + 1];\n    const nextKeyframeLevelsAbove = data[tileIndex * datasPerTile + 2];\n    const previousKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 3];\n    const nextKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 4];\n\n    const timeLerpCompressed = CesiumMath.clamp(\n      Math.floor(65536 * timeLerp),\n      0,\n      65535,\n    );\n    textureData[tileIndex * 8 + 0] = (timeLerpCompressed >>> 0) & 0xff;\n    textureData[tileIndex * 8 + 1] = (timeLerpCompressed >>> 8) & 0xff;\n    textureData[tileIndex * 8 + 2] = previousKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 3] = nextKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 4] =\n      (previousKeyframeMegatextureIndex >>> 0) & 0xff;\n    textureData[tileIndex * 8 + 5] =\n      (previousKeyframeMegatextureIndex >>> 8) & 0xff;\n    textureData[tileIndex * 8 + 6] =\n      (nextKeyframeMegatextureIndex >>> 0) & 0xff;\n    textureData[tileIndex * 8 + 7] =\n      (nextKeyframeMegatextureIndex >>> 8) & 0xff;\n  }\n\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight,\n  };\n\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0,\n  };\n\n  texture.copyFrom(copyOptions);\n}\n\n/**\n * @param {number} tileCount\n * @param {Cartesian3} dimensions\n * @param {MetadataType[]} types\n * @param {MetadataComponentType[]} componentTypes\n */\nVoxelTraversal.getApproximateTextureMemoryByteLength = function (\n  tileCount,\n  dimensions,\n  types,\n  componentTypes,\n) {\n  let textureMemoryByteLength = 0;\n\n  const length = types.length;\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    const componentType = componentTypes[i];\n    const componentCount = MetadataType.getComponentCount(type);\n\n    textureMemoryByteLength +=\n      Megatexture.getApproximateTextureMemoryByteLength(\n        tileCount,\n        dimensions,\n        componentCount,\n        componentType,\n      );\n  }\n\n  return textureMemoryByteLength;\n};\n\nexport default VoxelTraversal;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,wBAAwB,MAAM,qCAAqC;AAC1E,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,WAAW,MAAM,wBAAwB;AAChD,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,0BAA0B,MAAM,2CAA2C;AAClF,OAAOC,yBAAyB,MAAM,0CAA0C;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CACrBC,SAAS,EACTC,OAAO,EACPC,UAAU,EACVC,KAAK,EACLC,cAAc,EACdC,aAAa,EACbC,8BAA8B,EAC9B;EACA;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGP,SAAS;;EAE3B;AACF;AACA;AACA;EACE,IAAI,CAACQ,YAAY,GAAG,IAAIC,KAAK,CAACN,KAAK,CAACO,MAAM,CAAC;;EAE3C;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACO,MAAM,EAAEC,CAAC,EAAE,EAAE;IACrC,MAAMC,IAAI,GAAGT,KAAK,CAACQ,CAAC,CAAC;IACrB,MAAME,cAAc,GAAGvB,YAAY,CAACwB,iBAAiB,CAACF,IAAI,CAAC;IAC3D,MAAMG,aAAa,GAAGX,cAAc,CAACO,CAAC,CAAC;IAEvC,IAAI,CAACH,YAAY,CAACG,CAAC,CAAC,GAAG,IAAIpB,WAAW,CACpCU,OAAO,EACPC,UAAU,EACVW,cAAc,EACdE,aAAa,EACbT,8BACF,CAAC;EACH;EAEA,MAAMU,gBAAgB,GAAG,IAAI,CAACR,YAAY,CAAC,CAAC,CAAC,CAACQ,gBAAgB;;EAE9D;AACF;AACA;AACA;EACE,IAAI,CAACC,yBAAyB,GAAG,CAAC;;EAElC;AACF;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,KAAK;;EAExB;AACF;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAG,CAAC;EAErB,MAAMC,KAAK,GAAGpB,SAAS,CAACqB,MAAM;;EAE9B;AACF;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,IAAI3B,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE4B,SAAS,EAAEH,KAAK,EAAElB,UAAU,CAAC;;EAEzE;AACF;AACA;AACA;EACE,IAAI,CAACsB,cAAc,GAAG,IAAIrC,wBAAwB,CAAC;IACjDsC,aAAa,EAAET,gBAAgB;IAC/BU,UAAU,EAAErC,YAAY,CAACsC;EAC3B,CAAC,CAAC;;EAEF;AACF;AACA;AACA;EACE,IAAI,CAACC,0BAA0B,GAAG,IAAInB,KAAK,CAACO,gBAAgB,CAAC;;EAE7D;AACF;AACA;AACA;EACE,IAAI,CAACa,2BAA2B,GAAG,IAAIpB,KAAK,CAACO,gBAAgB,CAAC;;EAE9D;AACF;AACA;AACA;EACE,IAAI,CAACc,cAAc,GAAGzB,aAAa;;EAEnC;AACF;AACA;AACA;EACE,IAAI,CAAC0B,YAAY,GAAGR,SAAS;;EAE7B;AACF;AACA;AACA;EACE,IAAI,CAACS,iBAAiB,GAAG,CAAC;;EAE1B;AACF;AACA;AACA;EACE,IAAI,CAACC,4BAA4B,GAAG,IAAIxB,KAAK,CAACJ,aAAa,CAAC;EAE5D,MAAM6B,2BAA2B,GAAG,IAAI,CAACD,4BAA4B;EACrEC,2BAA2B,CAAC,CAAC,CAAC,GAAG,CAAC;EAClCA,2BAA2B,CAAC7B,aAAa,GAAG,CAAC,CAAC,GAAG,CAAC;EAClD8B,4BAA4B,CAC1BD,2BAA2B,EAC3B,CAAC,EACD7B,aAAa,GAAG,CAAC,EACjB,CACF,CAAC;EAED,MAAM+B,sBAAsB,GAAG,CAAC;EAChC,MAAMC,6BAA6B,GAAG,IAAI;EAC1C,MAAMC,uBAAuB,GAAGC,IAAI,CAACC,KAAK,CACxCH,6BAA6B,GAAGD,sBAClC,CAAC;EACD,MAAMK,6BAA6B,GAAGF,IAAI,CAACG,IAAI,CAC7C1B,gBAAgB,GAAGsB,uBACrB,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACK,mBAAmB,GAAG,IAAI/C,OAAO,CAAC;IACrCK,OAAO,EAAEA,OAAO;IAChB2C,WAAW,EAAEpD,WAAW,CAACqD,IAAI;IAC7BC,aAAa,EAAErD,aAAa,CAACsD,aAAa;IAC1CC,KAAK,EAAE,KAAK;IACZC,KAAK,EAAEZ,6BAA6B;IACpCa,MAAM,EAAET,6BAA6B;IACrCU,OAAO,EAAE,IAAIzD,OAAO,CAAC;MACnB0D,kBAAkB,EAAEtD,yBAAyB,CAACuD,OAAO;MACrDC,mBAAmB,EAAEzD,0BAA0B,CAACwD;IAClD,CAAC;EACH,CAAC,CAAC;;EAEF;AACF;AACA;AACA;EACE,IAAI,CAACf,uBAAuB,GAAGA,uBAAuB;;EAEtD;AACF;AACA;AACA;EACE,IAAI,CAACiB,uBAAuB,GAAG,IAAIzE,UAAU,CAC3C,GAAG,GAAGuD,6BAA6B,EACnC,GAAG,GAAGI,6BACR,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,IAAI,CAACe,eAAe,GAAGjC,SAAS;;EAEhC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACkC,mBAAmB,GAAGlC,SAAS;;EAEpC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACmC,mBAAmB,GAAG,IAAI5E,UAAU,CAAC,CAAC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAiB,cAAc,CAAC4D,SAAS,CAACC,gBAAgB,GAAG,UAAUC,gBAAgB,EAAE;EACtE,OAAO,IAAI,CAAChC,2BAA2B,CAACiC,IAAI,CAAC,UAAUC,YAAY,EAAE;IACnE,OAAOA,YAAY,CAACF,gBAAgB,KAAKA,gBAAgB;EAC3D,CAAC,CAAC;AACJ,CAAC;AAED,SAAS1B,4BAA4BA,CAAC6B,GAAG,EAAEC,KAAK,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAC5D,IAAIF,KAAK,GAAGC,GAAG,EAAE;IACf;EACF;EACA,MAAME,GAAG,GAAG7B,IAAI,CAACC,KAAK,CAAC,CAACyB,KAAK,GAAGC,GAAG,IAAI,CAAC,CAAC;EACzCF,GAAG,CAACI,GAAG,CAAC,GAAGD,KAAK;EAChBhC,4BAA4B,CAAC6B,GAAG,EAAEC,KAAK,EAAEG,GAAG,GAAG,CAAC,EAAED,KAAK,GAAG,CAAC,CAAC;EAC5DhC,4BAA4B,CAAC6B,GAAG,EAAEI,GAAG,GAAG,CAAC,EAAEF,GAAG,EAAEC,KAAK,GAAG,CAAC,CAAC;AAC5D;AAEApE,cAAc,CAACsE,+BAA+B,GAAG,EAAE;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACAtE,cAAc,CAAC4D,SAAS,CAACW,MAAM,GAAG,UAChCC,UAAU,EACVC,gBAAgB,EAChBC,wBAAwB,EACxBC,WAAW,EACX;EACA,MAAM1E,SAAS,GAAG,IAAI,CAACO,UAAU;EACjC,MAAMN,OAAO,GAAGsE,UAAU,CAACtE,OAAO;EAClC,MAAMe,gBAAgB,GAAG,IAAI,CAACR,YAAY,CAAC,CAAC,CAAC,CAACQ,gBAAgB;EAC9D,MAAMX,aAAa,GAAG,IAAI,CAACyB,cAAc;EAEzC,MAAM6C,gBAAgB,GAAG3E,SAAS,CAAC4E,iBAAiB;EACpD,MAAMC,mBAAmB,GAAGF,gBAAgB,GAAG,GAAG;EAClD,MAAMG,YAAY,GAAGzE,aAAa,GAAG,CAAC;EACtC,MAAM0E,WAAW,GAAG,CAACF,mBAAmB,GAAG,CAAC,GAAG,CAAC,KAAKC,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;EAC1E,IAAI,CAAC/C,YAAY,GAAGgD,WAAW;EAE/B,MAAMC,YAAY,GAAGD,WAAW,IAAI,CAAC;EACrC,IAAIC,YAAY,IAAI,CAAC/F,OAAO,CAAC,IAAI,CAACuE,eAAe,CAAC,EAAE;IAClD,MAAMyB,kBAAkB,GAAG,CAAC;IAC5B,MAAMC,yBAAyB,GAAG,IAAI;IACtC,MAAMzB,mBAAmB,GAAGlB,IAAI,CAACC,KAAK,CACpC0C,yBAAyB,GAAGD,kBAC9B,CAAC;IACD,MAAME,yBAAyB,GAAG5C,IAAI,CAACG,IAAI,CACzC1B,gBAAgB,GAAGyC,mBACrB,CAAC;IAED,IAAI,CAACD,eAAe,GAAG,IAAI5D,OAAO,CAAC;MACjCK,OAAO,EAAEA,OAAO;MAChB2C,WAAW,EAAEpD,WAAW,CAACqD,IAAI;MAC7BC,aAAa,EAAErD,aAAa,CAACsD,aAAa;MAC1CC,KAAK,EAAE,KAAK;MACZC,KAAK,EAAEiC,yBAAyB;MAChChC,MAAM,EAAEiC,yBAAyB;MACjChC,OAAO,EAAE,IAAIzD,OAAO,CAAC;QACnB0D,kBAAkB,EAAEtD,yBAAyB,CAACuD,OAAO;QACrDC,mBAAmB,EAAEzD,0BAA0B,CAACwD;MAClD,CAAC;IACH,CAAC,CAAC;IACF,IAAI,CAACK,mBAAmB,GAAG5E,UAAU,CAACsG,YAAY,CAChD,GAAG,GAAGF,yBAAyB,EAC/B,GAAG,GAAGC,yBAAyB,EAC/B,IAAI,CAACzB,mBACP,CAAC;IACD,IAAI,CAACD,mBAAmB,GAAGA,mBAAmB;EAChD,CAAC,MAAM,IAAI,CAACuB,YAAY,IAAI/F,OAAO,CAAC,IAAI,CAACuE,eAAe,CAAC,EAAE;IACzD,IAAI,CAACA,eAAe,GAAG,IAAI,CAACA,eAAe,CAAC6B,OAAO,CAAC,CAAC;EACvD;EAEA,IAAI,CAACrD,iBAAiB,GAAGjD,UAAU,CAACuG,KAAK,CACvCd,gBAAgB,EAChB,GAAG,EACHnE,aAAa,GAAG,CAClB,CAAC;EAED,IAAIoE,wBAAwB,EAAE;IAC5Bc,iCAAiC,CAAC,IAAI,EAAE,IAAI,CAACjE,QAAQ,CAAC;EACxD;EAEA,IAAIoD,WAAW,EAAE;IACf;EACF;EAEA,IAAI,CAACvD,YAAY,GAAGoD,UAAU,CAACiB,WAAW;EAC1C,MAAMC,UAAU,GAAGrG,YAAY,CAAC,CAAC;EACjCsG,aAAa,CAAC,IAAI,EAAEnB,UAAU,CAAC;EAC/B,MAAMoB,UAAU,GAAGvG,YAAY,CAAC,CAAC;EACjCwG,cAAc,CAAC,IAAI,EAAEb,WAAW,EAAEJ,gBAAgB,CAAC;EACnD,MAAMkB,UAAU,GAAGzG,YAAY,CAAC,CAAC;EAEjC,IAAI,IAAI,CAAC8B,WAAW,EAAE;IACpB,MAAM4E,mBAAmB,GAAGH,UAAU,GAAGF,UAAU;IACnD,MAAMM,oBAAoB,GAAGF,UAAU,GAAGF,UAAU;IACpD,MAAMK,WAAW,GAAGH,UAAU,GAAGJ,UAAU;IAC3CQ,qBAAqB,CACnB,IAAI,EACJH,mBAAmB,EACnBC,oBAAoB,EACpBC,WACF,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjG,cAAc,CAAC4D,SAAS,CAACuC,YAAY,GAAG,UAAUC,IAAI,EAAE;EACtD,OAAOA,IAAI,CAACD,YAAY,CAAC,IAAI,CAAC/E,YAAY,CAAC;AAC7C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApB,cAAc,CAAC4D,SAAS,CAACyC,WAAW,GAAG,YAAY;EACjD,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArG,cAAc,CAAC4D,SAAS,CAAC0B,OAAO,GAAG,YAAY;EAC7C,MAAM7E,YAAY,GAAG,IAAI,CAACA,YAAY;EACtC,MAAM6F,iBAAiB,GAAG7F,YAAY,CAACE,MAAM;EAC7C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0F,iBAAiB,EAAE1F,CAAC,EAAE,EAAE;IAC1CH,YAAY,CAACG,CAAC,CAAC,GAAGH,YAAY,CAACG,CAAC,CAAC,IAAIH,YAAY,CAACG,CAAC,CAAC,CAAC0E,OAAO,CAAC,CAAC;EAChE;EAEA,IAAI,CAAC1C,mBAAmB,GACtB,IAAI,CAACA,mBAAmB,IAAI,IAAI,CAACA,mBAAmB,CAAC0C,OAAO,CAAC,CAAC;EAEhE,IAAI,CAAC7B,eAAe,GAAG,IAAI,CAACA,eAAe,IAAI,IAAI,CAACA,eAAe,CAAC6B,OAAO,CAAC,CAAC;EAE7E,OAAOnG,aAAa,CAAC,IAAI,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqG,iCAAiCA,CAACe,IAAI,EAAEC,IAAI,EAAE;EACrDA,IAAI,CAACC,sBAAsB,CAACF,IAAI,CAAC/F,UAAU,CAACc,MAAM,CAAC;EACnD,IAAIpC,OAAO,CAACsH,IAAI,CAACE,QAAQ,CAAC,EAAE;IAC1B,KAAK,IAAI9F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B,MAAM+F,KAAK,GAAGH,IAAI,CAACE,QAAQ,CAAC9F,CAAC,CAAC;MAC9B4E,iCAAiC,CAACe,IAAI,EAAEI,KAAK,CAAC;IAChD;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACL,IAAI,EAAEvC,YAAY,EAAE;EACvC,IACEuC,IAAI,CAACrF,yBAAyB,IAC9BlB,cAAc,CAACsE,+BAA+B,EAC9C;IACA;EACF;EAEA,MAAMuC,QAAQ,GAAGN,IAAI,CAAC/F,UAAU,CAACsG,SAAS;EAE1C,SAASC,kBAAkBA,CAACC,MAAM,EAAE;IAClCT,IAAI,CAACrF,yBAAyB,EAAE;IAChC,MAAMP,MAAM,GAAGkG,QAAQ,CAACzG,KAAK,CAACO,MAAM;IAEpC,IAAI,CAACzB,OAAO,CAAC8H,MAAM,CAAC,EAAE;MACpBhD,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACC,WAAW;IACzD,CAAC,MAAM,IAAIH,MAAM,KAAK1H,YAAY,CAAC4H,SAAS,CAACE,MAAM,EAAE;MACnDpD,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACE,MAAM;IACpD,CAAC,MAAM,IAAI,CAAC1G,KAAK,CAAC2G,OAAO,CAACL,MAAM,CAAC,IAAIA,MAAM,CAACrG,MAAM,KAAKA,MAAM,EAAE;MAC7D;MACAqD,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACE,MAAM;IACpD,CAAC,MAAM;MACL,MAAM3G,YAAY,GAAG8F,IAAI,CAAC9F,YAAY;MACtC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;QAC/B,MAAM;UAAE0G,iBAAiB;UAAEC;QAAa,CAAC,GAAG9G,YAAY,CAACG,CAAC,CAAC;QAC3D,MAAM;UAAE4G,CAAC;UAAEC,CAAC;UAAEC;QAAE,CAAC,GAAGJ,iBAAiB;QACrC,MAAMK,cAAc,GAAGH,CAAC,GAAGC,CAAC,GAAGC,CAAC;QAEhC,MAAME,IAAI,GAAGZ,MAAM,CAACpG,CAAC,CAAC;QACtB,MAAMiH,cAAc,GAAGF,cAAc,GAAGJ,YAAY;QACpD,IAAIK,IAAI,CAACjH,MAAM,KAAKkH,cAAc,EAAE;UAClC7D,YAAY,CAAC8D,QAAQ,CAAClH,CAAC,CAAC,GAAGgH,IAAI;UAC/B;UACA5D,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACa,QAAQ;QACtD,CAAC,MAAM;UACL/D,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACE,MAAM;UAClD;QACF;MACF;IACF;EACF;EAEA,SAASY,kBAAkBA,CAAA,EAAG;IAC5BzB,IAAI,CAACrF,yBAAyB,EAAE;IAChC8C,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACE,MAAM;EACpD;EAEA,MAAM;IAAEa,QAAQ;IAAEC;EAAY,CAAC,GAAGlE,YAAY;EAC9C,MAAMmE,OAAO,GAAGtB,QAAQ,CAACD,WAAW,CAAC;IACnCwB,SAAS,EAAEF,WAAW,CAACG,KAAK;IAC5BC,KAAK,EAAEJ,WAAW,CAACV,CAAC;IACpBe,KAAK,EAAEL,WAAW,CAACT,CAAC;IACpBe,KAAK,EAAEN,WAAW,CAACR,CAAC;IACpBO,QAAQ,EAAEA;EACZ,CAAC,CAAC;EAEF,IAAI/I,OAAO,CAACiJ,OAAO,CAAC,EAAE;IACpB5B,IAAI,CAACrF,yBAAyB,EAAE;IAChC8C,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACuB,SAAS;IACrDN,OAAO,CAACO,IAAI,CAAC3B,kBAAkB,CAAC,CAAC4B,KAAK,CAACX,kBAAkB,CAAC;EAC5D,CAAC,MAAM;IACLhE,YAAY,CAACiD,KAAK,GAAG3H,YAAY,CAAC4H,SAAS,CAACE,MAAM;EACpD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwB,yBAAyBA,CAACpB,CAAC,EAAE;EACpC,OAAOA,CAAC,IAAI,GAAG,GAAGA,CAAC,CAAC;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7B,aAAaA,CAACY,IAAI,EAAE/B,UAAU,EAAE;EACvC,MAAMiB,WAAW,GAAGc,IAAI,CAACnF,YAAY;EACrC,MAAMnB,SAAS,GAAGsG,IAAI,CAAC/F,UAAU;EACjC,MAAMa,KAAK,GAAGpB,SAAS,CAACqB,MAAM;EAC9B,MAAMuH,sBAAsB,GAAG5I,SAAS,CAAC6I,gBAAgB;EACzD,MAAMC,aAAa,GAAGxC,IAAI,CAAC9E,cAAc;EACzC,MAAMnB,aAAa,GAAGiG,IAAI,CAACxE,cAAc;EAEzC,MAAMiH,gBAAgB,GAAGhK,UAAU,CAACuG,KAAK,CACvC/C,IAAI,CAACC,KAAK,CAAC8D,IAAI,CAACtE,iBAAiB,CAAC,EAClC,CAAC,EACD3B,aAAa,GAAG,CAClB,CAAC;EACD,MAAM2I,YAAY,GAAGD,gBAAgB,GAAG,CAAC;EAEzC,MAAM;IAAEE,MAAM;IAAEhJ,OAAO;IAAEiJ;EAAW,CAAC,GAAG3E,UAAU;EAClD,MAAM;IAAE4E,UAAU;IAAEC;EAAQ,CAAC,GAAGH,MAAM;EACtC,MAAMI,YAAY,GAAGpJ,OAAO,CAACqJ,mBAAmB,GAAGJ,UAAU;EAC7D,MAAMK,0BAA0B,GAAGF,YAAY,GAAGD,OAAO,CAACI,cAAc;;EAExE;AACF;AACA;AACA;AACA;EACE,SAASC,mBAAmBA,CAACxB,WAAW,EAAEyB,mBAAmB,EAAE;IAC7DzB,WAAW,CAAC0B,uBAAuB,CAACR,UAAU,EAAEI,0BAA0B,CAAC;IAE3EG,mBAAmB,GAAGzB,WAAW,CAAC2B,UAAU,CAC1CrF,UAAU,EACVmF,mBACF,CAAC;IACD,IAAIA,mBAAmB,KAAK1K,aAAa,CAAC6K,YAAY,EAAE;MACtD;IACF;IACA5B,WAAW,CAAC6B,kBAAkB,GAAGtE,WAAW;;IAE5C;IACA;IACA,IAAInF,aAAa,KAAK,CAAC,EAAE;MACvB4H,WAAW,CAAC8B,kBAAkB,CAAC,CAAC,CAAC;IACnC,CAAC,MAAM,IAAI9B,WAAW,CAAC+B,aAAa,CAACtJ,MAAM,KAAKL,aAAa,EAAE;MAC7D,KAAK,IAAI4J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5J,aAAa,EAAE4J,CAAC,EAAE,EAAE;QACtChC,WAAW,CAAC8B,kBAAkB,CAACE,CAAC,CAAC;MACnC;IACF;IACA,MAAM;MAAEpB,gBAAgB;MAAEmB;IAAc,CAAC,GAAG/B,WAAW;IACvD,MAAMiC,WAAW,GAAGvB,yBAAyB,CAACE,gBAAgB,CAAC;IAE/D,IAAIsB,iBAAiB,GAAG,KAAK;IAC7B,KAAK,IAAIxJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,aAAa,CAACtJ,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC7C,MAAMoD,YAAY,GAAGiG,aAAa,CAACrJ,CAAC,CAAC;MAErCoD,YAAY,CAACqG,QAAQ,GACnB,IAAI,GAAGF,WAAW,GAClBG,gBAAgB,CACdtB,gBAAgB,EAChBhF,YAAY,CAACiE,QAAQ,EACrBgB,YAAY,EACZ1C,IACF,CAAC;MAEH,IACEvC,YAAY,CAACiD,KAAK,KAAK3H,YAAY,CAAC4H,SAAS,CAACC,WAAW,IACzDnD,YAAY,CAACiD,KAAK,KAAK3H,YAAY,CAAC4H,SAAS,CAACE,MAAM,IACpDpD,YAAY,CAACqG,QAAQ,KAAK,CAACE,MAAM,CAACC,SAAS,EAC3C;QACAzB,aAAa,CAAC0B,MAAM,CAACzG,YAAY,CAAC;MACpC;MACA,IAAIA,YAAY,CAACiD,KAAK,KAAK3H,YAAY,CAAC4H,SAAS,CAACwD,MAAM,EAAE;QACxDN,iBAAiB,GAAG,IAAI;MAC1B;IACF;IAEA,IAAItB,gBAAgB,GAAGD,sBAAsB,IAAI,CAACuB,iBAAiB,EAAE;MACnE;MACAlC,WAAW,CAACxB,QAAQ,GAAGlF,SAAS;MAChC;IACF;IAEA,IAAI,CAACtC,OAAO,CAACgJ,WAAW,CAACxB,QAAQ,CAAC,EAAE;MAClCwB,WAAW,CAACyC,mBAAmB,CAACtJ,KAAK,CAAC;IACxC;IACA,KAAK,IAAIuJ,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,CAAC,EAAEA,UAAU,EAAE,EAAE;MACrD,MAAMjE,KAAK,GAAGuB,WAAW,CAACxB,QAAQ,CAACkE,UAAU,CAAC;MAC9ClB,mBAAmB,CAAC/C,KAAK,EAAEgD,mBAAmB,CAAC;IACjD;EACF;;EAEA;EACAZ,aAAa,CAAC8B,KAAK,CAAC,CAAC;EACrBnB,mBAAmB,CAACnD,IAAI,CAAChF,QAAQ,EAAEtC,aAAa,CAAC6L,kBAAkB,CAAC;;EAEpE;EACA,MAAMC,yBAAyB,GAAGxE,IAAI,CAAC1E,0BAA0B;EACjE,IAAImJ,6BAA6B,GAAG,CAAC;EACrC,IAAIC,wBAAwB;EAC5B,OAAOlC,aAAa,CAACpI,MAAM,GAAG,CAAC,EAAE;IAC/BsK,wBAAwB,GAAGlC,aAAa,CAACmC,aAAa,CAAC,CAAC;IACxDD,wBAAwB,CAACE,uBAAuB,GAAG1F,WAAW;IAC9DsF,yBAAyB,CAACC,6BAA6B,CAAC,GACtDC,wBAAwB;IAC1BD,6BAA6B,EAAE;EACjC;;EAEA;EACA;EACA,MAAMI,0BAA0B,GAAG7E,IAAI,CAACzE,2BAA2B;EACnE;EACA,MAAMuJ,WAAW,GAAG9E,IAAI,CAAC9F,YAAY,CAAC,CAAC,CAAC;EACxC,MAAM6K,+BAA+B,GAAGD,WAAW,CAACE,aAAa;EACjEH,0BAA0B,CAACzK,MAAM,GAAG2K,+BAA+B;EACnEF,0BAA0B,CAACI,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;IAC9C,IAAID,CAAC,CAACN,uBAAuB,KAAKO,CAAC,CAACP,uBAAuB,EAAE;MAC3D,OAAOO,CAAC,CAACrB,QAAQ,GAAGoB,CAAC,CAACpB,QAAQ;IAChC;IACA,OAAOqB,CAAC,CAACP,uBAAuB,GAAGM,CAAC,CAACN,uBAAuB;EAC9D,CAAC,CAAC;;EAEF;EACA;EACA,IAAIQ,cAAc,GAAG,CAAC;EACtB,IAAIC,UAAU,GAAG,CAAC;EAElB,KACE,IAAIC,6BAA6B,GAAG,CAAC,EACrCA,6BAA6B,GAAGb,6BAA6B,EAC7Da,6BAA6B,EAAE,EAC/B;IACAZ,wBAAwB,GACtBF,yBAAyB,CAACc,6BAA6B,CAAC;IAE1D,IACEZ,wBAAwB,CAAChE,KAAK,KAAK3H,YAAY,CAAC4H,SAAS,CAACwD,MAAM,IAChEO,wBAAwB,CAAC/C,WAAW,KAAK1G,SAAS,EAClD;MACA;MACA;MACA;IACF;IACA,IAAIyJ,wBAAwB,CAAChE,KAAK,KAAK3H,YAAY,CAAC4H,SAAS,CAAC4E,QAAQ,EAAE;MACtElF,WAAW,CAACL,IAAI,EAAE0E,wBAAwB,CAAC;IAC7C;IACA,IAAIA,wBAAwB,CAAChE,KAAK,KAAK3H,YAAY,CAAC4H,SAAS,CAACa,QAAQ,EAAE;MACtE,IAAIgE,YAAY,GAAG,CAAC;MACpB,IAAIV,WAAW,CAACW,MAAM,CAAC,CAAC,EAAE;QACxB;QACAD,YAAY,GAAGT,+BAA+B,GAAG,CAAC,GAAGK,cAAc;QACnEA,cAAc,EAAE;QAEhB,MAAMM,WAAW,GAAGb,0BAA0B,CAACW,YAAY,CAAC;QAC5DE,WAAW,CAAC/D,WAAW,CAACgE,mBAAmB,CACzCD,WAAW,EACX1F,IAAI,CAAC9F,YACP,CAAC;MACH,CAAC,MAAM;QACLsL,YAAY,GAAGT,+BAA+B,GAAGM,UAAU;QAC3DA,UAAU,EAAE;MACd;MACAX,wBAAwB,CAAC/C,WAAW,CAACiE,6BAA6B,CAChElB,wBAAwB,EACxB1E,IAAI,CAAC9F,YACP,CAAC;MACD2K,0BAA0B,CAACW,YAAY,CAAC,GAAGd,wBAAwB;IACrE;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASX,gBAAgBA,CAACtB,gBAAgB,EAAEf,QAAQ,EAAEgB,YAAY,EAAEmD,SAAS,EAAE;EAC7E,MAAMC,kBAAkB,GAAG7J,IAAI,CAAC8J,GAAG,CACjC9J,IAAI,CAAC+J,GAAG,CAACtE,QAAQ,GAAGe,gBAAgB,CAAC,EACrCxG,IAAI,CAAC+J,GAAG,CAACtE,QAAQ,GAAGgB,YAAY,CAClC,CAAC;EACD,MAAMuD,qBAAqB,GAAGhK,IAAI,CAACiK,GAAG,CACpCzD,gBAAgB,EAChBoD,SAAS,CAACrK,cAAc,GAAGkH,YAAY,GAAG,CAAC,EAC3C,CACF,CAAC;EACD,MAAMyD,cAAc,GAAGlK,IAAI,CAACmK,GAAG,CAC7B,GAAG,GAAGN,kBAAkB,GAAGG,qBAAqB,EAChD,GACF,CAAC;EACD,MAAMI,gBAAgB,GAAGpK,IAAI,CAACqK,GAAG,CAC/B,CAACT,SAAS,CAAClK,4BAA4B,CAAC+F,QAAQ,CAClD,CAAC;EACD,OAAOjJ,UAAU,CAAC8N,IAAI,CACpBF,gBAAgB,EAChBF,cAAc,EACd,IAAI,GAAG,IAAI,GAAGA,cAChB,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASxG,qBAAqBA,CAC5BK,IAAI,EACJR,mBAAmB,EACnBC,oBAAoB,EACpBC,WAAW,EACX;EACA,MAAM3F,aAAa,GAAGiG,IAAI,CAACxE,cAAc;EACzC,MAAMR,QAAQ,GAAGgF,IAAI,CAAChF,QAAQ;EAE9B,MAAMwL,cAAc,GAAGC,MAAM,CAACC,IAAI,CAAC3N,YAAY,CAAC4H,SAAS,CAAC,CAACvG,MAAM;EACjE,MAAMuM,oBAAoB,GAAG,IAAIxM,KAAK,CAACqM,cAAc,CAAC;EACtD,MAAMI,gBAAgB,GAAG,IAAIzM,KAAK,CAACqM,cAAc,CAAC;EAClD,IAAIK,cAAc,GAAG,CAAC;EAEtB,KACE,IAAIC,cAAc,GAAG,CAAC,EACtBA,cAAc,GAAGN,cAAc,EAC/BM,cAAc,EAAE,EAChB;IACA,MAAMC,aAAa,GAAG,IAAI5M,KAAK,CAACJ,aAAa,CAAC;IAC9C4M,oBAAoB,CAACG,cAAc,CAAC,GAAGC,aAAa;IACpD,KAAK,IAAI1M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,aAAa,EAAEM,CAAC,EAAE,EAAE;MACtC0M,aAAa,CAAC1M,CAAC,CAAC,GAAG,CAAC;IACtB;IACAuM,gBAAgB,CAACE,cAAc,CAAC,GAAG,CAAC;EACtC;;EAEA;AACF;AACA;AACA;EACE,SAASE,iBAAiBA,CAAC/G,IAAI,EAAE;IAC/B,MAAMyD,aAAa,GAAGzD,IAAI,CAACyD,aAAa;IACxC,KACE,IAAIuD,aAAa,GAAG,CAAC,EACrBA,aAAa,GAAGvD,aAAa,CAACtJ,MAAM,EACpC6M,aAAa,EAAE,EACf;MACA,MAAMxJ,YAAY,GAAGiG,aAAa,CAACuD,aAAa,CAAC;MACjD,MAAMvF,QAAQ,GAAGjE,YAAY,CAACiE,QAAQ;MACtC,MAAMhB,KAAK,GAAGjD,YAAY,CAACiD,KAAK;MAChCiG,oBAAoB,CAACjG,KAAK,CAAC,CAACgB,QAAQ,CAAC,IAAI,CAAC;MAC1CkF,gBAAgB,CAAClG,KAAK,CAAC,IAAI,CAAC;MAC5BmG,cAAc,EAAE;IAClB;IAEA,IAAIlO,OAAO,CAACsH,IAAI,CAACE,QAAQ,CAAC,EAAE;MAC1B,KAAK,IAAIkE,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,CAAC,EAAEA,UAAU,EAAE,EAAE;QACrD,MAAMjE,KAAK,GAAGH,IAAI,CAACE,QAAQ,CAACkE,UAAU,CAAC;QACvC2C,iBAAiB,CAAC5G,KAAK,CAAC;MAC1B;IACF;EACF;EACA4G,iBAAiB,CAAChM,QAAQ,CAAC;EAE3B,MAAMkM,wBAAwB,GAAG,cAC/BP,oBAAoB,CAAC5N,YAAY,CAAC4H,SAAS,CAACwD,MAAM,CAAC,EACnD;EACF,MAAMgD,mBAAmB,GACvB,aAAaP,gBAAgB,CAAC7N,YAAY,CAAC4H,SAAS,CAAC4E,QAAQ,CAAC,KAAK,GACnE,cAAcqB,gBAAgB,CAAC7N,YAAY,CAAC4H,SAAS,CAACuB,SAAS,CAAC,KAAK,GACrE,aAAa0E,gBAAgB,CAAC7N,YAAY,CAAC4H,SAAS,CAACa,QAAQ,CAAC,KAAK,GACnE,WAAWoF,gBAAgB,CAAC7N,YAAY,CAAC4H,SAAS,CAACwD,MAAM,CAAC,KAAK,GAC/D,WAAWyC,gBAAgB,CAAC7N,YAAY,CAAC4H,SAAS,CAACE,MAAM,CAAC,KAAK,GAC/D,gBAAgB+F,gBAAgB,CAAC7N,YAAY,CAAC4H,SAAS,CAACC,WAAW,CAAC,KAAK,GACzE,UAAUiG,cAAc,EAAE;EAE5B,MAAMO,0BAA0B,GAC9BnL,IAAI,CAACoL,KAAK,CAAC7H,mBAAmB,GAAG,GAAG,CAAC,GAAG,GAAG;EAC7C,MAAM8H,2BAA2B,GAC/BrL,IAAI,CAACoL,KAAK,CAAC5H,oBAAoB,GAAG,GAAG,CAAC,GAAG,GAAG;EAC9C,MAAM8H,kBAAkB,GAAGtL,IAAI,CAACoL,KAAK,CAAC3H,WAAW,GAAG,GAAG,CAAC,GAAG,GAAG;EAE9D,MAAM8H,eAAe,GACnB,SAASJ,0BAA0B,KAAK,GACxC,QAAQE,2BAA2B,KAAK,GACxC,QAAQC,kBAAkB,EAAE;EAE9BE,OAAO,CAACC,GAAG,CACT,GAAGR,wBAAwB,OAAOC,mBAAmB,OAAOK,eAAe,EAC7E,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMG,aAAa,GAAG;EACpB;EACAC,QAAQ,EAAE,CAAC;EACX;EACAC,IAAI,EAAE,CAAC;EACP;EACA;EACA;EACAC,uBAAuB,EAAE;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASxI,cAAcA,CAACU,IAAI,EAAEvB,WAAW,EAAEJ,gBAAgB,EAAE;EAC3D,MAAM0J,SAAS,GAAG/H,IAAI,CAAC/F,UAAU,CAAC+N,iBAAiB;EACnD,MAAM9J,gBAAgB,GAAG8B,IAAI,CAACtE,iBAAiB;EAC/C,MAAMwD,WAAW,GAAGc,IAAI,CAACnF,YAAY;EACrC,MAAM6D,YAAY,GAAGD,WAAW,IAAI,CAAC;EAErC,IAAIwJ,iBAAiB,GAAG,CAAC;EACzB,IAAIC,aAAa,GAAG,CAAC;EACrB,MAAMC,sBAAsB,GAAG,EAAE;EACjC,MAAMC,kBAAkB,GAAG,EAAE;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,WAAWA,CAClBpI,IAAI,EACJqI,gBAAgB,EAChBC,eAAe,EACfC,iBAAiB,EACjBC,gBAAgB,EAChB;IACA,IAAIC,qBAAqB,GAAG,KAAK;IACjC,IAAI/P,OAAO,CAACsH,IAAI,CAACE,QAAQ,CAAC,EAAE;MAC1B,KAAK,IAAIwI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,MAAMC,SAAS,GAAG3I,IAAI,CAACE,QAAQ,CAACwI,CAAC,CAAC;QAClCC,SAAS,CAACC,yCAAyC,CAAC3K,gBAAgB,CAAC;QACrE,IAAI0K,SAAS,CAAChJ,YAAY,CAACV,WAAW,CAAC,EAAE;UACvCwJ,qBAAqB,GAAG,IAAI;QAC9B;MACF;IACF;IAEA,IAAIA,qBAAqB,EAAE;MACzB;MACAP,sBAAsB,CAACM,gBAAgB,CAAC,GACrCd,aAAa,CAACC,QAAQ,IAAI,EAAE,GAAIU,gBAAgB;MACnDH,sBAAsB,CAACI,eAAe,CAAC,GAAGC,iBAAiB;MAC3DP,iBAAiB,EAAE;;MAEnB;MACAO,iBAAiB,GAAGF,gBAAgB;MACpCG,gBAAgB,GAAGD,iBAAiB,GAAG,CAAC,GAAG,CAAC;MAC5C,KAAK,IAAIM,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG,CAAC,EAAEA,EAAE,EAAE,EAAE;QAC7B,MAAM1I,KAAK,GAAGH,IAAI,CAACE,QAAQ,CAAC2I,EAAE,CAAC;QAC/BR,gBAAgB,GAAGL,iBAAiB;QACpCM,eAAe,GAAGD,gBAAgB,GAAG,CAAC,GAAG,CAAC;QAC1CD,WAAW,CACTjI,KAAK,EACLkI,gBAAgB,EAChBC,eAAe,EACfC,iBAAiB,EACjBC,gBAAgB,GAAGK,EACrB,CAAC;MACH;IACF,CAAC,MAAM;MACL;MACA;MACA,IAAIpK,YAAY,EAAE;QAChB,MAAMqK,OAAO,GAAGb,aAAa,GAAG,CAAC;QACjC,MAAMzK,YAAY,GAAGwC,IAAI,CAAC+I,8BAA8B;QACxD,MAAMC,eAAe,GAAGhJ,IAAI,CAAC6B,KAAK,GAAGrE,YAAY,CAACkE,WAAW,CAACG,KAAK;QAEnE,MAAMoH,UAAU,GAAGzL,YAAY,CAACkE,WAAW,CAACwH,MAAM;QAClD,MAAMC,kBAAkB,GAAGzQ,OAAO,CAACuQ,UAAU,CAAC,GAC1CA,UAAU,CAACF,8BAA8B,GACzCvL,YAAY;QAEhB,MAAM4L,OAAO,GAAGC,UAAU,CAACrJ,IAAI,EAAE8H,SAAS,EAAE1J,gBAAgB,CAAC;QAC7D,MAAMkL,oBAAoB,GAAGN,eAAe;QAC5C,MAAMO,qBAAqB,GAAG,CAAC;QAC/B,MAAMC,qBAAqB,GAAGhM,YAAY,CAACF,gBAAgB;QAC3D,MAAMmM,sBAAsB,GAAGN,kBAAkB,CAAC7L,gBAAgB;QAElE6K,kBAAkB,CAACW,OAAO,GAAG,CAAC,CAAC,GAAGM,OAAO;QACzCjB,kBAAkB,CAACW,OAAO,GAAG,CAAC,CAAC,GAAGQ,oBAAoB;QACtDnB,kBAAkB,CAACW,OAAO,GAAG,CAAC,CAAC,GAAGS,qBAAqB;QACvDpB,kBAAkB,CAACW,OAAO,GAAG,CAAC,CAAC,GAAGU,qBAAqB;QACvDrB,kBAAkB,CAACW,OAAO,GAAG,CAAC,CAAC,GAAGW,sBAAsB;QAExDvB,sBAAsB,CAACM,gBAAgB,CAAC,GACrCd,aAAa,CAACE,IAAI,IAAI,EAAE,GAAIK,aAAa;MAC9C,CAAC,MAAM;QACL,MAAMzK,YAAY,GAAGwC,IAAI,CAAC+I,8BAA8B;QACxD,MAAMC,eAAe,GAAGhJ,IAAI,CAAC6B,KAAK,GAAGrE,YAAY,CAACkE,WAAW,CAACG,KAAK;QACnE,MAAM6H,IAAI,GACRV,eAAe,KAAK,CAAC,GACjBtB,aAAa,CAACE,IAAI,GAClBF,aAAa,CAACG,uBAAuB;QAC3CK,sBAAsB,CAACM,gBAAgB,CAAC,GACrCkB,IAAI,IAAI,EAAE,GAAIlM,YAAY,CAACF,gBAAgB;MAChD;MACA2K,aAAa,EAAE;IACjB;EACF;EAEA,MAAMlN,QAAQ,GAAGgF,IAAI,CAAChF,QAAQ;EAC9BA,QAAQ,CAAC6N,yCAAyC,CAAC3K,gBAAgB,CAAC;EACpE,IAAIlD,QAAQ,CAAC4E,YAAY,CAACV,WAAW,CAAC,EAAE;IACtCmJ,WAAW,CAACrN,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACnC;EAEA4O,yBAAyB,CACvBzB,sBAAsB,EACtB,CAAC,EACDnI,IAAI,CAAChE,uBAAuB,EAC5BgE,IAAI,CAAC3D,mBACP,CAAC;EACD,IAAIqC,YAAY,EAAE;IAChBmL,qBAAqB,CACnBzB,kBAAkB,EAClB,CAAC,EACDpI,IAAI,CAAC7C,mBAAmB,EACxB6C,IAAI,CAAC9C,eACP,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoM,UAAUA,CAACrJ,IAAI,EAAE8H,SAAS,EAAE1J,gBAAgB,EAAE;EACrD,IAAI4B,IAAI,CAACkJ,MAAM,KAAKlO,SAAS,EAAE;IAC7B,OAAO,GAAG;EACZ;EACA,MAAM6O,GAAG,GAAG7J,IAAI,CAACsC,gBAAgB;EACjC,MAAMwH,SAAS,GAAG9J,IAAI,CAACkJ,MAAM,CAAC5G,gBAAgB;EAC9C,MAAM8G,OAAO,GAAG,CAACtB,SAAS,GAAG+B,GAAG,KAAKC,SAAS,GAAGD,GAAG,CAAC;EACrD,MAAME,OAAO,GAAG,CAACX,OAAO,GAAGhL,gBAAgB,GAAG,GAAG,IAAIA,gBAAgB;EAErE,OAAO5F,UAAU,CAACuG,KAAK,CAACgL,OAAO,EAAE,GAAG,EAAE,GAAG,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,yBAAyBA,CAACvI,IAAI,EAAE4I,aAAa,EAAEC,WAAW,EAAEC,OAAO,EAAE;EAC5E,MAAMnJ,YAAY,GAAG9H,WAAW,CAACkR,gBAAgB,CAACD,OAAO,CAAC7N,WAAW,CAAC;EACtE,MAAM+N,SAAS,GAAGpO,IAAI,CAACG,IAAI,CAACiF,IAAI,CAACjH,MAAM,GAAG6P,aAAa,CAAC;EACxD,MAAMK,SAAS,GAAGrO,IAAI,CAACiK,GAAG,CACxB,CAAC,EACD+D,aAAa,GAAGhO,IAAI,CAAC8J,GAAG,CAACsE,SAAS,EAAEH,WAAW,CACjD,CAAC;EACD,MAAMK,UAAU,GAAGtO,IAAI,CAACiK,GAAG,CAAC,CAAC,EAAEjK,IAAI,CAACG,IAAI,CAACiO,SAAS,GAAGH,WAAW,CAAC,CAAC;EAElE,MAAMM,WAAW,GAAG,IAAIC,UAAU,CAACH,SAAS,GAAGC,UAAU,GAAGvJ,YAAY,CAAC;EACzE,KAAK,IAAI3G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgH,IAAI,CAACjH,MAAM,EAAEC,CAAC,EAAE,EAAE;IACpC,MAAMqQ,GAAG,GAAGrJ,IAAI,CAAChH,CAAC,CAAC;IACnB,MAAMsQ,UAAU,GAAGtQ,CAAC,GAAG2G,YAAY;IACnC,KAAK,IAAI4J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5J,YAAY,EAAE4J,CAAC,EAAE,EAAE;MACrCJ,WAAW,CAACG,UAAU,GAAGC,CAAC,CAAC,GAAIF,GAAG,KAAME,CAAC,GAAG,CAAE,GAAI,IAAI;IACxD;EACF;EAEA,MAAMC,MAAM,GAAG;IACbC,eAAe,EAAEN,WAAW;IAC5B7N,KAAK,EAAE2N,SAAS;IAChB1N,MAAM,EAAE2N;EACV,CAAC;EAED,MAAMQ,WAAW,GAAG;IAClBF,MAAM,EAAEA,MAAM;IACdG,OAAO,EAAE,CAAC;IACVC,OAAO,EAAE;EACX,CAAC;EAEDd,OAAO,CAACe,QAAQ,CAACH,WAAW,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASlB,qBAAqBA,CAACxI,IAAI,EAAE4I,aAAa,EAAEC,WAAW,EAAEC,OAAO,EAAE;EACxE,MAAMnJ,YAAY,GAAG9H,WAAW,CAACkR,gBAAgB,CAACD,OAAO,CAAC7N,WAAW,CAAC;EACtE,MAAM6O,YAAY,GAAG,CAAC;EACtB,MAAMd,SAAS,GAAGpO,IAAI,CAACG,IAAI,CAACiF,IAAI,CAACjH,MAAM,GAAG+Q,YAAY,CAAC;EACvD,MAAMb,SAAS,GAAGrO,IAAI,CAACiK,GAAG,CACxB,CAAC,EACD+D,aAAa,GAAGhO,IAAI,CAAC8J,GAAG,CAACsE,SAAS,EAAEH,WAAW,CACjD,CAAC;EACD,MAAMK,UAAU,GAAGtO,IAAI,CAACiK,GAAG,CAAC,CAAC,EAAEjK,IAAI,CAACG,IAAI,CAACiO,SAAS,GAAGH,WAAW,CAAC,CAAC;EAElE,MAAMM,WAAW,GAAG,IAAIC,UAAU,CAACH,SAAS,GAAGC,UAAU,GAAGvJ,YAAY,CAAC;EACzE,KAAK,IAAIoK,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGf,SAAS,EAAEe,SAAS,EAAE,EAAE;IAC1D,MAAMC,QAAQ,GAAGhK,IAAI,CAAC+J,SAAS,GAAGD,YAAY,GAAG,CAAC,CAAC;IACnD,MAAMG,2BAA2B,GAAGjK,IAAI,CAAC+J,SAAS,GAAGD,YAAY,GAAG,CAAC,CAAC;IACtE,MAAMI,uBAAuB,GAAGlK,IAAI,CAAC+J,SAAS,GAAGD,YAAY,GAAG,CAAC,CAAC;IAClE,MAAMK,gCAAgC,GAAGnK,IAAI,CAAC+J,SAAS,GAAGD,YAAY,GAAG,CAAC,CAAC;IAC3E,MAAMM,4BAA4B,GAAGpK,IAAI,CAAC+J,SAAS,GAAGD,YAAY,GAAG,CAAC,CAAC;IAEvE,MAAMO,kBAAkB,GAAGjT,UAAU,CAACuG,KAAK,CACzC/C,IAAI,CAACC,KAAK,CAAC,KAAK,GAAGmP,QAAQ,CAAC,EAC5B,CAAC,EACD,KACF,CAAC;IACDb,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAAIM,kBAAkB,KAAK,CAAC,GAAI,IAAI;IAClElB,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAAIM,kBAAkB,KAAK,CAAC,GAAI,IAAI;IAClElB,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGE,2BAA2B,GAAG,IAAI;IACnEd,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGG,uBAAuB,GAAG,IAAI;IAC/Df,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAC3BI,gCAAgC,KAAK,CAAC,GAAI,IAAI;IACjDhB,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAC3BI,gCAAgC,KAAK,CAAC,GAAI,IAAI;IACjDhB,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAC3BK,4BAA4B,KAAK,CAAC,GAAI,IAAI;IAC7CjB,WAAW,CAACY,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAC3BK,4BAA4B,KAAK,CAAC,GAAI,IAAI;EAC/C;EAEA,MAAMZ,MAAM,GAAG;IACbC,eAAe,EAAEN,WAAW;IAC5B7N,KAAK,EAAE2N,SAAS;IAChB1N,MAAM,EAAE2N;EACV,CAAC;EAED,MAAMQ,WAAW,GAAG;IAClBF,MAAM,EAAEA,MAAM;IACdG,OAAO,EAAE,CAAC;IACVC,OAAO,EAAE;EACX,CAAC;EAEDd,OAAO,CAACe,QAAQ,CAACH,WAAW,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAtR,cAAc,CAACkS,qCAAqC,GAAG,UACrDtB,SAAS,EACTzQ,UAAU,EACVC,KAAK,EACLC,cAAc,EACd;EACA,IAAI8R,uBAAuB,GAAG,CAAC;EAE/B,MAAMxR,MAAM,GAAGP,KAAK,CAACO,MAAM;EAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;IAC/B,MAAMC,IAAI,GAAGT,KAAK,CAACQ,CAAC,CAAC;IACrB,MAAMI,aAAa,GAAGX,cAAc,CAACO,CAAC,CAAC;IACvC,MAAME,cAAc,GAAGvB,YAAY,CAACwB,iBAAiB,CAACF,IAAI,CAAC;IAE3DsR,uBAAuB,IACrB3S,WAAW,CAAC0S,qCAAqC,CAC/CtB,SAAS,EACTzQ,UAAU,EACVW,cAAc,EACdE,aACF,CAAC;EACL;EAEA,OAAOmR,uBAAuB;AAChC,CAAC;AAED,eAAenS,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}