{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"vec4 czm_screenToEyeCoordinates(vec4 screenCoordinate)\\n\\\n{\\n\\\n    // Reconstruct NDC coordinates\\n\\\n    float x = 2.0 * screenCoordinate.x - 1.0;\\n\\\n    float y = 2.0 * screenCoordinate.y - 1.0;\\n\\\n    float z = (screenCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\\n\\\n    vec4 q = vec4(x, y, z, 1.0);\\n\\\n\\n\\\n    // Reverse the perspective division to obtain clip coordinates.\\n\\\n    q /= screenCoordinate.w;\\n\\\n\\n\\\n    // Reverse the projection transformation to obtain eye coordinates.\\n\\\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\\n\\\n    {\\n\\\n        q = czm_inverseProjection * q;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        float top = czm_frustumPlanes.x;\\n\\\n        float bottom = czm_frustumPlanes.y;\\n\\\n        float left = czm_frustumPlanes.z;\\n\\\n        float right = czm_frustumPlanes.w;\\n\\\n\\n\\\n        float near = czm_currentFrustum.x;\\n\\\n        float far = czm_currentFrustum.y;\\n\\\n\\n\\\n        q.x = (q.x * (right - left) + left + right) * 0.5;\\n\\\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\\n\\\n        q.z = (q.z * (near - far) - near - far) * 0.5;\\n\\\n        q.w = 1.0;\\n\\\n    }\\n\\\n\\n\\\n    return q;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Transforms a position from window to eye coordinates.\\n\\\n * The transform from window to normalized device coordinates is done using components\\n\\\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\\n\\\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\\n\\\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\\n\\\n * which is expected to be the scalar used in the perspective divide. The transformation\\n\\\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\\n\\\n *\\n\\\n * @name czm_windowToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in eye coordinates.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_inverseProjection\\n\\\n * @see czm_viewport\\n\\\n * @see czm_viewportTransformation\\n\\\n *\\n\\\n * @example\\n\\\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n */\\n\\\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\\n\\\n{\\n\\\n    vec2 screenCoordXY = (fragmentCoordinate.xy - czm_viewport.xy) / czm_viewport.zw;\\n\\\n    return czm_screenToEyeCoordinates(vec4(screenCoordXY, fragmentCoordinate.zw));\\n\\\n}\\n\\\n\\n\\\nvec4 czm_screenToEyeCoordinates(vec2 screenCoordinateXY, float depthOrLogDepth)\\n\\\n{\\n\\\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\\n\\\n#if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY)\\n\\\n    float near = czm_currentFrustum.x;\\n\\\n    float far = czm_currentFrustum.y;\\n\\\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\\n\\\n    float depthFromNear = exp2(log2Depth) - 1.0;\\n\\\n    float depthFromCamera = depthFromNear + near;\\n\\\n    vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\\n\\\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\\n\\\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\\n\\\n    return eyeCoordinate;\\n\\\n#else\\n\\\n    vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0);\\n\\\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\\n\\\n#endif\\n\\\n    return eyeCoordinate;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\\n\\\n * This function produces more accurate results for window positions with log depth than\\n\\\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\\n\\\n * of czm_windowToEyeCoordinates.\\n\\\n *\\n\\\n * @name czm_windowToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\\n\\\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_inverseProjection\\n\\\n * @see czm_viewport\\n\\\n * @see czm_viewportTransformation\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in eye coordinates.\\n\\\n */\\n\\\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\\n\\\n{\\n\\\n    vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw;\\n\\\n    return czm_screenToEyeCoordinates(screenCoordXY, depthOrLogDepth);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Builtin/Functions/windowToEyeCoordinates.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"vec4 czm_screenToEyeCoordinates(vec4 screenCoordinate)\\n\\\n{\\n\\\n    // Reconstruct NDC coordinates\\n\\\n    float x = 2.0 * screenCoordinate.x - 1.0;\\n\\\n    float y = 2.0 * screenCoordinate.y - 1.0;\\n\\\n    float z = (screenCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\\n\\\n    vec4 q = vec4(x, y, z, 1.0);\\n\\\n\\n\\\n    // Reverse the perspective division to obtain clip coordinates.\\n\\\n    q /= screenCoordinate.w;\\n\\\n\\n\\\n    // Reverse the projection transformation to obtain eye coordinates.\\n\\\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\\n\\\n    {\\n\\\n        q = czm_inverseProjection * q;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        float top = czm_frustumPlanes.x;\\n\\\n        float bottom = czm_frustumPlanes.y;\\n\\\n        float left = czm_frustumPlanes.z;\\n\\\n        float right = czm_frustumPlanes.w;\\n\\\n\\n\\\n        float near = czm_currentFrustum.x;\\n\\\n        float far = czm_currentFrustum.y;\\n\\\n\\n\\\n        q.x = (q.x * (right - left) + left + right) * 0.5;\\n\\\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\\n\\\n        q.z = (q.z * (near - far) - near - far) * 0.5;\\n\\\n        q.w = 1.0;\\n\\\n    }\\n\\\n\\n\\\n    return q;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Transforms a position from window to eye coordinates.\\n\\\n * The transform from window to normalized device coordinates is done using components\\n\\\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\\n\\\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\\n\\\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\\n\\\n * which is expected to be the scalar used in the perspective divide. The transformation\\n\\\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\\n\\\n *\\n\\\n * @name czm_windowToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in eye coordinates.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_inverseProjection\\n\\\n * @see czm_viewport\\n\\\n * @see czm_viewportTransformation\\n\\\n *\\n\\\n * @example\\n\\\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n */\\n\\\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\\n\\\n{\\n\\\n    vec2 screenCoordXY = (fragmentCoordinate.xy - czm_viewport.xy) / czm_viewport.zw;\\n\\\n    return czm_screenToEyeCoordinates(vec4(screenCoordXY, fragmentCoordinate.zw));\\n\\\n}\\n\\\n\\n\\\nvec4 czm_screenToEyeCoordinates(vec2 screenCoordinateXY, float depthOrLogDepth)\\n\\\n{\\n\\\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\\n\\\n#if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY)\\n\\\n    float near = czm_currentFrustum.x;\\n\\\n    float far = czm_currentFrustum.y;\\n\\\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\\n\\\n    float depthFromNear = exp2(log2Depth) - 1.0;\\n\\\n    float depthFromCamera = depthFromNear + near;\\n\\\n    vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\\n\\\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\\n\\\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\\n\\\n    return eyeCoordinate;\\n\\\n#else\\n\\\n    vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0);\\n\\\n    vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord);\\n\\\n#endif\\n\\\n    return eyeCoordinate;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\\n\\\n * This function produces more accurate results for window positions with log depth than\\n\\\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\\n\\\n * of czm_windowToEyeCoordinates.\\n\\\n *\\n\\\n * @name czm_windowToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\\n\\\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_inverseProjection\\n\\\n * @see czm_viewport\\n\\\n * @see czm_viewportTransformation\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in eye coordinates.\\n\\\n */\\n\\\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\\n\\\n{\\n\\\n    vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw;\\n\\\n    return czm_screenToEyeCoordinates(screenCoordXY, depthOrLogDepth);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}