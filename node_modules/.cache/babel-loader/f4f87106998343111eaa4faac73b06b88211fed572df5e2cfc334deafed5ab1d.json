{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport TranslationRotationScale from \"../Core/TranslationRotationScale.js\";\nimport createPropertyDescriptor from \"./createPropertyDescriptor.js\";\nimport Property from \"./Property.js\";\nconst defaultNodeTransformation = new TranslationRotationScale();\n\n/**\n * A {@link Property} that produces {@link TranslationRotationScale} data.\n * @alias NodeTransformationProperty\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Property|Cartesian3} [options.translation=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n * @param {Property|Quaternion} [options.rotation=Quaternion.IDENTITY] A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n * @param {Property|Cartesian3} [options.scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n */\nfunction NodeTransformationProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._definitionChanged = new Event();\n  this._translation = undefined;\n  this._translationSubscription = undefined;\n  this._rotation = undefined;\n  this._rotationSubscription = undefined;\n  this._scale = undefined;\n  this._scaleSubscription = undefined;\n  this.translation = options.translation;\n  this.rotation = options.rotation;\n  this.scale = options.scale;\n}\nObject.defineProperties(NodeTransformationProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return Property.isConstant(this._translation) && Property.isConstant(this._rotation) && Property.isConstant(this._scale);\n    }\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property|undefined}\n   * @default Cartesian3.ZERO\n   */\n  translation: createPropertyDescriptor(\"translation\"),\n  /**\n   * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property|undefined}\n   * @default Quaternion.IDENTITY\n   */\n  rotation: createPropertyDescriptor(\"rotation\"),\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property|undefined}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  scale: createPropertyDescriptor(\"scale\")\n});\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {TranslationRotationScale} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {TranslationRotationScale} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nNodeTransformationProperty.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  if (!defined(result)) {\n    result = new TranslationRotationScale();\n  }\n  result.translation = Property.getValueOrClonedDefault(this._translation, time, defaultNodeTransformation.translation, result.translation);\n  result.rotation = Property.getValueOrClonedDefault(this._rotation, time, defaultNodeTransformation.rotation, result.rotation);\n  result.scale = Property.getValueOrClonedDefault(this._scale, time, defaultNodeTransformation.scale, result.scale);\n  return result;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nNodeTransformationProperty.prototype.equals = function (other) {\n  return this === other || other instanceof NodeTransformationProperty && Property.equals(this._translation, other._translation) && Property.equals(this._rotation, other._rotation) && Property.equals(this._scale, other._scale);\n};\nexport default NodeTransformationProperty;","map":{"version":3,"names":["defaultValue","defined","Event","JulianDate","TranslationRotationScale","createPropertyDescriptor","Property","defaultNodeTransformation","NodeTransformationProperty","options","EMPTY_OBJECT","_definitionChanged","_translation","undefined","_translationSubscription","_rotation","_rotationSubscription","_scale","_scaleSubscription","translation","rotation","scale","Object","defineProperties","prototype","isConstant","get","definitionChanged","timeScratch","getValue","time","result","now","getValueOrClonedDefault","equals","other"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/NodeTransformationProperty.js"],"sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport TranslationRotationScale from \"../Core/TranslationRotationScale.js\";\nimport createPropertyDescriptor from \"./createPropertyDescriptor.js\";\nimport Property from \"./Property.js\";\n\nconst defaultNodeTransformation = new TranslationRotationScale();\n\n/**\n * A {@link Property} that produces {@link TranslationRotationScale} data.\n * @alias NodeTransformationProperty\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Property|Cartesian3} [options.translation=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n * @param {Property|Quaternion} [options.rotation=Quaternion.IDENTITY] A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n * @param {Property|Cartesian3} [options.scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n */\nfunction NodeTransformationProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._definitionChanged = new Event();\n  this._translation = undefined;\n  this._translationSubscription = undefined;\n  this._rotation = undefined;\n  this._rotationSubscription = undefined;\n  this._scale = undefined;\n  this._scaleSubscription = undefined;\n\n  this.translation = options.translation;\n  this.rotation = options.rotation;\n  this.scale = options.scale;\n}\n\nObject.defineProperties(NodeTransformationProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return (\n        Property.isConstant(this._translation) &&\n        Property.isConstant(this._rotation) &&\n        Property.isConstant(this._scale)\n      );\n    },\n  },\n\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof NodeTransformationProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property|undefined}\n   * @default Cartesian3.ZERO\n   */\n  translation: createPropertyDescriptor(\"translation\"),\n\n  /**\n   * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property|undefined}\n   * @default Quaternion.IDENTITY\n   */\n  rotation: createPropertyDescriptor(\"rotation\"),\n\n  /**\n   * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.\n   * @memberof NodeTransformationProperty.prototype\n   * @type {Property|undefined}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  scale: createPropertyDescriptor(\"scale\"),\n});\n\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {TranslationRotationScale} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {TranslationRotationScale} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nNodeTransformationProperty.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  if (!defined(result)) {\n    result = new TranslationRotationScale();\n  }\n\n  result.translation = Property.getValueOrClonedDefault(\n    this._translation,\n    time,\n    defaultNodeTransformation.translation,\n    result.translation,\n  );\n  result.rotation = Property.getValueOrClonedDefault(\n    this._rotation,\n    time,\n    defaultNodeTransformation.rotation,\n    result.rotation,\n  );\n  result.scale = Property.getValueOrClonedDefault(\n    this._scale,\n    time,\n    defaultNodeTransformation.scale,\n    result.scale,\n  );\n  return result;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nNodeTransformationProperty.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (other instanceof NodeTransformationProperty &&\n      Property.equals(this._translation, other._translation) &&\n      Property.equals(this._rotation, other._rotation) &&\n      Property.equals(this._scale, other._scale))\n  );\n};\nexport default NodeTransformationProperty;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}