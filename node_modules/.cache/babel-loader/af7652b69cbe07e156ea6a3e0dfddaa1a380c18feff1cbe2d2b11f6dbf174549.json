{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\n/**\n * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n * is responsible for handling visualization of a specific type of geometry\n * that needs to be recomputed based on simulation time.\n * This object is never used directly by client code, but is instead created by\n * {@link GeometryUpdater} implementations which contain dynamic geometry.\n *\n * This type defines an interface and cannot be instantiated directly.\n *\n * @alias DynamicGeometryUpdater\n * @constructor\n * @private\n * @abstract\n */\nfunction DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"geometryUpdater\", geometryUpdater);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"orderedGroundPrimitives\", orderedGroundPrimitives);\n  //>>includeEnd('debug');\n\n  this._primitives = primitives;\n  this._orderedGroundPrimitives = orderedGroundPrimitives;\n  this._primitive = undefined;\n  this._outlinePrimitive = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._options = geometryUpdater._options;\n  this._entity = geometryUpdater._entity;\n  this._material = undefined;\n}\nDynamicGeometryUpdater.prototype._isHidden = function (entity, geometry, time) {\n  return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);\n};\nDynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;\n\n/**\n * Updates the geometry to the specified time.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @param {JulianDate} time The current time.\n */\nDynamicGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const geometryUpdater = this._geometryUpdater;\n  const onTerrain = geometryUpdater._onTerrain;\n  const primitives = this._primitives;\n  const orderedGroundPrimitives = this._orderedGroundPrimitives;\n  if (onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._outlinePrimitive = undefined;\n  }\n  this._primitive = undefined;\n  const entity = this._entity;\n  const geometry = entity[this._geometryUpdater._geometryPropertyName];\n  this._setOptions(entity, geometry, time);\n  if (this._isHidden(entity, geometry, time)) {\n    return;\n  }\n  const shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n  const options = this._options;\n  if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n    const fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    const isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;\n    let appearance;\n    const closed = geometryUpdater._getIsClosed(options);\n    if (isColorAppearance) {\n      appearance = new PerInstanceColorAppearance({\n        closed: closed,\n        flat: onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain\n      });\n    } else {\n      const material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n      this._material = material;\n      appearance = new MaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent(),\n        closed: closed\n      });\n    }\n    if (onTerrain) {\n      options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n      this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({\n        geometryInstances: this._geometryUpdater.createFillGeometryInstance(time),\n        appearance: appearance,\n        asynchronous: false,\n        shadows: shadows,\n        classificationType: this._geometryUpdater.classificationTypeProperty.getValue(time)\n      }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));\n    } else {\n      options.vertexFormat = appearance.vertexFormat;\n      const fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n      if (isColorAppearance) {\n        appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n      }\n      this._primitive = primitives.add(new Primitive({\n        geometryInstances: fillInstance,\n        appearance: appearance,\n        asynchronous: false,\n        shadows: shadows\n      }));\n    }\n  }\n  if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {\n    const outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);\n    const outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);\n    this._outlinePrimitive = primitives.add(new Primitive({\n      geometryInstances: outlineInstance,\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: outlineInstance.attributes.color.value[3] !== 255,\n        renderState: {\n          lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth)\n        }\n      }),\n      asynchronous: false,\n      shadows: shadows\n    }));\n  }\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n * @function\n *\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n  const entity = this._entity;\n  const primitive = this._primitive;\n  const outlinePrimitive = this._outlinePrimitive;\n  let attributes;\n\n  //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n  if (defined(primitive) && primitive.show && primitive.ready) {\n    attributes = primitive.getGeometryInstanceAttributes(entity);\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n  if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {\n    attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n  if (defined(primitive) && !primitive.ready || defined(outlinePrimitive) && !outlinePrimitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  return BoundingSphereState.FAILED;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nDynamicGeometryUpdater.prototype.destroy = function () {\n  const primitives = this._primitives;\n  const orderedGroundPrimitives = this._orderedGroundPrimitives;\n  if (this._geometryUpdater._onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n  }\n  primitives.removeAndDestroy(this._outlinePrimitive);\n  destroyObject(this);\n};\nexport default DynamicGeometryUpdater;","map":{"version":3,"names":["BoundingSphere","Check","defined","destroyObject","DeveloperError","GroundPrimitive","MaterialAppearance","PerInstanceColorAppearance","Primitive","BoundingSphereState","ColorMaterialProperty","MaterialProperty","Property","DynamicGeometryUpdater","geometryUpdater","primitives","orderedGroundPrimitives","_primitives","_orderedGroundPrimitives","_primitive","undefined","_outlinePrimitive","_geometryUpdater","_options","_entity","_material","prototype","_isHidden","entity","geometry","time","isShowing","isAvailable","getValueOrDefault","show","_setOptions","throwInstantiationError","update","onTerrain","_onTerrain","remove","removeAndDestroy","_geometryPropertyName","shadows","shadowsProperty","getValue","options","fill","fillMaterialProperty","isColorAppearance","appearance","closed","_getIsClosed","flat","_supportsMaterialsforEntitiesOnTerrain","material","translucent","isTranslucent","vertexFormat","VERTEX_FORMAT","add","geometryInstances","createFillGeometryInstance","asynchronous","classificationType","classificationTypeProperty","getValueOrUndefined","zIndex","fillInstance","attributes","color","value","outline","outlineInstance","createOutlineGeometryInstance","outlineWidth","renderState","lineWidth","_scene","clampLineWidth","getBoundingSphere","result","primitive","outlinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","clone","DONE","PENDING","FAILED","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/DynamicGeometryUpdater.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\n/**\n * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n * is responsible for handling visualization of a specific type of geometry\n * that needs to be recomputed based on simulation time.\n * This object is never used directly by client code, but is instead created by\n * {@link GeometryUpdater} implementations which contain dynamic geometry.\n *\n * This type defines an interface and cannot be instantiated directly.\n *\n * @alias DynamicGeometryUpdater\n * @constructor\n * @private\n * @abstract\n */\nfunction DynamicGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  orderedGroundPrimitives,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"geometryUpdater\", geometryUpdater);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"orderedGroundPrimitives\", orderedGroundPrimitives);\n  //>>includeEnd('debug');\n\n  this._primitives = primitives;\n  this._orderedGroundPrimitives = orderedGroundPrimitives;\n  this._primitive = undefined;\n  this._outlinePrimitive = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._options = geometryUpdater._options;\n  this._entity = geometryUpdater._entity;\n  this._material = undefined;\n}\n\nDynamicGeometryUpdater.prototype._isHidden = function (entity, geometry, time) {\n  return (\n    !entity.isShowing ||\n    !entity.isAvailable(time) ||\n    !Property.getValueOrDefault(geometry.show, time, true)\n  );\n};\n\nDynamicGeometryUpdater.prototype._setOptions =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Updates the geometry to the specified time.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @param {JulianDate} time The current time.\n */\nDynamicGeometryUpdater.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const geometryUpdater = this._geometryUpdater;\n  const onTerrain = geometryUpdater._onTerrain;\n\n  const primitives = this._primitives;\n  const orderedGroundPrimitives = this._orderedGroundPrimitives;\n  if (onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n    primitives.removeAndDestroy(this._outlinePrimitive);\n    this._outlinePrimitive = undefined;\n  }\n  this._primitive = undefined;\n\n  const entity = this._entity;\n  const geometry = entity[this._geometryUpdater._geometryPropertyName];\n  this._setOptions(entity, geometry, time);\n  if (this._isHidden(entity, geometry, time)) {\n    return;\n  }\n\n  const shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n  const options = this._options;\n  if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n    const fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    const isColorAppearance =\n      fillMaterialProperty instanceof ColorMaterialProperty;\n    let appearance;\n    const closed = geometryUpdater._getIsClosed(options);\n    if (isColorAppearance) {\n      appearance = new PerInstanceColorAppearance({\n        closed: closed,\n        flat:\n          onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain,\n      });\n    } else {\n      const material = MaterialProperty.getValue(\n        time,\n        fillMaterialProperty,\n        this._material,\n      );\n      this._material = material;\n      appearance = new MaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent(),\n        closed: closed,\n      });\n    }\n\n    if (onTerrain) {\n      options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n      this._primitive = orderedGroundPrimitives.add(\n        new GroundPrimitive({\n          geometryInstances:\n            this._geometryUpdater.createFillGeometryInstance(time),\n          appearance: appearance,\n          asynchronous: false,\n          shadows: shadows,\n          classificationType:\n            this._geometryUpdater.classificationTypeProperty.getValue(time),\n        }),\n        Property.getValueOrUndefined(this._geometryUpdater.zIndex, time),\n      );\n    } else {\n      options.vertexFormat = appearance.vertexFormat;\n\n      const fillInstance =\n        this._geometryUpdater.createFillGeometryInstance(time);\n\n      if (isColorAppearance) {\n        appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n      }\n\n      this._primitive = primitives.add(\n        new Primitive({\n          geometryInstances: fillInstance,\n          appearance: appearance,\n          asynchronous: false,\n          shadows: shadows,\n        }),\n      );\n    }\n  }\n\n  if (\n    !onTerrain &&\n    defined(geometry.outline) &&\n    geometry.outline.getValue(time)\n  ) {\n    const outlineInstance =\n      this._geometryUpdater.createOutlineGeometryInstance(time);\n    const outlineWidth = Property.getValueOrDefault(\n      geometry.outlineWidth,\n      time,\n      1.0,\n    );\n\n    this._outlinePrimitive = primitives.add(\n      new Primitive({\n        geometryInstances: outlineInstance,\n        appearance: new PerInstanceColorAppearance({\n          flat: true,\n          translucent: outlineInstance.attributes.color.value[3] !== 255,\n          renderState: {\n            lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth),\n          },\n        }),\n        asynchronous: false,\n        shadows: shadows,\n      }),\n    );\n  }\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n * @function\n *\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n  const entity = this._entity;\n  const primitive = this._primitive;\n  const outlinePrimitive = this._outlinePrimitive;\n\n  let attributes;\n\n  //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n  if (defined(primitive) && primitive.show && primitive.ready) {\n    attributes = primitive.getGeometryInstanceAttributes(entity);\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n\n  if (\n    defined(outlinePrimitive) &&\n    outlinePrimitive.show &&\n    outlinePrimitive.ready\n  ) {\n    attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n    if (defined(attributes) && defined(attributes.boundingSphere)) {\n      BoundingSphere.clone(attributes.boundingSphere, result);\n      return BoundingSphereState.DONE;\n    }\n  }\n\n  if (\n    (defined(primitive) && !primitive.ready) ||\n    (defined(outlinePrimitive) && !outlinePrimitive.ready)\n  ) {\n    return BoundingSphereState.PENDING;\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n * @memberof DynamicGeometryUpdater\n * @function\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nDynamicGeometryUpdater.prototype.destroy = function () {\n  const primitives = this._primitives;\n  const orderedGroundPrimitives = this._orderedGroundPrimitives;\n  if (this._geometryUpdater._onTerrain) {\n    orderedGroundPrimitives.remove(this._primitive);\n  } else {\n    primitives.removeAndDestroy(this._primitive);\n  }\n  primitives.removeAndDestroy(this._outlinePrimitive);\n  destroyObject(this);\n};\nexport default DynamicGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}