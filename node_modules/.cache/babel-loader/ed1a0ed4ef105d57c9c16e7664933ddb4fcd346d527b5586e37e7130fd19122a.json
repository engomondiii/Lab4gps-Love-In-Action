{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\n\n/**\n * Results of the preprocess3DTileContent() function. This includes the\n * {@link Cesium3DTileContentType} and the payload. The payload is either\n * binary or JSON depending on the content type.\n *\n * @typedef {object} PreprocessedContent\n * @property {Cesium3DTileContentType} contentType The type of the content\n * @property {Uint8Array} [binaryPayload] For binary files, the payload is returned as a typed array with byteOffset of 0\n * @property {object} [jsonPayload] For JSON files, the results are returned as a JSON object.\n * @private\n */\n\n/**\n * Preprocess a {@link Cesium3DTileContent}, to determine the type of content\n * and to parse JSON files into objects.\n *\n * @param {ArrayBuffer} arrayBuffer The raw binary payload\n * @return {PreprocessedContent}\n * @private\n */\nfunction preprocess3DTileContent(arrayBuffer) {\n  const uint8Array = new Uint8Array(arrayBuffer);\n  let contentType = getMagic(uint8Array);\n\n  // We use glTF for JSON glTF files. For binary glTF, we rename this\n  // to glb to disambiguate\n  if (contentType === \"glTF\") {\n    contentType = \"glb\";\n  }\n  if (Cesium3DTileContentType.isBinaryFormat(contentType)) {\n    return {\n      // For binary files, the enum value is the magic number\n      contentType: contentType,\n      binaryPayload: uint8Array\n    };\n  }\n  const json = getJsonContent(uint8Array);\n  if (defined(json.root)) {\n    // Most likely a tileset JSON\n    return {\n      contentType: Cesium3DTileContentType.EXTERNAL_TILESET,\n      jsonPayload: json\n    };\n  }\n  if (defined(json.asset)) {\n    // Most likely a glTF. Tileset JSON also has an \"asset\" property\n    // so this check needs to happen second\n    return {\n      contentType: Cesium3DTileContentType.GLTF,\n      jsonPayload: json\n    };\n  }\n  if (defined(json.tileAvailability)) {\n    // Most likely a subtree JSON.\n    return {\n      contentType: Cesium3DTileContentType.IMPLICIT_SUBTREE_JSON,\n      jsonPayload: json\n    };\n  }\n  if (defined(json.type)) {\n    // Most likely a GeoJSON\n    return {\n      contentType: Cesium3DTileContentType.GEOJSON,\n      jsonPayload: json\n    };\n  }\n  if (defined(json.voxelTable)) {\n    // Most likely a voxel JSON\n    return {\n      contentType: Cesium3DTileContentType.VOXEL_JSON,\n      jsonPayload: json\n    };\n  }\n  throw new RuntimeError(\"Invalid tile content.\");\n}\nfunction getJsonContent(uint8Array) {\n  let json;\n  try {\n    json = getJsonFromTypedArray(uint8Array);\n  } catch (error) {\n    throw new RuntimeError(\"Invalid tile content.\");\n  }\n  return json;\n}\nexport default preprocess3DTileContent;","map":{"version":3,"names":["defined","getJsonFromTypedArray","getMagic","RuntimeError","Cesium3DTileContentType","preprocess3DTileContent","arrayBuffer","uint8Array","Uint8Array","contentType","isBinaryFormat","binaryPayload","json","getJsonContent","root","EXTERNAL_TILESET","jsonPayload","asset","GLTF","tileAvailability","IMPLICIT_SUBTREE_JSON","type","GEOJSON","voxelTable","VOXEL_JSON","error"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/preprocess3DTileContent.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\n\n/**\n * Results of the preprocess3DTileContent() function. This includes the\n * {@link Cesium3DTileContentType} and the payload. The payload is either\n * binary or JSON depending on the content type.\n *\n * @typedef {object} PreprocessedContent\n * @property {Cesium3DTileContentType} contentType The type of the content\n * @property {Uint8Array} [binaryPayload] For binary files, the payload is returned as a typed array with byteOffset of 0\n * @property {object} [jsonPayload] For JSON files, the results are returned as a JSON object.\n * @private\n */\n\n/**\n * Preprocess a {@link Cesium3DTileContent}, to determine the type of content\n * and to parse JSON files into objects.\n *\n * @param {ArrayBuffer} arrayBuffer The raw binary payload\n * @return {PreprocessedContent}\n * @private\n */\nfunction preprocess3DTileContent(arrayBuffer) {\n  const uint8Array = new Uint8Array(arrayBuffer);\n  let contentType = getMagic(uint8Array);\n\n  // We use glTF for JSON glTF files. For binary glTF, we rename this\n  // to glb to disambiguate\n  if (contentType === \"glTF\") {\n    contentType = \"glb\";\n  }\n\n  if (Cesium3DTileContentType.isBinaryFormat(contentType)) {\n    return {\n      // For binary files, the enum value is the magic number\n      contentType: contentType,\n      binaryPayload: uint8Array,\n    };\n  }\n\n  const json = getJsonContent(uint8Array);\n  if (defined(json.root)) {\n    // Most likely a tileset JSON\n    return {\n      contentType: Cesium3DTileContentType.EXTERNAL_TILESET,\n      jsonPayload: json,\n    };\n  }\n\n  if (defined(json.asset)) {\n    // Most likely a glTF. Tileset JSON also has an \"asset\" property\n    // so this check needs to happen second\n    return {\n      contentType: Cesium3DTileContentType.GLTF,\n      jsonPayload: json,\n    };\n  }\n\n  if (defined(json.tileAvailability)) {\n    // Most likely a subtree JSON.\n    return {\n      contentType: Cesium3DTileContentType.IMPLICIT_SUBTREE_JSON,\n      jsonPayload: json,\n    };\n  }\n\n  if (defined(json.type)) {\n    // Most likely a GeoJSON\n    return {\n      contentType: Cesium3DTileContentType.GEOJSON,\n      jsonPayload: json,\n    };\n  }\n\n  if (defined(json.voxelTable)) {\n    // Most likely a voxel JSON\n    return {\n      contentType: Cesium3DTileContentType.VOXEL_JSON,\n      jsonPayload: json,\n    };\n  }\n\n  throw new RuntimeError(\"Invalid tile content.\");\n}\n\nfunction getJsonContent(uint8Array) {\n  let json;\n\n  try {\n    json = getJsonFromTypedArray(uint8Array);\n  } catch (error) {\n    throw new RuntimeError(\"Invalid tile content.\");\n  }\n\n  return json;\n}\n\nexport default preprocess3DTileContent;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,oBAAoB;AACxC,OAAOC,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,uBAAuB,MAAM,8BAA8B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,uBAAuBA,CAACC,WAAW,EAAE;EAC5C,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAACF,WAAW,CAAC;EAC9C,IAAIG,WAAW,GAAGP,QAAQ,CAACK,UAAU,CAAC;;EAEtC;EACA;EACA,IAAIE,WAAW,KAAK,MAAM,EAAE;IAC1BA,WAAW,GAAG,KAAK;EACrB;EAEA,IAAIL,uBAAuB,CAACM,cAAc,CAACD,WAAW,CAAC,EAAE;IACvD,OAAO;MACL;MACAA,WAAW,EAAEA,WAAW;MACxBE,aAAa,EAAEJ;IACjB,CAAC;EACH;EAEA,MAAMK,IAAI,GAAGC,cAAc,CAACN,UAAU,CAAC;EACvC,IAAIP,OAAO,CAACY,IAAI,CAACE,IAAI,CAAC,EAAE;IACtB;IACA,OAAO;MACLL,WAAW,EAAEL,uBAAuB,CAACW,gBAAgB;MACrDC,WAAW,EAAEJ;IACf,CAAC;EACH;EAEA,IAAIZ,OAAO,CAACY,IAAI,CAACK,KAAK,CAAC,EAAE;IACvB;IACA;IACA,OAAO;MACLR,WAAW,EAAEL,uBAAuB,CAACc,IAAI;MACzCF,WAAW,EAAEJ;IACf,CAAC;EACH;EAEA,IAAIZ,OAAO,CAACY,IAAI,CAACO,gBAAgB,CAAC,EAAE;IAClC;IACA,OAAO;MACLV,WAAW,EAAEL,uBAAuB,CAACgB,qBAAqB;MAC1DJ,WAAW,EAAEJ;IACf,CAAC;EACH;EAEA,IAAIZ,OAAO,CAACY,IAAI,CAACS,IAAI,CAAC,EAAE;IACtB;IACA,OAAO;MACLZ,WAAW,EAAEL,uBAAuB,CAACkB,OAAO;MAC5CN,WAAW,EAAEJ;IACf,CAAC;EACH;EAEA,IAAIZ,OAAO,CAACY,IAAI,CAACW,UAAU,CAAC,EAAE;IAC5B;IACA,OAAO;MACLd,WAAW,EAAEL,uBAAuB,CAACoB,UAAU;MAC/CR,WAAW,EAAEJ;IACf,CAAC;EACH;EAEA,MAAM,IAAIT,YAAY,CAAC,uBAAuB,CAAC;AACjD;AAEA,SAASU,cAAcA,CAACN,UAAU,EAAE;EAClC,IAAIK,IAAI;EAER,IAAI;IACFA,IAAI,GAAGX,qBAAqB,CAACM,UAAU,CAAC;EAC1C,CAAC,CAAC,OAAOkB,KAAK,EAAE;IACd,MAAM,IAAItB,YAAY,CAAC,uBAAuB,CAAC;EACjD;EAEA,OAAOS,IAAI;AACb;AAEA,eAAeP,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}