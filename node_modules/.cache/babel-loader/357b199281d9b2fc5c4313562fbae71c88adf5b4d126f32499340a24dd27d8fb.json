{"ast":null,"code":"import ArticulationStageType from \"../Core/ArticulationStageType.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport InterpolationType from \"../Core/InterpolationType.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport getAccessorByteStride from \"./GltfPipeline/getAccessorByteStride.js\";\nimport getComponentReader from \"./GltfPipeline/getComponentReader.js\";\nimport numberOfComponentsForType from \"./GltfPipeline/numberOfComponentsForType.js\";\nimport GltfStructuralMetadataLoader from \"./GltfStructuralMetadataLoader.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Axis from \"./Axis.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport InstanceAttributeSemantic from \"./InstanceAttributeSemantic.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport PrimitiveLoadPlan from \"./PrimitiveLoadPlan.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport SupportedImageFormats from \"./SupportedImageFormats.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\nimport GltfGpmLoader from \"./Model/Extensions/Gpm/GltfGpmLoader.js\";\nimport GltfMeshPrimitiveGpmLoader from \"./Model/Extensions/Gpm/GltfMeshPrimitiveGpmLoader.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nconst {\n  Attribute,\n  Indices,\n  FeatureIdAttribute,\n  FeatureIdTexture,\n  FeatureIdImplicitRange,\n  MorphTarget,\n  Primitive,\n  Instances,\n  Skin,\n  Node,\n  AnimatedPropertyType,\n  AnimationSampler,\n  AnimationTarget,\n  AnimationChannel,\n  Animation,\n  ArticulationStage,\n  Articulation,\n  Asset,\n  Scene,\n  Components,\n  MetallicRoughness,\n  SpecularGlossiness,\n  Specular,\n  Anisotropy,\n  Clearcoat,\n  Material\n} = ModelComponents;\n\n/**\n * States of the glTF loading process. These states also apply to\n * asynchronous texture loading unless otherwise noted\n *\n * @enum {number}\n *\n * @private\n */\nconst GltfLoaderState = {\n  /**\n   * The initial state of the glTF loader before load() is called.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  NOT_LOADED: 0,\n  /**\n   * The state of the loader while waiting for the glTF JSON loader promise\n   * to resolve.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  LOADING: 1,\n  /**\n   * The state of the loader once the glTF JSON is loaded but before\n   * process() is called.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  LOADED: 2,\n  /**\n   * The state of the loader while parsing the glTF and creating GPU resources\n   * as needed.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  PROCESSING: 3,\n  /**\n   * For some features like handling CESIUM_primitive_outlines, the geometry\n   * must be modified after it is loaded. The post-processing state handles\n   * any geometry modification (if needed).\n   * <p>\n   * This state is not used for asynchronous texture loading.\n   * </p>\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  POST_PROCESSING: 4,\n  /**\n   * Once the processing/post-processing states are finished, the loader\n   * enters the processed state (sometimes from a promise chain). The next\n   * call to process() will advance to the ready state.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  PROCESSED: 5,\n  /**\n   * When the loader reaches the ready state, the loaders' promise will be\n   * resolved.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  READY: 6,\n  /**\n   * If an error occurs at any point, the loader switches to the failed state.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  FAILED: 7,\n  /**\n   * If unload() is called, the loader switches to the unloaded state.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  UNLOADED: 8\n};\n\n/**\n * Loads a glTF model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF. This is often the path of the .gltf or .glb file, but may also be the path of the .b3dm, .i3dm, or .cmpt file containing the embedded glb. .cmpt resources should have a URI fragment indicating the index of the inner content to which the glb belongs in order to individually identify the glb in the cache, e.g. http://example.com/tile.cmpt#index=2.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents, e.g. from a .b3dm, .i3dm, or .cmpt file.\n * @param {object} [options.gltfJson] A parsed glTF JSON file instead of passing it in as a typed array.\n * @param {boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.Z] The forward-axis of the glTF model.\n * @param {boolean} [options.loadAttributesAsTypedArray=false] Load all attributes and indices as typed arrays instead of GPU buffers. If the attributes are interleaved in the glTF they will be de-interleaved in the typed array.\n * @param {boolean} [options.loadAttributesFor2D=false] If <code>true</code>, load the positions buffer and any instanced attribute buffers as typed arrays for accurately projecting models to 2D.\n * @param {boolean} [options.enablePick=false]  If <code>true</code>, load the positions buffer, any instanced attribute buffers, and index buffer as typed arrays for CPU-enabled picking in WebGL1.\n * @param {boolean} [options.loadIndicesForWireframe=false] If <code>true</code>, load the index buffer as both a buffer and typed array. The latter is useful for creating wireframe indices in WebGL1.\n * @param {boolean} [options.loadPrimitiveOutline=true] If <code>true</code>, load outlines from the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time.\n * @param {boolean} [options.loadForClassification=false] If <code>true</code> and if the model has feature IDs, load the feature IDs and indices as typed arrays. This is useful for batching features for classification.\n * @param {boolean} [options.renameBatchIdSemantic=false] If <code>true</code>, rename _BATCHID or BATCHID to _FEATURE_ID_0. This is used for .b3dm models\n * @private\n */\nfunction GltfLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltfResource,\n    typedArray,\n    releaseGltfJson = false,\n    asynchronous = true,\n    incrementallyLoadTextures = true,\n    upAxis = Axis.Y,\n    forwardAxis = Axis.Z,\n    loadAttributesAsTypedArray = false,\n    loadAttributesFor2D = false,\n    enablePick = false,\n    loadIndicesForWireframe = false,\n    loadPrimitiveOutline = true,\n    loadForClassification = false,\n    renameBatchIdSemantic = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  //>>includeEnd('debug');\n\n  const {\n    baseResource = gltfResource.clone()\n  } = options;\n  this._gltfJson = options.gltfJson;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._typedArray = typedArray;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadAttributesFor2D = loadAttributesFor2D;\n  this._enablePick = enablePick;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._loadPrimitiveOutline = loadPrimitiveOutline;\n  this._loadForClassification = loadForClassification;\n  this._renameBatchIdSemantic = renameBatchIdSemantic;\n\n  // When loading EXT_feature_metadata, the feature tables and textures\n  // are now stored as arrays like the newer EXT_structural_metadata extension.\n  // This requires sorting the dictionary keys for a consistent ordering.\n  this._sortedPropertyTableIds = undefined;\n  this._sortedFeatureTextureIds = undefined;\n  this._gltfJsonLoader = undefined;\n  this._state = GltfLoaderState.NOT_LOADED;\n  this._textureState = GltfLoaderState.NOT_LOADED;\n  this._promise = undefined;\n  this._processError = undefined;\n  this._textureErrors = [];\n\n  // Information about whether to load primitives as typed arrays or buffers,\n  // and whether post-processing is needed after loading (e.g. for\n  // generating outlines)\n  this._primitiveLoadPlans = [];\n\n  // Loaders that need to be processed before the glTF becomes ready\n  this._loaderPromises = [];\n  this._textureLoaders = [];\n  this._texturesPromises = [];\n  this._textureCallbacks = [];\n  this._bufferViewLoaders = [];\n  this._geometryLoaders = [];\n  this._geometryCallbacks = [];\n  this._structuralMetadataLoader = undefined;\n  this._meshPrimitiveGpmLoader = undefined;\n  this._loadResourcesPromise = undefined;\n  this._resourcesLoaded = false;\n  this._texturesLoaded = false;\n  this._supportedImageFormats = undefined;\n\n  // In some cases where geometry post-processing is needed (like generating\n  // outlines) new attributes are added that may have GPU resources attached.\n  // The GltfLoader will own the resources and store them here.\n  this._postProcessBuffers = [];\n\n  // Loaded results\n  this._components = undefined;\n}\nif (defined(Object.create)) {\n  GltfLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfLoader.prototype.constructor = GltfLoader;\n}\nObject.defineProperties(GltfLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    }\n  },\n  /**\n   * The loaded glTF json.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  gltfJson: {\n    get: function () {\n      if (defined(this._gltfJsonLoader)) {\n        return this._gltfJsonLoader.gltf;\n      }\n      return this._gltfJson;\n    }\n  },\n  /**\n   * Returns true if textures are loaded separately from the other glTF resources.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    }\n  },\n  /**\n   * true if textures are loaded, useful when incrementallyLoadTextures is true\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  texturesLoaded: {\n    get: function () {\n      return this._texturesLoaded;\n    }\n  }\n});\n\n/**\n * Loads the gltf object\n */\nasync function loadGltfJson(loader) {\n  loader._state = GltfLoaderState.LOADING;\n  loader._textureState = GltfLoaderState.LOADING;\n  try {\n    const gltfJsonLoader = ResourceCache.getGltfJsonLoader({\n      gltfResource: loader._gltfResource,\n      baseResource: loader._baseResource,\n      typedArray: loader._typedArray,\n      gltfJson: loader._gltfJson\n    });\n    loader._gltfJsonLoader = gltfJsonLoader;\n    await gltfJsonLoader.load();\n    if (loader.isDestroyed() || loader.isUnloaded() || gltfJsonLoader.isDestroyed()) {\n      return;\n    }\n    loader._state = GltfLoaderState.LOADED;\n    loader._textureState = GltfLoaderState.LOADED;\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    loader._state = GltfLoaderState.FAILED;\n    loader._textureState = GltfLoaderState.FAILED;\n    handleError(loader, error);\n  }\n}\nasync function loadResources(loader, frameState) {\n  if (!FeatureDetection.supportsWebP.initialized) {\n    await FeatureDetection.supportsWebP.initialize();\n  }\n  loader._supportedImageFormats = new SupportedImageFormats({\n    webp: FeatureDetection.supportsWebP(),\n    basis: frameState.context.supportsBasis\n  });\n\n  // Loaders that create GPU resources need to be processed every frame until they become\n  // ready since the JobScheduler is not able to execute all jobs in a single\n  // frame. Any promise failures are collected, and will be handled synchronously in process().\n  // Also note that it's fine to call process before a loader is ready to process or\n  // after it has failed; nothing will happen.\n  const promise = parse(loader, frameState);\n\n  // All resource loaders have been created, so we can begin processing\n  loader._state = GltfLoaderState.PROCESSING;\n  loader._textureState = GltfLoaderState.PROCESSING;\n  if (defined(loader._gltfJsonLoader) && loader._releaseGltfJson) {\n    // Check that the glTF JSON loader is still defined before trying to unload it.\n    // It can be unloaded if the glTF loader is destroyed.\n    ResourceCache.unload(loader._gltfJsonLoader);\n    loader._gltfJsonLoader = undefined;\n  }\n  return promise;\n}\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @exception {RuntimeError} Unsupported glTF version\n * @exception {RuntimeError} Unsupported glTF Extension\n * @private\n */\nGltfLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  this._promise = loadGltfJson(this);\n  return this._promise;\n};\nfunction handleError(gltfLoader, error) {\n  gltfLoader.unload();\n  const errorMessage = \"Failed to load glTF\";\n  throw gltfLoader.getError(errorMessage, error);\n}\nfunction processLoaders(loader, frameState) {\n  let ready = true;\n  const geometryLoaders = loader._geometryLoaders;\n  for (let i = 0; i < geometryLoaders.length; ++i) {\n    const geometryReady = geometryLoaders[i].process(frameState);\n    if (geometryReady && defined(loader._geometryCallbacks[i])) {\n      loader._geometryCallbacks[i]();\n      loader._geometryCallbacks[i] = undefined;\n    }\n    ready = ready && geometryReady;\n  }\n  const structuralMetadataLoader = loader._structuralMetadataLoader;\n  if (defined(structuralMetadataLoader)) {\n    const metadataReady = structuralMetadataLoader.process(frameState);\n    if (metadataReady) {\n      loader._components.structuralMetadata = structuralMetadataLoader.structuralMetadata;\n    }\n    ready = ready && metadataReady;\n  }\n  const meshPrimitiveGpmLoader = loader._meshPrimitiveGpmLoader;\n  if (defined(meshPrimitiveGpmLoader)) {\n    const metadataReady = meshPrimitiveGpmLoader.process(frameState);\n    if (metadataReady) {\n      if (defined(loader._components.structuralMetadata)) {\n        oneTimeWarning(\"structural-metadata-gpm\", \"The model defines both the 'EXT_structural_metadata' extension and the \" + \"'NGA_gpm_local' extension. The data from the 'EXT_structural_metadata' \" + \"extension will be replaced with the data from the 'NGA_gpm_local' extension, \" + \"and will no longer be available for styling and picking.\");\n      }\n      loader._components.structuralMetadata = meshPrimitiveGpmLoader.structuralMetadata;\n    }\n    ready = ready && metadataReady;\n  }\n  if (ready) {\n    // Geometry requires further processing\n    loader._state = GltfLoaderState.POST_PROCESSING;\n  }\n}\nfunction postProcessGeometry(loader, context) {\n  // Apply post-processing steps on geometry such as\n  // updating attributes for rendering outlines.\n  const loadPlans = loader._primitiveLoadPlans;\n  for (let i = 0; i < loadPlans.length; i++) {\n    const loadPlan = loadPlans[i];\n    loadPlan.postProcess(context);\n    if (loadPlan.needsOutlines) {\n      // The glTF loader takes ownership of any buffers generated in the\n      // post-process stage since they were created after the geometry loaders\n      // finished. This way they can be destroyed when the loader is destroyed.\n      gatherPostProcessBuffers(loader, loadPlan);\n    }\n  }\n}\nfunction gatherPostProcessBuffers(loader, primitiveLoadPlan) {\n  const buffers = loader._postProcessBuffers;\n  const primitive = primitiveLoadPlan.primitive;\n  const outlineCoordinates = primitive.outlineCoordinates;\n  if (defined(outlineCoordinates)) {\n    // outline coordinates are always loaded as a buffer.\n    buffers.push(outlineCoordinates.buffer);\n  }\n\n  // to do post-processing, all the attributes are loaded as typed arrays\n  // so if a buffer exists, it was newly generated\n  const attributes = primitive.attributes;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      buffers.push(attribute.buffer);\n    }\n  }\n\n  // Similarly for the indices.\n  const indices = primitive.indices;\n  if (defined(indices) && defined(indices.buffer)) {\n    buffers.push(indices.buffer);\n  }\n}\n\n/**\n * Process loaders other than textures\n * @private\n */\nGltfLoader.prototype._process = function (frameState) {\n  if (this._state === GltfLoaderState.READY) {\n    return true;\n  }\n  if (this._state === GltfLoaderState.PROCESSING) {\n    processLoaders(this, frameState);\n  }\n  if (this._resourcesLoaded && this._state === GltfLoaderState.POST_PROCESSING) {\n    postProcessGeometry(this, frameState.context);\n    this._state = GltfLoaderState.PROCESSED;\n  }\n  if (this._resourcesLoaded && this._state === GltfLoaderState.PROCESSED) {\n    // The buffer views can be unloaded once the data is copied.\n    unloadBufferViewLoaders(this);\n\n    // Similarly, if the glTF was loaded from a typed array, release the memory\n    this._typedArray = undefined;\n    this._state = GltfLoaderState.READY;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Process textures other than textures\n * @private\n */\nGltfLoader.prototype._processTextures = function (frameState) {\n  if (this._textureState === GltfLoaderState.READY) {\n    return true;\n  }\n  if (this._textureState !== GltfLoaderState.PROCESSING) {\n    return false;\n  }\n  let ready = true;\n  const textureLoaders = this._textureLoaders;\n  for (let i = 0; i < textureLoaders.length; ++i) {\n    const textureReady = textureLoaders[i].process(frameState);\n    if (textureReady && defined(this._textureCallbacks[i])) {\n      this._textureCallbacks[i]();\n      this._textureCallbacks[i] = undefined;\n    }\n    ready = ready && textureReady;\n  }\n  if (!ready) {\n    return false;\n  }\n  this._textureState = GltfLoaderState.READY;\n  this._texturesLoaded = true;\n  return true;\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === GltfLoaderState.LOADED && !defined(this._loadResourcesPromise)) {\n    this._loadResourcesPromise = loadResources(this, frameState).then(() => {\n      this._resourcesLoaded = true;\n    }).catch(error => {\n      this._processError = error;\n    });\n  }\n  if (defined(this._processError)) {\n    this._state = GltfLoaderState.FAILED;\n    const error = this._processError;\n    this._processError = undefined;\n    handleError(this, error);\n  }\n\n  // Pop the next error of the list in case there are multiple\n  const textureError = this._textureErrors.pop();\n  if (defined(textureError)) {\n    // There shouldn't be the need to completely unload in this case. Just throw the error.\n    const error = this.getError(\"Failed to load glTF texture\", textureError);\n    error.name = \"TextureError\";\n    throw error;\n  }\n  if (this._state === GltfLoaderState.FAILED) {\n    return false;\n  }\n  let ready = false;\n  try {\n    ready = this._process(frameState);\n  } catch (error) {\n    this._state = GltfLoaderState.FAILED;\n    handleError(this, error);\n  }\n\n  // Since textures can be loaded independently and are handled through a separate promise, they are processed in their own function\n  let texturesReady = false;\n  try {\n    texturesReady = this._processTextures(frameState);\n  } catch (error) {\n    this._textureState = GltfLoaderState.FAILED;\n    handleError(this, error);\n  }\n  if (this._incrementallyLoadTextures) {\n    return ready;\n  }\n  return ready && texturesReady;\n};\nfunction getVertexBufferLoader(loader, accessorId, semantic, draco, loadBuffer, loadTypedArray, frameState) {\n  const gltf = loader.gltfJson;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n  const vertexBufferLoader = ResourceCache.getVertexBufferLoader({\n    gltf: gltf,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    frameState: frameState,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: semantic,\n    accessorId: accessorId,\n    asynchronous: loader._asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  return vertexBufferLoader;\n}\nfunction getIndexBufferLoader(loader, accessorId, draco, loadBuffer, loadTypedArray, frameState) {\n  const indexBufferLoader = ResourceCache.getIndexBufferLoader({\n    gltf: loader.gltfJson,\n    accessorId: accessorId,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    frameState: frameState,\n    draco: draco,\n    asynchronous: loader._asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  return indexBufferLoader;\n}\nfunction getBufferViewLoader(loader, bufferViewId) {\n  const bufferViewLoader = ResourceCache.getBufferViewLoader({\n    gltf: loader.gltfJson,\n    bufferViewId: bufferViewId,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource\n  });\n  loader._bufferViewLoaders.push(bufferViewLoader);\n  return bufferViewLoader;\n}\nfunction getPackedTypedArray(gltf, accessor, bufferViewTypedArray) {\n  let byteOffset = accessor.byteOffset;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const count = accessor.count;\n  const componentCount = numberOfComponentsForType(accessor.type);\n  const componentType = accessor.componentType;\n  const componentByteLength = ComponentDatatype.getSizeInBytes(componentType);\n  const defaultByteStride = componentByteLength * componentCount;\n  const componentsLength = count * componentCount;\n  if (byteStride === defaultByteStride) {\n    // Copy the typed array and let the underlying ArrayBuffer be freed\n    bufferViewTypedArray = new Uint8Array(bufferViewTypedArray);\n    return ComponentDatatype.createArrayBufferView(componentType, bufferViewTypedArray.buffer, bufferViewTypedArray.byteOffset + byteOffset, componentsLength);\n  }\n  const accessorTypedArray = ComponentDatatype.createTypedArray(componentType, componentsLength);\n  const dataView = new DataView(bufferViewTypedArray.buffer);\n  const components = new Array(componentCount);\n  const componentReader = getComponentReader(accessor.componentType);\n  byteOffset = bufferViewTypedArray.byteOffset + byteOffset;\n  for (let i = 0; i < count; ++i) {\n    componentReader(dataView, byteOffset, componentCount, componentByteLength, components);\n    for (let j = 0; j < componentCount; ++j) {\n      accessorTypedArray[i * componentCount + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n  return accessorTypedArray;\n}\nfunction loadDefaultAccessorValues(accessor, values) {\n  const accessorType = accessor.type;\n  if (accessorType === AttributeType.SCALAR) {\n    return values.fill(0);\n  }\n  const MathType = AttributeType.getMathType(accessorType);\n  return values.fill(MathType.clone(MathType.ZERO));\n}\nfunction loadAccessorValues(accessor, typedArray, values, useQuaternion) {\n  const accessorType = accessor.type;\n  const accessorCount = accessor.count;\n  if (accessorType === AttributeType.SCALAR) {\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = typedArray[i];\n    }\n  } else if (accessorType === AttributeType.VEC4 && useQuaternion) {\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = Quaternion.unpack(typedArray, i * 4);\n    }\n  } else {\n    const MathType = AttributeType.getMathType(accessorType);\n    const numberOfComponents = AttributeType.getNumberOfComponents(accessorType);\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = MathType.unpack(typedArray, i * numberOfComponents);\n    }\n  }\n  return values;\n}\nasync function loadAccessorBufferView(loader, bufferViewLoader, accessor, useQuaternion, values) {\n  // Save a link to the gltfJson, which is removed after bufferViewLoader.load()\n  const {\n    gltfJson\n  } = loader;\n  await bufferViewLoader.load();\n  if (loader.isDestroyed()) {\n    return;\n  }\n  const typedArray = getPackedTypedArray(gltfJson, accessor, bufferViewLoader.typedArray);\n  useQuaternion = defaultValue(useQuaternion, false);\n  loadAccessorValues(accessor, typedArray, values, useQuaternion);\n}\nfunction loadAccessor(loader, accessor, useQuaternion) {\n  const values = new Array(accessor.count);\n  const bufferViewId = accessor.bufferView;\n  if (defined(bufferViewId)) {\n    const bufferViewLoader = getBufferViewLoader(loader, bufferViewId);\n    const promise = loadAccessorBufferView(loader, bufferViewLoader, accessor, useQuaternion, values);\n    loader._loaderPromises.push(promise);\n    return values;\n  }\n  return loadDefaultAccessorValues(accessor, values);\n}\nfunction fromArray(MathType, values) {\n  if (!defined(values)) {\n    return undefined;\n  }\n  if (MathType === Number) {\n    return values[0];\n  }\n  return MathType.unpack(values);\n}\nfunction getDefault(MathType) {\n  if (MathType === Number) {\n    return 0.0;\n  }\n  return new MathType(); // defaults to 0.0 for all types\n}\nfunction getQuantizationDivisor(componentDatatype) {\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return 127;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return 255;\n    case ComponentDatatype.SHORT:\n      return 32767;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return 65535;\n    default:\n      return 1.0;\n  }\n}\nconst minimumBoundsByType = {\n  VEC2: new Cartesian2(-1.0, -1.0),\n  VEC3: new Cartesian3(-1.0, -1.0, -1.0),\n  VEC4: new Cartesian4(-1.0, -1.0, -1.0, -1.0)\n};\nfunction dequantizeMinMax(attribute, VectorType) {\n  const divisor = getQuantizationDivisor(attribute.componentDatatype);\n  const minimumBound = minimumBoundsByType[attribute.type];\n\n  // dequantized = max(quantized / divisor, -1.0)\n  let min = attribute.min;\n  if (defined(min)) {\n    min = VectorType.divideByScalar(min, divisor, min);\n    min = VectorType.maximumByComponent(min, minimumBound, min);\n  }\n  let max = attribute.max;\n  if (defined(max)) {\n    max = VectorType.divideByScalar(max, divisor, max);\n    max = VectorType.maximumByComponent(max, minimumBound, max);\n  }\n  attribute.min = min;\n  attribute.max = max;\n}\nfunction setQuantizationFromWeb3dQuantizedAttributes(extension, attribute, MathType) {\n  const decodeMatrix = extension.decodeMatrix;\n  const decodedMin = fromArray(MathType, extension.decodedMin);\n  const decodedMax = fromArray(MathType, extension.decodedMax);\n  if (defined(decodedMin) && defined(decodedMax)) {\n    attribute.min = decodedMin;\n    attribute.max = decodedMax;\n  }\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = attribute.componentDatatype;\n  quantization.type = attribute.type;\n  if (decodeMatrix.length === 4) {\n    quantization.quantizedVolumeOffset = decodeMatrix[2];\n    quantization.quantizedVolumeStepSize = decodeMatrix[0];\n  } else if (decodeMatrix.length === 9) {\n    quantization.quantizedVolumeOffset = new Cartesian2(decodeMatrix[6], decodeMatrix[7]);\n    quantization.quantizedVolumeStepSize = new Cartesian2(decodeMatrix[0], decodeMatrix[4]);\n  } else if (decodeMatrix.length === 16) {\n    quantization.quantizedVolumeOffset = new Cartesian3(decodeMatrix[12], decodeMatrix[13], decodeMatrix[14]);\n    quantization.quantizedVolumeStepSize = new Cartesian3(decodeMatrix[0], decodeMatrix[5], decodeMatrix[10]);\n  } else if (decodeMatrix.length === 25) {\n    quantization.quantizedVolumeOffset = new Cartesian4(decodeMatrix[20], decodeMatrix[21], decodeMatrix[22], decodeMatrix[23]);\n    quantization.quantizedVolumeStepSize = new Cartesian4(decodeMatrix[0], decodeMatrix[6], decodeMatrix[12], decodeMatrix[18]);\n  }\n  attribute.quantization = quantization;\n}\nfunction createAttribute(gltf, accessorId, name, semantic, setIndex) {\n  const accessor = gltf.accessors[accessorId];\n  const MathType = AttributeType.getMathType(accessor.type);\n  const normalized = defaultValue(accessor.normalized, false);\n  const attribute = new Attribute();\n  attribute.name = name;\n  attribute.semantic = semantic;\n  attribute.setIndex = setIndex;\n  attribute.constant = getDefault(MathType);\n  attribute.componentDatatype = accessor.componentType;\n  attribute.normalized = normalized;\n  attribute.count = accessor.count;\n  attribute.type = accessor.type;\n  attribute.min = fromArray(MathType, accessor.min);\n  attribute.max = fromArray(MathType, accessor.max);\n  attribute.byteOffset = accessor.byteOffset;\n  attribute.byteStride = getAccessorByteStride(gltf, accessor);\n  if (hasExtension(accessor, \"WEB3D_quantized_attributes\")) {\n    setQuantizationFromWeb3dQuantizedAttributes(accessor.extensions.WEB3D_quantized_attributes, attribute, MathType);\n  }\n  const isQuantizable = attribute.semantic === VertexAttributeSemantic.POSITION || attribute.semantic === VertexAttributeSemantic.NORMAL || attribute.semantic === VertexAttributeSemantic.TANGENT || attribute.semantic === VertexAttributeSemantic.TEXCOORD;\n\n  // In the glTF 2.0 spec, min and max are not affected by the normalized flag.\n  // However, for KHR_mesh_quantization, min and max must be dequantized for\n  // normalized values, else the bounding sphere will be computed incorrectly.\n  const hasKhrMeshQuantization = gltf.extensionsRequired?.includes(\"KHR_mesh_quantization\");\n  if (hasKhrMeshQuantization && normalized && isQuantizable) {\n    dequantizeMinMax(attribute, MathType);\n  }\n  return attribute;\n}\nfunction getSetIndex(gltfSemantic) {\n  const setIndexRegex = /^\\w+_(\\d+)$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    return parseInt(setIndexMatch[1]);\n  }\n  return undefined;\n}\nconst scratchSemanticInfo = {\n  gltfSemantic: undefined,\n  renamedSemantic: undefined,\n  modelSemantic: undefined\n};\nfunction getSemanticInfo(loader, semanticType, gltfSemantic) {\n  // For .b3dm, rename _BATCHID (or the legacy BATCHID) to _FEATURE_ID_0\n  // in the generated model components for compatibility with EXT_mesh_features\n  let renamedSemantic = gltfSemantic;\n  if (loader._renameBatchIdSemantic && (gltfSemantic === \"_BATCHID\" || gltfSemantic === \"BATCHID\")) {\n    renamedSemantic = \"_FEATURE_ID_0\";\n  }\n  const modelSemantic = semanticType.fromGltfSemantic(renamedSemantic);\n  const semanticInfo = scratchSemanticInfo;\n  semanticInfo.gltfSemantic = gltfSemantic;\n  semanticInfo.renamedSemantic = renamedSemantic;\n  semanticInfo.modelSemantic = modelSemantic;\n  return semanticInfo;\n}\nfunction isClassificationAttribute(attributeSemantic) {\n  // Classification models only use the position, texcoord, and feature ID attributes.\n  const isPositionAttribute = attributeSemantic === VertexAttributeSemantic.POSITION;\n  const isFeatureIdAttribute = attributeSemantic === VertexAttributeSemantic.FEATURE_ID;\n  const isTexcoordAttribute = attributeSemantic === VertexAttributeSemantic.TEXCOORD;\n  return isPositionAttribute || isFeatureIdAttribute || isTexcoordAttribute;\n}\nfunction finalizeDracoAttribute(attribute, vertexBufferLoader, loadBuffer, loadTypedArray) {\n  // The accessor's byteOffset and byteStride should be ignored for draco.\n  // Each attribute is tightly packed in its own buffer after decode.\n  attribute.byteOffset = 0;\n  attribute.byteStride = undefined;\n  attribute.quantization = vertexBufferLoader.quantization;\n  if (loadBuffer) {\n    attribute.buffer = vertexBufferLoader.buffer;\n  }\n  if (loadTypedArray) {\n    const componentDatatype = defined(vertexBufferLoader.quantization) ? vertexBufferLoader.quantization.componentDatatype : attribute.componentDatatype;\n    attribute.typedArray = ComponentDatatype.createArrayBufferView(componentDatatype, vertexBufferLoader.typedArray.buffer);\n  }\n}\nfunction finalizeAttribute(gltf, accessor, attribute, vertexBufferLoader, loadBuffer, loadTypedArray) {\n  if (loadBuffer) {\n    attribute.buffer = vertexBufferLoader.buffer;\n  }\n  if (loadTypedArray) {\n    const bufferViewTypedArray = vertexBufferLoader.typedArray;\n    attribute.typedArray = getPackedTypedArray(gltf, accessor, bufferViewTypedArray);\n    if (!loadBuffer) {\n      // If the buffer isn't loaded, then the accessor's byteOffset and\n      // byteStride should be ignored, since values are only available in a\n      // tightly packed typed array\n      attribute.byteOffset = 0;\n      attribute.byteStride = undefined;\n    }\n  }\n}\nfunction loadAttribute(loader, accessorId, semanticInfo, draco, loadBuffer, loadTypedArray, frameState) {\n  const gltf = loader.gltfJson;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n  const gltfSemantic = semanticInfo.gltfSemantic;\n  const renamedSemantic = semanticInfo.renamedSemantic;\n  const modelSemantic = semanticInfo.modelSemantic;\n  const setIndex = defined(modelSemantic) ? getSetIndex(renamedSemantic) : undefined;\n  const name = gltfSemantic;\n  const attribute = createAttribute(gltf, accessorId, name, modelSemantic, setIndex);\n  if (!defined(draco) && !defined(bufferViewId)) {\n    return attribute;\n  }\n  const vertexBufferLoader = getVertexBufferLoader(loader, accessorId, gltfSemantic, draco, loadBuffer, loadTypedArray, frameState);\n  const index = loader._geometryLoaders.length;\n  loader._geometryLoaders.push(vertexBufferLoader);\n  const promise = vertexBufferLoader.load();\n  loader._loaderPromises.push(promise);\n  // This can only execute once vertexBufferLoader.process() has run and returns true\n  // Save this finish callback by the loader index so it can be called\n  // in process().\n  loader._geometryCallbacks[index] = () => {\n    if (defined(draco) && defined(draco.attributes) && defined(draco.attributes[gltfSemantic])) {\n      finalizeDracoAttribute(attribute, vertexBufferLoader, loadBuffer, loadTypedArray);\n    } else {\n      finalizeAttribute(gltf, accessor, attribute, vertexBufferLoader, loadBuffer, loadTypedArray);\n    }\n  };\n  return attribute;\n}\nfunction loadVertexAttribute(loader, accessorId, semanticInfo, draco, hasInstances, needsPostProcessing, frameState) {\n  const modelSemantic = semanticInfo.modelSemantic;\n  const isPositionAttribute = modelSemantic === VertexAttributeSemantic.POSITION;\n  const isFeatureIdAttribute = modelSemantic === VertexAttributeSemantic.FEATURE_ID;\n  const loadTypedArrayFor2D = isPositionAttribute && !hasInstances && loader._loadAttributesFor2D && !frameState.scene3DOnly;\n  const loadTypedArrayForPicking = isPositionAttribute && loader._enablePick && !frameState.context.webgl2;\n  const loadTypedArrayForClassification = loader._loadForClassification && isFeatureIdAttribute;\n\n  // Whether the final output should be a buffer or typed array\n  // after loading and post-processing.\n  const outputTypedArrayOnly = loader._loadAttributesAsTypedArray;\n  const outputBuffer = !outputTypedArrayOnly;\n  const outputTypedArray = outputTypedArrayOnly || loadTypedArrayFor2D || loadTypedArrayForPicking || loadTypedArrayForClassification;\n\n  // Determine what to load right now:\n  //\n  // - If post-processing is needed, load a packed typed array for\n  //   further processing, and defer the buffer loading until later.\n  // - On the other hand, if post-processing is not needed,\n  //   set the load flags directly\n  const loadBuffer = needsPostProcessing ? false : outputBuffer;\n  const loadTypedArray = needsPostProcessing ? true : outputTypedArray;\n  const attribute = loadAttribute(loader, accessorId, semanticInfo, draco, loadBuffer, loadTypedArray, frameState);\n  const attributePlan = new PrimitiveLoadPlan.AttributeLoadPlan(attribute);\n  attributePlan.loadBuffer = outputBuffer;\n  attributePlan.loadTypedArray = outputTypedArray;\n  return attributePlan;\n}\nfunction loadInstancedAttribute(loader, accessorId, attributes, gltfSemantic, frameState) {\n  const accessors = loader.gltfJson.accessors;\n  const hasRotation = defined(attributes.ROTATION);\n  const hasTranslationMinMax = defined(attributes.TRANSLATION) && defined(accessors[attributes.TRANSLATION].min) && defined(accessors[attributes.TRANSLATION].max);\n  const semanticInfo = getSemanticInfo(loader, InstanceAttributeSemantic, gltfSemantic);\n  const modelSemantic = semanticInfo.modelSemantic;\n  const isTransformAttribute = modelSemantic === InstanceAttributeSemantic.TRANSLATION || modelSemantic === InstanceAttributeSemantic.ROTATION || modelSemantic === InstanceAttributeSemantic.SCALE;\n  const isTranslationAttribute = modelSemantic === InstanceAttributeSemantic.TRANSLATION;\n\n  // Load the attributes as typed arrays only if:\n  // - loadAttributesAsTypedArray is true\n  // - the instances have rotations. This only applies to the transform attributes,\n  //   since The instance matrices are computed on the CPU. This avoids the\n  //   expensive quaternion -> rotation matrix conversion in the shader.\n  // - GPU instancing is not supported.\n  const loadAsTypedArrayOnly = loader._loadAttributesAsTypedArray || hasRotation && isTransformAttribute || !frameState.context.instancedArrays;\n  const loadTypedArrayForPicking = loader._enablePick && !frameState.context.webgl2;\n  const loadBuffer = !loadAsTypedArrayOnly;\n\n  // Load the translations as a typed array in addition to the buffer if\n  // - the accessor does not have a min and max. The values will be used\n  //   for computing an accurate bounding volume.\n  // - the model will be projected to 2D.\n  const loadFor2D = loader._loadAttributesFor2D && !frameState.scene3DOnly;\n  const loadTranslationAsTypedArray = isTranslationAttribute && (!hasTranslationMinMax || loadFor2D || loadTypedArrayForPicking);\n  const loadTypedArray = loadAsTypedArrayOnly || loadTranslationAsTypedArray;\n\n  // Don't pass in draco object since instanced attributes can't be draco compressed\n  return loadAttribute(loader, accessorId, semanticInfo, undefined, loadBuffer, loadTypedArray, frameState);\n}\nfunction loadIndices(loader, accessorId, draco, hasFeatureIds, needsPostProcessing, frameState) {\n  const accessor = loader.gltfJson.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n  if (!defined(draco) && !defined(bufferViewId)) {\n    return undefined;\n  }\n  const indices = new Indices();\n  indices.count = accessor.count;\n  const loadAttributesAsTypedArray = loader._loadAttributesAsTypedArray;\n  // Load the index buffer as a typed array to generate wireframes or pick in WebGL1.\n  const loadForCpuOperations = (loader._loadIndicesForWireframe || loader._enablePick) && !frameState.context.webgl2;\n\n  // Load the index buffer as a typed array to batch features together for classification.\n  const loadForClassification = loader._loadForClassification && hasFeatureIds;\n\n  // Whether the final output should be a buffer or typed array\n  // after loading and post-processing.\n  const outputTypedArrayOnly = loadAttributesAsTypedArray;\n  const outputBuffer = !outputTypedArrayOnly;\n  const outputTypedArray = loadAttributesAsTypedArray || loadForCpuOperations || loadForClassification;\n\n  // Determine what to load right now:\n  //\n  // - If post-processing is needed, load a packed typed array for\n  //   further processing, and defer the buffer loading until later.\n  // - On the other hand, if post-processing is not needed, set the load\n  //   flags directly\n  const loadBuffer = needsPostProcessing ? false : outputBuffer;\n  const loadTypedArray = needsPostProcessing ? true : outputTypedArray;\n  const indexBufferLoader = getIndexBufferLoader(loader, accessorId, draco, loadBuffer, loadTypedArray, frameState);\n  const index = loader._geometryLoaders.length;\n  loader._geometryLoaders.push(indexBufferLoader);\n  const promise = indexBufferLoader.load();\n  loader._loaderPromises.push(promise);\n  // This can only execute once indexBufferLoader.process() has run and returns true\n  // Save this finish callback by the loader index so it can be called\n  // in process().\n  loader._geometryCallbacks[index] = () => {\n    indices.indexDatatype = indexBufferLoader.indexDatatype;\n    indices.buffer = indexBufferLoader.buffer;\n    indices.typedArray = indexBufferLoader.typedArray;\n  };\n  const indicesPlan = new PrimitiveLoadPlan.IndicesLoadPlan(indices);\n  indicesPlan.loadBuffer = outputBuffer;\n  indicesPlan.loadTypedArray = outputTypedArray;\n  return indicesPlan;\n}\nfunction loadTexture(loader, textureInfo, frameState, samplerOverride) {\n  const gltf = loader.gltfJson;\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureInfo.index,\n    supportedImageFormats: loader._supportedImageFormats\n  });\n  if (!defined(imageId)) {\n    return undefined;\n  }\n  const textureLoader = ResourceCache.getTextureLoader({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: loader._supportedImageFormats,\n    frameState: frameState,\n    asynchronous: loader._asynchronous\n  });\n  const textureReader = GltfLoaderUtil.createModelTextureReader({\n    textureInfo: textureInfo\n  });\n  const index = loader._textureLoaders.length;\n  loader._textureLoaders.push(textureLoader);\n  const promise = textureLoader.load().catch(error => {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    if (!loader._incrementallyLoadTextures) {\n      // If incrementallyLoadTextures is false, throw the error to ensure the loader state\n      // immediately is set to have failed\n      throw error;\n    }\n\n    // Otherwise, save the error so it can be thrown next\n    loader._textureState = GltfLoaderState.FAILED;\n    loader._textureErrors.push(error);\n  });\n  loader._texturesPromises.push(promise);\n  // This can only execute once textureLoader.process() has run and returns true\n  // Save this finish callback by the loader index so it can be called\n  // in process().\n  loader._textureCallbacks[index] = () => {\n    textureReader.texture = textureLoader.texture;\n    if (defined(samplerOverride)) {\n      textureReader.texture.sampler = samplerOverride;\n    }\n  };\n  return textureReader;\n}\n\n/**\n * Load textures and parse factors for the KHR_materials_pbrSpecularGlossiness extension\n * @param {GltfLoader} loader\n * @param {object} specularGlossinessInfo The contents of the KHR_materials_pbrSpecularGlossiness extension in the parsed glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.SpecularGlossiness}\n * @private\n */\nfunction loadSpecularGlossiness(loader, specularGlossinessInfo, frameState) {\n  const {\n    diffuseTexture,\n    specularGlossinessTexture,\n    diffuseFactor,\n    specularFactor,\n    glossinessFactor\n  } = specularGlossinessInfo;\n  const specularGlossiness = new SpecularGlossiness();\n  if (defined(diffuseTexture)) {\n    specularGlossiness.diffuseTexture = loadTexture(loader, diffuseTexture, frameState);\n  }\n  if (defined(specularGlossinessTexture)) {\n    specularGlossiness.specularGlossinessTexture = loadTexture(loader, specularGlossinessTexture, frameState);\n  }\n  specularGlossiness.diffuseFactor = fromArray(Cartesian4, diffuseFactor);\n  specularGlossiness.specularFactor = fromArray(Cartesian3, specularFactor);\n  specularGlossiness.glossinessFactor = glossinessFactor;\n  return specularGlossiness;\n}\n\n/**\n * Load textures and parse factors for a metallic-roughness PBR model in a glTF material\n * @param {GltfLoader} loader\n * @param {object} metallicRoughnessInfo The contents of a pbrMetallicRoughness property in the parsed glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.MetallicRoughness}\n * @private\n */\nfunction loadMetallicRoughness(loader, metallicRoughnessInfo, frameState) {\n  const {\n    baseColorTexture,\n    metallicRoughnessTexture,\n    baseColorFactor,\n    metallicFactor,\n    roughnessFactor\n  } = metallicRoughnessInfo;\n  const metallicRoughness = new MetallicRoughness();\n  if (defined(baseColorTexture)) {\n    metallicRoughness.baseColorTexture = loadTexture(loader, baseColorTexture, frameState);\n  }\n  if (defined(metallicRoughnessTexture)) {\n    metallicRoughness.metallicRoughnessTexture = loadTexture(loader, metallicRoughnessTexture, frameState);\n  }\n  metallicRoughness.baseColorFactor = fromArray(Cartesian4, baseColorFactor);\n  metallicRoughness.metallicFactor = metallicFactor;\n  metallicRoughness.roughnessFactor = roughnessFactor;\n  return metallicRoughness;\n}\nfunction loadSpecular(loader, specularInfo, frameState) {\n  const {\n    specularFactor,\n    specularTexture,\n    specularColorFactor,\n    specularColorTexture\n  } = specularInfo;\n  const specular = new Specular();\n  if (defined(specularTexture)) {\n    specular.specularTexture = loadTexture(loader, specularTexture, frameState);\n  }\n  if (defined(specularColorTexture)) {\n    specular.specularColorTexture = loadTexture(loader, specularColorTexture, frameState);\n  }\n  specular.specularFactor = specularFactor;\n  specular.specularColorFactor = fromArray(Cartesian3, specularColorFactor);\n  return specular;\n}\nfunction loadAnisotropy(loader, anisotropyInfo, frameState) {\n  const {\n    anisotropyStrength = Anisotropy.DEFAULT_ANISOTROPY_STRENGTH,\n    anisotropyRotation = Anisotropy.DEFAULT_ANISOTROPY_ROTATION,\n    anisotropyTexture\n  } = anisotropyInfo;\n  const anisotropy = new Anisotropy();\n  if (defined(anisotropyTexture)) {\n    anisotropy.anisotropyTexture = loadTexture(loader, anisotropyTexture, frameState);\n  }\n  anisotropy.anisotropyStrength = anisotropyStrength;\n  anisotropy.anisotropyRotation = anisotropyRotation;\n  return anisotropy;\n}\nfunction loadClearcoat(loader, clearcoatInfo, frameState) {\n  const {\n    clearcoatFactor = Clearcoat.DEFAULT_CLEARCOAT_FACTOR,\n    clearcoatTexture,\n    clearcoatRoughnessFactor = Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture\n  } = clearcoatInfo;\n  const clearcoat = new Clearcoat();\n  if (defined(clearcoatTexture)) {\n    clearcoat.clearcoatTexture = loadTexture(loader, clearcoatTexture, frameState);\n  }\n  if (defined(clearcoatRoughnessTexture)) {\n    clearcoat.clearcoatRoughnessTexture = loadTexture(loader, clearcoatRoughnessTexture, frameState);\n  }\n  if (defined(clearcoatNormalTexture)) {\n    clearcoat.clearcoatNormalTexture = loadTexture(loader, clearcoatNormalTexture, frameState);\n  }\n  clearcoat.clearcoatFactor = clearcoatFactor;\n  clearcoat.clearcoatRoughnessFactor = clearcoatRoughnessFactor;\n  return clearcoat;\n}\n\n/**\n * Load textures and parse factors and flags for a glTF material\n *\n * @param {GltfLoader} loader\n * @param {object} gltfMaterial An entry from the <code>.materials</code> array in the glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.Material}\n * @private\n */\nfunction loadMaterial(loader, gltfMaterial, frameState) {\n  const material = new Material();\n  const extensions = defaultValue(gltfMaterial.extensions, defaultValue.EMPTY_OBJECT);\n  const pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;\n  const pbrSpecular = extensions.KHR_materials_specular;\n  const pbrAnisotropy = extensions.KHR_materials_anisotropy;\n  const pbrClearcoat = extensions.KHR_materials_clearcoat;\n  const pbrMetallicRoughness = gltfMaterial.pbrMetallicRoughness;\n  material.unlit = defined(extensions.KHR_materials_unlit);\n  if (defined(pbrSpecularGlossiness)) {\n    material.specularGlossiness = loadSpecularGlossiness(loader, pbrSpecularGlossiness, frameState);\n  } else {\n    if (defined(pbrMetallicRoughness)) {\n      material.metallicRoughness = loadMetallicRoughness(loader, pbrMetallicRoughness, frameState);\n    }\n    if (defined(pbrSpecular) && !material.unlit) {\n      material.specular = loadSpecular(loader, pbrSpecular, frameState);\n    }\n    if (defined(pbrAnisotropy) && !material.unlit) {\n      material.anisotropy = loadAnisotropy(loader, pbrAnisotropy, frameState);\n    }\n    if (defined(pbrClearcoat) && !material.unlit) {\n      material.clearcoat = loadClearcoat(loader, pbrClearcoat, frameState);\n    }\n  }\n\n  // Top level textures\n  if (defined(gltfMaterial.emissiveTexture)) {\n    material.emissiveTexture = loadTexture(loader, gltfMaterial.emissiveTexture, frameState);\n  }\n  // Normals aren't used for classification, so don't load the normal texture.\n  if (defined(gltfMaterial.normalTexture) && !loader._loadForClassification) {\n    material.normalTexture = loadTexture(loader, gltfMaterial.normalTexture, frameState);\n  }\n  if (defined(gltfMaterial.occlusionTexture)) {\n    material.occlusionTexture = loadTexture(loader, gltfMaterial.occlusionTexture, frameState);\n  }\n  material.emissiveFactor = fromArray(Cartesian3, gltfMaterial.emissiveFactor);\n  material.alphaMode = gltfMaterial.alphaMode;\n  material.alphaCutoff = gltfMaterial.alphaCutoff;\n  material.doubleSided = gltfMaterial.doubleSided;\n  return material;\n}\n\n// for EXT_mesh_features\nfunction loadFeatureIdAttribute(featureIds, positionalLabel) {\n  const featureIdAttribute = new FeatureIdAttribute();\n  featureIdAttribute.featureCount = featureIds.featureCount;\n  featureIdAttribute.nullFeatureId = featureIds.nullFeatureId;\n  featureIdAttribute.propertyTableId = featureIds.propertyTable;\n  featureIdAttribute.setIndex = featureIds.attribute;\n  featureIdAttribute.label = featureIds.label;\n  featureIdAttribute.positionalLabel = positionalLabel;\n  return featureIdAttribute;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdAttributeLegacy(gltfFeatureIdAttribute, featureTableId, featureCount, positionalLabel) {\n  const featureIdAttribute = new FeatureIdAttribute();\n  const featureIds = gltfFeatureIdAttribute.featureIds;\n  featureIdAttribute.featureCount = featureCount;\n  featureIdAttribute.propertyTableId = featureTableId;\n  featureIdAttribute.setIndex = getSetIndex(featureIds.attribute);\n  featureIdAttribute.positionalLabel = positionalLabel;\n  return featureIdAttribute;\n}\n\n// implicit ranges do not exist in EXT_mesh_features and EXT_instance_features,\n// but both default to the vertex/instance ID which is like\n// an implicit range of {offset: 0, repeat: 1}\nfunction loadDefaultFeatureIds(featureIds, positionalLabel) {\n  const featureIdRange = new FeatureIdImplicitRange();\n  featureIdRange.propertyTableId = featureIds.propertyTable;\n  featureIdRange.featureCount = featureIds.featureCount;\n  featureIdRange.nullFeatureId = featureIds.nullFeatureId;\n  featureIdRange.label = featureIds.label;\n  featureIdRange.positionalLabel = positionalLabel;\n  featureIdRange.offset = 0;\n  featureIdRange.repeat = 1;\n  return featureIdRange;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdImplicitRangeLegacy(gltfFeatureIdAttribute, featureTableId, featureCount, positionalLabel) {\n  const featureIdRange = new FeatureIdImplicitRange();\n  const featureIds = gltfFeatureIdAttribute.featureIds;\n  featureIdRange.propertyTableId = featureTableId;\n  featureIdRange.featureCount = featureCount;\n\n  // constant/divisor was renamed to offset/repeat\n  featureIdRange.offset = defaultValue(featureIds.constant, 0);\n  // The default is now undefined\n  const divisor = defaultValue(featureIds.divisor, 0);\n  featureIdRange.repeat = divisor === 0 ? undefined : divisor;\n  featureIdRange.positionalLabel = positionalLabel;\n  return featureIdRange;\n}\n\n// for EXT_mesh_features\nfunction loadFeatureIdTexture(loader, gltfFeatureIdTexture, frameState, positionalLabel) {\n  const featureIdTexture = new FeatureIdTexture();\n  featureIdTexture.featureCount = gltfFeatureIdTexture.featureCount;\n  featureIdTexture.nullFeatureId = gltfFeatureIdTexture.nullFeatureId;\n  featureIdTexture.propertyTableId = gltfFeatureIdTexture.propertyTable;\n  featureIdTexture.label = gltfFeatureIdTexture.label;\n  featureIdTexture.positionalLabel = positionalLabel;\n  const textureInfo = gltfFeatureIdTexture.texture;\n  featureIdTexture.textureReader = loadTexture(loader, textureInfo, frameState, Sampler.NEAREST // Feature ID textures require nearest sampling\n  );\n\n  // Though the new channel index is more future-proof, this implementation\n  // only supports RGBA textures. At least for now, the string representation\n  // is more useful for generating shader code.\n  const channels = defined(textureInfo.channels) ? textureInfo.channels : [0];\n  const channelString = channels.map(function (channelIndex) {\n    return \"rgba\".charAt(channelIndex);\n  }).join(\"\");\n  featureIdTexture.textureReader.channels = channelString;\n  return featureIdTexture;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdTextureLegacy(loader, gltfFeatureIdTexture, featureTableId, frameState, featureCount, positionalLabel) {\n  const featureIdTexture = new FeatureIdTexture();\n  const featureIds = gltfFeatureIdTexture.featureIds;\n  const textureInfo = featureIds.texture;\n  featureIdTexture.featureCount = featureCount;\n  featureIdTexture.propertyTableId = featureTableId;\n  featureIdTexture.textureReader = loadTexture(loader, textureInfo, frameState, Sampler.NEAREST // Feature ID textures require nearest sampling\n  );\n  featureIdTexture.textureReader.channels = featureIds.channels;\n  featureIdTexture.positionalLabel = positionalLabel;\n  return featureIdTexture;\n}\nfunction loadMorphTarget(loader, target, needsPostProcessing, primitiveLoadPlan, frameState) {\n  const morphTarget = new MorphTarget();\n\n  // Don't pass in draco object since morph targets can't be draco compressed\n  const draco = undefined;\n  const hasInstances = false;\n  for (const semantic in target) {\n    if (!target.hasOwnProperty(semantic)) {\n      continue;\n    }\n    const accessorId = target[semantic];\n    const semanticInfo = getSemanticInfo(loader, VertexAttributeSemantic, semantic);\n    const attributePlan = loadVertexAttribute(loader, accessorId, semanticInfo, draco, hasInstances, needsPostProcessing, frameState);\n    morphTarget.attributes.push(attributePlan.attribute);\n\n    // The load plan doesn't need to distinguish morph target attributes from\n    // regular attributes\n    primitiveLoadPlan.attributePlans.push(attributePlan);\n  }\n  return morphTarget;\n}\n\n/**\n * Load resources associated with a mesh primitive for a glTF node\n * @param {GltfLoader} loader\n * @param {object} gltfPrimitive One of the primitives in a mesh\n * @param {boolean} hasInstances True if the node using this mesh has instances\n * @param {FrameState} frameState\n * @returns {ModelComponents.Primitive}\n * @private\n */\nfunction loadPrimitive(loader, gltfPrimitive, hasInstances, frameState) {\n  const primitive = new Primitive();\n  const primitivePlan = new PrimitiveLoadPlan(primitive);\n  loader._primitiveLoadPlans.push(primitivePlan);\n  const materialId = gltfPrimitive.material;\n  if (defined(materialId)) {\n    primitive.material = loadMaterial(loader, loader.gltfJson.materials[materialId], frameState);\n  }\n  const extensions = defaultValue(gltfPrimitive.extensions, defaultValue.EMPTY_OBJECT);\n  let needsPostProcessing = false;\n  const outlineExtension = extensions.CESIUM_primitive_outline;\n  if (loader._loadPrimitiveOutline && defined(outlineExtension)) {\n    needsPostProcessing = true;\n    primitivePlan.needsOutlines = true;\n    primitivePlan.outlineIndices = loadPrimitiveOutline(loader, outlineExtension, primitivePlan);\n  }\n  const loadForClassification = loader._loadForClassification;\n  const draco = extensions.KHR_draco_mesh_compression;\n  let hasFeatureIds = false;\n  const attributes = gltfPrimitive.attributes;\n  if (defined(attributes)) {\n    for (const semantic in attributes) {\n      if (!attributes.hasOwnProperty(semantic)) {\n        continue;\n      }\n      const accessorId = attributes[semantic];\n      const semanticInfo = getSemanticInfo(loader, VertexAttributeSemantic, semantic);\n      const modelSemantic = semanticInfo.modelSemantic;\n      if (loadForClassification && !isClassificationAttribute(modelSemantic)) {\n        continue;\n      }\n      if (modelSemantic === VertexAttributeSemantic.FEATURE_ID) {\n        hasFeatureIds = true;\n      }\n      const attributePlan = loadVertexAttribute(loader, accessorId, semanticInfo, draco, hasInstances, needsPostProcessing, frameState);\n      primitivePlan.attributePlans.push(attributePlan);\n      primitive.attributes.push(attributePlan.attribute);\n    }\n  }\n  const targets = gltfPrimitive.targets;\n  // Morph targets are disabled for classification models.\n  if (defined(targets) && !loadForClassification) {\n    for (let i = 0; i < targets.length; ++i) {\n      primitive.morphTargets.push(loadMorphTarget(loader, targets[i], needsPostProcessing, primitivePlan, frameState));\n    }\n  }\n  const indices = gltfPrimitive.indices;\n  if (defined(indices)) {\n    const indicesPlan = loadIndices(loader, indices, draco, hasFeatureIds, needsPostProcessing, frameState);\n    if (defined(indicesPlan)) {\n      primitivePlan.indicesPlan = indicesPlan;\n      primitive.indices = indicesPlan.indices;\n    }\n  }\n\n  // With the latest revision, feature IDs are defined in EXT_mesh_features\n  // while EXT_structural_metadata is for defining property textures and\n  // property mappings. In the legacy EXT_feature_metadata, these concepts\n  // were all in one extension.\n  const structuralMetadata = extensions.EXT_structural_metadata;\n  const meshFeatures = extensions.EXT_mesh_features;\n  const featureMetadataLegacy = extensions.EXT_feature_metadata;\n  const hasFeatureMetadataLegacy = defined(featureMetadataLegacy);\n\n  // Load feature Ids\n  if (defined(meshFeatures)) {\n    loadPrimitiveFeatures(loader, primitive, meshFeatures, frameState);\n  } else if (hasFeatureMetadataLegacy) {\n    loadPrimitiveFeaturesLegacy(loader, primitive, featureMetadataLegacy, frameState);\n  }\n\n  // Load structural metadata\n  if (defined(structuralMetadata)) {\n    loadPrimitiveMetadata(primitive, structuralMetadata);\n  } else if (hasFeatureMetadataLegacy) {\n    loadPrimitiveMetadataLegacy(loader, primitive, featureMetadataLegacy);\n  }\n  const primitiveType = gltfPrimitive.mode;\n  if (loadForClassification && primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new RuntimeError(\"Only triangle meshes can be used for classification.\");\n  }\n  primitive.primitiveType = primitiveType;\n  return primitive;\n}\nfunction loadPrimitiveOutline(loader, outlineExtension) {\n  const accessorId = outlineExtension.indices;\n  const accessor = loader.gltfJson.accessors[accessorId];\n  const useQuaternion = false;\n  return loadAccessor(loader, accessor, useQuaternion);\n}\n\n// For EXT_mesh_features\nfunction loadPrimitiveFeatures(loader, primitive, meshFeaturesExtension, frameState) {\n  let featureIdsArray;\n  if (defined(meshFeaturesExtension) && defined(meshFeaturesExtension.featureIds)) {\n    featureIdsArray = meshFeaturesExtension.featureIds;\n  } else {\n    featureIdsArray = [];\n  }\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const label = `featureId_${i}`;\n    let featureIdComponent;\n    if (defined(featureIds.texture)) {\n      featureIdComponent = loadFeatureIdTexture(loader, featureIds, frameState, label);\n    } else if (defined(featureIds.attribute)) {\n      featureIdComponent = loadFeatureIdAttribute(featureIds, label);\n    } else {\n      // default to vertex ID, in other words an implicit range with\n      // offset: 0, repeat: 1\n      featureIdComponent = loadDefaultFeatureIds(featureIds, label);\n    }\n    primitive.featureIds.push(featureIdComponent);\n  }\n}\n\n// For EXT_feature_metadata\nfunction loadPrimitiveFeaturesLegacy(loader, primitive, metadataExtension, frameState) {\n  // For looking up the featureCount for each set of feature IDs\n  const {\n    featureTables\n  } = loader.gltfJson.extensions.EXT_feature_metadata;\n  let nextFeatureIdIndex = 0;\n\n  // Feature ID Attributes\n  const featureIdAttributes = metadataExtension.featureIdAttributes;\n  if (defined(featureIdAttributes)) {\n    for (let i = 0; i < featureIdAttributes.length; ++i) {\n      const featureIdAttribute = featureIdAttributes[i];\n      const featureTableId = featureIdAttribute.featureTable;\n      const propertyTableId = loader._sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const label = `featureId_${nextFeatureIdIndex}`;\n      nextFeatureIdIndex++;\n      let featureIdComponent;\n      if (defined(featureIdAttribute.featureIds.attribute)) {\n        featureIdComponent = loadFeatureIdAttributeLegacy(featureIdAttribute, propertyTableId, featureCount, label);\n      } else {\n        featureIdComponent = loadFeatureIdImplicitRangeLegacy(featureIdAttribute, propertyTableId, featureCount, label);\n      }\n      primitive.featureIds.push(featureIdComponent);\n    }\n  }\n\n  // Feature ID Textures\n  const featureIdTextures = metadataExtension.featureIdTextures;\n  if (defined(featureIdTextures)) {\n    for (let i = 0; i < featureIdTextures.length; ++i) {\n      const featureIdTexture = featureIdTextures[i];\n      const featureTableId = featureIdTexture.featureTable;\n      const propertyTableId = loader._sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const featureIdLabel = `featureId_${nextFeatureIdIndex}`;\n      nextFeatureIdIndex++;\n      const featureIdComponent = loadFeatureIdTextureLegacy(loader, featureIdTexture, propertyTableId, frameState, featureCount, featureIdLabel);\n      // Feature ID textures are added after feature ID attributes in the list\n      primitive.featureIds.push(featureIdComponent);\n    }\n  }\n}\n\n// For primitive-level EXT_structural_metadata\nfunction loadPrimitiveMetadata(primitive, structuralMetadataExtension) {\n  if (!defined(structuralMetadataExtension)) {\n    return;\n  }\n\n  // Property Textures\n  if (defined(structuralMetadataExtension.propertyTextures)) {\n    primitive.propertyTextureIds = structuralMetadataExtension.propertyTextures;\n  }\n\n  // Property Attributes\n  if (defined(structuralMetadataExtension.propertyAttributes)) {\n    primitive.propertyAttributeIds = structuralMetadataExtension.propertyAttributes;\n  }\n}\n\n// For EXT_feature_metadata\nfunction loadPrimitiveMetadataLegacy(loader, primitive, metadataExtension) {\n  // Feature Textures\n  if (defined(metadataExtension.featureTextures)) {\n    // feature textures are now identified by an integer index. To convert the\n    // string IDs to integers, find their place in the sorted list of feature\n    // table names\n    primitive.propertyTextureIds = metadataExtension.featureTextures.map(function (id) {\n      return loader._sortedFeatureTextureIds.indexOf(id);\n    });\n  }\n}\nfunction loadInstances(loader, nodeExtensions, frameState) {\n  const instancingExtension = nodeExtensions.EXT_mesh_gpu_instancing;\n  const instances = new Instances();\n  const attributes = instancingExtension.attributes;\n  if (defined(attributes)) {\n    for (const semantic in attributes) {\n      if (!attributes.hasOwnProperty(semantic)) {\n        continue;\n      }\n      const accessorId = attributes[semantic];\n      instances.attributes.push(loadInstancedAttribute(loader, accessorId, attributes, semantic, frameState));\n    }\n  }\n  const instancingExtExtensions = defaultValue(instancingExtension.extensions, defaultValue.EMPTY_OBJECT);\n  const instanceFeatures = nodeExtensions.EXT_instance_features;\n  const featureMetadataLegacy = instancingExtExtensions.EXT_feature_metadata;\n  if (defined(instanceFeatures)) {\n    loadInstanceFeatures(instances, instanceFeatures);\n  } else if (defined(featureMetadataLegacy)) {\n    loadInstanceFeaturesLegacy(loader.gltfJson, instances, featureMetadataLegacy, loader._sortedPropertyTableIds);\n  }\n  return instances;\n}\n\n// For EXT_mesh_features\nfunction loadInstanceFeatures(instances, instanceFeaturesExtension) {\n  // feature IDs are required in EXT_instance_features\n  const featureIdsArray = instanceFeaturesExtension.featureIds;\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const label = `instanceFeatureId_${i}`;\n    let featureIdComponent;\n    if (defined(featureIds.attribute)) {\n      featureIdComponent = loadFeatureIdAttribute(featureIds, label);\n    } else {\n      // in EXT_instance_features, the default is to assign IDs by instance\n      // ID. This can be expressed with offset: 0, repeat: 1\n      featureIdComponent = loadDefaultFeatureIds(featureIds, label);\n    }\n    instances.featureIds.push(featureIdComponent);\n  }\n}\n\n// For backwards-compatibility with EXT_feature_metadata\nfunction loadInstanceFeaturesLegacy(gltf, instances, metadataExtension, sortedPropertyTableIds) {\n  // For looking up the featureCount for each set of feature IDs\n  const featureTables = gltf.extensions.EXT_feature_metadata.featureTables;\n  const featureIdAttributes = metadataExtension.featureIdAttributes;\n  if (defined(featureIdAttributes)) {\n    for (let i = 0; i < featureIdAttributes.length; ++i) {\n      const featureIdAttribute = featureIdAttributes[i];\n      const featureTableId = featureIdAttribute.featureTable;\n      const propertyTableId = sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const label = `instanceFeatureId_${i}`;\n      let featureIdComponent;\n      if (defined(featureIdAttribute.featureIds.attribute)) {\n        featureIdComponent = loadFeatureIdAttributeLegacy(featureIdAttribute, propertyTableId, featureCount, label);\n      } else {\n        featureIdComponent = loadFeatureIdImplicitRangeLegacy(featureIdAttribute, propertyTableId, featureCount, label);\n      }\n      instances.featureIds.push(featureIdComponent);\n    }\n  }\n}\n\n/**\n * Load resources associated with one node from a glTF JSON\n * @param {GltfLoader} loader\n * @param {object} gltfNode An entry from the <code>.nodes</code> array in the glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.Node}\n * @private\n */\nfunction loadNode(loader, gltfNode, frameState) {\n  const node = new Node();\n  node.name = gltfNode.name;\n  node.matrix = fromArray(Matrix4, gltfNode.matrix);\n  node.translation = fromArray(Cartesian3, gltfNode.translation);\n  node.rotation = fromArray(Quaternion, gltfNode.rotation);\n  node.scale = fromArray(Cartesian3, gltfNode.scale);\n  const nodeExtensions = defaultValue(gltfNode.extensions, defaultValue.EMPTY_OBJECT);\n  const instancingExtension = nodeExtensions.EXT_mesh_gpu_instancing;\n  const articulationsExtension = nodeExtensions.AGI_articulations;\n  if (defined(instancingExtension)) {\n    if (loader._loadForClassification) {\n      throw new RuntimeError(\"Models with the EXT_mesh_gpu_instancing extension cannot be used for classification.\");\n    }\n    node.instances = loadInstances(loader, nodeExtensions, frameState);\n  }\n  if (defined(articulationsExtension)) {\n    node.articulationName = articulationsExtension.articulationName;\n  }\n  const meshId = gltfNode.mesh;\n  if (defined(meshId)) {\n    const mesh = loader.gltfJson.meshes[meshId];\n    const primitives = mesh.primitives;\n    for (let i = 0; i < primitives.length; ++i) {\n      node.primitives.push(loadPrimitive(loader, primitives[i], defined(node.instances), frameState));\n    }\n\n    // If the node has no weights array, it will look for the weights array provided\n    // by the mesh. If both are undefined, it will default to an array of zero weights.\n    const morphWeights = defaultValue(gltfNode.weights, mesh.weights);\n    const targets = node.primitives[0].morphTargets;\n\n    // Since meshes are not stored as separate components, the mesh weights will still\n    // be stored at the node level.\n    node.morphWeights = defined(morphWeights) ? morphWeights.slice() : new Array(targets.length).fill(0.0);\n  }\n  return node;\n}\n\n/**\n * Load resources associated with the nodes in a glTF JSON\n * @param {GltfLoader} loader\n * @param {FrameState} frameState\n * @returns {ModelComponents.Node[]}\n * @private\n */\nfunction loadNodes(loader, frameState) {\n  const nodeJsons = loader.gltfJson.nodes;\n  if (!defined(nodeJsons)) {\n    return [];\n  }\n  const loadedNodes = nodeJsons.map(function (nodeJson, i) {\n    const node = loadNode(loader, nodeJson, frameState);\n    node.index = i;\n    return node;\n  });\n  for (let i = 0; i < loadedNodes.length; ++i) {\n    const childrenNodeIds = nodeJsons[i].children;\n    if (defined(childrenNodeIds)) {\n      for (let j = 0; j < childrenNodeIds.length; ++j) {\n        loadedNodes[i].children.push(loadedNodes[childrenNodeIds[j]]);\n      }\n    }\n  }\n  return loadedNodes;\n}\nfunction loadSkin(loader, gltfSkin, nodes) {\n  const skin = new Skin();\n  const jointIds = gltfSkin.joints;\n  skin.joints = jointIds.map(jointId => nodes[jointId]);\n  const inverseBindMatricesAccessorId = gltfSkin.inverseBindMatrices;\n  if (defined(inverseBindMatricesAccessorId)) {\n    const accessor = loader.gltfJson.accessors[inverseBindMatricesAccessorId];\n    skin.inverseBindMatrices = loadAccessor(loader, accessor);\n  } else {\n    skin.inverseBindMatrices = new Array(jointIds.length).fill(Matrix4.IDENTITY);\n  }\n  return skin;\n}\nfunction loadSkins(loader, nodes) {\n  const skinJsons = loader.gltfJson.skins;\n\n  // Skins are disabled for classification models.\n  if (loader._loadForClassification || !defined(skinJsons)) {\n    return [];\n  }\n  const loadedSkins = skinJsons.map(function (skinJson, i) {\n    const skin = loadSkin(loader, skinJson, nodes);\n    skin.index = i;\n    return skin;\n  });\n  const nodeJsons = loader.gltfJson.nodes;\n  for (let i = 0; i < nodes.length; ++i) {\n    const skinId = nodeJsons[i].skin;\n    if (defined(skinId)) {\n      nodes[i].skin = loadedSkins[skinId];\n    }\n  }\n  return loadedSkins;\n}\nasync function loadStructuralMetadata(loader, extension, extensionLegacy, frameState) {\n  const structuralMetadataLoader = new GltfStructuralMetadataLoader({\n    gltf: loader.gltfJson,\n    extension: extension,\n    extensionLegacy: extensionLegacy,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: loader._supportedImageFormats,\n    frameState: frameState,\n    asynchronous: loader._asynchronous\n  });\n  loader._structuralMetadataLoader = structuralMetadataLoader;\n  return structuralMetadataLoader.load();\n}\nasync function loadMeshPrimitiveGpm(loader, gltf, extension, frameState) {\n  const meshPrimitiveGpmLoader = new GltfMeshPrimitiveGpmLoader({\n    gltf: gltf,\n    extension: extension,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: loader._supportedImageFormats,\n    frameState: frameState,\n    asynchronous: loader._asynchronous\n  });\n  loader._meshPrimitiveGpmLoader = meshPrimitiveGpmLoader;\n  return meshPrimitiveGpmLoader.load();\n}\nfunction loadAnimationSampler(loader, gltfSampler) {\n  const animationSampler = new AnimationSampler();\n  const accessors = loader.gltfJson.accessors;\n  const inputAccessor = accessors[gltfSampler.input];\n  animationSampler.input = loadAccessor(loader, inputAccessor);\n  const gltfInterpolation = gltfSampler.interpolation;\n  animationSampler.interpolation = defaultValue(InterpolationType[gltfInterpolation], InterpolationType.LINEAR);\n  const outputAccessor = accessors[gltfSampler.output];\n  animationSampler.output = loadAccessor(loader, outputAccessor, true);\n  return animationSampler;\n}\nfunction loadAnimationTarget(gltfTarget, nodes) {\n  const animationTarget = new AnimationTarget();\n  const nodeIndex = gltfTarget.node;\n  // If the node isn't defined, the animation channel should be ignored.\n  // It's easiest to signal this by returning undefined.\n  if (!defined(nodeIndex)) {\n    return undefined;\n  }\n  animationTarget.node = nodes[nodeIndex];\n  const path = gltfTarget.path.toUpperCase();\n  animationTarget.path = AnimatedPropertyType[path];\n  return animationTarget;\n}\nfunction loadAnimationChannel(gltfChannel, samplers, nodes) {\n  const animationChannel = new AnimationChannel();\n  const samplerIndex = gltfChannel.sampler;\n  animationChannel.sampler = samplers[samplerIndex];\n  animationChannel.target = loadAnimationTarget(gltfChannel.target, nodes);\n  return animationChannel;\n}\nfunction loadAnimation(loader, animationJson, nodes) {\n  const animation = new Animation();\n  animation.name = animationJson.name;\n  const samplers = animationJson.samplers.map(function (samplerJson, i) {\n    const sampler = loadAnimationSampler(loader, samplerJson);\n    sampler.index = i;\n    return sampler;\n  });\n  const channels = animationJson.channels.map(function (channelJson) {\n    return loadAnimationChannel(channelJson, samplers, nodes);\n  });\n  animation.samplers = samplers;\n  animation.channels = channels;\n  return animation;\n}\nfunction loadAnimations(loader, nodes) {\n  const animationJsons = loader.gltfJson.animations;\n\n  // Animations are disabled for classification models.\n  if (loader._loadForClassification || !defined(animationJsons)) {\n    return [];\n  }\n  const animations = animationJsons.map(function (animationJson, i) {\n    const animation = loadAnimation(loader, animationJson, nodes);\n    animation.index = i;\n    return animation;\n  });\n  return animations;\n}\nfunction loadArticulationStage(gltfStage) {\n  const stage = new ArticulationStage();\n  stage.name = gltfStage.name;\n  const type = gltfStage.type.toUpperCase();\n  stage.type = ArticulationStageType[type];\n  stage.minimumValue = gltfStage.minimumValue;\n  stage.maximumValue = gltfStage.maximumValue;\n  stage.initialValue = gltfStage.initialValue;\n  return stage;\n}\nfunction loadArticulation(articulationJson) {\n  const articulation = new Articulation();\n  articulation.name = articulationJson.name;\n  articulation.stages = articulationJson.stages.map(loadArticulationStage);\n  return articulation;\n}\nfunction loadArticulations(gltf) {\n  const extensions = defaultValue(gltf.extensions, defaultValue.EMPTY_OBJECT);\n  const articulationJsons = extensions.AGI_articulations?.articulations;\n  if (!defined(articulationJsons)) {\n    return [];\n  }\n  return articulationJsons.map(loadArticulation);\n}\nfunction getSceneNodeIds(gltf) {\n  let nodesIds;\n  if (defined(gltf.scenes) && defined(gltf.scene)) {\n    nodesIds = gltf.scenes[gltf.scene].nodes;\n  }\n  nodesIds = defaultValue(nodesIds, gltf.nodes);\n  nodesIds = defined(nodesIds) ? nodesIds : [];\n  return nodesIds;\n}\nfunction loadScene(gltf, nodes) {\n  const scene = new Scene();\n  const sceneNodeIds = getSceneNodeIds(gltf);\n  scene.nodes = sceneNodeIds.map(function (sceneNodeId) {\n    return nodes[sceneNodeId];\n  });\n  return scene;\n}\nconst scratchCenter = new Cartesian3();\n\n/**\n * Parse the glTF which populates the loaders arrays. Loading promises will be created, and will\n * resolve once the loaders are ready (i.e. all external resources\n * have been fetched and all GPU resources have been created). Loaders that\n * create GPU resources need to be processed every frame until they become\n * ready since the JobScheduler is not able to execute all jobs in a single\n * frame. Any promise failures are collected, and will be handled synchronously in process().\n * Also note that it's fine to call process before a loader is ready to process or\n * after it has failed; nothing will happen.\n *\n * @param {GltfLoader} loader\n * @param {FrameState} frameState\n * @returns {Promise} A Promise that resolves when all loaders are ready\n * @private\n */\nfunction parse(loader, frameState) {\n  const gltf = loader.gltfJson;\n  const extensions = defaultValue(gltf.extensions, defaultValue.EMPTY_OBJECT);\n  const structuralMetadataExtension = extensions.EXT_structural_metadata;\n  const featureMetadataExtensionLegacy = extensions.EXT_feature_metadata;\n  const cesiumRtcExtension = extensions.CESIUM_RTC;\n  if (defined(featureMetadataExtensionLegacy)) {\n    // If the old EXT_feature_metadata extension is present, sort the IDs of the\n    // feature tables and feature textures so we don't have to do this once\n    // per primitive.\n    //\n    // This must run before loadNodes so these IDs are available when\n    // attributes are processed.\n    const featureTables = featureMetadataExtensionLegacy.featureTables;\n    const featureTextures = featureMetadataExtensionLegacy.featureTextures;\n    const allPropertyTableIds = defined(featureTables) ? featureTables : [];\n    const allFeatureTextureIds = defined(featureTextures) ? featureTextures : [];\n    loader._sortedPropertyTableIds = Object.keys(allPropertyTableIds).sort();\n    loader._sortedFeatureTextureIds = Object.keys(allFeatureTextureIds).sort();\n  }\n  const nodes = loadNodes(loader, frameState);\n  const skins = loadSkins(loader, nodes);\n  const animations = loadAnimations(loader, nodes);\n  const articulations = loadArticulations(gltf);\n  const scene = loadScene(gltf, nodes);\n  const components = new Components();\n  const asset = new Asset();\n  const copyright = gltf.asset.copyright;\n  if (defined(copyright)) {\n    const credits = copyright.split(\";\").map(function (string) {\n      return new Credit(string.trim());\n    });\n    asset.credits = credits;\n  }\n  components.asset = asset;\n  components.scene = scene;\n  components.nodes = nodes;\n  components.skins = skins;\n  components.animations = animations;\n  components.articulations = articulations;\n  components.upAxis = loader._upAxis;\n  components.forwardAxis = loader._forwardAxis;\n  if (defined(cesiumRtcExtension)) {\n    // CESIUM_RTC is almost always WGS84 coordinates so no axis conversion needed\n    const center = Cartesian3.fromArray(cesiumRtcExtension.center, 0, scratchCenter);\n    components.transform = Matrix4.fromTranslation(center, components.transform);\n  }\n  loader._components = components;\n\n  // Load structural metadata (property tables and property textures)\n  if (defined(structuralMetadataExtension) || defined(featureMetadataExtensionLegacy)) {\n    const promise = loadStructuralMetadata(loader, structuralMetadataExtension, featureMetadataExtensionLegacy, frameState);\n    loader._loaderPromises.push(promise);\n  }\n\n  // Load NGA_gpm_local from root object\n  const gpmExtension = extensions.NGA_gpm_local;\n  if (defined(gpmExtension)) {\n    const gltfGpmLocal = GltfGpmLoader.load(gpmExtension);\n    loader._components.extensions[\"NGA_gpm_local\"] = gltfGpmLocal;\n  }\n\n  // Load NGA_gpm_local from mesh primitives\n  const meshes = gltf.meshes;\n  if (defined(meshes)) {\n    for (const mesh of meshes) {\n      const primitives = mesh.primitives;\n      if (defined(primitives)) {\n        for (const primitive of primitives) {\n          const primitiveExtensions = primitive.extensions;\n          if (defined(primitiveExtensions)) {\n            const meshPrimitiveGpmExtension = primitiveExtensions.NGA_gpm_local;\n            if (defined(meshPrimitiveGpmExtension)) {\n              const promise = loadMeshPrimitiveGpm(loader, gltf, meshPrimitiveGpmExtension, frameState);\n              loader._loaderPromises.push(promise);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Gather promises and handle any errors\n  const readyPromises = [];\n  readyPromises.push.apply(readyPromises, loader._loaderPromises);\n\n  // When incrementallyLoadTextures is true, the errors are caught and thrown individually\n  // since it doesn't affect the overall loader state\n  if (!loader._incrementallyLoadTextures) {\n    readyPromises.push.apply(readyPromises, loader._texturesPromises);\n  }\n  return Promise.all(readyPromises);\n}\nfunction unloadTextures(loader) {\n  const textureLoaders = loader._textureLoaders;\n  for (let i = 0; i < textureLoaders.length; ++i) {\n    textureLoaders[i] = !textureLoaders[i].isDestroyed() && ResourceCache.unload(textureLoaders[i]);\n  }\n  loader._textureLoaders.length = 0;\n}\nfunction unloadBufferViewLoaders(loader) {\n  const bufferViewLoaders = loader._bufferViewLoaders;\n  for (let i = 0; i < bufferViewLoaders.length; ++i) {\n    bufferViewLoaders[i] = !bufferViewLoaders[i].isDestroyed() && ResourceCache.unload(bufferViewLoaders[i]);\n  }\n  loader._bufferViewLoaders.length = 0;\n}\nfunction unloadGeometry(loader) {\n  const geometryLoaders = loader._geometryLoaders;\n  for (let i = 0; i < geometryLoaders.length; ++i) {\n    geometryLoaders[i] = !geometryLoaders[i].isDestroyed() && ResourceCache.unload(geometryLoaders[i]);\n  }\n  loader._geometryLoaders.length = 0;\n}\nfunction unloadGeneratedAttributes(loader) {\n  const buffers = loader._postProcessBuffers;\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    if (!buffer.isDestroyed()) {\n      buffer.destroy();\n    }\n  }\n  buffers.length = 0;\n}\nfunction unloadStructuralMetadata(loader) {\n  if (defined(loader._structuralMetadataLoader) && !loader._structuralMetadataLoader.isDestroyed()) {\n    loader._structuralMetadataLoader.destroy();\n    loader._structuralMetadataLoader = undefined;\n  }\n}\nfunction unloadMeshPrimitiveGpm(loader) {\n  if (defined(loader._meshPrimitiveGpmLoader) && !loader._meshPrimitiveGpmLoader.isDestroyed()) {\n    loader._meshPrimitiveGpmLoader.destroy();\n    loader._meshPrimitiveGpmLoader = undefined;\n  }\n}\n\n/**\n * Returns whether the resource has been unloaded.\n * @private\n */\nGltfLoader.prototype.isUnloaded = function () {\n  return this._state === GltfLoaderState.UNLOADED;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfLoader.prototype.unload = function () {\n  if (defined(this._gltfJsonLoader) && !this._gltfJsonLoader.isDestroyed()) {\n    ResourceCache.unload(this._gltfJsonLoader);\n  }\n  this._gltfJsonLoader = undefined;\n  unloadTextures(this);\n  unloadBufferViewLoaders(this);\n  unloadGeometry(this);\n  unloadGeneratedAttributes(this);\n  unloadStructuralMetadata(this);\n  unloadMeshPrimitiveGpm(this);\n  this._components = undefined;\n  this._typedArray = undefined;\n  this._state = GltfLoaderState.UNLOADED;\n};\nexport default GltfLoader;","map":{"version":3,"names":["ArticulationStageType","Cartesian2","Cartesian3","Cartesian4","Check","ComponentDatatype","Credit","defaultValue","defined","FeatureDetection","InterpolationType","Matrix4","PrimitiveType","Quaternion","RuntimeError","Sampler","getAccessorByteStride","getComponentReader","numberOfComponentsForType","GltfStructuralMetadataLoader","AttributeType","Axis","GltfLoaderUtil","hasExtension","InstanceAttributeSemantic","ModelComponents","PrimitiveLoadPlan","ResourceCache","ResourceLoader","SupportedImageFormats","VertexAttributeSemantic","GltfGpmLoader","GltfMeshPrimitiveGpmLoader","oneTimeWarning","Attribute","Indices","FeatureIdAttribute","FeatureIdTexture","FeatureIdImplicitRange","MorphTarget","Primitive","Instances","Skin","Node","AnimatedPropertyType","AnimationSampler","AnimationTarget","AnimationChannel","Animation","ArticulationStage","Articulation","Asset","Scene","Components","MetallicRoughness","SpecularGlossiness","Specular","Anisotropy","Clearcoat","Material","GltfLoaderState","NOT_LOADED","LOADING","LOADED","PROCESSING","POST_PROCESSING","PROCESSED","READY","FAILED","UNLOADED","GltfLoader","options","EMPTY_OBJECT","gltfResource","typedArray","releaseGltfJson","asynchronous","incrementallyLoadTextures","upAxis","Y","forwardAxis","Z","loadAttributesAsTypedArray","loadAttributesFor2D","enablePick","loadIndicesForWireframe","loadPrimitiveOutline","loadForClassification","renameBatchIdSemantic","typeOf","object","baseResource","clone","_gltfJson","gltfJson","_gltfResource","_baseResource","_typedArray","_releaseGltfJson","_asynchronous","_incrementallyLoadTextures","_upAxis","_forwardAxis","_loadAttributesAsTypedArray","_loadAttributesFor2D","_enablePick","_loadIndicesForWireframe","_loadPrimitiveOutline","_loadForClassification","_renameBatchIdSemantic","_sortedPropertyTableIds","undefined","_sortedFeatureTextureIds","_gltfJsonLoader","_state","_textureState","_promise","_processError","_textureErrors","_primitiveLoadPlans","_loaderPromises","_textureLoaders","_texturesPromises","_textureCallbacks","_bufferViewLoaders","_geometryLoaders","_geometryCallbacks","_structuralMetadataLoader","_meshPrimitiveGpmLoader","_loadResourcesPromise","_resourcesLoaded","_texturesLoaded","_supportedImageFormats","_postProcessBuffers","_components","Object","create","prototype","constructor","defineProperties","cacheKey","get","components","gltf","texturesLoaded","loadGltfJson","loader","gltfJsonLoader","getGltfJsonLoader","load","isDestroyed","isUnloaded","error","handleError","loadResources","frameState","supportsWebP","initialized","initialize","webp","basis","context","supportsBasis","promise","parse","unload","gltfLoader","errorMessage","getError","processLoaders","ready","geometryLoaders","i","length","geometryReady","process","structuralMetadataLoader","metadataReady","structuralMetadata","meshPrimitiveGpmLoader","postProcessGeometry","loadPlans","loadPlan","postProcess","needsOutlines","gatherPostProcessBuffers","primitiveLoadPlan","buffers","primitive","outlineCoordinates","push","buffer","attributes","attribute","indices","_process","unloadBufferViewLoaders","_processTextures","textureLoaders","textureReady","then","catch","textureError","pop","name","texturesReady","getVertexBufferLoader","accessorId","semantic","draco","loadBuffer","loadTypedArray","accessor","accessors","bufferViewId","bufferView","vertexBufferLoader","attributeSemantic","getIndexBufferLoader","indexBufferLoader","getBufferViewLoader","bufferViewLoader","getPackedTypedArray","bufferViewTypedArray","byteOffset","byteStride","count","componentCount","type","componentType","componentByteLength","getSizeInBytes","defaultByteStride","componentsLength","Uint8Array","createArrayBufferView","accessorTypedArray","createTypedArray","dataView","DataView","Array","componentReader","j","loadDefaultAccessorValues","values","accessorType","SCALAR","fill","MathType","getMathType","ZERO","loadAccessorValues","useQuaternion","accessorCount","VEC4","unpack","numberOfComponents","getNumberOfComponents","loadAccessorBufferView","loadAccessor","fromArray","Number","getDefault","getQuantizationDivisor","componentDatatype","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","minimumBoundsByType","VEC2","VEC3","dequantizeMinMax","VectorType","divisor","minimumBound","min","divideByScalar","maximumByComponent","max","setQuantizationFromWeb3dQuantizedAttributes","extension","decodeMatrix","decodedMin","decodedMax","quantization","Quantization","quantizedVolumeOffset","quantizedVolumeStepSize","createAttribute","setIndex","normalized","constant","extensions","WEB3D_quantized_attributes","isQuantizable","POSITION","NORMAL","TANGENT","TEXCOORD","hasKhrMeshQuantization","extensionsRequired","includes","getSetIndex","gltfSemantic","setIndexRegex","setIndexMatch","exec","parseInt","scratchSemanticInfo","renamedSemantic","modelSemantic","getSemanticInfo","semanticType","fromGltfSemantic","semanticInfo","isClassificationAttribute","isPositionAttribute","isFeatureIdAttribute","FEATURE_ID","isTexcoordAttribute","finalizeDracoAttribute","finalizeAttribute","loadAttribute","index","loadVertexAttribute","hasInstances","needsPostProcessing","loadTypedArrayFor2D","scene3DOnly","loadTypedArrayForPicking","webgl2","loadTypedArrayForClassification","outputTypedArrayOnly","outputBuffer","outputTypedArray","attributePlan","AttributeLoadPlan","loadInstancedAttribute","hasRotation","ROTATION","hasTranslationMinMax","TRANSLATION","isTransformAttribute","SCALE","isTranslationAttribute","loadAsTypedArrayOnly","instancedArrays","loadFor2D","loadTranslationAsTypedArray","loadIndices","hasFeatureIds","loadForCpuOperations","indexDatatype","indicesPlan","IndicesLoadPlan","loadTexture","textureInfo","samplerOverride","imageId","getImageIdFromTexture","textureId","supportedImageFormats","textureLoader","getTextureLoader","textureReader","createModelTextureReader","texture","sampler","loadSpecularGlossiness","specularGlossinessInfo","diffuseTexture","specularGlossinessTexture","diffuseFactor","specularFactor","glossinessFactor","specularGlossiness","loadMetallicRoughness","metallicRoughnessInfo","baseColorTexture","metallicRoughnessTexture","baseColorFactor","metallicFactor","roughnessFactor","metallicRoughness","loadSpecular","specularInfo","specularTexture","specularColorFactor","specularColorTexture","specular","loadAnisotropy","anisotropyInfo","anisotropyStrength","DEFAULT_ANISOTROPY_STRENGTH","anisotropyRotation","DEFAULT_ANISOTROPY_ROTATION","anisotropyTexture","anisotropy","loadClearcoat","clearcoatInfo","clearcoatFactor","DEFAULT_CLEARCOAT_FACTOR","clearcoatTexture","clearcoatRoughnessFactor","DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoat","loadMaterial","gltfMaterial","material","pbrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","pbrSpecular","KHR_materials_specular","pbrAnisotropy","KHR_materials_anisotropy","pbrClearcoat","KHR_materials_clearcoat","pbrMetallicRoughness","unlit","KHR_materials_unlit","emissiveTexture","normalTexture","occlusionTexture","emissiveFactor","alphaMode","alphaCutoff","doubleSided","loadFeatureIdAttribute","featureIds","positionalLabel","featureIdAttribute","featureCount","nullFeatureId","propertyTableId","propertyTable","label","loadFeatureIdAttributeLegacy","gltfFeatureIdAttribute","featureTableId","loadDefaultFeatureIds","featureIdRange","offset","repeat","loadFeatureIdImplicitRangeLegacy","loadFeatureIdTexture","gltfFeatureIdTexture","featureIdTexture","NEAREST","channels","channelString","map","channelIndex","charAt","join","loadFeatureIdTextureLegacy","loadMorphTarget","target","morphTarget","hasOwnProperty","attributePlans","loadPrimitive","gltfPrimitive","primitivePlan","materialId","materials","outlineExtension","CESIUM_primitive_outline","outlineIndices","KHR_draco_mesh_compression","targets","morphTargets","EXT_structural_metadata","meshFeatures","EXT_mesh_features","featureMetadataLegacy","EXT_feature_metadata","hasFeatureMetadataLegacy","loadPrimitiveFeatures","loadPrimitiveFeaturesLegacy","loadPrimitiveMetadata","loadPrimitiveMetadataLegacy","primitiveType","mode","TRIANGLES","meshFeaturesExtension","featureIdsArray","featureIdComponent","metadataExtension","featureTables","nextFeatureIdIndex","featureIdAttributes","featureTable","indexOf","featureIdTextures","featureIdLabel","structuralMetadataExtension","propertyTextures","propertyTextureIds","propertyAttributes","propertyAttributeIds","featureTextures","id","loadInstances","nodeExtensions","instancingExtension","EXT_mesh_gpu_instancing","instances","instancingExtExtensions","instanceFeatures","EXT_instance_features","loadInstanceFeatures","loadInstanceFeaturesLegacy","instanceFeaturesExtension","sortedPropertyTableIds","loadNode","gltfNode","node","matrix","translation","rotation","scale","articulationsExtension","AGI_articulations","articulationName","meshId","mesh","meshes","primitives","morphWeights","weights","slice","loadNodes","nodeJsons","nodes","loadedNodes","nodeJson","childrenNodeIds","children","loadSkin","gltfSkin","skin","jointIds","joints","jointId","inverseBindMatricesAccessorId","inverseBindMatrices","IDENTITY","loadSkins","skinJsons","skins","loadedSkins","skinJson","skinId","loadStructuralMetadata","extensionLegacy","loadMeshPrimitiveGpm","loadAnimationSampler","gltfSampler","animationSampler","inputAccessor","input","gltfInterpolation","interpolation","LINEAR","outputAccessor","output","loadAnimationTarget","gltfTarget","animationTarget","nodeIndex","path","toUpperCase","loadAnimationChannel","gltfChannel","samplers","animationChannel","samplerIndex","loadAnimation","animationJson","animation","samplerJson","channelJson","loadAnimations","animationJsons","animations","loadArticulationStage","gltfStage","stage","minimumValue","maximumValue","initialValue","loadArticulation","articulationJson","articulation","stages","loadArticulations","articulationJsons","articulations","getSceneNodeIds","nodesIds","scenes","scene","loadScene","sceneNodeIds","sceneNodeId","scratchCenter","featureMetadataExtensionLegacy","cesiumRtcExtension","CESIUM_RTC","allPropertyTableIds","allFeatureTextureIds","keys","sort","asset","copyright","credits","split","string","trim","center","transform","fromTranslation","gpmExtension","NGA_gpm_local","gltfGpmLocal","primitiveExtensions","meshPrimitiveGpmExtension","readyPromises","apply","Promise","all","unloadTextures","bufferViewLoaders","unloadGeometry","unloadGeneratedAttributes","destroy","unloadStructuralMetadata","unloadMeshPrimitiveGpm"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfLoader.js"],"sourcesContent":["import ArticulationStageType from \"../Core/ArticulationStageType.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport InterpolationType from \"../Core/InterpolationType.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport getAccessorByteStride from \"./GltfPipeline/getAccessorByteStride.js\";\nimport getComponentReader from \"./GltfPipeline/getComponentReader.js\";\nimport numberOfComponentsForType from \"./GltfPipeline/numberOfComponentsForType.js\";\nimport GltfStructuralMetadataLoader from \"./GltfStructuralMetadataLoader.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Axis from \"./Axis.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport InstanceAttributeSemantic from \"./InstanceAttributeSemantic.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport PrimitiveLoadPlan from \"./PrimitiveLoadPlan.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport SupportedImageFormats from \"./SupportedImageFormats.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\nimport GltfGpmLoader from \"./Model/Extensions/Gpm/GltfGpmLoader.js\";\nimport GltfMeshPrimitiveGpmLoader from \"./Model/Extensions/Gpm/GltfMeshPrimitiveGpmLoader.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\nconst {\n  Attribute,\n  Indices,\n  FeatureIdAttribute,\n  FeatureIdTexture,\n  FeatureIdImplicitRange,\n  MorphTarget,\n  Primitive,\n  Instances,\n  Skin,\n  Node,\n  AnimatedPropertyType,\n  AnimationSampler,\n  AnimationTarget,\n  AnimationChannel,\n  Animation,\n  ArticulationStage,\n  Articulation,\n  Asset,\n  Scene,\n  Components,\n  MetallicRoughness,\n  SpecularGlossiness,\n  Specular,\n  Anisotropy,\n  Clearcoat,\n  Material,\n} = ModelComponents;\n\n/**\n * States of the glTF loading process. These states also apply to\n * asynchronous texture loading unless otherwise noted\n *\n * @enum {number}\n *\n * @private\n */\nconst GltfLoaderState = {\n  /**\n   * The initial state of the glTF loader before load() is called.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  NOT_LOADED: 0,\n  /**\n   * The state of the loader while waiting for the glTF JSON loader promise\n   * to resolve.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  LOADING: 1,\n  /**\n   * The state of the loader once the glTF JSON is loaded but before\n   * process() is called.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  LOADED: 2,\n  /**\n   * The state of the loader while parsing the glTF and creating GPU resources\n   * as needed.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  PROCESSING: 3,\n  /**\n   * For some features like handling CESIUM_primitive_outlines, the geometry\n   * must be modified after it is loaded. The post-processing state handles\n   * any geometry modification (if needed).\n   * <p>\n   * This state is not used for asynchronous texture loading.\n   * </p>\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  POST_PROCESSING: 4,\n  /**\n   * Once the processing/post-processing states are finished, the loader\n   * enters the processed state (sometimes from a promise chain). The next\n   * call to process() will advance to the ready state.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  PROCESSED: 5,\n  /**\n   * When the loader reaches the ready state, the loaders' promise will be\n   * resolved.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  READY: 6,\n  /**\n   * If an error occurs at any point, the loader switches to the failed state.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  FAILED: 7,\n  /**\n   * If unload() is called, the loader switches to the unloaded state.\n   *\n   * @type {number}\n   * @constant\n   *\n   * @private\n   */\n  UNLOADED: 8,\n};\n\n/**\n * Loads a glTF model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF. This is often the path of the .gltf or .glb file, but may also be the path of the .b3dm, .i3dm, or .cmpt file containing the embedded glb. .cmpt resources should have a URI fragment indicating the index of the inner content to which the glb belongs in order to individually identify the glb in the cache, e.g. http://example.com/tile.cmpt#index=2.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents, e.g. from a .b3dm, .i3dm, or .cmpt file.\n * @param {object} [options.gltfJson] A parsed glTF JSON file instead of passing it in as a typed array.\n * @param {boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.Z] The forward-axis of the glTF model.\n * @param {boolean} [options.loadAttributesAsTypedArray=false] Load all attributes and indices as typed arrays instead of GPU buffers. If the attributes are interleaved in the glTF they will be de-interleaved in the typed array.\n * @param {boolean} [options.loadAttributesFor2D=false] If <code>true</code>, load the positions buffer and any instanced attribute buffers as typed arrays for accurately projecting models to 2D.\n * @param {boolean} [options.enablePick=false]  If <code>true</code>, load the positions buffer, any instanced attribute buffers, and index buffer as typed arrays for CPU-enabled picking in WebGL1.\n * @param {boolean} [options.loadIndicesForWireframe=false] If <code>true</code>, load the index buffer as both a buffer and typed array. The latter is useful for creating wireframe indices in WebGL1.\n * @param {boolean} [options.loadPrimitiveOutline=true] If <code>true</code>, load outlines from the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time.\n * @param {boolean} [options.loadForClassification=false] If <code>true</code> and if the model has feature IDs, load the feature IDs and indices as typed arrays. This is useful for batching features for classification.\n * @param {boolean} [options.renameBatchIdSemantic=false] If <code>true</code>, rename _BATCHID or BATCHID to _FEATURE_ID_0. This is used for .b3dm models\n * @private\n */\nfunction GltfLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltfResource,\n    typedArray,\n    releaseGltfJson = false,\n    asynchronous = true,\n    incrementallyLoadTextures = true,\n    upAxis = Axis.Y,\n    forwardAxis = Axis.Z,\n    loadAttributesAsTypedArray = false,\n    loadAttributesFor2D = false,\n    enablePick = false,\n    loadIndicesForWireframe = false,\n    loadPrimitiveOutline = true,\n    loadForClassification = false,\n    renameBatchIdSemantic = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  //>>includeEnd('debug');\n\n  const { baseResource = gltfResource.clone() } = options;\n\n  this._gltfJson = options.gltfJson;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._typedArray = typedArray;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadAttributesFor2D = loadAttributesFor2D;\n  this._enablePick = enablePick;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._loadPrimitiveOutline = loadPrimitiveOutline;\n  this._loadForClassification = loadForClassification;\n  this._renameBatchIdSemantic = renameBatchIdSemantic;\n\n  // When loading EXT_feature_metadata, the feature tables and textures\n  // are now stored as arrays like the newer EXT_structural_metadata extension.\n  // This requires sorting the dictionary keys for a consistent ordering.\n  this._sortedPropertyTableIds = undefined;\n  this._sortedFeatureTextureIds = undefined;\n\n  this._gltfJsonLoader = undefined;\n  this._state = GltfLoaderState.NOT_LOADED;\n  this._textureState = GltfLoaderState.NOT_LOADED;\n  this._promise = undefined;\n  this._processError = undefined;\n  this._textureErrors = [];\n\n  // Information about whether to load primitives as typed arrays or buffers,\n  // and whether post-processing is needed after loading (e.g. for\n  // generating outlines)\n  this._primitiveLoadPlans = [];\n\n  // Loaders that need to be processed before the glTF becomes ready\n  this._loaderPromises = [];\n  this._textureLoaders = [];\n  this._texturesPromises = [];\n  this._textureCallbacks = [];\n  this._bufferViewLoaders = [];\n  this._geometryLoaders = [];\n  this._geometryCallbacks = [];\n  this._structuralMetadataLoader = undefined;\n  this._meshPrimitiveGpmLoader = undefined;\n  this._loadResourcesPromise = undefined;\n  this._resourcesLoaded = false;\n  this._texturesLoaded = false;\n\n  this._supportedImageFormats = undefined;\n\n  // In some cases where geometry post-processing is needed (like generating\n  // outlines) new attributes are added that may have GPU resources attached.\n  // The GltfLoader will own the resources and store them here.\n  this._postProcessBuffers = [];\n\n  // Loaded results\n  this._components = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfLoader.prototype.constructor = GltfLoader;\n}\n\nObject.defineProperties(GltfLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n  /**\n   * The loaded glTF json.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  gltfJson: {\n    get: function () {\n      if (defined(this._gltfJsonLoader)) {\n        return this._gltfJsonLoader.gltf;\n      }\n      return this._gltfJson;\n    },\n  },\n  /**\n   * Returns true if textures are loaded separately from the other glTF resources.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    },\n  },\n  /**\n   * true if textures are loaded, useful when incrementallyLoadTextures is true\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  texturesLoaded: {\n    get: function () {\n      return this._texturesLoaded;\n    },\n  },\n});\n\n/**\n * Loads the gltf object\n */\nasync function loadGltfJson(loader) {\n  loader._state = GltfLoaderState.LOADING;\n  loader._textureState = GltfLoaderState.LOADING;\n\n  try {\n    const gltfJsonLoader = ResourceCache.getGltfJsonLoader({\n      gltfResource: loader._gltfResource,\n      baseResource: loader._baseResource,\n      typedArray: loader._typedArray,\n      gltfJson: loader._gltfJson,\n    });\n    loader._gltfJsonLoader = gltfJsonLoader;\n    await gltfJsonLoader.load();\n\n    if (\n      loader.isDestroyed() ||\n      loader.isUnloaded() ||\n      gltfJsonLoader.isDestroyed()\n    ) {\n      return;\n    }\n\n    loader._state = GltfLoaderState.LOADED;\n    loader._textureState = GltfLoaderState.LOADED;\n\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    loader._state = GltfLoaderState.FAILED;\n    loader._textureState = GltfLoaderState.FAILED;\n    handleError(loader, error);\n  }\n}\n\nasync function loadResources(loader, frameState) {\n  if (!FeatureDetection.supportsWebP.initialized) {\n    await FeatureDetection.supportsWebP.initialize();\n  }\n\n  loader._supportedImageFormats = new SupportedImageFormats({\n    webp: FeatureDetection.supportsWebP(),\n    basis: frameState.context.supportsBasis,\n  });\n\n  // Loaders that create GPU resources need to be processed every frame until they become\n  // ready since the JobScheduler is not able to execute all jobs in a single\n  // frame. Any promise failures are collected, and will be handled synchronously in process().\n  // Also note that it's fine to call process before a loader is ready to process or\n  // after it has failed; nothing will happen.\n  const promise = parse(loader, frameState);\n\n  // All resource loaders have been created, so we can begin processing\n  loader._state = GltfLoaderState.PROCESSING;\n  loader._textureState = GltfLoaderState.PROCESSING;\n\n  if (defined(loader._gltfJsonLoader) && loader._releaseGltfJson) {\n    // Check that the glTF JSON loader is still defined before trying to unload it.\n    // It can be unloaded if the glTF loader is destroyed.\n    ResourceCache.unload(loader._gltfJsonLoader);\n    loader._gltfJsonLoader = undefined;\n  }\n\n  return promise;\n}\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @exception {RuntimeError} Unsupported glTF version\n * @exception {RuntimeError} Unsupported glTF Extension\n * @private\n */\nGltfLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._promise = loadGltfJson(this);\n  return this._promise;\n};\n\nfunction handleError(gltfLoader, error) {\n  gltfLoader.unload();\n  const errorMessage = \"Failed to load glTF\";\n  throw gltfLoader.getError(errorMessage, error);\n}\n\nfunction processLoaders(loader, frameState) {\n  let ready = true;\n  const geometryLoaders = loader._geometryLoaders;\n  for (let i = 0; i < geometryLoaders.length; ++i) {\n    const geometryReady = geometryLoaders[i].process(frameState);\n    if (geometryReady && defined(loader._geometryCallbacks[i])) {\n      loader._geometryCallbacks[i]();\n      loader._geometryCallbacks[i] = undefined;\n    }\n    ready = ready && geometryReady;\n  }\n\n  const structuralMetadataLoader = loader._structuralMetadataLoader;\n  if (defined(structuralMetadataLoader)) {\n    const metadataReady = structuralMetadataLoader.process(frameState);\n    if (metadataReady) {\n      loader._components.structuralMetadata =\n        structuralMetadataLoader.structuralMetadata;\n    }\n    ready = ready && metadataReady;\n  }\n\n  const meshPrimitiveGpmLoader = loader._meshPrimitiveGpmLoader;\n  if (defined(meshPrimitiveGpmLoader)) {\n    const metadataReady = meshPrimitiveGpmLoader.process(frameState);\n    if (metadataReady) {\n      if (defined(loader._components.structuralMetadata)) {\n        oneTimeWarning(\n          \"structural-metadata-gpm\",\n          \"The model defines both the 'EXT_structural_metadata' extension and the \" +\n            \"'NGA_gpm_local' extension. The data from the 'EXT_structural_metadata' \" +\n            \"extension will be replaced with the data from the 'NGA_gpm_local' extension, \" +\n            \"and will no longer be available for styling and picking.\",\n        );\n      }\n      loader._components.structuralMetadata =\n        meshPrimitiveGpmLoader.structuralMetadata;\n    }\n    ready = ready && metadataReady;\n  }\n\n  if (ready) {\n    // Geometry requires further processing\n    loader._state = GltfLoaderState.POST_PROCESSING;\n  }\n}\n\nfunction postProcessGeometry(loader, context) {\n  // Apply post-processing steps on geometry such as\n  // updating attributes for rendering outlines.\n  const loadPlans = loader._primitiveLoadPlans;\n  for (let i = 0; i < loadPlans.length; i++) {\n    const loadPlan = loadPlans[i];\n    loadPlan.postProcess(context);\n\n    if (loadPlan.needsOutlines) {\n      // The glTF loader takes ownership of any buffers generated in the\n      // post-process stage since they were created after the geometry loaders\n      // finished. This way they can be destroyed when the loader is destroyed.\n      gatherPostProcessBuffers(loader, loadPlan);\n    }\n  }\n}\n\nfunction gatherPostProcessBuffers(loader, primitiveLoadPlan) {\n  const buffers = loader._postProcessBuffers;\n  const primitive = primitiveLoadPlan.primitive;\n\n  const outlineCoordinates = primitive.outlineCoordinates;\n  if (defined(outlineCoordinates)) {\n    // outline coordinates are always loaded as a buffer.\n    buffers.push(outlineCoordinates.buffer);\n  }\n\n  // to do post-processing, all the attributes are loaded as typed arrays\n  // so if a buffer exists, it was newly generated\n  const attributes = primitive.attributes;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      buffers.push(attribute.buffer);\n    }\n  }\n\n  // Similarly for the indices.\n  const indices = primitive.indices;\n  if (defined(indices) && defined(indices.buffer)) {\n    buffers.push(indices.buffer);\n  }\n}\n\n/**\n * Process loaders other than textures\n * @private\n */\nGltfLoader.prototype._process = function (frameState) {\n  if (this._state === GltfLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state === GltfLoaderState.PROCESSING) {\n    processLoaders(this, frameState);\n  }\n\n  if (\n    this._resourcesLoaded &&\n    this._state === GltfLoaderState.POST_PROCESSING\n  ) {\n    postProcessGeometry(this, frameState.context);\n    this._state = GltfLoaderState.PROCESSED;\n  }\n\n  if (this._resourcesLoaded && this._state === GltfLoaderState.PROCESSED) {\n    // The buffer views can be unloaded once the data is copied.\n    unloadBufferViewLoaders(this);\n\n    // Similarly, if the glTF was loaded from a typed array, release the memory\n    this._typedArray = undefined;\n\n    this._state = GltfLoaderState.READY;\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Process textures other than textures\n * @private\n */\nGltfLoader.prototype._processTextures = function (frameState) {\n  if (this._textureState === GltfLoaderState.READY) {\n    return true;\n  }\n\n  if (this._textureState !== GltfLoaderState.PROCESSING) {\n    return false;\n  }\n\n  let ready = true;\n  const textureLoaders = this._textureLoaders;\n  for (let i = 0; i < textureLoaders.length; ++i) {\n    const textureReady = textureLoaders[i].process(frameState);\n    if (textureReady && defined(this._textureCallbacks[i])) {\n      this._textureCallbacks[i]();\n      this._textureCallbacks[i] = undefined;\n    }\n\n    ready = ready && textureReady;\n  }\n\n  if (!ready) {\n    return false;\n  }\n\n  this._textureState = GltfLoaderState.READY;\n  this._texturesLoaded = true;\n  return true;\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (\n    this._state === GltfLoaderState.LOADED &&\n    !defined(this._loadResourcesPromise)\n  ) {\n    this._loadResourcesPromise = loadResources(this, frameState)\n      .then(() => {\n        this._resourcesLoaded = true;\n      })\n      .catch((error) => {\n        this._processError = error;\n      });\n  }\n\n  if (defined(this._processError)) {\n    this._state = GltfLoaderState.FAILED;\n    const error = this._processError;\n    this._processError = undefined;\n    handleError(this, error);\n  }\n\n  // Pop the next error of the list in case there are multiple\n  const textureError = this._textureErrors.pop();\n  if (defined(textureError)) {\n    // There shouldn't be the need to completely unload in this case. Just throw the error.\n    const error = this.getError(\"Failed to load glTF texture\", textureError);\n    error.name = \"TextureError\";\n    throw error;\n  }\n\n  if (this._state === GltfLoaderState.FAILED) {\n    return false;\n  }\n\n  let ready = false;\n  try {\n    ready = this._process(frameState);\n  } catch (error) {\n    this._state = GltfLoaderState.FAILED;\n    handleError(this, error);\n  }\n\n  // Since textures can be loaded independently and are handled through a separate promise, they are processed in their own function\n  let texturesReady = false;\n  try {\n    texturesReady = this._processTextures(frameState);\n  } catch (error) {\n    this._textureState = GltfLoaderState.FAILED;\n    handleError(this, error);\n  }\n\n  if (this._incrementallyLoadTextures) {\n    return ready;\n  }\n\n  return ready && texturesReady;\n};\n\nfunction getVertexBufferLoader(\n  loader,\n  accessorId,\n  semantic,\n  draco,\n  loadBuffer,\n  loadTypedArray,\n  frameState,\n) {\n  const gltf = loader.gltfJson;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  const vertexBufferLoader = ResourceCache.getVertexBufferLoader({\n    gltf: gltf,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    frameState: frameState,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: semantic,\n    accessorId: accessorId,\n    asynchronous: loader._asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  return vertexBufferLoader;\n}\n\nfunction getIndexBufferLoader(\n  loader,\n  accessorId,\n  draco,\n  loadBuffer,\n  loadTypedArray,\n  frameState,\n) {\n  const indexBufferLoader = ResourceCache.getIndexBufferLoader({\n    gltf: loader.gltfJson,\n    accessorId: accessorId,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    frameState: frameState,\n    draco: draco,\n    asynchronous: loader._asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  return indexBufferLoader;\n}\n\nfunction getBufferViewLoader(loader, bufferViewId) {\n  const bufferViewLoader = ResourceCache.getBufferViewLoader({\n    gltf: loader.gltfJson,\n    bufferViewId: bufferViewId,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n  });\n\n  loader._bufferViewLoaders.push(bufferViewLoader);\n\n  return bufferViewLoader;\n}\n\nfunction getPackedTypedArray(gltf, accessor, bufferViewTypedArray) {\n  let byteOffset = accessor.byteOffset;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const count = accessor.count;\n  const componentCount = numberOfComponentsForType(accessor.type);\n  const componentType = accessor.componentType;\n  const componentByteLength = ComponentDatatype.getSizeInBytes(componentType);\n  const defaultByteStride = componentByteLength * componentCount;\n  const componentsLength = count * componentCount;\n\n  if (byteStride === defaultByteStride) {\n    // Copy the typed array and let the underlying ArrayBuffer be freed\n    bufferViewTypedArray = new Uint8Array(bufferViewTypedArray);\n    return ComponentDatatype.createArrayBufferView(\n      componentType,\n      bufferViewTypedArray.buffer,\n      bufferViewTypedArray.byteOffset + byteOffset,\n      componentsLength,\n    );\n  }\n\n  const accessorTypedArray = ComponentDatatype.createTypedArray(\n    componentType,\n    componentsLength,\n  );\n\n  const dataView = new DataView(bufferViewTypedArray.buffer);\n  const components = new Array(componentCount);\n  const componentReader = getComponentReader(accessor.componentType);\n  byteOffset = bufferViewTypedArray.byteOffset + byteOffset;\n\n  for (let i = 0; i < count; ++i) {\n    componentReader(\n      dataView,\n      byteOffset,\n      componentCount,\n      componentByteLength,\n      components,\n    );\n    for (let j = 0; j < componentCount; ++j) {\n      accessorTypedArray[i * componentCount + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n\n  return accessorTypedArray;\n}\n\nfunction loadDefaultAccessorValues(accessor, values) {\n  const accessorType = accessor.type;\n  if (accessorType === AttributeType.SCALAR) {\n    return values.fill(0);\n  }\n\n  const MathType = AttributeType.getMathType(accessorType);\n  return values.fill(MathType.clone(MathType.ZERO));\n}\n\nfunction loadAccessorValues(accessor, typedArray, values, useQuaternion) {\n  const accessorType = accessor.type;\n  const accessorCount = accessor.count;\n\n  if (accessorType === AttributeType.SCALAR) {\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = typedArray[i];\n    }\n  } else if (accessorType === AttributeType.VEC4 && useQuaternion) {\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = Quaternion.unpack(typedArray, i * 4);\n    }\n  } else {\n    const MathType = AttributeType.getMathType(accessorType);\n    const numberOfComponents =\n      AttributeType.getNumberOfComponents(accessorType);\n\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = MathType.unpack(typedArray, i * numberOfComponents);\n    }\n  }\n\n  return values;\n}\n\nasync function loadAccessorBufferView(\n  loader,\n  bufferViewLoader,\n  accessor,\n  useQuaternion,\n  values,\n) {\n  // Save a link to the gltfJson, which is removed after bufferViewLoader.load()\n  const { gltfJson } = loader;\n\n  await bufferViewLoader.load();\n  if (loader.isDestroyed()) {\n    return;\n  }\n\n  const typedArray = getPackedTypedArray(\n    gltfJson,\n    accessor,\n    bufferViewLoader.typedArray,\n  );\n\n  useQuaternion = defaultValue(useQuaternion, false);\n  loadAccessorValues(accessor, typedArray, values, useQuaternion);\n}\n\nfunction loadAccessor(loader, accessor, useQuaternion) {\n  const values = new Array(accessor.count);\n\n  const bufferViewId = accessor.bufferView;\n  if (defined(bufferViewId)) {\n    const bufferViewLoader = getBufferViewLoader(loader, bufferViewId);\n    const promise = loadAccessorBufferView(\n      loader,\n      bufferViewLoader,\n      accessor,\n      useQuaternion,\n      values,\n    );\n    loader._loaderPromises.push(promise);\n\n    return values;\n  }\n\n  return loadDefaultAccessorValues(accessor, values);\n}\n\nfunction fromArray(MathType, values) {\n  if (!defined(values)) {\n    return undefined;\n  }\n\n  if (MathType === Number) {\n    return values[0];\n  }\n\n  return MathType.unpack(values);\n}\n\nfunction getDefault(MathType) {\n  if (MathType === Number) {\n    return 0.0;\n  }\n\n  return new MathType(); // defaults to 0.0 for all types\n}\n\nfunction getQuantizationDivisor(componentDatatype) {\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return 127;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return 255;\n    case ComponentDatatype.SHORT:\n      return 32767;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return 65535;\n    default:\n      return 1.0;\n  }\n}\n\nconst minimumBoundsByType = {\n  VEC2: new Cartesian2(-1.0, -1.0),\n  VEC3: new Cartesian3(-1.0, -1.0, -1.0),\n  VEC4: new Cartesian4(-1.0, -1.0, -1.0, -1.0),\n};\n\nfunction dequantizeMinMax(attribute, VectorType) {\n  const divisor = getQuantizationDivisor(attribute.componentDatatype);\n  const minimumBound = minimumBoundsByType[attribute.type];\n\n  // dequantized = max(quantized / divisor, -1.0)\n  let min = attribute.min;\n  if (defined(min)) {\n    min = VectorType.divideByScalar(min, divisor, min);\n    min = VectorType.maximumByComponent(min, minimumBound, min);\n  }\n\n  let max = attribute.max;\n  if (defined(max)) {\n    max = VectorType.divideByScalar(max, divisor, max);\n    max = VectorType.maximumByComponent(max, minimumBound, max);\n  }\n\n  attribute.min = min;\n  attribute.max = max;\n}\n\nfunction setQuantizationFromWeb3dQuantizedAttributes(\n  extension,\n  attribute,\n  MathType,\n) {\n  const decodeMatrix = extension.decodeMatrix;\n  const decodedMin = fromArray(MathType, extension.decodedMin);\n  const decodedMax = fromArray(MathType, extension.decodedMax);\n\n  if (defined(decodedMin) && defined(decodedMax)) {\n    attribute.min = decodedMin;\n    attribute.max = decodedMax;\n  }\n\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = attribute.componentDatatype;\n  quantization.type = attribute.type;\n\n  if (decodeMatrix.length === 4) {\n    quantization.quantizedVolumeOffset = decodeMatrix[2];\n    quantization.quantizedVolumeStepSize = decodeMatrix[0];\n  } else if (decodeMatrix.length === 9) {\n    quantization.quantizedVolumeOffset = new Cartesian2(\n      decodeMatrix[6],\n      decodeMatrix[7],\n    );\n    quantization.quantizedVolumeStepSize = new Cartesian2(\n      decodeMatrix[0],\n      decodeMatrix[4],\n    );\n  } else if (decodeMatrix.length === 16) {\n    quantization.quantizedVolumeOffset = new Cartesian3(\n      decodeMatrix[12],\n      decodeMatrix[13],\n      decodeMatrix[14],\n    );\n    quantization.quantizedVolumeStepSize = new Cartesian3(\n      decodeMatrix[0],\n      decodeMatrix[5],\n      decodeMatrix[10],\n    );\n  } else if (decodeMatrix.length === 25) {\n    quantization.quantizedVolumeOffset = new Cartesian4(\n      decodeMatrix[20],\n      decodeMatrix[21],\n      decodeMatrix[22],\n      decodeMatrix[23],\n    );\n    quantization.quantizedVolumeStepSize = new Cartesian4(\n      decodeMatrix[0],\n      decodeMatrix[6],\n      decodeMatrix[12],\n      decodeMatrix[18],\n    );\n  }\n\n  attribute.quantization = quantization;\n}\n\nfunction createAttribute(gltf, accessorId, name, semantic, setIndex) {\n  const accessor = gltf.accessors[accessorId];\n  const MathType = AttributeType.getMathType(accessor.type);\n  const normalized = defaultValue(accessor.normalized, false);\n\n  const attribute = new Attribute();\n  attribute.name = name;\n  attribute.semantic = semantic;\n  attribute.setIndex = setIndex;\n  attribute.constant = getDefault(MathType);\n  attribute.componentDatatype = accessor.componentType;\n  attribute.normalized = normalized;\n  attribute.count = accessor.count;\n  attribute.type = accessor.type;\n  attribute.min = fromArray(MathType, accessor.min);\n  attribute.max = fromArray(MathType, accessor.max);\n  attribute.byteOffset = accessor.byteOffset;\n  attribute.byteStride = getAccessorByteStride(gltf, accessor);\n\n  if (hasExtension(accessor, \"WEB3D_quantized_attributes\")) {\n    setQuantizationFromWeb3dQuantizedAttributes(\n      accessor.extensions.WEB3D_quantized_attributes,\n      attribute,\n      MathType,\n    );\n  }\n\n  const isQuantizable =\n    attribute.semantic === VertexAttributeSemantic.POSITION ||\n    attribute.semantic === VertexAttributeSemantic.NORMAL ||\n    attribute.semantic === VertexAttributeSemantic.TANGENT ||\n    attribute.semantic === VertexAttributeSemantic.TEXCOORD;\n\n  // In the glTF 2.0 spec, min and max are not affected by the normalized flag.\n  // However, for KHR_mesh_quantization, min and max must be dequantized for\n  // normalized values, else the bounding sphere will be computed incorrectly.\n  const hasKhrMeshQuantization = gltf.extensionsRequired?.includes(\n    \"KHR_mesh_quantization\",\n  );\n\n  if (hasKhrMeshQuantization && normalized && isQuantizable) {\n    dequantizeMinMax(attribute, MathType);\n  }\n\n  return attribute;\n}\n\nfunction getSetIndex(gltfSemantic) {\n  const setIndexRegex = /^\\w+_(\\d+)$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    return parseInt(setIndexMatch[1]);\n  }\n  return undefined;\n}\n\nconst scratchSemanticInfo = {\n  gltfSemantic: undefined,\n  renamedSemantic: undefined,\n  modelSemantic: undefined,\n};\n\nfunction getSemanticInfo(loader, semanticType, gltfSemantic) {\n  // For .b3dm, rename _BATCHID (or the legacy BATCHID) to _FEATURE_ID_0\n  // in the generated model components for compatibility with EXT_mesh_features\n  let renamedSemantic = gltfSemantic;\n  if (\n    loader._renameBatchIdSemantic &&\n    (gltfSemantic === \"_BATCHID\" || gltfSemantic === \"BATCHID\")\n  ) {\n    renamedSemantic = \"_FEATURE_ID_0\";\n  }\n\n  const modelSemantic = semanticType.fromGltfSemantic(renamedSemantic);\n\n  const semanticInfo = scratchSemanticInfo;\n  semanticInfo.gltfSemantic = gltfSemantic;\n  semanticInfo.renamedSemantic = renamedSemantic;\n  semanticInfo.modelSemantic = modelSemantic;\n\n  return semanticInfo;\n}\n\nfunction isClassificationAttribute(attributeSemantic) {\n  // Classification models only use the position, texcoord, and feature ID attributes.\n  const isPositionAttribute =\n    attributeSemantic === VertexAttributeSemantic.POSITION;\n  const isFeatureIdAttribute =\n    attributeSemantic === VertexAttributeSemantic.FEATURE_ID;\n  const isTexcoordAttribute =\n    attributeSemantic === VertexAttributeSemantic.TEXCOORD;\n\n  return isPositionAttribute || isFeatureIdAttribute || isTexcoordAttribute;\n}\n\nfunction finalizeDracoAttribute(\n  attribute,\n  vertexBufferLoader,\n  loadBuffer,\n  loadTypedArray,\n) {\n  // The accessor's byteOffset and byteStride should be ignored for draco.\n  // Each attribute is tightly packed in its own buffer after decode.\n  attribute.byteOffset = 0;\n  attribute.byteStride = undefined;\n  attribute.quantization = vertexBufferLoader.quantization;\n\n  if (loadBuffer) {\n    attribute.buffer = vertexBufferLoader.buffer;\n  }\n\n  if (loadTypedArray) {\n    const componentDatatype = defined(vertexBufferLoader.quantization)\n      ? vertexBufferLoader.quantization.componentDatatype\n      : attribute.componentDatatype;\n\n    attribute.typedArray = ComponentDatatype.createArrayBufferView(\n      componentDatatype,\n      vertexBufferLoader.typedArray.buffer,\n    );\n  }\n}\n\nfunction finalizeAttribute(\n  gltf,\n  accessor,\n  attribute,\n  vertexBufferLoader,\n  loadBuffer,\n  loadTypedArray,\n) {\n  if (loadBuffer) {\n    attribute.buffer = vertexBufferLoader.buffer;\n  }\n\n  if (loadTypedArray) {\n    const bufferViewTypedArray = vertexBufferLoader.typedArray;\n    attribute.typedArray = getPackedTypedArray(\n      gltf,\n      accessor,\n      bufferViewTypedArray,\n    );\n\n    if (!loadBuffer) {\n      // If the buffer isn't loaded, then the accessor's byteOffset and\n      // byteStride should be ignored, since values are only available in a\n      // tightly packed typed array\n      attribute.byteOffset = 0;\n      attribute.byteStride = undefined;\n    }\n  }\n}\n\nfunction loadAttribute(\n  loader,\n  accessorId,\n  semanticInfo,\n  draco,\n  loadBuffer,\n  loadTypedArray,\n  frameState,\n) {\n  const gltf = loader.gltfJson;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  const gltfSemantic = semanticInfo.gltfSemantic;\n  const renamedSemantic = semanticInfo.renamedSemantic;\n  const modelSemantic = semanticInfo.modelSemantic;\n\n  const setIndex = defined(modelSemantic)\n    ? getSetIndex(renamedSemantic)\n    : undefined;\n\n  const name = gltfSemantic;\n  const attribute = createAttribute(\n    gltf,\n    accessorId,\n    name,\n    modelSemantic,\n    setIndex,\n  );\n\n  if (!defined(draco) && !defined(bufferViewId)) {\n    return attribute;\n  }\n\n  const vertexBufferLoader = getVertexBufferLoader(\n    loader,\n    accessorId,\n    gltfSemantic,\n    draco,\n    loadBuffer,\n    loadTypedArray,\n    frameState,\n  );\n\n  const index = loader._geometryLoaders.length;\n  loader._geometryLoaders.push(vertexBufferLoader);\n  const promise = vertexBufferLoader.load();\n  loader._loaderPromises.push(promise);\n  // This can only execute once vertexBufferLoader.process() has run and returns true\n  // Save this finish callback by the loader index so it can be called\n  // in process().\n  loader._geometryCallbacks[index] = () => {\n    if (\n      defined(draco) &&\n      defined(draco.attributes) &&\n      defined(draco.attributes[gltfSemantic])\n    ) {\n      finalizeDracoAttribute(\n        attribute,\n        vertexBufferLoader,\n        loadBuffer,\n        loadTypedArray,\n      );\n    } else {\n      finalizeAttribute(\n        gltf,\n        accessor,\n        attribute,\n        vertexBufferLoader,\n        loadBuffer,\n        loadTypedArray,\n      );\n    }\n  };\n\n  return attribute;\n}\n\nfunction loadVertexAttribute(\n  loader,\n  accessorId,\n  semanticInfo,\n  draco,\n  hasInstances,\n  needsPostProcessing,\n  frameState,\n) {\n  const modelSemantic = semanticInfo.modelSemantic;\n\n  const isPositionAttribute =\n    modelSemantic === VertexAttributeSemantic.POSITION;\n  const isFeatureIdAttribute =\n    modelSemantic === VertexAttributeSemantic.FEATURE_ID;\n\n  const loadTypedArrayFor2D =\n    isPositionAttribute &&\n    !hasInstances &&\n    loader._loadAttributesFor2D &&\n    !frameState.scene3DOnly;\n  const loadTypedArrayForPicking =\n    isPositionAttribute && loader._enablePick && !frameState.context.webgl2;\n\n  const loadTypedArrayForClassification =\n    loader._loadForClassification && isFeatureIdAttribute;\n\n  // Whether the final output should be a buffer or typed array\n  // after loading and post-processing.\n  const outputTypedArrayOnly = loader._loadAttributesAsTypedArray;\n  const outputBuffer = !outputTypedArrayOnly;\n  const outputTypedArray =\n    outputTypedArrayOnly ||\n    loadTypedArrayFor2D ||\n    loadTypedArrayForPicking ||\n    loadTypedArrayForClassification;\n\n  // Determine what to load right now:\n  //\n  // - If post-processing is needed, load a packed typed array for\n  //   further processing, and defer the buffer loading until later.\n  // - On the other hand, if post-processing is not needed,\n  //   set the load flags directly\n  const loadBuffer = needsPostProcessing ? false : outputBuffer;\n  const loadTypedArray = needsPostProcessing ? true : outputTypedArray;\n\n  const attribute = loadAttribute(\n    loader,\n    accessorId,\n    semanticInfo,\n    draco,\n    loadBuffer,\n    loadTypedArray,\n    frameState,\n  );\n\n  const attributePlan = new PrimitiveLoadPlan.AttributeLoadPlan(attribute);\n  attributePlan.loadBuffer = outputBuffer;\n  attributePlan.loadTypedArray = outputTypedArray;\n\n  return attributePlan;\n}\n\nfunction loadInstancedAttribute(\n  loader,\n  accessorId,\n  attributes,\n  gltfSemantic,\n  frameState,\n) {\n  const accessors = loader.gltfJson.accessors;\n  const hasRotation = defined(attributes.ROTATION);\n  const hasTranslationMinMax =\n    defined(attributes.TRANSLATION) &&\n    defined(accessors[attributes.TRANSLATION].min) &&\n    defined(accessors[attributes.TRANSLATION].max);\n\n  const semanticInfo = getSemanticInfo(\n    loader,\n    InstanceAttributeSemantic,\n    gltfSemantic,\n  );\n  const modelSemantic = semanticInfo.modelSemantic;\n\n  const isTransformAttribute =\n    modelSemantic === InstanceAttributeSemantic.TRANSLATION ||\n    modelSemantic === InstanceAttributeSemantic.ROTATION ||\n    modelSemantic === InstanceAttributeSemantic.SCALE;\n  const isTranslationAttribute =\n    modelSemantic === InstanceAttributeSemantic.TRANSLATION;\n\n  // Load the attributes as typed arrays only if:\n  // - loadAttributesAsTypedArray is true\n  // - the instances have rotations. This only applies to the transform attributes,\n  //   since The instance matrices are computed on the CPU. This avoids the\n  //   expensive quaternion -> rotation matrix conversion in the shader.\n  // - GPU instancing is not supported.\n  const loadAsTypedArrayOnly =\n    loader._loadAttributesAsTypedArray ||\n    (hasRotation && isTransformAttribute) ||\n    !frameState.context.instancedArrays;\n  const loadTypedArrayForPicking =\n    loader._enablePick && !frameState.context.webgl2;\n\n  const loadBuffer = !loadAsTypedArrayOnly;\n\n  // Load the translations as a typed array in addition to the buffer if\n  // - the accessor does not have a min and max. The values will be used\n  //   for computing an accurate bounding volume.\n  // - the model will be projected to 2D.\n  const loadFor2D = loader._loadAttributesFor2D && !frameState.scene3DOnly;\n  const loadTranslationAsTypedArray =\n    isTranslationAttribute &&\n    (!hasTranslationMinMax || loadFor2D || loadTypedArrayForPicking);\n\n  const loadTypedArray = loadAsTypedArrayOnly || loadTranslationAsTypedArray;\n\n  // Don't pass in draco object since instanced attributes can't be draco compressed\n  return loadAttribute(\n    loader,\n    accessorId,\n    semanticInfo,\n    undefined,\n    loadBuffer,\n    loadTypedArray,\n    frameState,\n  );\n}\n\nfunction loadIndices(\n  loader,\n  accessorId,\n  draco,\n  hasFeatureIds,\n  needsPostProcessing,\n  frameState,\n) {\n  const accessor = loader.gltfJson.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  if (!defined(draco) && !defined(bufferViewId)) {\n    return undefined;\n  }\n\n  const indices = new Indices();\n  indices.count = accessor.count;\n\n  const loadAttributesAsTypedArray = loader._loadAttributesAsTypedArray;\n  // Load the index buffer as a typed array to generate wireframes or pick in WebGL1.\n  const loadForCpuOperations =\n    (loader._loadIndicesForWireframe || loader._enablePick) &&\n    !frameState.context.webgl2;\n\n  // Load the index buffer as a typed array to batch features together for classification.\n  const loadForClassification = loader._loadForClassification && hasFeatureIds;\n\n  // Whether the final output should be a buffer or typed array\n  // after loading and post-processing.\n  const outputTypedArrayOnly = loadAttributesAsTypedArray;\n  const outputBuffer = !outputTypedArrayOnly;\n  const outputTypedArray =\n    loadAttributesAsTypedArray || loadForCpuOperations || loadForClassification;\n\n  // Determine what to load right now:\n  //\n  // - If post-processing is needed, load a packed typed array for\n  //   further processing, and defer the buffer loading until later.\n  // - On the other hand, if post-processing is not needed, set the load\n  //   flags directly\n  const loadBuffer = needsPostProcessing ? false : outputBuffer;\n  const loadTypedArray = needsPostProcessing ? true : outputTypedArray;\n\n  const indexBufferLoader = getIndexBufferLoader(\n    loader,\n    accessorId,\n    draco,\n    loadBuffer,\n    loadTypedArray,\n    frameState,\n  );\n\n  const index = loader._geometryLoaders.length;\n  loader._geometryLoaders.push(indexBufferLoader);\n  const promise = indexBufferLoader.load();\n  loader._loaderPromises.push(promise);\n  // This can only execute once indexBufferLoader.process() has run and returns true\n  // Save this finish callback by the loader index so it can be called\n  // in process().\n  loader._geometryCallbacks[index] = () => {\n    indices.indexDatatype = indexBufferLoader.indexDatatype;\n    indices.buffer = indexBufferLoader.buffer;\n    indices.typedArray = indexBufferLoader.typedArray;\n  };\n\n  const indicesPlan = new PrimitiveLoadPlan.IndicesLoadPlan(indices);\n  indicesPlan.loadBuffer = outputBuffer;\n  indicesPlan.loadTypedArray = outputTypedArray;\n\n  return indicesPlan;\n}\n\nfunction loadTexture(loader, textureInfo, frameState, samplerOverride) {\n  const gltf = loader.gltfJson;\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureInfo.index,\n    supportedImageFormats: loader._supportedImageFormats,\n  });\n\n  if (!defined(imageId)) {\n    return undefined;\n  }\n\n  const textureLoader = ResourceCache.getTextureLoader({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: loader._supportedImageFormats,\n    frameState: frameState,\n    asynchronous: loader._asynchronous,\n  });\n\n  const textureReader = GltfLoaderUtil.createModelTextureReader({\n    textureInfo: textureInfo,\n  });\n\n  const index = loader._textureLoaders.length;\n  loader._textureLoaders.push(textureLoader);\n  const promise = textureLoader.load().catch((error) => {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    if (!loader._incrementallyLoadTextures) {\n      // If incrementallyLoadTextures is false, throw the error to ensure the loader state\n      // immediately is set to have failed\n      throw error;\n    }\n\n    // Otherwise, save the error so it can be thrown next\n    loader._textureState = GltfLoaderState.FAILED;\n    loader._textureErrors.push(error);\n  });\n  loader._texturesPromises.push(promise);\n  // This can only execute once textureLoader.process() has run and returns true\n  // Save this finish callback by the loader index so it can be called\n  // in process().\n  loader._textureCallbacks[index] = () => {\n    textureReader.texture = textureLoader.texture;\n    if (defined(samplerOverride)) {\n      textureReader.texture.sampler = samplerOverride;\n    }\n  };\n\n  return textureReader;\n}\n\n/**\n * Load textures and parse factors for the KHR_materials_pbrSpecularGlossiness extension\n * @param {GltfLoader} loader\n * @param {object} specularGlossinessInfo The contents of the KHR_materials_pbrSpecularGlossiness extension in the parsed glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.SpecularGlossiness}\n * @private\n */\nfunction loadSpecularGlossiness(loader, specularGlossinessInfo, frameState) {\n  const {\n    diffuseTexture,\n    specularGlossinessTexture,\n    diffuseFactor,\n    specularFactor,\n    glossinessFactor,\n  } = specularGlossinessInfo;\n\n  const specularGlossiness = new SpecularGlossiness();\n  if (defined(diffuseTexture)) {\n    specularGlossiness.diffuseTexture = loadTexture(\n      loader,\n      diffuseTexture,\n      frameState,\n    );\n  }\n  if (defined(specularGlossinessTexture)) {\n    specularGlossiness.specularGlossinessTexture = loadTexture(\n      loader,\n      specularGlossinessTexture,\n      frameState,\n    );\n  }\n  specularGlossiness.diffuseFactor = fromArray(Cartesian4, diffuseFactor);\n  specularGlossiness.specularFactor = fromArray(Cartesian3, specularFactor);\n  specularGlossiness.glossinessFactor = glossinessFactor;\n\n  return specularGlossiness;\n}\n\n/**\n * Load textures and parse factors for a metallic-roughness PBR model in a glTF material\n * @param {GltfLoader} loader\n * @param {object} metallicRoughnessInfo The contents of a pbrMetallicRoughness property in the parsed glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.MetallicRoughness}\n * @private\n */\nfunction loadMetallicRoughness(loader, metallicRoughnessInfo, frameState) {\n  const {\n    baseColorTexture,\n    metallicRoughnessTexture,\n    baseColorFactor,\n    metallicFactor,\n    roughnessFactor,\n  } = metallicRoughnessInfo;\n\n  const metallicRoughness = new MetallicRoughness();\n  if (defined(baseColorTexture)) {\n    metallicRoughness.baseColorTexture = loadTexture(\n      loader,\n      baseColorTexture,\n      frameState,\n    );\n  }\n  if (defined(metallicRoughnessTexture)) {\n    metallicRoughness.metallicRoughnessTexture = loadTexture(\n      loader,\n      metallicRoughnessTexture,\n      frameState,\n    );\n  }\n  metallicRoughness.baseColorFactor = fromArray(Cartesian4, baseColorFactor);\n  metallicRoughness.metallicFactor = metallicFactor;\n  metallicRoughness.roughnessFactor = roughnessFactor;\n\n  return metallicRoughness;\n}\n\nfunction loadSpecular(loader, specularInfo, frameState) {\n  const {\n    specularFactor,\n    specularTexture,\n    specularColorFactor,\n    specularColorTexture,\n  } = specularInfo;\n\n  const specular = new Specular();\n  if (defined(specularTexture)) {\n    specular.specularTexture = loadTexture(loader, specularTexture, frameState);\n  }\n  if (defined(specularColorTexture)) {\n    specular.specularColorTexture = loadTexture(\n      loader,\n      specularColorTexture,\n      frameState,\n    );\n  }\n  specular.specularFactor = specularFactor;\n  specular.specularColorFactor = fromArray(Cartesian3, specularColorFactor);\n\n  return specular;\n}\n\nfunction loadAnisotropy(loader, anisotropyInfo, frameState) {\n  const {\n    anisotropyStrength = Anisotropy.DEFAULT_ANISOTROPY_STRENGTH,\n    anisotropyRotation = Anisotropy.DEFAULT_ANISOTROPY_ROTATION,\n    anisotropyTexture,\n  } = anisotropyInfo;\n\n  const anisotropy = new Anisotropy();\n  if (defined(anisotropyTexture)) {\n    anisotropy.anisotropyTexture = loadTexture(\n      loader,\n      anisotropyTexture,\n      frameState,\n    );\n  }\n  anisotropy.anisotropyStrength = anisotropyStrength;\n  anisotropy.anisotropyRotation = anisotropyRotation;\n\n  return anisotropy;\n}\n\nfunction loadClearcoat(loader, clearcoatInfo, frameState) {\n  const {\n    clearcoatFactor = Clearcoat.DEFAULT_CLEARCOAT_FACTOR,\n    clearcoatTexture,\n    clearcoatRoughnessFactor = Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture,\n  } = clearcoatInfo;\n\n  const clearcoat = new Clearcoat();\n  if (defined(clearcoatTexture)) {\n    clearcoat.clearcoatTexture = loadTexture(\n      loader,\n      clearcoatTexture,\n      frameState,\n    );\n  }\n  if (defined(clearcoatRoughnessTexture)) {\n    clearcoat.clearcoatRoughnessTexture = loadTexture(\n      loader,\n      clearcoatRoughnessTexture,\n      frameState,\n    );\n  }\n  if (defined(clearcoatNormalTexture)) {\n    clearcoat.clearcoatNormalTexture = loadTexture(\n      loader,\n      clearcoatNormalTexture,\n      frameState,\n    );\n  }\n  clearcoat.clearcoatFactor = clearcoatFactor;\n  clearcoat.clearcoatRoughnessFactor = clearcoatRoughnessFactor;\n\n  return clearcoat;\n}\n\n/**\n * Load textures and parse factors and flags for a glTF material\n *\n * @param {GltfLoader} loader\n * @param {object} gltfMaterial An entry from the <code>.materials</code> array in the glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.Material}\n * @private\n */\nfunction loadMaterial(loader, gltfMaterial, frameState) {\n  const material = new Material();\n\n  const extensions = defaultValue(\n    gltfMaterial.extensions,\n    defaultValue.EMPTY_OBJECT,\n  );\n  const pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;\n  const pbrSpecular = extensions.KHR_materials_specular;\n  const pbrAnisotropy = extensions.KHR_materials_anisotropy;\n  const pbrClearcoat = extensions.KHR_materials_clearcoat;\n  const pbrMetallicRoughness = gltfMaterial.pbrMetallicRoughness;\n\n  material.unlit = defined(extensions.KHR_materials_unlit);\n\n  if (defined(pbrSpecularGlossiness)) {\n    material.specularGlossiness = loadSpecularGlossiness(\n      loader,\n      pbrSpecularGlossiness,\n      frameState,\n    );\n  } else {\n    if (defined(pbrMetallicRoughness)) {\n      material.metallicRoughness = loadMetallicRoughness(\n        loader,\n        pbrMetallicRoughness,\n        frameState,\n      );\n    }\n    if (defined(pbrSpecular) && !material.unlit) {\n      material.specular = loadSpecular(loader, pbrSpecular, frameState);\n    }\n    if (defined(pbrAnisotropy) && !material.unlit) {\n      material.anisotropy = loadAnisotropy(loader, pbrAnisotropy, frameState);\n    }\n    if (defined(pbrClearcoat) && !material.unlit) {\n      material.clearcoat = loadClearcoat(loader, pbrClearcoat, frameState);\n    }\n  }\n\n  // Top level textures\n  if (defined(gltfMaterial.emissiveTexture)) {\n    material.emissiveTexture = loadTexture(\n      loader,\n      gltfMaterial.emissiveTexture,\n      frameState,\n    );\n  }\n  // Normals aren't used for classification, so don't load the normal texture.\n  if (defined(gltfMaterial.normalTexture) && !loader._loadForClassification) {\n    material.normalTexture = loadTexture(\n      loader,\n      gltfMaterial.normalTexture,\n      frameState,\n    );\n  }\n  if (defined(gltfMaterial.occlusionTexture)) {\n    material.occlusionTexture = loadTexture(\n      loader,\n      gltfMaterial.occlusionTexture,\n      frameState,\n    );\n  }\n  material.emissiveFactor = fromArray(Cartesian3, gltfMaterial.emissiveFactor);\n  material.alphaMode = gltfMaterial.alphaMode;\n  material.alphaCutoff = gltfMaterial.alphaCutoff;\n  material.doubleSided = gltfMaterial.doubleSided;\n\n  return material;\n}\n\n// for EXT_mesh_features\nfunction loadFeatureIdAttribute(featureIds, positionalLabel) {\n  const featureIdAttribute = new FeatureIdAttribute();\n  featureIdAttribute.featureCount = featureIds.featureCount;\n  featureIdAttribute.nullFeatureId = featureIds.nullFeatureId;\n  featureIdAttribute.propertyTableId = featureIds.propertyTable;\n  featureIdAttribute.setIndex = featureIds.attribute;\n  featureIdAttribute.label = featureIds.label;\n  featureIdAttribute.positionalLabel = positionalLabel;\n  return featureIdAttribute;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdAttributeLegacy(\n  gltfFeatureIdAttribute,\n  featureTableId,\n  featureCount,\n  positionalLabel,\n) {\n  const featureIdAttribute = new FeatureIdAttribute();\n  const featureIds = gltfFeatureIdAttribute.featureIds;\n  featureIdAttribute.featureCount = featureCount;\n  featureIdAttribute.propertyTableId = featureTableId;\n  featureIdAttribute.setIndex = getSetIndex(featureIds.attribute);\n  featureIdAttribute.positionalLabel = positionalLabel;\n  return featureIdAttribute;\n}\n\n// implicit ranges do not exist in EXT_mesh_features and EXT_instance_features,\n// but both default to the vertex/instance ID which is like\n// an implicit range of {offset: 0, repeat: 1}\nfunction loadDefaultFeatureIds(featureIds, positionalLabel) {\n  const featureIdRange = new FeatureIdImplicitRange();\n  featureIdRange.propertyTableId = featureIds.propertyTable;\n  featureIdRange.featureCount = featureIds.featureCount;\n  featureIdRange.nullFeatureId = featureIds.nullFeatureId;\n  featureIdRange.label = featureIds.label;\n  featureIdRange.positionalLabel = positionalLabel;\n  featureIdRange.offset = 0;\n  featureIdRange.repeat = 1;\n  return featureIdRange;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdImplicitRangeLegacy(\n  gltfFeatureIdAttribute,\n  featureTableId,\n  featureCount,\n  positionalLabel,\n) {\n  const featureIdRange = new FeatureIdImplicitRange();\n  const featureIds = gltfFeatureIdAttribute.featureIds;\n  featureIdRange.propertyTableId = featureTableId;\n  featureIdRange.featureCount = featureCount;\n\n  // constant/divisor was renamed to offset/repeat\n  featureIdRange.offset = defaultValue(featureIds.constant, 0);\n  // The default is now undefined\n  const divisor = defaultValue(featureIds.divisor, 0);\n  featureIdRange.repeat = divisor === 0 ? undefined : divisor;\n\n  featureIdRange.positionalLabel = positionalLabel;\n  return featureIdRange;\n}\n\n// for EXT_mesh_features\nfunction loadFeatureIdTexture(\n  loader,\n  gltfFeatureIdTexture,\n  frameState,\n  positionalLabel,\n) {\n  const featureIdTexture = new FeatureIdTexture();\n\n  featureIdTexture.featureCount = gltfFeatureIdTexture.featureCount;\n  featureIdTexture.nullFeatureId = gltfFeatureIdTexture.nullFeatureId;\n  featureIdTexture.propertyTableId = gltfFeatureIdTexture.propertyTable;\n  featureIdTexture.label = gltfFeatureIdTexture.label;\n  featureIdTexture.positionalLabel = positionalLabel;\n\n  const textureInfo = gltfFeatureIdTexture.texture;\n  featureIdTexture.textureReader = loadTexture(\n    loader,\n    textureInfo,\n    frameState,\n    Sampler.NEAREST, // Feature ID textures require nearest sampling\n  );\n\n  // Though the new channel index is more future-proof, this implementation\n  // only supports RGBA textures. At least for now, the string representation\n  // is more useful for generating shader code.\n  const channels = defined(textureInfo.channels) ? textureInfo.channels : [0];\n  const channelString = channels\n    .map(function (channelIndex) {\n      return \"rgba\".charAt(channelIndex);\n    })\n    .join(\"\");\n  featureIdTexture.textureReader.channels = channelString;\n\n  return featureIdTexture;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdTextureLegacy(\n  loader,\n  gltfFeatureIdTexture,\n  featureTableId,\n  frameState,\n  featureCount,\n  positionalLabel,\n) {\n  const featureIdTexture = new FeatureIdTexture();\n  const featureIds = gltfFeatureIdTexture.featureIds;\n  const textureInfo = featureIds.texture;\n  featureIdTexture.featureCount = featureCount;\n  featureIdTexture.propertyTableId = featureTableId;\n  featureIdTexture.textureReader = loadTexture(\n    loader,\n    textureInfo,\n    frameState,\n    Sampler.NEAREST, // Feature ID textures require nearest sampling\n  );\n\n  featureIdTexture.textureReader.channels = featureIds.channels;\n  featureIdTexture.positionalLabel = positionalLabel;\n\n  return featureIdTexture;\n}\n\nfunction loadMorphTarget(\n  loader,\n  target,\n  needsPostProcessing,\n  primitiveLoadPlan,\n  frameState,\n) {\n  const morphTarget = new MorphTarget();\n\n  // Don't pass in draco object since morph targets can't be draco compressed\n  const draco = undefined;\n  const hasInstances = false;\n\n  for (const semantic in target) {\n    if (!target.hasOwnProperty(semantic)) {\n      continue;\n    }\n    const accessorId = target[semantic];\n\n    const semanticInfo = getSemanticInfo(\n      loader,\n      VertexAttributeSemantic,\n      semantic,\n    );\n\n    const attributePlan = loadVertexAttribute(\n      loader,\n      accessorId,\n      semanticInfo,\n      draco,\n      hasInstances,\n      needsPostProcessing,\n      frameState,\n    );\n    morphTarget.attributes.push(attributePlan.attribute);\n\n    // The load plan doesn't need to distinguish morph target attributes from\n    // regular attributes\n    primitiveLoadPlan.attributePlans.push(attributePlan);\n  }\n\n  return morphTarget;\n}\n\n/**\n * Load resources associated with a mesh primitive for a glTF node\n * @param {GltfLoader} loader\n * @param {object} gltfPrimitive One of the primitives in a mesh\n * @param {boolean} hasInstances True if the node using this mesh has instances\n * @param {FrameState} frameState\n * @returns {ModelComponents.Primitive}\n * @private\n */\nfunction loadPrimitive(loader, gltfPrimitive, hasInstances, frameState) {\n  const primitive = new Primitive();\n  const primitivePlan = new PrimitiveLoadPlan(primitive);\n  loader._primitiveLoadPlans.push(primitivePlan);\n\n  const materialId = gltfPrimitive.material;\n  if (defined(materialId)) {\n    primitive.material = loadMaterial(\n      loader,\n      loader.gltfJson.materials[materialId],\n      frameState,\n    );\n  }\n\n  const extensions = defaultValue(\n    gltfPrimitive.extensions,\n    defaultValue.EMPTY_OBJECT,\n  );\n\n  let needsPostProcessing = false;\n  const outlineExtension = extensions.CESIUM_primitive_outline;\n  if (loader._loadPrimitiveOutline && defined(outlineExtension)) {\n    needsPostProcessing = true;\n    primitivePlan.needsOutlines = true;\n    primitivePlan.outlineIndices = loadPrimitiveOutline(\n      loader,\n      outlineExtension,\n      primitivePlan,\n    );\n  }\n\n  const loadForClassification = loader._loadForClassification;\n  const draco = extensions.KHR_draco_mesh_compression;\n\n  let hasFeatureIds = false;\n  const attributes = gltfPrimitive.attributes;\n  if (defined(attributes)) {\n    for (const semantic in attributes) {\n      if (!attributes.hasOwnProperty(semantic)) {\n        continue;\n      }\n      const accessorId = attributes[semantic];\n      const semanticInfo = getSemanticInfo(\n        loader,\n        VertexAttributeSemantic,\n        semantic,\n      );\n\n      const modelSemantic = semanticInfo.modelSemantic;\n      if (loadForClassification && !isClassificationAttribute(modelSemantic)) {\n        continue;\n      }\n\n      if (modelSemantic === VertexAttributeSemantic.FEATURE_ID) {\n        hasFeatureIds = true;\n      }\n\n      const attributePlan = loadVertexAttribute(\n        loader,\n        accessorId,\n        semanticInfo,\n        draco,\n        hasInstances,\n        needsPostProcessing,\n        frameState,\n      );\n\n      primitivePlan.attributePlans.push(attributePlan);\n      primitive.attributes.push(attributePlan.attribute);\n    }\n  }\n\n  const targets = gltfPrimitive.targets;\n  // Morph targets are disabled for classification models.\n  if (defined(targets) && !loadForClassification) {\n    for (let i = 0; i < targets.length; ++i) {\n      primitive.morphTargets.push(\n        loadMorphTarget(\n          loader,\n          targets[i],\n          needsPostProcessing,\n          primitivePlan,\n          frameState,\n        ),\n      );\n    }\n  }\n\n  const indices = gltfPrimitive.indices;\n  if (defined(indices)) {\n    const indicesPlan = loadIndices(\n      loader,\n      indices,\n      draco,\n      hasFeatureIds,\n      needsPostProcessing,\n      frameState,\n    );\n\n    if (defined(indicesPlan)) {\n      primitivePlan.indicesPlan = indicesPlan;\n      primitive.indices = indicesPlan.indices;\n    }\n  }\n\n  // With the latest revision, feature IDs are defined in EXT_mesh_features\n  // while EXT_structural_metadata is for defining property textures and\n  // property mappings. In the legacy EXT_feature_metadata, these concepts\n  // were all in one extension.\n  const structuralMetadata = extensions.EXT_structural_metadata;\n  const meshFeatures = extensions.EXT_mesh_features;\n  const featureMetadataLegacy = extensions.EXT_feature_metadata;\n  const hasFeatureMetadataLegacy = defined(featureMetadataLegacy);\n\n  // Load feature Ids\n  if (defined(meshFeatures)) {\n    loadPrimitiveFeatures(loader, primitive, meshFeatures, frameState);\n  } else if (hasFeatureMetadataLegacy) {\n    loadPrimitiveFeaturesLegacy(\n      loader,\n      primitive,\n      featureMetadataLegacy,\n      frameState,\n    );\n  }\n\n  // Load structural metadata\n  if (defined(structuralMetadata)) {\n    loadPrimitiveMetadata(primitive, structuralMetadata);\n  } else if (hasFeatureMetadataLegacy) {\n    loadPrimitiveMetadataLegacy(loader, primitive, featureMetadataLegacy);\n  }\n\n  const primitiveType = gltfPrimitive.mode;\n  if (loadForClassification && primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new RuntimeError(\n      \"Only triangle meshes can be used for classification.\",\n    );\n  }\n  primitive.primitiveType = primitiveType;\n\n  return primitive;\n}\n\nfunction loadPrimitiveOutline(loader, outlineExtension) {\n  const accessorId = outlineExtension.indices;\n  const accessor = loader.gltfJson.accessors[accessorId];\n  const useQuaternion = false;\n  return loadAccessor(loader, accessor, useQuaternion);\n}\n\n// For EXT_mesh_features\nfunction loadPrimitiveFeatures(\n  loader,\n  primitive,\n  meshFeaturesExtension,\n  frameState,\n) {\n  let featureIdsArray;\n  if (\n    defined(meshFeaturesExtension) &&\n    defined(meshFeaturesExtension.featureIds)\n  ) {\n    featureIdsArray = meshFeaturesExtension.featureIds;\n  } else {\n    featureIdsArray = [];\n  }\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const label = `featureId_${i}`;\n\n    let featureIdComponent;\n    if (defined(featureIds.texture)) {\n      featureIdComponent = loadFeatureIdTexture(\n        loader,\n        featureIds,\n        frameState,\n        label,\n      );\n    } else if (defined(featureIds.attribute)) {\n      featureIdComponent = loadFeatureIdAttribute(featureIds, label);\n    } else {\n      // default to vertex ID, in other words an implicit range with\n      // offset: 0, repeat: 1\n      featureIdComponent = loadDefaultFeatureIds(featureIds, label);\n    }\n\n    primitive.featureIds.push(featureIdComponent);\n  }\n}\n\n// For EXT_feature_metadata\nfunction loadPrimitiveFeaturesLegacy(\n  loader,\n  primitive,\n  metadataExtension,\n  frameState,\n) {\n  // For looking up the featureCount for each set of feature IDs\n  const { featureTables } = loader.gltfJson.extensions.EXT_feature_metadata;\n\n  let nextFeatureIdIndex = 0;\n\n  // Feature ID Attributes\n  const featureIdAttributes = metadataExtension.featureIdAttributes;\n  if (defined(featureIdAttributes)) {\n    for (let i = 0; i < featureIdAttributes.length; ++i) {\n      const featureIdAttribute = featureIdAttributes[i];\n      const featureTableId = featureIdAttribute.featureTable;\n      const propertyTableId =\n        loader._sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const label = `featureId_${nextFeatureIdIndex}`;\n      nextFeatureIdIndex++;\n\n      let featureIdComponent;\n      if (defined(featureIdAttribute.featureIds.attribute)) {\n        featureIdComponent = loadFeatureIdAttributeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label,\n        );\n      } else {\n        featureIdComponent = loadFeatureIdImplicitRangeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label,\n        );\n      }\n      primitive.featureIds.push(featureIdComponent);\n    }\n  }\n\n  // Feature ID Textures\n  const featureIdTextures = metadataExtension.featureIdTextures;\n  if (defined(featureIdTextures)) {\n    for (let i = 0; i < featureIdTextures.length; ++i) {\n      const featureIdTexture = featureIdTextures[i];\n      const featureTableId = featureIdTexture.featureTable;\n      const propertyTableId =\n        loader._sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const featureIdLabel = `featureId_${nextFeatureIdIndex}`;\n      nextFeatureIdIndex++;\n\n      const featureIdComponent = loadFeatureIdTextureLegacy(\n        loader,\n        featureIdTexture,\n        propertyTableId,\n        frameState,\n        featureCount,\n        featureIdLabel,\n      );\n      // Feature ID textures are added after feature ID attributes in the list\n      primitive.featureIds.push(featureIdComponent);\n    }\n  }\n}\n\n// For primitive-level EXT_structural_metadata\nfunction loadPrimitiveMetadata(primitive, structuralMetadataExtension) {\n  if (!defined(structuralMetadataExtension)) {\n    return;\n  }\n\n  // Property Textures\n  if (defined(structuralMetadataExtension.propertyTextures)) {\n    primitive.propertyTextureIds = structuralMetadataExtension.propertyTextures;\n  }\n\n  // Property Attributes\n  if (defined(structuralMetadataExtension.propertyAttributes)) {\n    primitive.propertyAttributeIds =\n      structuralMetadataExtension.propertyAttributes;\n  }\n}\n\n// For EXT_feature_metadata\nfunction loadPrimitiveMetadataLegacy(loader, primitive, metadataExtension) {\n  // Feature Textures\n  if (defined(metadataExtension.featureTextures)) {\n    // feature textures are now identified by an integer index. To convert the\n    // string IDs to integers, find their place in the sorted list of feature\n    // table names\n    primitive.propertyTextureIds = metadataExtension.featureTextures.map(\n      function (id) {\n        return loader._sortedFeatureTextureIds.indexOf(id);\n      },\n    );\n  }\n}\n\nfunction loadInstances(loader, nodeExtensions, frameState) {\n  const instancingExtension = nodeExtensions.EXT_mesh_gpu_instancing;\n\n  const instances = new Instances();\n  const attributes = instancingExtension.attributes;\n  if (defined(attributes)) {\n    for (const semantic in attributes) {\n      if (!attributes.hasOwnProperty(semantic)) {\n        continue;\n      }\n      const accessorId = attributes[semantic];\n      instances.attributes.push(\n        loadInstancedAttribute(\n          loader,\n          accessorId,\n          attributes,\n          semantic,\n          frameState,\n        ),\n      );\n    }\n  }\n\n  const instancingExtExtensions = defaultValue(\n    instancingExtension.extensions,\n    defaultValue.EMPTY_OBJECT,\n  );\n  const instanceFeatures = nodeExtensions.EXT_instance_features;\n  const featureMetadataLegacy = instancingExtExtensions.EXT_feature_metadata;\n\n  if (defined(instanceFeatures)) {\n    loadInstanceFeatures(instances, instanceFeatures);\n  } else if (defined(featureMetadataLegacy)) {\n    loadInstanceFeaturesLegacy(\n      loader.gltfJson,\n      instances,\n      featureMetadataLegacy,\n      loader._sortedPropertyTableIds,\n    );\n  }\n\n  return instances;\n}\n\n// For EXT_mesh_features\nfunction loadInstanceFeatures(instances, instanceFeaturesExtension) {\n  // feature IDs are required in EXT_instance_features\n  const featureIdsArray = instanceFeaturesExtension.featureIds;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const label = `instanceFeatureId_${i}`;\n\n    let featureIdComponent;\n    if (defined(featureIds.attribute)) {\n      featureIdComponent = loadFeatureIdAttribute(featureIds, label);\n    } else {\n      // in EXT_instance_features, the default is to assign IDs by instance\n      // ID. This can be expressed with offset: 0, repeat: 1\n      featureIdComponent = loadDefaultFeatureIds(featureIds, label);\n    }\n\n    instances.featureIds.push(featureIdComponent);\n  }\n}\n\n// For backwards-compatibility with EXT_feature_metadata\nfunction loadInstanceFeaturesLegacy(\n  gltf,\n  instances,\n  metadataExtension,\n  sortedPropertyTableIds,\n) {\n  // For looking up the featureCount for each set of feature IDs\n  const featureTables = gltf.extensions.EXT_feature_metadata.featureTables;\n\n  const featureIdAttributes = metadataExtension.featureIdAttributes;\n  if (defined(featureIdAttributes)) {\n    for (let i = 0; i < featureIdAttributes.length; ++i) {\n      const featureIdAttribute = featureIdAttributes[i];\n      const featureTableId = featureIdAttribute.featureTable;\n      const propertyTableId = sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const label = `instanceFeatureId_${i}`;\n\n      let featureIdComponent;\n      if (defined(featureIdAttribute.featureIds.attribute)) {\n        featureIdComponent = loadFeatureIdAttributeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label,\n        );\n      } else {\n        featureIdComponent = loadFeatureIdImplicitRangeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label,\n        );\n      }\n      instances.featureIds.push(featureIdComponent);\n    }\n  }\n}\n\n/**\n * Load resources associated with one node from a glTF JSON\n * @param {GltfLoader} loader\n * @param {object} gltfNode An entry from the <code>.nodes</code> array in the glTF JSON\n * @param {FrameState} frameState\n * @returns {ModelComponents.Node}\n * @private\n */\nfunction loadNode(loader, gltfNode, frameState) {\n  const node = new Node();\n\n  node.name = gltfNode.name;\n\n  node.matrix = fromArray(Matrix4, gltfNode.matrix);\n  node.translation = fromArray(Cartesian3, gltfNode.translation);\n  node.rotation = fromArray(Quaternion, gltfNode.rotation);\n  node.scale = fromArray(Cartesian3, gltfNode.scale);\n\n  const nodeExtensions = defaultValue(\n    gltfNode.extensions,\n    defaultValue.EMPTY_OBJECT,\n  );\n  const instancingExtension = nodeExtensions.EXT_mesh_gpu_instancing;\n  const articulationsExtension = nodeExtensions.AGI_articulations;\n\n  if (defined(instancingExtension)) {\n    if (loader._loadForClassification) {\n      throw new RuntimeError(\n        \"Models with the EXT_mesh_gpu_instancing extension cannot be used for classification.\",\n      );\n    }\n    node.instances = loadInstances(loader, nodeExtensions, frameState);\n  }\n\n  if (defined(articulationsExtension)) {\n    node.articulationName = articulationsExtension.articulationName;\n  }\n\n  const meshId = gltfNode.mesh;\n  if (defined(meshId)) {\n    const mesh = loader.gltfJson.meshes[meshId];\n    const primitives = mesh.primitives;\n    for (let i = 0; i < primitives.length; ++i) {\n      node.primitives.push(\n        loadPrimitive(\n          loader,\n          primitives[i],\n          defined(node.instances),\n          frameState,\n        ),\n      );\n    }\n\n    // If the node has no weights array, it will look for the weights array provided\n    // by the mesh. If both are undefined, it will default to an array of zero weights.\n    const morphWeights = defaultValue(gltfNode.weights, mesh.weights);\n    const targets = node.primitives[0].morphTargets;\n\n    // Since meshes are not stored as separate components, the mesh weights will still\n    // be stored at the node level.\n    node.morphWeights = defined(morphWeights)\n      ? morphWeights.slice()\n      : new Array(targets.length).fill(0.0);\n  }\n\n  return node;\n}\n\n/**\n * Load resources associated with the nodes in a glTF JSON\n * @param {GltfLoader} loader\n * @param {FrameState} frameState\n * @returns {ModelComponents.Node[]}\n * @private\n */\nfunction loadNodes(loader, frameState) {\n  const nodeJsons = loader.gltfJson.nodes;\n  if (!defined(nodeJsons)) {\n    return [];\n  }\n\n  const loadedNodes = nodeJsons.map(function (nodeJson, i) {\n    const node = loadNode(loader, nodeJson, frameState);\n    node.index = i;\n    return node;\n  });\n\n  for (let i = 0; i < loadedNodes.length; ++i) {\n    const childrenNodeIds = nodeJsons[i].children;\n    if (defined(childrenNodeIds)) {\n      for (let j = 0; j < childrenNodeIds.length; ++j) {\n        loadedNodes[i].children.push(loadedNodes[childrenNodeIds[j]]);\n      }\n    }\n  }\n\n  return loadedNodes;\n}\n\nfunction loadSkin(loader, gltfSkin, nodes) {\n  const skin = new Skin();\n\n  const jointIds = gltfSkin.joints;\n  skin.joints = jointIds.map((jointId) => nodes[jointId]);\n\n  const inverseBindMatricesAccessorId = gltfSkin.inverseBindMatrices;\n  if (defined(inverseBindMatricesAccessorId)) {\n    const accessor = loader.gltfJson.accessors[inverseBindMatricesAccessorId];\n    skin.inverseBindMatrices = loadAccessor(loader, accessor);\n  } else {\n    skin.inverseBindMatrices = new Array(jointIds.length).fill(\n      Matrix4.IDENTITY,\n    );\n  }\n\n  return skin;\n}\n\nfunction loadSkins(loader, nodes) {\n  const skinJsons = loader.gltfJson.skins;\n\n  // Skins are disabled for classification models.\n  if (loader._loadForClassification || !defined(skinJsons)) {\n    return [];\n  }\n\n  const loadedSkins = skinJsons.map(function (skinJson, i) {\n    const skin = loadSkin(loader, skinJson, nodes);\n    skin.index = i;\n    return skin;\n  });\n\n  const nodeJsons = loader.gltfJson.nodes;\n  for (let i = 0; i < nodes.length; ++i) {\n    const skinId = nodeJsons[i].skin;\n    if (defined(skinId)) {\n      nodes[i].skin = loadedSkins[skinId];\n    }\n  }\n\n  return loadedSkins;\n}\n\nasync function loadStructuralMetadata(\n  loader,\n  extension,\n  extensionLegacy,\n  frameState,\n) {\n  const structuralMetadataLoader = new GltfStructuralMetadataLoader({\n    gltf: loader.gltfJson,\n    extension: extension,\n    extensionLegacy: extensionLegacy,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: loader._supportedImageFormats,\n    frameState: frameState,\n    asynchronous: loader._asynchronous,\n  });\n  loader._structuralMetadataLoader = structuralMetadataLoader;\n  return structuralMetadataLoader.load();\n}\n\nasync function loadMeshPrimitiveGpm(loader, gltf, extension, frameState) {\n  const meshPrimitiveGpmLoader = new GltfMeshPrimitiveGpmLoader({\n    gltf: gltf,\n    extension: extension,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: loader._supportedImageFormats,\n    frameState: frameState,\n    asynchronous: loader._asynchronous,\n  });\n  loader._meshPrimitiveGpmLoader = meshPrimitiveGpmLoader;\n  return meshPrimitiveGpmLoader.load();\n}\n\nfunction loadAnimationSampler(loader, gltfSampler) {\n  const animationSampler = new AnimationSampler();\n  const accessors = loader.gltfJson.accessors;\n\n  const inputAccessor = accessors[gltfSampler.input];\n  animationSampler.input = loadAccessor(loader, inputAccessor);\n\n  const gltfInterpolation = gltfSampler.interpolation;\n  animationSampler.interpolation = defaultValue(\n    InterpolationType[gltfInterpolation],\n    InterpolationType.LINEAR,\n  );\n\n  const outputAccessor = accessors[gltfSampler.output];\n  animationSampler.output = loadAccessor(loader, outputAccessor, true);\n\n  return animationSampler;\n}\n\nfunction loadAnimationTarget(gltfTarget, nodes) {\n  const animationTarget = new AnimationTarget();\n\n  const nodeIndex = gltfTarget.node;\n  // If the node isn't defined, the animation channel should be ignored.\n  // It's easiest to signal this by returning undefined.\n  if (!defined(nodeIndex)) {\n    return undefined;\n  }\n\n  animationTarget.node = nodes[nodeIndex];\n\n  const path = gltfTarget.path.toUpperCase();\n  animationTarget.path = AnimatedPropertyType[path];\n\n  return animationTarget;\n}\n\nfunction loadAnimationChannel(gltfChannel, samplers, nodes) {\n  const animationChannel = new AnimationChannel();\n\n  const samplerIndex = gltfChannel.sampler;\n  animationChannel.sampler = samplers[samplerIndex];\n  animationChannel.target = loadAnimationTarget(gltfChannel.target, nodes);\n\n  return animationChannel;\n}\n\nfunction loadAnimation(loader, animationJson, nodes) {\n  const animation = new Animation();\n  animation.name = animationJson.name;\n\n  const samplers = animationJson.samplers.map(function (samplerJson, i) {\n    const sampler = loadAnimationSampler(loader, samplerJson);\n    sampler.index = i;\n    return sampler;\n  });\n\n  const channels = animationJson.channels.map(function (channelJson) {\n    return loadAnimationChannel(channelJson, samplers, nodes);\n  });\n\n  animation.samplers = samplers;\n  animation.channels = channels;\n\n  return animation;\n}\n\nfunction loadAnimations(loader, nodes) {\n  const animationJsons = loader.gltfJson.animations;\n\n  // Animations are disabled for classification models.\n  if (loader._loadForClassification || !defined(animationJsons)) {\n    return [];\n  }\n\n  const animations = animationJsons.map(function (animationJson, i) {\n    const animation = loadAnimation(loader, animationJson, nodes);\n    animation.index = i;\n    return animation;\n  });\n\n  return animations;\n}\n\nfunction loadArticulationStage(gltfStage) {\n  const stage = new ArticulationStage();\n  stage.name = gltfStage.name;\n\n  const type = gltfStage.type.toUpperCase();\n  stage.type = ArticulationStageType[type];\n\n  stage.minimumValue = gltfStage.minimumValue;\n  stage.maximumValue = gltfStage.maximumValue;\n  stage.initialValue = gltfStage.initialValue;\n\n  return stage;\n}\n\nfunction loadArticulation(articulationJson) {\n  const articulation = new Articulation();\n  articulation.name = articulationJson.name;\n  articulation.stages = articulationJson.stages.map(loadArticulationStage);\n  return articulation;\n}\n\nfunction loadArticulations(gltf) {\n  const extensions = defaultValue(gltf.extensions, defaultValue.EMPTY_OBJECT);\n  const articulationJsons = extensions.AGI_articulations?.articulations;\n  if (!defined(articulationJsons)) {\n    return [];\n  }\n  return articulationJsons.map(loadArticulation);\n}\n\nfunction getSceneNodeIds(gltf) {\n  let nodesIds;\n  if (defined(gltf.scenes) && defined(gltf.scene)) {\n    nodesIds = gltf.scenes[gltf.scene].nodes;\n  }\n  nodesIds = defaultValue(nodesIds, gltf.nodes);\n  nodesIds = defined(nodesIds) ? nodesIds : [];\n  return nodesIds;\n}\n\nfunction loadScene(gltf, nodes) {\n  const scene = new Scene();\n  const sceneNodeIds = getSceneNodeIds(gltf);\n  scene.nodes = sceneNodeIds.map(function (sceneNodeId) {\n    return nodes[sceneNodeId];\n  });\n  return scene;\n}\n\nconst scratchCenter = new Cartesian3();\n\n/**\n * Parse the glTF which populates the loaders arrays. Loading promises will be created, and will\n * resolve once the loaders are ready (i.e. all external resources\n * have been fetched and all GPU resources have been created). Loaders that\n * create GPU resources need to be processed every frame until they become\n * ready since the JobScheduler is not able to execute all jobs in a single\n * frame. Any promise failures are collected, and will be handled synchronously in process().\n * Also note that it's fine to call process before a loader is ready to process or\n * after it has failed; nothing will happen.\n *\n * @param {GltfLoader} loader\n * @param {FrameState} frameState\n * @returns {Promise} A Promise that resolves when all loaders are ready\n * @private\n */\nfunction parse(loader, frameState) {\n  const gltf = loader.gltfJson;\n  const extensions = defaultValue(gltf.extensions, defaultValue.EMPTY_OBJECT);\n  const structuralMetadataExtension = extensions.EXT_structural_metadata;\n  const featureMetadataExtensionLegacy = extensions.EXT_feature_metadata;\n  const cesiumRtcExtension = extensions.CESIUM_RTC;\n\n  if (defined(featureMetadataExtensionLegacy)) {\n    // If the old EXT_feature_metadata extension is present, sort the IDs of the\n    // feature tables and feature textures so we don't have to do this once\n    // per primitive.\n    //\n    // This must run before loadNodes so these IDs are available when\n    // attributes are processed.\n    const featureTables = featureMetadataExtensionLegacy.featureTables;\n    const featureTextures = featureMetadataExtensionLegacy.featureTextures;\n    const allPropertyTableIds = defined(featureTables) ? featureTables : [];\n    const allFeatureTextureIds = defined(featureTextures)\n      ? featureTextures\n      : [];\n    loader._sortedPropertyTableIds = Object.keys(allPropertyTableIds).sort();\n    loader._sortedFeatureTextureIds = Object.keys(allFeatureTextureIds).sort();\n  }\n\n  const nodes = loadNodes(loader, frameState);\n  const skins = loadSkins(loader, nodes);\n  const animations = loadAnimations(loader, nodes);\n  const articulations = loadArticulations(gltf);\n  const scene = loadScene(gltf, nodes);\n\n  const components = new Components();\n  const asset = new Asset();\n  const copyright = gltf.asset.copyright;\n  if (defined(copyright)) {\n    const credits = copyright.split(\";\").map(function (string) {\n      return new Credit(string.trim());\n    });\n    asset.credits = credits;\n  }\n\n  components.asset = asset;\n  components.scene = scene;\n  components.nodes = nodes;\n  components.skins = skins;\n  components.animations = animations;\n  components.articulations = articulations;\n  components.upAxis = loader._upAxis;\n  components.forwardAxis = loader._forwardAxis;\n\n  if (defined(cesiumRtcExtension)) {\n    // CESIUM_RTC is almost always WGS84 coordinates so no axis conversion needed\n    const center = Cartesian3.fromArray(\n      cesiumRtcExtension.center,\n      0,\n      scratchCenter,\n    );\n    components.transform = Matrix4.fromTranslation(\n      center,\n      components.transform,\n    );\n  }\n\n  loader._components = components;\n\n  // Load structural metadata (property tables and property textures)\n  if (\n    defined(structuralMetadataExtension) ||\n    defined(featureMetadataExtensionLegacy)\n  ) {\n    const promise = loadStructuralMetadata(\n      loader,\n      structuralMetadataExtension,\n      featureMetadataExtensionLegacy,\n      frameState,\n    );\n    loader._loaderPromises.push(promise);\n  }\n\n  // Load NGA_gpm_local from root object\n  const gpmExtension = extensions.NGA_gpm_local;\n  if (defined(gpmExtension)) {\n    const gltfGpmLocal = GltfGpmLoader.load(gpmExtension);\n    loader._components.extensions[\"NGA_gpm_local\"] = gltfGpmLocal;\n  }\n\n  // Load NGA_gpm_local from mesh primitives\n  const meshes = gltf.meshes;\n  if (defined(meshes)) {\n    for (const mesh of meshes) {\n      const primitives = mesh.primitives;\n      if (defined(primitives)) {\n        for (const primitive of primitives) {\n          const primitiveExtensions = primitive.extensions;\n          if (defined(primitiveExtensions)) {\n            const meshPrimitiveGpmExtension = primitiveExtensions.NGA_gpm_local;\n            if (defined(meshPrimitiveGpmExtension)) {\n              const promise = loadMeshPrimitiveGpm(\n                loader,\n                gltf,\n                meshPrimitiveGpmExtension,\n                frameState,\n              );\n              loader._loaderPromises.push(promise);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Gather promises and handle any errors\n  const readyPromises = [];\n  readyPromises.push.apply(readyPromises, loader._loaderPromises);\n\n  // When incrementallyLoadTextures is true, the errors are caught and thrown individually\n  // since it doesn't affect the overall loader state\n  if (!loader._incrementallyLoadTextures) {\n    readyPromises.push.apply(readyPromises, loader._texturesPromises);\n  }\n\n  return Promise.all(readyPromises);\n}\n\nfunction unloadTextures(loader) {\n  const textureLoaders = loader._textureLoaders;\n  for (let i = 0; i < textureLoaders.length; ++i) {\n    textureLoaders[i] =\n      !textureLoaders[i].isDestroyed() &&\n      ResourceCache.unload(textureLoaders[i]);\n  }\n  loader._textureLoaders.length = 0;\n}\n\nfunction unloadBufferViewLoaders(loader) {\n  const bufferViewLoaders = loader._bufferViewLoaders;\n  for (let i = 0; i < bufferViewLoaders.length; ++i) {\n    bufferViewLoaders[i] =\n      !bufferViewLoaders[i].isDestroyed() &&\n      ResourceCache.unload(bufferViewLoaders[i]);\n  }\n  loader._bufferViewLoaders.length = 0;\n}\n\nfunction unloadGeometry(loader) {\n  const geometryLoaders = loader._geometryLoaders;\n  for (let i = 0; i < geometryLoaders.length; ++i) {\n    geometryLoaders[i] =\n      !geometryLoaders[i].isDestroyed() &&\n      ResourceCache.unload(geometryLoaders[i]);\n  }\n  loader._geometryLoaders.length = 0;\n}\n\nfunction unloadGeneratedAttributes(loader) {\n  const buffers = loader._postProcessBuffers;\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    if (!buffer.isDestroyed()) {\n      buffer.destroy();\n    }\n  }\n  buffers.length = 0;\n}\n\nfunction unloadStructuralMetadata(loader) {\n  if (\n    defined(loader._structuralMetadataLoader) &&\n    !loader._structuralMetadataLoader.isDestroyed()\n  ) {\n    loader._structuralMetadataLoader.destroy();\n    loader._structuralMetadataLoader = undefined;\n  }\n}\n\nfunction unloadMeshPrimitiveGpm(loader) {\n  if (\n    defined(loader._meshPrimitiveGpmLoader) &&\n    !loader._meshPrimitiveGpmLoader.isDestroyed()\n  ) {\n    loader._meshPrimitiveGpmLoader.destroy();\n    loader._meshPrimitiveGpmLoader = undefined;\n  }\n}\n\n/**\n * Returns whether the resource has been unloaded.\n * @private\n */\nGltfLoader.prototype.isUnloaded = function () {\n  return this._state === GltfLoaderState.UNLOADED;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfLoader.prototype.unload = function () {\n  if (defined(this._gltfJsonLoader) && !this._gltfJsonLoader.isDestroyed()) {\n    ResourceCache.unload(this._gltfJsonLoader);\n  }\n  this._gltfJsonLoader = undefined;\n\n  unloadTextures(this);\n  unloadBufferViewLoaders(this);\n  unloadGeometry(this);\n  unloadGeneratedAttributes(this);\n  unloadStructuralMetadata(this);\n  unloadMeshPrimitiveGpm(this);\n\n  this._components = undefined;\n  this._typedArray = undefined;\n  this._state = GltfLoaderState.UNLOADED;\n};\n\nexport default GltfLoader;\n"],"mappings":"AAAA,OAAOA,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,qBAAqB,MAAM,yCAAyC;AAC3E,OAAOC,kBAAkB,MAAM,sCAAsC;AACrE,OAAOC,yBAAyB,MAAM,6CAA6C;AACnF,OAAOC,4BAA4B,MAAM,mCAAmC;AAC5E,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,IAAI,MAAM,WAAW;AAC5B,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,yBAAyB,MAAM,gCAAgC;AACtE,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,uBAAuB,MAAM,8BAA8B;AAClE,OAAOC,aAAa,MAAM,yCAAyC;AACnE,OAAOC,0BAA0B,MAAM,sDAAsD;AAC7F,OAAOC,cAAc,MAAM,2BAA2B;AAEtD,MAAM;EACJC,SAAS;EACTC,OAAO;EACPC,kBAAkB;EAClBC,gBAAgB;EAChBC,sBAAsB;EACtBC,WAAW;EACXC,SAAS;EACTC,SAAS;EACTC,IAAI;EACJC,IAAI;EACJC,oBAAoB;EACpBC,gBAAgB;EAChBC,eAAe;EACfC,gBAAgB;EAChBC,SAAS;EACTC,iBAAiB;EACjBC,YAAY;EACZC,KAAK;EACLC,KAAK;EACLC,UAAU;EACVC,iBAAiB;EACjBC,kBAAkB;EAClBC,QAAQ;EACRC,UAAU;EACVC,SAAS;EACTC;AACF,CAAC,GAAGlC,eAAe;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmC,eAAe,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAU,EAAE,CAAC;EACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAO,EAAE,CAAC;EACV;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,CAAC;EACT;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAU,EAAE,CAAC;EACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,eAAe,EAAE,CAAC;EAClB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAAS,EAAE,CAAC;EACZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE,CAAC;EACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,CAAC;EACT;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,QAAQ,EAAE;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACC,OAAO,EAAE;EAC3BA,OAAO,GAAGhE,YAAY,CAACgE,OAAO,EAAEhE,YAAY,CAACiE,YAAY,CAAC;EAC1D,MAAM;IACJC,YAAY;IACZC,UAAU;IACVC,eAAe,GAAG,KAAK;IACvBC,YAAY,GAAG,IAAI;IACnBC,yBAAyB,GAAG,IAAI;IAChCC,MAAM,GAAGzD,IAAI,CAAC0D,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}