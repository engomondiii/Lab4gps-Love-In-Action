{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The classification pipeline stage is responsible for batching features\n * together to be rendered by the {@link ClassificationModelDrawCommand}.\n *\n * @namespace ClassificationPipelineStage\n *\n * @private\n */\nconst ClassificationPipelineStage = {\n  name: \"ClassificationPipelineStage\" // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the shader to indicate that the primitive classifies other assets</li>\n *  <li>adds arrays containing batch lengths and offsets to the primitive's resources\n * </ul>\n *\n * <p>\n * See {@link ClassificationModelDrawCommand} for the use of the batch offsets and lengths.\n * </p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nClassificationPipelineStage.process = function (renderResources, primitive, frameState) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_CLASSIFICATION\", undefined, ShaderDestination.BOTH);\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  if (!defined(runtimePrimitive.batchLengths)) {\n    createClassificationBatches(primitive, runtimePrimitive);\n  }\n};\nfunction createClassificationBatches(primitive, runtimePrimitive) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.POSITION);\n  if (!defined(positionAttribute)) {\n    throw new RuntimeError(\"Primitives must have a position attribute to be used for classification.\");\n  }\n  let indicesArray;\n  const indices = primitive.indices;\n  const hasIndices = defined(indices);\n  if (hasIndices) {\n    indicesArray = indices.typedArray;\n    // Unload the typed array. This is just a pointer to the array in\n    // the index buffer loader.\n    indices.typedArray = undefined;\n  }\n  const count = hasIndices ? indices.count : positionAttribute.count;\n  const featureIdAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.FEATURE_ID, 0);\n\n  // If there are no feature IDs, render the primitive in a single batch.\n  if (!defined(featureIdAttribute)) {\n    runtimePrimitive.batchLengths = [count];\n    runtimePrimitive.batchOffsets = [0];\n    return;\n  }\n  const featureIds = featureIdAttribute.typedArray;\n  // Unload the typed array. This is just a pointer to the array in\n  // the vertex buffer loader, so if the typed array is shared by\n  // multiple primitives (i.e. multiple instances of the same mesh),\n  // this will not affect the other primitives.\n  featureIdAttribute.typedArray = undefined;\n  const batchLengths = [];\n  const batchOffsets = [0];\n  const firstIndex = hasIndices ? indicesArray[0] : 0;\n  let currentBatchId = featureIds[firstIndex];\n  let currentOffset = 0;\n  for (let i = 1; i < count; i++) {\n    const index = hasIndices ? indicesArray[i] : i;\n    const batchId = featureIds[index];\n    if (batchId !== currentBatchId) {\n      // Store the length of this batch and begin counting the next one.\n      const batchLength = i - currentOffset;\n      const newOffset = i;\n      batchLengths.push(batchLength);\n      batchOffsets.push(newOffset);\n      currentOffset = newOffset;\n      currentBatchId = batchId;\n    }\n  }\n  const finalBatchLength = count - currentOffset;\n  batchLengths.push(finalBatchLength);\n  runtimePrimitive.batchLengths = batchLengths;\n  runtimePrimitive.batchOffsets = batchOffsets;\n}\nexport default ClassificationPipelineStage;","map":{"version":3,"names":["defined","RuntimeError","ShaderDestination","VertexAttributeSemantic","ModelUtility","ClassificationPipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","addDefine","undefined","BOTH","runtimePrimitive","batchLengths","createClassificationBatches","positionAttribute","getAttributeBySemantic","POSITION","indicesArray","indices","hasIndices","typedArray","count","featureIdAttribute","FEATURE_ID","batchOffsets","featureIds","firstIndex","currentBatchId","currentOffset","i","index","batchId","batchLength","newOffset","push","finalBatchLength"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ClassificationPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The classification pipeline stage is responsible for batching features\n * together to be rendered by the {@link ClassificationModelDrawCommand}.\n *\n * @namespace ClassificationPipelineStage\n *\n * @private\n */\nconst ClassificationPipelineStage = {\n  name: \"ClassificationPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the shader to indicate that the primitive classifies other assets</li>\n *  <li>adds arrays containing batch lengths and offsets to the primitive's resources\n * </ul>\n *\n * <p>\n * See {@link ClassificationModelDrawCommand} for the use of the batch offsets and lengths.\n * </p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nClassificationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_CLASSIFICATION\",\n    undefined,\n    ShaderDestination.BOTH,\n  );\n\n  const runtimePrimitive = renderResources.runtimePrimitive;\n\n  if (!defined(runtimePrimitive.batchLengths)) {\n    createClassificationBatches(primitive, runtimePrimitive);\n  }\n};\n\nfunction createClassificationBatches(primitive, runtimePrimitive) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n\n  if (!defined(positionAttribute)) {\n    throw new RuntimeError(\n      \"Primitives must have a position attribute to be used for classification.\",\n    );\n  }\n\n  let indicesArray;\n  const indices = primitive.indices;\n  const hasIndices = defined(indices);\n  if (hasIndices) {\n    indicesArray = indices.typedArray;\n    // Unload the typed array. This is just a pointer to the array in\n    // the index buffer loader.\n    indices.typedArray = undefined;\n  }\n\n  const count = hasIndices ? indices.count : positionAttribute.count;\n  const featureIdAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.FEATURE_ID,\n    0,\n  );\n\n  // If there are no feature IDs, render the primitive in a single batch.\n  if (!defined(featureIdAttribute)) {\n    runtimePrimitive.batchLengths = [count];\n    runtimePrimitive.batchOffsets = [0];\n\n    return;\n  }\n\n  const featureIds = featureIdAttribute.typedArray;\n  // Unload the typed array. This is just a pointer to the array in\n  // the vertex buffer loader, so if the typed array is shared by\n  // multiple primitives (i.e. multiple instances of the same mesh),\n  // this will not affect the other primitives.\n  featureIdAttribute.typedArray = undefined;\n\n  const batchLengths = [];\n  const batchOffsets = [0];\n\n  const firstIndex = hasIndices ? indicesArray[0] : 0;\n  let currentBatchId = featureIds[firstIndex];\n  let currentOffset = 0;\n\n  for (let i = 1; i < count; i++) {\n    const index = hasIndices ? indicesArray[i] : i;\n    const batchId = featureIds[index];\n\n    if (batchId !== currentBatchId) {\n      // Store the length of this batch and begin counting the next one.\n      const batchLength = i - currentOffset;\n      const newOffset = i;\n\n      batchLengths.push(batchLength);\n      batchOffsets.push(newOffset);\n\n      currentOffset = newOffset;\n      currentBatchId = batchId;\n    }\n  }\n\n  const finalBatchLength = count - currentOffset;\n  batchLengths.push(finalBatchLength);\n\n  runtimePrimitive.batchLengths = batchLengths;\n  runtimePrimitive.batchOffsets = batchOffsets;\n}\n\nexport default ClassificationPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}