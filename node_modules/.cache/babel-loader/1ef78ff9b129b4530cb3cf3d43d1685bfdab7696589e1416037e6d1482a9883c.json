{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n  const vertexCount = this._quantizedVertices.length / 3;\n  const uValues = this._uValues = this._quantizedVertices.subarray(0, vertexCount);\n  const vValues = this._vValues = this._quantizedVertices.subarray(vertexCount, 2 * vertexCount);\n  this._heightValues = this._quantizedVertices.subarray(2 * vertexCount, 3 * vertexCount);\n\n  // We don't assume that we can count on the edge vertices being sorted by u or v.\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n  this._westIndices = sortIndicesIfNecessary(options.westIndices, sortByV, vertexCount);\n  this._southIndices = sortIndicesIfNecessary(options.southIndices, sortByU, vertexCount);\n  this._eastIndices = sortIndicesIfNecessary(options.eastIndices, sortByV, vertexCount);\n  this._northIndices = sortIndicesIfNecessary(options.northIndices, sortByU, vertexCount);\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n  this._mesh = undefined;\n}\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    }\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    }\n  },\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    }\n  },\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    }\n  }\n});\nconst arrayScratch = [];\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n  let needsSort = false;\n  for (let i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort = needsSort || i > 0 && sortFunction(indices[i - 1], indices[i]) > 0;\n  }\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n  return indices;\n}\nconst createMeshTaskName = \"createVerticesFromQuantizedTerrainMesh\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(createMeshTaskName, TerrainData.maximumAsynchronousTasks);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nQuantizedMeshTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(options.exaggerationRelativeHeight, 0.0);\n  const throttle = defaultValue(options.throttle, true);\n  const ellipsoid = tilingScheme.ellipsoid;\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  const createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight\n  });\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    const vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    const vertexCount = vertexCountWithoutSkirts + that._westIndices.length + that._southIndices.length + that._eastIndices.length + that._northIndices.length;\n    const indicesTypedArray = IndexDatatype.createTypedArray(vertexCount, result.indices);\n    const vertices = new Float32Array(result.vertices);\n    const rtc = result.center;\n    const minimumHeight = result.minimumHeight;\n    const maximumHeight = result.maximumHeight;\n    const boundingSphere = that._boundingSphere;\n    const obb = that._orientedBoundingBox;\n    const occludeePointInScaledSpace = defaultValue(Cartesian3.clone(result.occludeePointInScaledSpace), that._horizonOcclusionPoint);\n    const stride = result.vertexStride;\n    const terrainEncoding = TerrainEncoding.clone(result.encoding);\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(rtc, vertices, indicesTypedArray, result.indexCountWithoutSkirts, vertexCountWithoutSkirts, minimumHeight, maximumHeight, boundingSphere, occludeePointInScaledSpace, stride, obb, terrainEncoding, result.westIndicesSouthToNorth, result.southIndicesEastToWest, result.eastIndicesNorthToSouth, result.northIndicesWestToEast);\n\n    // Free memory received from server after mesh is created.\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n    return that._mesh;\n  });\n};\nconst upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\", TerrainData.maximumAsynchronousTasks);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nQuantizedMeshTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid\n  });\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n  let shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n  const westSkirtHeight = isEastChild ? shortestSkirt * 0.5 : this._westSkirtHeight;\n  const southSkirtHeight = isNorthChild ? shortestSkirt * 0.5 : this._southSkirtHeight;\n  const eastSkirtHeight = isEastChild ? this._eastSkirtHeight : shortestSkirt * 0.5;\n  const northSkirtHeight = isNorthChild ? this._northSkirtHeight : shortestSkirt * 0.5;\n  const credits = this._credits;\n  return Promise.resolve(upsamplePromise).then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);\n    let encodedNormals;\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(result.orientedBoundingBox),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true\n    });\n  });\n};\nconst maxShort = 32767;\nconst barycentricCoordinateScratch = new Cartesian3();\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  let u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0.0, 1.0);\n  u *= maxShort;\n  let v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0.0, 1.0);\n  v *= maxShort;\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n  return interpolateMeshHeight(this, u, v);\n};\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  const minU = Math.min(u0, u1, u2);\n  const maxU = Math.max(u0, u1, u2);\n  const minV = Math.min(v0, v1, v2);\n  const maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    const uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    const uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y, barycentricCoordinateScratch);\n      if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n        const h0 = encoding.decodeHeight(vertices, i0);\n        const h1 = encoding.decodeHeight(vertices, i1);\n        const h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nfunction interpolateHeight(terrainData, u, v) {\n  const uBuffer = terrainData._uValues;\n  const vBuffer = terrainData._vValues;\n  const heightBuffer = terrainData._heightValues;\n  const indices = terrainData._indices;\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);\n      if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n        const quantizedHeight = barycentric.x * heightBuffer[i0] + barycentric.y * heightBuffer[i1] + barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(terrainData._minimumHeight, terrainData._maximumHeight, quantizedHeight / maxShort);\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nexport default QuantizedMeshTerrainData;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Check","defaultValue","defined","DeveloperError","IndexDatatype","Intersections2D","CesiumMath","OrientedBoundingBox","TaskProcessor","TerrainData","TerrainEncoding","TerrainMesh","QuantizedMeshTerrainData","options","quantizedVertices","indices","minimumHeight","maximumHeight","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","_quantizedVertices","_encodedNormals","encodedNormals","_indices","_minimumHeight","_maximumHeight","_boundingSphere","_orientedBoundingBox","orientedBoundingBox","_horizonOcclusionPoint","_credits","credits","vertexCount","length","uValues","_uValues","subarray","vValues","_vValues","_heightValues","sortByV","a","b","sortByU","_westIndices","sortIndicesIfNecessary","_southIndices","_eastIndices","_northIndices","_westSkirtHeight","_southSkirtHeight","_eastSkirtHeight","_northSkirtHeight","_childTileMask","childTileMask","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_mesh","undefined","Object","defineProperties","prototype","get","canUpsample","arrayScratch","sortFunction","needsSort","i","len","sort","createTypedArray","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","createMesh","EMPTY_OBJECT","typeOf","object","tilingScheme","number","x","y","level","exaggeration","exaggerationRelativeHeight","throttle","ellipsoid","rectangle","tileXYToRectangle","createMeshTaskProcessor","verticesPromise","scheduleTask","octEncodedNormals","includeWebMercatorT","relativeToCenter","center","that","Promise","resolve","then","result","vertexCountWithoutSkirts","indicesTypedArray","vertices","Float32Array","rtc","obb","occludeePointInScaledSpace","clone","stride","vertexStride","terrainEncoding","encoding","indexCountWithoutSkirts","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","shortestSkirt","Math","min","Uint16Array","Uint8Array","maxShort","barycentricCoordinateScratch","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","pointInBoundingBox","u0","v0","u1","v1","u2","v2","minU","maxU","max","minV","maxV","texCoordScratch0","texCoordScratch1","texCoordScratch2","terrainData","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","uBuffer","vBuffer","heightBuffer","quantizedHeight","lerp","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/QuantizedMeshTerrainData.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n\n  const vertexCount = this._quantizedVertices.length / 3;\n  const uValues = (this._uValues = this._quantizedVertices.subarray(\n    0,\n    vertexCount,\n  ));\n  const vValues = (this._vValues = this._quantizedVertices.subarray(\n    vertexCount,\n    2 * vertexCount,\n  ));\n  this._heightValues = this._quantizedVertices.subarray(\n    2 * vertexCount,\n    3 * vertexCount,\n  );\n\n  // We don't assume that we can count on the edge vertices being sorted by u or v.\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(\n    options.westIndices,\n    sortByV,\n    vertexCount,\n  );\n  this._southIndices = sortIndicesIfNecessary(\n    options.southIndices,\n    sortByU,\n    vertexCount,\n  );\n  this._eastIndices = sortIndicesIfNecessary(\n    options.eastIndices,\n    sortByV,\n    vertexCount,\n  );\n  this._northIndices = sortIndicesIfNecessary(\n    options.northIndices,\n    sortByU,\n    vertexCount,\n  );\n\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    },\n  },\n});\n\nconst arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n\n  let needsSort = false;\n  for (let i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort =\n      needsSort || (i > 0 && sortFunction(indices[i - 1], indices[i]) > 0);\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n  return indices;\n}\n\nconst createMeshTaskName = \"createVerticesFromQuantizedTerrainMesh\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {number} options.level The level of the tile for which to create the terrain data.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nQuantizedMeshTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0,\n  );\n  const throttle = defaultValue(options.throttle, true);\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    const vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    const vertexCount =\n      vertexCountWithoutSkirts +\n      that._westIndices.length +\n      that._southIndices.length +\n      that._eastIndices.length +\n      that._northIndices.length;\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      vertexCount,\n      result.indices,\n    );\n\n    const vertices = new Float32Array(result.vertices);\n    const rtc = result.center;\n    const minimumHeight = result.minimumHeight;\n    const maximumHeight = result.maximumHeight;\n    const boundingSphere = that._boundingSphere;\n    const obb = that._orientedBoundingBox;\n    const occludeePointInScaledSpace = defaultValue(\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      that._horizonOcclusionPoint,\n    );\n    const stride = result.vertexStride;\n    const terrainEncoding = TerrainEncoding.clone(result.encoding);\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      rtc,\n      vertices,\n      indicesTypedArray,\n      result.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      minimumHeight,\n      maximumHeight,\n      boundingSphere,\n      occludeePointInScaledSpace,\n      stride,\n      obb,\n      terrainEncoding,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast,\n    );\n\n    // Free memory received from server after mesh is created.\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n\n    return that._mesh;\n  });\n};\n\nconst upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks,\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {number} thisLevel The level of this tile in the tiling scheme.\n * @param {number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nQuantizedMeshTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel,\n  );\n\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  let shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n\n  const westSkirtHeight = isEastChild\n    ? shortestSkirt * 0.5\n    : this._westSkirtHeight;\n  const southSkirtHeight = isNorthChild\n    ? shortestSkirt * 0.5\n    : this._southSkirtHeight;\n  const eastSkirtHeight = isEastChild\n    ? this._eastSkirtHeight\n    : shortestSkirt * 0.5;\n  const northSkirtHeight = isNorthChild\n    ? this._northSkirtHeight\n    : shortestSkirt * 0.5;\n  const credits = this._credits;\n\n  return Promise.resolve(upsamplePromise).then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices,\n    );\n    let encodedNormals;\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox,\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true,\n    });\n  });\n};\n\nconst maxShort = 32767;\nconst barycentricCoordinateScratch = new Cartesian3();\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {number} longitude The longitude in radians.\n * @param {number} latitude The latitude in radians.\n * @returns {number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude,\n) {\n  let u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0,\n  );\n  u *= maxShort;\n  let v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0,\n  );\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  const minU = Math.min(u0, u1, u2);\n  const maxU = Math.max(u0, u1, u2);\n  const minV = Math.min(v0, v1, v2);\n  const maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const uv0 = encoding.decodeTextureCoordinates(\n      vertices,\n      i0,\n      texCoordScratch0,\n    );\n    const uv1 = encoding.decodeTextureCoordinates(\n      vertices,\n      i1,\n      texCoordScratch1,\n    );\n    const uv2 = encoding.decodeTextureCoordinates(\n      vertices,\n      i2,\n      texCoordScratch2,\n    );\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        uv0.x,\n        uv0.y,\n        uv1.x,\n        uv1.y,\n        uv2.x,\n        uv2.y,\n        barycentricCoordinateScratch,\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        const h0 = encoding.decodeHeight(vertices, i0);\n        const h1 = encoding.decodeHeight(vertices, i1);\n        const h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  const uBuffer = terrainData._uValues;\n  const vBuffer = terrainData._vValues;\n  const heightBuffer = terrainData._heightValues;\n\n  const indices = terrainData._indices;\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        u0,\n        v0,\n        u1,\n        v1,\n        u2,\n        v2,\n        barycentricCoordinateScratch,\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        const quantizedHeight =\n          barycentric.x * heightBuffer[i0] +\n          barycentric.y * heightBuffer[i1] +\n          barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(\n          terrainData._minimumHeight,\n          terrainData._maximumHeight,\n          quantizedHeight / maxShort,\n        );\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {number} thisX The tile X coordinate of this (the parent) tile.\n * @param {number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {number} childX The tile X coordinate of the child tile to check for availability.\n * @param {number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {boolean} True if the child tile is available; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {boolean} True if this instance was created by upsampling; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nexport default QuantizedMeshTerrainData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}