{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nconst defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nconst cos = Math.cos;\nconst sin = Math.sin;\n\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const radii = defaultValue(options.radii, defaultRadii);\n  const innerRadii = defaultValue(options.innerRadii, radii);\n  const minimumClock = defaultValue(options.minimumClock, 0.0);\n  const maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  const minimumCone = defaultValue(options.minimumCone, 0.0);\n  const maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  const stackPartitions = Math.round(defaultValue(options.stackPartitions, 10));\n  const slicePartitions = Math.round(defaultValue(options.slicePartitions, 8));\n  const subdivisions = Math.round(defaultValue(options.subdivisions, 128));\n\n  //>>includeStart('debug', pragmas.debug);\n  if (stackPartitions < 1) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than 1\");\n  }\n  if (slicePartitions < 0) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than 0\");\n  }\n  if (subdivisions < 0) {\n    throw new DeveloperError(\"options.subdivisions must be greater than or equal to zero.\");\n  }\n  if (defined(options.offsetAttribute) && options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n    throw new DeveloperError(\"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchRadii = new Cartesian3();\nconst scratchInnerRadii = new Cartesian3();\nconst scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n  const innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n  const minimumClock = array[startingIndex++];\n  const maximumClock = array[startingIndex++];\n  const minimumCone = array[startingIndex++];\n  const maximumCone = array[startingIndex++];\n  const stackPartitions = array[startingIndex++];\n  const slicePartitions = array[startingIndex++];\n  const subdivisions = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  const radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n  const innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n  const minimumClock = ellipsoidGeometry._minimumClock;\n  const maximumClock = ellipsoidGeometry._maximumClock;\n  const minimumCone = ellipsoidGeometry._minimumCone;\n  const maximumCone = ellipsoidGeometry._maximumCone;\n  const subdivisions = ellipsoidGeometry._subdivisions;\n  const ellipsoid = Ellipsoid.fromCartesian3(radii);\n\n  // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n  let slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  let stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n  slicePartitions = Math.round(slicePartitions * Math.abs(maximumClock - minimumClock) / CesiumMath.TWO_PI);\n  stackPartitions = Math.round(stackPartitions * Math.abs(maximumCone - minimumCone) / CesiumMath.PI);\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n  let extraIndices = 0;\n  let vertexMultiplier = 1.0;\n  const hasInnerSurface = innerRadii.x !== radii.x || innerRadii.y !== radii.y || innerRadii.z !== radii.z;\n  let isTopOpen = false;\n  let isBotOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n  const vertexCount = subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  const positions = new Float64Array(vertexCount * 3);\n\n  // Multiply by two because two points define each line segment\n  const numIndices = 2 * (vertexCount + extraIndices - (slicePartitions + stackPartitions) * vertexMultiplier);\n  const indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\n  let i;\n  let j;\n  let theta;\n  let phi;\n  let index = 0;\n\n  // Calculate sin/cos phi\n  const sinPhi = new Array(stackPartitions);\n  const cosPhi = new Array(stackPartitions);\n  for (i = 0; i < stackPartitions; i++) {\n    phi = minimumCone + i * (maximumCone - minimumCone) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta\n  const sinTheta = new Array(subdivisions);\n  const cosTheta = new Array(subdivisions);\n  for (i = 0; i < subdivisions; i++) {\n    theta = minimumClock + i * (maximumClock - minimumClock) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the latitude lines on the outer surface\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the latitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Calculate sin/cos phi\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + i * (maximumCone - minimumCone) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta for each slice partition\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n  for (i = 0; i < slicePartitions; i++) {\n    theta = minimumClock + i * (maximumClock - minimumClock) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the longitude lines on the outer surface\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the longitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Create indices for the latitude lines\n  index = 0;\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    const topOffset = i * subdivisions;\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  }\n\n  // Create indices for the outer longitude lines\n  let offset = stackPartitions * subdivisions * vertexMultiplier;\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  }\n\n  // Create indices for the inner longitude lines\n  if (hasInnerSurface) {\n    offset = stackPartitions * subdivisions * vertexMultiplier + slicePartitions * subdivisions;\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n  if (hasInnerSurface) {\n    let outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    let innerOffset = outerOffset + subdivisions * slicePartitions;\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute\n  });\n};\nexport default EllipsoidOutlineGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","defaultRadii","cos","Math","sin","EllipsoidOutlineGeometry","options","EMPTY_OBJECT","radii","innerRadii","minimumClock","maximumClock","TWO_PI","minimumCone","maximumCone","PI","stackPartitions","round","slicePartitions","subdivisions","offsetAttribute","TOP","_radii","clone","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","_subdivisions","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRadii","scratchInnerRadii","scratchOptions","undefined","unpack","result","createGeometry","ellipsoidGeometry","x","y","z","ellipsoid","fromCartesian3","abs","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","vertexCount","positions","Float64Array","numIndices","indices","createTypedArray","i","j","theta","phi","index","sinPhi","Array","cosPhi","sinTheta","cosTheta","length","topOffset","offset","outerOffset","innerOffset","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","offsetValue","NONE","applyOffset","Uint8Array","fill","UNSIGNED_BYTE","primitiveType","LINES","boundingSphere","fromEllipsoid"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EllipsoidOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nconst cos = Math.cos;\nconst sin = Math.sin;\n\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const radii = defaultValue(options.radii, defaultRadii);\n  const innerRadii = defaultValue(options.innerRadii, radii);\n  const minimumClock = defaultValue(options.minimumClock, 0.0);\n  const maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  const minimumCone = defaultValue(options.minimumCone, 0.0);\n  const maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  const stackPartitions = Math.round(defaultValue(options.stackPartitions, 10));\n  const slicePartitions = Math.round(defaultValue(options.slicePartitions, 8));\n  const subdivisions = Math.round(defaultValue(options.subdivisions, 128));\n\n  //>>includeStart('debug', pragmas.debug);\n  if (stackPartitions < 1) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than 1\");\n  }\n  if (slicePartitions < 0) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than 0\");\n  }\n  if (subdivisions < 0) {\n    throw new DeveloperError(\n      \"options.subdivisions must be greater than or equal to zero.\",\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchRadii = new Cartesian3();\nconst scratchInnerRadii = new Cartesian3();\nconst scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const minimumClock = array[startingIndex++];\n  const maximumClock = array[startingIndex++];\n  const minimumCone = array[startingIndex++];\n  const maximumCone = array[startingIndex++];\n  const stackPartitions = array[startingIndex++];\n  const slicePartitions = array[startingIndex++];\n  const subdivisions = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  const radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  const innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  const minimumClock = ellipsoidGeometry._minimumClock;\n  const maximumClock = ellipsoidGeometry._maximumClock;\n  const minimumCone = ellipsoidGeometry._minimumCone;\n  const maximumCone = ellipsoidGeometry._maximumCone;\n  const subdivisions = ellipsoidGeometry._subdivisions;\n  const ellipsoid = Ellipsoid.fromCartesian3(radii);\n\n  // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n  let slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  let stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI,\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI,\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  let extraIndices = 0;\n  let vertexMultiplier = 1.0;\n  const hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  let isTopOpen = false;\n  let isBotOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n\n  const vertexCount =\n    subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  const positions = new Float64Array(vertexCount * 3);\n\n  // Multiply by two because two points define each line segment\n  const numIndices =\n    2 *\n    (vertexCount +\n      extraIndices -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  const indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\n\n  let i;\n  let j;\n  let theta;\n  let phi;\n  let index = 0;\n\n  // Calculate sin/cos phi\n  const sinPhi = new Array(stackPartitions);\n  const cosPhi = new Array(stackPartitions);\n  for (i = 0; i < stackPartitions; i++) {\n    phi =\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta\n  const sinTheta = new Array(subdivisions);\n  const cosTheta = new Array(subdivisions);\n  for (i = 0; i < subdivisions; i++) {\n    theta =\n      minimumClock + (i * (maximumClock - minimumClock)) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the latitude lines on the outer surface\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the latitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Calculate sin/cos phi\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + (i * (maximumCone - minimumCone)) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta for each slice partition\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n  for (i = 0; i < slicePartitions; i++) {\n    theta =\n      minimumClock +\n      (i * (maximumClock - minimumClock)) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the longitude lines on the outer surface\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the longitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Create indices for the latitude lines\n  index = 0;\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    const topOffset = i * subdivisions;\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  }\n\n  // Create indices for the outer longitude lines\n  let offset = stackPartitions * subdivisions * vertexMultiplier;\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  }\n\n  // Create indices for the inner longitude lines\n  if (hasInnerSurface) {\n    offset =\n      stackPartitions * subdivisions * vertexMultiplier +\n      slicePartitions * subdivisions;\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n\n  if (hasInnerSurface) {\n    let outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    let innerOffset = outerOffset + subdivisions * slicePartitions;\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\nexport default EllipsoidOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}