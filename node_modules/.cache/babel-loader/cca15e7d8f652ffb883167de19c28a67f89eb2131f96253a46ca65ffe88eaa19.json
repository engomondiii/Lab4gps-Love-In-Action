{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport Autolinker from \"autolinker\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PolylineOutlineMaterialProperty from \"./PolylineOutlineMaterialProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nlet parser;\nif (typeof DOMParser !== \"undefined\") {\n  parser = new DOMParser();\n}\nconst autolinker = new Autolinker({\n  stripPrefix: false,\n  email: false,\n  replaceFn: function (linker, match) {\n    //Prevent matching of non-explicit urls.\n    //i.e. foo.id won't match but http://foo.id will\n    return match.urlMatchType === \"scheme\" || match.urlMatchType === \"www\";\n  }\n});\nconst BILLBOARD_SIZE = 32;\nconst BILLBOARD_NEAR_DISTANCE = 2414016;\nconst BILLBOARD_NEAR_RATIO = 1.0;\nconst BILLBOARD_FAR_DISTANCE = 1.6093e7;\nconst BILLBOARD_FAR_RATIO = 0.1;\nconst gpxNamespaces = [null, undefined, \"http://www.topografix.com/GPX/1/1\"];\nconst namespaces = {\n  gpx: gpxNamespaces\n};\nfunction readBlobAsText(blob) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", function () {\n      resolve(reader.result);\n    });\n    reader.addEventListener(\"error\", function () {\n      reject(reader.error);\n    });\n    reader.readAsText(blob);\n  });\n}\nfunction getOrCreateEntity(node, entityCollection) {\n  let id = queryStringAttribute(node, \"id\");\n  id = defined(id) ? id : createGuid();\n  const entity = entityCollection.getOrCreateEntity(id);\n  return entity;\n}\nfunction readCoordinateFromNode(node) {\n  const longitude = queryNumericAttribute(node, \"lon\");\n  const latitude = queryNumericAttribute(node, \"lat\");\n  const elevation = queryNumericValue(node, \"ele\", namespaces.gpx);\n  return Cartesian3.fromDegrees(longitude, latitude, elevation);\n}\nfunction queryNumericAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  if (value !== null) {\n    const result = parseFloat(value);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\nfunction queryStringAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  return value !== null ? value : undefined;\n}\nfunction queryFirstNode(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      return child;\n    }\n  }\n  return undefined;\n}\nfunction queryNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const result = [];\n  const childNodes = node.getElementsByTagName(tagName);\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      result.push(child);\n    }\n  }\n  return result;\n}\nfunction queryNumericValue(node, tagName, namespace) {\n  const resultNode = queryFirstNode(node, tagName, namespace);\n  if (defined(resultNode)) {\n    const result = parseFloat(resultNode.textContent);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\nfunction queryStringValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    return result.textContent.trim();\n  }\n  return undefined;\n}\nfunction createDefaultBillboard(image) {\n  const billboard = new BillboardGraphics();\n  billboard.width = BILLBOARD_SIZE;\n  billboard.height = BILLBOARD_SIZE;\n  billboard.scaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n  billboard.pixelOffsetScaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n  billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);\n  billboard.image = image;\n  return billboard;\n}\nfunction createDefaultLabel() {\n  const label = new LabelGraphics();\n  label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n  label.pixelOffset = new Cartesian2(17, 0);\n  label.horizontalOrigin = HorizontalOrigin.LEFT;\n  label.font = \"16px sans-serif\";\n  label.style = LabelStyle.FILL_AND_OUTLINE;\n  return label;\n}\nfunction createDefaultPolyline(color) {\n  const polyline = new PolylineGraphics();\n  polyline.width = 4;\n  polyline.material = new PolylineOutlineMaterialProperty();\n  polyline.material.color = defined(color) ? color : Color.RED;\n  polyline.material.outlineWidth = 2;\n  polyline.material.outlineColor = Color.BLACK;\n  return polyline;\n}\n\n// This is a list of the Optional Description Information:\n//  <cmt> GPS comment of the waypoint\n//  <desc> Descriptive description of the waypoint\n//  <src> Source of the waypoint data\n//  <type> Type (category) of waypoint\nconst descriptiveInfoTypes = {\n  time: {\n    text: \"Time\",\n    tag: \"time\"\n  },\n  comment: {\n    text: \"Comment\",\n    tag: \"cmt\"\n  },\n  description: {\n    text: \"Description\",\n    tag: \"desc\"\n  },\n  source: {\n    text: \"Source\",\n    tag: \"src\"\n  },\n  number: {\n    text: \"GPS track/route number\",\n    tag: \"number\"\n  },\n  type: {\n    text: \"Type\",\n    tag: \"type\"\n  }\n};\nlet scratchDiv;\nif (typeof document !== \"undefined\") {\n  scratchDiv = document.createElement(\"div\");\n}\nfunction processDescription(node, entity) {\n  let i;\n  let text = \"\";\n  const infoTypeNames = Object.keys(descriptiveInfoTypes);\n  const length = infoTypeNames.length;\n  for (i = 0; i < length; i++) {\n    const infoTypeName = infoTypeNames[i];\n    const infoType = descriptiveInfoTypes[infoTypeName];\n    infoType.value = defaultValue(queryStringValue(node, infoType.tag, namespaces.gpx), \"\");\n    if (defined(infoType.value) && infoType.value !== \"\") {\n      text = `${text}<p>${infoType.text}: ${infoType.value}</p>`;\n    }\n  }\n  if (!defined(text) || text === \"\") {\n    // No description\n    return;\n  }\n\n  // Turns non-explicit links into clickable links.\n  text = autolinker.link(text);\n\n  // Use a temporary div to manipulate the links\n  // so that they open in a new window.\n  scratchDiv.innerHTML = text;\n  const links = scratchDiv.querySelectorAll(\"a\");\n  for (i = 0; i < links.length; i++) {\n    links[i].setAttribute(\"target\", \"_blank\");\n  }\n  const background = Color.WHITE;\n  const foreground = Color.BLACK;\n  let tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n  tmp += \"overflow:auto;\";\n  tmp += \"word-wrap:break-word;\";\n  tmp += `background-color:${background.toCssColorString()};`;\n  tmp += `color:${foreground.toCssColorString()};`;\n  tmp += '\">';\n  tmp += `${scratchDiv.innerHTML}</div>`;\n  scratchDiv.innerHTML = \"\";\n\n  // return the final HTML as the description.\n  return tmp;\n}\nfunction processWpt(dataSource, geometryNode, entityCollection, options) {\n  const position = readCoordinateFromNode(geometryNode);\n  const entity = getOrCreateEntity(geometryNode, entityCollection);\n  entity.position = position;\n\n  // Get billboard image\n  const image = defined(options.waypointImage) ? options.waypointImage : dataSource._pinBuilder.fromMakiIconId(\"marker\", Color.RED, BILLBOARD_SIZE);\n  entity.billboard = createDefaultBillboard(image);\n  const name = queryStringValue(geometryNode, \"name\", namespaces.gpx);\n  entity.name = name;\n  entity.label = createDefaultLabel();\n  entity.label.text = name;\n  entity.description = processDescription(geometryNode, entity);\n  if (options.clampToGround) {\n    entity.billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n    entity.label.heightReference = HeightReference.CLAMP_TO_GROUND;\n  }\n}\n\n// rte represents route - an ordered list of waypoints representing a series of turn points leading to a destination\nfunction processRte(dataSource, geometryNode, entityCollection, options) {\n  const entity = getOrCreateEntity(geometryNode, entityCollection);\n  entity.description = processDescription(geometryNode, entity);\n\n  // a list of waypoint\n  const routePoints = queryNodes(geometryNode, \"rtept\", namespaces.gpx);\n  const coordinateTuples = new Array(routePoints.length);\n  for (let i = 0; i < routePoints.length; i++) {\n    processWpt(dataSource, routePoints[i], entityCollection, options);\n    coordinateTuples[i] = readCoordinateFromNode(routePoints[i]);\n  }\n  entity.polyline = createDefaultPolyline(options.routeColor);\n  if (options.clampToGround) {\n    entity.polyline.clampToGround = true;\n  }\n  entity.polyline.positions = coordinateTuples;\n}\n\n// trk represents a track - an ordered list of points describing a path.\nfunction processTrk(dataSource, geometryNode, entityCollection, options) {\n  const entity = getOrCreateEntity(geometryNode, entityCollection);\n  entity.description = processDescription(geometryNode, entity);\n  const trackSegs = queryNodes(geometryNode, \"trkseg\", namespaces.gpx);\n  let positions = [];\n  let times = [];\n  let trackSegInfo;\n  let isTimeDynamic = true;\n  const property = new SampledPositionProperty();\n  for (let i = 0; i < trackSegs.length; i++) {\n    trackSegInfo = processTrkSeg(trackSegs[i]);\n    positions = positions.concat(trackSegInfo.positions);\n    if (trackSegInfo.times.length > 0) {\n      times = times.concat(trackSegInfo.times);\n      property.addSamples(times, positions);\n      // if one track segment is non dynamic the whole track must also be\n      isTimeDynamic = isTimeDynamic && true;\n    } else {\n      isTimeDynamic = false;\n    }\n  }\n  if (isTimeDynamic) {\n    // Assign billboard image\n    const image = defined(options.waypointImage) ? options.waypointImage : dataSource._pinBuilder.fromMakiIconId(\"marker\", Color.RED, BILLBOARD_SIZE);\n    entity.billboard = createDefaultBillboard(image);\n    entity.position = property;\n    if (options.clampToGround) {\n      entity.billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n    }\n    entity.availability = new TimeIntervalCollection();\n    entity.availability.addInterval(new TimeInterval({\n      start: times[0],\n      stop: times[times.length - 1]\n    }));\n  }\n  entity.polyline = createDefaultPolyline(options.trackColor);\n  entity.polyline.positions = positions;\n  if (options.clampToGround) {\n    entity.polyline.clampToGround = true;\n  }\n}\nfunction processTrkSeg(node) {\n  const result = {\n    positions: [],\n    times: []\n  };\n  const trackPoints = queryNodes(node, \"trkpt\", namespaces.gpx);\n  let time;\n  for (let i = 0; i < trackPoints.length; i++) {\n    const position = readCoordinateFromNode(trackPoints[i]);\n    result.positions.push(position);\n    time = queryStringValue(trackPoints[i], \"time\", namespaces.gpx);\n    if (defined(time)) {\n      result.times.push(JulianDate.fromIso8601(time));\n    }\n  }\n  return result;\n}\n\n// Processes a metadataType node and returns a metadata object\n// {@link http://www.topografix.com/gpx/1/1/#type_metadataType|GPX Schema}\nfunction processMetadata(node) {\n  const metadataNode = queryFirstNode(node, \"metadata\", namespaces.gpx);\n  if (defined(metadataNode)) {\n    const metadata = {\n      name: queryStringValue(metadataNode, \"name\", namespaces.gpx),\n      desc: queryStringValue(metadataNode, \"desc\", namespaces.gpx),\n      author: getPerson(metadataNode),\n      copyright: getCopyright(metadataNode),\n      link: getLink(metadataNode),\n      time: queryStringValue(metadataNode, \"time\", namespaces.gpx),\n      keywords: queryStringValue(metadataNode, \"keywords\", namespaces.gpx),\n      bounds: getBounds(metadataNode)\n    };\n    if (defined(metadata.name) || defined(metadata.desc) || defined(metadata.author) || defined(metadata.copyright) || defined(metadata.link) || defined(metadata.time) || defined(metadata.keywords) || defined(metadata.bounds)) {\n      return metadata;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a personType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_personType|GPX Schema}\nfunction getPerson(node) {\n  const personNode = queryFirstNode(node, \"author\", namespaces.gpx);\n  if (defined(personNode)) {\n    const person = {\n      name: queryStringValue(personNode, \"name\", namespaces.gpx),\n      email: getEmail(personNode),\n      link: getLink(personNode)\n    };\n    if (defined(person.name) || defined(person.email) || defined(person.link)) {\n      return person;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns an email address (from emailType), refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_emailType|GPX Schema}\nfunction getEmail(node) {\n  const emailNode = queryFirstNode(node, \"email\", namespaces.gpx);\n  if (defined(emailNode)) {\n    const id = queryStringValue(emailNode, \"id\", namespaces.gpx);\n    const domain = queryStringValue(emailNode, \"domain\", namespaces.gpx);\n    return `${id}@${domain}`;\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a linkType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_linkType|GPX Schema}\nfunction getLink(node) {\n  const linkNode = queryFirstNode(node, \"link\", namespaces.gpx);\n  if (defined(linkNode)) {\n    const link = {\n      href: queryStringAttribute(linkNode, \"href\"),\n      text: queryStringValue(linkNode, \"text\", namespaces.gpx),\n      mimeType: queryStringValue(linkNode, \"type\", namespaces.gpx)\n    };\n    if (defined(link.href) || defined(link.text) || defined(link.mimeType)) {\n      return link;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a copyrightType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_copyrightType|GPX Schema}\nfunction getCopyright(node) {\n  const copyrightNode = queryFirstNode(node, \"copyright\", namespaces.gpx);\n  if (defined(copyrightNode)) {\n    const copyright = {\n      author: queryStringAttribute(copyrightNode, \"author\"),\n      year: queryStringValue(copyrightNode, \"year\", namespaces.gpx),\n      license: queryStringValue(copyrightNode, \"license\", namespaces.gpx)\n    };\n    if (defined(copyright.author) || defined(copyright.year) || defined(copyright.license)) {\n      return copyright;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a boundsType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_boundsType|GPX Schema}\nfunction getBounds(node) {\n  const boundsNode = queryFirstNode(node, \"bounds\", namespaces.gpx);\n  if (defined(boundsNode)) {\n    const bounds = {\n      minLat: queryNumericValue(boundsNode, \"minlat\", namespaces.gpx),\n      maxLat: queryNumericValue(boundsNode, \"maxlat\", namespaces.gpx),\n      minLon: queryNumericValue(boundsNode, \"minlon\", namespaces.gpx),\n      maxLon: queryNumericValue(boundsNode, \"maxlon\", namespaces.gpx)\n    };\n    if (defined(bounds.minLat) || defined(bounds.maxLat) || defined(bounds.minLon) || defined(bounds.maxLon)) {\n      return bounds;\n    }\n  }\n  return undefined;\n}\nconst complexTypes = {\n  wpt: processWpt,\n  rte: processRte,\n  trk: processTrk\n};\nfunction processGpx(dataSource, node, entityCollection, options) {\n  const complexTypeNames = Object.keys(complexTypes);\n  const complexTypeNamesLength = complexTypeNames.length;\n  for (let i = 0; i < complexTypeNamesLength; i++) {\n    const typeName = complexTypeNames[i];\n    const processComplexTypeNode = complexTypes[typeName];\n    const childNodes = node.childNodes;\n    const length = childNodes.length;\n    for (let q = 0; q < length; q++) {\n      const child = childNodes[q];\n      if (child.localName === typeName && namespaces.gpx.indexOf(child.namespaceURI) !== -1) {\n        processComplexTypeNode(dataSource, child, entityCollection, options);\n      }\n    }\n  }\n}\nfunction loadGpx(dataSource, gpx, options) {\n  const entityCollection = dataSource._entityCollection;\n  entityCollection.removeAll();\n  const element = gpx.documentElement;\n  const version = queryStringAttribute(element, \"version\");\n  const creator = queryStringAttribute(element, \"creator\");\n  let name;\n  const metadata = processMetadata(element);\n  if (defined(metadata)) {\n    name = metadata.name;\n  }\n  if (element.localName === \"gpx\") {\n    processGpx(dataSource, element, entityCollection, options);\n  } else {\n    console.log(`GPX - Unsupported node: ${element.localName}`);\n  }\n  let clock;\n  const availability = entityCollection.computeAvailability();\n  let start = availability.start;\n  let stop = availability.stop;\n  const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n  const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n  if (!isMinStart || !isMaxStop) {\n    let date;\n\n    // If start is min time just start at midnight this morning, local time\n    if (isMinStart) {\n      date = new Date();\n      date.setHours(0, 0, 0, 0);\n      start = JulianDate.fromDate(date);\n    }\n\n    // If stop is max value just stop at midnight tonight, local time\n    if (isMaxStop) {\n      date = new Date();\n      date.setHours(24, 0, 0, 0);\n      stop = JulianDate.fromDate(date);\n    }\n    clock = new DataSourceClock();\n    clock.startTime = start;\n    clock.stopTime = stop;\n    clock.currentTime = JulianDate.clone(start);\n    clock.clockRange = ClockRange.LOOP_STOP;\n    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n    clock.multiplier = Math.round(Math.min(Math.max(JulianDate.secondsDifference(stop, start) / 60, 1), 3.15569e7));\n  }\n  let changed = false;\n  if (dataSource._name !== name) {\n    dataSource._name = name;\n    changed = true;\n  }\n  if (dataSource._creator !== creator) {\n    dataSource._creator = creator;\n    changed = true;\n  }\n  if (metadataChanged(dataSource._metadata, metadata)) {\n    dataSource._metadata = metadata;\n    changed = true;\n  }\n  if (dataSource._version !== version) {\n    dataSource._version = version;\n    changed = true;\n  }\n  if (clock !== dataSource._clock) {\n    changed = true;\n    dataSource._clock = clock;\n  }\n  if (changed) {\n    dataSource._changed.raiseEvent(dataSource);\n  }\n  DataSource.setLoading(dataSource, false);\n  return dataSource;\n}\nfunction metadataChanged(old, current) {\n  if (!defined(old) && !defined(current)) {\n    return false;\n  } else if (defined(old) && defined(current)) {\n    if (old.name !== current.name || old.dec !== current.desc || old.src !== current.src || old.author !== current.author || old.copyright !== current.copyright || old.link !== current.link || old.time !== current.time || old.bounds !== current.bounds) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\nfunction load(dataSource, entityCollection, data, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let promise = data;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchBlob();\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n  return Promise.resolve(promise).then(function (dataToLoad) {\n    if (dataToLoad instanceof Blob) {\n      return readBlobAsText(dataToLoad).then(function (text) {\n        // There's no official way to validate if a parse was successful.\n        // The following check detects the error on various browsers.\n        // IE raises an exception\n        let gpx;\n        let error;\n        try {\n          gpx = parser.parseFromString(text, \"application/xml\");\n        } catch (e) {\n          error = e.toString();\n        }\n\n        // The parse succeeds on Chrome and Firefox, but the error\n        // handling is different in each.\n        if (defined(error) || gpx.body || gpx.documentElement.tagName === \"parsererror\") {\n          // Firefox has error information as the firstChild nodeValue.\n          let msg = defined(error) ? error : gpx.documentElement.firstChild.nodeValue;\n\n          // Chrome has it in the body text.\n          if (!msg) {\n            msg = gpx.body.innerText;\n          }\n\n          // Return the error\n          throw new RuntimeError(msg);\n        }\n        return loadGpx(dataSource, gpx, options);\n      });\n    }\n    return loadGpx(dataSource, dataToLoad, options);\n  }).catch(function (error) {\n    dataSource._error.raiseEvent(dataSource, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n}\n\n/**\n * A {@link DataSource} which processes the GPS Exchange Format (GPX).\n *\n * @alias GpxDataSource\n * @constructor\n *\n * @see {@link http://www.topografix.com/gpx.asp|Topografix GPX Standard}\n * @see {@link http://www.topografix.com/gpx/1/1/|Topografix GPX Documentation}\n *\n * @demo {@link http://sandcastle.cesium.com/index.html?src=GPX.html}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GpxDataSource.load('../../SampleData/track.gpx'));\n */\nfunction GpxDataSource() {\n  this._changed = new Event();\n  this._error = new Event();\n  this._loading = new Event();\n  this._clock = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._entityCluster = new EntityCluster();\n  this._name = undefined;\n  this._version = undefined;\n  this._creator = undefined;\n  this._metadata = undefined;\n  this._isLoading = false;\n  this._pinBuilder = new PinBuilder();\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided GPX data.\n *\n * @param {string|Document|Blob} data A url, parsed GPX document, or Blob containing binary GPX data.\n * @param {object} [options] An object with the following properties:\n * @param {boolean} [options.clampToGround] True if the symbols should be rendered at the same height as the terrain\n * @param {string} [options.waypointImage] Image to use for waypoint billboards.\n * @param {string} [options.trackImage] Image to use for track billboards.\n * @param {string} [options.trackColor] Color to use for track lines.\n * @param {string} [options.routeColor] Color to use for route lines.\n * @returns {Promise<GpxDataSource>} A promise that will resolve to a new GpxDataSource instance once the gpx is loaded.\n */\nGpxDataSource.load = function (data, options) {\n  return new GpxDataSource().load(data, options);\n};\nObject.defineProperties(GpxDataSource.prototype, {\n  /**\n   * Gets a human-readable name for this instance.\n   * This will be automatically be set to the GPX document name on load.\n   * @memberof GpxDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * Gets the version of the GPX Schema in use.\n   * @memberof GpxDataSource.prototype\n   * @type {string}\n   */\n  version: {\n    get: function () {\n      return this._version;\n    }\n  },\n  /**\n   * Gets the creator of the GPX document.\n   * @memberof GpxDataSource.prototype\n   * @type {string}\n   */\n  creator: {\n    get: function () {\n      return this._creator;\n    }\n  },\n  /**\n   * Gets an object containing metadata about the GPX file.\n   * @memberof GpxDataSource.prototype\n   * @type {object}\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    }\n  },\n  /**\n   * Gets the clock settings defined by the loaded GPX. This represents the total\n   * availability interval for all time-dynamic data. If the GPX does not contain\n   * time-dynamic data, this value is undefined.\n   * @memberof GpxDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    }\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof GpxDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    }\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof GpxDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof GpxDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    }\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof GpxDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof GpxDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    }\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof GpxDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    }\n  },\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof GpxDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    }\n  }\n});\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nGpxDataSource.prototype.update = function (time) {\n  return true;\n};\n\n/**\n * Asynchronously loads the provided GPX data, replacing any existing data.\n *\n * @param {string|Document|Blob} data A url, parsed GPX document, or Blob containing binary GPX data or a parsed GPX document.\n * @param {object} [options] An object with the following properties:\n * @param {boolean} [options.clampToGround] True if the symbols should be rendered at the same height as the terrain\n * @param {string} [options.waypointImage] Image to use for waypoint billboards.\n * @param {string} [options.trackImage] Image to use for track billboards.\n * @param {string} [options.trackColor] Color to use for track lines.\n * @param {string} [options.routeColor] Color to use for route lines.\n * @returns {Promise<GpxDataSource>} A promise that will resolve to this instances once the GPX is loaded.\n */\nGpxDataSource.prototype.load = function (data, options) {\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  DataSource.setLoading(this, true);\n  const oldName = this._name;\n  const that = this;\n  return load(this, this._entityCollection, data, options).then(function () {\n    let clock;\n    const availability = that._entityCollection.computeAvailability();\n    let start = availability.start;\n    let stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      let date;\n\n      // If start is min time just start at midnight this morning, local time\n      if (isMinStart) {\n        date = new Date();\n        date.setHours(0, 0, 0, 0);\n        start = JulianDate.fromDate(date);\n      }\n\n      // If stop is max value just stop at midnight tonight, local time\n      if (isMaxStop) {\n        date = new Date();\n        date.setHours(24, 0, 0, 0);\n        stop = JulianDate.fromDate(date);\n      }\n      clock = new DataSourceClock();\n      clock.startTime = start;\n      clock.stopTime = stop;\n      clock.currentTime = JulianDate.clone(start);\n      clock.clockRange = ClockRange.LOOP_STOP;\n      clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n      clock.multiplier = Math.round(Math.min(Math.max(JulianDate.secondsDifference(stop, start) / 60, 1), 3.15569e7));\n    }\n    let changed = false;\n    if (clock !== that._clock) {\n      that._clock = clock;\n      changed = true;\n    }\n    if (oldName !== that._name) {\n      changed = true;\n    }\n    if (changed) {\n      that._changed.raiseEvent(that);\n    }\n    DataSource.setLoading(that, false);\n    return that;\n  }).catch(function (error) {\n    DataSource.setLoading(that, false);\n    that._error.raiseEvent(that, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n};\nexport default GpxDataSource;","map":{"version":3,"names":["Cartesian2","Cartesian3","ClockRange","ClockStep","Color","createGuid","defaultValue","defined","DeveloperError","Event","Iso8601","JulianDate","NearFarScalar","PinBuilder","Resource","RuntimeError","TimeInterval","TimeIntervalCollection","HeightReference","HorizontalOrigin","LabelStyle","VerticalOrigin","Autolinker","BillboardGraphics","ConstantProperty","DataSource","DataSourceClock","EntityCluster","EntityCollection","LabelGraphics","PolylineGraphics","PolylineOutlineMaterialProperty","SampledPositionProperty","parser","DOMParser","autolinker","stripPrefix","email","replaceFn","linker","match","urlMatchType","BILLBOARD_SIZE","BILLBOARD_NEAR_DISTANCE","BILLBOARD_NEAR_RATIO","BILLBOARD_FAR_DISTANCE","BILLBOARD_FAR_RATIO","gpxNamespaces","undefined","namespaces","gpx","readBlobAsText","blob","Promise","resolve","reject","reader","FileReader","addEventListener","result","error","readAsText","getOrCreateEntity","node","entityCollection","id","queryStringAttribute","entity","readCoordinateFromNode","longitude","queryNumericAttribute","latitude","elevation","queryNumericValue","fromDegrees","attributeName","value","getAttribute","parseFloat","isNaN","queryFirstNode","tagName","namespace","childNodes","length","q","child","localName","indexOf","namespaceURI","queryNodes","getElementsByTagName","push","resultNode","textContent","queryStringValue","trim","createDefaultBillboard","image","billboard","width","height","scaleByDistance","pixelOffsetScaleByDistance","verticalOrigin","BOTTOM","createDefaultLabel","label","translucencyByDistance","pixelOffset","horizontalOrigin","LEFT","font","style","FILL_AND_OUTLINE","createDefaultPolyline","color","polyline","material","RED","outlineWidth","outlineColor","BLACK","descriptiveInfoTypes","time","text","tag","comment","description","source","number","type","scratchDiv","document","createElement","processDescription","i","infoTypeNames","Object","keys","infoTypeName","infoType","link","innerHTML","links","querySelectorAll","setAttribute","background","WHITE","foreground","tmp","toCssColorString","processWpt","dataSource","geometryNode","options","position","waypointImage","_pinBuilder","fromMakiIconId","name","clampToGround","heightReference","CLAMP_TO_GROUND","processRte","routePoints","coordinateTuples","Array","routeColor","positions","processTrk","trackSegs","times","trackSegInfo","isTimeDynamic","property","processTrkSeg","concat","addSamples","availability","addInterval","start","stop","trackColor","trackPoints","fromIso8601","processMetadata","metadataNode","metadata","desc","author","getPerson","copyright","getCopyright","getLink","keywords","bounds","getBounds","personNode","person","getEmail","emailNode","domain","linkNode","href","mimeType","copyrightNode","year","license","boundsNode","minLat","maxLat","minLon","maxLon","complexTypes","wpt","rte","trk","processGpx","complexTypeNames","complexTypeNamesLength","typeName","processComplexTypeNode","loadGpx","_entityCollection","removeAll","element","documentElement","version","creator","console","log","clock","computeAvailability","isMinStart","equals","MINIMUM_VALUE","isMaxStop","MAXIMUM_VALUE","date","Date","setHours","fromDate","startTime","stopTime","currentTime","clone","clockRange","LOOP_STOP","clockStep","SYSTEM_CLOCK_MULTIPLIER","multiplier","Math","round","min","max","secondsDifference","changed","_name","_creator","metadataChanged","_metadata","_version","_clock","_changed","raiseEvent","setLoading","old","current","dec","src","load","data","EMPTY_OBJECT","promise","createIfNeeded","fetchBlob","resourceCredits","_resourceCredits","credits","then","dataToLoad","Blob","parseFromString","e","toString","body","msg","firstChild","nodeValue","innerText","catch","_error","GpxDataSource","_loading","_entityCluster","_isLoading","defineProperties","prototype","get","entities","isLoading","changedEvent","errorEvent","loadingEvent","show","set","clustering","update","oldName","that"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/GpxDataSource.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport Autolinker from \"autolinker\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PolylineOutlineMaterialProperty from \"./PolylineOutlineMaterialProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\n\nlet parser;\nif (typeof DOMParser !== \"undefined\") {\n  parser = new DOMParser();\n}\n\nconst autolinker = new Autolinker({\n  stripPrefix: false,\n  email: false,\n  replaceFn: function (linker, match) {\n    //Prevent matching of non-explicit urls.\n    //i.e. foo.id won't match but http://foo.id will\n    return match.urlMatchType === \"scheme\" || match.urlMatchType === \"www\";\n  },\n});\n\nconst BILLBOARD_SIZE = 32;\nconst BILLBOARD_NEAR_DISTANCE = 2414016;\nconst BILLBOARD_NEAR_RATIO = 1.0;\nconst BILLBOARD_FAR_DISTANCE = 1.6093e7;\nconst BILLBOARD_FAR_RATIO = 0.1;\n\nconst gpxNamespaces = [null, undefined, \"http://www.topografix.com/GPX/1/1\"];\nconst namespaces = {\n  gpx: gpxNamespaces,\n};\n\nfunction readBlobAsText(blob) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", function () {\n      resolve(reader.result);\n    });\n    reader.addEventListener(\"error\", function () {\n      reject(reader.error);\n    });\n    reader.readAsText(blob);\n  });\n}\n\nfunction getOrCreateEntity(node, entityCollection) {\n  let id = queryStringAttribute(node, \"id\");\n  id = defined(id) ? id : createGuid();\n  const entity = entityCollection.getOrCreateEntity(id);\n  return entity;\n}\n\nfunction readCoordinateFromNode(node) {\n  const longitude = queryNumericAttribute(node, \"lon\");\n  const latitude = queryNumericAttribute(node, \"lat\");\n  const elevation = queryNumericValue(node, \"ele\", namespaces.gpx);\n  return Cartesian3.fromDegrees(longitude, latitude, elevation);\n}\n\nfunction queryNumericAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  const value = node.getAttribute(attributeName);\n  if (value !== null) {\n    const result = parseFloat(value);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\n\nfunction queryStringAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  return value !== null ? value : undefined;\n}\n\nfunction queryFirstNode(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      return child;\n    }\n  }\n  return undefined;\n}\n\nfunction queryNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const result = [];\n  const childNodes = node.getElementsByTagName(tagName);\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\nfunction queryNumericValue(node, tagName, namespace) {\n  const resultNode = queryFirstNode(node, tagName, namespace);\n  if (defined(resultNode)) {\n    const result = parseFloat(resultNode.textContent);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\n\nfunction queryStringValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    return result.textContent.trim();\n  }\n  return undefined;\n}\n\nfunction createDefaultBillboard(image) {\n  const billboard = new BillboardGraphics();\n  billboard.width = BILLBOARD_SIZE;\n  billboard.height = BILLBOARD_SIZE;\n  billboard.scaleByDistance = new NearFarScalar(\n    BILLBOARD_NEAR_DISTANCE,\n    BILLBOARD_NEAR_RATIO,\n    BILLBOARD_FAR_DISTANCE,\n    BILLBOARD_FAR_RATIO,\n  );\n  billboard.pixelOffsetScaleByDistance = new NearFarScalar(\n    BILLBOARD_NEAR_DISTANCE,\n    BILLBOARD_NEAR_RATIO,\n    BILLBOARD_FAR_DISTANCE,\n    BILLBOARD_FAR_RATIO,\n  );\n  billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);\n  billboard.image = image;\n  return billboard;\n}\n\nfunction createDefaultLabel() {\n  const label = new LabelGraphics();\n  label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n  label.pixelOffset = new Cartesian2(17, 0);\n  label.horizontalOrigin = HorizontalOrigin.LEFT;\n  label.font = \"16px sans-serif\";\n  label.style = LabelStyle.FILL_AND_OUTLINE;\n  return label;\n}\n\nfunction createDefaultPolyline(color) {\n  const polyline = new PolylineGraphics();\n  polyline.width = 4;\n  polyline.material = new PolylineOutlineMaterialProperty();\n  polyline.material.color = defined(color) ? color : Color.RED;\n  polyline.material.outlineWidth = 2;\n  polyline.material.outlineColor = Color.BLACK;\n  return polyline;\n}\n\n// This is a list of the Optional Description Information:\n//  <cmt> GPS comment of the waypoint\n//  <desc> Descriptive description of the waypoint\n//  <src> Source of the waypoint data\n//  <type> Type (category) of waypoint\nconst descriptiveInfoTypes = {\n  time: {\n    text: \"Time\",\n    tag: \"time\",\n  },\n  comment: {\n    text: \"Comment\",\n    tag: \"cmt\",\n  },\n  description: {\n    text: \"Description\",\n    tag: \"desc\",\n  },\n  source: {\n    text: \"Source\",\n    tag: \"src\",\n  },\n  number: {\n    text: \"GPS track/route number\",\n    tag: \"number\",\n  },\n  type: {\n    text: \"Type\",\n    tag: \"type\",\n  },\n};\n\nlet scratchDiv;\nif (typeof document !== \"undefined\") {\n  scratchDiv = document.createElement(\"div\");\n}\nfunction processDescription(node, entity) {\n  let i;\n\n  let text = \"\";\n  const infoTypeNames = Object.keys(descriptiveInfoTypes);\n  const length = infoTypeNames.length;\n  for (i = 0; i < length; i++) {\n    const infoTypeName = infoTypeNames[i];\n    const infoType = descriptiveInfoTypes[infoTypeName];\n    infoType.value = defaultValue(\n      queryStringValue(node, infoType.tag, namespaces.gpx),\n      \"\",\n    );\n    if (defined(infoType.value) && infoType.value !== \"\") {\n      text = `${text}<p>${infoType.text}: ${infoType.value}</p>`;\n    }\n  }\n\n  if (!defined(text) || text === \"\") {\n    // No description\n    return;\n  }\n\n  // Turns non-explicit links into clickable links.\n  text = autolinker.link(text);\n\n  // Use a temporary div to manipulate the links\n  // so that they open in a new window.\n  scratchDiv.innerHTML = text;\n  const links = scratchDiv.querySelectorAll(\"a\");\n\n  for (i = 0; i < links.length; i++) {\n    links[i].setAttribute(\"target\", \"_blank\");\n  }\n\n  const background = Color.WHITE;\n  const foreground = Color.BLACK;\n  let tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n  tmp += \"overflow:auto;\";\n  tmp += \"word-wrap:break-word;\";\n  tmp += `background-color:${background.toCssColorString()};`;\n  tmp += `color:${foreground.toCssColorString()};`;\n  tmp += '\">';\n  tmp += `${scratchDiv.innerHTML}</div>`;\n  scratchDiv.innerHTML = \"\";\n\n  // return the final HTML as the description.\n  return tmp;\n}\n\nfunction processWpt(dataSource, geometryNode, entityCollection, options) {\n  const position = readCoordinateFromNode(geometryNode);\n\n  const entity = getOrCreateEntity(geometryNode, entityCollection);\n  entity.position = position;\n\n  // Get billboard image\n  const image = defined(options.waypointImage)\n    ? options.waypointImage\n    : dataSource._pinBuilder.fromMakiIconId(\n        \"marker\",\n        Color.RED,\n        BILLBOARD_SIZE,\n      );\n  entity.billboard = createDefaultBillboard(image);\n\n  const name = queryStringValue(geometryNode, \"name\", namespaces.gpx);\n  entity.name = name;\n  entity.label = createDefaultLabel();\n  entity.label.text = name;\n  entity.description = processDescription(geometryNode, entity);\n\n  if (options.clampToGround) {\n    entity.billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n    entity.label.heightReference = HeightReference.CLAMP_TO_GROUND;\n  }\n}\n\n// rte represents route - an ordered list of waypoints representing a series of turn points leading to a destination\nfunction processRte(dataSource, geometryNode, entityCollection, options) {\n  const entity = getOrCreateEntity(geometryNode, entityCollection);\n  entity.description = processDescription(geometryNode, entity);\n\n  // a list of waypoint\n  const routePoints = queryNodes(geometryNode, \"rtept\", namespaces.gpx);\n  const coordinateTuples = new Array(routePoints.length);\n  for (let i = 0; i < routePoints.length; i++) {\n    processWpt(dataSource, routePoints[i], entityCollection, options);\n    coordinateTuples[i] = readCoordinateFromNode(routePoints[i]);\n  }\n  entity.polyline = createDefaultPolyline(options.routeColor);\n  if (options.clampToGround) {\n    entity.polyline.clampToGround = true;\n  }\n  entity.polyline.positions = coordinateTuples;\n}\n\n// trk represents a track - an ordered list of points describing a path.\nfunction processTrk(dataSource, geometryNode, entityCollection, options) {\n  const entity = getOrCreateEntity(geometryNode, entityCollection);\n  entity.description = processDescription(geometryNode, entity);\n\n  const trackSegs = queryNodes(geometryNode, \"trkseg\", namespaces.gpx);\n  let positions = [];\n  let times = [];\n  let trackSegInfo;\n  let isTimeDynamic = true;\n  const property = new SampledPositionProperty();\n  for (let i = 0; i < trackSegs.length; i++) {\n    trackSegInfo = processTrkSeg(trackSegs[i]);\n    positions = positions.concat(trackSegInfo.positions);\n    if (trackSegInfo.times.length > 0) {\n      times = times.concat(trackSegInfo.times);\n      property.addSamples(times, positions);\n      // if one track segment is non dynamic the whole track must also be\n      isTimeDynamic = isTimeDynamic && true;\n    } else {\n      isTimeDynamic = false;\n    }\n  }\n  if (isTimeDynamic) {\n    // Assign billboard image\n    const image = defined(options.waypointImage)\n      ? options.waypointImage\n      : dataSource._pinBuilder.fromMakiIconId(\n          \"marker\",\n          Color.RED,\n          BILLBOARD_SIZE,\n        );\n    entity.billboard = createDefaultBillboard(image);\n    entity.position = property;\n    if (options.clampToGround) {\n      entity.billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n    }\n    entity.availability = new TimeIntervalCollection();\n    entity.availability.addInterval(\n      new TimeInterval({\n        start: times[0],\n        stop: times[times.length - 1],\n      }),\n    );\n  }\n  entity.polyline = createDefaultPolyline(options.trackColor);\n  entity.polyline.positions = positions;\n  if (options.clampToGround) {\n    entity.polyline.clampToGround = true;\n  }\n}\n\nfunction processTrkSeg(node) {\n  const result = {\n    positions: [],\n    times: [],\n  };\n  const trackPoints = queryNodes(node, \"trkpt\", namespaces.gpx);\n  let time;\n  for (let i = 0; i < trackPoints.length; i++) {\n    const position = readCoordinateFromNode(trackPoints[i]);\n    result.positions.push(position);\n\n    time = queryStringValue(trackPoints[i], \"time\", namespaces.gpx);\n    if (defined(time)) {\n      result.times.push(JulianDate.fromIso8601(time));\n    }\n  }\n  return result;\n}\n\n// Processes a metadataType node and returns a metadata object\n// {@link http://www.topografix.com/gpx/1/1/#type_metadataType|GPX Schema}\nfunction processMetadata(node) {\n  const metadataNode = queryFirstNode(node, \"metadata\", namespaces.gpx);\n  if (defined(metadataNode)) {\n    const metadata = {\n      name: queryStringValue(metadataNode, \"name\", namespaces.gpx),\n      desc: queryStringValue(metadataNode, \"desc\", namespaces.gpx),\n      author: getPerson(metadataNode),\n      copyright: getCopyright(metadataNode),\n      link: getLink(metadataNode),\n      time: queryStringValue(metadataNode, \"time\", namespaces.gpx),\n      keywords: queryStringValue(metadataNode, \"keywords\", namespaces.gpx),\n      bounds: getBounds(metadataNode),\n    };\n    if (\n      defined(metadata.name) ||\n      defined(metadata.desc) ||\n      defined(metadata.author) ||\n      defined(metadata.copyright) ||\n      defined(metadata.link) ||\n      defined(metadata.time) ||\n      defined(metadata.keywords) ||\n      defined(metadata.bounds)\n    ) {\n      return metadata;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a personType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_personType|GPX Schema}\nfunction getPerson(node) {\n  const personNode = queryFirstNode(node, \"author\", namespaces.gpx);\n  if (defined(personNode)) {\n    const person = {\n      name: queryStringValue(personNode, \"name\", namespaces.gpx),\n      email: getEmail(personNode),\n      link: getLink(personNode),\n    };\n    if (defined(person.name) || defined(person.email) || defined(person.link)) {\n      return person;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns an email address (from emailType), refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_emailType|GPX Schema}\nfunction getEmail(node) {\n  const emailNode = queryFirstNode(node, \"email\", namespaces.gpx);\n  if (defined(emailNode)) {\n    const id = queryStringValue(emailNode, \"id\", namespaces.gpx);\n    const domain = queryStringValue(emailNode, \"domain\", namespaces.gpx);\n    return `${id}@${domain}`;\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a linkType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_linkType|GPX Schema}\nfunction getLink(node) {\n  const linkNode = queryFirstNode(node, \"link\", namespaces.gpx);\n  if (defined(linkNode)) {\n    const link = {\n      href: queryStringAttribute(linkNode, \"href\"),\n      text: queryStringValue(linkNode, \"text\", namespaces.gpx),\n      mimeType: queryStringValue(linkNode, \"type\", namespaces.gpx),\n    };\n    if (defined(link.href) || defined(link.text) || defined(link.mimeType)) {\n      return link;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a copyrightType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_copyrightType|GPX Schema}\nfunction getCopyright(node) {\n  const copyrightNode = queryFirstNode(node, \"copyright\", namespaces.gpx);\n  if (defined(copyrightNode)) {\n    const copyright = {\n      author: queryStringAttribute(copyrightNode, \"author\"),\n      year: queryStringValue(copyrightNode, \"year\", namespaces.gpx),\n      license: queryStringValue(copyrightNode, \"license\", namespaces.gpx),\n    };\n    if (\n      defined(copyright.author) ||\n      defined(copyright.year) ||\n      defined(copyright.license)\n    ) {\n      return copyright;\n    }\n  }\n  return undefined;\n}\n\n// Receives a XML node and returns a boundsType object, refer to\n// {@link http://www.topografix.com/gpx/1/1/#type_boundsType|GPX Schema}\nfunction getBounds(node) {\n  const boundsNode = queryFirstNode(node, \"bounds\", namespaces.gpx);\n  if (defined(boundsNode)) {\n    const bounds = {\n      minLat: queryNumericValue(boundsNode, \"minlat\", namespaces.gpx),\n      maxLat: queryNumericValue(boundsNode, \"maxlat\", namespaces.gpx),\n      minLon: queryNumericValue(boundsNode, \"minlon\", namespaces.gpx),\n      maxLon: queryNumericValue(boundsNode, \"maxlon\", namespaces.gpx),\n    };\n    if (\n      defined(bounds.minLat) ||\n      defined(bounds.maxLat) ||\n      defined(bounds.minLon) ||\n      defined(bounds.maxLon)\n    ) {\n      return bounds;\n    }\n  }\n  return undefined;\n}\n\nconst complexTypes = {\n  wpt: processWpt,\n  rte: processRte,\n  trk: processTrk,\n};\n\nfunction processGpx(dataSource, node, entityCollection, options) {\n  const complexTypeNames = Object.keys(complexTypes);\n  const complexTypeNamesLength = complexTypeNames.length;\n\n  for (let i = 0; i < complexTypeNamesLength; i++) {\n    const typeName = complexTypeNames[i];\n    const processComplexTypeNode = complexTypes[typeName];\n\n    const childNodes = node.childNodes;\n    const length = childNodes.length;\n    for (let q = 0; q < length; q++) {\n      const child = childNodes[q];\n      if (\n        child.localName === typeName &&\n        namespaces.gpx.indexOf(child.namespaceURI) !== -1\n      ) {\n        processComplexTypeNode(dataSource, child, entityCollection, options);\n      }\n    }\n  }\n}\n\nfunction loadGpx(dataSource, gpx, options) {\n  const entityCollection = dataSource._entityCollection;\n\n  entityCollection.removeAll();\n\n  const element = gpx.documentElement;\n  const version = queryStringAttribute(element, \"version\");\n  const creator = queryStringAttribute(element, \"creator\");\n\n  let name;\n  const metadata = processMetadata(element);\n  if (defined(metadata)) {\n    name = metadata.name;\n  }\n\n  if (element.localName === \"gpx\") {\n    processGpx(dataSource, element, entityCollection, options);\n  } else {\n    console.log(`GPX - Unsupported node: ${element.localName}`);\n  }\n\n  let clock;\n  const availability = entityCollection.computeAvailability();\n\n  let start = availability.start;\n  let stop = availability.stop;\n  const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n  const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n  if (!isMinStart || !isMaxStop) {\n    let date;\n\n    // If start is min time just start at midnight this morning, local time\n    if (isMinStart) {\n      date = new Date();\n      date.setHours(0, 0, 0, 0);\n      start = JulianDate.fromDate(date);\n    }\n\n    // If stop is max value just stop at midnight tonight, local time\n    if (isMaxStop) {\n      date = new Date();\n      date.setHours(24, 0, 0, 0);\n      stop = JulianDate.fromDate(date);\n    }\n\n    clock = new DataSourceClock();\n    clock.startTime = start;\n    clock.stopTime = stop;\n    clock.currentTime = JulianDate.clone(start);\n    clock.clockRange = ClockRange.LOOP_STOP;\n    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n    clock.multiplier = Math.round(\n      Math.min(\n        Math.max(JulianDate.secondsDifference(stop, start) / 60, 1),\n        3.15569e7,\n      ),\n    );\n  }\n  let changed = false;\n  if (dataSource._name !== name) {\n    dataSource._name = name;\n    changed = true;\n  }\n\n  if (dataSource._creator !== creator) {\n    dataSource._creator = creator;\n    changed = true;\n  }\n\n  if (metadataChanged(dataSource._metadata, metadata)) {\n    dataSource._metadata = metadata;\n    changed = true;\n  }\n\n  if (dataSource._version !== version) {\n    dataSource._version = version;\n    changed = true;\n  }\n\n  if (clock !== dataSource._clock) {\n    changed = true;\n    dataSource._clock = clock;\n  }\n\n  if (changed) {\n    dataSource._changed.raiseEvent(dataSource);\n  }\n\n  DataSource.setLoading(dataSource, false);\n  return dataSource;\n}\n\nfunction metadataChanged(old, current) {\n  if (!defined(old) && !defined(current)) {\n    return false;\n  } else if (defined(old) && defined(current)) {\n    if (\n      old.name !== current.name ||\n      old.dec !== current.desc ||\n      old.src !== current.src ||\n      old.author !== current.author ||\n      old.copyright !== current.copyright ||\n      old.link !== current.link ||\n      old.time !== current.time ||\n      old.bounds !== current.bounds\n    ) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\n\nfunction load(dataSource, entityCollection, data, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let promise = data;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchBlob();\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n\n  return Promise.resolve(promise)\n    .then(function (dataToLoad) {\n      if (dataToLoad instanceof Blob) {\n        return readBlobAsText(dataToLoad).then(function (text) {\n          // There's no official way to validate if a parse was successful.\n          // The following check detects the error on various browsers.\n          // IE raises an exception\n          let gpx;\n          let error;\n          try {\n            gpx = parser.parseFromString(text, \"application/xml\");\n          } catch (e) {\n            error = e.toString();\n          }\n\n          // The parse succeeds on Chrome and Firefox, but the error\n          // handling is different in each.\n          if (\n            defined(error) ||\n            gpx.body ||\n            gpx.documentElement.tagName === \"parsererror\"\n          ) {\n            // Firefox has error information as the firstChild nodeValue.\n            let msg = defined(error)\n              ? error\n              : gpx.documentElement.firstChild.nodeValue;\n\n            // Chrome has it in the body text.\n            if (!msg) {\n              msg = gpx.body.innerText;\n            }\n\n            // Return the error\n            throw new RuntimeError(msg);\n          }\n          return loadGpx(dataSource, gpx, options);\n        });\n      }\n      return loadGpx(dataSource, dataToLoad, options);\n    })\n    .catch(function (error) {\n      dataSource._error.raiseEvent(dataSource, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n}\n\n/**\n * A {@link DataSource} which processes the GPS Exchange Format (GPX).\n *\n * @alias GpxDataSource\n * @constructor\n *\n * @see {@link http://www.topografix.com/gpx.asp|Topografix GPX Standard}\n * @see {@link http://www.topografix.com/gpx/1/1/|Topografix GPX Documentation}\n *\n * @demo {@link http://sandcastle.cesium.com/index.html?src=GPX.html}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GpxDataSource.load('../../SampleData/track.gpx'));\n */\nfunction GpxDataSource() {\n  this._changed = new Event();\n  this._error = new Event();\n  this._loading = new Event();\n  this._clock = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._entityCluster = new EntityCluster();\n  this._name = undefined;\n  this._version = undefined;\n  this._creator = undefined;\n  this._metadata = undefined;\n  this._isLoading = false;\n  this._pinBuilder = new PinBuilder();\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided GPX data.\n *\n * @param {string|Document|Blob} data A url, parsed GPX document, or Blob containing binary GPX data.\n * @param {object} [options] An object with the following properties:\n * @param {boolean} [options.clampToGround] True if the symbols should be rendered at the same height as the terrain\n * @param {string} [options.waypointImage] Image to use for waypoint billboards.\n * @param {string} [options.trackImage] Image to use for track billboards.\n * @param {string} [options.trackColor] Color to use for track lines.\n * @param {string} [options.routeColor] Color to use for route lines.\n * @returns {Promise<GpxDataSource>} A promise that will resolve to a new GpxDataSource instance once the gpx is loaded.\n */\nGpxDataSource.load = function (data, options) {\n  return new GpxDataSource().load(data, options);\n};\n\nObject.defineProperties(GpxDataSource.prototype, {\n  /**\n   * Gets a human-readable name for this instance.\n   * This will be automatically be set to the GPX document name on load.\n   * @memberof GpxDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * Gets the version of the GPX Schema in use.\n   * @memberof GpxDataSource.prototype\n   * @type {string}\n   */\n  version: {\n    get: function () {\n      return this._version;\n    },\n  },\n  /**\n   * Gets the creator of the GPX document.\n   * @memberof GpxDataSource.prototype\n   * @type {string}\n   */\n  creator: {\n    get: function () {\n      return this._creator;\n    },\n  },\n  /**\n   * Gets an object containing metadata about the GPX file.\n   * @memberof GpxDataSource.prototype\n   * @type {object}\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n  },\n  /**\n   * Gets the clock settings defined by the loaded GPX. This represents the total\n   * availability interval for all time-dynamic data. If the GPX does not contain\n   * time-dynamic data, this value is undefined.\n   * @memberof GpxDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof GpxDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof GpxDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof GpxDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof GpxDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof GpxDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof GpxDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof GpxDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n});\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nGpxDataSource.prototype.update = function (time) {\n  return true;\n};\n\n/**\n * Asynchronously loads the provided GPX data, replacing any existing data.\n *\n * @param {string|Document|Blob} data A url, parsed GPX document, or Blob containing binary GPX data or a parsed GPX document.\n * @param {object} [options] An object with the following properties:\n * @param {boolean} [options.clampToGround] True if the symbols should be rendered at the same height as the terrain\n * @param {string} [options.waypointImage] Image to use for waypoint billboards.\n * @param {string} [options.trackImage] Image to use for track billboards.\n * @param {string} [options.trackColor] Color to use for track lines.\n * @param {string} [options.routeColor] Color to use for route lines.\n * @returns {Promise<GpxDataSource>} A promise that will resolve to this instances once the GPX is loaded.\n */\nGpxDataSource.prototype.load = function (data, options) {\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  DataSource.setLoading(this, true);\n  const oldName = this._name;\n  const that = this;\n  return load(this, this._entityCollection, data, options)\n    .then(function () {\n      let clock;\n\n      const availability = that._entityCollection.computeAvailability();\n\n      let start = availability.start;\n      let stop = availability.stop;\n      const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n      const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n      if (!isMinStart || !isMaxStop) {\n        let date;\n\n        // If start is min time just start at midnight this morning, local time\n        if (isMinStart) {\n          date = new Date();\n          date.setHours(0, 0, 0, 0);\n          start = JulianDate.fromDate(date);\n        }\n\n        // If stop is max value just stop at midnight tonight, local time\n        if (isMaxStop) {\n          date = new Date();\n          date.setHours(24, 0, 0, 0);\n          stop = JulianDate.fromDate(date);\n        }\n\n        clock = new DataSourceClock();\n        clock.startTime = start;\n        clock.stopTime = stop;\n        clock.currentTime = JulianDate.clone(start);\n        clock.clockRange = ClockRange.LOOP_STOP;\n        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n        clock.multiplier = Math.round(\n          Math.min(\n            Math.max(JulianDate.secondsDifference(stop, start) / 60, 1),\n            3.15569e7,\n          ),\n        );\n      }\n\n      let changed = false;\n      if (clock !== that._clock) {\n        that._clock = clock;\n        changed = true;\n      }\n\n      if (oldName !== that._name) {\n        changed = true;\n      }\n\n      if (changed) {\n        that._changed.raiseEvent(that);\n      }\n\n      DataSource.setLoading(that, false);\n\n      return that;\n    })\n    .catch(function (error) {\n      DataSource.setLoading(that, false);\n      that._error.raiseEvent(that, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n};\n\nexport default GpxDataSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}