{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\nconst EllipseGeometryLibrary = {};\nconst rotAxis = new Cartesian3();\nconst tempVec = new Cartesian3();\nconst unitQuat = new Quaternion();\nconst rotMtx = new Matrix3();\nfunction pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\n  const azimuth = theta + rotation;\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n  let cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n  let sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n  const radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  const angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (positions, options, extrude) {\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const size = extrude ? positions.length / 3 * 2 : positions.length / 3;\n  const finalPositions = new Float64Array(size * 3);\n  const length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n    const extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    const scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\n    Cartesian3.add(position, scaledNormal, position);\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n  return finalPositions;\n};\nconst unitPosScratch = new Cartesian3();\nconst eastVecScratch = new Cartesian3();\nconst northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (options, addFillPositions, addEdgePositions) {\n  const semiMinorAxis = options.semiMinorAxis;\n  const semiMajorAxis = options.semiMajorAxis;\n  const rotation = options.rotation;\n  const center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  const granularity = options.granularity * 8.0;\n  const aSqr = semiMinorAxis * semiMinorAxis;\n  const bSqr = semiMajorAxis * semiMajorAxis;\n  const ab = semiMajorAxis * semiMinorAxis;\n  const mag = Cartesian3.magnitude(center);\n  const unitPos = Cartesian3.normalize(center, unitPosScratch);\n  let eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  const northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  let numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n  const deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  let theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  const size = 2 * (numPts * (numPts + 2));\n  const positions = addFillPositions ? new Array(size * 3) : undefined;\n  let positionIndex = 0;\n  let position = scratchCartesian1;\n  let reflectedPosition = scratchCartesian2;\n  const outerPositionsLength = numPts * 4 * 3;\n  let outerRightIndex = outerPositionsLength - 1;\n  let outerLeftIndex = 0;\n  const outerPositions = addEdgePositions ? new Array(outerPositionsLength) : undefined;\n  let i;\n  let j;\n  let numInterior;\n  let t;\n  let interiorPosition;\n\n  // Compute points in the 'eastern' half of the ellipse\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n    reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the 'western' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n    position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n    reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n  const r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n  return r;\n};\nexport default EllipseGeometryLibrary;","map":{"version":3,"names":["Cartesian3","CesiumMath","Matrix3","Quaternion","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","result","azimuth","multiplyByScalar","Math","cos","sin","add","cosThetaSquared","sinThetaSquared","radius","sqrt","angle","fromAxisAngle","fromQuaternion","multiplyByVector","normalize","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchNormal","raisePositionsToHeight","positions","options","extrude","ellipsoid","height","extrudedHeight","size","length","finalPositions","Float64Array","bottomOffset","i","i1","i2","position","fromArray","scaleToGeodeticSurface","extrudedPosition","clone","normal","geodeticSurfaceNormal","scaledNormal","x","y","z","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","center","granularity","magnitude","cross","UNIT_Z","numPts","ceil","PI_OVER_TWO","deltaTheta","abs","Array","undefined","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","j","numInterior","t","interiorPosition","PI","lerp","r"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EllipseGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst EllipseGeometryLibrary = {};\n\nconst rotAxis = new Cartesian3();\nconst tempVec = new Cartesian3();\nconst unitQuat = new Quaternion();\nconst rotMtx = new Matrix3();\n\nfunction pointOnEllipsoid(\n  theta,\n  rotation,\n  northVec,\n  eastVec,\n  aSqr,\n  ab,\n  bSqr,\n  mag,\n  unitPos,\n  result,\n) {\n  const azimuth = theta + rotation;\n\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n  let cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n  let sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n  const radius =\n    ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  const angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (\n  positions,\n  options,\n  extrude,\n) {\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n\n  const finalPositions = new Float64Array(size * 3);\n\n  const length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n\n    const extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    const scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian3,\n    );\n    Cartesian3.add(position, scaledNormal, position);\n\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nconst unitPosScratch = new Cartesian3();\nconst eastVecScratch = new Cartesian3();\nconst northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (\n  options,\n  addFillPositions,\n  addEdgePositions,\n) {\n  const semiMinorAxis = options.semiMinorAxis;\n  const semiMajorAxis = options.semiMajorAxis;\n  const rotation = options.rotation;\n  const center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  const granularity = options.granularity * 8.0;\n\n  const aSqr = semiMinorAxis * semiMinorAxis;\n  const bSqr = semiMajorAxis * semiMajorAxis;\n  const ab = semiMajorAxis * semiMinorAxis;\n\n  const mag = Cartesian3.magnitude(center);\n\n  const unitPos = Cartesian3.normalize(center, unitPosScratch);\n  let eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  const northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  let numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n  const deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  let theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  const size = 2 * (numPts * (numPts + 2));\n  const positions = addFillPositions ? new Array(size * 3) : undefined;\n  let positionIndex = 0;\n  let position = scratchCartesian1;\n  let reflectedPosition = scratchCartesian2;\n\n  const outerPositionsLength = numPts * 4 * 3;\n  let outerRightIndex = outerPositionsLength - 1;\n  let outerLeftIndex = 0;\n  const outerPositions = addEdgePositions\n    ? new Array(outerPositionsLength)\n    : undefined;\n\n  let i;\n  let j;\n  let numInterior;\n  let t;\n  let interiorPosition;\n\n  // Compute points in the 'eastern' half of the ellipse\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position,\n  );\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(\n      theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position,\n    );\n    reflectedPosition = pointOnEllipsoid(\n      Math.PI - theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition,\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3,\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the 'western' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n    position = pointOnEllipsoid(\n      -theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position,\n    );\n    reflectedPosition = pointOnEllipsoid(\n      theta + Math.PI,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition,\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3,\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    -theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position,\n  );\n\n  const r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\nexport default EllipseGeometryLibrary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}