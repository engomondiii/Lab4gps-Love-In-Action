{"ast":null,"code":"import addBuffer from \"./addBuffer.js\";\nimport ForEach from \"./ForEach.js\";\nimport readAccessorPacked from \"./readAccessorPacked.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Update accessors referenced by JOINTS_0 and WEIGHTS_0 attributes to use correct component types.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The glTF asset with compressed meshes.\n *\n * @private\n */\nfunction updateAccessorComponentTypes(gltf) {\n  let componentType;\n  ForEach.accessorWithSemantic(gltf, \"JOINTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (componentType !== WebGLConstants.UNSIGNED_BYTE && componentType !== WebGLConstants.UNSIGNED_SHORT) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n  ForEach.accessorWithSemantic(gltf, \"WEIGHTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (componentType === WebGLConstants.SHORT) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n  return gltf;\n}\nfunction convertType(gltf, accessor, updatedComponentType) {\n  const typedArray = ComponentDatatype.createTypedArray(updatedComponentType, readAccessorPacked(gltf, accessor));\n  const newBuffer = new Uint8Array(typedArray.buffer);\n  accessor.bufferView = addBuffer(gltf, newBuffer);\n  accessor.componentType = updatedComponentType;\n  accessor.byteOffset = 0;\n}\nexport default updateAccessorComponentTypes;","map":{"version":3,"names":["addBuffer","ForEach","readAccessorPacked","ComponentDatatype","WebGLConstants","updateAccessorComponentTypes","gltf","componentType","accessorWithSemantic","accessorId","accessor","accessors","BYTE","convertType","UNSIGNED_BYTE","UNSIGNED_SHORT","SHORT","updatedComponentType","typedArray","createTypedArray","newBuffer","Uint8Array","buffer","bufferView","byteOffset"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfPipeline/updateAccessorComponentTypes.js"],"sourcesContent":["import addBuffer from \"./addBuffer.js\";\nimport ForEach from \"./ForEach.js\";\nimport readAccessorPacked from \"./readAccessorPacked.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Update accessors referenced by JOINTS_0 and WEIGHTS_0 attributes to use correct component types.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The glTF asset with compressed meshes.\n *\n * @private\n */\nfunction updateAccessorComponentTypes(gltf) {\n  let componentType;\n  ForEach.accessorWithSemantic(gltf, \"JOINTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (\n      componentType !== WebGLConstants.UNSIGNED_BYTE &&\n      componentType !== WebGLConstants.UNSIGNED_SHORT\n    ) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n  ForEach.accessorWithSemantic(gltf, \"WEIGHTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (componentType === WebGLConstants.SHORT) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n\n  return gltf;\n}\n\nfunction convertType(gltf, accessor, updatedComponentType) {\n  const typedArray = ComponentDatatype.createTypedArray(\n    updatedComponentType,\n    readAccessorPacked(gltf, accessor)\n  );\n  const newBuffer = new Uint8Array(typedArray.buffer);\n  accessor.bufferView = addBuffer(gltf, newBuffer);\n  accessor.componentType = updatedComponentType;\n  accessor.byteOffset = 0;\n}\n\nexport default updateAccessorComponentTypes;\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,gBAAgB;AACtC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,iBAAiB,MAAM,iCAAiC;AAC/D,OAAOC,cAAc,MAAM,8BAA8B;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,4BAA4BA,CAACC,IAAI,EAAE;EAC1C,IAAIC,aAAa;EACjBN,OAAO,CAACO,oBAAoB,CAACF,IAAI,EAAE,UAAU,EAAE,UAAUG,UAAU,EAAE;IACnE,MAAMC,QAAQ,GAAGJ,IAAI,CAACK,SAAS,CAACF,UAAU,CAAC;IAC3CF,aAAa,GAAGG,QAAQ,CAACH,aAAa;IACtC,IAAIA,aAAa,KAAKH,cAAc,CAACQ,IAAI,EAAE;MACzCC,WAAW,CAACP,IAAI,EAAEI,QAAQ,EAAEP,iBAAiB,CAACW,aAAa,CAAC;IAC9D,CAAC,MAAM,IACLP,aAAa,KAAKH,cAAc,CAACU,aAAa,IAC9CP,aAAa,KAAKH,cAAc,CAACW,cAAc,EAC/C;MACAF,WAAW,CAACP,IAAI,EAAEI,QAAQ,EAAEP,iBAAiB,CAACY,cAAc,CAAC;IAC/D;EACF,CAAC,CAAC;EACFd,OAAO,CAACO,oBAAoB,CAACF,IAAI,EAAE,WAAW,EAAE,UAAUG,UAAU,EAAE;IACpE,MAAMC,QAAQ,GAAGJ,IAAI,CAACK,SAAS,CAACF,UAAU,CAAC;IAC3CF,aAAa,GAAGG,QAAQ,CAACH,aAAa;IACtC,IAAIA,aAAa,KAAKH,cAAc,CAACQ,IAAI,EAAE;MACzCC,WAAW,CAACP,IAAI,EAAEI,QAAQ,EAAEP,iBAAiB,CAACW,aAAa,CAAC;IAC9D,CAAC,MAAM,IAAIP,aAAa,KAAKH,cAAc,CAACY,KAAK,EAAE;MACjDH,WAAW,CAACP,IAAI,EAAEI,QAAQ,EAAEP,iBAAiB,CAACY,cAAc,CAAC;IAC/D;EACF,CAAC,CAAC;EAEF,OAAOT,IAAI;AACb;AAEA,SAASO,WAAWA,CAACP,IAAI,EAAEI,QAAQ,EAAEO,oBAAoB,EAAE;EACzD,MAAMC,UAAU,GAAGf,iBAAiB,CAACgB,gBAAgB,CACnDF,oBAAoB,EACpBf,kBAAkB,CAACI,IAAI,EAAEI,QAAQ,CACnC,CAAC;EACD,MAAMU,SAAS,GAAG,IAAIC,UAAU,CAACH,UAAU,CAACI,MAAM,CAAC;EACnDZ,QAAQ,CAACa,UAAU,GAAGvB,SAAS,CAACM,IAAI,EAAEc,SAAS,CAAC;EAChDV,QAAQ,CAACH,aAAa,GAAGU,oBAAoB;EAC7CP,QAAQ,CAACc,UAAU,GAAG,CAAC;AACzB;AAEA,eAAenB,4BAA4B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}