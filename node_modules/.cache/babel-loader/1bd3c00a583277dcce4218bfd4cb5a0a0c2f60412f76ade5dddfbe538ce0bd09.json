{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference, { isHeightReferenceClamp } from \"../Scene/HeightReference.js\";\nimport Model from \"../Scene/Model/Model.js\";\nimport ModelAnimationLoop from \"../Scene/ModelAnimationLoop.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nconst defaultScale = 1.0;\nconst defaultEnableVerticalExaggeration = true;\nconst defaultMinimumPixelSize = 0.0;\nconst defaultIncrementallyLoadTextures = true;\nconst defaultClampAnimations = true;\nconst defaultShadows = ShadowMode.ENABLED;\nconst defaultHeightReference = HeightReference.NONE;\nconst defaultSilhouetteColor = Color.RED;\nconst defaultSilhouetteSize = 0.0;\nconst defaultColor = Color.WHITE;\nconst defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\nconst defaultColorBlendAmount = 0.5;\nconst defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\nconst modelMatrixScratch = new Matrix4();\nconst nodeMatrixScratch = new Matrix4();\nconst scratchColor = new Color();\nconst scratchArray = new Array(4);\nconst scratchCartesian = new Cartesian3();\n\n/**\n * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n * @alias ModelVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction ModelVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  Check.typeOf.object(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n  this._scene = scene;\n  this._primitives = scene.primitives;\n  this._entityCollection = entityCollection;\n  this._modelHash = {};\n  this._entitiesToVisualize = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\nasync function createModelPrimitive(visualizer, entity, resource, incrementallyLoadTextures) {\n  const primitives = visualizer._primitives;\n  const modelHash = visualizer._modelHash;\n  try {\n    const model = await Model.fromGltfAsync({\n      url: resource,\n      incrementallyLoadTextures: incrementallyLoadTextures,\n      scene: visualizer._scene\n    });\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n    model.id = entity;\n    primitives.add(model);\n    modelHash[entity.id].modelPrimitive = model;\n    model.errorEvent.addEventListener(error => {\n      if (!defined(modelHash[entity.id])) {\n        return;\n      }\n      console.log(error);\n\n      // Texture failures when incrementallyLoadTextures\n      // will not affect the ability to compute the bounding sphere\n      if (error.name !== \"TextureError\" && model.incrementallyLoadTextures) {\n        modelHash[entity.id].loadFailed = true;\n      }\n    });\n  } catch (error) {\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n    console.log(error);\n    modelHash[entity.id].loadFailed = true;\n  }\n}\n\n/**\n * Updates models created this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nModelVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (let i = 0, len = entities.length; i < len; i++) {\n    const entity = entities[i];\n    const modelGraphics = entity._model;\n    let resource;\n    let modelData = modelHash[entity.id];\n    let show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);\n    let modelMatrix;\n    if (show) {\n      modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n      resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));\n      show = defined(modelMatrix) && defined(resource);\n    }\n    if (!show) {\n      if (defined(modelData) && modelData.modelPrimitive) {\n        modelData.modelPrimitive.show = false;\n      }\n      continue;\n    }\n    if (!defined(modelData) || resource.url !== modelData.url) {\n      if (defined(modelData?.modelPrimitive)) {\n        primitives.removeAndDestroy(modelData.modelPrimitive);\n        delete modelHash[entity.id];\n      }\n      modelData = {\n        modelPrimitive: undefined,\n        url: resource.url,\n        animationsRunning: false,\n        nodeTransformationsScratch: {},\n        articulationsScratch: {},\n        loadFailed: false,\n        modelUpdated: false\n      };\n      modelHash[entity.id] = modelData;\n      const incrementallyLoadTextures = Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures);\n      createModelPrimitive(this, entity, resource, incrementallyLoadTextures);\n    }\n    const model = modelData.modelPrimitive;\n    if (!defined(model)) {\n      continue;\n    }\n    model.show = true;\n    model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);\n    model.enableVerticalExaggeration = Property.getValueOrDefault(modelGraphics._enableVerticalExaggeration, time, defaultEnableVerticalExaggeration);\n    model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);\n    model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);\n    model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n    model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);\n    model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);\n    model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);\n    model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, scratchColor);\n    model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);\n    model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, scratchColor);\n    model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);\n    model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);\n    model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);\n    model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);\n    model.imageBasedLighting.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);\n    let lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);\n\n    // Convert from Color to Cartesian3\n    if (defined(lightColor)) {\n      Color.pack(lightColor, scratchArray, 0);\n      lightColor = Cartesian3.unpack(scratchArray, 0, scratchCartesian);\n    }\n    model.lightColor = lightColor;\n    model.customShader = Property.getValueOrUndefined(modelGraphics._customShader, time);\n\n    // It's possible for getBoundingSphere to run before\n    // model becomes ready and these properties are updated\n    modelHash[entity.id].modelUpdated = true;\n    if (model.ready) {\n      const runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);\n      if (modelData.animationsRunning !== runAnimations) {\n        if (runAnimations) {\n          model.activeAnimations.addAll({\n            loop: ModelAnimationLoop.REPEAT\n          });\n        } else {\n          model.activeAnimations.removeAll();\n        }\n        modelData.animationsRunning = runAnimations;\n      }\n\n      // Apply node transformations\n      const nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);\n      if (defined(nodeTransformations)) {\n        const nodeNames = Object.keys(nodeTransformations);\n        for (let nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {\n          const nodeName = nodeNames[nodeIndex];\n          const nodeTransformation = nodeTransformations[nodeName];\n          if (!defined(nodeTransformation)) {\n            continue;\n          }\n          const modelNode = model.getNode(nodeName);\n          if (!defined(modelNode)) {\n            continue;\n          }\n          const transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);\n          modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);\n        }\n      }\n\n      // Apply articulations\n      let anyArticulationUpdated = false;\n      const articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);\n      if (defined(articulations)) {\n        const articulationStageKeys = Object.keys(articulations);\n        for (let s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {\n          const key = articulationStageKeys[s];\n          const articulationStageValue = articulations[key];\n          if (!defined(articulationStageValue)) {\n            continue;\n          }\n          anyArticulationUpdated = true;\n          model.setArticulationStage(key, articulationStageValue);\n        }\n      }\n      if (anyArticulationUpdated) {\n        model.applyArticulations();\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nModelVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nModelVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (let i = entities.length - 1; i > -1; i--) {\n    removeModel(this, entities[i], modelHash, primitives);\n  }\n  return destroyObject(this);\n};\nconst scratchPosition = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nModelVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelData = this._modelHash[entity.id];\n  if (!defined(modelData)) {\n    return BoundingSphereState.FAILED;\n  }\n  if (modelData.loadFailed) {\n    return BoundingSphereState.FAILED;\n  }\n  const model = modelData.modelPrimitive;\n  if (!defined(model) || !model.show) {\n    return BoundingSphereState.PENDING;\n  }\n  if (!model.ready || !modelData.modelUpdated) {\n    return BoundingSphereState.PENDING;\n  }\n  const scene = this._scene;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n  const hasHeightReference = model.heightReference !== HeightReference.NONE;\n  if (hasHeightReference) {\n    const modelMatrix = model.modelMatrix;\n    scratchPosition.x = modelMatrix[12];\n    scratchPosition.y = modelMatrix[13];\n    scratchPosition.z = modelMatrix[14];\n    const cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition, scratchCartographic);\n    const height = scene.getHeight(cartoPosition, model.heightReference);\n    if (defined(height)) {\n      if (isHeightReferenceClamp(model.heightReference)) {\n        cartoPosition.height = height;\n      } else {\n        cartoPosition.height += height;\n      }\n    }\n    BoundingSphere.clone(model.boundingSphere, result);\n    result.center = ellipsoid.cartographicToCartesian(cartoPosition);\n    return BoundingSphereState.DONE;\n  }\n  BoundingSphere.clone(model.boundingSphere, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * @private\n */\nModelVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  let i;\n  let entity;\n  const entities = this._entitiesToVisualize;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      entities.set(entity.id, entity);\n    }\n  }\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      clearNodeTransformationsArticulationsScratch(entity, modelHash);\n      entities.set(entity.id, entity);\n    } else {\n      removeModel(this, entity, modelHash, primitives);\n      entities.remove(entity.id);\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    removeModel(this, entity, modelHash, primitives);\n    entities.remove(entity.id);\n  }\n};\nfunction removeModel(visualizer, entity, modelHash, primitives) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    primitives.removeAndDestroy(modelData.modelPrimitive);\n    delete modelHash[entity.id];\n  }\n}\nfunction clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    modelData.nodeTransformationsScratch = {};\n    modelData.articulationsScratch = {};\n  }\n}\nexport default ModelVisualizer;","map":{"version":3,"names":["AssociativeArray","BoundingSphere","Cartesian2","Cartesian3","Check","Color","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","Matrix4","Resource","ColorBlendMode","HeightReference","isHeightReferenceClamp","Model","ModelAnimationLoop","ShadowMode","BoundingSphereState","Property","Cartographic","defaultScale","defaultEnableVerticalExaggeration","defaultMinimumPixelSize","defaultIncrementallyLoadTextures","defaultClampAnimations","defaultShadows","ENABLED","defaultHeightReference","NONE","defaultSilhouetteColor","RED","defaultSilhouetteSize","defaultColor","WHITE","defaultColorBlendMode","HIGHLIGHT","defaultColorBlendAmount","defaultImageBasedLightingFactor","modelMatrixScratch","nodeMatrixScratch","scratchColor","scratchArray","Array","scratchCartesian","ModelVisualizer","scene","entityCollection","typeOf","object","collectionChanged","addEventListener","prototype","_onCollectionChanged","_scene","_primitives","primitives","_entityCollection","_modelHash","_entitiesToVisualize","values","createModelPrimitive","visualizer","entity","resource","incrementallyLoadTextures","modelHash","model","fromGltfAsync","url","isDestroyed","id","add","modelPrimitive","errorEvent","error","console","log","name","loadFailed","update","time","entities","i","len","length","modelGraphics","_model","modelData","show","isShowing","isAvailable","getValueOrDefault","_show","modelMatrix","computeModelMatrix","createIfNeeded","getValueOrUndefined","_uri","removeAndDestroy","undefined","animationsRunning","nodeTransformationsScratch","articulationsScratch","modelUpdated","_incrementallyLoadTextures","scale","_scale","enableVerticalExaggeration","_enableVerticalExaggeration","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","clone","shadows","_shadows","heightReference","_heightReference","distanceDisplayCondition","_distanceDisplayCondition","silhouetteColor","_silhouetteColor","silhouetteSize","_silhouetteSize","color","_color","colorBlendMode","_colorBlendMode","colorBlendAmount","_colorBlendAmount","clippingPlanes","_clippingPlanes","clampAnimations","_clampAnimations","imageBasedLighting","imageBasedLightingFactor","_imageBasedLightingFactor","lightColor","_lightColor","pack","unpack","customShader","_customShader","ready","runAnimations","_runAnimations","activeAnimations","addAll","loop","REPEAT","removeAll","nodeTransformations","_nodeTransformations","nodeNames","Object","keys","nodeIndex","nodeLength","nodeName","nodeTransformation","modelNode","getNode","transformationMatrix","fromTranslationRotationScale","matrix","multiply","originalMatrix","anyArticulationUpdated","articulations","_articulations","articulationStageKeys","s","numKeys","key","articulationStageValue","setArticulationStage","applyArticulations","destroy","removeEventListener","removeModel","scratchPosition","scratchCartographic","getBoundingSphere","result","FAILED","PENDING","ellipsoid","default","hasHeightReference","x","y","z","cartoPosition","cartesianToCartographic","height","getHeight","boundingSphere","center","cartographicToCartesian","DONE","added","removed","changed","_position","set","clearNodeTransformationsArticulationsScratch","remove"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/ModelVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference, {\n  isHeightReferenceClamp,\n} from \"../Scene/HeightReference.js\";\nimport Model from \"../Scene/Model/Model.js\";\nimport ModelAnimationLoop from \"../Scene/ModelAnimationLoop.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\n\nconst defaultScale = 1.0;\nconst defaultEnableVerticalExaggeration = true;\nconst defaultMinimumPixelSize = 0.0;\nconst defaultIncrementallyLoadTextures = true;\nconst defaultClampAnimations = true;\nconst defaultShadows = ShadowMode.ENABLED;\nconst defaultHeightReference = HeightReference.NONE;\nconst defaultSilhouetteColor = Color.RED;\nconst defaultSilhouetteSize = 0.0;\nconst defaultColor = Color.WHITE;\nconst defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\nconst defaultColorBlendAmount = 0.5;\nconst defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n\nconst modelMatrixScratch = new Matrix4();\nconst nodeMatrixScratch = new Matrix4();\n\nconst scratchColor = new Color();\nconst scratchArray = new Array(4);\nconst scratchCartesian = new Cartesian3();\n\n/**\n * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n * @alias ModelVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction ModelVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  Check.typeOf.object(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    ModelVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n\n  this._scene = scene;\n  this._primitives = scene.primitives;\n  this._entityCollection = entityCollection;\n  this._modelHash = {};\n  this._entitiesToVisualize = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\nasync function createModelPrimitive(\n  visualizer,\n  entity,\n  resource,\n  incrementallyLoadTextures,\n) {\n  const primitives = visualizer._primitives;\n  const modelHash = visualizer._modelHash;\n\n  try {\n    const model = await Model.fromGltfAsync({\n      url: resource,\n      incrementallyLoadTextures: incrementallyLoadTextures,\n      scene: visualizer._scene,\n    });\n\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n\n    model.id = entity;\n    primitives.add(model);\n    modelHash[entity.id].modelPrimitive = model;\n    model.errorEvent.addEventListener((error) => {\n      if (!defined(modelHash[entity.id])) {\n        return;\n      }\n\n      console.log(error);\n\n      // Texture failures when incrementallyLoadTextures\n      // will not affect the ability to compute the bounding sphere\n      if (error.name !== \"TextureError\" && model.incrementallyLoadTextures) {\n        modelHash[entity.id].loadFailed = true;\n      }\n    });\n  } catch (error) {\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n\n    console.log(error);\n    modelHash[entity.id].loadFailed = true;\n  }\n}\n\n/**\n * Updates models created this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nModelVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n\n  for (let i = 0, len = entities.length; i < len; i++) {\n    const entity = entities[i];\n    const modelGraphics = entity._model;\n\n    let resource;\n    let modelData = modelHash[entity.id];\n    let show =\n      entity.isShowing &&\n      entity.isAvailable(time) &&\n      Property.getValueOrDefault(modelGraphics._show, time, true);\n\n    let modelMatrix;\n    if (show) {\n      modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n      resource = Resource.createIfNeeded(\n        Property.getValueOrUndefined(modelGraphics._uri, time),\n      );\n      show = defined(modelMatrix) && defined(resource);\n    }\n\n    if (!show) {\n      if (defined(modelData) && modelData.modelPrimitive) {\n        modelData.modelPrimitive.show = false;\n      }\n      continue;\n    }\n\n    if (!defined(modelData) || resource.url !== modelData.url) {\n      if (defined(modelData?.modelPrimitive)) {\n        primitives.removeAndDestroy(modelData.modelPrimitive);\n        delete modelHash[entity.id];\n      }\n\n      modelData = {\n        modelPrimitive: undefined,\n        url: resource.url,\n        animationsRunning: false,\n        nodeTransformationsScratch: {},\n        articulationsScratch: {},\n        loadFailed: false,\n        modelUpdated: false,\n      };\n      modelHash[entity.id] = modelData;\n\n      const incrementallyLoadTextures = Property.getValueOrDefault(\n        modelGraphics._incrementallyLoadTextures,\n        time,\n        defaultIncrementallyLoadTextures,\n      );\n\n      createModelPrimitive(this, entity, resource, incrementallyLoadTextures);\n    }\n\n    const model = modelData.modelPrimitive;\n    if (!defined(model)) {\n      continue;\n    }\n\n    model.show = true;\n    model.scale = Property.getValueOrDefault(\n      modelGraphics._scale,\n      time,\n      defaultScale,\n    );\n\n    model.enableVerticalExaggeration = Property.getValueOrDefault(\n      modelGraphics._enableVerticalExaggeration,\n      time,\n      defaultEnableVerticalExaggeration,\n    );\n\n    model.minimumPixelSize = Property.getValueOrDefault(\n      modelGraphics._minimumPixelSize,\n      time,\n      defaultMinimumPixelSize,\n    );\n    model.maximumScale = Property.getValueOrUndefined(\n      modelGraphics._maximumScale,\n      time,\n    );\n    model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n    model.shadows = Property.getValueOrDefault(\n      modelGraphics._shadows,\n      time,\n      defaultShadows,\n    );\n    model.heightReference = Property.getValueOrDefault(\n      modelGraphics._heightReference,\n      time,\n      defaultHeightReference,\n    );\n    model.distanceDisplayCondition = Property.getValueOrUndefined(\n      modelGraphics._distanceDisplayCondition,\n      time,\n    );\n    model.silhouetteColor = Property.getValueOrDefault(\n      modelGraphics._silhouetteColor,\n      time,\n      defaultSilhouetteColor,\n      scratchColor,\n    );\n    model.silhouetteSize = Property.getValueOrDefault(\n      modelGraphics._silhouetteSize,\n      time,\n      defaultSilhouetteSize,\n    );\n    model.color = Property.getValueOrDefault(\n      modelGraphics._color,\n      time,\n      defaultColor,\n      scratchColor,\n    );\n    model.colorBlendMode = Property.getValueOrDefault(\n      modelGraphics._colorBlendMode,\n      time,\n      defaultColorBlendMode,\n    );\n    model.colorBlendAmount = Property.getValueOrDefault(\n      modelGraphics._colorBlendAmount,\n      time,\n      defaultColorBlendAmount,\n    );\n    model.clippingPlanes = Property.getValueOrUndefined(\n      modelGraphics._clippingPlanes,\n      time,\n    );\n    model.clampAnimations = Property.getValueOrDefault(\n      modelGraphics._clampAnimations,\n      time,\n      defaultClampAnimations,\n    );\n    model.imageBasedLighting.imageBasedLightingFactor =\n      Property.getValueOrDefault(\n        modelGraphics._imageBasedLightingFactor,\n        time,\n        defaultImageBasedLightingFactor,\n      );\n    let lightColor = Property.getValueOrUndefined(\n      modelGraphics._lightColor,\n      time,\n    );\n\n    // Convert from Color to Cartesian3\n    if (defined(lightColor)) {\n      Color.pack(lightColor, scratchArray, 0);\n      lightColor = Cartesian3.unpack(scratchArray, 0, scratchCartesian);\n    }\n\n    model.lightColor = lightColor;\n    model.customShader = Property.getValueOrUndefined(\n      modelGraphics._customShader,\n      time,\n    );\n\n    // It's possible for getBoundingSphere to run before\n    // model becomes ready and these properties are updated\n    modelHash[entity.id].modelUpdated = true;\n\n    if (model.ready) {\n      const runAnimations = Property.getValueOrDefault(\n        modelGraphics._runAnimations,\n        time,\n        true,\n      );\n      if (modelData.animationsRunning !== runAnimations) {\n        if (runAnimations) {\n          model.activeAnimations.addAll({\n            loop: ModelAnimationLoop.REPEAT,\n          });\n        } else {\n          model.activeAnimations.removeAll();\n        }\n        modelData.animationsRunning = runAnimations;\n      }\n\n      // Apply node transformations\n      const nodeTransformations = Property.getValueOrUndefined(\n        modelGraphics._nodeTransformations,\n        time,\n        modelData.nodeTransformationsScratch,\n      );\n      if (defined(nodeTransformations)) {\n        const nodeNames = Object.keys(nodeTransformations);\n        for (\n          let nodeIndex = 0, nodeLength = nodeNames.length;\n          nodeIndex < nodeLength;\n          ++nodeIndex\n        ) {\n          const nodeName = nodeNames[nodeIndex];\n\n          const nodeTransformation = nodeTransformations[nodeName];\n          if (!defined(nodeTransformation)) {\n            continue;\n          }\n\n          const modelNode = model.getNode(nodeName);\n          if (!defined(modelNode)) {\n            continue;\n          }\n\n          const transformationMatrix = Matrix4.fromTranslationRotationScale(\n            nodeTransformation,\n            nodeMatrixScratch,\n          );\n          modelNode.matrix = Matrix4.multiply(\n            modelNode.originalMatrix,\n            transformationMatrix,\n            transformationMatrix,\n          );\n        }\n      }\n\n      // Apply articulations\n      let anyArticulationUpdated = false;\n      const articulations = Property.getValueOrUndefined(\n        modelGraphics._articulations,\n        time,\n        modelData.articulationsScratch,\n      );\n      if (defined(articulations)) {\n        const articulationStageKeys = Object.keys(articulations);\n        for (\n          let s = 0, numKeys = articulationStageKeys.length;\n          s < numKeys;\n          ++s\n        ) {\n          const key = articulationStageKeys[s];\n\n          const articulationStageValue = articulations[key];\n          if (!defined(articulationStageValue)) {\n            continue;\n          }\n\n          anyArticulationUpdated = true;\n          model.setArticulationStage(key, articulationStageValue);\n        }\n      }\n\n      if (anyArticulationUpdated) {\n        model.applyArticulations();\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nModelVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nModelVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    ModelVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (let i = entities.length - 1; i > -1; i--) {\n    removeModel(this, entities[i], modelHash, primitives);\n  }\n  return destroyObject(this);\n};\n\nconst scratchPosition = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nModelVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelData = this._modelHash[entity.id];\n  if (!defined(modelData)) {\n    return BoundingSphereState.FAILED;\n  }\n\n  if (modelData.loadFailed) {\n    return BoundingSphereState.FAILED;\n  }\n\n  const model = modelData.modelPrimitive;\n  if (!defined(model) || !model.show) {\n    return BoundingSphereState.PENDING;\n  }\n\n  if (!model.ready || !modelData.modelUpdated) {\n    return BoundingSphereState.PENDING;\n  }\n\n  const scene = this._scene;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n\n  const hasHeightReference = model.heightReference !== HeightReference.NONE;\n  if (hasHeightReference) {\n    const modelMatrix = model.modelMatrix;\n    scratchPosition.x = modelMatrix[12];\n    scratchPosition.y = modelMatrix[13];\n    scratchPosition.z = modelMatrix[14];\n    const cartoPosition = ellipsoid.cartesianToCartographic(\n      scratchPosition,\n      scratchCartographic,\n    );\n\n    const height = scene.getHeight(cartoPosition, model.heightReference);\n    if (defined(height)) {\n      if (isHeightReferenceClamp(model.heightReference)) {\n        cartoPosition.height = height;\n      } else {\n        cartoPosition.height += height;\n      }\n    }\n\n    BoundingSphere.clone(model.boundingSphere, result);\n    result.center = ellipsoid.cartographicToCartesian(cartoPosition);\n    return BoundingSphereState.DONE;\n  }\n\n  BoundingSphere.clone(model.boundingSphere, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * @private\n */\nModelVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed,\n) {\n  let i;\n  let entity;\n  const entities = this._entitiesToVisualize;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      entities.set(entity.id, entity);\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      clearNodeTransformationsArticulationsScratch(entity, modelHash);\n      entities.set(entity.id, entity);\n    } else {\n      removeModel(this, entity, modelHash, primitives);\n      entities.remove(entity.id);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    removeModel(this, entity, modelHash, primitives);\n    entities.remove(entity.id);\n  }\n};\n\nfunction removeModel(visualizer, entity, modelHash, primitives) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    primitives.removeAndDestroy(modelData.modelPrimitive);\n    delete modelHash[entity.id];\n  }\n}\n\nfunction clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    modelData.nodeTransformationsScratch = {};\n    modelData.articulationsScratch = {};\n  }\n}\n\nexport default ModelVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}