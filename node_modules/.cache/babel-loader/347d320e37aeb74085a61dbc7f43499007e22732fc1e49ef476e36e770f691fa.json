{"ast":null,"code":"import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport BillboardCollectionFS from \"../Shaders/BillboardCollectionFS.js\";\nimport BillboardCollectionVS from \"../Shaders/BillboardCollectionVS.js\";\nimport Billboard from \"./Billboard.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference, { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nconst SHOW_INDEX = Billboard.SHOW_INDEX;\nconst POSITION_INDEX = Billboard.POSITION_INDEX;\nconst PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;\nconst EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;\nconst HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;\nconst VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;\nconst SCALE_INDEX = Billboard.SCALE_INDEX;\nconst IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;\nconst COLOR_INDEX = Billboard.COLOR_INDEX;\nconst ROTATION_INDEX = Billboard.ROTATION_INDEX;\nconst ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX = Billboard.DISTANCE_DISPLAY_CONDITION;\nconst DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE;\nconst TEXTURE_COORDINATE_BOUNDS = Billboard.TEXTURE_COORDINATE_BOUNDS;\nconst SDF_INDEX = Billboard.SDF_INDEX;\nconst SPLIT_DIRECTION_INDEX = Billboard.SPLIT_DIRECTION_INDEX;\nconst NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;\nlet attributeLocations;\nconst attributeLocationsBatched = {\n  positionHighAndScale: 0,\n  positionLowAndRotation: 1,\n  compressedAttribute0: 2,\n  // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates\n  compressedAttribute1: 3,\n  // aligned axis, translucency by distance, image width\n  compressedAttribute2: 4,\n  // image height, color, pick color, size in meters, valid aligned axis, 13 bits free\n  eyeOffset: 5,\n  // 4 bytes free\n  scaleByDistance: 6,\n  pixelOffsetScaleByDistance: 7,\n  compressedAttribute3: 8,\n  textureCoordinateBoundsOrLabelTranslate: 9,\n  a_batchId: 10,\n  sdf: 11,\n  splitDirection: 12\n};\nconst attributeLocationsInstanced = {\n  direction: 0,\n  positionHighAndScale: 1,\n  positionLowAndRotation: 2,\n  // texture offset in w\n  compressedAttribute0: 3,\n  compressedAttribute1: 4,\n  compressedAttribute2: 5,\n  eyeOffset: 6,\n  // texture range in w\n  scaleByDistance: 7,\n  pixelOffsetScaleByDistance: 8,\n  compressedAttribute3: 9,\n  textureCoordinateBoundsOrLabelTranslate: 10,\n  a_batchId: 11,\n  sdf: 12,\n  splitDirection: 13\n};\n\n/**\n * A renderable collection of billboards.  Billboards are viewport-aligned\n * images positioned in the 3D scene.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.png' width='400' height='300' /><br />\n * Example billboards\n * </div>\n * <br /><br />\n * Billboards are added and removed from the collection using {@link BillboardCollection#add}\n * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures\n * for images with the same identifier.\n *\n * @alias BillboardCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each billboard from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for billboards that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The billboard blending option. The default\n * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the billboards in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many billboards, to\n * many collections with only a few billboards each.  Organize collections so that billboards\n * with the same update frequency are in the same collection, i.e., billboards that do not\n * change should be in one collection; billboards that change every frame should be in another\n * collection; and so on.\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n * @see Billboard\n * @see LabelCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}\n *\n * @example\n * // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });\n */\nfunction BillboardCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n  this._textureAtlas = undefined;\n  this._textureAtlasGUID = undefined;\n  this._destroyTextureAtlas = true;\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = false;\n  this._shaderRotation = false;\n  this._compiledShaderRotation = false;\n  this._shaderAlignedAxis = false;\n  this._compiledShaderAlignedAxis = false;\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n  this._shaderPixelOffsetScaleByDistance = false;\n  this._compiledShaderPixelOffsetScaleByDistance = false;\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n  this._shaderClampToGround = false;\n  this._compiledShaderClampToGround = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._maxSize = 0.0;\n  this._maxEyeOffset = 0.0;\n  this._maxScale = 1.0;\n  this._maxPixelOffset = 0.0;\n  this._allHorizontalCenter = true;\n  this._allVerticalCenter = true;\n  this._allSizedInMeters = true;\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n  this._colorCommands = [];\n\n  /**\n   * Determines if billboards in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.\n   * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the texture atlas for this BillboardCollection as a fullscreen quad.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowTextureAtlas = defaultValue(options.debugShowTextureAtlas, false);\n\n  /**\n   * The billboard blending option. The default is used for rendering both opaque and translucent billboards.\n   * However, if either all of the billboards are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(options.blendOption, BlendOption.OPAQUE_AND_TRANSLUCENT);\n  this._blendOption = undefined;\n  this._mode = SceneMode.SCENE3D;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [BufferUsage.STATIC_DRAW,\n  // SHOW_INDEX\n  BufferUsage.STATIC_DRAW,\n  // POSITION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // PIXEL_OFFSET_INDEX\n  BufferUsage.STATIC_DRAW,\n  // EYE_OFFSET_INDEX\n  BufferUsage.STATIC_DRAW,\n  // HORIZONTAL_ORIGIN_INDEX\n  BufferUsage.STATIC_DRAW,\n  // VERTICAL_ORIGIN_INDEX\n  BufferUsage.STATIC_DRAW,\n  // SCALE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // IMAGE_INDEX_INDEX\n  BufferUsage.STATIC_DRAW,\n  // COLOR_INDEX\n  BufferUsage.STATIC_DRAW,\n  // ROTATION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // ALIGNED_AXIS_INDEX\n  BufferUsage.STATIC_DRAW,\n  // SCALE_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // TRANSLUCENCY_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // DISTANCE_DISPLAY_CONDITION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // TEXTURE_COORDINATE_BOUNDS\n  BufferUsage.STATIC_DRAW // SPLIT_DIRECTION_INDEX\n  ];\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  const that = this;\n  this._uniforms = {\n    u_atlas: function () {\n      return that._textureAtlas.texture;\n    },\n    u_highlightColor: function () {\n      return that._highlightColor;\n    }\n  };\n  const scene = this._scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._removeCallbackFunc = scene.terrainProviderChanged.addEventListener(function () {\n      const billboards = this._billboards;\n      const length = billboards.length;\n      for (let i = 0; i < length; ++i) {\n        if (defined(billboards[i])) {\n          billboards[i]._updateClamping();\n        }\n      }\n    }, this);\n  }\n}\nObject.defineProperties(BillboardCollection.prototype, {\n  /**\n   * Returns the number of billboards in this collection.  This is commonly used with\n   * {@link BillboardCollection#get} to iterate over all the billboards\n   * in the collection.\n   * @memberof BillboardCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      removeBillboards(this);\n      return this._billboards.length;\n    }\n  },\n  /**\n   * Gets or sets the textureAtlas.\n   * @memberof BillboardCollection.prototype\n   * @type {TextureAtlas}\n   * @private\n   */\n  textureAtlas: {\n    get: function () {\n      return this._textureAtlas;\n    },\n    set: function (value) {\n      if (this._textureAtlas !== value) {\n        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();\n        this._textureAtlas = value;\n        this._createVertexArray = true; // New per-billboard texture coordinates\n      }\n    }\n  },\n  /**\n   * Gets or sets a value which determines if the texture atlas is\n   * destroyed when the collection is destroyed.\n   *\n   * If the texture atlas is used by more than one collection, set this to <code>false</code>,\n   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.\n   *\n   * @memberof BillboardCollection.prototype\n   * @type {boolean}\n   * @private\n   *\n   * @example\n   * // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas({\n   *   scene : scene,\n   *   images : images\n   * });\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False\n   */\n  destroyTextureAtlas: {\n    get: function () {\n      return this._destroyTextureAtlas;\n    },\n    set: function (value) {\n      this._destroyTextureAtlas = value;\n    }\n  }\n});\nfunction destroyBillboards(billboards) {\n  const length = billboards.length;\n  for (let i = 0; i < length; ++i) {\n    if (billboards[i]) {\n      billboards[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a billboard with the specified initial properties to the collection.\n * The added billboard is returned so it can be modified or removed from the collection later.\n *\n * @param {Billboard.ConstructorOptions}[options] A template describing the billboard's properties as shown in Example 1.\n * @returns {Billboard} The billboard that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many billboards as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the billboard's cartographic position.\n * const b = billboards.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see BillboardCollection#remove\n * @see BillboardCollection#removeAll\n */\nBillboardCollection.prototype.add = function (options) {\n  const billboard = new Billboard(options, this);\n  billboard._index = this._billboards.length;\n  this._billboards.push(billboard);\n  this._createVertexArray = true;\n  return billboard;\n};\n\n/**\n * Removes a billboard from the collection.\n *\n * @param {Billboard} billboard The billboard to remove.\n * @returns {boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many billboards as possible before calling <code>update</code>.\n * If you intend to temporarily hide a billboard, it is usually more efficient to call\n * {@link Billboard#show} instead of removing and re-adding the billboard.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#removeAll\n * @see Billboard#show\n */\nBillboardCollection.prototype.remove = function (billboard) {\n  if (this.contains(billboard)) {\n    this._billboards[billboard._index] = undefined; // Removed later\n    this._billboardsRemoved = true;\n    this._createVertexArray = true;\n    billboard._destroy();\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all billboards from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n */\nBillboardCollection.prototype.removeAll = function () {\n  destroyBillboards(this._billboards);\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = true;\n};\nfunction removeBillboards(billboardCollection) {\n  if (billboardCollection._billboardsRemoved) {\n    billboardCollection._billboardsRemoved = false;\n    const newBillboards = [];\n    const billboards = billboardCollection._billboards;\n    const length = billboards.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const billboard = billboards[i];\n      if (defined(billboard)) {\n        billboard._index = j++;\n        newBillboards.push(billboard);\n      }\n    }\n    billboardCollection._billboards = newBillboards;\n  }\n}\nBillboardCollection.prototype._updateBillboard = function (billboard, propertyChanged) {\n  if (!billboard._dirty) {\n    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given billboard.\n *\n * @param {Billboard} [billboard] The billboard to check for.\n * @returns {boolean} true if this collection contains the billboard, false otherwise.\n *\n * @see BillboardCollection#get\n */\nBillboardCollection.prototype.contains = function (billboard) {\n  return defined(billboard) && billboard._billboardCollection === this;\n};\n\n/**\n * Returns the billboard in the collection at the specified index.  Indices are zero-based\n * and increase as billboards are added.  Removing a billboard shifts all billboards after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link BillboardCollection#length} to iterate over all the billboards\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n * @returns {Billboard} The billboard at the specified index.\n *\n * @performance Expected constant time.  If billboards were removed from the collection and\n * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n * @see BillboardCollection#length\n */\nBillboardCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  removeBillboards(this);\n  return this._billboards[index];\n};\nlet getIndexBuffer;\nfunction getIndexBufferBatched(context) {\n  const sixteenK = 16 * 1024;\n  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  // Subtract 6 because the last index is reserverd for primitive restart.\n  // https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.18\n  const length = sixteenK * 6 - 6;\n  const indices = new Uint16Array(length);\n  for (let i = 0, j = 0; i < length; i += 6, j += 4) {\n    indices[i] = j;\n    indices[i + 1] = j + 1;\n    indices[i + 2] = j + 2;\n    indices[i + 3] = j + 0;\n    indices[i + 4] = j + 2;\n    indices[i + 5] = j + 3;\n  }\n\n  // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?\n  // Is this too much memory to allocate up front?  Should we dynamically grow it?\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferBatched = indexBuffer;\n  return indexBuffer;\n}\nfunction getIndexBufferInstanced(context) {\n  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;\n  return indexBuffer;\n}\nfunction getVertexBufferInstanced(context) {\n  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;\n  if (defined(vertexBuffer)) {\n    return vertexBuffer;\n  }\n  vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]),\n    usage: BufferUsage.STATIC_DRAW\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;\n  return vertexBuffer;\n}\nBillboardCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage = properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n  return usageChanged;\n};\nfunction createVAF(context, numberOfBillboards, buffersUsage, instanced, batchTable, sdf) {\n  const attributes = [{\n    index: attributeLocations.positionHighAndScale,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.positionLowAndRotation,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute0,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[PIXEL_OFFSET_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute1,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute2,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[COLOR_INDEX]\n  }, {\n    index: attributeLocations.eyeOffset,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[EYE_OFFSET_INDEX]\n  }, {\n    index: attributeLocations.scaleByDistance,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[SCALE_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.pixelOffsetScaleByDistance,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute3,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]\n  }, {\n    index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS]\n  }, {\n    index: attributeLocations.splitDirection,\n    componentsPerAttribute: 1,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[SPLIT_DIRECTION_INDEX]\n  }];\n\n  // Instancing requires one non-instanced attribute.\n  if (instanced) {\n    attributes.push({\n      index: attributeLocations.direction,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      vertexBuffer: getVertexBufferInstanced(context)\n    });\n  }\n  if (defined(batchTable)) {\n    attributes.push({\n      index: attributeLocations.a_batchId,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      bufferUsage: BufferUsage.STATIC_DRAW\n    });\n  }\n  if (sdf) {\n    attributes.push({\n      index: attributeLocations.sdf,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SDF_INDEX]\n    });\n  }\n\n  // When instancing is enabled, only one vertex is needed for each billboard.\n  const sizeInVertices = instanced ? numberOfBillboards : 4 * numberOfBillboards;\n  return new VertexArrayFacade(context, attributes, sizeInVertices, instanced);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\nfunction writePositionScaleAndRotation(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const positionHighWriter = vafWriters[attributeLocations.positionHighAndScale];\n  const positionLowWriter = vafWriters[attributeLocations.positionLowAndRotation];\n  const position = billboard._getActualPosition();\n  if (billboardCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(billboardCollection._baseVolume, position, billboardCollection._baseVolume);\n    billboardCollection._boundingVolumeDirty = true;\n  }\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const scale = billboard.scale;\n  const rotation = billboard.rotation;\n  if (rotation !== 0.0) {\n    billboardCollection._shaderRotation = true;\n  }\n  billboardCollection._maxScale = Math.max(billboardCollection._maxScale, scale);\n  const high = writePositionScratch.high;\n  const low = writePositionScratch.low;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    positionHighWriter(i, high.x, high.y, high.z, scale);\n    positionLowWriter(i, low.x, low.y, low.z, rotation);\n  } else {\n    i = billboard._index * 4;\n    positionHighWriter(i + 0, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 1, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 2, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 3, high.x, high.y, high.z, scale);\n    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);\n  }\n}\nconst scratchCartesian2 = new Cartesian2();\nconst UPPER_BOUND = 32768.0; // 2^15\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT12 = 4096.0; // 2^12\nconst LEFT_SHIFT8 = 256.0; // 2^8\nconst LEFT_SHIFT7 = 128.0;\nconst LEFT_SHIFT5 = 32.0;\nconst LEFT_SHIFT3 = 8.0;\nconst LEFT_SHIFT2 = 4.0;\nconst RIGHT_SHIFT8 = 1.0 / 256.0;\nconst LOWER_LEFT = 0.0;\nconst LOWER_RIGHT = 2.0;\nconst UPPER_RIGHT = 3.0;\nconst UPPER_LEFT = 1.0;\nfunction writeCompressedAttrib0(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  const pixelOffset = billboard.pixelOffset;\n  const pixelOffsetX = pixelOffset.x;\n  const pixelOffsetY = pixelOffset.y;\n  const translate = billboard._translate;\n  const translateX = translate.x;\n  const translateY = translate.y;\n  billboardCollection._maxPixelOffset = Math.max(billboardCollection._maxPixelOffset, Math.abs(pixelOffsetX + translateX), Math.abs(-pixelOffsetY + translateY));\n  const horizontalOrigin = billboard.horizontalOrigin;\n  let verticalOrigin = billboard._verticalOrigin;\n  let show = billboard.show && billboard.clusterShow;\n\n  // If the color alpha is zero, do not show this billboard.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (billboard.color.alpha === 0.0) {\n    show = false;\n  }\n\n  // Raw billboards don't distinguish between BASELINE and BOTTOM, only LabelCollection does that.\n  if (verticalOrigin === VerticalOrigin.BASELINE) {\n    verticalOrigin = VerticalOrigin.BOTTOM;\n  }\n  billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin.CENTER;\n  billboardCollection._allVerticalCenter = billboardCollection._allVerticalCenter && verticalOrigin === VerticalOrigin.CENTER;\n  let bottomLeftX = 0;\n  let bottomLeftY = 0;\n  let width = 0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    bottomLeftX = imageRectangle.x;\n    bottomLeftY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const topRightX = bottomLeftX + width;\n  const topRightY = bottomLeftY + height;\n  let compressed0 = Math.floor(CesiumMath.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT7;\n  compressed0 += (horizontalOrigin + 1.0) * LEFT_SHIFT5;\n  compressed0 += (verticalOrigin + 1.0) * LEFT_SHIFT3;\n  compressed0 += (show ? 1.0 : 0.0) * LEFT_SHIFT2;\n  let compressed1 = Math.floor(CesiumMath.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT8;\n  let compressed2 = Math.floor(CesiumMath.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT8;\n  const tempTanslateY = (CesiumMath.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * RIGHT_SHIFT8;\n  const upperTranslateY = Math.floor(tempTanslateY);\n  const lowerTranslateY = Math.floor((tempTanslateY - upperTranslateY) * LEFT_SHIFT8);\n  compressed1 += upperTranslateY;\n  compressed2 += lowerTranslateY;\n  scratchCartesian2.x = bottomLeftX;\n  scratchCartesian2.y = bottomLeftY;\n  const compressedTexCoordsLL = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = topRightX;\n  const compressedTexCoordsLR = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.y = topRightY;\n  const compressedTexCoordsUR = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = bottomLeftX;\n  const compressedTexCoordsUL = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1, compressed2, compressedTexCoordsLL);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1, compressed2, compressedTexCoordsLR);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1, compressed2, compressedTexCoordsUR);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1, compressed2, compressedTexCoordsUL);\n  }\n}\nfunction writeCompressedAttrib1(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  const alignedAxis = billboard.alignedAxis;\n  if (!Cartesian3.equals(alignedAxis, Cartesian3.ZERO)) {\n    billboardCollection._shaderAlignedAxis = true;\n  }\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const translucency = billboard.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n  let width = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    width = imageRectangle.width;\n  }\n  const textureWidth = billboardCollection._textureAtlas.texture.width;\n  const imageWidth = Math.round(defaultValue(billboard.width, textureWidth * width));\n  billboardCollection._maxSize = Math.max(billboardCollection._maxSize, imageWidth);\n  let compressed0 = CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT16);\n  let compressed1 = 0.0;\n  if (Math.abs(Cartesian3.magnitudeSquared(alignedAxis) - 1.0) < CesiumMath.EPSILON6) {\n    compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);\n  }\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : nearValue * 255.0 | 0;\n  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : farValue * 255.0 | 0;\n  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, near, far);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, near, far);\n    writer(i + 1, compressed0, compressed1, near, far);\n    writer(i + 2, compressed0, compressed1, near, far);\n    writer(i + 3, compressed0, compressed1, near, far);\n  }\n}\nfunction writeCompressedAttrib2(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute2];\n  const color = billboard.color;\n  const pickColor = !defined(billboardCollection._batchTable) ? billboard.getPickId(frameState.context).color : Color.WHITE;\n  const sizeInMeters = billboard.sizeInMeters ? 1.0 : 0.0;\n  const validAlignedAxis = Math.abs(Cartesian3.magnitudeSquared(billboard.alignedAxis) - 1.0) < CesiumMath.EPSILON6 ? 1.0 : 0.0;\n  billboardCollection._allSizedInMeters = billboardCollection._allSizedInMeters && sizeInMeters === 1.0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    height = imageRectangle.height;\n  }\n  const dimensions = billboardCollection._textureAtlas.texture.dimensions;\n  const imageHeight = Math.round(defaultValue(billboard.height, dimensions.y * height));\n  billboardCollection._maxSize = Math.max(billboardCollection._maxSize, imageHeight);\n  let labelHorizontalOrigin = defaultValue(billboard._labelHorizontalOrigin, -2);\n  labelHorizontalOrigin += 2;\n  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  let compressed2 = Color.floatToByte(color.alpha) * LEFT_SHIFT16 + Color.floatToByte(pickColor.alpha) * LEFT_SHIFT8;\n  compressed2 += sizeInMeters * 2.0 + validAlignedAxis;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressed3);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 1, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 2, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 3, compressed0, compressed1, compressed2, compressed3);\n  }\n}\nfunction writeEyeOffset(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.eyeOffset];\n  const eyeOffset = billboard.eyeOffset;\n\n  // For billboards that are clamped to ground, move it slightly closer to the camera\n  let eyeOffsetZ = eyeOffset.z;\n  if (billboard._heightReference !== HeightReference.NONE) {\n    eyeOffsetZ *= 1.005;\n  }\n  billboardCollection._maxEyeOffset = Math.max(billboardCollection._maxEyeOffset, Math.abs(eyeOffset.x), Math.abs(eyeOffset.y), Math.abs(eyeOffsetZ));\n  if (billboardCollection._instanced) {\n    let width = 0;\n    let height = 0;\n    const index = billboard._imageIndex;\n    if (index !== -1) {\n      const imageRectangle = textureAtlasCoordinates[index];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(imageRectangle)) {\n        throw new DeveloperError(`Invalid billboard image index: ${index}`);\n      }\n      //>>includeEnd('debug');\n\n      width = imageRectangle.width;\n      height = imageRectangle.height;\n    }\n    scratchCartesian2.x = width;\n    scratchCartesian2.y = height;\n    const compressedTexCoordsRange = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    i = billboard._index;\n    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n  }\n}\nfunction writeScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const scale = billboard.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderScaleByDistance = true;\n    }\n  }\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\nfunction writePixelOffsetScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;\n  if (defined(pixelOffsetScale)) {\n    near = pixelOffsetScale.near;\n    nearValue = pixelOffsetScale.nearValue;\n    far = pixelOffsetScale.far;\n    farValue = pixelOffsetScale.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // pixelOffsetScale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderPixelOffsetScaleByDistance = true;\n    }\n  }\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\nfunction writeCompressedAttribute3(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute3];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n  const distanceDisplayCondition = billboard.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n    near *= near;\n    far *= far;\n    billboardCollection._shaderDistanceDisplayCondition = true;\n  }\n  let disableDepthTestDistance = billboard.disableDepthTestDistance;\n  const clampToGround = isHeightReferenceClamp(billboard.heightReference) && frameState.context.depthTexture;\n  if (!defined(disableDepthTestDistance)) {\n    disableDepthTestDistance = clampToGround ? 5000.0 : 0.0;\n  }\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (clampToGround || disableDepthTestDistance > 0.0) {\n    billboardCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n  let imageHeight;\n  let imageWidth;\n  if (!defined(billboard._labelDimensions)) {\n    let height = 0;\n    let width = 0;\n    const index = billboard._imageIndex;\n    if (index !== -1) {\n      const imageRectangle = textureAtlasCoordinates[index];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(imageRectangle)) {\n        throw new DeveloperError(`Invalid billboard image index: ${index}`);\n      }\n      //>>includeEnd('debug');\n\n      height = imageRectangle.height;\n      width = imageRectangle.width;\n    }\n    imageHeight = Math.round(defaultValue(billboard.height, billboardCollection._textureAtlas.texture.dimensions.y * height));\n    const textureWidth = billboardCollection._textureAtlas.texture.width;\n    imageWidth = Math.round(defaultValue(billboard.width, textureWidth * width));\n  } else {\n    imageWidth = billboard._labelDimensions.x;\n    imageHeight = billboard._labelDimensions.y;\n  }\n  const w = Math.floor(CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT12));\n  const h = Math.floor(CesiumMath.clamp(imageHeight, 0.0, LEFT_SHIFT12));\n  const dimensions = w * LEFT_SHIFT12 + h;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, far, disableDepthTestDistance, dimensions);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 1, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 2, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 3, near, far, disableDepthTestDistance, dimensions);\n  }\n}\nfunction writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  if (isHeightReferenceClamp(billboard.heightReference)) {\n    const scene = billboardCollection._scene;\n    const context = frameState.context;\n    const globeTranslucent = frameState.globeTranslucencyState.translucent;\n    const depthTestAgainstTerrain = defined(scene.globe) && scene.globe.depthTestAgainstTerrain;\n\n    // Only do manual depth test if the globe is opaque and writes depth\n    billboardCollection._shaderClampToGround = context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;\n  }\n  let i;\n  const writer = vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];\n  if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n    //write _labelTranslate, used by depth testing in the vertex shader\n    let translateX = 0;\n    let translateY = 0;\n    if (defined(billboard._labelTranslate)) {\n      translateX = billboard._labelTranslate.x;\n      translateY = billboard._labelTranslate.y;\n    }\n    if (billboardCollection._instanced) {\n      i = billboard._index;\n      writer(i, translateX, translateY, 0.0, 0.0);\n    } else {\n      i = billboard._index * 4;\n      writer(i + 0, translateX, translateY, 0.0, 0.0);\n      writer(i + 1, translateX, translateY, 0.0, 0.0);\n      writer(i + 2, translateX, translateY, 0.0, 0.0);\n      writer(i + 3, translateX, translateY, 0.0, 0.0);\n    }\n    return;\n  }\n\n  //write texture coordinate bounds, used by depth testing in fragment shader\n  let minX = 0;\n  let minY = 0;\n  let width = 0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    minX = imageRectangle.x;\n    minY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const maxX = minX + width;\n  const maxY = minY + height;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, minX, minY, maxX, maxY);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, minX, minY, maxX, maxY);\n    writer(i + 1, minX, minY, maxX, maxY);\n    writer(i + 2, minX, minY, maxX, maxY);\n    writer(i + 3, minX, minY, maxX, maxY);\n  }\n}\nfunction writeBatchId(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  if (!defined(billboardCollection._batchTable)) {\n    return;\n  }\n  const writer = vafWriters[attributeLocations.a_batchId];\n  const id = billboard._batchIndex;\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, id);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, id);\n    writer(i + 1, id);\n    writer(i + 2, id);\n    writer(i + 3, id);\n  }\n}\nfunction writeSDF(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  if (!billboardCollection._sdf) {\n    return;\n  }\n  let i;\n  const writer = vafWriters[attributeLocations.sdf];\n  const outlineColor = billboard.outlineColor;\n  const outlineWidth = billboard.outlineWidth;\n  const red = Color.floatToByte(outlineColor.red);\n  const green = Color.floatToByte(outlineColor.green);\n  const blue = Color.floatToByte(outlineColor.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  // Compute the relative outline distance\n  const outlineDistance = outlineWidth / SDFSettings.RADIUS;\n  const compressed1 = Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 + Color.floatToByte(outlineDistance) * LEFT_SHIFT8;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);\n  }\n}\nfunction writeSplitDirection(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  const writer = vafWriters[attributeLocations.splitDirection];\n  let direction = 0.0;\n  const split = billboard.splitDirection;\n  if (defined(split)) {\n    direction = split;\n  }\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, direction);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, direction);\n    writer(i + 1, direction);\n    writer(i + 2, direction);\n    writer(i + 3, direction);\n  }\n}\nfunction writeBillboard(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {\n  writePositionScaleAndRotation(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeCompressedAttrib0(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeCompressedAttrib1(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeCompressedAttrib2(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeEyeOffset(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writePixelOffsetScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeCompressedAttribute3(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeBatchId(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeSDF(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n  writeSplitDirection(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard);\n}\nfunction recomputeActualPositions(billboardCollection, billboards, length, frameState, modelMatrix, recomputeBoundingVolume) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = billboardCollection._baseVolume;\n    billboardCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = billboardCollection._baseVolume2D;\n  }\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const billboard = billboards[i];\n    const position = billboard.position;\n    const actualPosition = Billboard._computeActualPosition(billboard, position, frameState, modelMatrix);\n    if (defined(actualPosition)) {\n      billboard._setActualPosition(actualPosition);\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\nfunction updateMode(billboardCollection, frameState) {\n  const mode = frameState.mode;\n  const billboards = billboardCollection._billboards;\n  const billboardsToUpdate = billboardCollection._billboardsToUpdate;\n  const modelMatrix = billboardCollection._modelMatrix;\n  if (billboardCollection._createVertexArray || billboardCollection._mode !== mode || mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, billboardCollection.modelMatrix)) {\n    billboardCollection._mode = mode;\n    Matrix4.clone(billboardCollection.modelMatrix, modelMatrix);\n    billboardCollection._createVertexArray = true;\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n      recomputeActualPositions(billboardCollection, billboards, billboards.length, frameState, modelMatrix, true);\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(billboardCollection, billboards, billboards.length, frameState, modelMatrix, true);\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(billboardCollection, billboardsToUpdate, billboardCollection._billboardsToUpdateIndex, frameState, modelMatrix, false);\n  }\n}\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  let pixelScale = 1.0;\n  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0.0) {\n    pixelScale = frameState.camera.getPixelSize(boundingVolume, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n  }\n  let size = pixelScale * collection._maxScale * collection._maxSize * 2.0;\n  if (collection._allHorizontalCenter && collection._allVerticalCenter) {\n    size *= 0.5;\n  }\n  const offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;\n  boundingVolume.radius += size + offset;\n}\nfunction createDebugCommand(billboardCollection, context) {\n  const fs = \"uniform sampler2D billboard_texture; \\n\" + \"in vec2 v_textureCoordinates; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    out_FragColor = texture(billboard_texture, v_textureCoordinates); \\n\" + \"} \\n\";\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      billboard_texture: function () {\n        return billboardCollection._textureAtlas.texture;\n      }\n    }\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\nconst scratchWriterArray = [];\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} image with id must be in the atlas.\n */\nBillboardCollection.prototype.update = function (frameState) {\n  removeBillboards(this);\n  if (!this.show) {\n    return;\n  }\n  let billboards = this._billboards;\n  let billboardsLength = billboards.length;\n  const context = frameState.context;\n  this._instanced = context.instancedArrays;\n  attributeLocations = this._instanced ? attributeLocationsInstanced : attributeLocationsBatched;\n  getIndexBuffer = this._instanced ? getIndexBufferInstanced : getIndexBufferBatched;\n  let textureAtlas = this._textureAtlas;\n  if (!defined(textureAtlas)) {\n    textureAtlas = this._textureAtlas = new TextureAtlas({\n      context: context\n    });\n    for (let ii = 0; ii < billboardsLength; ++ii) {\n      billboards[ii]._loadImage();\n    }\n  }\n  const textureAtlasCoordinates = textureAtlas.textureCoordinates;\n  if (textureAtlasCoordinates.length === 0) {\n    // Can't write billboard vertices until we have texture coordinates\n    // provided by a texture atlas\n    return;\n  }\n  updateMode(this, frameState);\n  billboards = this._billboards;\n  billboardsLength = billboards.length;\n  const billboardsToUpdate = this._billboardsToUpdate;\n  const billboardsToUpdateLength = this._billboardsToUpdateIndex;\n  const properties = this._propertiesChanged;\n  const textureAtlasGUID = textureAtlas.guid;\n  const createVertexArray = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;\n  this._textureAtlasGUID = textureAtlasGUID;\n  let vafWriters;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || !picking && this.computeNewBuffersUsage()) {\n    this._createVertexArray = false;\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n    this._vaf = this._vaf && this._vaf.destroy();\n    if (billboardsLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, billboardsLength, this._buffersUsage, this._instanced, this._batchTable, this._sdf);\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if billboards were added or removed.\n      for (let i = 0; i < billboardsLength; ++i) {\n        const billboard = this._billboards[i];\n        billboard._dirty = false; // In case it needed an update.\n        writeBillboard(this, frameState, textureAtlasCoordinates, vafWriters, billboard);\n      }\n\n      // Different billboard collections share the same index buffer.\n      this._vaf.commit(getIndexBuffer(context));\n    }\n    this._billboardsToUpdateIndex = 0;\n  } else if (billboardsToUpdateLength > 0) {\n    // Billboards were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n    if (properties[POSITION_INDEX] || properties[ROTATION_INDEX] || properties[SCALE_INDEX]) {\n      writers.push(writePositionScaleAndRotation);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[PIXEL_OFFSET_INDEX] || properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n      if (this._instanced) {\n        writers.push(writeEyeOffset);\n      }\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[ALIGNED_AXIS_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n      writers.push(writeCompressedAttrib2);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib2);\n    }\n    if (properties[EYE_OFFSET_INDEX]) {\n      writers.push(writeEyeOffset);\n    }\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writePixelOffsetScaleByDistance);\n    }\n    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE] || properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeCompressedAttribute3);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);\n    }\n    if (properties[SDF_INDEX]) {\n      writers.push(writeSDF);\n    }\n    if (properties[SPLIT_DIRECTION_INDEX]) {\n      writers.push(writeSplitDirection);\n    }\n    const numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n    if (billboardsToUpdateLength / billboardsLength > 0.1) {\n      // If more than 10% of billboard change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < billboardsToUpdateLength; ++m) {\n        const b = billboardsToUpdate[m];\n        b._dirty = false;\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, frameState, textureAtlasCoordinates, vafWriters, b);\n        }\n      }\n      this._vaf.commit(getIndexBuffer(context));\n    } else {\n      for (let h = 0; h < billboardsToUpdateLength; ++h) {\n        const bb = billboardsToUpdate[h];\n        bb._dirty = false;\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, frameState, textureAtlasCoordinates, vafWriters, bb);\n        }\n        if (this._instanced) {\n          this._vaf.subCommit(bb._index, 1);\n        } else {\n          this._vaf.subCommit(bb._index * 4, 4);\n        }\n      }\n      this._vaf.endSubCommits();\n    }\n    this._billboardsToUpdateIndex = 0;\n  }\n\n  // If the number of total billboards ever shrinks considerably\n  // Truncate billboardsToUpdate so that we free memory that we're\n  // not going to be using.\n  if (billboardsToUpdateLength > billboardsLength * 1.5) {\n    billboardsToUpdate.length = billboardsLength;\n  }\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC);\n  }\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(this._baseVolumeWC, this._boundingVolume);\n  } else {\n    boundingVolume = BoundingSphere.clone(this._baseVolume2D, this._boundingVolume);\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n  if (blendOptionChanged) {\n    if (this._blendOption === BlendOption.OPAQUE || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LESS\n        },\n        depthMask: true\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    // If OPAQUE_AND_TRANSLUCENT is in use, only the opaque pass gets the benefit of the depth buffer,\n    // not the translucent pass.  Otherwise, if the TRANSLUCENT pass is on its own, it turns on\n    // a depthMask in lieu of full depth sorting (because it has opaque-ish fragments that look bad in OIT).\n    // When the TRANSLUCENT depth mask is in use, label backgrounds require the depth func to be LEQUAL.\n    const useTranslucentDepthMask = this._blendOption === BlendOption.TRANSLUCENT;\n    if (this._blendOption === BlendOption.TRANSLUCENT || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: useTranslucentDepthMask ? WebGLConstants.LEQUAL : WebGLConstants.LESS\n        },\n        depthMask: useTranslucentDepthMask,\n        blending: BlendingState.ALPHA_BLEND\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0.0;\n  let vsSource;\n  let fsSource;\n  let vs;\n  let fs;\n  let vertDefines;\n  const supportVSTextureReads = ContextLimits.maximumVertexTextureImageUnits > 0;\n  if (blendOptionChanged || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) {\n    vsSource = BillboardCollectionVS;\n    fsSource = BillboardCollectionFS;\n    vertDefines = [];\n    if (defined(this._batchTable)) {\n      vertDefines.push(\"VECTOR_TILE\");\n      vsSource = this._batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(vsSource);\n      fsSource = this._batchTable.getFragmentShaderCallback(false, undefined)(fsSource);\n    }\n    vs = new ShaderSource({\n      defines: vertDefines,\n      sources: [vsSource]\n    });\n    if (this._instanced) {\n      vs.defines.push(\"INSTANCED\");\n    }\n    if (this._shaderRotation) {\n      vs.defines.push(\"ROTATION\");\n    }\n    if (this._shaderAlignedAxis) {\n      vs.defines.push(\"ALIGNED_AXIS\");\n    }\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderPixelOffsetScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_PIXEL_OFFSET\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n    if (this._shaderClampToGround) {\n      if (supportVSTextureReads) {\n        vs.defines.push(\"VERTEX_DEPTH_CHECK\");\n      } else {\n        vs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n      }\n    }\n    const sdfEdge = 1.0 - SDFSettings.CUTOFF;\n    if (this._sdf) {\n      vs.defines.push(\"SDF\");\n    }\n    const vectorFragDefine = defined(this._batchTable) ? \"VECTOR_TILE\" : \"\";\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\", vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\", vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    this._compiledShaderRotation = this._shaderRotation;\n    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n    this._compiledShaderClampToGround = this._shaderClampToGround;\n    this._compiledSDF = this._sdf;\n  }\n  const commandList = frameState.commandList;\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent = this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n    const va = this._vaf.va;\n    const vaLength = va.length;\n    let uniforms = this._uniforms;\n    let pickId;\n    if (defined(this._batchTable)) {\n      uniforms = this._batchTable.getUniformMapCallback()(uniforms);\n      pickId = this._batchTable.getPickId();\n    } else {\n      pickId = \"v_pickColor\";\n    }\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (let j = 0; j < totalLength; ++j) {\n      let command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;\n      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.count = va[index].indicesCount;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = pickId;\n      if (this._instanced) {\n        command.count = 6;\n        command.instanceCount = billboardsLength;\n      }\n      commandList.push(command);\n    }\n    if (this.debugShowTextureAtlas) {\n      if (!defined(this.debugCommand)) {\n        this.debugCommand = createDebugCommand(this, frameState.context);\n      }\n      commandList.push(this.debugCommand);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BillboardCollection#destroy\n */\nBillboardCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards = billboards && billboards.destroy();\n *\n * @see BillboardCollection#isDestroyed\n */\nBillboardCollection.prototype.destroy = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n    this._removeCallbackFunc = undefined;\n  }\n  this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyBillboards(this._billboards);\n  return destroyObject(this);\n};\nexport default BillboardCollection;","map":{"version":3,"names":["AttributeCompression","BoundingSphere","Cartesian2","Cartesian3","Check","Color","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","IndexDatatype","CesiumMath","Matrix4","WebGLConstants","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArrayFacade","BillboardCollectionFS","BillboardCollectionVS","Billboard","BlendingState","BlendOption","HeightReference","isHeightReferenceClamp","HorizontalOrigin","SceneMode","SDFSettings","TextureAtlas","VerticalOrigin","SHOW_INDEX","POSITION_INDEX","PIXEL_OFFSET_INDEX","EYE_OFFSET_INDEX","HORIZONTAL_ORIGIN_INDEX","VERTICAL_ORIGIN_INDEX","SCALE_INDEX","IMAGE_INDEX_INDEX","COLOR_INDEX","ROTATION_INDEX","ALIGNED_AXIS_INDEX","SCALE_BY_DISTANCE_INDEX","TRANSLUCENCY_BY_DISTANCE_INDEX","PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX","DISTANCE_DISPLAY_CONDITION_INDEX","DISTANCE_DISPLAY_CONDITION","DISABLE_DEPTH_DISTANCE","TEXTURE_COORDINATE_BOUNDS","SDF_INDEX","SPLIT_DIRECTION_INDEX","NUMBER_OF_PROPERTIES","attributeLocations","attributeLocationsBatched","positionHighAndScale","positionLowAndRotation","compressedAttribute0","compressedAttribute1","compressedAttribute2","eyeOffset","scaleByDistance","pixelOffsetScaleByDistance","compressedAttribute3","textureCoordinateBoundsOrLabelTranslate","a_batchId","sdf","splitDirection","attributeLocationsInstanced","direction","BillboardCollection","options","EMPTY_OBJECT","_scene","scene","_batchTable","batchTable","_textureAtlas","undefined","_textureAtlasGUID","_destroyTextureAtlas","_sp","_spTranslucent","_rsOpaque","_rsTranslucent","_vaf","_billboards","_billboardsToUpdate","_billboardsToUpdateIndex","_billboardsRemoved","_createVertexArray","_shaderRotation","_compiledShaderRotation","_shaderAlignedAxis","_compiledShaderAlignedAxis","_shaderScaleByDistance","_compiledShaderScaleByDistance","_shaderTranslucencyByDistance","_compiledShaderTranslucencyByDistance","_shaderPixelOffsetScaleByDistance","_compiledShaderPixelOffsetScaleByDistance","_shaderDistanceDisplayCondition","_compiledShaderDistanceDisplayCondition","_shaderDisableDepthDistance","_compiledShaderDisableDepthDistance","_shaderClampToGround","_compiledShaderClampToGround","_propertiesChanged","Uint32Array","_maxSize","_maxEyeOffset","_maxScale","_maxPixelOffset","_allHorizontalCenter","_allVerticalCenter","_allSizedInMeters","_baseVolume","_baseVolumeWC","_baseVolume2D","_boundingVolume","_boundingVolumeDirty","_colorCommands","show","modelMatrix","clone","IDENTITY","_modelMatrix","debugShowBoundingVolume","debugShowTextureAtlas","blendOption","OPAQUE_AND_TRANSLUCENT","_blendOption","_mode","SCENE3D","_buffersUsage","STATIC_DRAW","_highlightColor","WHITE","that","_uniforms","u_atlas","texture","u_highlightColor","terrainProviderChanged","_removeCallbackFunc","addEventListener","billboards","length","i","_updateClamping","Object","defineProperties","prototype","get","removeBillboards","textureAtlas","set","value","destroy","destroyTextureAtlas","destroyBillboards","_destroy","add","billboard","_index","push","remove","contains","removeAll","billboardCollection","newBillboards","j","_updateBillboard","propertyChanged","_dirty","_billboardCollection","index","typeOf","number","getIndexBuffer","getIndexBufferBatched","context","sixteenK","indexBuffer","cache","billboardCollection_indexBufferBatched","indices","Uint16Array","createIndexBuffer","typedArray","usage","indexDatatype","UNSIGNED_SHORT","vertexArrayDestroyable","getIndexBufferInstanced","billboardCollection_indexBufferInstanced","getVertexBufferInstanced","vertexBuffer","billboardCollection_vertexBufferInstanced","createVertexBuffer","Float32Array","computeNewBuffersUsage","buffersUsage","usageChanged","properties","k","newUsage","STREAM_DRAW","createVAF","numberOfBillboards","instanced","attributes","componentsPerAttribute","componentDatatype","FLOAT","bufferUsage","sizeInVertices","writePositionScratch","writePositionScaleAndRotation","frameState","textureAtlasCoordinates","vafWriters","positionHighWriter","positionLowWriter","position","_getActualPosition","expand","fromCartesian","scale","rotation","Math","max","high","low","_instanced","x","y","z","scratchCartesian2","UPPER_BOUND","LEFT_SHIFT16","LEFT_SHIFT12","LEFT_SHIFT8","LEFT_SHIFT7","LEFT_SHIFT5","LEFT_SHIFT3","LEFT_SHIFT2","RIGHT_SHIFT8","LOWER_LEFT","LOWER_RIGHT","UPPER_RIGHT","UPPER_LEFT","writeCompressedAttrib0","writer","pixelOffset","pixelOffsetX","pixelOffsetY","translate","_translate","translateX","translateY","abs","horizontalOrigin","verticalOrigin","_verticalOrigin","clusterShow","color","alpha","BASELINE","BOTTOM","CENTER","bottomLeftX","bottomLeftY","width","height","_imageIndex","imageRectangle","topRightX","topRightY","compressed0","floor","clamp","compressed1","compressed2","tempTanslateY","upperTranslateY","lowerTranslateY","compressedTexCoordsLL","compressTextureCoordinates","compressedTexCoordsLR","compressedTexCoordsUR","compressedTexCoordsUL","writeCompressedAttrib1","alignedAxis","equals","ZERO","near","nearValue","far","farValue","translucency","translucencyByDistance","textureWidth","imageWidth","round","magnitudeSquared","EPSILON6","octEncodeFloat","writeCompressedAttrib2","pickColor","getPickId","sizeInMeters","validAlignedAxis","dimensions","imageHeight","labelHorizontalOrigin","_labelHorizontalOrigin","compressed3","red","floatToByte","green","blue","writeEyeOffset","eyeOffsetZ","_heightReference","NONE","compressedTexCoordsRange","writeScaleByDistance","writePixelOffsetScaleByDistance","pixelOffsetScale","writeCompressedAttribute3","Number","MAX_VALUE","distanceDisplayCondition","disableDepthTestDistance","clampToGround","heightReference","depthTexture","POSITIVE_INFINITY","_labelDimensions","w","h","writeTextureCoordinateBoundsOrLabelTranslate","globeTranslucent","globeTranslucencyState","translucent","depthTestAgainstTerrain","globe","maximumVertexTextureImageUnits","_labelTranslate","minX","minY","maxX","maxY","writeBatchId","id","_batchIndex","writeSDF","_sdf","outlineColor","outlineWidth","outlineDistance","RADIUS","writeSplitDirection","split","writeBillboard","recomputeActualPositions","recomputeBoundingVolume","boundingVolume","mode","positions","actualPosition","_computeActualPosition","_setActualPosition","fromPoints","updateMode","billboardsToUpdate","SCENE2D","COLUMBUS_VIEW","MORPHING","updateBoundingVolume","collection","pixelScale","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","size","offset","radius","createDebugCommand","fs","drawCommand","createViewportQuadCommand","uniformMap","billboard_texture","pass","OVERLAY","scratchWriterArray","update","billboardsLength","instancedArrays","ii","_loadImage","textureCoordinates","billboardsToUpdateLength","textureAtlasGUID","guid","createVertexArray","passes","picking","pick","writers","commit","numWriters","m","b","n","bb","o","subCommit","endSubCommits","va","transform","blendOptionChanged","OPAQUE","fromCache","depthTest","enabled","func","LESS","depthMask","useTranslucentDepthMask","TRANSLUCENT","LEQUAL","blending","ALPHA_BLEND","minimumDisableDepthTestDistance","vsSource","fsSource","vs","vertDefines","supportVSTextureReads","_compiledSDF","getVertexShaderCallback","getFragmentShaderCallback","defines","sources","sdfEdge","CUTOFF","vectorFragDefine","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","commandList","render","colorList","opaque","opaqueAndTranslucent","vaLength","uniforms","pickId","getUniformMapCallback","totalLength","command","opaqueCommand","owner","count","indicesCount","vertexArray","renderState","instanceCount","debugCommand","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/BillboardCollection.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport BillboardCollectionFS from \"../Shaders/BillboardCollectionFS.js\";\nimport BillboardCollectionVS from \"../Shaders/BillboardCollectionVS.js\";\nimport Billboard from \"./Billboard.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference, { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\nconst SHOW_INDEX = Billboard.SHOW_INDEX;\nconst POSITION_INDEX = Billboard.POSITION_INDEX;\nconst PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;\nconst EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;\nconst HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;\nconst VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;\nconst SCALE_INDEX = Billboard.SCALE_INDEX;\nconst IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;\nconst COLOR_INDEX = Billboard.COLOR_INDEX;\nconst ROTATION_INDEX = Billboard.ROTATION_INDEX;\nconst ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX =\n  Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX = Billboard.DISTANCE_DISPLAY_CONDITION;\nconst DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE;\nconst TEXTURE_COORDINATE_BOUNDS = Billboard.TEXTURE_COORDINATE_BOUNDS;\nconst SDF_INDEX = Billboard.SDF_INDEX;\nconst SPLIT_DIRECTION_INDEX = Billboard.SPLIT_DIRECTION_INDEX;\nconst NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;\n\nlet attributeLocations;\n\nconst attributeLocationsBatched = {\n  positionHighAndScale: 0,\n  positionLowAndRotation: 1,\n  compressedAttribute0: 2, // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates\n  compressedAttribute1: 3, // aligned axis, translucency by distance, image width\n  compressedAttribute2: 4, // image height, color, pick color, size in meters, valid aligned axis, 13 bits free\n  eyeOffset: 5, // 4 bytes free\n  scaleByDistance: 6,\n  pixelOffsetScaleByDistance: 7,\n  compressedAttribute3: 8,\n  textureCoordinateBoundsOrLabelTranslate: 9,\n  a_batchId: 10,\n  sdf: 11,\n  splitDirection: 12,\n};\n\nconst attributeLocationsInstanced = {\n  direction: 0,\n  positionHighAndScale: 1,\n  positionLowAndRotation: 2, // texture offset in w\n  compressedAttribute0: 3,\n  compressedAttribute1: 4,\n  compressedAttribute2: 5,\n  eyeOffset: 6, // texture range in w\n  scaleByDistance: 7,\n  pixelOffsetScaleByDistance: 8,\n  compressedAttribute3: 9,\n  textureCoordinateBoundsOrLabelTranslate: 10,\n  a_batchId: 11,\n  sdf: 12,\n  splitDirection: 13,\n};\n\n/**\n * A renderable collection of billboards.  Billboards are viewport-aligned\n * images positioned in the 3D scene.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.png' width='400' height='300' /><br />\n * Example billboards\n * </div>\n * <br /><br />\n * Billboards are added and removed from the collection using {@link BillboardCollection#add}\n * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures\n * for images with the same identifier.\n *\n * @alias BillboardCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each billboard from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for billboards that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The billboard blending option. The default\n * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the billboards in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many billboards, to\n * many collections with only a few billboards each.  Organize collections so that billboards\n * with the same update frequency are in the same collection, i.e., billboards that do not\n * change should be in one collection; billboards that change every frame should be in another\n * collection; and so on.\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n * @see Billboard\n * @see LabelCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}\n *\n * @example\n * // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });\n */\nfunction BillboardCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  this._textureAtlas = undefined;\n  this._textureAtlasGUID = undefined;\n  this._destroyTextureAtlas = true;\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = false;\n\n  this._shaderRotation = false;\n  this._compiledShaderRotation = false;\n\n  this._shaderAlignedAxis = false;\n  this._compiledShaderAlignedAxis = false;\n\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n\n  this._shaderPixelOffsetScaleByDistance = false;\n  this._compiledShaderPixelOffsetScaleByDistance = false;\n\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n\n  this._shaderClampToGround = false;\n  this._compiledShaderClampToGround = false;\n\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n\n  this._maxSize = 0.0;\n  this._maxEyeOffset = 0.0;\n  this._maxScale = 1.0;\n  this._maxPixelOffset = 0.0;\n  this._allHorizontalCenter = true;\n  this._allVerticalCenter = true;\n  this._allSizedInMeters = true;\n\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n\n  this._colorCommands = [];\n\n  /**\n   * Determines if billboards in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.\n   * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false,\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the texture atlas for this BillboardCollection as a fullscreen quad.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowTextureAtlas = defaultValue(\n    options.debugShowTextureAtlas,\n    false,\n  );\n\n  /**\n   * The billboard blending option. The default is used for rendering both opaque and translucent billboards.\n   * However, if either all of the billboards are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT,\n  );\n  this._blendOption = undefined;\n\n  this._mode = SceneMode.SCENE3D;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [\n    BufferUsage.STATIC_DRAW, // SHOW_INDEX\n    BufferUsage.STATIC_DRAW, // POSITION_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_INDEX\n    BufferUsage.STATIC_DRAW, // EYE_OFFSET_INDEX\n    BufferUsage.STATIC_DRAW, // HORIZONTAL_ORIGIN_INDEX\n    BufferUsage.STATIC_DRAW, // VERTICAL_ORIGIN_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_INDEX\n    BufferUsage.STATIC_DRAW, // IMAGE_INDEX_INDEX\n    BufferUsage.STATIC_DRAW, // COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // ROTATION_INDEX\n    BufferUsage.STATIC_DRAW, // ALIGNED_AXIS_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // DISTANCE_DISPLAY_CONDITION_INDEX\n    BufferUsage.STATIC_DRAW, // TEXTURE_COORDINATE_BOUNDS\n    BufferUsage.STATIC_DRAW, // SPLIT_DIRECTION_INDEX\n  ];\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  const that = this;\n  this._uniforms = {\n    u_atlas: function () {\n      return that._textureAtlas.texture;\n    },\n    u_highlightColor: function () {\n      return that._highlightColor;\n    },\n  };\n\n  const scene = this._scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._removeCallbackFunc = scene.terrainProviderChanged.addEventListener(\n      function () {\n        const billboards = this._billboards;\n        const length = billboards.length;\n        for (let i = 0; i < length; ++i) {\n          if (defined(billboards[i])) {\n            billboards[i]._updateClamping();\n          }\n        }\n      },\n      this,\n    );\n  }\n}\n\nObject.defineProperties(BillboardCollection.prototype, {\n  /**\n   * Returns the number of billboards in this collection.  This is commonly used with\n   * {@link BillboardCollection#get} to iterate over all the billboards\n   * in the collection.\n   * @memberof BillboardCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      removeBillboards(this);\n      return this._billboards.length;\n    },\n  },\n\n  /**\n   * Gets or sets the textureAtlas.\n   * @memberof BillboardCollection.prototype\n   * @type {TextureAtlas}\n   * @private\n   */\n  textureAtlas: {\n    get: function () {\n      return this._textureAtlas;\n    },\n    set: function (value) {\n      if (this._textureAtlas !== value) {\n        this._textureAtlas =\n          this._destroyTextureAtlas &&\n          this._textureAtlas &&\n          this._textureAtlas.destroy();\n        this._textureAtlas = value;\n        this._createVertexArray = true; // New per-billboard texture coordinates\n      }\n    },\n  },\n\n  /**\n   * Gets or sets a value which determines if the texture atlas is\n   * destroyed when the collection is destroyed.\n   *\n   * If the texture atlas is used by more than one collection, set this to <code>false</code>,\n   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.\n   *\n   * @memberof BillboardCollection.prototype\n   * @type {boolean}\n   * @private\n   *\n   * @example\n   * // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas({\n   *   scene : scene,\n   *   images : images\n   * });\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False\n   */\n  destroyTextureAtlas: {\n    get: function () {\n      return this._destroyTextureAtlas;\n    },\n    set: function (value) {\n      this._destroyTextureAtlas = value;\n    },\n  },\n});\n\nfunction destroyBillboards(billboards) {\n  const length = billboards.length;\n  for (let i = 0; i < length; ++i) {\n    if (billboards[i]) {\n      billboards[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a billboard with the specified initial properties to the collection.\n * The added billboard is returned so it can be modified or removed from the collection later.\n *\n * @param {Billboard.ConstructorOptions}[options] A template describing the billboard's properties as shown in Example 1.\n * @returns {Billboard} The billboard that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many billboards as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the billboard's cartographic position.\n * const b = billboards.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see BillboardCollection#remove\n * @see BillboardCollection#removeAll\n */\nBillboardCollection.prototype.add = function (options) {\n  const billboard = new Billboard(options, this);\n  billboard._index = this._billboards.length;\n\n  this._billboards.push(billboard);\n  this._createVertexArray = true;\n\n  return billboard;\n};\n\n/**\n * Removes a billboard from the collection.\n *\n * @param {Billboard} billboard The billboard to remove.\n * @returns {boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many billboards as possible before calling <code>update</code>.\n * If you intend to temporarily hide a billboard, it is usually more efficient to call\n * {@link Billboard#show} instead of removing and re-adding the billboard.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#removeAll\n * @see Billboard#show\n */\nBillboardCollection.prototype.remove = function (billboard) {\n  if (this.contains(billboard)) {\n    this._billboards[billboard._index] = undefined; // Removed later\n    this._billboardsRemoved = true;\n    this._createVertexArray = true;\n    billboard._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all billboards from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n */\nBillboardCollection.prototype.removeAll = function () {\n  destroyBillboards(this._billboards);\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n\n  this._createVertexArray = true;\n};\n\nfunction removeBillboards(billboardCollection) {\n  if (billboardCollection._billboardsRemoved) {\n    billboardCollection._billboardsRemoved = false;\n\n    const newBillboards = [];\n    const billboards = billboardCollection._billboards;\n    const length = billboards.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const billboard = billboards[i];\n      if (defined(billboard)) {\n        billboard._index = j++;\n        newBillboards.push(billboard);\n      }\n    }\n\n    billboardCollection._billboards = newBillboards;\n  }\n}\n\nBillboardCollection.prototype._updateBillboard = function (\n  billboard,\n  propertyChanged,\n) {\n  if (!billboard._dirty) {\n    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given billboard.\n *\n * @param {Billboard} [billboard] The billboard to check for.\n * @returns {boolean} true if this collection contains the billboard, false otherwise.\n *\n * @see BillboardCollection#get\n */\nBillboardCollection.prototype.contains = function (billboard) {\n  return defined(billboard) && billboard._billboardCollection === this;\n};\n\n/**\n * Returns the billboard in the collection at the specified index.  Indices are zero-based\n * and increase as billboards are added.  Removing a billboard shifts all billboards after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link BillboardCollection#length} to iterate over all the billboards\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n * @returns {Billboard} The billboard at the specified index.\n *\n * @performance Expected constant time.  If billboards were removed from the collection and\n * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n * @see BillboardCollection#length\n */\nBillboardCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  removeBillboards(this);\n  return this._billboards[index];\n};\n\nlet getIndexBuffer;\n\nfunction getIndexBufferBatched(context) {\n  const sixteenK = 16 * 1024;\n\n  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  // Subtract 6 because the last index is reserverd for primitive restart.\n  // https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.18\n  const length = sixteenK * 6 - 6;\n  const indices = new Uint16Array(length);\n  for (let i = 0, j = 0; i < length; i += 6, j += 4) {\n    indices[i] = j;\n    indices[i + 1] = j + 1;\n    indices[i + 2] = j + 2;\n\n    indices[i + 3] = j + 0;\n    indices[i + 4] = j + 2;\n    indices[i + 5] = j + 3;\n  }\n\n  // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?\n  // Is this too much memory to allocate up front?  Should we dynamically grow it?\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferBatched = indexBuffer;\n  return indexBuffer;\n}\n\nfunction getIndexBufferInstanced(context) {\n  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;\n  return indexBuffer;\n}\n\nfunction getVertexBufferInstanced(context) {\n  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;\n  if (defined(vertexBuffer)) {\n    return vertexBuffer;\n  }\n\n  vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]),\n    usage: BufferUsage.STATIC_DRAW,\n  });\n\n  vertexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;\n  return vertexBuffer;\n}\n\nBillboardCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage =\n      properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(\n  context,\n  numberOfBillboards,\n  buffersUsage,\n  instanced,\n  batchTable,\n  sdf,\n) {\n  const attributes = [\n    {\n      index: attributeLocations.positionHighAndScale,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[POSITION_INDEX],\n    },\n    {\n      index: attributeLocations.positionLowAndRotation,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[POSITION_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute0,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[PIXEL_OFFSET_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute1,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute2,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[COLOR_INDEX],\n    },\n    {\n      index: attributeLocations.eyeOffset,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[EYE_OFFSET_INDEX],\n    },\n    {\n      index: attributeLocations.scaleByDistance,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SCALE_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.pixelOffsetScaleByDistance,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute3,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX],\n    },\n    {\n      index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS],\n    },\n    {\n      index: attributeLocations.splitDirection,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SPLIT_DIRECTION_INDEX],\n    },\n  ];\n\n  // Instancing requires one non-instanced attribute.\n  if (instanced) {\n    attributes.push({\n      index: attributeLocations.direction,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      vertexBuffer: getVertexBufferInstanced(context),\n    });\n  }\n\n  if (defined(batchTable)) {\n    attributes.push({\n      index: attributeLocations.a_batchId,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  if (sdf) {\n    attributes.push({\n      index: attributeLocations.sdf,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SDF_INDEX],\n    });\n  }\n\n  // When instancing is enabled, only one vertex is needed for each billboard.\n  const sizeInVertices = instanced\n    ? numberOfBillboards\n    : 4 * numberOfBillboards;\n  return new VertexArrayFacade(context, attributes, sizeInVertices, instanced);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionScaleAndRotation(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const positionHighWriter =\n    vafWriters[attributeLocations.positionHighAndScale];\n  const positionLowWriter =\n    vafWriters[attributeLocations.positionLowAndRotation];\n  const position = billboard._getActualPosition();\n\n  if (billboardCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(\n      billboardCollection._baseVolume,\n      position,\n      billboardCollection._baseVolume,\n    );\n    billboardCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const scale = billboard.scale;\n  const rotation = billboard.rotation;\n\n  if (rotation !== 0.0) {\n    billboardCollection._shaderRotation = true;\n  }\n\n  billboardCollection._maxScale = Math.max(\n    billboardCollection._maxScale,\n    scale,\n  );\n\n  const high = writePositionScratch.high;\n  const low = writePositionScratch.low;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    positionHighWriter(i, high.x, high.y, high.z, scale);\n    positionLowWriter(i, low.x, low.y, low.z, rotation);\n  } else {\n    i = billboard._index * 4;\n    positionHighWriter(i + 0, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 1, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 2, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 3, high.x, high.y, high.z, scale);\n\n    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);\n  }\n}\n\nconst scratchCartesian2 = new Cartesian2();\n\nconst UPPER_BOUND = 32768.0; // 2^15\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT12 = 4096.0; // 2^12\nconst LEFT_SHIFT8 = 256.0; // 2^8\nconst LEFT_SHIFT7 = 128.0;\nconst LEFT_SHIFT5 = 32.0;\nconst LEFT_SHIFT3 = 8.0;\nconst LEFT_SHIFT2 = 4.0;\n\nconst RIGHT_SHIFT8 = 1.0 / 256.0;\n\nconst LOWER_LEFT = 0.0;\nconst LOWER_RIGHT = 2.0;\nconst UPPER_RIGHT = 3.0;\nconst UPPER_LEFT = 1.0;\n\nfunction writeCompressedAttrib0(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  const pixelOffset = billboard.pixelOffset;\n  const pixelOffsetX = pixelOffset.x;\n  const pixelOffsetY = pixelOffset.y;\n\n  const translate = billboard._translate;\n  const translateX = translate.x;\n  const translateY = translate.y;\n\n  billboardCollection._maxPixelOffset = Math.max(\n    billboardCollection._maxPixelOffset,\n    Math.abs(pixelOffsetX + translateX),\n    Math.abs(-pixelOffsetY + translateY),\n  );\n\n  const horizontalOrigin = billboard.horizontalOrigin;\n  let verticalOrigin = billboard._verticalOrigin;\n  let show = billboard.show && billboard.clusterShow;\n\n  // If the color alpha is zero, do not show this billboard.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (billboard.color.alpha === 0.0) {\n    show = false;\n  }\n\n  // Raw billboards don't distinguish between BASELINE and BOTTOM, only LabelCollection does that.\n  if (verticalOrigin === VerticalOrigin.BASELINE) {\n    verticalOrigin = VerticalOrigin.BOTTOM;\n  }\n\n  billboardCollection._allHorizontalCenter =\n    billboardCollection._allHorizontalCenter &&\n    horizontalOrigin === HorizontalOrigin.CENTER;\n  billboardCollection._allVerticalCenter =\n    billboardCollection._allVerticalCenter &&\n    verticalOrigin === VerticalOrigin.CENTER;\n\n  let bottomLeftX = 0;\n  let bottomLeftY = 0;\n  let width = 0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    bottomLeftX = imageRectangle.x;\n    bottomLeftY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const topRightX = bottomLeftX + width;\n  const topRightY = bottomLeftY + height;\n\n  let compressed0 =\n    Math.floor(\n      CesiumMath.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND,\n    ) * LEFT_SHIFT7;\n  compressed0 += (horizontalOrigin + 1.0) * LEFT_SHIFT5;\n  compressed0 += (verticalOrigin + 1.0) * LEFT_SHIFT3;\n  compressed0 += (show ? 1.0 : 0.0) * LEFT_SHIFT2;\n\n  let compressed1 =\n    Math.floor(\n      CesiumMath.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND,\n    ) * LEFT_SHIFT8;\n  let compressed2 =\n    Math.floor(\n      CesiumMath.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND,\n    ) * LEFT_SHIFT8;\n\n  const tempTanslateY =\n    (CesiumMath.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) *\n    RIGHT_SHIFT8;\n  const upperTranslateY = Math.floor(tempTanslateY);\n  const lowerTranslateY = Math.floor(\n    (tempTanslateY - upperTranslateY) * LEFT_SHIFT8,\n  );\n\n  compressed1 += upperTranslateY;\n  compressed2 += lowerTranslateY;\n\n  scratchCartesian2.x = bottomLeftX;\n  scratchCartesian2.y = bottomLeftY;\n  const compressedTexCoordsLL =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = topRightX;\n  const compressedTexCoordsLR =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.y = topRightY;\n  const compressedTexCoordsUR =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = bottomLeftX;\n  const compressedTexCoordsUL =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);\n  } else {\n    i = billboard._index * 4;\n    writer(\n      i + 0,\n      compressed0 + LOWER_LEFT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsLL,\n    );\n    writer(\n      i + 1,\n      compressed0 + LOWER_RIGHT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsLR,\n    );\n    writer(\n      i + 2,\n      compressed0 + UPPER_RIGHT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsUR,\n    );\n    writer(\n      i + 3,\n      compressed0 + UPPER_LEFT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsUL,\n    );\n  }\n}\n\nfunction writeCompressedAttrib1(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  const alignedAxis = billboard.alignedAxis;\n  if (!Cartesian3.equals(alignedAxis, Cartesian3.ZERO)) {\n    billboardCollection._shaderAlignedAxis = true;\n  }\n\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const translucency = billboard.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  let width = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    width = imageRectangle.width;\n  }\n\n  const textureWidth = billboardCollection._textureAtlas.texture.width;\n  const imageWidth = Math.round(\n    defaultValue(billboard.width, textureWidth * width),\n  );\n  billboardCollection._maxSize = Math.max(\n    billboardCollection._maxSize,\n    imageWidth,\n  );\n\n  let compressed0 = CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT16);\n  let compressed1 = 0.0;\n\n  if (\n    Math.abs(Cartesian3.magnitudeSquared(alignedAxis) - 1.0) <\n    CesiumMath.EPSILON6\n  ) {\n    compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : (nearValue * 255.0) | 0;\n  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;\n\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : (farValue * 255.0) | 0;\n  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, near, far);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, near, far);\n    writer(i + 1, compressed0, compressed1, near, far);\n    writer(i + 2, compressed0, compressed1, near, far);\n    writer(i + 3, compressed0, compressed1, near, far);\n  }\n}\n\nfunction writeCompressedAttrib2(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute2];\n  const color = billboard.color;\n  const pickColor = !defined(billboardCollection._batchTable)\n    ? billboard.getPickId(frameState.context).color\n    : Color.WHITE;\n  const sizeInMeters = billboard.sizeInMeters ? 1.0 : 0.0;\n  const validAlignedAxis =\n    Math.abs(Cartesian3.magnitudeSquared(billboard.alignedAxis) - 1.0) <\n    CesiumMath.EPSILON6\n      ? 1.0\n      : 0.0;\n\n  billboardCollection._allSizedInMeters =\n    billboardCollection._allSizedInMeters && sizeInMeters === 1.0;\n\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    height = imageRectangle.height;\n  }\n\n  const dimensions = billboardCollection._textureAtlas.texture.dimensions;\n  const imageHeight = Math.round(\n    defaultValue(billboard.height, dimensions.y * height),\n  );\n  billboardCollection._maxSize = Math.max(\n    billboardCollection._maxSize,\n    imageHeight,\n  );\n  let labelHorizontalOrigin = defaultValue(\n    billboard._labelHorizontalOrigin,\n    -2,\n  );\n  labelHorizontalOrigin += 2;\n  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;\n\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  let compressed2 =\n    Color.floatToByte(color.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(pickColor.alpha) * LEFT_SHIFT8;\n  compressed2 += sizeInMeters * 2.0 + validAlignedAxis;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressed3);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 1, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 2, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 3, compressed0, compressed1, compressed2, compressed3);\n  }\n}\n\nfunction writeEyeOffset(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.eyeOffset];\n  const eyeOffset = billboard.eyeOffset;\n\n  // For billboards that are clamped to ground, move it slightly closer to the camera\n  let eyeOffsetZ = eyeOffset.z;\n  if (billboard._heightReference !== HeightReference.NONE) {\n    eyeOffsetZ *= 1.005;\n  }\n  billboardCollection._maxEyeOffset = Math.max(\n    billboardCollection._maxEyeOffset,\n    Math.abs(eyeOffset.x),\n    Math.abs(eyeOffset.y),\n    Math.abs(eyeOffsetZ),\n  );\n\n  if (billboardCollection._instanced) {\n    let width = 0;\n    let height = 0;\n    const index = billboard._imageIndex;\n    if (index !== -1) {\n      const imageRectangle = textureAtlasCoordinates[index];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(imageRectangle)) {\n        throw new DeveloperError(`Invalid billboard image index: ${index}`);\n      }\n      //>>includeEnd('debug');\n\n      width = imageRectangle.width;\n      height = imageRectangle.height;\n    }\n\n    scratchCartesian2.x = width;\n    scratchCartesian2.y = height;\n    const compressedTexCoordsRange =\n      AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n\n    i = billboard._index;\n    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n  }\n}\n\nfunction writeScaleByDistance(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const scale = billboard.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\n\nfunction writePixelOffsetScaleByDistance(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;\n  if (defined(pixelOffsetScale)) {\n    near = pixelOffsetScale.near;\n    nearValue = pixelOffsetScale.nearValue;\n    far = pixelOffsetScale.far;\n    farValue = pixelOffsetScale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // pixelOffsetScale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderPixelOffsetScaleByDistance = true;\n    }\n  }\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\n\nfunction writeCompressedAttribute3(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute3];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n\n  const distanceDisplayCondition = billboard.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n\n    near *= near;\n    far *= far;\n\n    billboardCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  let disableDepthTestDistance = billboard.disableDepthTestDistance;\n  const clampToGround =\n    isHeightReferenceClamp(billboard.heightReference) &&\n    frameState.context.depthTexture;\n  if (!defined(disableDepthTestDistance)) {\n    disableDepthTestDistance = clampToGround ? 5000.0 : 0.0;\n  }\n\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (clampToGround || disableDepthTestDistance > 0.0) {\n    billboardCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  let imageHeight;\n  let imageWidth;\n\n  if (!defined(billboard._labelDimensions)) {\n    let height = 0;\n    let width = 0;\n    const index = billboard._imageIndex;\n    if (index !== -1) {\n      const imageRectangle = textureAtlasCoordinates[index];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(imageRectangle)) {\n        throw new DeveloperError(`Invalid billboard image index: ${index}`);\n      }\n      //>>includeEnd('debug');\n\n      height = imageRectangle.height;\n      width = imageRectangle.width;\n    }\n\n    imageHeight = Math.round(\n      defaultValue(\n        billboard.height,\n        billboardCollection._textureAtlas.texture.dimensions.y * height,\n      ),\n    );\n\n    const textureWidth = billboardCollection._textureAtlas.texture.width;\n    imageWidth = Math.round(\n      defaultValue(billboard.width, textureWidth * width),\n    );\n  } else {\n    imageWidth = billboard._labelDimensions.x;\n    imageHeight = billboard._labelDimensions.y;\n  }\n\n  const w = Math.floor(CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT12));\n  const h = Math.floor(CesiumMath.clamp(imageHeight, 0.0, LEFT_SHIFT12));\n  const dimensions = w * LEFT_SHIFT12 + h;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, far, disableDepthTestDistance, dimensions);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 1, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 2, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 3, near, far, disableDepthTestDistance, dimensions);\n  }\n}\n\nfunction writeTextureCoordinateBoundsOrLabelTranslate(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  if (isHeightReferenceClamp(billboard.heightReference)) {\n    const scene = billboardCollection._scene;\n    const context = frameState.context;\n    const globeTranslucent = frameState.globeTranslucencyState.translucent;\n    const depthTestAgainstTerrain =\n      defined(scene.globe) && scene.globe.depthTestAgainstTerrain;\n\n    // Only do manual depth test if the globe is opaque and writes depth\n    billboardCollection._shaderClampToGround =\n      context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;\n  }\n  let i;\n  const writer =\n    vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];\n\n  if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n    //write _labelTranslate, used by depth testing in the vertex shader\n    let translateX = 0;\n    let translateY = 0;\n    if (defined(billboard._labelTranslate)) {\n      translateX = billboard._labelTranslate.x;\n      translateY = billboard._labelTranslate.y;\n    }\n    if (billboardCollection._instanced) {\n      i = billboard._index;\n      writer(i, translateX, translateY, 0.0, 0.0);\n    } else {\n      i = billboard._index * 4;\n      writer(i + 0, translateX, translateY, 0.0, 0.0);\n      writer(i + 1, translateX, translateY, 0.0, 0.0);\n      writer(i + 2, translateX, translateY, 0.0, 0.0);\n      writer(i + 3, translateX, translateY, 0.0, 0.0);\n    }\n    return;\n  }\n\n  //write texture coordinate bounds, used by depth testing in fragment shader\n  let minX = 0;\n  let minY = 0;\n  let width = 0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    minX = imageRectangle.x;\n    minY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const maxX = minX + width;\n  const maxY = minY + height;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, minX, minY, maxX, maxY);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, minX, minY, maxX, maxY);\n    writer(i + 1, minX, minY, maxX, maxY);\n    writer(i + 2, minX, minY, maxX, maxY);\n    writer(i + 3, minX, minY, maxX, maxY);\n  }\n}\n\nfunction writeBatchId(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  if (!defined(billboardCollection._batchTable)) {\n    return;\n  }\n\n  const writer = vafWriters[attributeLocations.a_batchId];\n  const id = billboard._batchIndex;\n\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, id);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, id);\n    writer(i + 1, id);\n    writer(i + 2, id);\n    writer(i + 3, id);\n  }\n}\n\nfunction writeSDF(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  if (!billboardCollection._sdf) {\n    return;\n  }\n\n  let i;\n  const writer = vafWriters[attributeLocations.sdf];\n\n  const outlineColor = billboard.outlineColor;\n  const outlineWidth = billboard.outlineWidth;\n\n  const red = Color.floatToByte(outlineColor.red);\n  const green = Color.floatToByte(outlineColor.green);\n  const blue = Color.floatToByte(outlineColor.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  // Compute the relative outline distance\n  const outlineDistance = outlineWidth / SDFSettings.RADIUS;\n  const compressed1 =\n    Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(outlineDistance) * LEFT_SHIFT8;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);\n  }\n}\n\nfunction writeSplitDirection(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  const writer = vafWriters[attributeLocations.splitDirection];\n  let direction = 0.0;\n\n  const split = billboard.splitDirection;\n  if (defined(split)) {\n    direction = split;\n  }\n\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, direction);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, direction);\n    writer(i + 1, direction);\n    writer(i + 2, direction);\n    writer(i + 3, direction);\n  }\n}\n\nfunction writeBillboard(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard,\n) {\n  writePositionScaleAndRotation(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttrib0(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttrib1(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttrib2(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeEyeOffset(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeScaleByDistance(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writePixelOffsetScaleByDistance(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttribute3(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeTextureCoordinateBoundsOrLabelTranslate(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeBatchId(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeSDF(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n  writeSplitDirection(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard,\n  );\n}\n\nfunction recomputeActualPositions(\n  billboardCollection,\n  billboards,\n  length,\n  frameState,\n  modelMatrix,\n  recomputeBoundingVolume,\n) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = billboardCollection._baseVolume;\n    billboardCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = billboardCollection._baseVolume2D;\n  }\n\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const billboard = billboards[i];\n    const position = billboard.position;\n    const actualPosition = Billboard._computeActualPosition(\n      billboard,\n      position,\n      frameState,\n      modelMatrix,\n    );\n    if (defined(actualPosition)) {\n      billboard._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(billboardCollection, frameState) {\n  const mode = frameState.mode;\n\n  const billboards = billboardCollection._billboards;\n  const billboardsToUpdate = billboardCollection._billboardsToUpdate;\n  const modelMatrix = billboardCollection._modelMatrix;\n\n  if (\n    billboardCollection._createVertexArray ||\n    billboardCollection._mode !== mode ||\n    (mode !== SceneMode.SCENE3D &&\n      !Matrix4.equals(modelMatrix, billboardCollection.modelMatrix))\n  ) {\n    billboardCollection._mode = mode;\n    Matrix4.clone(billboardCollection.modelMatrix, modelMatrix);\n    billboardCollection._createVertexArray = true;\n\n    if (\n      mode === SceneMode.SCENE3D ||\n      mode === SceneMode.SCENE2D ||\n      mode === SceneMode.COLUMBUS_VIEW\n    ) {\n      recomputeActualPositions(\n        billboardCollection,\n        billboards,\n        billboards.length,\n        frameState,\n        modelMatrix,\n        true,\n      );\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(\n      billboardCollection,\n      billboards,\n      billboards.length,\n      frameState,\n      modelMatrix,\n      true,\n    );\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(\n      billboardCollection,\n      billboardsToUpdate,\n      billboardCollection._billboardsToUpdateIndex,\n      frameState,\n      modelMatrix,\n      false,\n    );\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  let pixelScale = 1.0;\n  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0.0) {\n    pixelScale = frameState.camera.getPixelSize(\n      boundingVolume,\n      frameState.context.drawingBufferWidth,\n      frameState.context.drawingBufferHeight,\n    );\n  }\n\n  let size = pixelScale * collection._maxScale * collection._maxSize * 2.0;\n  if (collection._allHorizontalCenter && collection._allVerticalCenter) {\n    size *= 0.5;\n  }\n\n  const offset =\n    pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;\n  boundingVolume.radius += size + offset;\n}\n\nfunction createDebugCommand(billboardCollection, context) {\n  const fs =\n    \"uniform sampler2D billboard_texture; \\n\" +\n    \"in vec2 v_textureCoordinates; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    out_FragColor = texture(billboard_texture, v_textureCoordinates); \\n\" +\n    \"} \\n\";\n\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      billboard_texture: function () {\n        return billboardCollection._textureAtlas.texture;\n      },\n    },\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nconst scratchWriterArray = [];\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} image with id must be in the atlas.\n */\nBillboardCollection.prototype.update = function (frameState) {\n  removeBillboards(this);\n\n  if (!this.show) {\n    return;\n  }\n\n  let billboards = this._billboards;\n  let billboardsLength = billboards.length;\n\n  const context = frameState.context;\n  this._instanced = context.instancedArrays;\n  attributeLocations = this._instanced\n    ? attributeLocationsInstanced\n    : attributeLocationsBatched;\n  getIndexBuffer = this._instanced\n    ? getIndexBufferInstanced\n    : getIndexBufferBatched;\n\n  let textureAtlas = this._textureAtlas;\n  if (!defined(textureAtlas)) {\n    textureAtlas = this._textureAtlas = new TextureAtlas({\n      context: context,\n    });\n\n    for (let ii = 0; ii < billboardsLength; ++ii) {\n      billboards[ii]._loadImage();\n    }\n  }\n\n  const textureAtlasCoordinates = textureAtlas.textureCoordinates;\n  if (textureAtlasCoordinates.length === 0) {\n    // Can't write billboard vertices until we have texture coordinates\n    // provided by a texture atlas\n    return;\n  }\n\n  updateMode(this, frameState);\n\n  billboards = this._billboards;\n  billboardsLength = billboards.length;\n  const billboardsToUpdate = this._billboardsToUpdate;\n  const billboardsToUpdateLength = this._billboardsToUpdateIndex;\n\n  const properties = this._propertiesChanged;\n\n  const textureAtlasGUID = textureAtlas.guid;\n  const createVertexArray =\n    this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;\n  this._textureAtlasGUID = textureAtlasGUID;\n\n  let vafWriters;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || (!picking && this.computeNewBuffersUsage())) {\n    this._createVertexArray = false;\n\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (billboardsLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(\n        context,\n        billboardsLength,\n        this._buffersUsage,\n        this._instanced,\n        this._batchTable,\n        this._sdf,\n      );\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if billboards were added or removed.\n      for (let i = 0; i < billboardsLength; ++i) {\n        const billboard = this._billboards[i];\n        billboard._dirty = false; // In case it needed an update.\n        writeBillboard(\n          this,\n          frameState,\n          textureAtlasCoordinates,\n          vafWriters,\n          billboard,\n        );\n      }\n\n      // Different billboard collections share the same index buffer.\n      this._vaf.commit(getIndexBuffer(context));\n    }\n\n    this._billboardsToUpdateIndex = 0;\n  } else if (billboardsToUpdateLength > 0) {\n    // Billboards were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (\n      properties[POSITION_INDEX] ||\n      properties[ROTATION_INDEX] ||\n      properties[SCALE_INDEX]\n    ) {\n      writers.push(writePositionScaleAndRotation);\n    }\n\n    if (\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[PIXEL_OFFSET_INDEX] ||\n      properties[HORIZONTAL_ORIGIN_INDEX] ||\n      properties[VERTICAL_ORIGIN_INDEX] ||\n      properties[SHOW_INDEX]\n    ) {\n      writers.push(writeCompressedAttrib0);\n      if (this._instanced) {\n        writers.push(writeEyeOffset);\n      }\n    }\n\n    if (\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[ALIGNED_AXIS_INDEX] ||\n      properties[TRANSLUCENCY_BY_DISTANCE_INDEX]\n    ) {\n      writers.push(writeCompressedAttrib1);\n      writers.push(writeCompressedAttrib2);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib2);\n    }\n\n    if (properties[EYE_OFFSET_INDEX]) {\n      writers.push(writeEyeOffset);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writePixelOffsetScaleByDistance);\n    }\n\n    if (\n      properties[DISTANCE_DISPLAY_CONDITION_INDEX] ||\n      properties[DISABLE_DEPTH_DISTANCE] ||\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[POSITION_INDEX]\n    ) {\n      writers.push(writeCompressedAttribute3);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);\n    }\n\n    if (properties[SDF_INDEX]) {\n      writers.push(writeSDF);\n    }\n\n    if (properties[SPLIT_DIRECTION_INDEX]) {\n      writers.push(writeSplitDirection);\n    }\n\n    const numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n\n    if (billboardsToUpdateLength / billboardsLength > 0.1) {\n      // If more than 10% of billboard change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < billboardsToUpdateLength; ++m) {\n        const b = billboardsToUpdate[m];\n        b._dirty = false;\n\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, frameState, textureAtlasCoordinates, vafWriters, b);\n        }\n      }\n      this._vaf.commit(getIndexBuffer(context));\n    } else {\n      for (let h = 0; h < billboardsToUpdateLength; ++h) {\n        const bb = billboardsToUpdate[h];\n        bb._dirty = false;\n\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, frameState, textureAtlasCoordinates, vafWriters, bb);\n        }\n\n        if (this._instanced) {\n          this._vaf.subCommit(bb._index, 1);\n        } else {\n          this._vaf.subCommit(bb._index * 4, 4);\n        }\n      }\n      this._vaf.endSubCommits();\n    }\n\n    this._billboardsToUpdateIndex = 0;\n  }\n\n  // If the number of total billboards ever shrinks considerably\n  // Truncate billboardsToUpdate so that we free memory that we're\n  // not going to be using.\n  if (billboardsToUpdateLength > billboardsLength * 1.5) {\n    billboardsToUpdate.length = billboardsLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(\n      this._baseVolume,\n      this.modelMatrix,\n      this._baseVolumeWC,\n    );\n  }\n\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolumeWC,\n      this._boundingVolume,\n    );\n  } else {\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolume2D,\n      this._boundingVolume,\n    );\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (\n      this._blendOption === BlendOption.OPAQUE ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LESS,\n        },\n        depthMask: true,\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    // If OPAQUE_AND_TRANSLUCENT is in use, only the opaque pass gets the benefit of the depth buffer,\n    // not the translucent pass.  Otherwise, if the TRANSLUCENT pass is on its own, it turns on\n    // a depthMask in lieu of full depth sorting (because it has opaque-ish fragments that look bad in OIT).\n    // When the TRANSLUCENT depth mask is in use, label backgrounds require the depth func to be LEQUAL.\n    const useTranslucentDepthMask =\n      this._blendOption === BlendOption.TRANSLUCENT;\n\n    if (\n      this._blendOption === BlendOption.TRANSLUCENT ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: useTranslucentDepthMask\n            ? WebGLConstants.LEQUAL\n            : WebGLConstants.LESS,\n        },\n        depthMask: useTranslucentDepthMask,\n        blending: BlendingState.ALPHA_BLEND,\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance =\n    this._shaderDisableDepthDistance ||\n    frameState.minimumDisableDepthTestDistance !== 0.0;\n\n  let vsSource;\n  let fsSource;\n  let vs;\n  let fs;\n  let vertDefines;\n\n  const supportVSTextureReads =\n    ContextLimits.maximumVertexTextureImageUnits > 0;\n\n  if (\n    blendOptionChanged ||\n    this._shaderRotation !== this._compiledShaderRotation ||\n    this._shaderAlignedAxis !== this._compiledShaderAlignedAxis ||\n    this._shaderScaleByDistance !== this._compiledShaderScaleByDistance ||\n    this._shaderTranslucencyByDistance !==\n      this._compiledShaderTranslucencyByDistance ||\n    this._shaderPixelOffsetScaleByDistance !==\n      this._compiledShaderPixelOffsetScaleByDistance ||\n    this._shaderDistanceDisplayCondition !==\n      this._compiledShaderDistanceDisplayCondition ||\n    this._shaderDisableDepthDistance !==\n      this._compiledShaderDisableDepthDistance ||\n    this._shaderClampToGround !== this._compiledShaderClampToGround ||\n    this._sdf !== this._compiledSDF\n  ) {\n    vsSource = BillboardCollectionVS;\n    fsSource = BillboardCollectionFS;\n\n    vertDefines = [];\n    if (defined(this._batchTable)) {\n      vertDefines.push(\"VECTOR_TILE\");\n      vsSource = this._batchTable.getVertexShaderCallback(\n        false,\n        \"a_batchId\",\n        undefined,\n      )(vsSource);\n      fsSource = this._batchTable.getFragmentShaderCallback(\n        false,\n        undefined,\n      )(fsSource);\n    }\n\n    vs = new ShaderSource({\n      defines: vertDefines,\n      sources: [vsSource],\n    });\n    if (this._instanced) {\n      vs.defines.push(\"INSTANCED\");\n    }\n    if (this._shaderRotation) {\n      vs.defines.push(\"ROTATION\");\n    }\n    if (this._shaderAlignedAxis) {\n      vs.defines.push(\"ALIGNED_AXIS\");\n    }\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderPixelOffsetScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_PIXEL_OFFSET\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n    if (this._shaderClampToGround) {\n      if (supportVSTextureReads) {\n        vs.defines.push(\"VERTEX_DEPTH_CHECK\");\n      } else {\n        vs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n      }\n    }\n\n    const sdfEdge = 1.0 - SDFSettings.CUTOFF;\n\n    if (this._sdf) {\n      vs.defines.push(\"SDF\");\n    }\n\n    const vectorFragDefine = defined(this._batchTable) ? \"VECTOR_TILE\" : \"\";\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\", vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\", vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    this._compiledShaderRotation = this._shaderRotation;\n    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance =\n      this._shaderTranslucencyByDistance;\n    this._compiledShaderPixelOffsetScaleByDistance =\n      this._shaderPixelOffsetScaleByDistance;\n    this._compiledShaderDistanceDisplayCondition =\n      this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n    this._compiledShaderClampToGround = this._shaderClampToGround;\n    this._compiledSDF = this._sdf;\n  }\n\n  const commandList = frameState.commandList;\n\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent =\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n\n    const va = this._vaf.va;\n    const vaLength = va.length;\n\n    let uniforms = this._uniforms;\n    let pickId;\n    if (defined(this._batchTable)) {\n      uniforms = this._batchTable.getUniformMapCallback()(uniforms);\n      pickId = this._batchTable.getPickId();\n    } else {\n      pickId = \"v_pickColor\";\n    }\n\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (let j = 0; j < totalLength; ++j) {\n      let command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      const opaqueCommand = opaque || (opaqueAndTranslucent && j % 2 === 0);\n\n      command.pass =\n        opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.count = va[index].indicesCount;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand\n        ? this._rsOpaque\n        : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = pickId;\n\n      if (this._instanced) {\n        command.count = 6;\n        command.instanceCount = billboardsLength;\n      }\n\n      commandList.push(command);\n    }\n\n    if (this.debugShowTextureAtlas) {\n      if (!defined(this.debugCommand)) {\n        this.debugCommand = createDebugCommand(this, frameState.context);\n      }\n\n      commandList.push(this.debugCommand);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BillboardCollection#destroy\n */\nBillboardCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards = billboards && billboards.destroy();\n *\n * @see BillboardCollection#isDestroyed\n */\nBillboardCollection.prototype.destroy = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n    this._removeCallbackFunc = undefined;\n  }\n\n  this._textureAtlas =\n    this._destroyTextureAtlas &&\n    this._textureAtlas &&\n    this._textureAtlas.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyBillboards(this._billboards);\n\n  return destroyObject(this);\n};\nexport default BillboardCollection;\n"],"mappings":"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AAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC5E,aAAa;IAC3B,CAAC;IACD+E,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MACpB,IAAI,IAAI,CAAChF,aAAa,KAAKgF,KAAK,EAAE;QAChC,IAAI,CAAChF,aAAa,GAChB,IAAI,CAACG,oBAAoB,IACzB,IAAI,CAACH,aAAa,IAClB,IAAI,CAACA,aAAa,CAACiF,OAAO,CAAC,CAAC;QAC9B,IAAI,CAACjF,aAAa,GAAGgF,KAAK;QAC1B,IAAI,CAACnE,kBAAkB,GAAG,IAAI,CAAC,CAAC;MAClC;IACF;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEqE,mBAAmB,EAAE;IACnBN,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACzE,oBAAoB;IAClC,CAAC;IACD4E,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MACpB,IAAI,CAAC7E,oBAAoB,GAAG6E,KAAK;IACnC;EACF;AACF,CAAC,CAAC;AAEF,SAASG,iBAAiBA,CAACd,UAAU,EAAE;EACrC,MAAMC,MAAM,GAAGD,UAAU,CAACC,MAAM;EAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAE,EAAEC,CAAC,EAAE;IAC/B,IAAIF,UAAU,CAACE,CAAC,CAAC,EAAE;MACjBF,UAAU,CAACE,CAAC,CAAC,CAACa,QAAQ,CAAC,CAAC;IAC1B;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA3F,mBAAmB,CAACkF,SAAS,CAACU,GAAG,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}