{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * Synchronizes a video element with a simulation clock.\n *\n * @alias VideoSynchronizer\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Clock} [options.clock] The clock instance used to drive the video.\n * @param {HTMLVideoElement} [options.element] The video element to be synchronized.\n * @param {JulianDate} [options.epoch=Iso8601.MINIMUM_VALUE] The simulation time that marks the start of the video.\n * @param {number} [options.tolerance=1.0] The maximum amount of time, in seconds, that the clock and video can diverge.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Video.html|Video Material Demo}\n */\nfunction VideoSynchronizer(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._clock = undefined;\n  this._element = undefined;\n  this._clockSubscription = undefined;\n  this._seekFunction = undefined;\n  this._lastPlaybackRate = undefined;\n  this.clock = options.clock;\n  this.element = options.element;\n\n  /**\n   * Gets or sets the simulation time that marks the start of the video.\n   * @type {JulianDate}\n   * @default Iso8601.MINIMUM_VALUE\n   */\n  this.epoch = defaultValue(options.epoch, Iso8601.MINIMUM_VALUE);\n\n  /**\n   * Gets or sets the amount of time in seconds the video's currentTime\n   * and the clock's currentTime can diverge before a video seek is performed.\n   * Lower values make the synchronization more accurate but video\n   * performance might suffer.  Higher values provide better performance\n   * but at the cost of accuracy.\n   * @type {number}\n   * @default 1.0\n   */\n  this.tolerance = defaultValue(options.tolerance, 1.0);\n  this._seeking = false;\n  this._seekFunction = undefined;\n  this._firstTickAfterSeek = false;\n}\nObject.defineProperties(VideoSynchronizer.prototype, {\n  /**\n   * Gets or sets the clock used to drive the video element.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      const oldValue = this._clock;\n      if (oldValue === value) {\n        return;\n      }\n      if (defined(oldValue)) {\n        this._clockSubscription();\n        this._clockSubscription = undefined;\n      }\n      if (defined(value)) {\n        this._clockSubscription = value.onTick.addEventListener(VideoSynchronizer.prototype._onTick, this);\n      }\n      this._clock = value;\n    }\n  },\n  /**\n   * Gets or sets the video element to synchronize.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {HTMLVideoElement}\n   */\n  element: {\n    get: function () {\n      return this._element;\n    },\n    set: function (value) {\n      const oldValue = this._element;\n      if (oldValue === value) {\n        return;\n      }\n      if (defined(oldValue)) {\n        oldValue.removeEventListener(\"seeked\", this._seekFunction, false);\n      }\n      if (defined(value)) {\n        this._seeking = false;\n        this._seekFunction = createSeekFunction(this);\n        value.addEventListener(\"seeked\", this._seekFunction, false);\n      }\n      this._element = value;\n      this._seeking = false;\n      this._firstTickAfterSeek = false;\n    }\n  }\n});\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVideoSynchronizer.prototype.destroy = function () {\n  this.element = undefined;\n  this.clock = undefined;\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nVideoSynchronizer.prototype.isDestroyed = function () {\n  return false;\n};\nVideoSynchronizer.prototype._trySetPlaybackRate = function (clock) {\n  if (this._lastPlaybackRate === clock.multiplier) {\n    return;\n  }\n  const element = this._element;\n  try {\n    element.playbackRate = clock.multiplier;\n  } catch (error) {\n    // Seek manually for unsupported playbackRates.\n    element.playbackRate = 0.0;\n  }\n  this._lastPlaybackRate = clock.multiplier;\n};\nVideoSynchronizer.prototype._onTick = function (clock) {\n  const element = this._element;\n  if (!defined(element) || element.readyState < 2) {\n    return;\n  }\n  const paused = element.paused;\n  const shouldAnimate = clock.shouldAnimate;\n  if (shouldAnimate === paused) {\n    if (shouldAnimate) {\n      element.play();\n    } else {\n      element.pause();\n    }\n  }\n\n  //We need to avoid constant seeking or the video will\n  //never contain a complete frame for us to render.\n  //So don't do anything if we're seeing or on the first\n  //tick after a seek (the latter of which allows the frame\n  //to actually be rendered.\n  if (this._seeking || this._firstTickAfterSeek) {\n    this._firstTickAfterSeek = false;\n    return;\n  }\n  this._trySetPlaybackRate(clock);\n  const clockTime = clock.currentTime;\n  const epoch = defaultValue(this.epoch, Iso8601.MINIMUM_VALUE);\n  let videoTime = JulianDate.secondsDifference(clockTime, epoch);\n  const duration = element.duration;\n  let desiredTime;\n  const currentTime = element.currentTime;\n  if (element.loop) {\n    videoTime = videoTime % duration;\n    if (videoTime < 0.0) {\n      videoTime = duration - videoTime;\n    }\n    desiredTime = videoTime;\n  } else if (videoTime > duration) {\n    desiredTime = duration;\n  } else if (videoTime < 0.0) {\n    desiredTime = 0.0;\n  } else {\n    desiredTime = videoTime;\n  }\n\n  //If the playing video's time and the scene's clock time\n  //ever drift too far apart, we want to set the video to match\n  const tolerance = shouldAnimate ? defaultValue(this.tolerance, 1.0) : 0.001;\n  if (Math.abs(desiredTime - currentTime) > tolerance) {\n    this._seeking = true;\n    element.currentTime = desiredTime;\n  }\n};\nfunction createSeekFunction(that) {\n  return function () {\n    that._seeking = false;\n    that._firstTickAfterSeek = true;\n  };\n}\nexport default VideoSynchronizer;","map":{"version":3,"names":["defaultValue","defined","destroyObject","Iso8601","JulianDate","VideoSynchronizer","options","EMPTY_OBJECT","_clock","undefined","_element","_clockSubscription","_seekFunction","_lastPlaybackRate","clock","element","epoch","MINIMUM_VALUE","tolerance","_seeking","_firstTickAfterSeek","Object","defineProperties","prototype","get","set","value","oldValue","onTick","addEventListener","_onTick","removeEventListener","createSeekFunction","destroy","isDestroyed","_trySetPlaybackRate","multiplier","playbackRate","error","readyState","paused","shouldAnimate","play","pause","clockTime","currentTime","videoTime","secondsDifference","duration","desiredTime","loop","Math","abs","that"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/VideoSynchronizer.js"],"sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * Synchronizes a video element with a simulation clock.\n *\n * @alias VideoSynchronizer\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Clock} [options.clock] The clock instance used to drive the video.\n * @param {HTMLVideoElement} [options.element] The video element to be synchronized.\n * @param {JulianDate} [options.epoch=Iso8601.MINIMUM_VALUE] The simulation time that marks the start of the video.\n * @param {number} [options.tolerance=1.0] The maximum amount of time, in seconds, that the clock and video can diverge.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Video.html|Video Material Demo}\n */\nfunction VideoSynchronizer(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._clock = undefined;\n  this._element = undefined;\n  this._clockSubscription = undefined;\n  this._seekFunction = undefined;\n  this._lastPlaybackRate = undefined;\n\n  this.clock = options.clock;\n  this.element = options.element;\n\n  /**\n   * Gets or sets the simulation time that marks the start of the video.\n   * @type {JulianDate}\n   * @default Iso8601.MINIMUM_VALUE\n   */\n  this.epoch = defaultValue(options.epoch, Iso8601.MINIMUM_VALUE);\n\n  /**\n   * Gets or sets the amount of time in seconds the video's currentTime\n   * and the clock's currentTime can diverge before a video seek is performed.\n   * Lower values make the synchronization more accurate but video\n   * performance might suffer.  Higher values provide better performance\n   * but at the cost of accuracy.\n   * @type {number}\n   * @default 1.0\n   */\n  this.tolerance = defaultValue(options.tolerance, 1.0);\n\n  this._seeking = false;\n  this._seekFunction = undefined;\n  this._firstTickAfterSeek = false;\n}\n\nObject.defineProperties(VideoSynchronizer.prototype, {\n  /**\n   * Gets or sets the clock used to drive the video element.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      const oldValue = this._clock;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if (defined(oldValue)) {\n        this._clockSubscription();\n        this._clockSubscription = undefined;\n      }\n\n      if (defined(value)) {\n        this._clockSubscription = value.onTick.addEventListener(\n          VideoSynchronizer.prototype._onTick,\n          this,\n        );\n      }\n\n      this._clock = value;\n    },\n  },\n  /**\n   * Gets or sets the video element to synchronize.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {HTMLVideoElement}\n   */\n  element: {\n    get: function () {\n      return this._element;\n    },\n    set: function (value) {\n      const oldValue = this._element;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if (defined(oldValue)) {\n        oldValue.removeEventListener(\"seeked\", this._seekFunction, false);\n      }\n\n      if (defined(value)) {\n        this._seeking = false;\n        this._seekFunction = createSeekFunction(this);\n        value.addEventListener(\"seeked\", this._seekFunction, false);\n      }\n\n      this._element = value;\n      this._seeking = false;\n      this._firstTickAfterSeek = false;\n    },\n  },\n});\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVideoSynchronizer.prototype.destroy = function () {\n  this.element = undefined;\n  this.clock = undefined;\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nVideoSynchronizer.prototype.isDestroyed = function () {\n  return false;\n};\n\nVideoSynchronizer.prototype._trySetPlaybackRate = function (clock) {\n  if (this._lastPlaybackRate === clock.multiplier) {\n    return;\n  }\n\n  const element = this._element;\n  try {\n    element.playbackRate = clock.multiplier;\n  } catch (error) {\n    // Seek manually for unsupported playbackRates.\n    element.playbackRate = 0.0;\n  }\n  this._lastPlaybackRate = clock.multiplier;\n};\n\nVideoSynchronizer.prototype._onTick = function (clock) {\n  const element = this._element;\n  if (!defined(element) || element.readyState < 2) {\n    return;\n  }\n\n  const paused = element.paused;\n  const shouldAnimate = clock.shouldAnimate;\n  if (shouldAnimate === paused) {\n    if (shouldAnimate) {\n      element.play();\n    } else {\n      element.pause();\n    }\n  }\n\n  //We need to avoid constant seeking or the video will\n  //never contain a complete frame for us to render.\n  //So don't do anything if we're seeing or on the first\n  //tick after a seek (the latter of which allows the frame\n  //to actually be rendered.\n  if (this._seeking || this._firstTickAfterSeek) {\n    this._firstTickAfterSeek = false;\n    return;\n  }\n\n  this._trySetPlaybackRate(clock);\n\n  const clockTime = clock.currentTime;\n  const epoch = defaultValue(this.epoch, Iso8601.MINIMUM_VALUE);\n  let videoTime = JulianDate.secondsDifference(clockTime, epoch);\n\n  const duration = element.duration;\n  let desiredTime;\n  const currentTime = element.currentTime;\n  if (element.loop) {\n    videoTime = videoTime % duration;\n    if (videoTime < 0.0) {\n      videoTime = duration - videoTime;\n    }\n    desiredTime = videoTime;\n  } else if (videoTime > duration) {\n    desiredTime = duration;\n  } else if (videoTime < 0.0) {\n    desiredTime = 0.0;\n  } else {\n    desiredTime = videoTime;\n  }\n\n  //If the playing video's time and the scene's clock time\n  //ever drift too far apart, we want to set the video to match\n  const tolerance = shouldAnimate ? defaultValue(this.tolerance, 1.0) : 0.001;\n  if (Math.abs(desiredTime - currentTime) > tolerance) {\n    this._seeking = true;\n    element.currentTime = desiredTime;\n  }\n};\n\nfunction createSeekFunction(that) {\n  return function () {\n    that._seeking = false;\n    that._firstTickAfterSeek = true;\n  };\n}\nexport default VideoSynchronizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}