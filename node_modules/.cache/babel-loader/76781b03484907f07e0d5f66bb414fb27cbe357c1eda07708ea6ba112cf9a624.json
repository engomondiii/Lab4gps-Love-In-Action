{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WallGeometryLibrary from \"./WallGeometryLibrary.js\";\nconst scratchCartesian3Position1 = new Cartesian3();\nconst scratchCartesian3Position2 = new Cartesian3();\n\n/**\n * A description of a wall outline. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @alias WallOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n *\n * @exception {DeveloperError} positions length must be greater than or equal to 2.\n * @exception {DeveloperError} positions and maximumHeights must have the same length.\n * @exception {DeveloperError} positions and minimumHeights must have the same length.\n *\n * @see WallGeometry#createGeometry\n * @see WallGeometry#fromConstantHeight\n *\n * @example\n * // create a wall outline that spans from ground level to 10000 meters\n * const wall = new Cesium.WallOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n */\nfunction WallOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const wallPositions = options.positions;\n  const maximumHeights = options.maximumHeights;\n  const minimumHeights = options.minimumHeights;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(wallPositions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  if (defined(maximumHeights) && maximumHeights.length !== wallPositions.length) {\n    throw new DeveloperError(\"options.positions and options.maximumHeights must have the same length.\");\n  }\n  if (defined(minimumHeights) && minimumHeights.length !== wallPositions.length) {\n    throw new DeveloperError(\"options.positions and options.minimumHeights must have the same length.\");\n  }\n  //>>includeEnd('debug');\n\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this._positions = wallPositions;\n  this._minimumHeights = minimumHeights;\n  this._maximumHeights = maximumHeights;\n  this._granularity = granularity;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._workerName = \"createWallOutlineGeometry\";\n  let numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n  if (defined(minimumHeights)) {\n    numComponents += minimumHeights.length;\n  }\n  if (defined(maximumHeights)) {\n    numComponents += maximumHeights.length;\n  }\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {WallOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nWallOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  let i;\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  const minimumHeights = value._minimumHeights;\n  length = defined(minimumHeights) ? minimumHeights.length : 0;\n  array[startingIndex++] = length;\n  if (defined(minimumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = minimumHeights[i];\n    }\n  }\n  const maximumHeights = value._maximumHeights;\n  length = defined(maximumHeights) ? maximumHeights.length : 0;\n  array[startingIndex++] = length;\n  if (defined(maximumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = maximumHeights[i];\n    }\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex] = value._granularity;\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  minimumHeights: undefined,\n  maximumHeights: undefined,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {WallOutlineGeometry} [result] The object into which to store the result.\n * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n */\nWallOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  let i;\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  length = array[startingIndex++];\n  let minimumHeights;\n  if (length > 0) {\n    minimumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      minimumHeights[i] = array[startingIndex++];\n    }\n  }\n  length = array[startingIndex++];\n  let maximumHeights;\n  if (length > 0) {\n    maximumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      maximumHeights[i] = array[startingIndex++];\n    }\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const granularity = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.minimumHeights = minimumHeights;\n    scratchOptions.maximumHeights = maximumHeights;\n    scratchOptions.granularity = granularity;\n    return new WallOutlineGeometry(scratchOptions);\n  }\n  result._positions = positions;\n  result._minimumHeights = minimumHeights;\n  result._maximumHeights = maximumHeights;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._granularity = granularity;\n  return result;\n};\n\n/**\n * A description of a walloutline. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.maximumHeight] A constant that defines the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number} [options.minimumHeight] A constant that defines the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @returns {WallOutlineGeometry}\n *\n *\n * @example\n * // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n *\n * @see WallOutlineGeometry#createGeometry\n */\nWallOutlineGeometry.fromConstantHeights = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let minHeights;\n  let maxHeights;\n  const min = options.minimumHeight;\n  const max = options.maximumHeight;\n  const doMin = defined(min);\n  const doMax = defined(max);\n  if (doMin || doMax) {\n    const length = positions.length;\n    minHeights = doMin ? new Array(length) : undefined;\n    maxHeights = doMax ? new Array(length) : undefined;\n    for (let i = 0; i < length; ++i) {\n      if (doMin) {\n        minHeights[i] = min;\n      }\n      if (doMax) {\n        maxHeights[i] = max;\n      }\n    }\n  }\n  const newOptions = {\n    positions: positions,\n    maximumHeights: maxHeights,\n    minimumHeights: minHeights,\n    ellipsoid: options.ellipsoid\n  };\n  return new WallOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nWallOutlineGeometry.createGeometry = function (wallGeometry) {\n  const wallPositions = wallGeometry._positions;\n  const minimumHeights = wallGeometry._minimumHeights;\n  const maximumHeights = wallGeometry._maximumHeights;\n  const granularity = wallGeometry._granularity;\n  const ellipsoid = wallGeometry._ellipsoid;\n  const pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);\n  if (!defined(pos)) {\n    return;\n  }\n  const bottomPositions = pos.bottomPositions;\n  const topPositions = pos.topPositions;\n  let length = topPositions.length;\n  let size = length * 2;\n  const positions = new Float64Array(size);\n  let positionIndex = 0;\n\n  // add lower and upper points one after the other, lower\n  // points being even and upper points being odd\n  length /= 3;\n  let i;\n  for (i = 0; i < length; ++i) {\n    const i3 = i * 3;\n    const topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n    const bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n\n    // insert the lower point\n    positions[positionIndex++] = bottomPosition.x;\n    positions[positionIndex++] = bottomPosition.y;\n    positions[positionIndex++] = bottomPosition.z;\n\n    // insert the upper point\n    positions[positionIndex++] = topPosition.x;\n    positions[positionIndex++] = topPosition.y;\n    positions[positionIndex++] = topPosition.z;\n  }\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n  const numVertices = size / 3;\n  size = 2 * numVertices - 4 + numVertices;\n  const indices = IndexDatatype.createTypedArray(numVertices, size);\n  let edgeIndex = 0;\n  for (i = 0; i < numVertices - 2; i += 2) {\n    const LL = i;\n    const LR = i + 2;\n    const pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n    const pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n    if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    const UL = i + 1;\n    const UR = i + 3;\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n  indices[edgeIndex++] = numVertices - 2;\n  indices[edgeIndex++] = numVertices - 1;\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere.fromVertices(positions)\n  });\n};\nexport default WallOutlineGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","IndexDatatype","CesiumMath","PrimitiveType","WallGeometryLibrary","scratchCartesian3Position1","scratchCartesian3Position2","WallOutlineGeometry","options","EMPTY_OBJECT","wallPositions","positions","maximumHeights","minimumHeights","length","granularity","RADIANS_PER_DEGREE","ellipsoid","default","_positions","_minimumHeights","_maximumHeights","_granularity","_ellipsoid","clone","_workerName","numComponents","packedLength","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","Array","fromConstantHeights","minHeights","maxHeights","min","minimumHeight","max","maximumHeight","doMin","doMax","newOptions","createGeometry","wallGeometry","pos","computePositions","bottomPositions","topPositions","size","Float64Array","positionIndex","i3","topPosition","fromArray","bottomPosition","x","y","z","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","numVertices","indices","createTypedArray","edgeIndex","LL","LR","pl","pr","equalsEpsilon","EPSILON10","UL","UR","primitiveType","LINES","boundingSphere","fromVertices"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/WallOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WallGeometryLibrary from \"./WallGeometryLibrary.js\";\n\nconst scratchCartesian3Position1 = new Cartesian3();\nconst scratchCartesian3Position2 = new Cartesian3();\n\n/**\n * A description of a wall outline. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @alias WallOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n *\n * @exception {DeveloperError} positions length must be greater than or equal to 2.\n * @exception {DeveloperError} positions and maximumHeights must have the same length.\n * @exception {DeveloperError} positions and minimumHeights must have the same length.\n *\n * @see WallGeometry#createGeometry\n * @see WallGeometry#fromConstantHeight\n *\n * @example\n * // create a wall outline that spans from ground level to 10000 meters\n * const wall = new Cesium.WallOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n */\nfunction WallOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const wallPositions = options.positions;\n  const maximumHeights = options.maximumHeights;\n  const minimumHeights = options.minimumHeights;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(wallPositions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  if (\n    defined(maximumHeights) &&\n    maximumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.maximumHeights must have the same length.\",\n    );\n  }\n  if (\n    defined(minimumHeights) &&\n    minimumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.minimumHeights must have the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n\n  this._positions = wallPositions;\n  this._minimumHeights = minimumHeights;\n  this._maximumHeights = maximumHeights;\n  this._granularity = granularity;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._workerName = \"createWallOutlineGeometry\";\n\n  let numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n  if (defined(minimumHeights)) {\n    numComponents += minimumHeights.length;\n  }\n  if (defined(maximumHeights)) {\n    numComponents += maximumHeights.length;\n  }\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {WallOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nWallOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const minimumHeights = value._minimumHeights;\n  length = defined(minimumHeights) ? minimumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(minimumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = minimumHeights[i];\n    }\n  }\n\n  const maximumHeights = value._maximumHeights;\n  length = defined(maximumHeights) ? maximumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(maximumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = maximumHeights[i];\n    }\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  minimumHeights: undefined,\n  maximumHeights: undefined,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {WallOutlineGeometry} [result] The object into which to store the result.\n * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n */\nWallOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  let minimumHeights;\n\n  if (length > 0) {\n    minimumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      minimumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  length = array[startingIndex++];\n  let maximumHeights;\n\n  if (length > 0) {\n    maximumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      maximumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.minimumHeights = minimumHeights;\n    scratchOptions.maximumHeights = maximumHeights;\n    scratchOptions.granularity = granularity;\n    return new WallOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._minimumHeights = minimumHeights;\n  result._maximumHeights = maximumHeights;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._granularity = granularity;\n\n  return result;\n};\n\n/**\n * A description of a walloutline. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.maximumHeight] A constant that defines the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number} [options.minimumHeight] A constant that defines the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @returns {WallOutlineGeometry}\n *\n *\n * @example\n * // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n *\n * @see WallOutlineGeometry#createGeometry\n */\nWallOutlineGeometry.fromConstantHeights = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let minHeights;\n  let maxHeights;\n\n  const min = options.minimumHeight;\n  const max = options.maximumHeight;\n\n  const doMin = defined(min);\n  const doMax = defined(max);\n  if (doMin || doMax) {\n    const length = positions.length;\n    minHeights = doMin ? new Array(length) : undefined;\n    maxHeights = doMax ? new Array(length) : undefined;\n\n    for (let i = 0; i < length; ++i) {\n      if (doMin) {\n        minHeights[i] = min;\n      }\n\n      if (doMax) {\n        maxHeights[i] = max;\n      }\n    }\n  }\n\n  const newOptions = {\n    positions: positions,\n    maximumHeights: maxHeights,\n    minimumHeights: minHeights,\n    ellipsoid: options.ellipsoid,\n  };\n  return new WallOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nWallOutlineGeometry.createGeometry = function (wallGeometry) {\n  const wallPositions = wallGeometry._positions;\n  const minimumHeights = wallGeometry._minimumHeights;\n  const maximumHeights = wallGeometry._maximumHeights;\n  const granularity = wallGeometry._granularity;\n  const ellipsoid = wallGeometry._ellipsoid;\n\n  const pos = WallGeometryLibrary.computePositions(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights,\n    granularity,\n    false,\n  );\n  if (!defined(pos)) {\n    return;\n  }\n\n  const bottomPositions = pos.bottomPositions;\n  const topPositions = pos.topPositions;\n\n  let length = topPositions.length;\n  let size = length * 2;\n\n  const positions = new Float64Array(size);\n  let positionIndex = 0;\n\n  // add lower and upper points one after the other, lower\n  // points being even and upper points being odd\n  length /= 3;\n  let i;\n  for (i = 0; i < length; ++i) {\n    const i3 = i * 3;\n    const topPosition = Cartesian3.fromArray(\n      topPositions,\n      i3,\n      scratchCartesian3Position1,\n    );\n    const bottomPosition = Cartesian3.fromArray(\n      bottomPositions,\n      i3,\n      scratchCartesian3Position2,\n    );\n\n    // insert the lower point\n    positions[positionIndex++] = bottomPosition.x;\n    positions[positionIndex++] = bottomPosition.y;\n    positions[positionIndex++] = bottomPosition.z;\n\n    // insert the upper point\n    positions[positionIndex++] = topPosition.x;\n    positions[positionIndex++] = topPosition.y;\n    positions[positionIndex++] = topPosition.z;\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  const numVertices = size / 3;\n  size = 2 * numVertices - 4 + numVertices;\n  const indices = IndexDatatype.createTypedArray(numVertices, size);\n\n  let edgeIndex = 0;\n  for (i = 0; i < numVertices - 2; i += 2) {\n    const LL = i;\n    const LR = i + 2;\n    const pl = Cartesian3.fromArray(\n      positions,\n      LL * 3,\n      scratchCartesian3Position1,\n    );\n    const pr = Cartesian3.fromArray(\n      positions,\n      LR * 3,\n      scratchCartesian3Position2,\n    );\n    if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    const UL = i + 1;\n    const UR = i + 3;\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  indices[edgeIndex++] = numVertices - 2;\n  indices[edgeIndex++] = numVertices - 1;\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere.fromVertices(positions),\n  });\n};\nexport default WallOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}