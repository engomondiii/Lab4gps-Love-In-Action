{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PropertyTable from \"./PropertyTable.js\";\nimport PropertyTexture from \"./PropertyTexture.js\";\nimport PropertyAttribute from \"./PropertyAttribute.js\";\nimport StructuralMetadata from \"./StructuralMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\n\n/**\n * Parse the <code>EXT_structural_metadata</code> glTF extension to create a\n * structural metadata object.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The extension JSON object.\n * @param {MetadataSchema} options.schema The parsed schema.\n * @param {Object<string, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n * @param {Object<string, Texture>} [options.textures] An object mapping texture IDs to {@link Texture} objects.\n * @return {StructuralMetadata} A structural metadata object\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction parseStructuralMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const extension = options.extension;\n\n  // The calling code is responsible for loading the schema.\n  // This keeps metadata parsing synchronous.\n  const schema = options.schema;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.schema\", schema);\n  //>>includeEnd('debug');\n\n  const propertyTables = [];\n  if (defined(extension.propertyTables)) {\n    for (let i = 0; i < extension.propertyTables.length; i++) {\n      const propertyTable = extension.propertyTables[i];\n      const classDefinition = schema.classes[propertyTable.class];\n      const metadataTable = new MetadataTable({\n        count: propertyTable.count,\n        properties: propertyTable.properties,\n        class: classDefinition,\n        bufferViews: options.bufferViews\n      });\n      propertyTables.push(new PropertyTable({\n        id: i,\n        name: propertyTable.name,\n        count: propertyTable.count,\n        metadataTable: metadataTable,\n        extras: propertyTable.extras,\n        extensions: propertyTable.extensions\n      }));\n    }\n  }\n  const propertyTextures = [];\n  if (defined(extension.propertyTextures)) {\n    for (let i = 0; i < extension.propertyTextures.length; i++) {\n      const propertyTexture = extension.propertyTextures[i];\n      propertyTextures.push(new PropertyTexture({\n        id: i,\n        name: propertyTexture.name,\n        propertyTexture: propertyTexture,\n        class: schema.classes[propertyTexture.class],\n        textures: options.textures\n      }));\n    }\n  }\n  const propertyAttributes = [];\n  if (defined(extension.propertyAttributes)) {\n    for (let i = 0; i < extension.propertyAttributes.length; i++) {\n      const propertyAttribute = extension.propertyAttributes[i];\n      propertyAttributes.push(new PropertyAttribute({\n        id: i,\n        name: propertyAttribute.name,\n        class: schema.classes[propertyAttribute.class],\n        propertyAttribute: propertyAttribute\n      }));\n    }\n  }\n  return new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n    propertyTextures: propertyTextures,\n    propertyAttributes: propertyAttributes,\n    statistics: extension.statistics,\n    extras: extension.extras,\n    extensions: extension.extensions\n  });\n}\nexport default parseStructuralMetadata;","map":{"version":3,"names":["Check","defaultValue","defined","PropertyTable","PropertyTexture","PropertyAttribute","StructuralMetadata","MetadataTable","parseStructuralMetadata","options","EMPTY_OBJECT","extension","schema","typeOf","object","propertyTables","i","length","propertyTable","classDefinition","classes","class","metadataTable","count","properties","bufferViews","push","id","name","extras","extensions","propertyTextures","propertyTexture","textures","propertyAttributes","propertyAttribute","statistics"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/parseStructuralMetadata.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PropertyTable from \"./PropertyTable.js\";\nimport PropertyTexture from \"./PropertyTexture.js\";\nimport PropertyAttribute from \"./PropertyAttribute.js\";\nimport StructuralMetadata from \"./StructuralMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\n\n/**\n * Parse the <code>EXT_structural_metadata</code> glTF extension to create a\n * structural metadata object.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The extension JSON object.\n * @param {MetadataSchema} options.schema The parsed schema.\n * @param {Object<string, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n * @param {Object<string, Texture>} [options.textures] An object mapping texture IDs to {@link Texture} objects.\n * @return {StructuralMetadata} A structural metadata object\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction parseStructuralMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const extension = options.extension;\n\n  // The calling code is responsible for loading the schema.\n  // This keeps metadata parsing synchronous.\n  const schema = options.schema;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.schema\", schema);\n  //>>includeEnd('debug');\n\n  const propertyTables = [];\n  if (defined(extension.propertyTables)) {\n    for (let i = 0; i < extension.propertyTables.length; i++) {\n      const propertyTable = extension.propertyTables[i];\n      const classDefinition = schema.classes[propertyTable.class];\n      const metadataTable = new MetadataTable({\n        count: propertyTable.count,\n        properties: propertyTable.properties,\n        class: classDefinition,\n        bufferViews: options.bufferViews,\n      });\n      propertyTables.push(\n        new PropertyTable({\n          id: i,\n          name: propertyTable.name,\n          count: propertyTable.count,\n          metadataTable: metadataTable,\n          extras: propertyTable.extras,\n          extensions: propertyTable.extensions,\n        }),\n      );\n    }\n  }\n\n  const propertyTextures = [];\n  if (defined(extension.propertyTextures)) {\n    for (let i = 0; i < extension.propertyTextures.length; i++) {\n      const propertyTexture = extension.propertyTextures[i];\n      propertyTextures.push(\n        new PropertyTexture({\n          id: i,\n          name: propertyTexture.name,\n          propertyTexture: propertyTexture,\n          class: schema.classes[propertyTexture.class],\n          textures: options.textures,\n        }),\n      );\n    }\n  }\n\n  const propertyAttributes = [];\n  if (defined(extension.propertyAttributes)) {\n    for (let i = 0; i < extension.propertyAttributes.length; i++) {\n      const propertyAttribute = extension.propertyAttributes[i];\n      propertyAttributes.push(\n        new PropertyAttribute({\n          id: i,\n          name: propertyAttribute.name,\n          class: schema.classes[propertyAttribute.class],\n          propertyAttribute: propertyAttribute,\n        }),\n      );\n    }\n  }\n\n  return new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n    propertyTextures: propertyTextures,\n    propertyAttributes: propertyAttributes,\n    statistics: extension.statistics,\n    extras: extension.extras,\n    extensions: extension.extensions,\n  });\n}\n\nexport default parseStructuralMetadata;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}