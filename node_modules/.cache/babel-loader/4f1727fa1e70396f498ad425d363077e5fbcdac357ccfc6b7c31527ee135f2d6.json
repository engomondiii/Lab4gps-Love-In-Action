{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n  ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);\n  ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {number} [x=0] The radius in the x direction.\n * @param {number} [y=0] The radius in the y direction.\n * @param {number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n  initialize(this, x, y, z);\n}\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    }\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    }\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    }\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    }\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    }\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    }\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    }\n  }\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  const radii = ellipsoid._radii;\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n  if (!defined(cartesian)) {\n    return result;\n  }\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\nEllipsoid._default = Ellipsoid.WGS84;\nObject.defineProperties(Ellipsoid, {\n  /**\n   * The default ellipsoid used when not otherwise specified.\n   * @memberof Ellipsoid\n   * @type {Ellipsoid}\n   * @example\n   * Cesium.Ellipsoid.default = Cesium.Ellipsoid.MOON;\n   *\n   * // Apollo 11 landing site\n   * const position = Cesium.Cartesian3.fromRadians(\n   *   0.67416,\n   *   23.47315,\n   * );\n   */\n  default: {\n    get: function () {\n      return Ellipsoid._default;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      Ellipsoid._default = value;\n      Cartesian3._ellipsoidRadiiSquared = value.radiiSquared;\n      Cartographic._ellipsoidOneOverRadii = value.oneOverRadii;\n      Cartographic._ellipsoidOneOverRadiiSquared = value.oneOverRadiiSquared;\n      Cartographic._ellipsoidCenterToleranceSquared = value._centerToleranceSquared;\n    }\n  }\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._radii, array, startingIndex);\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  const longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n  const cosLatitude = Math.cos(latitude);\n  const x = cosLatitude * Math.cos(longitude);\n  const y = cosLatitude * Math.sin(longitude);\n  const z = Math.sin(latitude);\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  if (isNaN(cartesian.x) || isNaN(cartesian.y) || isNaN(cartesian.z)) {\n    throw new DeveloperError(\"cartesian has a NaN component\");\n  }\n  //>>includeEnd('debug');\n  if (Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\n  return Cartesian3.normalize(result, result);\n};\nconst cartographicToCartesianNormal = new Cartesian3();\nconst cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  const n = cartographicToCartesianNormal;\n  const k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  const gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  const length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\nconst cartesianToCartographicN = new Cartesian3();\nconst cartesianToCartographicP = new Cartesian3();\nconst cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n  if (!defined(p)) {\n    return undefined;\n  }\n  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiSquared = this._oneOverRadiiSquared;\n  const beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (position, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (position, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return this === right || defined(right) && Cartesian3.equals(this._radii, right._radii);\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {string} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (position, buffer, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n  if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {\n    throw new DeveloperError(\"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\");\n  }\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n  return result;\n};\nconst scratchEndpoint = new Cartesian3();\n\n/**\n * Computes the ellipsoid curvatures at a given position on the surface.\n *\n * @param {Cartesian3} surfacePosition The position on the ellipsoid surface where curvatures will be calculated.\n * @param {Cartesian2} [result] The cartesian to which to copy the result, or undefined to create and return a new instance.\n * @returns {Cartesian2} The local curvature of the ellipsoid surface at the provided position, in east and north directions.\n *\n * @exception {DeveloperError} position is required.\n */\nEllipsoid.prototype.getLocalCurvature = function (surfacePosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"surfacePosition\", surfacePosition);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  const primeVerticalEndpoint = this.getSurfaceNormalIntersectionWithZAxis(surfacePosition, 0.0, scratchEndpoint);\n  const primeVerticalRadius = Cartesian3.distance(surfacePosition, primeVerticalEndpoint);\n  // meridional radius = (1 - e^2) * primeVerticalRadius^3 / a^2\n  // where 1 - e^2 = b^2 / a^2,\n  // so meridional = b^2 * primeVerticalRadius^3 / a^4\n  //   = (b * primeVerticalRadius / a^2)^2 * primeVertical\n  const radiusRatio = this.minimumRadius * primeVerticalRadius / this.maximumRadius ** 2;\n  const meridionalRadius = primeVerticalRadius * radiusRatio ** 2;\n  return Cartesian2.fromElements(1.0 / primeVerticalRadius, 1.0 / meridionalRadius, result);\n};\nconst abscissas = [0.14887433898163, 0.43339539412925, 0.67940956829902, 0.86506336668898, 0.97390652851717, 0.0];\nconst weights = [0.29552422471475, 0.26926671930999, 0.21908636251598, 0.14945134915058, 0.066671344308684, 0.0];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {number} a The lower bound for the integration.\n * @param {number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  const xMean = 0.5 * (b + a);\n  const xRange = 0.5 * (b - a);\n  let sum = 0.0;\n  for (let i = 0; i < 5; i++) {\n    const dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {number} x The value used to evaluate the function.\n * @returns {number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  const minLongitude = rectangle.west;\n  let maxLongitude = rectangle.east;\n  const minLatitude = rectangle.south;\n  const maxLatitude = rectangle.north;\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n  const radiiSquared = this._radiiSquared;\n  const a2 = radiiSquared.x;\n  const b2 = radiiSquared.y;\n  const c2 = radiiSquared.z;\n  const a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    const sinPhi = Math.cos(lat);\n    const cosPhi = Math.sin(lat);\n    return Math.cos(lat) * gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n      const cosTheta = Math.cos(lon);\n      const sinTheta = Math.sin(lon);\n      return Math.sqrt(a2b2 * cosPhi * cosPhi + c2 * (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) * sinPhi * sinPhi);\n    });\n  });\n};\nexport default Ellipsoid;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","CesiumMath","scaleToGeodeticSurface","initialize","ellipsoid","x","y","z","typeOf","number","greaterThanOrEquals","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","Math","min","_maximumRadius","max","_centerToleranceSquared","EPSILON1","_squaredXOverSquaredZ","Ellipsoid","undefined","Object","defineProperties","prototype","radii","get","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","maximumRadius","clone","result","fromCartesian3","cartesian","WGS84","freeze","UNIT_SPHERE","MOON","LUNAR_RADIUS","_default","default","set","value","object","_ellipsoidRadiiSquared","_ellipsoidOneOverRadii","_ellipsoidOneOverRadiiSquared","_ellipsoidCenterToleranceSquared","packedLength","pack","array","startingIndex","unpack","geocentricSurfaceNormal","normalize","geodeticSurfaceNormalCartographic","cartographic","longitude","latitude","cosLatitude","cos","sin","geodeticSurfaceNormal","isNaN","equalsEpsilon","ZERO","EPSILON14","multiplyComponents","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","n","k","gamma","sqrt","dot","divideByScalar","multiplyByScalar","height","add","cartographicArrayToCartesianArray","cartographics","length","Array","i","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","cartesianToCartographic","p","h","subtract","atan2","asin","sign","magnitude","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","equals","right","toString","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ","abs","scratchEndpoint","getLocalCurvature","surfacePosition","primeVerticalEndpoint","primeVerticalRadius","distance","radiusRatio","meridionalRadius","fromElements","abscissas","weights","gaussLegendreQuadrature","a","b","func","xMean","xRange","sum","dx","surfaceArea","rectangle","minLongitude","west","maxLongitude","east","minLatitude","south","maxLatitude","north","TWO_PI","a2","b2","c2","a2b2","lat","sinPhi","cosPhi","lon","cosTheta","sinTheta"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Ellipsoid.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z,\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z,\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z),\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {number} [x=0] The radius in the x direction.\n * @param {number} [y=0] The radius in the y direction.\n * @param {number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  const radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793),\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n  ),\n);\n\nEllipsoid._default = Ellipsoid.WGS84;\nObject.defineProperties(Ellipsoid, {\n  /**\n   * The default ellipsoid used when not otherwise specified.\n   * @memberof Ellipsoid\n   * @type {Ellipsoid}\n   * @example\n   * Cesium.Ellipsoid.default = Cesium.Ellipsoid.MOON;\n   *\n   * // Apollo 11 landing site\n   * const position = Cesium.Cartesian3.fromRadians(\n   *   0.67416,\n   *   23.47315,\n   * );\n   */\n  default: {\n    get: function () {\n      return Ellipsoid._default;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      Ellipsoid._default = value;\n      Cartesian3._ellipsoidRadiiSquared = value.radiiSquared;\n      Cartographic._ellipsoidOneOverRadii = value.oneOverRadii;\n      Cartographic._ellipsoidOneOverRadiiSquared = value.oneOverRadiiSquared;\n      Cartographic._ellipsoidCenterToleranceSquared =\n        value._centerToleranceSquared;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  const longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n  const cosLatitude = Math.cos(latitude);\n\n  const x = cosLatitude * Math.cos(longitude);\n  const y = cosLatitude * Math.sin(longitude);\n  const z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  if (isNaN(cartesian.x) || isNaN(cartesian.y) || isNaN(cartesian.z)) {\n    throw new DeveloperError(\"cartesian has a NaN component\");\n  }\n  //>>includeEnd('debug');\n  if (\n    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result,\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nconst cartographicToCartesianNormal = new Cartesian3();\nconst cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  const n = cartographicToCartesianNormal;\n  const k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  const gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  const length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nconst cartesianToCartographicN = new Cartesian3();\nconst cartesianToCartographicP = new Cartesian3();\nconst cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result,\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  const beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z,\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {string} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15,\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\",\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n\n  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst scratchEndpoint = new Cartesian3();\n\n/**\n * Computes the ellipsoid curvatures at a given position on the surface.\n *\n * @param {Cartesian3} surfacePosition The position on the ellipsoid surface where curvatures will be calculated.\n * @param {Cartesian2} [result] The cartesian to which to copy the result, or undefined to create and return a new instance.\n * @returns {Cartesian2} The local curvature of the ellipsoid surface at the provided position, in east and north directions.\n *\n * @exception {DeveloperError} position is required.\n */\nEllipsoid.prototype.getLocalCurvature = function (surfacePosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"surfacePosition\", surfacePosition);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const primeVerticalEndpoint = this.getSurfaceNormalIntersectionWithZAxis(\n    surfacePosition,\n    0.0,\n    scratchEndpoint,\n  );\n  const primeVerticalRadius = Cartesian3.distance(\n    surfacePosition,\n    primeVerticalEndpoint,\n  );\n  // meridional radius = (1 - e^2) * primeVerticalRadius^3 / a^2\n  // where 1 - e^2 = b^2 / a^2,\n  // so meridional = b^2 * primeVerticalRadius^3 / a^4\n  //   = (b * primeVerticalRadius / a^2)^2 * primeVertical\n  const radiusRatio =\n    (this.minimumRadius * primeVerticalRadius) / this.maximumRadius ** 2;\n  const meridionalRadius = primeVerticalRadius * radiusRatio ** 2;\n\n  return Cartesian2.fromElements(\n    1.0 / primeVerticalRadius,\n    1.0 / meridionalRadius,\n    result,\n  );\n};\n\nconst abscissas = [\n  0.14887433898163, 0.43339539412925, 0.67940956829902, 0.86506336668898,\n  0.97390652851717, 0.0,\n];\nconst weights = [\n  0.29552422471475, 0.26926671930999, 0.21908636251598, 0.14945134915058,\n  0.066671344308684, 0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {number} a The lower bound for the integration.\n * @param {number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  const xMean = 0.5 * (b + a);\n  const xRange = 0.5 * (b - a);\n\n  let sum = 0.0;\n  for (let i = 0; i < 5; i++) {\n    const dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {number} x The value used to evaluate the function.\n * @returns {number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  const minLongitude = rectangle.west;\n  let maxLongitude = rectangle.east;\n  const minLatitude = rectangle.south;\n  const maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n\n  const radiiSquared = this._radiiSquared;\n  const a2 = radiiSquared.x;\n  const b2 = radiiSquared.y;\n  const c2 = radiiSquared.z;\n  const a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    const sinPhi = Math.cos(lat);\n    const cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        const cosTheta = Math.cos(lon);\n        const sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi,\n        );\n      })\n    );\n  });\n};\n\nexport default Ellipsoid;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}