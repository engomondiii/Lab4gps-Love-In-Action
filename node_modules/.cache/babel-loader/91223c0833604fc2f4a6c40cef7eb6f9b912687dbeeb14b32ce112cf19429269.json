{"ast":null,"code":"import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport FeatureIdStageFS from \"../../Shaders/Model/FeatureIdStageFS.js\";\nimport FeatureIdStageVS from \"../../Shaders/Model/FeatureIdStageVS.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * The feature ID pipeline stage is responsible for processing feature IDs\n * (both attributes and textures), updating the shader in preparation for\n * custom shaders, picking, and/or styling.\n *\n * @namespace FeatureIdPipelineStage\n * @private\n */\nconst FeatureIdPipelineStage = {\n  name: \"FeatureIdPipelineStage\",\n  // Helps with debugging\n\n  STRUCT_ID_FEATURE_IDS_VS: \"FeatureIdsVS\",\n  STRUCT_ID_FEATURE_IDS_FS: \"FeatureIdsFS\",\n  STRUCT_NAME_FEATURE_IDS: \"FeatureIds\",\n  FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS: \"initializeFeatureIdsVS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS: \"initializeFeatureIdsFS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS: \"initializeFeatureIdAliasesVS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS: \"initializeFeatureIdAliasesFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS: \"void initializeFeatureIds(out FeatureIds featureIds, ProcessedAttributes attributes)\",\n  FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES: \"void initializeFeatureIdAliases(inout FeatureIds featureIds)\",\n  FUNCTION_ID_SET_FEATURE_ID_VARYINGS: \"setFeatureIdVaryings\",\n  FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS: \"void setFeatureIdVaryings()\"\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>Adds the FeatureIds struct and corresponding initialization functions in the vertex and fragment shader</li>\n *  <li>For each feature ID attribute, the attributes were already uploaded in the geometry stage, so just update the shader code </li>\n *  <li>For each feature ID implicit range, a new attribute is created and uploaded to the GPU since gl_VertexID is not available in WebGL 1. The shader is updated with an attribute, varying, and initialization code.</li>\n *  <li>For each feature ID texture, the texture is added to the uniform map, and shader code is added to perform the texture read.</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nFeatureIdPipelineStage.process = function (renderResources, primitive, frameState) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  declareStructsAndFunctions(shaderBuilder);\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    processInstanceFeatureIds(renderResources, instances, frameState);\n  }\n  processPrimitiveFeatureIds(renderResources, primitive, frameState);\n  shaderBuilder.addVertexLines(FeatureIdStageVS);\n  shaderBuilder.addFragmentLines(FeatureIdStageFS);\n};\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the FeatureIds struct. The vertex shader will only use\n  // feature ID attributes, while the fragment shader will also use\n  // feature ID textures.\n  shaderBuilder.addStruct(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS, FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS, ShaderDestination.VERTEX);\n  shaderBuilder.addStruct(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS, FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS, ShaderDestination.FRAGMENT);\n\n  // declare the initializeFeatureIds() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS, ShaderDestination.VERTEX);\n  shaderBuilder.addFunction(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS, ShaderDestination.FRAGMENT);\n\n  // declare the initializeFeatureIdAliases() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS, FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES, ShaderDestination.VERTEX);\n  shaderBuilder.addFunction(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS, FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES, ShaderDestination.FRAGMENT);\n\n  // declare the setFeatureIdVaryings() function in the vertex shader only\n  shaderBuilder.addFunction(FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS, FeatureIdPipelineStage.FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS, ShaderDestination.VERTEX);\n}\nfunction processInstanceFeatureIds(renderResources, instances, frameState) {\n  const featureIdsArray = instances.featureIds;\n  const count = instances.attributes[0].count;\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processInstanceAttribute(renderResources, featureIds, variableName);\n    } else {\n      const instanceDivisor = 1;\n      processImplicitRange(renderResources, featureIds, variableName, count, instanceDivisor, frameState);\n    }\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, ShaderDestination.BOTH);\n    }\n  }\n}\nfunction processPrimitiveFeatureIds(renderResources, primitive, frameState) {\n  const featureIdsArray = primitive.featureIds;\n  const positionAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.POSITION);\n  const count = positionAttribute.count;\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n    let aliasDestination = ShaderDestination.BOTH;\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processAttribute(renderResources, featureIds, variableName);\n    } else if (featureIds instanceof ModelComponents.FeatureIdImplicitRange) {\n      processImplicitRange(renderResources, featureIds, variableName, count, undefined, frameState);\n    } else {\n      processTexture(renderResources, featureIds, variableName, i, frameState);\n      aliasDestination = ShaderDestination.FRAGMENT;\n    }\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, aliasDestination);\n    }\n  }\n}\nfunction processInstanceAttribute(renderResources, featureIdAttribute, variableName) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int instanceFeatureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS, \"int\", variableName);\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS, \"int\", variableName);\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.instanceFeatureId_n = int(czm_round(attributes.instanceFeatureId_0));\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n  const attributeName = `a_${prefix}${setIndex}`;\n  const varyingName = `v_${prefix}${setIndex}`;\n  const vertexLine = `featureIds.${variableName} = int(czm_round(${attributeName}));`;\n  const fragmentLine = `featureIds.${variableName} = int(czm_round(${varyingName}));`;\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, [vertexLine]);\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, [fragmentLine]);\n\n  // Instanced attributes don't normally need varyings, so add one here\n  shaderBuilder.addVarying(\"float\", varyingName);\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_instanceFeatureId_n = a_instanceFeatureId_n;\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS, [`${varyingName} = ${attributeName};`]);\n}\nfunction processAttribute(renderResources, featureIdAttribute, variableName) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS, \"int\", variableName);\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS, \"int\", variableName);\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.featureId_n = attributes.featureId_0;\n  // Since this uses the ProcessedAttributes struct, the line is the same\n  // for both vertex and fragment shader.\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n  const initializationLines = [`featureIds.${variableName} = int(czm_round(attributes.${prefix}${setIndex}));`];\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, initializationLines);\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, initializationLines);\n}\nfunction processImplicitRange(renderResources, implicitFeatureIds, variableName, count, instanceDivisor, frameState) {\n  // Generate a vertex attribute for the implicit IDs since WebGL 1 does not\n  // support gl_VertexID\n  generateImplicitFeatureIdAttribute(renderResources, implicitFeatureIds, count, instanceDivisor, frameState);\n\n  // Declare the vertex attribute in the shader\n  // Example: in float a_implicit_feature_id_n;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const implicitAttributeName = `a_implicit_${variableName}`;\n  shaderBuilder.addAttribute(\"float\", implicitAttributeName);\n\n  // Also declare the corresponding varyings\n  // Example: in float v_implicit_feature_id_n;\n  const implicitVaryingName = `v_implicit_${variableName}`;\n  shaderBuilder.addVarying(\"float\", implicitVaryingName);\n\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS, \"int\", variableName);\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS, \"int\", variableName);\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_implicit_featureId_n = a_implicit_featureId_n;\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS, [`${implicitVaryingName} = ${implicitAttributeName};`]);\n\n  // Initialize the field from the generated attribute/varying.\n  // Example:\n  // featureIds.featureId_n = a_implicit_featureId_n; (VS)\n  // featureIds.featureId_n = v_implicit_featureId_n; (FS)\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS, [`featureIds.${variableName} = int(czm_round(${implicitAttributeName}));`]);\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, [`featureIds.${variableName} = int(czm_round(${implicitVaryingName}));`]);\n}\nfunction processTexture(renderResources, featureIdTexture, variableName, index, frameState) {\n  // Create the feature ID texture uniform. The index matches the index from\n  // the featureIds array, even if this is not consecutive.\n  const uniformName = `u_featureIdTexture_${index}`;\n  const uniformMap = renderResources.uniformMap;\n  const textureReader = featureIdTexture.textureReader;\n  uniformMap[uniformName] = function () {\n    return defaultValue(textureReader.texture, frameState.context.defaultTexture);\n  };\n  const channels = textureReader.channels;\n\n  // Add a field to the FeatureIds struct in the fragment shader only\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS, \"int\", variableName);\n\n  // Declare the uniform in the fragment shader\n  shaderBuilder.addUniform(\"sampler2D\", uniformName, ShaderDestination.FRAGMENT);\n\n  // Get a GLSL expression for the texture coordinates\n  const texCoord = textureReader.texCoord;\n  const texCoordVariable = `v_texCoord_${texCoord}`;\n  let texCoordVariableExpression = texCoordVariable;\n\n  // Check if the texture defines a `transform` from a `KHR_texture_transform`\n  const transform = textureReader.transform;\n  if (defined(transform) && !Matrix3.equals(transform, Matrix3.IDENTITY)) {\n    // Add a uniform for the transformation matrix\n    const transformUniformName = `${uniformName}Transform`;\n    shaderBuilder.addUniform(\"mat3\", transformUniformName, ShaderDestination.FRAGMENT);\n    uniformMap[transformUniformName] = function () {\n      return transform;\n    };\n    // Update the expression for the texture coordinates\n    // with one that transforms the texture coordinates\n    // with the transform matrix first\n    texCoordVariableExpression = `vec2(${transformUniformName} * vec3(${texCoordVariable}, 1.0))`;\n  }\n  // Read one or more channels from the texture\n  // example: texture(u_featureIdTexture_0, v_texCoord_1).rg\n  const textureRead = `texture(${uniformName}, ${texCoordVariableExpression}).${channels}`;\n\n  // Finally, assign to the struct field. Example:\n  // featureIds.featureId_0 = unpacked;\n  const initializationLine = `featureIds.${variableName} = czm_unpackUint(${textureRead});`;\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS, [initializationLine]);\n}\nfunction addAlias(renderResources, variableName, alias, shaderDestination) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int alias;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  const updateVS = ShaderDestination.includesVertexShader(shaderDestination);\n  if (updateVS) {\n    shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS, \"int\", alias);\n  }\n  shaderBuilder.addStructField(FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS, \"int\", alias);\n\n  // Initialize the field from the original variable\n  // Example: featureIds.alias = featureIds.featureId_n;\n  const initializationLines = [`featureIds.${alias} = featureIds.${variableName};`];\n  if (updateVS) {\n    shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS, initializationLines);\n  }\n  shaderBuilder.addFunctionLines(FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS, initializationLines);\n}\nfunction generateImplicitFeatureIdAttribute(renderResources, implicitFeatureIds, count, instanceDivisor, frameState) {\n  const model = renderResources.model;\n  let vertexBuffer;\n  let value;\n  if (defined(implicitFeatureIds.repeat)) {\n    const typedArray = generateImplicitFeatureIdTypedArray(implicitFeatureIds, count);\n    vertexBuffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: typedArray,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    vertexBuffer.vertexArrayDestroyable = false;\n    model._pipelineResources.push(vertexBuffer);\n    const hasCpuCopy = false;\n    model.statistics.addBuffer(vertexBuffer, hasCpuCopy);\n  } else {\n    value = [implicitFeatureIds.offset];\n  }\n  const generatedFeatureIdAttribute = {\n    index: renderResources.attributeIndex++,\n    instanceDivisor: instanceDivisor,\n    value: value,\n    vertexBuffer: vertexBuffer,\n    normalize: false,\n    componentsPerAttribute: 1,\n    componentDatatype: ComponentDatatype.FLOAT,\n    strideInBytes: ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT),\n    offsetInBytes: 0\n  };\n  renderResources.attributes.push(generatedFeatureIdAttribute);\n}\n\n/**\n * Generates a typed array for implicit feature IDs\n * @private\n */\nfunction generateImplicitFeatureIdTypedArray(implicitFeatureIds, count) {\n  const offset = implicitFeatureIds.offset;\n  const repeat = implicitFeatureIds.repeat;\n  const typedArray = new Float32Array(count);\n  for (let i = 0; i < count; i++) {\n    typedArray[i] = offset + Math.floor(i / repeat);\n  }\n  return typedArray;\n}\nexport default FeatureIdPipelineStage;","map":{"version":3,"names":["ComponentDatatype","defaultValue","defined","ShaderDestination","Buffer","BufferUsage","FeatureIdStageFS","FeatureIdStageVS","ModelComponents","VertexAttributeSemantic","ModelUtility","Matrix3","FeatureIdPipelineStage","name","STRUCT_ID_FEATURE_IDS_VS","STRUCT_ID_FEATURE_IDS_FS","STRUCT_NAME_FEATURE_IDS","FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS","FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS","FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS","FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS","FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS","FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES","FUNCTION_ID_SET_FEATURE_ID_VARYINGS","FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS","process","renderResources","primitive","frameState","shaderBuilder","declareStructsAndFunctions","instances","runtimeNode","node","processInstanceFeatureIds","processPrimitiveFeatureIds","addVertexLines","addFragmentLines","addStruct","VERTEX","FRAGMENT","addFunction","featureIdsArray","featureIds","count","attributes","i","length","variableName","positionalLabel","FeatureIdAttribute","processInstanceAttribute","instanceDivisor","processImplicitRange","label","addAlias","BOTH","positionAttribute","getAttributeBySemantic","POSITION","aliasDestination","processAttribute","FeatureIdImplicitRange","undefined","processTexture","featureIdAttribute","addStructField","setIndex","prefix","replace","attributeName","varyingName","vertexLine","fragmentLine","addFunctionLines","addVarying","initializationLines","implicitFeatureIds","generateImplicitFeatureIdAttribute","implicitAttributeName","addAttribute","implicitVaryingName","featureIdTexture","index","uniformName","uniformMap","textureReader","texture","context","defaultTexture","channels","addUniform","texCoord","texCoordVariable","texCoordVariableExpression","transform","equals","IDENTITY","transformUniformName","textureRead","initializationLine","alias","shaderDestination","updateVS","includesVertexShader","model","vertexBuffer","value","repeat","typedArray","generateImplicitFeatureIdTypedArray","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","_pipelineResources","push","hasCpuCopy","statistics","addBuffer","offset","generatedFeatureIdAttribute","attributeIndex","normalize","componentsPerAttribute","componentDatatype","FLOAT","strideInBytes","getSizeInBytes","offsetInBytes","Float32Array","Math","floor"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/FeatureIdPipelineStage.js"],"sourcesContent":["import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport FeatureIdStageFS from \"../../Shaders/Model/FeatureIdStageFS.js\";\nimport FeatureIdStageVS from \"../../Shaders/Model/FeatureIdStageVS.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * The feature ID pipeline stage is responsible for processing feature IDs\n * (both attributes and textures), updating the shader in preparation for\n * custom shaders, picking, and/or styling.\n *\n * @namespace FeatureIdPipelineStage\n * @private\n */\nconst FeatureIdPipelineStage = {\n  name: \"FeatureIdPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_FEATURE_IDS_VS: \"FeatureIdsVS\",\n  STRUCT_ID_FEATURE_IDS_FS: \"FeatureIdsFS\",\n  STRUCT_NAME_FEATURE_IDS: \"FeatureIds\",\n  FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS: \"initializeFeatureIdsVS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS: \"initializeFeatureIdsFS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS: \"initializeFeatureIdAliasesVS\",\n  FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS: \"initializeFeatureIdAliasesFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS:\n    \"void initializeFeatureIds(out FeatureIds featureIds, ProcessedAttributes attributes)\",\n  FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES:\n    \"void initializeFeatureIdAliases(inout FeatureIds featureIds)\",\n  FUNCTION_ID_SET_FEATURE_ID_VARYINGS: \"setFeatureIdVaryings\",\n  FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS: \"void setFeatureIdVaryings()\",\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>Adds the FeatureIds struct and corresponding initialization functions in the vertex and fragment shader</li>\n *  <li>For each feature ID attribute, the attributes were already uploaded in the geometry stage, so just update the shader code </li>\n *  <li>For each feature ID implicit range, a new attribute is created and uploaded to the GPU since gl_VertexID is not available in WebGL 1. The shader is updated with an attribute, varying, and initialization code.</li>\n *  <li>For each feature ID texture, the texture is added to the uniform map, and shader code is added to perform the texture read.</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nFeatureIdPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  declareStructsAndFunctions(shaderBuilder);\n\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    processInstanceFeatureIds(renderResources, instances, frameState);\n  }\n  processPrimitiveFeatureIds(renderResources, primitive, frameState);\n\n  shaderBuilder.addVertexLines(FeatureIdStageVS);\n  shaderBuilder.addFragmentLines(FeatureIdStageFS);\n};\n\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the FeatureIds struct. The vertex shader will only use\n  // feature ID attributes, while the fragment shader will also use\n  // feature ID textures.\n  shaderBuilder.addStruct(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the initializeFeatureIds() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the initializeFeatureIdAliases() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the setFeatureIdVaryings() function in the vertex shader only\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS,\n    ShaderDestination.VERTEX,\n  );\n}\n\nfunction processInstanceFeatureIds(renderResources, instances, frameState) {\n  const featureIdsArray = instances.featureIds;\n  const count = instances.attributes[0].count;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processInstanceAttribute(renderResources, featureIds, variableName);\n    } else {\n      const instanceDivisor = 1;\n      processImplicitRange(\n        renderResources,\n        featureIds,\n        variableName,\n        count,\n        instanceDivisor,\n        frameState,\n      );\n    }\n\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, ShaderDestination.BOTH);\n    }\n  }\n}\n\nfunction processPrimitiveFeatureIds(renderResources, primitive, frameState) {\n  const featureIdsArray = primitive.featureIds;\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const count = positionAttribute.count;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n\n    let aliasDestination = ShaderDestination.BOTH;\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processAttribute(renderResources, featureIds, variableName);\n    } else if (featureIds instanceof ModelComponents.FeatureIdImplicitRange) {\n      processImplicitRange(\n        renderResources,\n        featureIds,\n        variableName,\n        count,\n        undefined,\n        frameState,\n      );\n    } else {\n      processTexture(renderResources, featureIds, variableName, i, frameState);\n      aliasDestination = ShaderDestination.FRAGMENT;\n    }\n\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, aliasDestination);\n    }\n  }\n}\n\nfunction processInstanceAttribute(\n  renderResources,\n  featureIdAttribute,\n  variableName,\n) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int instanceFeatureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName,\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.instanceFeatureId_n = int(czm_round(attributes.instanceFeatureId_0));\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n\n  const attributeName = `a_${prefix}${setIndex}`;\n  const varyingName = `v_${prefix}${setIndex}`;\n  const vertexLine = `featureIds.${variableName} = int(czm_round(${attributeName}));`;\n  const fragmentLine = `featureIds.${variableName} = int(czm_round(${varyingName}));`;\n\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    [vertexLine],\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [fragmentLine],\n  );\n\n  // Instanced attributes don't normally need varyings, so add one here\n  shaderBuilder.addVarying(\"float\", varyingName);\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_instanceFeatureId_n = a_instanceFeatureId_n;\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    [`${varyingName} = ${attributeName};`],\n  );\n}\n\nfunction processAttribute(renderResources, featureIdAttribute, variableName) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName,\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.featureId_n = attributes.featureId_0;\n  // Since this uses the ProcessedAttributes struct, the line is the same\n  // for both vertex and fragment shader.\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n\n  const initializationLines = [\n    `featureIds.${variableName} = int(czm_round(attributes.${prefix}${setIndex}));`,\n  ];\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    initializationLines,\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    initializationLines,\n  );\n}\n\nfunction processImplicitRange(\n  renderResources,\n  implicitFeatureIds,\n  variableName,\n  count,\n  instanceDivisor,\n  frameState,\n) {\n  // Generate a vertex attribute for the implicit IDs since WebGL 1 does not\n  // support gl_VertexID\n  generateImplicitFeatureIdAttribute(\n    renderResources,\n    implicitFeatureIds,\n    count,\n    instanceDivisor,\n    frameState,\n  );\n\n  // Declare the vertex attribute in the shader\n  // Example: in float a_implicit_feature_id_n;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const implicitAttributeName = `a_implicit_${variableName}`;\n  shaderBuilder.addAttribute(\"float\", implicitAttributeName);\n\n  // Also declare the corresponding varyings\n  // Example: in float v_implicit_feature_id_n;\n  const implicitVaryingName = `v_implicit_${variableName}`;\n  shaderBuilder.addVarying(\"float\", implicitVaryingName);\n\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName,\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_implicit_featureId_n = a_implicit_featureId_n;\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    [`${implicitVaryingName} = ${implicitAttributeName};`],\n  );\n\n  // Initialize the field from the generated attribute/varying.\n  // Example:\n  // featureIds.featureId_n = a_implicit_featureId_n; (VS)\n  // featureIds.featureId_n = v_implicit_featureId_n; (FS)\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    [`featureIds.${variableName} = int(czm_round(${implicitAttributeName}));`],\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [`featureIds.${variableName} = int(czm_round(${implicitVaryingName}));`],\n  );\n}\n\nfunction processTexture(\n  renderResources,\n  featureIdTexture,\n  variableName,\n  index,\n  frameState,\n) {\n  // Create the feature ID texture uniform. The index matches the index from\n  // the featureIds array, even if this is not consecutive.\n  const uniformName = `u_featureIdTexture_${index}`;\n  const uniformMap = renderResources.uniformMap;\n  const textureReader = featureIdTexture.textureReader;\n  uniformMap[uniformName] = function () {\n    return defaultValue(\n      textureReader.texture,\n      frameState.context.defaultTexture,\n    );\n  };\n\n  const channels = textureReader.channels;\n\n  // Add a field to the FeatureIds struct in the fragment shader only\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName,\n  );\n\n  // Declare the uniform in the fragment shader\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Get a GLSL expression for the texture coordinates\n  const texCoord = textureReader.texCoord;\n  const texCoordVariable = `v_texCoord_${texCoord}`;\n  let texCoordVariableExpression = texCoordVariable;\n\n  // Check if the texture defines a `transform` from a `KHR_texture_transform`\n  const transform = textureReader.transform;\n  if (defined(transform) && !Matrix3.equals(transform, Matrix3.IDENTITY)) {\n    // Add a uniform for the transformation matrix\n    const transformUniformName = `${uniformName}Transform`;\n    shaderBuilder.addUniform(\n      \"mat3\",\n      transformUniformName,\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap[transformUniformName] = function () {\n      return transform;\n    };\n    // Update the expression for the texture coordinates\n    // with one that transforms the texture coordinates\n    // with the transform matrix first\n    texCoordVariableExpression = `vec2(${transformUniformName} * vec3(${texCoordVariable}, 1.0))`;\n  }\n  // Read one or more channels from the texture\n  // example: texture(u_featureIdTexture_0, v_texCoord_1).rg\n  const textureRead = `texture(${uniformName}, ${texCoordVariableExpression}).${channels}`;\n\n  // Finally, assign to the struct field. Example:\n  // featureIds.featureId_0 = unpacked;\n  const initializationLine = `featureIds.${variableName} = czm_unpackUint(${textureRead});`;\n\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [initializationLine],\n  );\n}\n\nfunction addAlias(renderResources, variableName, alias, shaderDestination) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int alias;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  const updateVS = ShaderDestination.includesVertexShader(shaderDestination);\n  if (updateVS) {\n    shaderBuilder.addStructField(\n      FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n      \"int\",\n      alias,\n    );\n  }\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    alias,\n  );\n\n  // Initialize the field from the original variable\n  // Example: featureIds.alias = featureIds.featureId_n;\n  const initializationLines = [\n    `featureIds.${alias} = featureIds.${variableName};`,\n  ];\n  if (updateVS) {\n    shaderBuilder.addFunctionLines(\n      FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS,\n      initializationLines,\n    );\n  }\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS,\n    initializationLines,\n  );\n}\n\nfunction generateImplicitFeatureIdAttribute(\n  renderResources,\n  implicitFeatureIds,\n  count,\n  instanceDivisor,\n  frameState,\n) {\n  const model = renderResources.model;\n  let vertexBuffer;\n  let value;\n  if (defined(implicitFeatureIds.repeat)) {\n    const typedArray = generateImplicitFeatureIdTypedArray(\n      implicitFeatureIds,\n      count,\n    );\n    vertexBuffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    vertexBuffer.vertexArrayDestroyable = false;\n    model._pipelineResources.push(vertexBuffer);\n    const hasCpuCopy = false;\n    model.statistics.addBuffer(vertexBuffer, hasCpuCopy);\n  } else {\n    value = [implicitFeatureIds.offset];\n  }\n\n  const generatedFeatureIdAttribute = {\n    index: renderResources.attributeIndex++,\n    instanceDivisor: instanceDivisor,\n    value: value,\n    vertexBuffer: vertexBuffer,\n    normalize: false,\n    componentsPerAttribute: 1,\n    componentDatatype: ComponentDatatype.FLOAT,\n    strideInBytes: ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT),\n    offsetInBytes: 0,\n  };\n\n  renderResources.attributes.push(generatedFeatureIdAttribute);\n}\n\n/**\n * Generates a typed array for implicit feature IDs\n * @private\n */\nfunction generateImplicitFeatureIdTypedArray(implicitFeatureIds, count) {\n  const offset = implicitFeatureIds.offset;\n  const repeat = implicitFeatureIds.repeat;\n\n  const typedArray = new Float32Array(count);\n  for (let i = 0; i < count; i++) {\n    typedArray[i] = offset + Math.floor(i / repeat);\n  }\n\n  return typedArray;\n}\n\nexport default FeatureIdPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}