{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * const ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *       radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *     })),\n *     modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *       Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *     id : 'ellipsoid',\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance(),\n *   asynchronous : false\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = new Matrix4();\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(options.releaseGeometryInstances, true);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n\n  /**\n   * @private\n   */\n  this.rtcCenter = options.rtcCenter;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && (!defined(this.geometryInstances) || Array.isArray(this.geometryInstances) && this.geometryInstances.length !== 1)) {\n    throw new DeveloperError(\"Relative-to-center rendering only supports one geometry instance.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n  this._translucent = undefined;\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = new Map();\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n  this._pickIds = [];\n  this._colorCommands = [];\n  this._pickCommands = [];\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n  this._createGeometryResults = undefined;\n  this._ready = false;\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    }\n  },\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    }\n  },\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    }\n  },\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    }\n  },\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    }\n  },\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @example\n   * // Wait for a primitive to become ready before accessing attributes\n   * const removeListener = scene.postRender.addEventListener(() => {\n   *   if (!frustumPrimitive.ready) {\n   *     return;\n   *   }\n   *\n   *   const attributes = primitive.getGeometryInstanceAttributes('an id');\n   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n   *\n   *   removeListener();\n   * });\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  }\n});\nfunction getCommonPerInstanceAttributeNames(instances) {\n  const length = instances.length;\n  const attributesInAllInstances = [];\n  const attributes0 = instances[0].attributes;\n  let name;\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      const attribute = attributes0[name];\n      let inAllInstances = true;\n\n      // Does this same attribute exist in all instances?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i].attributes[name];\n        if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {\n          inAllInstances = false;\n          break;\n        }\n      }\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n  return attributesInAllInstances;\n}\nconst scratchGetAttributeCartesian2 = new Cartesian2();\nconst scratchGetAttributeCartesian3 = new Cartesian3();\nconst scratchGetAttributeCartesian4 = new Cartesian4();\nfunction getAttributeValue(value) {\n  const componentsPerAttribute = value.length;\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\nfunction createBatchTable(primitive, context) {\n  const geometryInstances = primitive.geometryInstances;\n  const instances = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];\n  const numberOfInstances = instances.length;\n  if (numberOfInstances === 0) {\n    return;\n  }\n  const names = getCommonPerInstanceAttributeNames(instances);\n  const length = names.length;\n  const attributes = [];\n  const attributeIndices = {};\n  const boundingSphereAttributeIndices = {};\n  let offset2DIndex;\n  const firstInstance = instances[0];\n  let instanceAttributes = firstInstance.attributes;\n  let i;\n  let name;\n  let attribute;\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: `czm_batchTable_${name}`,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize\n    });\n  }\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereRadius\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1\n    });\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true\n  });\n  const attributesLength = attributes.length;\n  const batchTable = new BatchTable(context, attributes, numberOfInstances);\n  for (i = 0; i < numberOfInstances; ++i) {\n    const instance = instances[i];\n    instanceAttributes = instance.attributes;\n    for (let j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      const value = getAttributeValue(attribute.value);\n      const attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n    const pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive)\n    };\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n    const pickId = context.createPickId(pickObject);\n    primitive._pickIds.push(pickId);\n    const pickColor = pickId.color;\n    const color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\nfunction cloneAttribute(attribute) {\n  let clonedValues;\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues\n  });\n}\nfunction cloneGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const newAttributes = new GeometryAttributes();\n  for (const property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n  let indices;\n  if (defined(geometry.indices)) {\n    const sourceValues = geometry.indices;\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere)\n  });\n}\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id\n  };\n}\nconst positionRegex = /in\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\nPrimitive._modifyShaderPosition = function (primitive, vertexShaderSource, scene3DOnly) {\n  let match;\n  let forwardDecl = \"\";\n  let attributes = \"\";\n  let computeFunctions = \"\";\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    const name = match[1];\n    const functionName = `vec4 czm_compute${name[0].toUpperCase()}${name.substr(1)}()`;\n\n    // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += `${functionName};\\n`;\n    }\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes += `in vec3 ${name}2DHigh;\\nin vec3 ${name}2DLow;\\n`;\n        computeFunctions += `${functionName}\\n` + `{\\n` + `    vec4 p;\\n` + `    if (czm_morphTime == 1.0)\\n` + `    {\\n` + `        p = czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` + `    }\\n` + `    else if (czm_morphTime == 0.0)\\n` + `    {\\n` + `        p = czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy);\\n` + `    }\\n` + `    else\\n` + `    {\\n` + `        p = czm_columbusViewMorph(\\n` + `                czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy),\\n` + `                czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow),\\n` + `                czm_morphTime);\\n` + `    }\\n` + `    return p;\\n` + `}\\n\\n`;\n      } else {\n        computeFunctions += `${functionName}\\n` + `{\\n` + `    return czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` + `}\\n\\n`;\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(/in\\s+vec(?:3|4)\\s+position3DHigh;/g, \"\");\n      vertexShaderSource = vertexShaderSource.replace(/in\\s+vec(?:3|4)\\s+position3DLow;/g, \"\");\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"in vec4 position;\\n\";\n      computeFunctions += `${functionName}\\n` + `{\\n` + `    return u_modifiedModelView * position;\\n` + `}\\n\\n`;\n      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewRelativeToEye\\s+\\*\\s+/g, \"\");\n      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewProjectionRelativeToEye/g, \"czm_projection\");\n    }\n  }\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\"\\n\");\n};\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n  const renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_show_main\");\n  const showMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_show_main(); \\n\" + \"    gl_Position *= czm_batchTable_show(batchId); \\n\" + \"}\";\n  return `${renamedVS}\\n${showMain}`;\n};\nPrimitive._updateColorAttribute = function (primitive, vertexShaderSource, isDepthFail) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (!defined(primitive._batchTableAttributeIndices.color) && !defined(primitive._batchTableAttributeIndices.depthFailColor)) {\n    return vertexShaderSource;\n  }\n  if (vertexShaderSource.search(/in\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isDepthFail && !defined(primitive._batchTableAttributeIndices.depthFailColor)) {\n    throw new DeveloperError(\"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\");\n  }\n  //>>includeEnd('debug');\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/in\\s+vec4\\s+color;/g, \"\");\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(/(\\b)color(\\b)/g, \"$1czm_batchTable_color(batchId)$2\");\n  } else {\n    modifiedVS = modifiedVS.replace(/(\\b)color(\\b)/g, \"$1czm_batchTable_depthFailColor(batchId)$2\");\n  }\n  return modifiedVS;\n};\nfunction appendPickToVertexShader(source) {\n  const renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  const pickMain = \"out vec4 v_pickColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" + \"}\";\n  return `${renamedVS}\\n${pickMain}`;\n}\nfunction appendPickToFragmentShader(source) {\n  return `in vec4 v_pickColor;\\n${source}`;\n}\nPrimitive._updatePickColorAttribute = function (source) {\n  let vsPick = source.replace(/in\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(/(\\b)pickColor(\\b)/g, \"$1czm_batchTable_pickColor(batchId)$2\");\n  return vsPick;\n};\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n  let attr = \"in float batchId;\\n\";\n  attr += \"in float applyOffset;\";\n  let modifiedShader = vertexShaderSource.replace(/in\\s+float\\s+batchId;/g, attr);\n  let str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str += \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str += \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(/vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g, str);\n  return modifiedShader;\n};\nPrimitive._appendDistanceDisplayConditionToShader = function (primitive, vertexShaderSource, scene3DOnly) {\n  if (!defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)) {\n    return vertexShaderSource;\n  }\n  const renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_distanceDisplayCondition_main\");\n  let distanceDisplayConditionMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_distanceDisplayCondition_main(); \\n\" + \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" + \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" + \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" + \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain += \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" + \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" + \"    vec4 centerRTE;\\n\" + \"    if (czm_morphTime == 1.0)\\n\" + \"    {\\n\" + \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" + \"    }\\n\" + \"    else if (czm_morphTime == 0.0)\\n\" + \"    {\\n\" + \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" + \"    }\\n\" + \"    else\\n\" + \"    {\\n\" + \"        centerRTE = czm_columbusViewMorph(\\n\" + \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" + \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" + \"                czm_morphTime);\\n\" + \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain += \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n  distanceDisplayConditionMain += \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" + \"    float distanceSq; \\n\" + \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" + \"    { \\n\" + \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" + \"    } \\n\" + \"    distanceSq = max(distanceSq, 0.0); \\n\" + \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" + \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" + \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" + \"    gl_Position *= show; \\n\" + \"}\";\n  return `${renamedVS}\\n${distanceDisplayConditionMain}`;\n};\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n  const containsNormal = vertexShaderSource.search(/in\\s+vec3\\s+normal;/g) !== -1;\n  const containsSt = vertexShaderSource.search(/in\\s+vec2\\s+st;/g) !== -1;\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n  const containsTangent = vertexShaderSource.search(/in\\s+vec3\\s+tangent;/g) !== -1;\n  const containsBitangent = vertexShaderSource.search(/in\\s+vec3\\s+bitangent;/g) !== -1;\n  let numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n  const type = numComponents > 1 ? `vec${numComponents}` : \"float\";\n  const attributeName = \"compressedAttributes\";\n  const attributeDecl = `in ${type} ${attributeName};`;\n  let globalDecl = \"\";\n  let decode = \"\";\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    const stComponent = numComponents > 1 ? `${attributeName}.x` : attributeName;\n    decode += `    st = czm_decompressTextureCoordinates(${stComponent});\\n`;\n  }\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode += `    czm_octDecode(${attributeName}.${containsSt ? \"yz\" : \"xy\"}, normal, tangent, bitangent);\\n`;\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode += `    normal = czm_octDecode(${attributeName}${numComponents > 1 ? `.${containsSt ? \"y\" : \"x\"}` : \"\"});\\n`;\n    }\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode += `    tangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? \"z\" : \"y\"});\\n`;\n    }\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode += `    bitangent = czm_octDecode(${attributeName}.${containsSt && containsNormal ? \"z\" : \"y\"});\\n`;\n    }\n  }\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  const compressedMain = `${\"void main() \\n\" + \"{ \\n\"}${decode}    czm_non_compressed_main(); \\n` + `}`;\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\nfunction depthClampVS(vertexShaderSource) {\n  let modifiedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_depth_clamp_main\");\n  modifiedVS += \"void main() {\\n\" + \"    czm_non_depth_clamp_main();\\n\" + \"    gl_Position = czm_depthClamp(gl_Position);\" + \"}\\n\";\n  return modifiedVS;\n}\nfunction depthClampFS(fragmentShaderSource) {\n  let modifiedFS = ShaderSource.replaceMain(fragmentShaderSource, \"czm_non_depth_clamp_main\");\n  modifiedFS += \"void main() {\\n\" + \"    czm_non_depth_clamp_main();\\n\" + \"    #if defined(LOG_DEPTH)\\n\" + \"        czm_writeLogDepth();\\n\" + \"    #else\\n\" + \"        czm_writeDepthClamp();\\n\" + \"    #endif\\n\" + \"}\\n\";\n  return modifiedFS;\n}\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  const shaderAttributes = shaderProgram.vertexAttributes;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (const name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(`Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`);\n      }\n    }\n  }\n  //>>includeEnd('debug');\n}\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\nconst numberOfCreationWorkers = Math.max(FeatureDetection.hardwareConcurrency - 1, 1);\nlet createGeometryTaskProcessors;\nconst combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\");\nfunction loadAsynchronous(primitive, frameState) {\n  let instances;\n  let geometry;\n  let i;\n  let j;\n  const instanceIds = primitive._instanceIds;\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n    const length = primitive._numberOfInstances = instances.length;\n    const promises = [];\n    let subTasks = [];\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id);\n\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(geometry._workerName) && defined(geometry._workerPath) || !defined(geometry._workerName) && !defined(geometry._workerPath)) {\n        throw new DeveloperError(\"Must define either _workerName or _workerPath for asynchronous geometry.\");\n      }\n      //>>includeEnd('debug');\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        modulePath: geometry._workerPath,\n        geometry: geometry\n      });\n    }\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\");\n      }\n    }\n    let subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n    for (i = 0; i < subTasks.length; i++) {\n      let packedLength = 0;\n      const workerSubTasks = subTasks[i];\n      const workerSubTasksLength = workerSubTasks.length;\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(geometry.constructor.packedLength, geometry.packedLength);\n        }\n      }\n      let subTaskTransferableObjects;\n      if (packedLength > 0) {\n        const array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n      promises.push(createGeometryTaskProcessors[i].scheduleTask({\n        subTasks: subTasks[i]\n      }, subTaskTransferableObjects));\n    }\n    primitive._state = PrimitiveState.CREATING;\n    Promise.all(promises).then(function (results) {\n      primitive._createGeometryResults = results;\n      primitive._state = PrimitiveState.CREATED;\n    }).catch(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    const transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n    const scene3DOnly = frameState.scene3DOnly;\n    const projection = frameState.mapProjection;\n    const promise = combineGeometryTaskProcessor.scheduleTask(PrimitivePipeline.packCombineGeometryParameters({\n      createGeometryResults: primitive._createGeometryResults,\n      instances: instances,\n      ellipsoid: projection.ellipsoid,\n      projection: projection,\n      elementIndexUintSupported: frameState.context.elementIndexUint,\n      scene3DOnly: scene3DOnly,\n      vertexCacheOptimize: primitive.vertexCacheOptimize,\n      compressVertices: primitive.compressVertices,\n      modelMatrix: primitive.modelMatrix,\n      createPickOffsets: primitive._createPickOffsets\n    }, transferableObjects), transferableObjects);\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n    Promise.resolve(promise).then(function (packedResult) {\n      const result = PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n      primitive._geometries = result.geometries;\n      primitive._attributeLocations = result.attributeLocations;\n      primitive.modelMatrix = Matrix4.clone(result.modelMatrix, primitive.modelMatrix);\n      primitive._pickOffsets = result.pickOffsets;\n      primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n      primitive._instanceBoundingSpheres = result.boundingSpheres;\n      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n      if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n        primitive._recomputeBoundingSpheres = true;\n        primitive._state = PrimitiveState.COMBINED;\n      } else {\n        setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n      }\n    }).catch(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  }\n}\nfunction loadSynchronous(primitive, frameState) {\n  const instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n  const length = primitive._numberOfInstances = instances.length;\n  const clonedInstances = new Array(length);\n  const instanceIds = primitive._instanceIds;\n  let instance;\n  let i;\n  let geometryIndex = 0;\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    const geometry = instance.geometry;\n    let createdGeometry;\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n  clonedInstances.length = geometryIndex;\n  const scene3DOnly = frameState.scene3DOnly;\n  const projection = frameState.mapProjection;\n  const result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets\n  });\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(result.modelMatrix, primitive.modelMatrix);\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  const offsetIndex = primitive._batchTableAttributeIndices.offset;\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n  let i;\n  const offsetInstanceExtend = primitive._offsetInstanceExtend;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n  let newBoundingSpheres = primitive._tempBoundingSpheres;\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n  for (i = 0; i < length; ++i) {\n    let newBS = newBoundingSpheres[i];\n    const offset = primitive._batchTable.getBatchedAttribute(i, offsetIndex, new Cartesian3());\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n  const combinedBS = [];\n  const combinedWestBS = [];\n  const combinedEastBS = [];\n  for (i = 0; i < length; ++i) {\n    const bs = newBoundingSpheres[i];\n    const minX = bs.center.x - bs.radius;\n    if (minX > 0 || BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n  let resultBS1 = combinedBS[0];\n  let resultBS2 = combinedEastBS[0];\n  let resultBS3 = combinedWestBS[0];\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n  const result = [];\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n  for (i = 0; i < result.length; i++) {\n    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(boundingSphere, frameState.mapProjection, primitive._boundingSphereCV[i]);\n  }\n  Primitive._updateBoundingVolumes(primitive, frameState, primitive.modelMatrix, true);\n  primitive._recomputeBoundingSpheres = false;\n}\nconst scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nconst scratchBoundingSphereCartographic = new Cartographic();\nconst scratchBoundingSphereCenter2D = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  const hasDistanceDisplayCondition = defined(primitive._batchTableAttributeIndices.distanceDisplayCondition);\n  if (!hasDistanceDisplayCondition || primitive._batchTableBoundingSpheresUpdated) {\n    return;\n  }\n  const indices = primitive._batchTableBoundingSphereAttributeIndices;\n  const center3DHighIndex = indices.center3DHigh;\n  const center3DLowIndex = indices.center3DLow;\n  const center2DHighIndex = indices.center2DHigh;\n  const center2DLowIndex = indices.center2DLow;\n  const radiusIndex = indices.radius;\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, scratchBoundingSphere);\n    }\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    let encodedCenter = EncodedCartesian3.fromCartesian(center, scratchBoundingSphereCenterEncoded);\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n    if (!frameState.scene3DOnly) {\n      const cartographic = ellipsoid.cartesianToCartographic(center, scratchBoundingSphereCartographic);\n      const center2D = projection.project(cartographic, scratchBoundingSphereCenter2D);\n      encodedCenter = EncodedCartesian3.fromCartesian(center2D, scratchBoundingSphereCenterEncoded);\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\nconst offsetScratchCartesian = new Cartesian3();\nconst offsetCenterScratch = new Cartesian3();\nfunction updateBatchTableOffsets(primitive, frameState) {\n  const hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n  if (!hasOffset || primitive._batchTableOffsetsUpdated || frameState.scene3DOnly) {\n    return;\n  }\n  const index2D = primitive._batchTableOffsetAttribute2DIndex;\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    const offset = batchTable.getBatchedAttribute(i, primitive._batchTableAttributeIndices.offset);\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, scratchBoundingSphere);\n    }\n    let center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    let cartographic = ellipsoid.cartesianToCartographic(center, scratchBoundingSphereCartographic);\n    const center2D = projection.project(cartographic, scratchBoundingSphereCenter2D);\n    const newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n    const newPointProjected = projection.project(cartographic, offsetScratchCartesian);\n    const newVector = Cartesian3.subtract(newPointProjected, center2D, offsetScratchCartesian);\n    const x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n  primitive._batchTableOffsetsUpdated = true;\n}\nfunction createVertexArray(primitive, frameState) {\n  const attributeLocations = primitive._attributeLocations;\n  const geometries = primitive._geometries;\n  const scene3DOnly = frameState.scene3DOnly;\n  const context = frameState.context;\n  const va = [];\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    const geometry = geometries[i];\n    va.push(VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n      interleave: primitive._interleave\n    }));\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(BoundingSphere.clone(geometry.boundingSphere));\n      primitive._boundingSphereWC.push(new BoundingSphere());\n      if (!scene3DOnly) {\n        const center = geometry.boundingSphereCV.center;\n        const x = center.x;\n        const y = center.y;\n        const z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n        primitive._boundingSphereCV.push(BoundingSphere.clone(geometry.boundingSphereCV));\n        primitive._boundingSphere2D.push(new BoundingSphere());\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  let renderState = appearance.getRenderState();\n  let rs;\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n  rs = clone(renderState, false);\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\nfunction createShaderProgram(primitive, frameState, appearance) {\n  const context = frameState.context;\n  const attributeLocations = primitive._attributeLocations;\n  let vs = primitive._batchTable.getVertexShaderCallback()(appearance.vertexShaderSource);\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs, frameState.scene3DOnly);\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  let fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(primitive._depthFailAppearance.vertexShaderSource);\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs, frameState.scene3DOnly);\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  const materialUniformMap = defined(material) ? material._uniforms : undefined;\n  const appearanceUniformMap = {};\n  const appearanceUniforms = appearance.uniforms;\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (const name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(`Appearance and material have a uniform with the same name: ${name}`);\n        }\n        //>>includeEnd('debug');\n\n        appearanceUniformMap[name] = getUniformFunction(appearanceUniforms, name);\n      }\n    }\n  }\n  let uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(viewMatrix, primitive._modelMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive.rtcCenter, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    };\n  }\n  return uniforms;\n}\nfunction createCommands(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands, frameState) {\n  const uniforms = getUniforms(primitive, appearance, material, frameState);\n  let depthFailUniforms;\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(primitive, primitive._depthFailAppearance, primitive._depthFailAppearance.material, frameState);\n  }\n  const pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n  let multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n  const length = colorCommands.length;\n  let vaIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    let colorCommand;\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n      ++i;\n    }\n    colorCommand = colorCommands[i];\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n        colorCommand = colorCommands[i];\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType\n          });\n        }\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n      ++i;\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n    ++vaIndex;\n  }\n}\nPrimitive._updateBoundingVolumes = function (primitive, frameState, modelMatrix, forceUpdate) {\n  let i;\n  let length;\n  let boundingSphere;\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(boundingSphere, modelMatrix, primitive._boundingSphereWC[i]);\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(primitive._boundingSphereCV[i], primitive._boundingSphere2D[i]);\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(primitive._boundingSphereWC[i], primitive._boundingSphereCV[i]);\n        }\n      }\n    }\n  }\n\n  // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n  const pixelSize = primitive.appearance.pixelSize;\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      const boundingSphereWC = primitive._boundingSphereWC[i];\n      const pixelSizeInMeters = frameState.camera.getPixelSize(boundingSphere, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n      const sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\nfunction updateAndQueueCommands(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  //>>includeStart('debug', pragmas.debug);\n  if (frameState.mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    throw new DeveloperError(\"Primitive.modelMatrix is only supported in 3D mode.\");\n  }\n  //>>includeEnd('debug');\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n  const commandList = frameState.commandList;\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    const allowPicking = primitive.allowPicking;\n    const castShadows = ShadowMode.castShadows(primitive.shadows);\n    const receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    const colorLength = colorCommands.length;\n    let factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n    for (let j = 0; j < colorLength; ++j) {\n      const sphereIndex = Math.floor(j / factor);\n      const colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n      commandList.push(colorCommand);\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPrimitive.prototype.update = function (frameState) {\n  if (!defined(this.geometryInstances) && this._va.length === 0 || defined(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined(this.appearance) || frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {\n    return;\n  }\n  if (defined(this._error)) {\n    throw this._error;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\"RTC rendering is only available for 3D only scenes.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n  const context = frameState.context;\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\");\n    }\n    this._batchTable.update(frameState);\n  }\n  if (this._state !== PrimitiveState.COMPLETE && this._state !== PrimitiveState.COMBINED) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  }\n\n  // Create or recreate render state and shader program if appearance/material changed\n  const appearance = this.appearance;\n  const material = appearance.material;\n  let createRS = false;\n  let createSP = false;\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n  const depthFailAppearance = this.depthFailAppearance;\n  const depthFailMaterial = defined(depthFailAppearance) ? depthFailAppearance.material : undefined;\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n  const translucent = this._appearance.isTranslucent();\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n  const twoPasses = appearance.closed && translucent;\n  if (createRS) {\n    const rsFunc = defaultValue(this._createRenderStatesFunction, createRenderStates);\n    rsFunc(this, context, appearance, twoPasses);\n  }\n  if (createSP) {\n    const spFunc = defaultValue(this._createShaderProgramFunction, createShaderProgram);\n    spFunc(this, frameState, appearance);\n  }\n  if (createRS || createSP) {\n    const commandFunc = defaultValue(this._createCommandsFunction, createCommands);\n    commandFunc(this, appearance, material, translucent, twoPasses, this._colorCommands, this._pickCommands, frameState);\n  }\n  const updateAndQueueCommandsFunc = defaultValue(this._updateAndQueueCommandsFunction, updateAndQueueCommands);\n  updateAndQueueCommandsFunc(this, frameState, this._colorCommands, this._pickCommands, this.modelMatrix, this.cull, this.debugShowBoundingVolume, twoPasses);\n};\nconst offsetBoundingSphereScratch1 = new BoundingSphere();\nconst offsetBoundingSphereScratch2 = new BoundingSphere();\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    const origBS = BoundingSphere.clone(boundingSphere, offsetBoundingSphereScratch1);\n    const offsetBS = BoundingSphere.clone(boundingSphere, offsetBoundingSphereScratch2);\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(boundingSphere.center, offset, boundingSphere.center);\n  }\n  return boundingSphere;\n}\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    const attributeValue = batchTable.getBatchedAttribute(instanceIndex, attributeIndex);\n    const attribute = batchTable.attributes[attributeIndex];\n    const componentsPerAttribute = attribute.componentsPerAttribute;\n    const value = ComponentDatatype.createTypedArray(attribute.componentDatatype, componentsPerAttribute);\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n    return value;\n  };\n}\nfunction createSetFunction(batchTable, instanceIndex, attributeIndex, primitive, name) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value) || !defined(value.length) || value.length < 1 || value.length > 4) {\n      throw new DeveloperError(\"value must be and array with length between 1 and 4.\");\n    }\n    //>>includeEnd('debug');\n    const attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(instanceIndex, attributeIndex, attributeValue);\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\nconst offsetScratch = new Cartesian3();\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      let boundingSphere = primitive._instanceBoundingSpheres[index];\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        const modelMatrix = primitive.modelMatrix;\n        const offset = properties.offset;\n        if (defined(offset)) {\n          transformBoundingSphere(boundingSphere, Cartesian3.fromArray(offset.get(), 0, offsetScratch), primitive._offsetInstanceExtend[index]);\n        }\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix);\n        }\n      }\n      return boundingSphere;\n    }\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    }\n  };\n}\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    }\n  };\n}\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  }\n  //>>includeEnd('debug');\n\n  let attributes = this._perInstanceAttributeCache.get(id);\n  if (defined(attributes)) {\n    return attributes;\n  }\n  let index = -1;\n  const lastIndex = this._lastPerInstanceAttributeIndex;\n  const ids = this._instanceIds;\n  const length = ids.length;\n  for (let i = 0; i < length; ++i) {\n    const curIndex = (lastIndex + i) % length;\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n  if (index === -1) {\n    return undefined;\n  }\n  const batchTable = this._batchTable;\n  const perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  const properties = {};\n  for (const name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      const attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name)\n      };\n    }\n  }\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache.set(id, attributes);\n  return attributes;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\nPrimitive.prototype.destroy = function () {\n  let length;\n  let i;\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n  const va = this._va;\n  length = va.length;\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n  this._va = undefined;\n  const pickIds = this._pickIds;\n  length = pickIds.length;\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  this._pickIds = undefined;\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n  return destroyObject(this);\n};\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready = primitive._state === PrimitiveState.COMPLETE || primitive._state === PrimitiveState.FAILED;\n  });\n}\nexport default Primitive;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","FeatureDetection","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","Intersect","Matrix4","Plane","RuntimeError","subdivideArray","TaskProcessor","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","BatchTable","CullFace","DepthFunction","PrimitivePipeline","PrimitiveState","SceneMode","ShadowMode","Primitive","options","EMPTY_OBJECT","geometryInstances","appearance","_appearance","undefined","_material","depthFailAppearance","_depthFailAppearance","_depthFailMaterial","modelMatrix","IDENTITY","_modelMatrix","show","_vertexCacheOptimize","vertexCacheOptimize","_interleave","interleave","_releaseGeometryInstances","releaseGeometryInstances","_allowPicking","allowPicking","_asynchronous","asynchronous","_compressVertices","compressVertices","cull","debugShowBoundingVolume","rtcCenter","Array","isArray","length","shadows","DISABLED","_translucent","_state","READY","_geometries","_error","_numberOfInstances","_boundingSpheres","_boundingSphereWC","_boundingSphereCV","_boundingSphere2D","_boundingSphereMorph","_perInstanceAttributeCache","Map","_instanceIds","_lastPerInstanceAttributeIndex","_va","_attributeLocations","_primitiveType","_frontFaceRS","_backFaceRS","_sp","_spDepthFail","_frontFaceDepthFailRS","_backFaceDepthFailRS","_pickIds","_colorCommands","_pickCommands","_createBoundingVolumeFunction","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_createPickOffsets","_pickOffsets","_createGeometryResults","_ready","_batchTable","_batchTableAttributeIndices","_offsetInstanceExtend","_batchTableOffsetAttribute2DIndex","_batchTableOffsetsUpdated","_instanceBoundingSpheres","_instanceBoundingSpheresCV","_tempBoundingSpheres","_recomputeBoundingSpheres","_batchTableBoundingSpheresUpdated","_batchTableBoundingSphereAttributeIndices","Object","defineProperties","prototype","get","ready","getCommonPerInstanceAttributeNames","instances","attributesInAllInstances","attributes0","attributes","name","hasOwnProperty","attribute","inAllInstances","i","otherAttribute","componentDatatype","componentsPerAttribute","normalize","push","scratchGetAttributeCartesian2","scratchGetAttributeCartesian3","scratchGetAttributeCartesian4","getAttributeValue","value","unpack","createBatchTable","primitive","context","numberOfInstances","names","attributeIndices","boundingSphereAttributeIndices","offset2DIndex","firstInstance","instanceAttributes","functionName","indexOf","FLOAT","center3DHigh","center3DLow","center2DHigh","center2DLow","radius","UNSIGNED_BYTE","attributesLength","batchTable","instance","j","attributeIndex","setBatchedAttribute","pickObject","pickPrimitive","id","pickId","createPickId","pickColor","color","x","floatToByte","red","y","green","z","blue","w","alpha","cloneAttribute","clonedValues","values","slice","constructor","cloneGeometry","geometry","newAttributes","property","indices","sourceValues","primitiveType","boundingSphere","cloneInstance","positionRegex","_modifyShaderPosition","vertexShaderSource","scene3DOnly","match","forwardDecl","computeFunctions","exec","toUpperCase","substr","replace","join","_appendShowToShader","renamedVS","replaceMain","showMain","_updateColorAttribute","isDepthFail","depthFailColor","search","modifiedVS","appendPickToVertexShader","source","pickMain","appendPickToFragmentShader","_updatePickColorAttribute","vsPick","_appendOffsetToShader","offset","attr","modifiedShader","str","_appendDistanceDisplayConditionToShader","distanceDisplayCondition","distanceDisplayConditionMain","modifyForEncodedNormals","containsNormal","containsSt","containsTangent","containsBitangent","numComponents","type","attributeName","attributeDecl","globalDecl","decode","stComponent","compressedMain","depthClampVS","depthClampFS","fragmentShaderSource","modifiedFS","validateShaderMatching","shaderProgram","attributeLocations","shaderAttributes","vertexAttributes","getUniformFunction","uniforms","numberOfCreationWorkers","Math","max","hardwareConcurrency","createGeometryTaskProcessors","combineGeometryTaskProcessor","loadAsynchronous","frameState","instanceIds","promises","subTasks","_workerName","_workerPath","moduleName","modulePath","subTask","packedLength","workerSubTasks","workerSubTasksLength","pack","subTaskTransferableObjects","array","Float64Array","buffer","scheduleTask","CREATING","Promise","all","then","results","CREATED","catch","error","setReady","FAILED","transferableObjects","projection","mapProjection","promise","packCombineGeometryParameters","createGeometryResults","ellipsoid","elementIndexUintSupported","elementIndexUint","createPickOffsets","COMBINING","resolve","packedResult","result","unpackCombineGeometryResults","geometries","pickOffsets","offsetInstanceExtend","boundingSpheres","boundingSpheresCV","COMBINED","loadSynchronous","clonedInstances","geometryIndex","createdGeometry","createGeometry","combineGeometry","recomputeBoundingSpheres","offsetIndex","newBoundingSpheres","newBS","getBatchedAttribute","transformBoundingSphere","combinedBS","combinedWestBS","combinedEastBS","bs","minX","center","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","resultBS1","resultBS2","resultBS3","union","projectTo2D","_updateBoundingVolumes","scratchBoundingSphereCenterEncoded","scratchBoundingSphereCartographic","scratchBoundingSphereCenter2D","scratchBoundingSphere","updateBatchTableBoundingSpheres","hasDistanceDisplayCondition","center3DHighIndex","center3DLowIndex","center2DHighIndex","center2DLowIndex","radiusIndex","transform","encodedCenter","fromCartesian","high","low","cartographic","cartesianToCartographic","center2D","project","offsetScratchCartesian","offsetCenterScratch","updateBatchTableOffsets","hasOffset","index2D","equals","ZERO","scaleToGeodeticSurface","newPoint","add","newPointProjected","newVector","subtract","createVertexArray","va","fromGeometry","bufferUsage","STATIC_DRAW","boundingSphereCV","COMPLETE","createRenderStates","twoPasses","renderState","getRenderState","rs","enabled","face","BACK","fromCache","FRONT","depthTest","func","GREATER","createShaderProgram","vs","getVertexShaderCallback","fs","getFragmentShaderSource","replaceCache","modifiedModelViewScratch","rtcScratch","getUniforms","material","materialUniformMap","_uniforms","appearanceUniformMap","appearanceUniforms","getUniformMapCallback","u_modifiedModelView","viewMatrix","uniformState","view","multiply","multiplyByPoint","setTranslation","createCommands","translucent","colorCommands","pickCommands","depthFailUniforms","pass","TRANSLUCENT","OPAQUE","multiplier","vaIndex","colorCommand","owner","vertexArray","uniformMap","forceUpdate","pixelSize","boundingSphereWC","pixelSizeInMeters","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","sizeInMeters","updateAndQueueCommands","mode","SCENE3D","COLUMBUS_VIEW","SCENE2D","commandList","passes","render","pick","castShadows","receiveShadows","colorLength","factor","sphereIndex","floor","boundingVolume","update","maximumVertexTextureImageUnits","createRS","createSP","depthFailMaterial","isTranslucent","closed","rsFunc","spFunc","commandFunc","updateAndQueueCommandsFunc","offsetBoundingSphereScratch1","offsetBoundingSphereScratch2","offsetAttribute","TOP","origBS","offsetBS","ALL","createGetFunction","instanceIndex","attributeValue","createTypedArray","createSetFunction","offsetScratch","createBoundingSphereProperties","properties","index","fromArray","createPickIdProperty","getGeometryInstanceAttributes","lastIndex","ids","curIndex","perInstanceAttributeIndices","set","isDestroyed","destroy","pickIds","state","afterRender"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Primitive.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * const ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *       radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *     })),\n *     modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *       Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *     id : 'ellipsoid',\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance(),\n *   asynchronous : false\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n  this._modelMatrix = new Matrix4();\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(\n    options.releaseGeometryInstances,\n    true,\n  );\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false,\n  );\n\n  /**\n   * @private\n   */\n  this.rtcCenter = options.rtcCenter;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(this.rtcCenter) &&\n    (!defined(this.geometryInstances) ||\n      (Array.isArray(this.geometryInstances) &&\n        this.geometryInstances.length !== 1))\n  ) {\n    throw new DeveloperError(\n      \"Relative-to-center rendering only supports one geometry instance.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n\n  this._translucent = undefined;\n\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = new Map();\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n\n  this._pickIds = [];\n\n  this._colorCommands = [];\n  this._pickCommands = [];\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n\n  this._createGeometryResults = undefined;\n  this._ready = false;\n\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @example\n   * // Wait for a primitive to become ready before accessing attributes\n   * const removeListener = scene.postRender.addEventListener(() => {\n   *   if (!frustumPrimitive.ready) {\n   *     return;\n   *   }\n   *\n   *   const attributes = primitive.getGeometryInstanceAttributes('an id');\n   *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n   *\n   *   removeListener();\n   * });\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  const length = instances.length;\n\n  const attributesInAllInstances = [];\n  const attributes0 = instances[0].attributes;\n  let name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      const attribute = attributes0[name];\n      let inAllInstances = true;\n\n      // Does this same attribute exist in all instances?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nconst scratchGetAttributeCartesian2 = new Cartesian2();\nconst scratchGetAttributeCartesian3 = new Cartesian3();\nconst scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  const componentsPerAttribute = value.length;\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  const geometryInstances = primitive.geometryInstances;\n  const instances = Array.isArray(geometryInstances)\n    ? geometryInstances\n    : [geometryInstances];\n  const numberOfInstances = instances.length;\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  const names = getCommonPerInstanceAttributeNames(instances);\n  const length = names.length;\n\n  const attributes = [];\n  const attributeIndices = {};\n  const boundingSphereAttributeIndices = {};\n  let offset2DIndex;\n\n  const firstInstance = instances[0];\n  let instanceAttributes = firstInstance.attributes;\n\n  let i;\n  let name;\n  let attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: `czm_batchTable_${name}`,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize,\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push(\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereRadius\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 1,\n      },\n    );\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true,\n  });\n\n  const attributesLength = attributes.length;\n  const batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    const instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (let j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      const value = getAttributeValue(attribute.value);\n      const attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    const pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive),\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    const pickId = context.createPickId(pickObject);\n    primitive._pickIds.push(pickId);\n\n    const pickColor = pickId.color;\n    const color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices =\n    boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  let clonedValues;\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues,\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const newAttributes = new GeometryAttributes();\n  for (const property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  let indices;\n  if (defined(geometry.indices)) {\n    const sourceValues = geometry.indices;\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere),\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id,\n  };\n}\n\nconst positionRegex = /in\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly,\n) {\n  let match;\n\n  let forwardDecl = \"\";\n  let attributes = \"\";\n  let computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    const name = match[1];\n\n    const functionName = `vec4 czm_compute${name[0].toUpperCase()}${name.substr(\n      1,\n    )}()`;\n\n    // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += `${functionName};\\n`;\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes += `in vec3 ${name}2DHigh;\\nin vec3 ${name}2DLow;\\n`;\n\n        computeFunctions +=\n          `${functionName}\\n` +\n          `{\\n` +\n          `    vec4 p;\\n` +\n          `    if (czm_morphTime == 1.0)\\n` +\n          `    {\\n` +\n          `        p = czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` +\n          `    }\\n` +\n          `    else if (czm_morphTime == 0.0)\\n` +\n          `    {\\n` +\n          `        p = czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy);\\n` +\n          `    }\\n` +\n          `    else\\n` +\n          `    {\\n` +\n          `        p = czm_columbusViewMorph(\\n` +\n          `                czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy),\\n` +\n          `                czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow),\\n` +\n          `                czm_morphTime);\\n` +\n          `    }\\n` +\n          `    return p;\\n` +\n          `}\\n\\n`;\n      } else {\n        computeFunctions +=\n          `${functionName}\\n` +\n          `{\\n` +\n          `    return czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` +\n          `}\\n\\n`;\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(\n        /in\\s+vec(?:3|4)\\s+position3DHigh;/g,\n        \"\",\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /in\\s+vec(?:3|4)\\s+position3DLow;/g,\n        \"\",\n      );\n\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"in vec4 position;\\n\";\n\n      computeFunctions +=\n        `${functionName}\\n` +\n        `{\\n` +\n        `    return u_modifiedModelView * position;\\n` +\n        `}\\n\\n`;\n\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewRelativeToEye\\s+\\*\\s+/g,\n        \"\",\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewProjectionRelativeToEye/g,\n        \"czm_projection\",\n      );\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\n    \"\\n\",\n  );\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_show_main\",\n  );\n  const showMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_show_main(); \\n\" +\n    \"    gl_Position *= czm_batchTable_show(batchId); \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${showMain}`;\n};\n\nPrimitive._updateColorAttribute = function (\n  primitive,\n  vertexShaderSource,\n  isDepthFail,\n) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (\n    !defined(primitive._batchTableAttributeIndices.color) &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/in\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isDepthFail &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    throw new DeveloperError(\n      \"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/in\\s+vec4\\s+color;/g, \"\");\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_color(batchId)$2\",\n    );\n  } else {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_depthFailColor(batchId)$2\",\n    );\n  }\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  const renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  const pickMain =\n    \"out vec4 v_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${pickMain}`;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return `in vec4 v_pickColor;\\n${source}`;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  let vsPick = source.replace(/in\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(\n    /(\\b)pickColor(\\b)/g,\n    \"$1czm_batchTable_pickColor(batchId)$2\",\n  );\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  let attr = \"in float batchId;\\n\";\n  attr += \"in float applyOffset;\";\n  let modifiedShader = vertexShaderSource.replace(\n    /in\\s+float\\s+batchId;/g,\n    attr,\n  );\n\n  let str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(\n    /vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g,\n    str,\n  );\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly,\n) {\n  if (\n    !defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)\n  ) {\n    return vertexShaderSource;\n  }\n\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_distanceDisplayCondition_main\",\n  );\n  let distanceDisplayConditionMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_distanceDisplayCondition_main(); \\n\" +\n    \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" +\n    \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain +=\n      \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" +\n      \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" +\n      \"    vec4 centerRTE;\\n\" +\n      \"    if (czm_morphTime == 1.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" +\n      \"    }\\n\" +\n      \"    else if (czm_morphTime == 0.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" +\n      \"    }\\n\" +\n      \"    else\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_columbusViewMorph(\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" +\n      \"                czm_morphTime);\\n\" +\n      \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain +=\n      \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain +=\n    \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" +\n    \"    float distanceSq; \\n\" +\n    \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    else \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    distanceSq = max(distanceSq, 0.0); \\n\" +\n    \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" +\n    \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" +\n    \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" +\n    \"    gl_Position *= show; \\n\" +\n    \"}\";\n  return `${renamedVS}\\n${distanceDisplayConditionMain}`;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  const containsNormal =\n    vertexShaderSource.search(/in\\s+vec3\\s+normal;/g) !== -1;\n  const containsSt = vertexShaderSource.search(/in\\s+vec2\\s+st;/g) !== -1;\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  const containsTangent =\n    vertexShaderSource.search(/in\\s+vec3\\s+tangent;/g) !== -1;\n  const containsBitangent =\n    vertexShaderSource.search(/in\\s+vec3\\s+bitangent;/g) !== -1;\n\n  let numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n\n  const type = numComponents > 1 ? `vec${numComponents}` : \"float\";\n\n  const attributeName = \"compressedAttributes\";\n  const attributeDecl = `in ${type} ${attributeName};`;\n\n  let globalDecl = \"\";\n  let decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    const stComponent =\n      numComponents > 1 ? `${attributeName}.x` : attributeName;\n    decode += `    st = czm_decompressTextureCoordinates(${stComponent});\\n`;\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode += `    czm_octDecode(${attributeName}.${\n      containsSt ? \"yz\" : \"xy\"\n    }, normal, tangent, bitangent);\\n`;\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode += `    normal = czm_octDecode(${attributeName}${\n        numComponents > 1 ? `.${containsSt ? \"y\" : \"x\"}` : \"\"\n      });\\n`;\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode += `    tangent = czm_octDecode(${attributeName}.${\n        containsSt && containsNormal ? \"z\" : \"y\"\n      });\\n`;\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode += `    bitangent = czm_octDecode(${attributeName}.${\n        containsSt && containsNormal ? \"z\" : \"y\"\n      });\\n`;\n    }\n  }\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  const compressedMain =\n    `${\"void main() \\n\" + \"{ \\n\"}${decode}    czm_non_compressed_main(); \\n` +\n    `}`;\n\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  let modifiedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_depth_clamp_main\",\n  );\n  modifiedVS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    gl_Position = czm_depthClamp(gl_Position);\" +\n    \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  let modifiedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_non_depth_clamp_main\",\n  );\n  modifiedFS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    #if defined(LOG_DEPTH)\\n\" +\n    \"        czm_writeLogDepth();\\n\" +\n    \"    #else\\n\" +\n    \"        czm_writeDepthClamp();\\n\" +\n    \"    #endif\\n\" +\n    \"}\\n\";\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  const shaderAttributes = shaderProgram.vertexAttributes;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (const name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\n          `Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`,\n        );\n      }\n    }\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nconst numberOfCreationWorkers = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1,\n);\nlet createGeometryTaskProcessors;\nconst combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\");\n\nfunction loadAsynchronous(primitive, frameState) {\n  let instances;\n  let geometry;\n  let i;\n  let j;\n\n  const instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n    const length = (primitive._numberOfInstances = instances.length);\n\n    const promises = [];\n    let subTasks = [];\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id);\n\n      //>>includeStart('debug', pragmas.debug);\n      if (\n        (defined(geometry._workerName) && defined(geometry._workerPath)) ||\n        (!defined(geometry._workerName) && !defined(geometry._workerPath))\n      ) {\n        throw new DeveloperError(\n          \"Must define either _workerName or _workerPath for asynchronous geometry.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        modulePath: geometry._workerPath,\n        geometry: geometry,\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\");\n      }\n    }\n\n    let subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      let packedLength = 0;\n      const workerSubTasks = subTasks[i];\n      const workerSubTasksLength = workerSubTasks.length;\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(\n            geometry.constructor.packedLength,\n            geometry.packedLength,\n          );\n        }\n      }\n\n      let subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        const array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(\n        createGeometryTaskProcessors[i].scheduleTask(\n          {\n            subTasks: subTasks[i],\n          },\n          subTaskTransferableObjects,\n        ),\n      );\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n\n    Promise.all(promises)\n      .then(function (results) {\n        primitive._createGeometryResults = results;\n        primitive._state = PrimitiveState.CREATED;\n      })\n      .catch(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    const transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n\n    const scene3DOnly = frameState.scene3DOnly;\n    const projection = frameState.mapProjection;\n\n    const promise = combineGeometryTaskProcessor.scheduleTask(\n      PrimitivePipeline.packCombineGeometryParameters(\n        {\n          createGeometryResults: primitive._createGeometryResults,\n          instances: instances,\n          ellipsoid: projection.ellipsoid,\n          projection: projection,\n          elementIndexUintSupported: frameState.context.elementIndexUint,\n          scene3DOnly: scene3DOnly,\n          vertexCacheOptimize: primitive.vertexCacheOptimize,\n          compressVertices: primitive.compressVertices,\n          modelMatrix: primitive.modelMatrix,\n          createPickOffsets: primitive._createPickOffsets,\n        },\n        transferableObjects,\n      ),\n      transferableObjects,\n    );\n\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n\n    Promise.resolve(promise)\n      .then(function (packedResult) {\n        const result =\n          PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n        primitive._geometries = result.geometries;\n        primitive._attributeLocations = result.attributeLocations;\n        primitive.modelMatrix = Matrix4.clone(\n          result.modelMatrix,\n          primitive.modelMatrix,\n        );\n        primitive._pickOffsets = result.pickOffsets;\n        primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n        primitive._instanceBoundingSpheres = result.boundingSpheres;\n        primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n        if (\n          defined(primitive._geometries) &&\n          primitive._geometries.length > 0\n        ) {\n          primitive._recomputeBoundingSpheres = true;\n          primitive._state = PrimitiveState.COMBINED;\n        } else {\n          setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n        }\n      })\n      .catch(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  const instances = Array.isArray(primitive.geometryInstances)\n    ? primitive.geometryInstances\n    : [primitive.geometryInstances];\n  const length = (primitive._numberOfInstances = instances.length);\n  const clonedInstances = new Array(length);\n  const instanceIds = primitive._instanceIds;\n\n  let instance;\n  let i;\n\n  let geometryIndex = 0;\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    const geometry = instance.geometry;\n\n    let createdGeometry;\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n\n  const scene3DOnly = frameState.scene3DOnly;\n  const projection = frameState.mapProjection;\n\n  const result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets,\n  });\n\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(\n    result.modelMatrix,\n    primitive.modelMatrix,\n  );\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  const offsetIndex = primitive._batchTableAttributeIndices.offset;\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  let i;\n  const offsetInstanceExtend = primitive._offsetInstanceExtend;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n  let newBoundingSpheres = primitive._tempBoundingSpheres;\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n  for (i = 0; i < length; ++i) {\n    let newBS = newBoundingSpheres[i];\n    const offset = primitive._batchTable.getBatchedAttribute(\n      i,\n      offsetIndex,\n      new Cartesian3(),\n    );\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n  const combinedBS = [];\n  const combinedWestBS = [];\n  const combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    const bs = newBoundingSpheres[i];\n\n    const minX = bs.center.x - bs.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  let resultBS1 = combinedBS[0];\n  let resultBS2 = combinedEastBS[0];\n  let resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n  const result = [];\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      primitive._boundingSphereCV[i],\n    );\n  }\n\n  Primitive._updateBoundingVolumes(\n    primitive,\n    frameState,\n    primitive.modelMatrix,\n    true,\n  );\n  primitive._recomputeBoundingSpheres = false;\n}\n\nconst scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nconst scratchBoundingSphereCartographic = new Cartographic();\nconst scratchBoundingSphereCenter2D = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  const hasDistanceDisplayCondition = defined(\n    primitive._batchTableAttributeIndices.distanceDisplayCondition,\n  );\n  if (\n    !hasDistanceDisplayCondition ||\n    primitive._batchTableBoundingSpheresUpdated\n  ) {\n    return;\n  }\n\n  const indices = primitive._batchTableBoundingSphereAttributeIndices;\n  const center3DHighIndex = indices.center3DHigh;\n  const center3DLowIndex = indices.center3DLow;\n  const center2DHighIndex = indices.center2DHigh;\n  const center2DLowIndex = indices.center2DLow;\n  const radiusIndex = indices.radius;\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere,\n      );\n    }\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let encodedCenter = EncodedCartesian3.fromCartesian(\n      center,\n      scratchBoundingSphereCenterEncoded,\n    );\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      const cartographic = ellipsoid.cartesianToCartographic(\n        center,\n        scratchBoundingSphereCartographic,\n      );\n      const center2D = projection.project(\n        cartographic,\n        scratchBoundingSphereCenter2D,\n      );\n      encodedCenter = EncodedCartesian3.fromCartesian(\n        center2D,\n        scratchBoundingSphereCenterEncoded,\n      );\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nconst offsetScratchCartesian = new Cartesian3();\nconst offsetCenterScratch = new Cartesian3();\nfunction updateBatchTableOffsets(primitive, frameState) {\n  const hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n  if (\n    !hasOffset ||\n    primitive._batchTableOffsetsUpdated ||\n    frameState.scene3DOnly\n  ) {\n    return;\n  }\n\n  const index2D = primitive._batchTableOffsetAttribute2DIndex;\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    const offset = batchTable.getBatchedAttribute(\n      i,\n      primitive._batchTableAttributeIndices.offset,\n    );\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere,\n      );\n    }\n\n    let center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    let cartographic = ellipsoid.cartesianToCartographic(\n      center,\n      scratchBoundingSphereCartographic,\n    );\n    const center2D = projection.project(\n      cartographic,\n      scratchBoundingSphereCenter2D,\n    );\n\n    const newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n\n    const newPointProjected = projection.project(\n      cartographic,\n      offsetScratchCartesian,\n    );\n\n    const newVector = Cartesian3.subtract(\n      newPointProjected,\n      center2D,\n      offsetScratchCartesian,\n    );\n\n    const x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  const attributeLocations = primitive._attributeLocations;\n  const geometries = primitive._geometries;\n  const scene3DOnly = frameState.scene3DOnly;\n  const context = frameState.context;\n\n  const va = [];\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    const geometry = geometries[i];\n\n    va.push(\n      VertexArray.fromGeometry({\n        context: context,\n        geometry: geometry,\n        attributeLocations: attributeLocations,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n        interleave: primitive._interleave,\n      }),\n    );\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(\n        BoundingSphere.clone(geometry.boundingSphere),\n      );\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        const center = geometry.boundingSphereCV.center;\n        const x = center.x;\n        const y = center.y;\n        const z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(\n          BoundingSphere.clone(geometry.boundingSphereCV),\n        );\n        primitive._boundingSphere2D.push(new BoundingSphere());\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  let renderState = appearance.getRenderState();\n  let rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK,\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  const context = frameState.context;\n\n  const attributeLocations = primitive._attributeLocations;\n\n  let vs = primitive._batchTable.getVertexShaderCallback()(\n    appearance.vertexShaderSource,\n  );\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vs,\n    frameState.scene3DOnly,\n  );\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  let fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(\n      primitive._depthFailAppearance.vertexShaderSource,\n    );\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(\n      primitive,\n      vs,\n      frameState.scene3DOnly,\n    );\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  const materialUniformMap = defined(material) ? material._uniforms : undefined;\n  const appearanceUniformMap = {};\n  const appearanceUniforms = appearance.uniforms;\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (const name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\n            `Appearance and material have a uniform with the same name: ${name}`,\n          );\n        }\n        //>>includeEnd('debug');\n\n        appearanceUniformMap[name] = getUniformFunction(\n          appearanceUniforms,\n          name,\n        );\n      }\n    }\n  }\n  let uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(\n        viewMatrix,\n        primitive._modelMatrix,\n        modifiedModelViewScratch,\n      );\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive.rtcCenter,\n        rtcScratch,\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch,\n      );\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(\n  primitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands,\n  frameState,\n) {\n  const uniforms = getUniforms(primitive, appearance, material, frameState);\n\n  let depthFailUniforms;\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(\n      primitive,\n      primitive._depthFailAppearance,\n      primitive._depthFailAppearance.material,\n      frameState,\n    );\n  }\n\n  const pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n  let multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n\n  const length = colorCommands.length;\n  let vaIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    let colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n\n        colorCommand = colorCommands[i];\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType,\n          });\n        }\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (\n  primitive,\n  frameState,\n  modelMatrix,\n  forceUpdate,\n) {\n  let i;\n  let length;\n  let boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(\n          boundingSphere,\n          modelMatrix,\n          primitive._boundingSphereWC[i],\n        );\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(\n            primitive._boundingSphereCV[i],\n            primitive._boundingSphere2D[i],\n          );\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(\n            primitive._boundingSphereWC[i],\n            primitive._boundingSphereCV[i],\n          );\n        }\n      }\n    }\n  }\n\n  // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n  const pixelSize = primitive.appearance.pixelSize;\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      const boundingSphereWC = primitive._boundingSphereWC[i];\n      const pixelSizeInMeters = frameState.camera.getPixelSize(\n        boundingSphere,\n        frameState.context.drawingBufferWidth,\n        frameState.context.drawingBufferHeight,\n      );\n      const sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(\n  primitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)\n  ) {\n    throw new DeveloperError(\n      \"Primitive.modelMatrix is only supported in 3D mode.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  const commandList = frameState.commandList;\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    const allowPicking = primitive.allowPicking;\n    const castShadows = ShadowMode.castShadows(primitive.shadows);\n    const receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    const colorLength = colorCommands.length;\n\n    let factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (let j = 0; j < colorLength; ++j) {\n      const sphereIndex = Math.floor(j / factor);\n      const colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPrimitive.prototype.update = function (frameState) {\n  if (\n    (!defined(this.geometryInstances) && this._va.length === 0) ||\n    (defined(this.geometryInstances) &&\n      Array.isArray(this.geometryInstances) &&\n      this.geometryInstances.length === 0) ||\n    !defined(this.appearance) ||\n    (frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly) ||\n    (!frameState.passes.render && !frameState.passes.pick)\n  ) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\n      \"RTC rendering is only available for 3D only scenes.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  const context = frameState.context;\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\",\n      );\n    }\n    this._batchTable.update(frameState);\n  }\n\n  if (\n    this._state !== PrimitiveState.COMPLETE &&\n    this._state !== PrimitiveState.COMBINED\n  ) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  }\n\n  // Create or recreate render state and shader program if appearance/material changed\n  const appearance = this.appearance;\n  const material = appearance.material;\n  let createRS = false;\n  let createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  const depthFailAppearance = this.depthFailAppearance;\n  const depthFailMaterial = defined(depthFailAppearance)\n    ? depthFailAppearance.material\n    : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  const translucent = this._appearance.isTranslucent();\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  const twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    const rsFunc = defaultValue(\n      this._createRenderStatesFunction,\n      createRenderStates,\n    );\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    const spFunc = defaultValue(\n      this._createShaderProgramFunction,\n      createShaderProgram,\n    );\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    const commandFunc = defaultValue(\n      this._createCommandsFunction,\n      createCommands,\n    );\n    commandFunc(\n      this,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      this._colorCommands,\n      this._pickCommands,\n      frameState,\n    );\n  }\n\n  const updateAndQueueCommandsFunc = defaultValue(\n    this._updateAndQueueCommandsFunction,\n    updateAndQueueCommands,\n  );\n  updateAndQueueCommandsFunc(\n    this,\n    frameState,\n    this._colorCommands,\n    this._pickCommands,\n    this.modelMatrix,\n    this.cull,\n    this.debugShowBoundingVolume,\n    twoPasses,\n  );\n};\n\nconst offsetBoundingSphereScratch1 = new BoundingSphere();\nconst offsetBoundingSphereScratch2 = new BoundingSphere();\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    const origBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch1,\n    );\n    const offsetBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch2,\n    );\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(\n      boundingSphere.center,\n      offset,\n      boundingSphere.center,\n    );\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    const attributeValue = batchTable.getBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n    );\n    const attribute = batchTable.attributes[attributeIndex];\n    const componentsPerAttribute = attribute.componentsPerAttribute;\n    const value = ComponentDatatype.createTypedArray(\n      attribute.componentDatatype,\n      componentsPerAttribute,\n    );\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n    return value;\n  };\n}\n\nfunction createSetFunction(\n  batchTable,\n  instanceIndex,\n  attributeIndex,\n  primitive,\n  name,\n) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(value) ||\n      !defined(value.length) ||\n      value.length < 1 ||\n      value.length > 4\n    ) {\n      throw new DeveloperError(\n        \"value must be and array with length between 1 and 4.\",\n      );\n    }\n    //>>includeEnd('debug');\n    const attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n      attributeValue,\n    );\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nconst offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      let boundingSphere = primitive._instanceBoundingSpheres[index];\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        const modelMatrix = primitive.modelMatrix;\n        const offset = properties.offset;\n        if (defined(offset)) {\n          transformBoundingSphere(\n            boundingSphere,\n            Cartesian3.fromArray(offset.get(), 0, offsetScratch),\n            primitive._offsetInstanceExtend[index],\n          );\n        }\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(\n            boundingSphere,\n            modelMatrix,\n          );\n        }\n      }\n\n      return boundingSphere;\n    },\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    },\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    },\n  };\n}\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let attributes = this._perInstanceAttributeCache.get(id);\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  let index = -1;\n  const lastIndex = this._lastPerInstanceAttributeIndex;\n  const ids = this._instanceIds;\n  const length = ids.length;\n  for (let i = 0; i < length; ++i) {\n    const curIndex = (lastIndex + i) % length;\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  const batchTable = this._batchTable;\n  const perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  const properties = {};\n\n  for (const name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      const attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name),\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache.set(id, attributes);\n  return attributes;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\nPrimitive.prototype.destroy = function () {\n  let length;\n  let i;\n\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n\n  const va = this._va;\n  length = va.length;\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n  this._va = undefined;\n\n  const pickIds = this._pickIds;\n  length = pickIds.length;\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  this._pickIds = undefined;\n\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready =\n      primitive._state === PrimitiveState.COMPLETE ||\n      primitive._state === PrimitiveState.FAILED;\n  });\n}\nexport default Primitive;\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,kBAAkB,MAAM,+BAA+B;AAC9D,OAAOC,uBAAuB,MAAM,oCAAoC;AACxE,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,IAAI,MAAM,qBAAqB;AACtC,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,YAAY,MAAM,6BAA6B;AACtD,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,UAAU,MAAM,iBAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,OAAO,EAAE;EAC1BA,OAAO,GAAGhC,YAAY,CAACgC,OAAO,EAAEhC,YAAY,CAACiC,YAAY,CAAC;;EAE1D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,iBAAiB,GAAGF,OAAO,CAACE,iBAAiB;;EAElD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGH,OAAO,CAACG,UAAU;EACpC,IAAI,CAACC,WAAW,GAAGC,SAAS;EAC5B,IAAI,CAACC,SAAS,GAAGD,SAAS;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACE,mBAAmB,GAAGP,OAAO,CAACO,mBAAmB;EACtD,IAAI,CAACC,oBAAoB,GAAGH,SAAS;EACrC,IAAI,CAACI,kBAAkB,GAAGJ,SAAS;;EAEnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}