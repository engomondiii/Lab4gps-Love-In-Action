{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPolylinePrimitive from \"../Scene/GroundPolylinePrimitive.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nconst scratchColor = new Color();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n// Encapsulates a Primitive and all the entities that it represents.\nfunction Batch(orderedGroundPrimitives, classificationType, materialProperty, zIndex, asynchronous) {\n  let appearanceType;\n  if (materialProperty instanceof ColorMaterialProperty) {\n    appearanceType = PolylineColorAppearance;\n  } else {\n    appearanceType = PolylineMaterialAppearance;\n  }\n  this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection\n  this.classificationType = classificationType;\n  this.appearanceType = appearanceType;\n  this.materialProperty = materialProperty;\n  this.updaters = new AssociativeArray();\n  this.createPrimitive = true;\n  this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.material = undefined;\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.invalidated = false;\n  this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.zIndex = zIndex;\n  this._asynchronous = asynchronous;\n}\nBatch.prototype.onMaterialChanged = function () {\n  this.invalidated = true;\n};\n\n// Check if the given updater's material is compatible with this batch\nBatch.prototype.isMaterial = function (updater) {\n  const material = this.materialProperty;\n  const updaterMaterial = updater.fillMaterialProperty;\n  if (updaterMaterial === material || updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty) {\n    return true;\n  }\n  return defined(material) && material.equals(updaterMaterial);\n};\nBatch.prototype.add = function (time, updater, geometryInstance) {\n  const id = updater.id;\n  this.updaters.set(id, updater);\n  this.geometry.set(id, geometryInstance);\n  // Updaters with dynamic attributes must be tracked separately, may exit the batch\n  if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    // Listen for show changes. These will be synchronized in updateShows.\n    this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function (entity, propertyName, newValue, oldValue) {\n      if (propertyName === \"isShowing\") {\n        that.showsUpdated.set(updater.id, updater);\n      }\n    }));\n  }\n  this.createPrimitive = true;\n};\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  let primitive = this.primitive;\n  const orderedGroundPrimitives = this.orderedGroundPrimitives;\n  const geometries = this.geometry.values;\n  let i;\n  if (this.createPrimitive) {\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          // For if the new primitive changes again before it is ready.\n          orderedGroundPrimitives.remove(primitive);\n        }\n      }\n      primitive = new GroundPolylinePrimitive({\n        show: false,\n        asynchronous: this._asynchronous,\n        geometryInstances: geometries.slice(),\n        appearance: new this.appearanceType(),\n        classificationType: this.classificationType\n      });\n      if (this.appearanceType === PolylineMaterialAppearance) {\n        this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n        primitive.appearance.material = this.material;\n      }\n      orderedGroundPrimitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        orderedGroundPrimitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        orderedGroundPrimitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      orderedGroundPrimitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n    if (this.appearanceType === PolylineMaterialAppearance) {\n      this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n      this.primitive.appearance.material = this.material;\n    }\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const entity = updater.entity;\n      const instance = this.geometry.get(updater.id);\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n      if (!updater.fillMaterialProperty.isConstant) {\n        const colorProperty = updater.fillMaterialProperty.color;\n        const resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, scratchColor);\n        if (!Color.equals(attributes._lastColor, resultColor)) {\n          attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n          attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n        }\n      }\n      const show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      }\n      const distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n        if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n          attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n          attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n        }\n      }\n    }\n    this.updateShows(primitive);\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  return isUpdated;\n};\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const entity = updater.entity;\n    const instance = this.geometry.get(updater.id);\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n    const show = entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (!defined(attributes) || !defined(attributes.boundingSphere) || defined(attributes.show) && attributes.show[0] === 0) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\nBatch.prototype.destroy = function () {\n  const primitive = this.primitive;\n  const orderedGroundPrimitives = this.orderedGroundPrimitives;\n  if (defined(primitive)) {\n    orderedGroundPrimitives.remove(primitive);\n  }\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    orderedGroundPrimitives.remove(oldPrimitive);\n  }\n  this.removeMaterialSubscription();\n};\n\n/**\n * @private\n */\nfunction StaticGroundPolylinePerMaterialBatch(orderedGroundPrimitives, classificationType, asynchronous) {\n  this._items = [];\n  this._orderedGroundPrimitives = orderedGroundPrimitives;\n  this._classificationType = classificationType;\n  this._asynchronous = defaultValue(asynchronous, true);\n}\nStaticGroundPolylinePerMaterialBatch.prototype.add = function (time, updater) {\n  const items = this._items;\n  const length = items.length;\n  const geometryInstance = updater.createFillGeometryInstance(time);\n  const zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.\n  for (let i = 0; i < length; ++i) {\n    const item = items[i];\n    if (item.isMaterial(updater) && item.zIndex === zIndex) {\n      item.add(time, updater, geometryInstance);\n      return;\n    }\n  }\n  // If a compatible batch wasn't found, create a new batch.\n  const batch = new Batch(this._orderedGroundPrimitives, this._classificationType, updater.fillMaterialProperty, zIndex, this._asynchronous);\n  batch.add(time, updater, geometryInstance);\n  items.push(batch);\n};\nStaticGroundPolylinePerMaterialBatch.prototype.remove = function (updater) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.remove(updater)) {\n      if (item.updaters.length === 0) {\n        items.splice(i, 1);\n        item.destroy();\n      }\n      break;\n    }\n  }\n};\nStaticGroundPolylinePerMaterialBatch.prototype.update = function (time) {\n  let i;\n  const items = this._items;\n  const length = items.length;\n  for (i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.invalidated) {\n      items.splice(i, 1);\n      const updaters = item.updaters.values;\n      const updatersLength = updaters.length;\n      for (let h = 0; h < updatersLength; h++) {\n        this.add(time, updaters[h]);\n      }\n      item.destroy();\n    }\n  }\n  let isUpdated = true;\n  for (i = 0; i < items.length; i++) {\n    isUpdated = items[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\nStaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function (updater, result) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const item = items[i];\n    if (item.contains(updater)) {\n      return item.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\nStaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives = function () {\n  const items = this._items;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    items[i].destroy();\n  }\n  this._items.length = 0;\n};\nexport default StaticGroundPolylinePerMaterialBatch;","map":{"version":3,"names":["AssociativeArray","Color","ColorGeometryInstanceAttribute","defaultValue","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","ShowGeometryInstanceAttribute","GroundPolylinePrimitive","PolylineColorAppearance","PolylineMaterialAppearance","BoundingSphereState","ColorMaterialProperty","MaterialProperty","Property","scratchColor","distanceDisplayConditionScratch","defaultDistanceDisplayCondition","Batch","orderedGroundPrimitives","classificationType","materialProperty","zIndex","asynchronous","appearanceType","updaters","createPrimitive","primitive","undefined","oldPrimitive","geometry","material","updatersWithAttributes","attributes","invalidated","removeMaterialSubscription","definitionChanged","addEventListener","prototype","onMaterialChanged","subscriptions","showsUpdated","_asynchronous","isMaterial","updater","updaterMaterial","fillMaterialProperty","equals","add","time","geometryInstance","id","set","hasConstantFill","isConstant","distanceDisplayConditionProperty","that","entity","propertyName","newValue","oldValue","remove","unsubscribe","get","update","isUpdated","geometries","values","i","geometriesLength","length","show","geometryInstances","slice","appearance","getValue","removeAll","ready","instance","getGeometryInstanceAttributes","colorProperty","color","resultColor","getValueOrDefault","WHITE","_lastColor","clone","toValue","isShowing","isFilled","currentShow","distanceDisplayCondition","_lastDistanceDisplayCondition","updateShows","value","contains","getBoundingSphere","result","PENDING","boundingSphere","FAILED","DONE","destroy","StaticGroundPolylinePerMaterialBatch","_items","_orderedGroundPrimitives","_classificationType","items","createFillGeometryInstance","item","batch","push","splice","updatersLength","h","removeAllPrimitives"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPolylinePrimitive from \"../Scene/GroundPolylinePrimitive.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nconst scratchColor = new Color();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n// Encapsulates a Primitive and all the entities that it represents.\nfunction Batch(\n  orderedGroundPrimitives,\n  classificationType,\n  materialProperty,\n  zIndex,\n  asynchronous,\n) {\n  let appearanceType;\n  if (materialProperty instanceof ColorMaterialProperty) {\n    appearanceType = PolylineColorAppearance;\n  } else {\n    appearanceType = PolylineMaterialAppearance;\n  }\n\n  this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection\n  this.classificationType = classificationType;\n  this.appearanceType = appearanceType;\n  this.materialProperty = materialProperty;\n  this.updaters = new AssociativeArray();\n  this.createPrimitive = true;\n  this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.material = undefined;\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.invalidated = false;\n  this.removeMaterialSubscription =\n    materialProperty.definitionChanged.addEventListener(\n      Batch.prototype.onMaterialChanged,\n      this,\n    );\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.zIndex = zIndex;\n\n  this._asynchronous = asynchronous;\n}\n\nBatch.prototype.onMaterialChanged = function () {\n  this.invalidated = true;\n};\n\n// Check if the given updater's material is compatible with this batch\nBatch.prototype.isMaterial = function (updater) {\n  const material = this.materialProperty;\n  const updaterMaterial = updater.fillMaterialProperty;\n\n  if (\n    updaterMaterial === material ||\n    (updaterMaterial instanceof ColorMaterialProperty &&\n      material instanceof ColorMaterialProperty)\n  ) {\n    return true;\n  }\n  return defined(material) && material.equals(updaterMaterial);\n};\n\nBatch.prototype.add = function (time, updater, geometryInstance) {\n  const id = updater.id;\n  this.updaters.set(id, updater);\n  this.geometry.set(id, geometryInstance);\n  // Updaters with dynamic attributes must be tracked separately, may exit the batch\n  if (\n    !updater.hasConstantFill ||\n    !updater.fillMaterialProperty.isConstant ||\n    !Property.isConstant(updater.distanceDisplayConditionProperty)\n  ) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    // Listen for show changes. These will be synchronized in updateShows.\n    this.subscriptions.set(\n      id,\n      updater.entity.definitionChanged.addEventListener(\n        function (entity, propertyName, newValue, oldValue) {\n          if (propertyName === \"isShowing\") {\n            that.showsUpdated.set(updater.id, updater);\n          }\n        },\n      ),\n    );\n  }\n  this.createPrimitive = true;\n};\n\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\n\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  let primitive = this.primitive;\n  const orderedGroundPrimitives = this.orderedGroundPrimitives;\n  const geometries = this.geometry.values;\n  let i;\n\n  if (this.createPrimitive) {\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          // For if the new primitive changes again before it is ready.\n          orderedGroundPrimitives.remove(primitive);\n        }\n      }\n\n      primitive = new GroundPolylinePrimitive({\n        show: false,\n        asynchronous: this._asynchronous,\n        geometryInstances: geometries.slice(),\n        appearance: new this.appearanceType(),\n        classificationType: this.classificationType,\n      });\n\n      if (this.appearanceType === PolylineMaterialAppearance) {\n        this.material = MaterialProperty.getValue(\n          time,\n          this.materialProperty,\n          this.material,\n        );\n        primitive.appearance.material = this.material;\n      }\n\n      orderedGroundPrimitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        orderedGroundPrimitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        orderedGroundPrimitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      orderedGroundPrimitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n\n    if (this.appearanceType === PolylineMaterialAppearance) {\n      this.material = MaterialProperty.getValue(\n        time,\n        this.materialProperty,\n        this.material,\n      );\n      this.primitive.appearance.material = this.material;\n    }\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const entity = updater.entity;\n      const instance = this.geometry.get(updater.id);\n\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n\n      if (!updater.fillMaterialProperty.isConstant) {\n        const colorProperty = updater.fillMaterialProperty.color;\n        const resultColor = Property.getValueOrDefault(\n          colorProperty,\n          time,\n          Color.WHITE,\n          scratchColor,\n        );\n        if (!Color.equals(attributes._lastColor, resultColor)) {\n          attributes._lastColor = Color.clone(\n            resultColor,\n            attributes._lastColor,\n          );\n          attributes.color = ColorGeometryInstanceAttribute.toValue(\n            resultColor,\n            attributes.color,\n          );\n        }\n      }\n\n      const show =\n        entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(\n          show,\n          attributes.show,\n        );\n      }\n\n      const distanceDisplayConditionProperty =\n        updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(\n          distanceDisplayConditionProperty,\n          time,\n          defaultDistanceDisplayCondition,\n          distanceDisplayConditionScratch,\n        );\n        if (\n          !DistanceDisplayCondition.equals(\n            distanceDisplayCondition,\n            attributes._lastDistanceDisplayCondition,\n          )\n        ) {\n          attributes._lastDistanceDisplayCondition =\n            DistanceDisplayCondition.clone(\n              distanceDisplayCondition,\n              attributes._lastDistanceDisplayCondition,\n            );\n          attributes.distanceDisplayCondition =\n            DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n              distanceDisplayCondition,\n              attributes.distanceDisplayCondition,\n            );\n        }\n      }\n    }\n\n    this.updateShows(primitive);\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  return isUpdated;\n};\n\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const entity = updater.entity;\n    const instance = this.geometry.get(updater.id);\n\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n\n    const show = entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        show,\n        attributes.show,\n      );\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\n\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\n\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (\n    !defined(attributes) ||\n    !defined(attributes.boundingSphere) ||\n    (defined(attributes.show) && attributes.show[0] === 0)\n  ) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\n\nBatch.prototype.destroy = function () {\n  const primitive = this.primitive;\n  const orderedGroundPrimitives = this.orderedGroundPrimitives;\n  if (defined(primitive)) {\n    orderedGroundPrimitives.remove(primitive);\n  }\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    orderedGroundPrimitives.remove(oldPrimitive);\n  }\n  this.removeMaterialSubscription();\n};\n\n/**\n * @private\n */\nfunction StaticGroundPolylinePerMaterialBatch(\n  orderedGroundPrimitives,\n  classificationType,\n  asynchronous,\n) {\n  this._items = [];\n  this._orderedGroundPrimitives = orderedGroundPrimitives;\n  this._classificationType = classificationType;\n  this._asynchronous = defaultValue(asynchronous, true);\n}\n\nStaticGroundPolylinePerMaterialBatch.prototype.add = function (time, updater) {\n  const items = this._items;\n  const length = items.length;\n  const geometryInstance = updater.createFillGeometryInstance(time);\n  const zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.\n  for (let i = 0; i < length; ++i) {\n    const item = items[i];\n    if (item.isMaterial(updater) && item.zIndex === zIndex) {\n      item.add(time, updater, geometryInstance);\n      return;\n    }\n  }\n  // If a compatible batch wasn't found, create a new batch.\n  const batch = new Batch(\n    this._orderedGroundPrimitives,\n    this._classificationType,\n    updater.fillMaterialProperty,\n    zIndex,\n    this._asynchronous,\n  );\n  batch.add(time, updater, geometryInstance);\n  items.push(batch);\n};\n\nStaticGroundPolylinePerMaterialBatch.prototype.remove = function (updater) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.remove(updater)) {\n      if (item.updaters.length === 0) {\n        items.splice(i, 1);\n        item.destroy();\n      }\n      break;\n    }\n  }\n};\n\nStaticGroundPolylinePerMaterialBatch.prototype.update = function (time) {\n  let i;\n  const items = this._items;\n  const length = items.length;\n\n  for (i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.invalidated) {\n      items.splice(i, 1);\n      const updaters = item.updaters.values;\n      const updatersLength = updaters.length;\n      for (let h = 0; h < updatersLength; h++) {\n        this.add(time, updaters[h]);\n      }\n      item.destroy();\n    }\n  }\n\n  let isUpdated = true;\n  for (i = 0; i < items.length; i++) {\n    isUpdated = items[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\n\nStaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function (\n  updater,\n  result,\n) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const item = items[i];\n    if (item.contains(updater)) {\n      return item.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\n\nStaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives =\n  function () {\n    const items = this._items;\n    const length = items.length;\n    for (let i = 0; i < length; i++) {\n      items[i].destroy();\n    }\n    this._items.length = 0;\n  };\nexport default StaticGroundPolylinePerMaterialBatch;\n"],"mappings":"AAAA,OAAOA,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,8BAA8B,MAAM,2CAA2C;AACtF,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,wBAAwB,MAAM,qCAAqC;AAC1E,OAAOC,iDAAiD,MAAM,8DAA8D;AAC5H,OAAOC,6BAA6B,MAAM,0CAA0C;AACpF,OAAOC,uBAAuB,MAAM,qCAAqC;AACzE,OAAOC,uBAAuB,MAAM,qCAAqC;AACzE,OAAOC,0BAA0B,MAAM,wCAAwC;AAC/E,OAAOC,mBAAmB,MAAM,0BAA0B;AAC1D,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,QAAQ,MAAM,eAAe;AAEpC,MAAMC,YAAY,GAAG,IAAId,KAAK,CAAC,CAAC;AAChC,MAAMe,+BAA+B,GAAG,IAAIX,wBAAwB,CAAC,CAAC;AACtE,MAAMY,+BAA+B,GAAG,IAAIZ,wBAAwB,CAAC,CAAC;;AAEtE;AACA,SAASa,KAAKA,CACZC,uBAAuB,EACvBC,kBAAkB,EAClBC,gBAAgB,EAChBC,MAAM,EACNC,YAAY,EACZ;EACA,IAAIC,cAAc;EAClB,IAAIH,gBAAgB,YAAYT,qBAAqB,EAAE;IACrDY,cAAc,GAAGf,uBAAuB;EAC1C,CAAC,MAAM;IACLe,cAAc,GAAGd,0BAA0B;EAC7C;EAEA,IAAI,CAACS,uBAAuB,GAAGA,uBAAuB,CAAC,CAAC;EACxD,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;EAC5C,IAAI,CAACI,cAAc,GAAGA,cAAc;EACpC,IAAI,CAACH,gBAAgB,GAAGA,gBAAgB;EACxC,IAAI,CAACI,QAAQ,GAAG,IAAIzB,gBAAgB,CAAC,CAAC;EACtC,IAAI,CAAC0B,eAAe,GAAG,IAAI;EAC3B,IAAI,CAACC,SAAS,GAAGC,SAAS,CAAC,CAAC;EAC5B,IAAI,CAACC,YAAY,GAAGD,SAAS;EAC7B,IAAI,CAACE,QAAQ,GAAG,IAAI9B,gBAAgB,CAAC,CAAC;EACtC,IAAI,CAAC+B,QAAQ,GAAGH,SAAS;EACzB,IAAI,CAACI,sBAAsB,GAAG,IAAIhC,gBAAgB,CAAC,CAAC;EACpD,IAAI,CAACiC,UAAU,GAAG,IAAIjC,gBAAgB,CAAC,CAAC;EACxC,IAAI,CAACkC,WAAW,GAAG,KAAK;EACxB,IAAI,CAACC,0BAA0B,GAC7Bd,gBAAgB,CAACe,iBAAiB,CAACC,gBAAgB,CACjDnB,KAAK,CAACoB,SAAS,CAACC,iBAAiB,EACjC,IACF,CAAC;EACH,IAAI,CAACC,aAAa,GAAG,IAAIxC,gBAAgB,CAAC,CAAC;EAC3C,IAAI,CAACyC,YAAY,GAAG,IAAIzC,gBAAgB,CAAC,CAAC;EAC1C,IAAI,CAACsB,MAAM,GAAGA,MAAM;EAEpB,IAAI,CAACoB,aAAa,GAAGnB,YAAY;AACnC;AAEAL,KAAK,CAACoB,SAAS,CAACC,iBAAiB,GAAG,YAAY;EAC9C,IAAI,CAACL,WAAW,GAAG,IAAI;AACzB,CAAC;;AAED;AACAhB,KAAK,CAACoB,SAAS,CAACK,UAAU,GAAG,UAAUC,OAAO,EAAE;EAC9C,MAAMb,QAAQ,GAAG,IAAI,CAACV,gBAAgB;EACtC,MAAMwB,eAAe,GAAGD,OAAO,CAACE,oBAAoB;EAEpD,IACED,eAAe,KAAKd,QAAQ,IAC3Bc,eAAe,YAAYjC,qBAAqB,IAC/CmB,QAAQ,YAAYnB,qBAAsB,EAC5C;IACA,OAAO,IAAI;EACb;EACA,OAAOR,OAAO,CAAC2B,QAAQ,CAAC,IAAIA,QAAQ,CAACgB,MAAM,CAACF,eAAe,CAAC;AAC9D,CAAC;AAED3B,KAAK,CAACoB,SAAS,CAACU,GAAG,GAAG,UAAUC,IAAI,EAAEL,OAAO,EAAEM,gBAAgB,EAAE;EAC/D,MAAMC,EAAE,GAAGP,OAAO,CAACO,EAAE;EACrB,IAAI,CAAC1B,QAAQ,CAAC2B,GAAG,CAACD,EAAE,EAAEP,OAAO,CAAC;EAC9B,IAAI,CAACd,QAAQ,CAACsB,GAAG,CAACD,EAAE,EAAED,gBAAgB,CAAC;EACvC;EACA,IACE,CAACN,OAAO,CAACS,eAAe,IACxB,CAACT,OAAO,CAACE,oBAAoB,CAACQ,UAAU,IACxC,CAACxC,QAAQ,CAACwC,UAAU,CAACV,OAAO,CAACW,gCAAgC,CAAC,EAC9D;IACA,IAAI,CAACvB,sBAAsB,CAACoB,GAAG,CAACD,EAAE,EAAEP,OAAO,CAAC;EAC9C,CAAC,MAAM;IACL,MAAMY,IAAI,GAAG,IAAI;IACjB;IACA,IAAI,CAAChB,aAAa,CAACY,GAAG,CACpBD,EAAE,EACFP,OAAO,CAACa,MAAM,CAACrB,iBAAiB,CAACC,gBAAgB,CAC/C,UAAUoB,MAAM,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;MAClD,IAAIF,YAAY,KAAK,WAAW,EAAE;QAChCF,IAAI,CAACf,YAAY,CAACW,GAAG,CAACR,OAAO,CAACO,EAAE,EAAEP,OAAO,CAAC;MAC5C;IACF,CACF,CACF,CAAC;EACH;EACA,IAAI,CAAClB,eAAe,GAAG,IAAI;AAC7B,CAAC;AAEDR,KAAK,CAACoB,SAAS,CAACuB,MAAM,GAAG,UAAUjB,OAAO,EAAE;EAC1C,MAAMO,EAAE,GAAGP,OAAO,CAACO,EAAE;EACrB,IAAI,CAACzB,eAAe,GAAG,IAAI,CAACI,QAAQ,CAAC+B,MAAM,CAACV,EAAE,CAAC,IAAI,IAAI,CAACzB,eAAe;EACvE,IAAI,IAAI,CAACD,QAAQ,CAACoC,MAAM,CAACV,EAAE,CAAC,EAAE;IAC5B,IAAI,CAACnB,sBAAsB,CAAC6B,MAAM,CAACV,EAAE,CAAC;IACtC,MAAMW,WAAW,GAAG,IAAI,CAACtB,aAAa,CAACuB,GAAG,CAACZ,EAAE,CAAC;IAC9C,IAAI/C,OAAO,CAAC0D,WAAW,CAAC,EAAE;MACxBA,WAAW,CAAC,CAAC;MACb,IAAI,CAACtB,aAAa,CAACqB,MAAM,CAACV,EAAE,CAAC;IAC/B;IACA,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd,CAAC;AAEDjC,KAAK,CAACoB,SAAS,CAAC0B,MAAM,GAAG,UAAUf,IAAI,EAAE;EACvC,IAAIgB,SAAS,GAAG,IAAI;EACpB,IAAItC,SAAS,GAAG,IAAI,CAACA,SAAS;EAC9B,MAAMR,uBAAuB,GAAG,IAAI,CAACA,uBAAuB;EAC5D,MAAM+C,UAAU,GAAG,IAAI,CAACpC,QAAQ,CAACqC,MAAM;EACvC,IAAIC,CAAC;EAEL,IAAI,IAAI,CAAC1C,eAAe,EAAE;IACxB,MAAM2C,gBAAgB,GAAGH,UAAU,CAACI,MAAM;IAC1C,IAAID,gBAAgB,GAAG,CAAC,EAAE;MACxB,IAAIjE,OAAO,CAACuB,SAAS,CAAC,EAAE;QACtB;QACA,IAAI,CAACvB,OAAO,CAAC,IAAI,CAACyB,YAAY,CAAC,EAAE;UAC/B,IAAI,CAACA,YAAY,GAAGF,SAAS;QAC/B,CAAC,MAAM;UACL;UACAR,uBAAuB,CAAC0C,MAAM,CAAClC,SAAS,CAAC;QAC3C;MACF;MAEAA,SAAS,GAAG,IAAInB,uBAAuB,CAAC;QACtC+D,IAAI,EAAE,KAAK;QACXhD,YAAY,EAAE,IAAI,CAACmB,aAAa;QAChC8B,iBAAiB,EAAEN,UAAU,CAACO,KAAK,CAAC,CAAC;QACrCC,UAAU,EAAE,IAAI,IAAI,CAAClD,cAAc,CAAC,CAAC;QACrCJ,kBAAkB,EAAE,IAAI,CAACA;MAC3B,CAAC,CAAC;MAEF,IAAI,IAAI,CAACI,cAAc,KAAKd,0BAA0B,EAAE;QACtD,IAAI,CAACqB,QAAQ,GAAGlB,gBAAgB,CAAC8D,QAAQ,CACvC1B,IAAI,EACJ,IAAI,CAAC5B,gBAAgB,EACrB,IAAI,CAACU,QACP,CAAC;QACDJ,SAAS,CAAC+C,UAAU,CAAC3C,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAC/C;MAEAZ,uBAAuB,CAAC6B,GAAG,CAACrB,SAAS,EAAE,IAAI,CAACL,MAAM,CAAC;MACnD2C,SAAS,GAAG,KAAK;IACnB,CAAC,MAAM;MACL,IAAI7D,OAAO,CAACuB,SAAS,CAAC,EAAE;QACtBR,uBAAuB,CAAC0C,MAAM,CAAClC,SAAS,CAAC;QACzCA,SAAS,GAAGC,SAAS;MACvB;MACA,MAAMC,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,IAAIzB,OAAO,CAACyB,YAAY,CAAC,EAAE;QACzBV,uBAAuB,CAAC0C,MAAM,CAAChC,YAAY,CAAC;QAC5C,IAAI,CAACA,YAAY,GAAGD,SAAS;MAC/B;IACF;IAEA,IAAI,CAACK,UAAU,CAAC2C,SAAS,CAAC,CAAC;IAC3B,IAAI,CAACjD,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACD,eAAe,GAAG,KAAK;EAC9B,CAAC,MAAM,IAAItB,OAAO,CAACuB,SAAS,CAAC,IAAIA,SAAS,CAACkD,KAAK,EAAE;IAChDlD,SAAS,CAAC4C,IAAI,GAAG,IAAI;IACrB,IAAInE,OAAO,CAAC,IAAI,CAACyB,YAAY,CAAC,EAAE;MAC9BV,uBAAuB,CAAC0C,MAAM,CAAC,IAAI,CAAChC,YAAY,CAAC;MACjD,IAAI,CAACA,YAAY,GAAGD,SAAS;IAC/B;IAEA,IAAI,IAAI,CAACJ,cAAc,KAAKd,0BAA0B,EAAE;MACtD,IAAI,CAACqB,QAAQ,GAAGlB,gBAAgB,CAAC8D,QAAQ,CACvC1B,IAAI,EACJ,IAAI,CAAC5B,gBAAgB,EACrB,IAAI,CAACU,QACP,CAAC;MACD,IAAI,CAACJ,SAAS,CAAC+C,UAAU,CAAC3C,QAAQ,GAAG,IAAI,CAACA,QAAQ;IACpD;IACA,MAAMC,sBAAsB,GAAG,IAAI,CAACA,sBAAsB,CAACmC,MAAM;IACjE,MAAMG,MAAM,GAAGtC,sBAAsB,CAACsC,MAAM;IAC5C,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC3B,MAAMxB,OAAO,GAAGZ,sBAAsB,CAACoC,CAAC,CAAC;MACzC,MAAMX,MAAM,GAAGb,OAAO,CAACa,MAAM;MAC7B,MAAMqB,QAAQ,GAAG,IAAI,CAAChD,QAAQ,CAACiC,GAAG,CAACnB,OAAO,CAACO,EAAE,CAAC;MAE9C,IAAIlB,UAAU,GAAG,IAAI,CAACA,UAAU,CAAC8B,GAAG,CAACe,QAAQ,CAAC3B,EAAE,CAACA,EAAE,CAAC;MACpD,IAAI,CAAC/C,OAAO,CAAC6B,UAAU,CAAC,EAAE;QACxBA,UAAU,GAAGN,SAAS,CAACoD,6BAA6B,CAACD,QAAQ,CAAC3B,EAAE,CAAC;QACjE,IAAI,CAAClB,UAAU,CAACmB,GAAG,CAAC0B,QAAQ,CAAC3B,EAAE,CAACA,EAAE,EAAElB,UAAU,CAAC;MACjD;MAEA,IAAI,CAACW,OAAO,CAACE,oBAAoB,CAACQ,UAAU,EAAE;QAC5C,MAAM0B,aAAa,GAAGpC,OAAO,CAACE,oBAAoB,CAACmC,KAAK;QACxD,MAAMC,WAAW,GAAGpE,QAAQ,CAACqE,iBAAiB,CAC5CH,aAAa,EACb/B,IAAI,EACJhD,KAAK,CAACmF,KAAK,EACXrE,YACF,CAAC;QACD,IAAI,CAACd,KAAK,CAAC8C,MAAM,CAACd,UAAU,CAACoD,UAAU,EAAEH,WAAW,CAAC,EAAE;UACrDjD,UAAU,CAACoD,UAAU,GAAGpF,KAAK,CAACqF,KAAK,CACjCJ,WAAW,EACXjD,UAAU,CAACoD,UACb,CAAC;UACDpD,UAAU,CAACgD,KAAK,GAAG/E,8BAA8B,CAACqF,OAAO,CACvDL,WAAW,EACXjD,UAAU,CAACgD,KACb,CAAC;QACH;MACF;MAEA,MAAMV,IAAI,GACRd,MAAM,CAAC+B,SAAS,KAAK5C,OAAO,CAACS,eAAe,IAAIT,OAAO,CAAC6C,QAAQ,CAACxC,IAAI,CAAC,CAAC;MACzE,MAAMyC,WAAW,GAAGzD,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;MAC5C,IAAIA,IAAI,KAAKmB,WAAW,EAAE;QACxBzD,UAAU,CAACsC,IAAI,GAAGhE,6BAA6B,CAACgF,OAAO,CACrDhB,IAAI,EACJtC,UAAU,CAACsC,IACb,CAAC;MACH;MAEA,MAAMhB,gCAAgC,GACpCX,OAAO,CAACW,gCAAgC;MAC1C,IAAI,CAACzC,QAAQ,CAACwC,UAAU,CAACC,gCAAgC,CAAC,EAAE;QAC1D,MAAMoC,wBAAwB,GAAG7E,QAAQ,CAACqE,iBAAiB,CACzD5B,gCAAgC,EAChCN,IAAI,EACJhC,+BAA+B,EAC/BD,+BACF,CAAC;QACD,IACE,CAACX,wBAAwB,CAAC0C,MAAM,CAC9B4C,wBAAwB,EACxB1D,UAAU,CAAC2D,6BACb,CAAC,EACD;UACA3D,UAAU,CAAC2D,6BAA6B,GACtCvF,wBAAwB,CAACiF,KAAK,CAC5BK,wBAAwB,EACxB1D,UAAU,CAAC2D,6BACb,CAAC;UACH3D,UAAU,CAAC0D,wBAAwB,GACjCrF,iDAAiD,CAACiF,OAAO,CACvDI,wBAAwB,EACxB1D,UAAU,CAAC0D,wBACb,CAAC;QACL;MACF;IACF;IAEA,IAAI,CAACE,WAAW,CAAClE,SAAS,CAAC;EAC7B,CAAC,MAAM,IAAIvB,OAAO,CAACuB,SAAS,CAAC,IAAI,CAACA,SAAS,CAACkD,KAAK,EAAE;IACjDZ,SAAS,GAAG,KAAK;EACnB;EACA,OAAOA,SAAS;AAClB,CAAC;AAED/C,KAAK,CAACoB,SAAS,CAACuD,WAAW,GAAG,UAAUlE,SAAS,EAAE;EACjD,MAAMc,YAAY,GAAG,IAAI,CAACA,YAAY,CAAC0B,MAAM;EAC7C,MAAMG,MAAM,GAAG7B,YAAY,CAAC6B,MAAM;EAClC,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAEF,CAAC,EAAE,EAAE;IAC/B,MAAMxB,OAAO,GAAGH,YAAY,CAAC2B,CAAC,CAAC;IAC/B,MAAMX,MAAM,GAAGb,OAAO,CAACa,MAAM;IAC7B,MAAMqB,QAAQ,GAAG,IAAI,CAAChD,QAAQ,CAACiC,GAAG,CAACnB,OAAO,CAACO,EAAE,CAAC;IAE9C,IAAIlB,UAAU,GAAG,IAAI,CAACA,UAAU,CAAC8B,GAAG,CAACe,QAAQ,CAAC3B,EAAE,CAACA,EAAE,CAAC;IACpD,IAAI,CAAC/C,OAAO,CAAC6B,UAAU,CAAC,EAAE;MACxBA,UAAU,GAAGN,SAAS,CAACoD,6BAA6B,CAACD,QAAQ,CAAC3B,EAAE,CAAC;MACjE,IAAI,CAAClB,UAAU,CAACmB,GAAG,CAAC0B,QAAQ,CAAC3B,EAAE,CAACA,EAAE,EAAElB,UAAU,CAAC;IACjD;IAEA,MAAMsC,IAAI,GAAGd,MAAM,CAAC+B,SAAS;IAC7B,MAAME,WAAW,GAAGzD,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;IAC5C,IAAIA,IAAI,KAAKmB,WAAW,EAAE;MACxBzD,UAAU,CAACsC,IAAI,GAAGhE,6BAA6B,CAACgF,OAAO,CACrDhB,IAAI,EACJtC,UAAU,CAACsC,IACb,CAAC;MACDO,QAAQ,CAAC7C,UAAU,CAACsC,IAAI,CAACuB,KAAK,CAAC,CAAC,CAAC,GAAG7D,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC;IACxD;EACF;EACA,IAAI,CAAC9B,YAAY,CAACmC,SAAS,CAAC,CAAC;AAC/B,CAAC;AAED1D,KAAK,CAACoB,SAAS,CAACyD,QAAQ,GAAG,UAAUnD,OAAO,EAAE;EAC5C,OAAO,IAAI,CAACnB,QAAQ,CAACsE,QAAQ,CAACnD,OAAO,CAACO,EAAE,CAAC;AAC3C,CAAC;AAEDjC,KAAK,CAACoB,SAAS,CAAC0D,iBAAiB,GAAG,UAAUpD,OAAO,EAAEqD,MAAM,EAAE;EAC7D,MAAMtE,SAAS,GAAG,IAAI,CAACA,SAAS;EAChC,IAAI,CAACA,SAAS,CAACkD,KAAK,EAAE;IACpB,OAAOlE,mBAAmB,CAACuF,OAAO;EACpC;EACA,MAAMjE,UAAU,GAAGN,SAAS,CAACoD,6BAA6B,CAACnC,OAAO,CAACa,MAAM,CAAC;EAC1E,IACE,CAACrD,OAAO,CAAC6B,UAAU,CAAC,IACpB,CAAC7B,OAAO,CAAC6B,UAAU,CAACkE,cAAc,CAAC,IAClC/F,OAAO,CAAC6B,UAAU,CAACsC,IAAI,CAAC,IAAItC,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAE,EACtD;IACA,OAAO5D,mBAAmB,CAACyF,MAAM;EACnC;EACAnE,UAAU,CAACkE,cAAc,CAACb,KAAK,CAACW,MAAM,CAAC;EACvC,OAAOtF,mBAAmB,CAAC0F,IAAI;AACjC,CAAC;AAEDnF,KAAK,CAACoB,SAAS,CAACgE,OAAO,GAAG,YAAY;EACpC,MAAM3E,SAAS,GAAG,IAAI,CAACA,SAAS;EAChC,MAAMR,uBAAuB,GAAG,IAAI,CAACA,uBAAuB;EAC5D,IAAIf,OAAO,CAACuB,SAAS,CAAC,EAAE;IACtBR,uBAAuB,CAAC0C,MAAM,CAAClC,SAAS,CAAC;EAC3C;EACA,MAAME,YAAY,GAAG,IAAI,CAACA,YAAY;EACtC,IAAIzB,OAAO,CAACyB,YAAY,CAAC,EAAE;IACzBV,uBAAuB,CAAC0C,MAAM,CAAChC,YAAY,CAAC;EAC9C;EACA,IAAI,CAACM,0BAA0B,CAAC,CAAC;AACnC,CAAC;;AAED;AACA;AACA;AACA,SAASoE,oCAAoCA,CAC3CpF,uBAAuB,EACvBC,kBAAkB,EAClBG,YAAY,EACZ;EACA,IAAI,CAACiF,MAAM,GAAG,EAAE;EAChB,IAAI,CAACC,wBAAwB,GAAGtF,uBAAuB;EACvD,IAAI,CAACuF,mBAAmB,GAAGtF,kBAAkB;EAC7C,IAAI,CAACsB,aAAa,GAAGvC,YAAY,CAACoB,YAAY,EAAE,IAAI,CAAC;AACvD;AAEAgF,oCAAoC,CAACjE,SAAS,CAACU,GAAG,GAAG,UAAUC,IAAI,EAAEL,OAAO,EAAE;EAC5E,MAAM+D,KAAK,GAAG,IAAI,CAACH,MAAM;EACzB,MAAMlC,MAAM,GAAGqC,KAAK,CAACrC,MAAM;EAC3B,MAAMpB,gBAAgB,GAAGN,OAAO,CAACgE,0BAA0B,CAAC3D,IAAI,CAAC;EACjE,MAAM3B,MAAM,GAAGR,QAAQ,CAACqE,iBAAiB,CAACvC,OAAO,CAACtB,MAAM,EAAE,CAAC,CAAC;EAC5D;EACA,KAAK,IAAI8C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAE,EAAEF,CAAC,EAAE;IAC/B,MAAMyC,IAAI,GAAGF,KAAK,CAACvC,CAAC,CAAC;IACrB,IAAIyC,IAAI,CAAClE,UAAU,CAACC,OAAO,CAAC,IAAIiE,IAAI,CAACvF,MAAM,KAAKA,MAAM,EAAE;MACtDuF,IAAI,CAAC7D,GAAG,CAACC,IAAI,EAAEL,OAAO,EAAEM,gBAAgB,CAAC;MACzC;IACF;EACF;EACA;EACA,MAAM4D,KAAK,GAAG,IAAI5F,KAAK,CACrB,IAAI,CAACuF,wBAAwB,EAC7B,IAAI,CAACC,mBAAmB,EACxB9D,OAAO,CAACE,oBAAoB,EAC5BxB,MAAM,EACN,IAAI,CAACoB,aACP,CAAC;EACDoE,KAAK,CAAC9D,GAAG,CAACC,IAAI,EAAEL,OAAO,EAAEM,gBAAgB,CAAC;EAC1CyD,KAAK,CAACI,IAAI,CAACD,KAAK,CAAC;AACnB,CAAC;AAEDP,oCAAoC,CAACjE,SAAS,CAACuB,MAAM,GAAG,UAAUjB,OAAO,EAAE;EACzE,MAAM+D,KAAK,GAAG,IAAI,CAACH,MAAM;EACzB,MAAMlC,MAAM,GAAGqC,KAAK,CAACrC,MAAM;EAC3B,KAAK,IAAIF,CAAC,GAAGE,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACpC,MAAMyC,IAAI,GAAGF,KAAK,CAACvC,CAAC,CAAC;IACrB,IAAIyC,IAAI,CAAChD,MAAM,CAACjB,OAAO,CAAC,EAAE;MACxB,IAAIiE,IAAI,CAACpF,QAAQ,CAAC6C,MAAM,KAAK,CAAC,EAAE;QAC9BqC,KAAK,CAACK,MAAM,CAAC5C,CAAC,EAAE,CAAC,CAAC;QAClByC,IAAI,CAACP,OAAO,CAAC,CAAC;MAChB;MACA;IACF;EACF;AACF,CAAC;AAEDC,oCAAoC,CAACjE,SAAS,CAAC0B,MAAM,GAAG,UAAUf,IAAI,EAAE;EACtE,IAAImB,CAAC;EACL,MAAMuC,KAAK,GAAG,IAAI,CAACH,MAAM;EACzB,MAAMlC,MAAM,GAAGqC,KAAK,CAACrC,MAAM;EAE3B,KAAKF,CAAC,GAAGE,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAChC,MAAMyC,IAAI,GAAGF,KAAK,CAACvC,CAAC,CAAC;IACrB,IAAIyC,IAAI,CAAC3E,WAAW,EAAE;MACpByE,KAAK,CAACK,MAAM,CAAC5C,CAAC,EAAE,CAAC,CAAC;MAClB,MAAM3C,QAAQ,GAAGoF,IAAI,CAACpF,QAAQ,CAAC0C,MAAM;MACrC,MAAM8C,cAAc,GAAGxF,QAAQ,CAAC6C,MAAM;MACtC,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,cAAc,EAAEC,CAAC,EAAE,EAAE;QACvC,IAAI,CAAClE,GAAG,CAACC,IAAI,EAAExB,QAAQ,CAACyF,CAAC,CAAC,CAAC;MAC7B;MACAL,IAAI,CAACP,OAAO,CAAC,CAAC;IAChB;EACF;EAEA,IAAIrC,SAAS,GAAG,IAAI;EACpB,KAAKG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,KAAK,CAACrC,MAAM,EAAEF,CAAC,EAAE,EAAE;IACjCH,SAAS,GAAG0C,KAAK,CAACvC,CAAC,CAAC,CAACJ,MAAM,CAACf,IAAI,CAAC,IAAIgB,SAAS;EAChD;EACA,OAAOA,SAAS;AAClB,CAAC;AAEDsC,oCAAoC,CAACjE,SAAS,CAAC0D,iBAAiB,GAAG,UACjEpD,OAAO,EACPqD,MAAM,EACN;EACA,MAAMU,KAAK,GAAG,IAAI,CAACH,MAAM;EACzB,MAAMlC,MAAM,GAAGqC,KAAK,CAACrC,MAAM;EAC3B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAEF,CAAC,EAAE,EAAE;IAC/B,MAAMyC,IAAI,GAAGF,KAAK,CAACvC,CAAC,CAAC;IACrB,IAAIyC,IAAI,CAACd,QAAQ,CAACnD,OAAO,CAAC,EAAE;MAC1B,OAAOiE,IAAI,CAACb,iBAAiB,CAACpD,OAAO,EAAEqD,MAAM,CAAC;IAChD;EACF;EACA,OAAOtF,mBAAmB,CAACyF,MAAM;AACnC,CAAC;AAEDG,oCAAoC,CAACjE,SAAS,CAAC6E,mBAAmB,GAChE,YAAY;EACV,MAAMR,KAAK,GAAG,IAAI,CAACH,MAAM;EACzB,MAAMlC,MAAM,GAAGqC,KAAK,CAACrC,MAAM;EAC3B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,EAAEF,CAAC,EAAE,EAAE;IAC/BuC,KAAK,CAACvC,CAAC,CAAC,CAACkC,OAAO,CAAC,CAAC;EACpB;EACA,IAAI,CAACE,MAAM,CAAClC,MAAM,GAAG,CAAC;AACxB,CAAC;AACH,eAAeiC,oCAAoC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}