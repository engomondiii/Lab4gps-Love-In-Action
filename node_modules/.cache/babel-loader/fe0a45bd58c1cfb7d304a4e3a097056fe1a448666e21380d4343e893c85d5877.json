{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WallGeometryLibrary from \"./WallGeometryLibrary.js\";\nconst scratchCartesian3Position1 = new Cartesian3();\nconst scratchCartesian3Position2 = new Cartesian3();\nconst scratchCartesian3Position4 = new Cartesian3();\nconst scratchCartesian3Position5 = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n\n/**\n * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @alias WallGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} positions length must be greater than or equal to 2.\n * @exception {DeveloperError} positions and maximumHeights must have the same length.\n * @exception {DeveloperError} positions and minimumHeights must have the same length.\n *\n * @see WallGeometry#createGeometry\n * @see WallGeometry#fromConstantHeight\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n *\n * @example\n * // create a wall that spans from ground level to 10000 meters\n * const wall = new Cesium.WallGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n */\nfunction WallGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const wallPositions = options.positions;\n  const maximumHeights = options.maximumHeights;\n  const minimumHeights = options.minimumHeights;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(wallPositions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  if (defined(maximumHeights) && maximumHeights.length !== wallPositions.length) {\n    throw new DeveloperError(\"options.positions and options.maximumHeights must have the same length.\");\n  }\n  if (defined(minimumHeights) && minimumHeights.length !== wallPositions.length) {\n    throw new DeveloperError(\"options.positions and options.minimumHeights must have the same length.\");\n  }\n  //>>includeEnd('debug');\n\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this._positions = wallPositions;\n  this._minimumHeights = minimumHeights;\n  this._maximumHeights = maximumHeights;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._granularity = granularity;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._workerName = \"createWallGeometry\";\n  let numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n  if (defined(minimumHeights)) {\n    numComponents += minimumHeights.length;\n  }\n  if (defined(maximumHeights)) {\n    numComponents += maximumHeights.length;\n  }\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {WallGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nWallGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  let i;\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  const minimumHeights = value._minimumHeights;\n  length = defined(minimumHeights) ? minimumHeights.length : 0;\n  array[startingIndex++] = length;\n  if (defined(minimumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = minimumHeights[i];\n    }\n  }\n  const maximumHeights = value._maximumHeights;\n  length = defined(maximumHeights) ? maximumHeights.length : 0;\n  array[startingIndex++] = length;\n  if (defined(maximumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = maximumHeights[i];\n    }\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._granularity;\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  minimumHeights: undefined,\n  maximumHeights: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {WallGeometry} [result] The object into which to store the result.\n * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n */\nWallGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  let i;\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  length = array[startingIndex++];\n  let minimumHeights;\n  if (length > 0) {\n    minimumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      minimumHeights[i] = array[startingIndex++];\n    }\n  }\n  length = array[startingIndex++];\n  let maximumHeights;\n  if (length > 0) {\n    maximumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      maximumHeights[i] = array[startingIndex++];\n    }\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const granularity = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.minimumHeights = minimumHeights;\n    scratchOptions.maximumHeights = maximumHeights;\n    scratchOptions.granularity = granularity;\n    return new WallGeometry(scratchOptions);\n  }\n  result._positions = positions;\n  result._minimumHeights = minimumHeights;\n  result._maximumHeights = maximumHeights;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  return result;\n};\n\n/**\n * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.maximumHeight] A constant that defines the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number} [options.minimumHeight] A constant that defines the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @returns {WallGeometry}\n *\n *\n * @example\n * // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n *\n * @see WallGeometry#createGeometry\n */\nWallGeometry.fromConstantHeights = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let minHeights;\n  let maxHeights;\n  const min = options.minimumHeight;\n  const max = options.maximumHeight;\n  const doMin = defined(min);\n  const doMax = defined(max);\n  if (doMin || doMax) {\n    const length = positions.length;\n    minHeights = doMin ? new Array(length) : undefined;\n    maxHeights = doMax ? new Array(length) : undefined;\n    for (let i = 0; i < length; ++i) {\n      if (doMin) {\n        minHeights[i] = min;\n      }\n      if (doMax) {\n        maxHeights[i] = max;\n      }\n    }\n  }\n  const newOptions = {\n    positions: positions,\n    maximumHeights: maxHeights,\n    minimumHeights: minHeights,\n    ellipsoid: options.ellipsoid,\n    vertexFormat: options.vertexFormat\n  };\n  return new WallGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n *\n * @param {WallGeometry} wallGeometry A description of the wall.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nWallGeometry.createGeometry = function (wallGeometry) {\n  const wallPositions = wallGeometry._positions;\n  const minimumHeights = wallGeometry._minimumHeights;\n  const maximumHeights = wallGeometry._maximumHeights;\n  const vertexFormat = wallGeometry._vertexFormat;\n  const granularity = wallGeometry._granularity;\n  const ellipsoid = wallGeometry._ellipsoid;\n  const pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);\n  if (!defined(pos)) {\n    return;\n  }\n  const bottomPositions = pos.bottomPositions;\n  const topPositions = pos.topPositions;\n  const numCorners = pos.numCorners;\n  let length = topPositions.length;\n  let size = length * 2;\n  const positions = vertexFormat.position ? new Float64Array(size) : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  const textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;\n  let positionIndex = 0;\n  let normalIndex = 0;\n  let bitangentIndex = 0;\n  let tangentIndex = 0;\n  let stIndex = 0;\n\n  // add lower and upper points one after the other, lower\n  // points being even and upper points being odd\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n  let recomputeNormal = true;\n  length /= 3;\n  let i;\n  let s = 0;\n  const ds = 1 / (length - numCorners - 1);\n  for (i = 0; i < length; ++i) {\n    const i3 = i * 3;\n    const topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n    const bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n    if (vertexFormat.position) {\n      // insert the lower point\n      positions[positionIndex++] = bottomPosition.x;\n      positions[positionIndex++] = bottomPosition.y;\n      positions[positionIndex++] = bottomPosition.z;\n\n      // insert the upper point\n      positions[positionIndex++] = topPosition.x;\n      positions[positionIndex++] = topPosition.y;\n      positions[positionIndex++] = topPosition.z;\n    }\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = s;\n      textureCoordinates[stIndex++] = 0.0;\n      textureCoordinates[stIndex++] = s;\n      textureCoordinates[stIndex++] = 1.0;\n    }\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      let nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);\n      const groundPosition = Cartesian3.subtract(topPosition, ellipsoid.geodeticSurfaceNormal(topPosition, scratchCartesian3Position2), scratchCartesian3Position2);\n      if (i + 1 < length) {\n        nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);\n      }\n      if (recomputeNormal) {\n        const scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);\n        const scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);\n        normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);\n        recomputeNormal = false;\n      }\n      if (Cartesian3.equalsEpsilon(topPosition, nextTop, CesiumMath.EPSILON10)) {\n        recomputeNormal = true;\n      } else {\n        s += ds;\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(Cartesian3.subtract(nextTop, topPosition, tangent), tangent);\n        }\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n        }\n      }\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    });\n  }\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n\n  // prepare the side walls, two triangles for each wall\n  //\n  //    A (i+1)  B (i+3) E\n  //    +--------+-------+\n  //    |      / |      /|    triangles:  A C B\n  //    |     /  |     / |                B C D\n  //    |    /   |    /  |\n  //    |   /    |   /   |\n  //    |  /     |  /    |\n  //    | /      | /     |\n  //    +--------+-------+\n  //    C (i)    D (i+2) F\n  //\n\n  const numVertices = size / 3;\n  size -= 6 * (numCorners + 1);\n  const indices = IndexDatatype.createTypedArray(numVertices, size);\n  let edgeIndex = 0;\n  for (i = 0; i < numVertices - 2; i += 2) {\n    const LL = i;\n    const LR = i + 2;\n    const pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n    const pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n    if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    const UL = i + 1;\n    const UR = i + 3;\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: new BoundingSphere.fromVertices(positions)\n  });\n};\nexport default WallGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","IndexDatatype","CesiumMath","PrimitiveType","VertexFormat","WallGeometryLibrary","scratchCartesian3Position1","scratchCartesian3Position2","scratchCartesian3Position4","scratchCartesian3Position5","scratchBitangent","scratchTangent","scratchNormal","WallGeometry","options","EMPTY_OBJECT","wallPositions","positions","maximumHeights","minimumHeights","length","vertexFormat","DEFAULT","granularity","RADIANS_PER_DEGREE","ellipsoid","default","_positions","_minimumHeights","_maximumHeights","_vertexFormat","clone","_granularity","_ellipsoid","_workerName","numComponents","packedLength","pack","value","array","startingIndex","i","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","fromConstantHeights","minHeights","maxHeights","min","minimumHeight","max","maximumHeight","doMin","doMax","newOptions","createGeometry","wallGeometry","pos","computePositions","bottomPositions","topPositions","numCorners","size","position","Float64Array","normals","normal","Float32Array","tangents","tangent","bitangents","bitangent","textureCoordinates","st","positionIndex","normalIndex","bitangentIndex","tangentIndex","stIndex","recomputeNormal","s","ds","i3","topPosition","fromArray","bottomPosition","x","y","z","nextTop","ZERO","groundPosition","subtract","geodeticSurfaceNormal","scalednextPosition","scaledGroundPosition","normalize","cross","equalsEpsilon","EPSILON10","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","numVertices","indices","createTypedArray","edgeIndex","LL","LR","pl","pr","UL","UR","primitiveType","TRIANGLES","boundingSphere","fromVertices"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/WallGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WallGeometryLibrary from \"./WallGeometryLibrary.js\";\n\nconst scratchCartesian3Position1 = new Cartesian3();\nconst scratchCartesian3Position2 = new Cartesian3();\nconst scratchCartesian3Position4 = new Cartesian3();\nconst scratchCartesian3Position5 = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n\n/**\n * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @alias WallGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} positions length must be greater than or equal to 2.\n * @exception {DeveloperError} positions and maximumHeights must have the same length.\n * @exception {DeveloperError} positions and minimumHeights must have the same length.\n *\n * @see WallGeometry#createGeometry\n * @see WallGeometry#fromConstantHeight\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n *\n * @example\n * // create a wall that spans from ground level to 10000 meters\n * const wall = new Cesium.WallGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *     19.0, 47.0, 10000.0,\n *     19.0, 48.0, 10000.0,\n *     20.0, 48.0, 10000.0,\n *     20.0, 47.0, 10000.0,\n *     19.0, 47.0, 10000.0\n *   ])\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n */\nfunction WallGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const wallPositions = options.positions;\n  const maximumHeights = options.maximumHeights;\n  const minimumHeights = options.minimumHeights;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(wallPositions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  if (\n    defined(maximumHeights) &&\n    maximumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.maximumHeights must have the same length.\",\n    );\n  }\n  if (\n    defined(minimumHeights) &&\n    minimumHeights.length !== wallPositions.length\n  ) {\n    throw new DeveloperError(\n      \"options.positions and options.minimumHeights must have the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n\n  this._positions = wallPositions;\n  this._minimumHeights = minimumHeights;\n  this._maximumHeights = maximumHeights;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._granularity = granularity;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._workerName = \"createWallGeometry\";\n\n  let numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n  if (defined(minimumHeights)) {\n    numComponents += minimumHeights.length;\n  }\n  if (defined(maximumHeights)) {\n    numComponents += maximumHeights.length;\n  }\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {WallGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nWallGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const minimumHeights = value._minimumHeights;\n  length = defined(minimumHeights) ? minimumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(minimumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = minimumHeights[i];\n    }\n  }\n\n  const maximumHeights = value._maximumHeights;\n  length = defined(maximumHeights) ? maximumHeights.length : 0;\n  array[startingIndex++] = length;\n\n  if (defined(maximumHeights)) {\n    for (i = 0; i < length; ++i) {\n      array[startingIndex++] = maximumHeights[i];\n    }\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  minimumHeights: undefined,\n  maximumHeights: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {WallGeometry} [result] The object into which to store the result.\n * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n */\nWallGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  let minimumHeights;\n\n  if (length > 0) {\n    minimumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      minimumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  length = array[startingIndex++];\n  let maximumHeights;\n\n  if (length > 0) {\n    maximumHeights = new Array(length);\n    for (i = 0; i < length; ++i) {\n      maximumHeights[i] = array[startingIndex++];\n    }\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.minimumHeights = minimumHeights;\n    scratchOptions.maximumHeights = maximumHeights;\n    scratchOptions.granularity = granularity;\n    return new WallGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._minimumHeights = minimumHeights;\n  result._maximumHeights = maximumHeights;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n\n  return result;\n};\n\n/**\n * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n * @param {number} [options.maximumHeight] A constant that defines the maximum height of the\n *        wall at <code>positions</code>. If undefined, the height of each position in used.\n * @param {number} [options.minimumHeight] A constant that defines the minimum height of the\n *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for coordinate manipulation\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @returns {WallGeometry}\n *\n *\n * @example\n * // create a wall that spans from 10000 meters to 20000 meters\n * const wall = Cesium.WallGeometry.fromConstantHeights({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     19.0, 47.0,\n *     19.0, 48.0,\n *     20.0, 48.0,\n *     20.0, 47.0,\n *     19.0, 47.0,\n *   ]),\n *   minimumHeight : 20000.0,\n *   maximumHeight : 10000.0\n * });\n * const geometry = Cesium.WallGeometry.createGeometry(wall);\n *\n * @see WallGeometry#createGeometry\n */\nWallGeometry.fromConstantHeights = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let minHeights;\n  let maxHeights;\n\n  const min = options.minimumHeight;\n  const max = options.maximumHeight;\n\n  const doMin = defined(min);\n  const doMax = defined(max);\n  if (doMin || doMax) {\n    const length = positions.length;\n    minHeights = doMin ? new Array(length) : undefined;\n    maxHeights = doMax ? new Array(length) : undefined;\n\n    for (let i = 0; i < length; ++i) {\n      if (doMin) {\n        minHeights[i] = min;\n      }\n\n      if (doMax) {\n        maxHeights[i] = max;\n      }\n    }\n  }\n\n  const newOptions = {\n    positions: positions,\n    maximumHeights: maxHeights,\n    minimumHeights: minHeights,\n    ellipsoid: options.ellipsoid,\n    vertexFormat: options.vertexFormat,\n  };\n  return new WallGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n *\n * @param {WallGeometry} wallGeometry A description of the wall.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nWallGeometry.createGeometry = function (wallGeometry) {\n  const wallPositions = wallGeometry._positions;\n  const minimumHeights = wallGeometry._minimumHeights;\n  const maximumHeights = wallGeometry._maximumHeights;\n  const vertexFormat = wallGeometry._vertexFormat;\n  const granularity = wallGeometry._granularity;\n  const ellipsoid = wallGeometry._ellipsoid;\n\n  const pos = WallGeometryLibrary.computePositions(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights,\n    granularity,\n    true,\n  );\n  if (!defined(pos)) {\n    return;\n  }\n\n  const bottomPositions = pos.bottomPositions;\n  const topPositions = pos.topPositions;\n  const numCorners = pos.numCorners;\n\n  let length = topPositions.length;\n  let size = length * 2;\n\n  const positions = vertexFormat.position ? new Float64Array(size) : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size)\n    : undefined;\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array((size / 3) * 2)\n    : undefined;\n\n  let positionIndex = 0;\n  let normalIndex = 0;\n  let bitangentIndex = 0;\n  let tangentIndex = 0;\n  let stIndex = 0;\n\n  // add lower and upper points one after the other, lower\n  // points being even and upper points being odd\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n  let recomputeNormal = true;\n  length /= 3;\n  let i;\n  let s = 0;\n  const ds = 1 / (length - numCorners - 1);\n  for (i = 0; i < length; ++i) {\n    const i3 = i * 3;\n    const topPosition = Cartesian3.fromArray(\n      topPositions,\n      i3,\n      scratchCartesian3Position1,\n    );\n    const bottomPosition = Cartesian3.fromArray(\n      bottomPositions,\n      i3,\n      scratchCartesian3Position2,\n    );\n    if (vertexFormat.position) {\n      // insert the lower point\n      positions[positionIndex++] = bottomPosition.x;\n      positions[positionIndex++] = bottomPosition.y;\n      positions[positionIndex++] = bottomPosition.z;\n\n      // insert the upper point\n      positions[positionIndex++] = topPosition.x;\n      positions[positionIndex++] = topPosition.y;\n      positions[positionIndex++] = topPosition.z;\n    }\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = s;\n      textureCoordinates[stIndex++] = 0.0;\n\n      textureCoordinates[stIndex++] = s;\n      textureCoordinates[stIndex++] = 1.0;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      let nextTop = Cartesian3.clone(\n        Cartesian3.ZERO,\n        scratchCartesian3Position5,\n      );\n      const groundPosition = Cartesian3.subtract(\n        topPosition,\n        ellipsoid.geodeticSurfaceNormal(\n          topPosition,\n          scratchCartesian3Position2,\n        ),\n        scratchCartesian3Position2,\n      );\n      if (i + 1 < length) {\n        nextTop = Cartesian3.fromArray(\n          topPositions,\n          i3 + 3,\n          scratchCartesian3Position5,\n        );\n      }\n\n      if (recomputeNormal) {\n        const scalednextPosition = Cartesian3.subtract(\n          nextTop,\n          topPosition,\n          scratchCartesian3Position4,\n        );\n        const scaledGroundPosition = Cartesian3.subtract(\n          groundPosition,\n          topPosition,\n          scratchCartesian3Position1,\n        );\n        normal = Cartesian3.normalize(\n          Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal),\n          normal,\n        );\n        recomputeNormal = false;\n      }\n\n      if (\n        Cartesian3.equalsEpsilon(topPosition, nextTop, CesiumMath.EPSILON10)\n      ) {\n        recomputeNormal = true;\n      } else {\n        s += ds;\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.subtract(nextTop, topPosition, tangent),\n            tangent,\n          );\n        }\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  // prepare the side walls, two triangles for each wall\n  //\n  //    A (i+1)  B (i+3) E\n  //    +--------+-------+\n  //    |      / |      /|    triangles:  A C B\n  //    |     /  |     / |                B C D\n  //    |    /   |    /  |\n  //    |   /    |   /   |\n  //    |  /     |  /    |\n  //    | /      | /     |\n  //    +--------+-------+\n  //    C (i)    D (i+2) F\n  //\n\n  const numVertices = size / 3;\n  size -= 6 * (numCorners + 1);\n  const indices = IndexDatatype.createTypedArray(numVertices, size);\n\n  let edgeIndex = 0;\n  for (i = 0; i < numVertices - 2; i += 2) {\n    const LL = i;\n    const LR = i + 2;\n    const pl = Cartesian3.fromArray(\n      positions,\n      LL * 3,\n      scratchCartesian3Position1,\n    );\n    const pr = Cartesian3.fromArray(\n      positions,\n      LR * 3,\n      scratchCartesian3Position2,\n    );\n    if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    const UL = i + 1;\n    const UR = i + 3;\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: new BoundingSphere.fromVertices(positions),\n  });\n};\nexport default WallGeometry;\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,qBAAqB;AAChD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,UAAU,MAAM,WAAW;AAClC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,mBAAmB,MAAM,0BAA0B;AAE1D,MAAMC,0BAA0B,GAAG,IAAId,UAAU,CAAC,CAAC;AACnD,MAAMe,0BAA0B,GAAG,IAAIf,UAAU,CAAC,CAAC;AACnD,MAAMgB,0BAA0B,GAAG,IAAIhB,UAAU,CAAC,CAAC;AACnD,MAAMiB,0BAA0B,GAAG,IAAIjB,UAAU,CAAC,CAAC;AACnD,MAAMkB,gBAAgB,GAAG,IAAIlB,UAAU,CAAC,CAAC;AACzC,MAAMmB,cAAc,GAAG,IAAInB,UAAU,CAAC,CAAC;AACvC,MAAMoB,aAAa,GAAG,IAAIpB,UAAU,CAAC,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqB,YAAYA,CAACC,OAAO,EAAE;EAC7BA,OAAO,GAAGpB,YAAY,CAACoB,OAAO,EAAEpB,YAAY,CAACqB,YAAY,CAAC;EAE1D,MAAMC,aAAa,GAAGF,OAAO,CAACG,SAAS;EACvC,MAAMC,cAAc,GAAGJ,OAAO,CAACI,cAAc;EAC7C,MAAMC,cAAc,GAAGL,OAAO,CAACK,cAAc;;EAE7C;EACA,IAAI,CAACxB,OAAO,CAACqB,aAAa,CAAC,EAAE;IAC3B,MAAM,IAAIpB,cAAc,CAAC,gCAAgC,CAAC;EAC5D;EACA,IACED,OAAO,CAACuB,cAAc,CAAC,IACvBA,cAAc,CAACE,MAAM,KAAKJ,aAAa,CAACI,MAAM,EAC9C;IACA,MAAM,IAAIxB,cAAc,CACtB,yEACF,CAAC;EACH;EACA,IACED,OAAO,CAACwB,cAAc,CAAC,IACvBA,cAAc,CAACC,MAAM,KAAKJ,aAAa,CAACI,MAAM,EAC9C;IACA,MAAM,IAAIxB,cAAc,CACtB,yEACF,CAAC;EACH;EACA;;EAEA,MAAMyB,YAAY,GAAG3B,YAAY,CAACoB,OAAO,CAACO,YAAY,EAAEjB,YAAY,CAACkB,OAAO,CAAC;EAC7E,MAAMC,WAAW,GAAG7B,YAAY,CAC9BoB,OAAO,CAACS,WAAW,EACnBrB,UAAU,CAACsB,kBACb,CAAC;EACD,MAAMC,SAAS,GAAG/B,YAAY,CAACoB,OAAO,CAACW,SAAS,EAAE5B,SAAS,CAAC6B,OAAO,CAAC;EAEpE,IAAI,CAACC,UAAU,GAAGX,aAAa;EAC/B,IAAI,CAACY,eAAe,GAAGT,cAAc;EACrC,IAAI,CAACU,eAAe,GAAGX,cAAc;EACrC,IAAI,CAACY,aAAa,GAAG1B,YAAY,CAAC2B,KAAK,CAACV,YAAY,CAAC;EACrD,IAAI,CAACW,YAAY,GAAGT,WAAW;EAC/B,IAAI,CAACU,UAAU,GAAGpC,SAAS,CAACkC,KAAK,CAACN,SAAS,CAAC;EAC5C,IAAI,CAACS,WAAW,GAAG,oBAAoB;EAEvC,IAAIC,aAAa,GAAG,CAAC,GAAGnB,aAAa,CAACI,MAAM,GAAG5B,UAAU,CAAC4C,YAAY,GAAG,CAAC;EAC1E,IAAIzC,OAAO,CAACwB,cAAc,CAAC,EAAE;IAC3BgB,aAAa,IAAIhB,cAAc,CAACC,MAAM;EACxC;EACA,IAAIzB,OAAO,CAACuB,cAAc,CAAC,EAAE;IAC3BiB,aAAa,IAAIjB,cAAc,CAACE,MAAM;EACxC;;EAEA;AACF;AACA;AACA;EACE,IAAI,CAACgB,YAAY,GACfD,aAAa,GAAGtC,SAAS,CAACuC,YAAY,GAAGhC,YAAY,CAACgC,YAAY,GAAG,CAAC;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,YAAY,CAACwB,IAAI,GAAG,UAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa,EAAE;EACzD;EACA,IAAI,CAAC7C,OAAO,CAAC2C,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI1C,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA,IAAI,CAACD,OAAO,CAAC4C,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI3C,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA;;EAEA4C,aAAa,GAAG9C,YAAY,CAAC8C,aAAa,EAAE,CAAC,CAAC;EAE9C,IAAIC,CAAC;EAEL,MAAMxB,SAAS,GAAGqB,KAAK,CAACX,UAAU;EAClC,IAAIP,MAAM,GAAGH,SAAS,CAACG,MAAM;EAC7BmB,KAAK,CAACC,aAAa,EAAE,CAAC,GAAGpB,MAAM;EAE/B,KAAKqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAED,aAAa,IAAIhD,UAAU,CAAC4C,YAAY,EAAE;IACrE5C,UAAU,CAAC6C,IAAI,CAACpB,SAAS,CAACwB,CAAC,CAAC,EAAEF,KAAK,EAAEC,aAAa,CAAC;EACrD;EAEA,MAAMrB,cAAc,GAAGmB,KAAK,CAACV,eAAe;EAC5CR,MAAM,GAAGzB,OAAO,CAACwB,cAAc,CAAC,GAAGA,cAAc,CAACC,MAAM,GAAG,CAAC;EAC5DmB,KAAK,CAACC,aAAa,EAAE,CAAC,GAAGpB,MAAM;EAE/B,IAAIzB,OAAO,CAACwB,cAAc,CAAC,EAAE;IAC3B,KAAKsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAE;MAC3BF,KAAK,CAACC,aAAa,EAAE,CAAC,GAAGrB,cAAc,CAACsB,CAAC,CAAC;IAC5C;EACF;EAEA,MAAMvB,cAAc,GAAGoB,KAAK,CAACT,eAAe;EAC5CT,MAAM,GAAGzB,OAAO,CAACuB,cAAc,CAAC,GAAGA,cAAc,CAACE,MAAM,GAAG,CAAC;EAC5DmB,KAAK,CAACC,aAAa,EAAE,CAAC,GAAGpB,MAAM;EAE/B,IAAIzB,OAAO,CAACuB,cAAc,CAAC,EAAE;IAC3B,KAAKuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAE;MAC3BF,KAAK,CAACC,aAAa,EAAE,CAAC,GAAGtB,cAAc,CAACuB,CAAC,CAAC;IAC5C;EACF;EAEA5C,SAAS,CAACwC,IAAI,CAACC,KAAK,CAACL,UAAU,EAAEM,KAAK,EAAEC,aAAa,CAAC;EACtDA,aAAa,IAAI3C,SAAS,CAACuC,YAAY;EAEvChC,YAAY,CAACiC,IAAI,CAACC,KAAK,CAACR,aAAa,EAAES,KAAK,EAAEC,aAAa,CAAC;EAC5DA,aAAa,IAAIpC,YAAY,CAACgC,YAAY;EAE1CG,KAAK,CAACC,aAAa,CAAC,GAAGF,KAAK,CAACN,YAAY;EAEzC,OAAOO,KAAK;AACd,CAAC;AAED,MAAMG,gBAAgB,GAAG7C,SAAS,CAACkC,KAAK,CAAClC,SAAS,CAAC8C,WAAW,CAAC;AAC/D,MAAMC,mBAAmB,GAAG,IAAIxC,YAAY,CAAC,CAAC;AAC9C,MAAMyC,cAAc,GAAG;EACrB5B,SAAS,EAAE6B,SAAS;EACpB3B,cAAc,EAAE2B,SAAS;EACzB5B,cAAc,EAAE4B,SAAS;EACzBrB,SAAS,EAAEiB,gBAAgB;EAC3BrB,YAAY,EAAEuB,mBAAmB;EACjCrB,WAAW,EAAEuB;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjC,YAAY,CAACkC,MAAM,GAAG,UAAUR,KAAK,EAAEC,aAAa,EAAEQ,MAAM,EAAE;EAC5D;EACA,IAAI,CAACrD,OAAO,CAAC4C,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI3C,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA;;EAEA4C,aAAa,GAAG9C,YAAY,CAAC8C,aAAa,EAAE,CAAC,CAAC;EAE9C,IAAIC,CAAC;EAEL,IAAIrB,MAAM,GAAGmB,KAAK,CAACC,aAAa,EAAE,CAAC;EACnC,MAAMvB,SAAS,GAAG,IAAIgC,KAAK,CAAC7B,MAAM,CAAC;EAEnC,KAAKqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAED,aAAa,IAAIhD,UAAU,CAAC4C,YAAY,EAAE;IACrEnB,SAAS,CAACwB,CAAC,CAAC,GAAGjD,UAAU,CAACuD,MAAM,CAACR,KAAK,EAAEC,aAAa,CAAC;EACxD;EAEApB,MAAM,GAAGmB,KAAK,CAACC,aAAa,EAAE,CAAC;EAC/B,IAAIrB,cAAc;EAElB,IAAIC,MAAM,GAAG,CAAC,EAAE;IACdD,cAAc,GAAG,IAAI8B,KAAK,CAAC7B,MAAM,CAAC;IAClC,KAAKqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAE;MAC3BtB,cAAc,CAACsB,CAAC,CAAC,GAAGF,KAAK,CAACC,aAAa,EAAE,CAAC;IAC5C;EACF;EAEApB,MAAM,GAAGmB,KAAK,CAACC,aAAa,EAAE,CAAC;EAC/B,IAAItB,cAAc;EAElB,IAAIE,MAAM,GAAG,CAAC,EAAE;IACdF,cAAc,GAAG,IAAI+B,KAAK,CAAC7B,MAAM,CAAC;IAClC,KAAKqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAE;MAC3BvB,cAAc,CAACuB,CAAC,CAAC,GAAGF,KAAK,CAACC,aAAa,EAAE,CAAC;IAC5C;EACF;EAEA,MAAMf,SAAS,GAAG5B,SAAS,CAACkD,MAAM,CAACR,KAAK,EAAEC,aAAa,EAAEE,gBAAgB,CAAC;EAC1EF,aAAa,IAAI3C,SAAS,CAACuC,YAAY;EAEvC,MAAMf,YAAY,GAAGjB,YAAY,CAAC2C,MAAM,CACtCR,KAAK,EACLC,aAAa,EACbI,mBACF,CAAC;EACDJ,aAAa,IAAIpC,YAAY,CAACgC,YAAY;EAE1C,MAAMb,WAAW,GAAGgB,KAAK,CAACC,aAAa,CAAC;EAExC,IAAI,CAAC7C,OAAO,CAACqD,MAAM,CAAC,EAAE;IACpBH,cAAc,CAAC5B,SAAS,GAAGA,SAAS;IACpC4B,cAAc,CAAC1B,cAAc,GAAGA,cAAc;IAC9C0B,cAAc,CAAC3B,cAAc,GAAGA,cAAc;IAC9C2B,cAAc,CAACtB,WAAW,GAAGA,WAAW;IACxC,OAAO,IAAIV,YAAY,CAACgC,cAAc,CAAC;EACzC;EAEAG,MAAM,CAACrB,UAAU,GAAGV,SAAS;EAC7B+B,MAAM,CAACpB,eAAe,GAAGT,cAAc;EACvC6B,MAAM,CAACnB,eAAe,GAAGX,cAAc;EACvC8B,MAAM,CAACf,UAAU,GAAGpC,SAAS,CAACkC,KAAK,CAACN,SAAS,EAAEuB,MAAM,CAACf,UAAU,CAAC;EACjEe,MAAM,CAAClB,aAAa,GAAG1B,YAAY,CAAC2B,KAAK,CAACV,YAAY,EAAE2B,MAAM,CAAClB,aAAa,CAAC;EAC7EkB,MAAM,CAAChB,YAAY,GAAGT,WAAW;EAEjC,OAAOyB,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnC,YAAY,CAACqC,mBAAmB,GAAG,UAAUpC,OAAO,EAAE;EACpDA,OAAO,GAAGpB,YAAY,CAACoB,OAAO,EAAEpB,YAAY,CAACqB,YAAY,CAAC;EAC1D,MAAME,SAAS,GAAGH,OAAO,CAACG,SAAS;;EAEnC;EACA,IAAI,CAACtB,OAAO,CAACsB,SAAS,CAAC,EAAE;IACvB,MAAM,IAAIrB,cAAc,CAAC,gCAAgC,CAAC;EAC5D;EACA;;EAEA,IAAIuD,UAAU;EACd,IAAIC,UAAU;EAEd,MAAMC,GAAG,GAAGvC,OAAO,CAACwC,aAAa;EACjC,MAAMC,GAAG,GAAGzC,OAAO,CAAC0C,aAAa;EAEjC,MAAMC,KAAK,GAAG9D,OAAO,CAAC0D,GAAG,CAAC;EAC1B,MAAMK,KAAK,GAAG/D,OAAO,CAAC4D,GAAG,CAAC;EAC1B,IAAIE,KAAK,IAAIC,KAAK,EAAE;IAClB,MAAMtC,MAAM,GAAGH,SAAS,CAACG,MAAM;IAC/B+B,UAAU,GAAGM,KAAK,GAAG,IAAIR,KAAK,CAAC7B,MAAM,CAAC,GAAG0B,SAAS;IAClDM,UAAU,GAAGM,KAAK,GAAG,IAAIT,KAAK,CAAC7B,MAAM,CAAC,GAAG0B,SAAS;IAElD,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAE;MAC/B,IAAIgB,KAAK,EAAE;QACTN,UAAU,CAACV,CAAC,CAAC,GAAGY,GAAG;MACrB;MAEA,IAAIK,KAAK,EAAE;QACTN,UAAU,CAACX,CAAC,CAAC,GAAGc,GAAG;MACrB;IACF;EACF;EAEA,MAAMI,UAAU,GAAG;IACjB1C,SAAS,EAAEA,SAAS;IACpBC,cAAc,EAAEkC,UAAU;IAC1BjC,cAAc,EAAEgC,UAAU;IAC1B1B,SAAS,EAAEX,OAAO,CAACW,SAAS;IAC5BJ,YAAY,EAAEP,OAAO,CAACO;EACxB,CAAC;EACD,OAAO,IAAIR,YAAY,CAAC8C,UAAU,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA9C,YAAY,CAAC+C,cAAc,GAAG,UAAUC,YAAY,EAAE;EACpD,MAAM7C,aAAa,GAAG6C,YAAY,CAAClC,UAAU;EAC7C,MAAMR,cAAc,GAAG0C,YAAY,CAACjC,eAAe;EACnD,MAAMV,cAAc,GAAG2C,YAAY,CAAChC,eAAe;EACnD,MAAMR,YAAY,GAAGwC,YAAY,CAAC/B,aAAa;EAC/C,MAAMP,WAAW,GAAGsC,YAAY,CAAC7B,YAAY;EAC7C,MAAMP,SAAS,GAAGoC,YAAY,CAAC5B,UAAU;EAEzC,MAAM6B,GAAG,GAAGzD,mBAAmB,CAAC0D,gBAAgB,CAC9CtC,SAAS,EACTT,aAAa,EACbE,cAAc,EACdC,cAAc,EACdI,WAAW,EACX,IACF,CAAC;EACD,IAAI,CAAC5B,OAAO,CAACmE,GAAG,CAAC,EAAE;IACjB;EACF;EAEA,MAAME,eAAe,GAAGF,GAAG,CAACE,eAAe;EAC3C,MAAMC,YAAY,GAAGH,GAAG,CAACG,YAAY;EACrC,MAAMC,UAAU,GAAGJ,GAAG,CAACI,UAAU;EAEjC,IAAI9C,MAAM,GAAG6C,YAAY,CAAC7C,MAAM;EAChC,IAAI+C,IAAI,GAAG/C,MAAM,GAAG,CAAC;EAErB,MAAMH,SAAS,GAAGI,YAAY,CAAC+C,QAAQ,GAAG,IAAIC,YAAY,CAACF,IAAI,CAAC,GAAGrB,SAAS;EAC5E,MAAMwB,OAAO,GAAGjD,YAAY,CAACkD,MAAM,GAAG,IAAIC,YAAY,CAACL,IAAI,CAAC,GAAGrB,SAAS;EACxE,MAAM2B,QAAQ,GAAGpD,YAAY,CAACqD,OAAO,GAAG,IAAIF,YAAY,CAACL,IAAI,CAAC,GAAGrB,SAAS;EAC1E,MAAM6B,UAAU,GAAGtD,YAAY,CAACuD,SAAS,GACrC,IAAIJ,YAAY,CAACL,IAAI,CAAC,GACtBrB,SAAS;EACb,MAAM+B,kBAAkB,GAAGxD,YAAY,CAACyD,EAAE,GACtC,IAAIN,YAAY,CAAEL,IAAI,GAAG,CAAC,GAAI,CAAC,CAAC,GAChCrB,SAAS;EAEb,IAAIiC,aAAa,GAAG,CAAC;EACrB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,OAAO,GAAG,CAAC;;EAEf;EACA;EACA,IAAIZ,MAAM,GAAG3D,aAAa;EAC1B,IAAI8D,OAAO,GAAG/D,cAAc;EAC5B,IAAIiE,SAAS,GAAGlE,gBAAgB;EAChC,IAAI0E,eAAe,GAAG,IAAI;EAC1BhE,MAAM,IAAI,CAAC;EACX,IAAIqB,CAAC;EACL,IAAI4C,CAAC,GAAG,CAAC;EACT,MAAMC,EAAE,GAAG,CAAC,IAAIlE,MAAM,GAAG8C,UAAU,GAAG,CAAC,CAAC;EACxC,KAAKzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,MAAM,EAAE,EAAEqB,CAAC,EAAE;IAC3B,MAAM8C,EAAE,GAAG9C,CAAC,GAAG,CAAC;IAChB,MAAM+C,WAAW,GAAGhG,UAAU,CAACiG,SAAS,CACtCxB,YAAY,EACZsB,EAAE,EACFjF,0BACF,CAAC;IACD,MAAMoF,cAAc,GAAGlG,UAAU,CAACiG,SAAS,CACzCzB,eAAe,EACfuB,EAAE,EACFhF,0BACF,CAAC;IACD,IAAIc,YAAY,CAAC+C,QAAQ,EAAE;MACzB;MACAnD,SAAS,CAAC8D,aAAa,EAAE,CAAC,GAAGW,cAAc,CAACC,CAAC;MAC7C1E,SAAS,CAAC8D,aAAa,EAAE,CAAC,GAAGW,cAAc,CAACE,CAAC;MAC7C3E,SAAS,CAAC8D,aAAa,EAAE,CAAC,GAAGW,cAAc,CAACG,CAAC;;MAE7C;MACA5E,SAAS,CAAC8D,aAAa,EAAE,CAAC,GAAGS,WAAW,CAACG,CAAC;MAC1C1E,SAAS,CAAC8D,aAAa,EAAE,CAAC,GAAGS,WAAW,CAACI,CAAC;MAC1C3E,SAAS,CAAC8D,aAAa,EAAE,CAAC,GAAGS,WAAW,CAACK,CAAC;IAC5C;IAEA,IAAIxE,YAAY,CAACyD,EAAE,EAAE;MACnBD,kBAAkB,CAACM,OAAO,EAAE,CAAC,GAAGE,CAAC;MACjCR,kBAAkB,CAACM,OAAO,EAAE,CAAC,GAAG,GAAG;MAEnCN,kBAAkB,CAACM,OAAO,EAAE,CAAC,GAAGE,CAAC;MACjCR,kBAAkB,CAACM,OAAO,EAAE,CAAC,GAAG,GAAG;IACrC;IAEA,IAAI9D,YAAY,CAACkD,MAAM,IAAIlD,YAAY,CAACqD,OAAO,IAAIrD,YAAY,CAACuD,SAAS,EAAE;MACzE,IAAIkB,OAAO,GAAGtG,UAAU,CAACuC,KAAK,CAC5BvC,UAAU,CAACuG,IAAI,EACftF,0BACF,CAAC;MACD,MAAMuF,cAAc,GAAGxG,UAAU,CAACyG,QAAQ,CACxCT,WAAW,EACX/D,SAAS,CAACyE,qBAAqB,CAC7BV,WAAW,EACXjF,0BACF,CAAC,EACDA,0BACF,CAAC;MACD,IAAIkC,CAAC,GAAG,CAAC,GAAGrB,MAAM,EAAE;QAClB0E,OAAO,GAAGtG,UAAU,CAACiG,SAAS,CAC5BxB,YAAY,EACZsB,EAAE,GAAG,CAAC,EACN9E,0BACF,CAAC;MACH;MAEA,IAAI2E,eAAe,EAAE;QACnB,MAAMe,kBAAkB,GAAG3G,UAAU,CAACyG,QAAQ,CAC5CH,OAAO,EACPN,WAAW,EACXhF,0BACF,CAAC;QACD,MAAM4F,oBAAoB,GAAG5G,UAAU,CAACyG,QAAQ,CAC9CD,cAAc,EACdR,WAAW,EACXlF,0BACF,CAAC;QACDiE,MAAM,GAAG/E,UAAU,CAAC6G,SAAS,CAC3B7G,UAAU,CAAC8G,KAAK,CAACF,oBAAoB,EAAED,kBAAkB,EAAE5B,MAAM,CAAC,EAClEA,MACF,CAAC;QACDa,eAAe,GAAG,KAAK;MACzB;MAEA,IACE5F,UAAU,CAAC+G,aAAa,CAACf,WAAW,EAAEM,OAAO,EAAE5F,UAAU,CAACsG,SAAS,CAAC,EACpE;QACApB,eAAe,GAAG,IAAI;MACxB,CAAC,MAAM;QACLC,CAAC,IAAIC,EAAE;QACP,IAAIjE,YAAY,CAACqD,OAAO,EAAE;UACxBA,OAAO,GAAGlF,UAAU,CAAC6G,SAAS,CAC5B7G,UAAU,CAACyG,QAAQ,CAACH,OAAO,EAAEN,WAAW,EAAEd,OAAO,CAAC,EAClDA,OACF,CAAC;QACH;QACA,IAAIrD,YAAY,CAACuD,SAAS,EAAE;UAC1BA,SAAS,GAAGpF,UAAU,CAAC6G,SAAS,CAC9B7G,UAAU,CAAC8G,KAAK,CAAC/B,MAAM,EAAEG,OAAO,EAAEE,SAAS,CAAC,EAC5CA,SACF,CAAC;QACH;MACF;MAEA,IAAIvD,YAAY,CAACkD,MAAM,EAAE;QACvBD,OAAO,CAACU,WAAW,EAAE,CAAC,GAAGT,MAAM,CAACoB,CAAC;QACjCrB,OAAO,CAACU,WAAW,EAAE,CAAC,GAAGT,MAAM,CAACqB,CAAC;QACjCtB,OAAO,CAACU,WAAW,EAAE,CAAC,GAAGT,MAAM,CAACsB,CAAC;QAEjCvB,OAAO,CAACU,WAAW,EAAE,CAAC,GAAGT,MAAM,CAACoB,CAAC;QACjCrB,OAAO,CAACU,WAAW,EAAE,CAAC,GAAGT,MAAM,CAACqB,CAAC;QACjCtB,OAAO,CAACU,WAAW,EAAE,CAAC,GAAGT,MAAM,CAACsB,CAAC;MACnC;MAEA,IAAIxE,YAAY,CAACqD,OAAO,EAAE;QACxBD,QAAQ,CAACS,YAAY,EAAE,CAAC,GAAGR,OAAO,CAACiB,CAAC;QACpClB,QAAQ,CAACS,YAAY,EAAE,CAAC,GAAGR,OAAO,CAACkB,CAAC;QACpCnB,QAAQ,CAACS,YAAY,EAAE,CAAC,GAAGR,OAAO,CAACmB,CAAC;QAEpCpB,QAAQ,CAACS,YAAY,EAAE,CAAC,GAAGR,OAAO,CAACiB,CAAC;QACpClB,QAAQ,CAACS,YAAY,EAAE,CAAC,GAAGR,OAAO,CAACkB,CAAC;QACpCnB,QAAQ,CAACS,YAAY,EAAE,CAAC,GAAGR,OAAO,CAACmB,CAAC;MACtC;MAEA,IAAIxE,YAAY,CAACuD,SAAS,EAAE;QAC1BD,UAAU,CAACM,cAAc,EAAE,CAAC,GAAGL,SAAS,CAACe,CAAC;QAC1ChB,UAAU,CAACM,cAAc,EAAE,CAAC,GAAGL,SAAS,CAACgB,CAAC;QAC1CjB,UAAU,CAACM,cAAc,EAAE,CAAC,GAAGL,SAAS,CAACiB,CAAC;QAE1ClB,UAAU,CAACM,cAAc,EAAE,CAAC,GAAGL,SAAS,CAACe,CAAC;QAC1ChB,UAAU,CAACM,cAAc,EAAE,CAAC,GAAGL,SAAS,CAACgB,CAAC;QAC1CjB,UAAU,CAACM,cAAc,EAAE,CAAC,GAAGL,SAAS,CAACiB,CAAC;MAC5C;IACF;EACF;EAEA,MAAMY,UAAU,GAAG,IAAIzG,kBAAkB,CAAC,CAAC;EAE3C,IAAIqB,YAAY,CAAC+C,QAAQ,EAAE;IACzBqC,UAAU,CAACrC,QAAQ,GAAG,IAAIrE,iBAAiB,CAAC;MAC1C2G,iBAAiB,EAAEjH,iBAAiB,CAACkH,MAAM;MAC3CC,sBAAsB,EAAE,CAAC;MACzBC,MAAM,EAAE5F;IACV,CAAC,CAAC;EACJ;EAEA,IAAII,YAAY,CAACkD,MAAM,EAAE;IACvBkC,UAAU,CAAClC,MAAM,GAAG,IAAIxE,iBAAiB,CAAC;MACxC2G,iBAAiB,EAAEjH,iBAAiB,CAACqH,KAAK;MAC1CF,sBAAsB,EAAE,CAAC;MACzBC,MAAM,EAAEvC;IACV,CAAC,CAAC;EACJ;EAEA,IAAIjD,YAAY,CAACqD,OAAO,EAAE;IACxB+B,UAAU,CAAC/B,OAAO,GAAG,IAAI3E,iBAAiB,CAAC;MACzC2G,iBAAiB,EAAEjH,iBAAiB,CAACqH,KAAK;MAC1CF,sBAAsB,EAAE,CAAC;MACzBC,MAAM,EAAEpC;IACV,CAAC,CAAC;EACJ;EAEA,IAAIpD,YAAY,CAACuD,SAAS,EAAE;IAC1B6B,UAAU,CAAC7B,SAAS,GAAG,IAAI7E,iBAAiB,CAAC;MAC3C2G,iBAAiB,EAAEjH,iBAAiB,CAACqH,KAAK;MAC1CF,sBAAsB,EAAE,CAAC;MACzBC,MAAM,EAAElC;IACV,CAAC,CAAC;EACJ;EAEA,IAAItD,YAAY,CAACyD,EAAE,EAAE;IACnB2B,UAAU,CAAC3B,EAAE,GAAG,IAAI/E,iBAAiB,CAAC;MACpC2G,iBAAiB,EAAEjH,iBAAiB,CAACqH,KAAK;MAC1CF,sBAAsB,EAAE,CAAC;MACzBC,MAAM,EAAEhC;IACV,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAMkC,WAAW,GAAG5C,IAAI,GAAG,CAAC;EAC5BA,IAAI,IAAI,CAAC,IAAID,UAAU,GAAG,CAAC,CAAC;EAC5B,MAAM8C,OAAO,GAAG/G,aAAa,CAACgH,gBAAgB,CAACF,WAAW,EAAE5C,IAAI,CAAC;EAEjE,IAAI+C,SAAS,GAAG,CAAC;EACjB,KAAKzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsE,WAAW,GAAG,CAAC,EAAEtE,CAAC,IAAI,CAAC,EAAE;IACvC,MAAM0E,EAAE,GAAG1E,CAAC;IACZ,MAAM2E,EAAE,GAAG3E,CAAC,GAAG,CAAC;IAChB,MAAM4E,EAAE,GAAG7H,UAAU,CAACiG,SAAS,CAC7BxE,SAAS,EACTkG,EAAE,GAAG,CAAC,EACN7G,0BACF,CAAC;IACD,MAAMgH,EAAE,GAAG9H,UAAU,CAACiG,SAAS,CAC7BxE,SAAS,EACTmG,EAAE,GAAG,CAAC,EACN7G,0BACF,CAAC;IACD,IAAIf,UAAU,CAAC+G,aAAa,CAACc,EAAE,EAAEC,EAAE,EAAEpH,UAAU,CAACsG,SAAS,CAAC,EAAE;MAC1D;IACF;IACA,MAAMe,EAAE,GAAG9E,CAAC,GAAG,CAAC;IAChB,MAAM+E,EAAE,GAAG/E,CAAC,GAAG,CAAC;IAEhBuE,OAAO,CAACE,SAAS,EAAE,CAAC,GAAGK,EAAE;IACzBP,OAAO,CAACE,SAAS,EAAE,CAAC,GAAGC,EAAE;IACzBH,OAAO,CAACE,SAAS,EAAE,CAAC,GAAGM,EAAE;IACzBR,OAAO,CAACE,SAAS,EAAE,CAAC,GAAGM,EAAE;IACzBR,OAAO,CAACE,SAAS,EAAE,CAAC,GAAGC,EAAE;IACzBH,OAAO,CAACE,SAAS,EAAE,CAAC,GAAGE,EAAE;EAC3B;EAEA,OAAO,IAAItH,QAAQ,CAAC;IAClB2G,UAAU,EAAEA,UAAU;IACtBO,OAAO,EAAEA,OAAO;IAChBS,aAAa,EAAEtH,aAAa,CAACuH,SAAS;IACtCC,cAAc,EAAE,IAAIpI,cAAc,CAACqI,YAAY,CAAC3G,SAAS;EAC3D,CAAC,CAAC;AACJ,CAAC;AACD,eAAeJ,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}