{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport HilbertOrder from \"../Core/HilbertOrder.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport S2Cell from \"../Core/S2Cell.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport BoundingVolumeSemantics from \"./BoundingVolumeSemantics.js\";\n\n/**\n * A specialized {@link Cesium3DTileContent} that lazily evaluates an implicit\n * tileset. It is somewhat similar in operation to a\n * {@link Tileset3DTileContent} in that once the content is constructed, it\n * updates the tileset tree with more tiles. However, unlike external tilesets,\n * child subtrees are represented as additional placeholder nodes with\n * Implicit3DTileContent.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n * This object is normally not instantiated directly, use {@link Implicit3DTileContent.fromSubtreeJson}.\n *\n * @alias Implicit3DTileContent\n * @constructor\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The tile this content belongs to.\n * @param {Resource} resource The resource for the tileset\n * @param {object} [json] The JSON object containing the subtree. Mutually exclusive with arrayBuffer.\n * @param {ArrayBuffer} [arrayBuffer] The array buffer that stores the content payload. Mutually exclusive with json.\n * @param {number} [byteOffset=0] The offset into the array buffer, if one was provided\n *\n * @exception {DeveloperError} One of json and arrayBuffer must be defined.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Implicit3DTileContent(tileset, tile, resource) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"tile.implicitTileset\", tile.implicitTileset);\n  Check.defined(\"tile.implicitCoordinates\", tile.implicitCoordinates);\n  //>>includeEnd('debug');\n\n  const implicitTileset = tile.implicitTileset;\n  const implicitCoordinates = tile.implicitCoordinates;\n  this._implicitTileset = implicitTileset;\n  this._implicitCoordinates = implicitCoordinates;\n  this._implicitSubtree = undefined;\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._metadata = undefined;\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n  const templateValues = implicitCoordinates.getTemplateValues();\n  const subtreeResource = implicitTileset.subtreeUriTemplate.getDerivedResource({\n    templateValues: templateValues\n  });\n  this._url = subtreeResource.getUrlComponent(true);\n  this._ready = false;\n}\nObject.defineProperties(Implicit3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  pointsLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  trianglesLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  innerContents: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Implicit3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  url: {\n    get: function () {\n      return this._url;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Implicit3DTileContent</code>\n   * always returns <code>undefined</code>. Only transcoded tiles have content metadata.\n   * @memberof Implicit3DTileContent.prototype\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Implicit3DTileContent cannot have metadata\");\n      //>>includeEnd('debug');\n    }\n  },\n  batchTable: {\n    get: function () {\n      return undefined;\n    }\n  },\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    }\n  }\n});\n\n/**\n * Initialize the implicit content by parsing the subtree resource and setting\n * up a promise chain to expand the immediate subtree.\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The tile this content belongs to.\n * @param {Resource} resource The resource for the tileset\n * @param {object} [json] The JSON containing the subtree. Mutually exclusive with arrayBuffer.\n * @param {ArrayBuffer} [arrayBuffer] The ArrayBuffer containing a subtree binary. Mutually exclusive with json.\n * @param {number} [byteOffset=0] The byte offset into the arrayBuffer\n * @return {Promise<Implicit3DTileContent>}\n *\n * @exception {DeveloperError} One of json and arrayBuffer must be defined.\n *\n * @private\n */\nImplicit3DTileContent.fromSubtreeJson = async function (tileset, tile, resource, json, arrayBuffer, byteOffset) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"tile.implicitTileset\", tile.implicitTileset);\n  Check.defined(\"tile.implicitCoordinates\", tile.implicitCoordinates);\n  if (defined(json) === defined(arrayBuffer)) {\n    throw new DeveloperError(\"One of json and arrayBuffer must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = defaultValue(byteOffset, 0);\n  let uint8Array;\n  if (defined(arrayBuffer)) {\n    uint8Array = new Uint8Array(arrayBuffer, byteOffset);\n  }\n  const implicitTileset = tile.implicitTileset;\n  const implicitCoordinates = tile.implicitCoordinates;\n  const subtree = await ImplicitSubtree.fromSubtreeJson(resource, json, uint8Array, implicitTileset, implicitCoordinates);\n  const content = new Implicit3DTileContent(tileset, tile, resource);\n  content._implicitSubtree = subtree;\n  expandSubtree(content, subtree);\n  content._ready = true;\n  return content;\n};\n\n/**\n * Expand a single subtree placeholder tile. This transcodes the subtree into\n * a tree of {@link Cesium3DTile}. The root of this tree is stored in\n * the placeholder tile's children array. This method also creates placeholder\n * tiles for the child subtrees to be lazily expanded as needed.\n *\n * @param {Implicit3DTileContent} content The content\n * @param {ImplicitSubtree} subtree The parsed subtree\n * @private\n */\nfunction expandSubtree(content, subtree) {\n  const placeholderTile = content._tile;\n\n  // Parse the tiles inside this immediate subtree\n  const childIndex = content._implicitCoordinates.childIndex;\n  const results = transcodeSubtreeTiles(content, subtree, placeholderTile, childIndex);\n  const statistics = content._tileset.statistics;\n\n  // Link the new subtree to the existing placeholder tile.\n  placeholderTile.children.push(results.rootTile);\n  statistics.numberOfTilesTotal++;\n\n  // for each child subtree, make new placeholder tiles\n  const childSubtrees = listChildSubtrees(content, subtree, results.bottomRow);\n  for (let i = 0; i < childSubtrees.length; i++) {\n    const subtreeLocator = childSubtrees[i];\n    const leafTile = subtreeLocator.tile;\n    const implicitChildTile = makePlaceholderChildSubtree(content, leafTile, subtreeLocator.childIndex);\n    leafTile.children.push(implicitChildTile);\n    statistics.numberOfTilesTotal++;\n  }\n}\n\n/**\n * A pair of (tile, childIndex) used for finding child subtrees.\n *\n * @typedef {object} ChildSubtreeLocator\n * @property {Cesium3DTile} tile One of the tiles in the bottommost row of the subtree.\n * @property {number} childIndex The morton index of the child tile relative to its parent\n * @private\n */\n\n/**\n * Determine what child subtrees exist and return a list of information\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {ImplicitSubtree} subtree The subtree for looking up availability\n * @param {Array<Cesium3DTile|undefined>} bottomRow The bottom row of tiles in a transcoded subtree\n * @returns {ChildSubtreeLocator[]} A list of identifiers for the child subtrees.\n * @private\n */\nfunction listChildSubtrees(content, subtree, bottomRow) {\n  const results = [];\n  const branchingFactor = content._implicitTileset.branchingFactor;\n  for (let i = 0; i < bottomRow.length; i++) {\n    const leafTile = bottomRow[i];\n    if (!defined(leafTile)) {\n      continue;\n    }\n    for (let j = 0; j < branchingFactor; j++) {\n      const index = i * branchingFactor + j;\n      if (subtree.childSubtreeIsAvailableAtIndex(index)) {\n        results.push({\n          tile: leafTile,\n          childIndex: j\n        });\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Results of transcodeSubtreeTiles, containing the root tile of the\n * subtree and the bottom row of nodes for further processing.\n *\n * @typedef {object} TranscodedSubtree\n * @property {Cesium3DTile} rootTile The transcoded root tile of the subtree\n * @property {Array<Cesium3DTile|undefined>} bottomRow The bottom row of transcoded tiles. This is helpful for processing child subtrees\n * @private\n */\n\n/**\n * Transcode the implicitly-defined tiles within this subtree and generate\n * explicit {@link Cesium3DTile} objects. This function only transcode tiles,\n * child subtrees are handled separately.\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {ImplicitSubtree} subtree The subtree to get availability information\n * @param {Cesium3DTile} placeholderTile The placeholder tile, used for constructing the subtree root tile\n * @param {number} childIndex The Morton index of the root tile relative to parentOfRootTile\n * @returns {TranscodedSubtree} The newly created subtree of tiles\n * @private\n */\nfunction transcodeSubtreeTiles(content, subtree, placeholderTile, childIndex) {\n  const rootBitIndex = 0;\n  const rootParentIsPlaceholder = true;\n  const rootTile = deriveChildTile(content, subtree, placeholderTile, childIndex, rootBitIndex, rootParentIsPlaceholder);\n  const statistics = content._tileset.statistics;\n\n  // Sliding window over the levels of the tree.\n  // Each row is branchingFactor * length of previous row\n  // Tiles within a row are ordered by Morton index.\n  let parentRow = [rootTile];\n  let currentRow = [];\n  const implicitTileset = content._implicitTileset;\n  for (let level = 1; level < implicitTileset.subtreeLevels; level++) {\n    const levelOffset = subtree.getLevelOffset(level);\n    const numberOfChildren = implicitTileset.branchingFactor * parentRow.length;\n    for (let childMortonIndex = 0; childMortonIndex < numberOfChildren; childMortonIndex++) {\n      const childBitIndex = levelOffset + childMortonIndex;\n      if (!subtree.tileIsAvailableAtIndex(childBitIndex)) {\n        currentRow.push(undefined);\n        continue;\n      }\n      const parentMortonIndex = subtree.getParentMortonIndex(childMortonIndex);\n      const parentTile = parentRow[parentMortonIndex];\n      const childChildIndex = childMortonIndex % implicitTileset.branchingFactor;\n      const childTile = deriveChildTile(content, subtree, parentTile, childChildIndex, childBitIndex);\n      parentTile.children.push(childTile);\n      statistics.numberOfTilesTotal++;\n      currentRow.push(childTile);\n    }\n    parentRow = currentRow;\n    currentRow = [];\n  }\n  return {\n    rootTile: rootTile,\n    // At the end of the last loop, bottomRow was moved to parentRow\n    bottomRow: parentRow\n  };\n}\nfunction getGeometricError(tileMetadata, implicitTileset, implicitCoordinates) {\n  const semantic = MetadataSemantic.TILE_GEOMETRIC_ERROR;\n  if (defined(tileMetadata) && tileMetadata.hasPropertyBySemantic(semantic)) {\n    return tileMetadata.getPropertyBySemantic(semantic);\n  }\n  return implicitTileset.geometricError / Math.pow(2, implicitCoordinates.level);\n}\n\n/**\n * Given a parent tile and information about which child to create, derive\n * the properties of the child tile implicitly.\n * <p>\n * This creates a real tile for rendering, not a placeholder tile like some of\n * the other methods of ImplicitTileset.\n * </p>\n *\n * @param {Implicit3DTileContent} implicitContent The implicit content\n * @param {ImplicitSubtree} subtree The subtree the child tile belongs to\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {number} childBitIndex The index of the child tile within the tile's availability information.\n * @param {boolean} [parentIsPlaceholderTile=false] True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @returns {Cesium3DTile} The new child tile.\n * @private\n */\nfunction deriveChildTile(implicitContent, subtree, parentTile, childIndex, childBitIndex, parentIsPlaceholderTile) {\n  const implicitTileset = implicitContent._implicitTileset;\n  let implicitCoordinates;\n  if (defaultValue(parentIsPlaceholderTile, false)) {\n    implicitCoordinates = parentTile.implicitCoordinates;\n  } else {\n    implicitCoordinates = parentTile.implicitCoordinates.getChildCoordinates(childIndex);\n  }\n\n  // Parse metadata and bounding volume semantics at the beginning\n  // as the bounding volumes are needed below.\n  let tileMetadata;\n  let tileBounds;\n  let contentBounds;\n  if (defined(subtree.tilePropertyTableJson)) {\n    tileMetadata = subtree.getTileMetadataView(implicitCoordinates);\n    const boundingVolumeSemantics = BoundingVolumeSemantics.parseAllBoundingVolumeSemantics(tileMetadata);\n    tileBounds = boundingVolumeSemantics.tile;\n    contentBounds = boundingVolumeSemantics.content;\n  }\n\n  // Content is not loaded at this point, so this flag is set for future reference.\n  const contentPropertyTableJsons = subtree.contentPropertyTableJsons;\n  const length = contentPropertyTableJsons.length;\n  let hasImplicitContentMetadata = false;\n  for (let i = 0; i < length; i++) {\n    if (subtree.contentIsAvailableAtCoordinates(implicitCoordinates, i)) {\n      hasImplicitContentMetadata = true;\n      break;\n    }\n  }\n  const boundingVolume = getTileBoundingVolume(implicitTileset, implicitCoordinates, childIndex, parentIsPlaceholderTile, parentTile, tileBounds);\n  const contentJsons = [];\n  for (let i = 0; i < implicitTileset.contentCount; i++) {\n    if (!subtree.contentIsAvailableAtIndex(childBitIndex, i)) {\n      continue;\n    }\n    const childContentTemplate = implicitTileset.contentUriTemplates[i];\n    const childContentUri = childContentTemplate.getDerivedResource({\n      templateValues: implicitCoordinates.getTemplateValues()\n    }).url;\n    const contentJson = {\n      uri: childContentUri\n    };\n    const contentBoundingVolume = getContentBoundingVolume(boundingVolume, contentBounds);\n    if (defined(contentBoundingVolume)) {\n      contentJson.boundingVolume = contentBoundingVolume;\n    }\n\n    // combine() is used to pass through any additional properties the\n    // user specified such as extras or extensions\n    contentJsons.push(combine(contentJson, implicitTileset.contentHeaders[i]));\n  }\n  const childGeometricError = getGeometricError(tileMetadata, implicitTileset, implicitCoordinates);\n  const tileJson = {\n    boundingVolume: boundingVolume,\n    geometricError: childGeometricError,\n    refine: implicitTileset.refine,\n    contents: contentJsons\n  };\n\n  // combine() is used to pass through any additional properties the\n  // user specified such as extras or extensions.\n  const deep = true;\n  const rootHeader = clone(implicitTileset.tileHeader, deep);\n  // The bounding volume was computed above since it may come from metadata\n  // in the subtree file.\n  delete rootHeader.boundingVolume;\n  // Copying the transform to all the transcoded tiles would cause the transform\n  // to be applied multiple times. Removing it from the header avoids this issue.\n  delete rootHeader.transform;\n  // The implicit tiling spec does not specify what should happen if explicit\n  // tile metadata is added to the placeholder tile. Since implicit tile\n  // metadata comes from the subtree file, ignore the explicit version.\n  //\n  // Also, when a property with the semantic TILE_BOUNDING_VOLUME is added to\n  // the placeholder tile to set a tight bounding volume (See Cesium3DTile.js)\n  // propagating it to transcoded tiles causes transcoded tiles to use the\n  // wrong bounding volume, this can lead to loading far too many tiles.\n  delete rootHeader.metadata;\n  const combinedTileJson = combine(tileJson, rootHeader, deep);\n  const childTile = makeTile(implicitContent, implicitTileset.baseResource, combinedTileJson, parentTile);\n  childTile.implicitCoordinates = implicitCoordinates;\n  childTile.implicitSubtree = subtree;\n  childTile.metadata = tileMetadata;\n  childTile.hasImplicitContentMetadata = hasImplicitContentMetadata;\n  return childTile;\n}\n\n/**\n * Checks whether the bounding volume's heights can be updated.\n * Returns true if the minimumHeight/maximumHeight parameter\n * is defined and the bounding volume is a region or S2 cell.\n *\n * @param {object} [boundingVolume] The bounding volume\n * @param {object} [tileBounds] The tile bounds\n * @param {number} [tileBounds.minimumHeight] The minimum height\n * @param {number} [tileBounds.maximumHeight] The maximum height\n * @returns {boolean} Whether the bounding volume's heights can be updated\n * @private\n */\nfunction canUpdateHeights(boundingVolume, tileBounds) {\n  return defined(boundingVolume) && defined(tileBounds) && (defined(tileBounds.minimumHeight) || defined(tileBounds.maximumHeight)) && (hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\") || defined(boundingVolume.region));\n}\n\n/**\n * Update the minimum and maximum height of the bounding volume.\n * This is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined and the\n * bounding volume is a region or S2 cell.\n *\n * @param {object} boundingVolume The bounding volume\n * @param {object} [tileBounds] The tile bounds\n * @param {number} [tileBounds.minimumHeight] The new minimum height\n * @param {number} [tileBounds.maximumHeight] The new maximum height\n * @private\n */\nfunction updateHeights(boundingVolume, tileBounds) {\n  if (!defined(tileBounds)) {\n    return;\n  }\n  if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\")) {\n    updateS2CellHeights(boundingVolume.extensions[\"3DTILES_bounding_volume_S2\"], tileBounds.minimumHeight, tileBounds.maximumHeight);\n  } else if (defined(boundingVolume.region)) {\n    updateRegionHeights(boundingVolume.region, tileBounds.minimumHeight, tileBounds.maximumHeight);\n  }\n}\n\n/**\n * For a bounding region, update the minimum and maximum height. This\n * is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined.\n *\n * @param {Array} region A 6-element array describing the bounding region\n * @param {number} [minimumHeight] The new minimum height\n * @param {number} [maximumHeight] The new maximum height\n * @private\n */\nfunction updateRegionHeights(region, minimumHeight, maximumHeight) {\n  if (defined(minimumHeight)) {\n    region[4] = minimumHeight;\n  }\n  if (defined(maximumHeight)) {\n    region[5] = maximumHeight;\n  }\n}\n\n/**\n * For a bounding S2 cell, update the minimum and maximum height. This\n * is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined.\n *\n * @param {object} s2CellVolume An object describing the S2 cell\n * @param {number} [minimumHeight] The new minimum height\n * @param {number} [maximumHeight] The new maximum height\n * @private\n */\nfunction updateS2CellHeights(s2CellVolume, minimumHeight, maximumHeight) {\n  if (defined(minimumHeight)) {\n    s2CellVolume.minimumHeight = minimumHeight;\n  }\n  if (defined(maximumHeight)) {\n    s2CellVolume.maximumHeight = maximumHeight;\n  }\n}\n\n/**\n * Gets the tile's bounding volume, which may be specified via\n * metadata semantics such as TILE_BOUNDING_BOX or implicitly\n * derived from the implicit root tile's bounding volume.\n * <p>\n * Priority of bounding volume types:\n * <ol>\n * <li>Explicit min/max height\n *   <ol>\n *     <li>With explicit region</li>\n *     <li>With implicit S2</li>\n *     <li>With implicit region</li>\n *   </ol>\n * </li>\n * <li>Explicit box</li>\n * <li>Explicit region</li>\n * <li>Explicit sphere</li>\n * <li>Implicit S2</li>\n * <li>Implicit box</li>\n * <li>Implicit region</li>\n * </ol>\n * </p>\n *\n * @param {ImplicitTileset} implicitTileset The implicit tileset struct which holds the root bounding volume\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {object} [tileBounds] The tile bounds\n * @returns {object} An object containing the JSON for a bounding volume\n * @private\n */\nfunction getTileBoundingVolume(implicitTileset, implicitCoordinates, childIndex, parentIsPlaceholderTile, parentTile, tileBounds) {\n  let boundingVolume;\n  if (!defined(tileBounds) || !defined(tileBounds.boundingVolume) || !canUpdateHeights(tileBounds.boundingVolume, tileBounds) && canUpdateHeights(implicitTileset.boundingVolume, tileBounds)) {\n    boundingVolume = deriveBoundingVolume(implicitTileset, implicitCoordinates, childIndex, defaultValue(parentIsPlaceholderTile, false), parentTile);\n  } else {\n    boundingVolume = tileBounds.boundingVolume;\n  }\n\n  // The TILE_MINIMUM_HEIGHT and TILE_MAXIMUM_HEIGHT metadata semantics\n  // can be used to tighten the bounding volume\n  updateHeights(boundingVolume, tileBounds);\n  return boundingVolume;\n}\n\n/**\n * Gets the content bounding volume, which may be specified via\n * metadata semantics such as CONTENT_BOUNDING_BOX.\n * <p>\n * Priority of bounding volume types:\n * <ol>\n * <li>Explicit min/max height\n *   <ol>\n *     <li>With explicit region</li>\n *     <li>With tile bounding volume (S2 or region)</li>\n *   </ol>\n * </li>\n * <li>Explicit box</li>\n * <li>Explicit region</li>\n * <li>Explicit sphere</li>\n * <li>Tile bounding volume (when content.boundingVolume is undefined)</li>\n * </ol>\n * </p>\n *\n * @param {object} tileBoundingVolume An object containing the JSON for the tile's bounding volume\n * @param {object} [contentBounds] The content bounds\n * @returns {object|undefined} An object containing the JSON for a bounding volume, or <code>undefined</code> if there is no bounding volume\n * @private\n */\nfunction getContentBoundingVolume(tileBoundingVolume, contentBounds) {\n  // content bounding volumes can only be specified via\n  // metadata semantics such as CONTENT_BOUNDING_BOX\n  let contentBoundingVolume;\n  if (defined(contentBounds)) {\n    contentBoundingVolume = contentBounds.boundingVolume;\n  }\n\n  // The CONTENT_MINIMUM_HEIGHT and CONTENT_MAXIMUM_HEIGHT metadata semantics\n  // can be used to tighten the bounding volume\n  if (canUpdateHeights(contentBoundingVolume, contentBounds)) {\n    updateHeights(contentBoundingVolume, contentBounds);\n  } else if (canUpdateHeights(tileBoundingVolume, contentBounds)) {\n    contentBoundingVolume = clone(tileBoundingVolume, true);\n    updateHeights(contentBoundingVolume, contentBounds);\n  }\n  return contentBoundingVolume;\n}\n\n/**\n * Given the coordinates of a tile, derive its bounding volume from the root.\n *\n * @param {ImplicitTileset} implicitTileset The implicit tileset struct which holds the root bounding volume\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @returns {object} An object containing the JSON for a bounding volume\n * @private\n */\nfunction deriveBoundingVolume(implicitTileset, implicitCoordinates, childIndex, parentIsPlaceholderTile, parentTile) {\n  const rootBoundingVolume = implicitTileset.boundingVolume;\n  if (hasExtension(rootBoundingVolume, \"3DTILES_bounding_volume_S2\")) {\n    return deriveBoundingVolumeS2(parentIsPlaceholderTile, parentTile, childIndex, implicitCoordinates.level, implicitCoordinates.x, implicitCoordinates.y, implicitCoordinates.z);\n  }\n  if (defined(rootBoundingVolume.region)) {\n    const childRegion = deriveBoundingRegion(rootBoundingVolume.region, implicitCoordinates.level, implicitCoordinates.x, implicitCoordinates.y, implicitCoordinates.z);\n    return {\n      region: childRegion\n    };\n  }\n  const childBox = deriveBoundingBox(rootBoundingVolume.box, implicitCoordinates.level, implicitCoordinates.x, implicitCoordinates.y, implicitCoordinates.z);\n  return {\n    box: childBox\n  };\n}\n\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (x, y), leaving the z axis unchanged.\n * </p>\n *\n * @param {boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {number} level The level of the descendant tile relative to the root implicit tile\n * @param {number} x The x coordinate of the descendant tile\n * @param {number} y The y coordinate of the descendant tile\n * @param {number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {object} An object with the 3DTILES_bounding_volume_S2 extension.\n * @private\n */\nfunction deriveBoundingVolumeS2(parentIsPlaceholderTile, parentTile, childIndex, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"parentIsPlaceholderTile\", parentIsPlaceholderTile);\n  Check.typeOf.object(\"parentTile\", parentTile);\n  Check.typeOf.number(\"childIndex\", childIndex);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  const boundingVolumeS2 = parentTile._boundingVolume;\n\n  // Handle the placeholder tile case, where we just duplicate the placeholder's bounding volume.\n  if (parentIsPlaceholderTile) {\n    return {\n      extensions: {\n        \"3DTILES_bounding_volume_S2\": {\n          token: S2Cell.getTokenFromId(boundingVolumeS2.s2Cell._cellId),\n          minimumHeight: boundingVolumeS2.minimumHeight,\n          maximumHeight: boundingVolumeS2.maximumHeight\n        }\n      }\n    };\n  }\n\n  // Extract the first 3 face bits from the 64-bit S2 cell ID.\n  // eslint-disable-next-line no-undef\n  const face = Number(parentTile._boundingVolume.s2Cell._cellId >> BigInt(61));\n  // The Hilbert curve is rotated for the \"odd\" faces on the S2 Earthcube.\n  // See http://s2geometry.io/devguide/img/s2cell_global.jpg\n  const position = face % 2 === 0 ? HilbertOrder.encode2D(level, x, y) : HilbertOrder.encode2D(level, y, x);\n  // eslint-disable-next-line no-undef\n  const cell = S2Cell.fromFacePositionLevel(face, BigInt(position), level);\n  let minHeight, maxHeight;\n  if (defined(z)) {\n    const midpointHeight = (boundingVolumeS2.maximumHeight + boundingVolumeS2.minimumHeight) / 2;\n    minHeight = childIndex < 4 ? boundingVolumeS2.minimumHeight : midpointHeight;\n    maxHeight = childIndex < 4 ? midpointHeight : boundingVolumeS2.maximumHeight;\n  } else {\n    minHeight = boundingVolumeS2.minimumHeight;\n    maxHeight = boundingVolumeS2.maximumHeight;\n  }\n  return {\n    extensions: {\n      \"3DTILES_bounding_volume_S2\": {\n        token: S2Cell.getTokenFromId(cell._cellId),\n        minimumHeight: minHeight,\n        maximumHeight: maxHeight\n      }\n    }\n  };\n}\nconst scratchScaleFactors = new Cartesian3();\nconst scratchRootCenter = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchHalfAxes = new Matrix3();\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (x, y), leaving the z axis unchanged.\n * </p>\n * <p>\n * This computes the child volume directly from the root bounding volume rather\n * than recursively subdividing to minimize floating point error.\n * </p>\n *\n * @param {number[]} rootBox An array of 12 numbers representing the bounding box of the root tile\n * @param {number} level The level of the descendant tile relative to the root implicit tile\n * @param {number} x The x coordinate of the descendant tile\n * @param {number} y The y coordinate of the descendant tile\n * @param {number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {number[]} An array of 12 numbers representing the bounding box of the descendant tile.\n * @private\n */\nfunction deriveBoundingBox(rootBox, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rootBox\", rootBox);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  if (level === 0) {\n    return rootBox;\n  }\n  const rootCenter = Cartesian3.unpack(rootBox, 0, scratchRootCenter);\n  const rootHalfAxes = Matrix3.unpack(rootBox, 3, scratchHalfAxes);\n  const tileScale = Math.pow(2, -level);\n  const modelSpaceX = -1 + (2 * x + 1) * tileScale;\n  const modelSpaceY = -1 + (2 * y + 1) * tileScale;\n  let modelSpaceZ = 0;\n  const scaleFactors = Cartesian3.fromElements(tileScale, tileScale, 1, scratchScaleFactors);\n  if (defined(z)) {\n    modelSpaceZ = -1 + (2 * z + 1) * tileScale;\n    scaleFactors.z = tileScale;\n  }\n  let center = Cartesian3.fromElements(modelSpaceX, modelSpaceY, modelSpaceZ, scratchCenter);\n  center = Matrix3.multiplyByVector(rootHalfAxes, center, scratchCenter);\n  center = Cartesian3.add(center, rootCenter, scratchCenter);\n  let halfAxes = Matrix3.clone(rootHalfAxes);\n  halfAxes = Matrix3.multiplyByScale(halfAxes, scaleFactors, halfAxes);\n  const childBox = new Array(12);\n  Cartesian3.pack(center, childBox);\n  Matrix3.pack(halfAxes, childBox, 3);\n  return childBox;\n}\nconst scratchRectangle = new Rectangle();\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (mid_longitude, mid_latitude), leaving the height values\n * unchanged.\n * </p>\n * <p>\n * This computes the child volume directly from the root bounding volume rather\n * than recursively subdividing to minimize floating point error.\n * </p>\n * @param {number[]} rootRegion An array of 6 numbers representing the root implicit tile\n * @param {number} level The level of the descendant tile relative to the root implicit tile\n * @param {number} x The x coordinate of the descendant tile\n * @param {number} y The x coordinate of the descendant tile\n * @param {number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {number[]} An array of 6 numbers representing the bounding region of the descendant tile\n * @private\n */\nfunction deriveBoundingRegion(rootRegion, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rootRegion\", rootRegion);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  if (level === 0) {\n    return rootRegion.slice();\n  }\n  const rectangle = Rectangle.unpack(rootRegion, 0, scratchRectangle);\n  const rootMinimumHeight = rootRegion[4];\n  const rootMaximumHeight = rootRegion[5];\n  const tileScale = Math.pow(2, -level);\n  const childWidth = tileScale * rectangle.width;\n  const west = CesiumMath.negativePiToPi(rectangle.west + x * childWidth);\n  const east = CesiumMath.negativePiToPi(west + childWidth);\n  const childHeight = tileScale * rectangle.height;\n  const south = CesiumMath.negativePiToPi(rectangle.south + y * childHeight);\n  const north = CesiumMath.negativePiToPi(south + childHeight);\n\n  // Height is only subdivided for octrees; It remains constant for quadtrees.\n  let minimumHeight = rootMinimumHeight;\n  let maximumHeight = rootMaximumHeight;\n  if (defined(z)) {\n    const childThickness = tileScale * (rootMaximumHeight - rootMinimumHeight);\n    minimumHeight += z * childThickness;\n    maximumHeight = minimumHeight + childThickness;\n  }\n  return [west, south, east, north, minimumHeight, maximumHeight];\n}\n\n/**\n * Create a placeholder 3D Tile whose content will be an Implicit3DTileContent\n * for lazy evaluation of a child subtree.\n *\n * @param {Implicit3DTileContent} content The content object.\n * @param {Cesium3DTile} parentTile The parent of the new child subtree.\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @returns {Cesium3DTile} The new placeholder tile\n * @private\n */\nfunction makePlaceholderChildSubtree(content, parentTile, childIndex) {\n  const implicitTileset = content._implicitTileset;\n  const implicitCoordinates = parentTile.implicitCoordinates.getChildCoordinates(childIndex);\n  const childBoundingVolume = deriveBoundingVolume(implicitTileset, implicitCoordinates, childIndex, false, parentTile);\n\n  // Ignore tile metadata when computing geometric error for the placeholder tile\n  // since the child subtree's metadata hasn't been loaded yet.\n  // The actual geometric error will be computed in deriveChildTile.\n  const childGeometricError = getGeometricError(undefined, implicitTileset, implicitCoordinates);\n  const childContentUri = implicitTileset.subtreeUriTemplate.getDerivedResource({\n    templateValues: implicitCoordinates.getTemplateValues()\n  }).url;\n  const tileJson = {\n    boundingVolume: childBoundingVolume,\n    geometricError: childGeometricError,\n    refine: implicitTileset.refine,\n    contents: [{\n      uri: childContentUri\n    }]\n  };\n  const tile = makeTile(content, implicitTileset.baseResource, tileJson, parentTile);\n  tile.implicitTileset = implicitTileset;\n  tile.implicitCoordinates = implicitCoordinates;\n  return tile;\n}\n\n/**\n * Make a {@link Cesium3DTile}. This uses the content's tile's constructor instead\n * of importing Cesium3DTile. This is to avoid a circular dependency between\n * this file and Cesium3DTile.js\n * @param {Implicit3DTileContent} content The implicit content\n * @param {Resource} baseResource The base resource for the tileset\n * @param {object} tileJson The JSON header for the tile\n * @param {Cesium3DTile} parentTile The parent of the new tile\n * @returns {Cesium3DTile} The newly created tile.\n * @private\n */\nfunction makeTile(content, baseResource, tileJson, parentTile) {\n  const Cesium3DTile = content._tile.constructor;\n  return new Cesium3DTile(content._tileset, baseResource, tileJson, parentTile);\n}\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Implicit3DTileContent</code>\n * always returns <code>false</code> since a tile of this type does not have any features.\n * @private\n */\nImplicit3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Implicit3DTileContent</code>\n * always returns <code>undefined</code> since a tile of this type does not have any features.\n * @private\n */\nImplicit3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\nImplicit3DTileContent.prototype.applyDebugSettings = function (enabled, color) {};\nImplicit3DTileContent.prototype.applyStyle = function (style) {};\nImplicit3DTileContent.prototype.update = function (tileset, frameState) {};\nImplicit3DTileContent.prototype.pick = function (ray, frameState, result) {\n  return undefined;\n};\nImplicit3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\nImplicit3DTileContent.prototype.destroy = function () {\n  this._implicitSubtree = this._implicitSubtree && this._implicitSubtree.destroy();\n  return destroyObject(this);\n};\n\n// Exposed for testing\nImplicit3DTileContent._deriveBoundingBox = deriveBoundingBox;\nImplicit3DTileContent._deriveBoundingRegion = deriveBoundingRegion;\nImplicit3DTileContent._deriveBoundingVolumeS2 = deriveBoundingVolumeS2;\nexport default Implicit3DTileContent;","map":{"version":3,"names":["Cartesian3","Check","clone","combine","defaultValue","defined","destroyObject","DeveloperError","CesiumMath","HilbertOrder","Matrix3","Rectangle","S2Cell","ImplicitSubtree","hasExtension","MetadataSemantic","BoundingVolumeSemantics","Implicit3DTileContent","tileset","tile","resource","implicitTileset","implicitCoordinates","_implicitTileset","_implicitCoordinates","_implicitSubtree","undefined","_tileset","_tile","_resource","_metadata","featurePropertiesDirty","_group","templateValues","getTemplateValues","subtreeResource","subtreeUriTemplate","getDerivedResource","_url","getUrlComponent","_ready","Object","defineProperties","prototype","featuresLength","get","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","innerContents","ready","url","metadata","set","batchTable","group","value","fromSubtreeJson","json","arrayBuffer","byteOffset","uint8Array","Uint8Array","subtree","content","expandSubtree","placeholderTile","childIndex","results","transcodeSubtreeTiles","statistics","children","push","rootTile","numberOfTilesTotal","childSubtrees","listChildSubtrees","bottomRow","i","length","subtreeLocator","leafTile","implicitChildTile","makePlaceholderChildSubtree","branchingFactor","j","index","childSubtreeIsAvailableAtIndex","rootBitIndex","rootParentIsPlaceholder","deriveChildTile","parentRow","currentRow","level","subtreeLevels","levelOffset","getLevelOffset","numberOfChildren","childMortonIndex","childBitIndex","tileIsAvailableAtIndex","parentMortonIndex","getParentMortonIndex","parentTile","childChildIndex","childTile","getGeometricError","tileMetadata","semantic","TILE_GEOMETRIC_ERROR","hasPropertyBySemantic","getPropertyBySemantic","geometricError","Math","pow","implicitContent","parentIsPlaceholderTile","getChildCoordinates","tileBounds","contentBounds","tilePropertyTableJson","getTileMetadataView","boundingVolumeSemantics","parseAllBoundingVolumeSemantics","contentPropertyTableJsons","hasImplicitContentMetadata","contentIsAvailableAtCoordinates","boundingVolume","getTileBoundingVolume","contentJsons","contentCount","contentIsAvailableAtIndex","childContentTemplate","contentUriTemplates","childContentUri","contentJson","uri","contentBoundingVolume","getContentBoundingVolume","contentHeaders","childGeometricError","tileJson","refine","contents","deep","rootHeader","tileHeader","transform","combinedTileJson","makeTile","baseResource","implicitSubtree","canUpdateHeights","minimumHeight","maximumHeight","region","updateHeights","updateS2CellHeights","extensions","updateRegionHeights","s2CellVolume","deriveBoundingVolume","tileBoundingVolume","rootBoundingVolume","deriveBoundingVolumeS2","x","y","z","childRegion","deriveBoundingRegion","childBox","deriveBoundingBox","box","typeOf","bool","object","number","boundingVolumeS2","_boundingVolume","token","getTokenFromId","s2Cell","_cellId","face","Number","BigInt","position","encode2D","cell","fromFacePositionLevel","minHeight","maxHeight","midpointHeight","scratchScaleFactors","scratchRootCenter","scratchCenter","scratchHalfAxes","rootBox","rootCenter","unpack","rootHalfAxes","tileScale","modelSpaceX","modelSpaceY","modelSpaceZ","scaleFactors","fromElements","center","multiplyByVector","add","halfAxes","multiplyByScale","Array","pack","scratchRectangle","rootRegion","slice","rectangle","rootMinimumHeight","rootMaximumHeight","childWidth","width","west","negativePiToPi","east","childHeight","height","south","north","childThickness","childBoundingVolume","Cesium3DTile","constructor","hasProperty","batchId","name","getFeature","applyDebugSettings","enabled","color","applyStyle","style","update","frameState","pick","ray","result","isDestroyed","destroy","_deriveBoundingBox","_deriveBoundingRegion","_deriveBoundingVolumeS2"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Implicit3DTileContent.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport HilbertOrder from \"../Core/HilbertOrder.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport S2Cell from \"../Core/S2Cell.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport BoundingVolumeSemantics from \"./BoundingVolumeSemantics.js\";\n\n/**\n * A specialized {@link Cesium3DTileContent} that lazily evaluates an implicit\n * tileset. It is somewhat similar in operation to a\n * {@link Tileset3DTileContent} in that once the content is constructed, it\n * updates the tileset tree with more tiles. However, unlike external tilesets,\n * child subtrees are represented as additional placeholder nodes with\n * Implicit3DTileContent.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n * This object is normally not instantiated directly, use {@link Implicit3DTileContent.fromSubtreeJson}.\n *\n * @alias Implicit3DTileContent\n * @constructor\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The tile this content belongs to.\n * @param {Resource} resource The resource for the tileset\n * @param {object} [json] The JSON object containing the subtree. Mutually exclusive with arrayBuffer.\n * @param {ArrayBuffer} [arrayBuffer] The array buffer that stores the content payload. Mutually exclusive with json.\n * @param {number} [byteOffset=0] The offset into the array buffer, if one was provided\n *\n * @exception {DeveloperError} One of json and arrayBuffer must be defined.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Implicit3DTileContent(tileset, tile, resource) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"tile.implicitTileset\", tile.implicitTileset);\n  Check.defined(\"tile.implicitCoordinates\", tile.implicitCoordinates);\n  //>>includeEnd('debug');\n\n  const implicitTileset = tile.implicitTileset;\n  const implicitCoordinates = tile.implicitCoordinates;\n\n  this._implicitTileset = implicitTileset;\n  this._implicitCoordinates = implicitCoordinates;\n  this._implicitSubtree = undefined;\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._metadata = undefined;\n\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  const templateValues = implicitCoordinates.getTemplateValues();\n  const subtreeResource = implicitTileset.subtreeUriTemplate.getDerivedResource(\n    {\n      templateValues: templateValues,\n    },\n  );\n  this._url = subtreeResource.getUrlComponent(true);\n\n  this._ready = false;\n}\n\nObject.defineProperties(Implicit3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Implicit3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Implicit3DTileContent</code>\n   * always returns <code>undefined</code>. Only transcoded tiles have content metadata.\n   * @memberof Implicit3DTileContent.prototype\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Implicit3DTileContent cannot have metadata\");\n      //>>includeEnd('debug');\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\n/**\n * Initialize the implicit content by parsing the subtree resource and setting\n * up a promise chain to expand the immediate subtree.\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The tile this content belongs to.\n * @param {Resource} resource The resource for the tileset\n * @param {object} [json] The JSON containing the subtree. Mutually exclusive with arrayBuffer.\n * @param {ArrayBuffer} [arrayBuffer] The ArrayBuffer containing a subtree binary. Mutually exclusive with json.\n * @param {number} [byteOffset=0] The byte offset into the arrayBuffer\n * @return {Promise<Implicit3DTileContent>}\n *\n * @exception {DeveloperError} One of json and arrayBuffer must be defined.\n *\n * @private\n */\nImplicit3DTileContent.fromSubtreeJson = async function (\n  tileset,\n  tile,\n  resource,\n  json,\n  arrayBuffer,\n  byteOffset,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"tile.implicitTileset\", tile.implicitTileset);\n  Check.defined(\"tile.implicitCoordinates\", tile.implicitCoordinates);\n  if (defined(json) === defined(arrayBuffer)) {\n    throw new DeveloperError(\"One of json and arrayBuffer must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = defaultValue(byteOffset, 0);\n  let uint8Array;\n  if (defined(arrayBuffer)) {\n    uint8Array = new Uint8Array(arrayBuffer, byteOffset);\n  }\n\n  const implicitTileset = tile.implicitTileset;\n  const implicitCoordinates = tile.implicitCoordinates;\n\n  const subtree = await ImplicitSubtree.fromSubtreeJson(\n    resource,\n    json,\n    uint8Array,\n    implicitTileset,\n    implicitCoordinates,\n  );\n\n  const content = new Implicit3DTileContent(tileset, tile, resource);\n\n  content._implicitSubtree = subtree;\n  expandSubtree(content, subtree);\n  content._ready = true;\n\n  return content;\n};\n\n/**\n * Expand a single subtree placeholder tile. This transcodes the subtree into\n * a tree of {@link Cesium3DTile}. The root of this tree is stored in\n * the placeholder tile's children array. This method also creates placeholder\n * tiles for the child subtrees to be lazily expanded as needed.\n *\n * @param {Implicit3DTileContent} content The content\n * @param {ImplicitSubtree} subtree The parsed subtree\n * @private\n */\nfunction expandSubtree(content, subtree) {\n  const placeholderTile = content._tile;\n\n  // Parse the tiles inside this immediate subtree\n  const childIndex = content._implicitCoordinates.childIndex;\n  const results = transcodeSubtreeTiles(\n    content,\n    subtree,\n    placeholderTile,\n    childIndex,\n  );\n\n  const statistics = content._tileset.statistics;\n\n  // Link the new subtree to the existing placeholder tile.\n  placeholderTile.children.push(results.rootTile);\n  statistics.numberOfTilesTotal++;\n\n  // for each child subtree, make new placeholder tiles\n  const childSubtrees = listChildSubtrees(content, subtree, results.bottomRow);\n  for (let i = 0; i < childSubtrees.length; i++) {\n    const subtreeLocator = childSubtrees[i];\n    const leafTile = subtreeLocator.tile;\n    const implicitChildTile = makePlaceholderChildSubtree(\n      content,\n      leafTile,\n      subtreeLocator.childIndex,\n    );\n    leafTile.children.push(implicitChildTile);\n    statistics.numberOfTilesTotal++;\n  }\n}\n\n/**\n * A pair of (tile, childIndex) used for finding child subtrees.\n *\n * @typedef {object} ChildSubtreeLocator\n * @property {Cesium3DTile} tile One of the tiles in the bottommost row of the subtree.\n * @property {number} childIndex The morton index of the child tile relative to its parent\n * @private\n */\n\n/**\n * Determine what child subtrees exist and return a list of information\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {ImplicitSubtree} subtree The subtree for looking up availability\n * @param {Array<Cesium3DTile|undefined>} bottomRow The bottom row of tiles in a transcoded subtree\n * @returns {ChildSubtreeLocator[]} A list of identifiers for the child subtrees.\n * @private\n */\nfunction listChildSubtrees(content, subtree, bottomRow) {\n  const results = [];\n  const branchingFactor = content._implicitTileset.branchingFactor;\n  for (let i = 0; i < bottomRow.length; i++) {\n    const leafTile = bottomRow[i];\n    if (!defined(leafTile)) {\n      continue;\n    }\n\n    for (let j = 0; j < branchingFactor; j++) {\n      const index = i * branchingFactor + j;\n      if (subtree.childSubtreeIsAvailableAtIndex(index)) {\n        results.push({\n          tile: leafTile,\n          childIndex: j,\n        });\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Results of transcodeSubtreeTiles, containing the root tile of the\n * subtree and the bottom row of nodes for further processing.\n *\n * @typedef {object} TranscodedSubtree\n * @property {Cesium3DTile} rootTile The transcoded root tile of the subtree\n * @property {Array<Cesium3DTile|undefined>} bottomRow The bottom row of transcoded tiles. This is helpful for processing child subtrees\n * @private\n */\n\n/**\n * Transcode the implicitly-defined tiles within this subtree and generate\n * explicit {@link Cesium3DTile} objects. This function only transcode tiles,\n * child subtrees are handled separately.\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {ImplicitSubtree} subtree The subtree to get availability information\n * @param {Cesium3DTile} placeholderTile The placeholder tile, used for constructing the subtree root tile\n * @param {number} childIndex The Morton index of the root tile relative to parentOfRootTile\n * @returns {TranscodedSubtree} The newly created subtree of tiles\n * @private\n */\nfunction transcodeSubtreeTiles(content, subtree, placeholderTile, childIndex) {\n  const rootBitIndex = 0;\n  const rootParentIsPlaceholder = true;\n  const rootTile = deriveChildTile(\n    content,\n    subtree,\n    placeholderTile,\n    childIndex,\n    rootBitIndex,\n    rootParentIsPlaceholder,\n  );\n\n  const statistics = content._tileset.statistics;\n\n  // Sliding window over the levels of the tree.\n  // Each row is branchingFactor * length of previous row\n  // Tiles within a row are ordered by Morton index.\n  let parentRow = [rootTile];\n  let currentRow = [];\n\n  const implicitTileset = content._implicitTileset;\n  for (let level = 1; level < implicitTileset.subtreeLevels; level++) {\n    const levelOffset = subtree.getLevelOffset(level);\n    const numberOfChildren = implicitTileset.branchingFactor * parentRow.length;\n    for (\n      let childMortonIndex = 0;\n      childMortonIndex < numberOfChildren;\n      childMortonIndex++\n    ) {\n      const childBitIndex = levelOffset + childMortonIndex;\n\n      if (!subtree.tileIsAvailableAtIndex(childBitIndex)) {\n        currentRow.push(undefined);\n        continue;\n      }\n\n      const parentMortonIndex = subtree.getParentMortonIndex(childMortonIndex);\n      const parentTile = parentRow[parentMortonIndex];\n      const childChildIndex =\n        childMortonIndex % implicitTileset.branchingFactor;\n      const childTile = deriveChildTile(\n        content,\n        subtree,\n        parentTile,\n        childChildIndex,\n        childBitIndex,\n      );\n      parentTile.children.push(childTile);\n      statistics.numberOfTilesTotal++;\n      currentRow.push(childTile);\n    }\n\n    parentRow = currentRow;\n    currentRow = [];\n  }\n\n  return {\n    rootTile: rootTile,\n    // At the end of the last loop, bottomRow was moved to parentRow\n    bottomRow: parentRow,\n  };\n}\n\nfunction getGeometricError(tileMetadata, implicitTileset, implicitCoordinates) {\n  const semantic = MetadataSemantic.TILE_GEOMETRIC_ERROR;\n\n  if (defined(tileMetadata) && tileMetadata.hasPropertyBySemantic(semantic)) {\n    return tileMetadata.getPropertyBySemantic(semantic);\n  }\n\n  return (\n    implicitTileset.geometricError / Math.pow(2, implicitCoordinates.level)\n  );\n}\n\n/**\n * Given a parent tile and information about which child to create, derive\n * the properties of the child tile implicitly.\n * <p>\n * This creates a real tile for rendering, not a placeholder tile like some of\n * the other methods of ImplicitTileset.\n * </p>\n *\n * @param {Implicit3DTileContent} implicitContent The implicit content\n * @param {ImplicitSubtree} subtree The subtree the child tile belongs to\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {number} childBitIndex The index of the child tile within the tile's availability information.\n * @param {boolean} [parentIsPlaceholderTile=false] True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @returns {Cesium3DTile} The new child tile.\n * @private\n */\nfunction deriveChildTile(\n  implicitContent,\n  subtree,\n  parentTile,\n  childIndex,\n  childBitIndex,\n  parentIsPlaceholderTile,\n) {\n  const implicitTileset = implicitContent._implicitTileset;\n  let implicitCoordinates;\n  if (defaultValue(parentIsPlaceholderTile, false)) {\n    implicitCoordinates = parentTile.implicitCoordinates;\n  } else {\n    implicitCoordinates =\n      parentTile.implicitCoordinates.getChildCoordinates(childIndex);\n  }\n\n  // Parse metadata and bounding volume semantics at the beginning\n  // as the bounding volumes are needed below.\n  let tileMetadata;\n  let tileBounds;\n  let contentBounds;\n  if (defined(subtree.tilePropertyTableJson)) {\n    tileMetadata = subtree.getTileMetadataView(implicitCoordinates);\n\n    const boundingVolumeSemantics =\n      BoundingVolumeSemantics.parseAllBoundingVolumeSemantics(tileMetadata);\n    tileBounds = boundingVolumeSemantics.tile;\n    contentBounds = boundingVolumeSemantics.content;\n  }\n\n  // Content is not loaded at this point, so this flag is set for future reference.\n  const contentPropertyTableJsons = subtree.contentPropertyTableJsons;\n  const length = contentPropertyTableJsons.length;\n  let hasImplicitContentMetadata = false;\n  for (let i = 0; i < length; i++) {\n    if (subtree.contentIsAvailableAtCoordinates(implicitCoordinates, i)) {\n      hasImplicitContentMetadata = true;\n      break;\n    }\n  }\n\n  const boundingVolume = getTileBoundingVolume(\n    implicitTileset,\n    implicitCoordinates,\n    childIndex,\n    parentIsPlaceholderTile,\n    parentTile,\n    tileBounds,\n  );\n\n  const contentJsons = [];\n  for (let i = 0; i < implicitTileset.contentCount; i++) {\n    if (!subtree.contentIsAvailableAtIndex(childBitIndex, i)) {\n      continue;\n    }\n    const childContentTemplate = implicitTileset.contentUriTemplates[i];\n    const childContentUri = childContentTemplate.getDerivedResource({\n      templateValues: implicitCoordinates.getTemplateValues(),\n    }).url;\n    const contentJson = {\n      uri: childContentUri,\n    };\n\n    const contentBoundingVolume = getContentBoundingVolume(\n      boundingVolume,\n      contentBounds,\n    );\n\n    if (defined(contentBoundingVolume)) {\n      contentJson.boundingVolume = contentBoundingVolume;\n    }\n\n    // combine() is used to pass through any additional properties the\n    // user specified such as extras or extensions\n    contentJsons.push(combine(contentJson, implicitTileset.contentHeaders[i]));\n  }\n\n  const childGeometricError = getGeometricError(\n    tileMetadata,\n    implicitTileset,\n    implicitCoordinates,\n  );\n\n  const tileJson = {\n    boundingVolume: boundingVolume,\n    geometricError: childGeometricError,\n    refine: implicitTileset.refine,\n    contents: contentJsons,\n  };\n\n  // combine() is used to pass through any additional properties the\n  // user specified such as extras or extensions.\n  const deep = true;\n  const rootHeader = clone(implicitTileset.tileHeader, deep);\n  // The bounding volume was computed above since it may come from metadata\n  // in the subtree file.\n  delete rootHeader.boundingVolume;\n  // Copying the transform to all the transcoded tiles would cause the transform\n  // to be applied multiple times. Removing it from the header avoids this issue.\n  delete rootHeader.transform;\n  // The implicit tiling spec does not specify what should happen if explicit\n  // tile metadata is added to the placeholder tile. Since implicit tile\n  // metadata comes from the subtree file, ignore the explicit version.\n  //\n  // Also, when a property with the semantic TILE_BOUNDING_VOLUME is added to\n  // the placeholder tile to set a tight bounding volume (See Cesium3DTile.js)\n  // propagating it to transcoded tiles causes transcoded tiles to use the\n  // wrong bounding volume, this can lead to loading far too many tiles.\n  delete rootHeader.metadata;\n  const combinedTileJson = combine(tileJson, rootHeader, deep);\n\n  const childTile = makeTile(\n    implicitContent,\n    implicitTileset.baseResource,\n    combinedTileJson,\n    parentTile,\n  );\n\n  childTile.implicitCoordinates = implicitCoordinates;\n  childTile.implicitSubtree = subtree;\n  childTile.metadata = tileMetadata;\n  childTile.hasImplicitContentMetadata = hasImplicitContentMetadata;\n\n  return childTile;\n}\n\n/**\n * Checks whether the bounding volume's heights can be updated.\n * Returns true if the minimumHeight/maximumHeight parameter\n * is defined and the bounding volume is a region or S2 cell.\n *\n * @param {object} [boundingVolume] The bounding volume\n * @param {object} [tileBounds] The tile bounds\n * @param {number} [tileBounds.minimumHeight] The minimum height\n * @param {number} [tileBounds.maximumHeight] The maximum height\n * @returns {boolean} Whether the bounding volume's heights can be updated\n * @private\n */\nfunction canUpdateHeights(boundingVolume, tileBounds) {\n  return (\n    defined(boundingVolume) &&\n    defined(tileBounds) &&\n    (defined(tileBounds.minimumHeight) || defined(tileBounds.maximumHeight)) &&\n    (hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\") ||\n      defined(boundingVolume.region))\n  );\n}\n\n/**\n * Update the minimum and maximum height of the bounding volume.\n * This is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined and the\n * bounding volume is a region or S2 cell.\n *\n * @param {object} boundingVolume The bounding volume\n * @param {object} [tileBounds] The tile bounds\n * @param {number} [tileBounds.minimumHeight] The new minimum height\n * @param {number} [tileBounds.maximumHeight] The new maximum height\n * @private\n */\nfunction updateHeights(boundingVolume, tileBounds) {\n  if (!defined(tileBounds)) {\n    return;\n  }\n\n  if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\")) {\n    updateS2CellHeights(\n      boundingVolume.extensions[\"3DTILES_bounding_volume_S2\"],\n      tileBounds.minimumHeight,\n      tileBounds.maximumHeight,\n    );\n  } else if (defined(boundingVolume.region)) {\n    updateRegionHeights(\n      boundingVolume.region,\n      tileBounds.minimumHeight,\n      tileBounds.maximumHeight,\n    );\n  }\n}\n\n/**\n * For a bounding region, update the minimum and maximum height. This\n * is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined.\n *\n * @param {Array} region A 6-element array describing the bounding region\n * @param {number} [minimumHeight] The new minimum height\n * @param {number} [maximumHeight] The new maximum height\n * @private\n */\nfunction updateRegionHeights(region, minimumHeight, maximumHeight) {\n  if (defined(minimumHeight)) {\n    region[4] = minimumHeight;\n  }\n\n  if (defined(maximumHeight)) {\n    region[5] = maximumHeight;\n  }\n}\n\n/**\n * For a bounding S2 cell, update the minimum and maximum height. This\n * is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined.\n *\n * @param {object} s2CellVolume An object describing the S2 cell\n * @param {number} [minimumHeight] The new minimum height\n * @param {number} [maximumHeight] The new maximum height\n * @private\n */\nfunction updateS2CellHeights(s2CellVolume, minimumHeight, maximumHeight) {\n  if (defined(minimumHeight)) {\n    s2CellVolume.minimumHeight = minimumHeight;\n  }\n\n  if (defined(maximumHeight)) {\n    s2CellVolume.maximumHeight = maximumHeight;\n  }\n}\n\n/**\n * Gets the tile's bounding volume, which may be specified via\n * metadata semantics such as TILE_BOUNDING_BOX or implicitly\n * derived from the implicit root tile's bounding volume.\n * <p>\n * Priority of bounding volume types:\n * <ol>\n * <li>Explicit min/max height\n *   <ol>\n *     <li>With explicit region</li>\n *     <li>With implicit S2</li>\n *     <li>With implicit region</li>\n *   </ol>\n * </li>\n * <li>Explicit box</li>\n * <li>Explicit region</li>\n * <li>Explicit sphere</li>\n * <li>Implicit S2</li>\n * <li>Implicit box</li>\n * <li>Implicit region</li>\n * </ol>\n * </p>\n *\n * @param {ImplicitTileset} implicitTileset The implicit tileset struct which holds the root bounding volume\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {object} [tileBounds] The tile bounds\n * @returns {object} An object containing the JSON for a bounding volume\n * @private\n */\nfunction getTileBoundingVolume(\n  implicitTileset,\n  implicitCoordinates,\n  childIndex,\n  parentIsPlaceholderTile,\n  parentTile,\n  tileBounds,\n) {\n  let boundingVolume;\n\n  if (\n    !defined(tileBounds) ||\n    !defined(tileBounds.boundingVolume) ||\n    (!canUpdateHeights(tileBounds.boundingVolume, tileBounds) &&\n      canUpdateHeights(implicitTileset.boundingVolume, tileBounds))\n  ) {\n    boundingVolume = deriveBoundingVolume(\n      implicitTileset,\n      implicitCoordinates,\n      childIndex,\n      defaultValue(parentIsPlaceholderTile, false),\n      parentTile,\n    );\n  } else {\n    boundingVolume = tileBounds.boundingVolume;\n  }\n\n  // The TILE_MINIMUM_HEIGHT and TILE_MAXIMUM_HEIGHT metadata semantics\n  // can be used to tighten the bounding volume\n  updateHeights(boundingVolume, tileBounds);\n\n  return boundingVolume;\n}\n\n/**\n * Gets the content bounding volume, which may be specified via\n * metadata semantics such as CONTENT_BOUNDING_BOX.\n * <p>\n * Priority of bounding volume types:\n * <ol>\n * <li>Explicit min/max height\n *   <ol>\n *     <li>With explicit region</li>\n *     <li>With tile bounding volume (S2 or region)</li>\n *   </ol>\n * </li>\n * <li>Explicit box</li>\n * <li>Explicit region</li>\n * <li>Explicit sphere</li>\n * <li>Tile bounding volume (when content.boundingVolume is undefined)</li>\n * </ol>\n * </p>\n *\n * @param {object} tileBoundingVolume An object containing the JSON for the tile's bounding volume\n * @param {object} [contentBounds] The content bounds\n * @returns {object|undefined} An object containing the JSON for a bounding volume, or <code>undefined</code> if there is no bounding volume\n * @private\n */\nfunction getContentBoundingVolume(tileBoundingVolume, contentBounds) {\n  // content bounding volumes can only be specified via\n  // metadata semantics such as CONTENT_BOUNDING_BOX\n  let contentBoundingVolume;\n  if (defined(contentBounds)) {\n    contentBoundingVolume = contentBounds.boundingVolume;\n  }\n\n  // The CONTENT_MINIMUM_HEIGHT and CONTENT_MAXIMUM_HEIGHT metadata semantics\n  // can be used to tighten the bounding volume\n  if (canUpdateHeights(contentBoundingVolume, contentBounds)) {\n    updateHeights(contentBoundingVolume, contentBounds);\n  } else if (canUpdateHeights(tileBoundingVolume, contentBounds)) {\n    contentBoundingVolume = clone(tileBoundingVolume, true);\n    updateHeights(contentBoundingVolume, contentBounds);\n  }\n\n  return contentBoundingVolume;\n}\n\n/**\n * Given the coordinates of a tile, derive its bounding volume from the root.\n *\n * @param {ImplicitTileset} implicitTileset The implicit tileset struct which holds the root bounding volume\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @returns {object} An object containing the JSON for a bounding volume\n * @private\n */\nfunction deriveBoundingVolume(\n  implicitTileset,\n  implicitCoordinates,\n  childIndex,\n  parentIsPlaceholderTile,\n  parentTile,\n) {\n  const rootBoundingVolume = implicitTileset.boundingVolume;\n\n  if (hasExtension(rootBoundingVolume, \"3DTILES_bounding_volume_S2\")) {\n    return deriveBoundingVolumeS2(\n      parentIsPlaceholderTile,\n      parentTile,\n      childIndex,\n      implicitCoordinates.level,\n      implicitCoordinates.x,\n      implicitCoordinates.y,\n      implicitCoordinates.z,\n    );\n  }\n\n  if (defined(rootBoundingVolume.region)) {\n    const childRegion = deriveBoundingRegion(\n      rootBoundingVolume.region,\n      implicitCoordinates.level,\n      implicitCoordinates.x,\n      implicitCoordinates.y,\n      implicitCoordinates.z,\n    );\n\n    return {\n      region: childRegion,\n    };\n  }\n\n  const childBox = deriveBoundingBox(\n    rootBoundingVolume.box,\n    implicitCoordinates.level,\n    implicitCoordinates.x,\n    implicitCoordinates.y,\n    implicitCoordinates.z,\n  );\n\n  return {\n    box: childBox,\n  };\n}\n\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (x, y), leaving the z axis unchanged.\n * </p>\n *\n * @param {boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @param {number} level The level of the descendant tile relative to the root implicit tile\n * @param {number} x The x coordinate of the descendant tile\n * @param {number} y The y coordinate of the descendant tile\n * @param {number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {object} An object with the 3DTILES_bounding_volume_S2 extension.\n * @private\n */\nfunction deriveBoundingVolumeS2(\n  parentIsPlaceholderTile,\n  parentTile,\n  childIndex,\n  level,\n  x,\n  y,\n  z,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"parentIsPlaceholderTile\", parentIsPlaceholderTile);\n  Check.typeOf.object(\"parentTile\", parentTile);\n  Check.typeOf.number(\"childIndex\", childIndex);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  const boundingVolumeS2 = parentTile._boundingVolume;\n\n  // Handle the placeholder tile case, where we just duplicate the placeholder's bounding volume.\n  if (parentIsPlaceholderTile) {\n    return {\n      extensions: {\n        \"3DTILES_bounding_volume_S2\": {\n          token: S2Cell.getTokenFromId(boundingVolumeS2.s2Cell._cellId),\n          minimumHeight: boundingVolumeS2.minimumHeight,\n          maximumHeight: boundingVolumeS2.maximumHeight,\n        },\n      },\n    };\n  }\n\n  // Extract the first 3 face bits from the 64-bit S2 cell ID.\n  // eslint-disable-next-line no-undef\n  const face = Number(parentTile._boundingVolume.s2Cell._cellId >> BigInt(61));\n  // The Hilbert curve is rotated for the \"odd\" faces on the S2 Earthcube.\n  // See http://s2geometry.io/devguide/img/s2cell_global.jpg\n  const position =\n    face % 2 === 0\n      ? HilbertOrder.encode2D(level, x, y)\n      : HilbertOrder.encode2D(level, y, x);\n  // eslint-disable-next-line no-undef\n  const cell = S2Cell.fromFacePositionLevel(face, BigInt(position), level);\n\n  let minHeight, maxHeight;\n  if (defined(z)) {\n    const midpointHeight =\n      (boundingVolumeS2.maximumHeight + boundingVolumeS2.minimumHeight) / 2;\n    minHeight =\n      childIndex < 4 ? boundingVolumeS2.minimumHeight : midpointHeight;\n    maxHeight =\n      childIndex < 4 ? midpointHeight : boundingVolumeS2.maximumHeight;\n  } else {\n    minHeight = boundingVolumeS2.minimumHeight;\n    maxHeight = boundingVolumeS2.maximumHeight;\n  }\n\n  return {\n    extensions: {\n      \"3DTILES_bounding_volume_S2\": {\n        token: S2Cell.getTokenFromId(cell._cellId),\n        minimumHeight: minHeight,\n        maximumHeight: maxHeight,\n      },\n    },\n  };\n}\n\nconst scratchScaleFactors = new Cartesian3();\nconst scratchRootCenter = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchHalfAxes = new Matrix3();\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (x, y), leaving the z axis unchanged.\n * </p>\n * <p>\n * This computes the child volume directly from the root bounding volume rather\n * than recursively subdividing to minimize floating point error.\n * </p>\n *\n * @param {number[]} rootBox An array of 12 numbers representing the bounding box of the root tile\n * @param {number} level The level of the descendant tile relative to the root implicit tile\n * @param {number} x The x coordinate of the descendant tile\n * @param {number} y The y coordinate of the descendant tile\n * @param {number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {number[]} An array of 12 numbers representing the bounding box of the descendant tile.\n * @private\n */\nfunction deriveBoundingBox(rootBox, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rootBox\", rootBox);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  if (level === 0) {\n    return rootBox;\n  }\n\n  const rootCenter = Cartesian3.unpack(rootBox, 0, scratchRootCenter);\n  const rootHalfAxes = Matrix3.unpack(rootBox, 3, scratchHalfAxes);\n\n  const tileScale = Math.pow(2, -level);\n  const modelSpaceX = -1 + (2 * x + 1) * tileScale;\n  const modelSpaceY = -1 + (2 * y + 1) * tileScale;\n\n  let modelSpaceZ = 0;\n  const scaleFactors = Cartesian3.fromElements(\n    tileScale,\n    tileScale,\n    1,\n    scratchScaleFactors,\n  );\n\n  if (defined(z)) {\n    modelSpaceZ = -1 + (2 * z + 1) * tileScale;\n    scaleFactors.z = tileScale;\n  }\n\n  let center = Cartesian3.fromElements(\n    modelSpaceX,\n    modelSpaceY,\n    modelSpaceZ,\n    scratchCenter,\n  );\n  center = Matrix3.multiplyByVector(rootHalfAxes, center, scratchCenter);\n  center = Cartesian3.add(center, rootCenter, scratchCenter);\n\n  let halfAxes = Matrix3.clone(rootHalfAxes);\n  halfAxes = Matrix3.multiplyByScale(halfAxes, scaleFactors, halfAxes);\n\n  const childBox = new Array(12);\n  Cartesian3.pack(center, childBox);\n  Matrix3.pack(halfAxes, childBox, 3);\n  return childBox;\n}\n\nconst scratchRectangle = new Rectangle();\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (mid_longitude, mid_latitude), leaving the height values\n * unchanged.\n * </p>\n * <p>\n * This computes the child volume directly from the root bounding volume rather\n * than recursively subdividing to minimize floating point error.\n * </p>\n * @param {number[]} rootRegion An array of 6 numbers representing the root implicit tile\n * @param {number} level The level of the descendant tile relative to the root implicit tile\n * @param {number} x The x coordinate of the descendant tile\n * @param {number} y The x coordinate of the descendant tile\n * @param {number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {number[]} An array of 6 numbers representing the bounding region of the descendant tile\n * @private\n */\nfunction deriveBoundingRegion(rootRegion, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rootRegion\", rootRegion);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  if (level === 0) {\n    return rootRegion.slice();\n  }\n\n  const rectangle = Rectangle.unpack(rootRegion, 0, scratchRectangle);\n  const rootMinimumHeight = rootRegion[4];\n  const rootMaximumHeight = rootRegion[5];\n  const tileScale = Math.pow(2, -level);\n\n  const childWidth = tileScale * rectangle.width;\n  const west = CesiumMath.negativePiToPi(rectangle.west + x * childWidth);\n  const east = CesiumMath.negativePiToPi(west + childWidth);\n\n  const childHeight = tileScale * rectangle.height;\n  const south = CesiumMath.negativePiToPi(rectangle.south + y * childHeight);\n  const north = CesiumMath.negativePiToPi(south + childHeight);\n\n  // Height is only subdivided for octrees; It remains constant for quadtrees.\n  let minimumHeight = rootMinimumHeight;\n  let maximumHeight = rootMaximumHeight;\n  if (defined(z)) {\n    const childThickness = tileScale * (rootMaximumHeight - rootMinimumHeight);\n    minimumHeight += z * childThickness;\n    maximumHeight = minimumHeight + childThickness;\n  }\n\n  return [west, south, east, north, minimumHeight, maximumHeight];\n}\n\n/**\n * Create a placeholder 3D Tile whose content will be an Implicit3DTileContent\n * for lazy evaluation of a child subtree.\n *\n * @param {Implicit3DTileContent} content The content object.\n * @param {Cesium3DTile} parentTile The parent of the new child subtree.\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @returns {Cesium3DTile} The new placeholder tile\n * @private\n */\nfunction makePlaceholderChildSubtree(content, parentTile, childIndex) {\n  const implicitTileset = content._implicitTileset;\n  const implicitCoordinates =\n    parentTile.implicitCoordinates.getChildCoordinates(childIndex);\n\n  const childBoundingVolume = deriveBoundingVolume(\n    implicitTileset,\n    implicitCoordinates,\n    childIndex,\n    false,\n    parentTile,\n  );\n\n  // Ignore tile metadata when computing geometric error for the placeholder tile\n  // since the child subtree's metadata hasn't been loaded yet.\n  // The actual geometric error will be computed in deriveChildTile.\n  const childGeometricError = getGeometricError(\n    undefined,\n    implicitTileset,\n    implicitCoordinates,\n  );\n\n  const childContentUri = implicitTileset.subtreeUriTemplate.getDerivedResource(\n    {\n      templateValues: implicitCoordinates.getTemplateValues(),\n    },\n  ).url;\n  const tileJson = {\n    boundingVolume: childBoundingVolume,\n    geometricError: childGeometricError,\n    refine: implicitTileset.refine,\n    contents: [\n      {\n        uri: childContentUri,\n      },\n    ],\n  };\n\n  const tile = makeTile(\n    content,\n    implicitTileset.baseResource,\n    tileJson,\n    parentTile,\n  );\n  tile.implicitTileset = implicitTileset;\n  tile.implicitCoordinates = implicitCoordinates;\n  return tile;\n}\n\n/**\n * Make a {@link Cesium3DTile}. This uses the content's tile's constructor instead\n * of importing Cesium3DTile. This is to avoid a circular dependency between\n * this file and Cesium3DTile.js\n * @param {Implicit3DTileContent} content The implicit content\n * @param {Resource} baseResource The base resource for the tileset\n * @param {object} tileJson The JSON header for the tile\n * @param {Cesium3DTile} parentTile The parent of the new tile\n * @returns {Cesium3DTile} The newly created tile.\n * @private\n */\nfunction makeTile(content, baseResource, tileJson, parentTile) {\n  const Cesium3DTile = content._tile.constructor;\n  return new Cesium3DTile(content._tileset, baseResource, tileJson, parentTile);\n}\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Implicit3DTileContent</code>\n * always returns <code>false</code> since a tile of this type does not have any features.\n * @private\n */\nImplicit3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Implicit3DTileContent</code>\n * always returns <code>undefined</code> since a tile of this type does not have any features.\n * @private\n */\nImplicit3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\n\nImplicit3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color,\n) {};\n\nImplicit3DTileContent.prototype.applyStyle = function (style) {};\n\nImplicit3DTileContent.prototype.update = function (tileset, frameState) {};\n\nImplicit3DTileContent.prototype.pick = function (ray, frameState, result) {\n  return undefined;\n};\n\nImplicit3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nImplicit3DTileContent.prototype.destroy = function () {\n  this._implicitSubtree =\n    this._implicitSubtree && this._implicitSubtree.destroy();\n  return destroyObject(this);\n};\n\n// Exposed for testing\nImplicit3DTileContent._deriveBoundingBox = deriveBoundingBox;\nImplicit3DTileContent._deriveBoundingRegion = deriveBoundingRegion;\nImplicit3DTileContent._deriveBoundingVolumeS2 = deriveBoundingVolumeS2;\n\nexport default Implicit3DTileContent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}