{"ast":null,"code":"import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport CubeMapFace from \"./CubeMapFace.js\";\nimport Framebuffer from \"./Framebuffer.js\";\nimport MipmapHint from \"./MipmapHint.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\nimport Sampler from \"./Sampler.js\";\nimport TextureMagnificationFilter from \"./TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"./TextureMinificationFilter.js\";\nimport VertexArray from \"./VertexArray.js\";\n\n/**\n * @typedef CubeMap.BufferSource\n *\n * @property {TypedArray} arrayBufferView A view of a binary data buffer containing pixel values.\n * @property {number} width The width of one face of the cube map, in pixels. Must be equal to height.\n * @property {number} height The height of one face of the cube map, in pixels. Must be equal to width.\n *\n * @private\n */\n\n/**\n * @typedef CubeMap.Source\n *\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveX\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeX\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveY\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeY\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveZ\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeZ\n */\n\n/**\n * @typedef CubeMap.ConstructorOptions\n *\n * @property {Context} context\n * @property {CubeMap.Source} [source] The source for texel values to be loaded into the texture.\n * @property {PixelFormat} [pixelFormat=PixelFormat.RGBA] The format of each pixel, i.e., the number of components it has and what they represent.\n * @property {PixelDatatype} [pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The data type of each pixel.\n * @property {boolean} [flipY=true] If true, the source values will be read as if the y-axis is inverted (y=0 at the top).\n * @property {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.\n * @property {Sampler} [sampler] Information about how to sample the cubemap texture.\n * @property {number} [width] The pixel width of the texture. If not supplied, must be available from the source. Must be equal to height.\n * @property {number} [height] The pixel height of the texture. If not supplied, must be available from the source. Must be equal to width.\n * @property {boolean} [preMultiplyAlpha] If true, the alpha channel will be multiplied into the other channels.\n *\n * @private\n */\n\n/**\n * A wrapper for a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture|WebGLTexture}\n * used as a cube map, to abstract away the verbose GL calls associated with setting up a texture.\n *\n * @alias CubeMap\n * @constructor\n *\n * @param {CubeMap.ConstructorOptions} options An object describing initialization options.\n * @private\n */\nfunction CubeMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    source,\n    pixelFormat = PixelFormat.RGBA,\n    pixelDatatype = PixelDatatype.UNSIGNED_BYTE,\n    flipY = true,\n    skipColorSpaceConversion = false,\n    sampler = new Sampler()\n  } = options;\n\n  // Use premultiplied alpha for opaque textures should perform better on Chrome:\n  // http://media.tojicode.com/webglCamp4/#20\n  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE;\n  let {\n    width,\n    height\n  } = options;\n  if (defined(source)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!Object.values(CubeMap.FaceName).every(faceName => defined(source[faceName]))) {\n      throw new DeveloperError(`options.source requires faces ${Object.values(CubeMap.FaceName).join(\", \")}.`);\n    }\n    //>>includeEnd('debug');\n\n    ({\n      width,\n      height\n    } = source.positiveX);\n\n    //>>includeStart('debug', pragmas.debug);\n    for (const faceName of CubeMap.faceNames()) {\n      const face = source[faceName];\n      if (Number(face.width) !== width || Number(face.height) !== height) {\n        throw new DeveloperError(\"Each face in options.source must have the same width and height.\");\n      }\n    }\n    //>>includeEnd('debug');\n  }\n  const size = width;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(width) || !defined(height)) {\n    throw new DeveloperError(\"options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.\");\n  }\n  if (width !== height) {\n    throw new DeveloperError(\"Width must equal height.\");\n  }\n  if (size <= 0) {\n    throw new DeveloperError(\"Width and height must be greater than zero.\");\n  }\n  if (size > ContextLimits.maximumCubeMapSize) {\n    throw new DeveloperError(`Width and height must be less than or equal to the maximum cube map size (${ContextLimits.maximumCubeMapSize}). Check maximumCubeMapSize.`);\n  }\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid options.pixelFormat.\");\n  }\n  if (PixelFormat.isDepthFormat(pixelFormat)) {\n    throw new DeveloperError(\"options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.\");\n  }\n  if (!PixelDatatype.validate(pixelDatatype)) {\n    throw new DeveloperError(\"Invalid options.pixelDatatype.\");\n  }\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {\n    throw new DeveloperError(\"When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.\");\n  }\n  if (pixelDatatype === PixelDatatype.HALF_FLOAT && !context.halfFloatingPointTexture) {\n    throw new DeveloperError(\"When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension.\");\n  }\n  //>>includeEnd('debug');\n\n  const sizeInBytes = PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;\n  const internalFormat = PixelFormat.toInternalFormat(pixelFormat, pixelDatatype, context);\n  const gl = context._gl;\n  const textureTarget = gl.TEXTURE_CUBE_MAP;\n  const texture = gl.createTexture();\n  this._context = context;\n  this._textureFilterAnisotropic = context._textureFilterAnisotropic;\n  this._textureTarget = textureTarget;\n  this._texture = texture;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._size = size;\n  this._hasMipmap = false;\n  this._sizeInBytes = sizeInBytes;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  const initialized = defined(source);\n  function constructFace(targetFace) {\n    return new CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized);\n  }\n  this._positiveX = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X);\n  this._negativeX = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X);\n  this._positiveY = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y);\n  this._negativeY = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y);\n  this._positiveZ = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z);\n  this._negativeZ = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z);\n  this._sampler = sampler;\n  setupSampler(this, sampler);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(textureTarget, texture);\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);\n  }\n  for (const faceName of CubeMap.faceNames()) {\n    loadFace(this[faceName], source?.[faceName], 0);\n  }\n  gl.bindTexture(textureTarget, null);\n}\n\n/**\n * Copy an existing texture to a cubemap face.\n * @param {FrameState} frameState The current rendering frameState\n * @param {Texture} texture Texture being copied\n * @param {CubeMap.FaceName} face The face to which to copy\n * @param {number} [mipLevel=0] The mip level at which to copy\n */\nCubeMap.prototype.copyFace = function (frameState, texture, face, mipLevel) {\n  const context = frameState.context;\n  const framebuffer = new Framebuffer({\n    context: context,\n    colorTextures: [texture],\n    destroyAttachments: false\n  });\n  framebuffer._bind();\n  this[face].copyMipmapFromFramebuffer(0, 0, texture.width, texture.height, defaultValue(mipLevel, 0));\n  framebuffer._unBind();\n  framebuffer.destroy();\n};\n\n/**\n * An enum defining the names of the faces of a cube map.\n * @alias {CubeMap.FaceName}\n * @enum {string}\n * @private\n */\nCubeMap.FaceName = Object.freeze({\n  POSITIVEX: \"positiveX\",\n  NEGATIVEX: \"negativeX\",\n  POSITIVEY: \"positiveY\",\n  NEGATIVEY: \"negativeY\",\n  POSITIVEZ: \"positiveZ\",\n  NEGATIVEZ: \"negativeZ\"\n});\nfunction* makeFaceNamesIterator() {\n  yield CubeMap.FaceName.POSITIVEX;\n  yield CubeMap.FaceName.NEGATIVEX;\n  yield CubeMap.FaceName.POSITIVEY;\n  yield CubeMap.FaceName.NEGATIVEY;\n  yield CubeMap.FaceName.POSITIVEZ;\n  yield CubeMap.FaceName.NEGATIVEZ;\n}\n\n/**\n * Creates an iterator for looping over the cubemap faces.\n * @type {Iterable<CubeMap.FaceName>}\n * @private\n */\nCubeMap.faceNames = function () {\n  return makeFaceNamesIterator();\n};\n\n/**\n * Load texel data into one face of a cube map.\n * @param {CubeMapFace} cubeMapFace The face to which texel values will be loaded.\n * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} [source] The source for texel values to be loaded into the texture.\n * @param {number} [mipLevel=0] The mip level to which the texel values will be loaded.\n * @private\n */\nfunction loadFace(cubeMapFace, source, mipLevel) {\n  mipLevel = defaultValue(mipLevel, 0);\n  const targetFace = cubeMapFace._targetFace;\n  const size = Math.max(Math.floor(cubeMapFace._size / 2 ** mipLevel), 1);\n  const pixelFormat = cubeMapFace._pixelFormat;\n  const pixelDatatype = cubeMapFace._pixelDatatype;\n  const internalFormat = cubeMapFace._internalFormat;\n  const flipY = cubeMapFace._flipY;\n  const preMultiplyAlpha = cubeMapFace._preMultiplyAlpha;\n  const context = cubeMapFace._context;\n  const gl = context._gl;\n  if (!defined(source)) {\n    gl.texImage2D(targetFace, mipLevel, internalFormat, size, size, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, context), null);\n    return;\n  }\n  let {\n    arrayBufferView\n  } = source;\n  let unpackAlignment = 4;\n  if (defined(arrayBufferView)) {\n    unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, size);\n  }\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  if (defined(arrayBufferView)) {\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    if (flipY) {\n      arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, size, size);\n    }\n    gl.texImage2D(targetFace, mipLevel, internalFormat, size, size, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, context), arrayBufferView);\n  } else {\n    // Only valid for DOM-Element uploads\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n    gl.texImage2D(targetFace, mipLevel, internalFormat, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, context), source);\n  }\n}\nCubeMap.loadFace = loadFace;\nObject.defineProperties(CubeMap.prototype, {\n  positiveX: {\n    get: function () {\n      return this._positiveX;\n    }\n  },\n  negativeX: {\n    get: function () {\n      return this._negativeX;\n    }\n  },\n  positiveY: {\n    get: function () {\n      return this._positiveY;\n    }\n  },\n  negativeY: {\n    get: function () {\n      return this._negativeY;\n    }\n  },\n  positiveZ: {\n    get: function () {\n      return this._positiveZ;\n    }\n  },\n  negativeZ: {\n    get: function () {\n      return this._negativeZ;\n    }\n  },\n  sampler: {\n    get: function () {\n      return this._sampler;\n    },\n    set: function (sampler) {\n      setupSampler(this, sampler);\n      this._sampler = sampler;\n    }\n  },\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    }\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    }\n  },\n  width: {\n    get: function () {\n      return this._size;\n    }\n  },\n  height: {\n    get: function () {\n      return this._size;\n    }\n  },\n  sizeInBytes: {\n    get: function () {\n      if (this._hasMipmap) {\n        return Math.floor(this._sizeInBytes * 4 / 3);\n      }\n      return this._sizeInBytes;\n    }\n  },\n  preMultiplyAlpha: {\n    get: function () {\n      return this._preMultiplyAlpha;\n    }\n  },\n  flipY: {\n    get: function () {\n      return this._flipY;\n    }\n  },\n  _target: {\n    get: function () {\n      return this._textureTarget;\n    }\n  }\n});\n\n/**\n * Get a vector representing the cubemap face direction\n * @param {CubeMap.FaceName} face The relevant face\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The vector representing the cubemap face direction\n */\nCubeMap.getDirection = function (face, result) {\n  switch (face) {\n    case CubeMap.FaceName.POSITIVEX:\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    case CubeMap.FaceName.NEGATIVEX:\n      return Cartesian3.negate(Cartesian3.UNIT_X, result);\n    case CubeMap.FaceName.POSITIVEY:\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    case CubeMap.FaceName.NEGATIVEY:\n      return Cartesian3.negate(Cartesian3.UNIT_Y, result);\n    case CubeMap.FaceName.POSITIVEZ:\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    case CubeMap.FaceName.NEGATIVEZ:\n      return Cartesian3.negate(Cartesian3.UNIT_Z, result);\n  }\n};\n\n/**\n * Set up a sampler for use with a cube map.\n * @param {CubeMap} cubeMap The cube map containing the texture to be sampled by this sampler.\n * @param {Sampler} sampler Information about how to sample the cubemap texture.\n * @private\n */\nfunction setupSampler(cubeMap, sampler) {\n  let {\n    minificationFilter,\n    magnificationFilter\n  } = sampler;\n  const mipmap = [TextureMinificationFilter.NEAREST_MIPMAP_NEAREST, TextureMinificationFilter.NEAREST_MIPMAP_LINEAR, TextureMinificationFilter.LINEAR_MIPMAP_NEAREST, TextureMinificationFilter.LINEAR_MIPMAP_LINEAR].includes(minificationFilter);\n  const context = cubeMap._context;\n  const pixelDatatype = cubeMap._pixelDatatype;\n\n  // float textures only support nearest filtering unless the linear extensions are supported\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype.HALF_FLOAT && !context.textureHalfFloatLinear) {\n    // override the sampler's settings\n    minificationFilter = mipmap ? TextureMinificationFilter.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter.NEAREST;\n    magnificationFilter = TextureMagnificationFilter.NEAREST;\n  }\n  const gl = context._gl;\n  const target = cubeMap._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, cubeMap._texture);\n  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);\n  if (defined(cubeMap._textureFilterAnisotropic)) {\n    gl.texParameteri(target, cubeMap._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);\n  }\n  gl.bindTexture(target, null);\n}\n\n/**\n * Load a complete mipmap chain for each cubemap face.\n *\n * @param {CubeMap.Source[]} source The source data for each mip level, beginning at level 1.\n * @param {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.\n *\n * @private\n */\nCubeMap.prototype.loadMipmaps = function (source, skipColorSpaceConversion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"source\", source);\n  if (!Array.isArray(source)) {\n    throw new DeveloperError(`source must be an array`);\n  }\n  const mipCount = Math.log2(this._size);\n  if (source.length !== mipCount) {\n    throw new DeveloperError(`all mip levels must be defined`);\n  }\n  //>>includeEnd('debug');\n\n  skipColorSpaceConversion = defaultValue(skipColorSpaceConversion, false);\n  const gl = this._context._gl;\n  const texture = this._texture;\n  const textureTarget = this._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(textureTarget, texture);\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);\n  }\n  for (let i = 0; i < source.length; i++) {\n    const mipSource = source[i];\n    // mipLevel 0 was the base layer, already loaded when the CubeMap was constructed.\n    const mipLevel = i + 1;\n    for (const faceName of CubeMap.faceNames()) {\n      loadFace(this[faceName], mipSource[faceName], mipLevel);\n    }\n  }\n  gl.bindTexture(textureTarget, null);\n  this._hasMipmap = true;\n};\n\n/**\n * Generates a complete mipmap chain for each cubemap face.\n *\n * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] A performance vs. quality hint.\n *\n * @exception {DeveloperError} hint is invalid.\n * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Generate mipmaps, and then set the sampler so mipmaps are used for\n * // minification when the cube map is sampled.\n * cubeMap.generateMipmap();\n * cubeMap.sampler = new Sampler({\n *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n * });\n */\nCubeMap.prototype.generateMipmap = function (hint) {\n  hint = defaultValue(hint, MipmapHint.DONT_CARE);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (this._size > 1 && !CesiumMath.isPowerOfTwo(this._size)) {\n    throw new DeveloperError(\"width and height must be a power of two to call generateMipmap().\");\n  }\n  if (!MipmapHint.validate(hint)) {\n    throw new DeveloperError(\"hint is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._hasMipmap = true;\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.generateMipmap(target);\n  gl.bindTexture(target, null);\n};\n\n/**\n * Create a vertex array that can be used for cubemap shaders.\n * @param {Context} context The rendering context\n * @returns {VertexArray} The created vertex array\n */\nCubeMap.createVertexArray = function (context) {\n  const geometry = BoxGeometry.createGeometry(BoxGeometry.fromDimensions({\n    dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    vertexFormat: VertexFormat.POSITION_ONLY\n  }));\n  const attributeLocations = this._attributeLocations = GeometryPipeline.createAttributeLocations(geometry);\n  return VertexArray.fromGeometry({\n    context: context,\n    geometry: geometry,\n    attributeLocations: attributeLocations,\n    bufferUsage: BufferUsage.STATIC_DRAW\n  });\n};\nCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\nCubeMap.prototype.destroy = function () {\n  this._context._gl.deleteTexture(this._texture);\n  this._positiveX = destroyObject(this._positiveX);\n  this._negativeX = destroyObject(this._negativeX);\n  this._positiveY = destroyObject(this._positiveY);\n  this._negativeY = destroyObject(this._negativeY);\n  this._positiveZ = destroyObject(this._positiveZ);\n  this._negativeZ = destroyObject(this._negativeZ);\n  return destroyObject(this);\n};\nexport default CubeMap;","map":{"version":3,"names":["BoxGeometry","Cartesian3","Check","defaultValue","defined","destroyObject","DeveloperError","GeometryPipeline","CesiumMath","PixelFormat","VertexFormat","BufferUsage","ContextLimits","CubeMapFace","Framebuffer","MipmapHint","PixelDatatype","Sampler","TextureMagnificationFilter","TextureMinificationFilter","VertexArray","CubeMap","options","EMPTY_OBJECT","context","source","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","flipY","skipColorSpaceConversion","sampler","preMultiplyAlpha","RGB","LUMINANCE","width","height","Object","values","FaceName","every","faceName","join","positiveX","faceNames","face","Number","size","maximumCubeMapSize","validate","isDepthFormat","FLOAT","floatingPointTexture","HALF_FLOAT","halfFloatingPointTexture","sizeInBytes","textureSizeInBytes","internalFormat","toInternalFormat","gl","_gl","textureTarget","TEXTURE_CUBE_MAP","texture","createTexture","_context","_textureFilterAnisotropic","_textureTarget","_texture","_pixelFormat","_pixelDatatype","_size","_hasMipmap","_sizeInBytes","_preMultiplyAlpha","_flipY","initialized","constructFace","targetFace","_positiveX","TEXTURE_CUBE_MAP_POSITIVE_X","_negativeX","TEXTURE_CUBE_MAP_NEGATIVE_X","_positiveY","TEXTURE_CUBE_MAP_POSITIVE_Y","_negativeY","TEXTURE_CUBE_MAP_NEGATIVE_Y","_positiveZ","TEXTURE_CUBE_MAP_POSITIVE_Z","_negativeZ","TEXTURE_CUBE_MAP_NEGATIVE_Z","_sampler","setupSampler","activeTexture","TEXTURE0","bindTexture","pixelStorei","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","BROWSER_DEFAULT_WEBGL","loadFace","prototype","copyFace","frameState","mipLevel","framebuffer","colorTextures","destroyAttachments","_bind","copyMipmapFromFramebuffer","_unBind","destroy","freeze","POSITIVEX","NEGATIVEX","POSITIVEY","NEGATIVEY","POSITIVEZ","NEGATIVEZ","makeFaceNamesIterator","cubeMapFace","_targetFace","Math","max","floor","_internalFormat","texImage2D","toWebGLConstant","arrayBufferView","unpackAlignment","alignmentInBytes","UNPACK_ALIGNMENT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","defineProperties","get","negativeX","positiveY","negativeY","positiveZ","negativeZ","set","_target","getDirection","result","clone","UNIT_X","negate","UNIT_Y","UNIT_Z","cubeMap","minificationFilter","magnificationFilter","mipmap","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","includes","textureFloatLinear","textureHalfFloatLinear","NEAREST","target","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_MAX_ANISOTROPY_EXT","maximumAnisotropy","loadMipmaps","Array","isArray","mipCount","log2","length","i","mipSource","generateMipmap","hint","DONT_CARE","isPowerOfTwo","GENERATE_MIPMAP_HINT","createVertexArray","geometry","createGeometry","fromDimensions","dimensions","vertexFormat","POSITION_ONLY","attributeLocations","_attributeLocations","createAttributeLocations","fromGeometry","bufferUsage","STATIC_DRAW","isDestroyed","deleteTexture"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/CubeMap.js"],"sourcesContent":["import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport CubeMapFace from \"./CubeMapFace.js\";\nimport Framebuffer from \"./Framebuffer.js\";\nimport MipmapHint from \"./MipmapHint.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\nimport Sampler from \"./Sampler.js\";\nimport TextureMagnificationFilter from \"./TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"./TextureMinificationFilter.js\";\nimport VertexArray from \"./VertexArray.js\";\n\n/**\n * @typedef CubeMap.BufferSource\n *\n * @property {TypedArray} arrayBufferView A view of a binary data buffer containing pixel values.\n * @property {number} width The width of one face of the cube map, in pixels. Must be equal to height.\n * @property {number} height The height of one face of the cube map, in pixels. Must be equal to width.\n *\n * @private\n */\n\n/**\n * @typedef CubeMap.Source\n *\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveX\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeX\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveY\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeY\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} positiveZ\n * @property {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} negativeZ\n */\n\n/**\n * @typedef CubeMap.ConstructorOptions\n *\n * @property {Context} context\n * @property {CubeMap.Source} [source] The source for texel values to be loaded into the texture.\n * @property {PixelFormat} [pixelFormat=PixelFormat.RGBA] The format of each pixel, i.e., the number of components it has and what they represent.\n * @property {PixelDatatype} [pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The data type of each pixel.\n * @property {boolean} [flipY=true] If true, the source values will be read as if the y-axis is inverted (y=0 at the top).\n * @property {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.\n * @property {Sampler} [sampler] Information about how to sample the cubemap texture.\n * @property {number} [width] The pixel width of the texture. If not supplied, must be available from the source. Must be equal to height.\n * @property {number} [height] The pixel height of the texture. If not supplied, must be available from the source. Must be equal to width.\n * @property {boolean} [preMultiplyAlpha] If true, the alpha channel will be multiplied into the other channels.\n *\n * @private\n */\n\n/**\n * A wrapper for a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture|WebGLTexture}\n * used as a cube map, to abstract away the verbose GL calls associated with setting up a texture.\n *\n * @alias CubeMap\n * @constructor\n *\n * @param {CubeMap.ConstructorOptions} options An object describing initialization options.\n * @private\n */\nfunction CubeMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    source,\n    pixelFormat = PixelFormat.RGBA,\n    pixelDatatype = PixelDatatype.UNSIGNED_BYTE,\n    flipY = true,\n    skipColorSpaceConversion = false,\n    sampler = new Sampler(),\n  } = options;\n\n  // Use premultiplied alpha for opaque textures should perform better on Chrome:\n  // http://media.tojicode.com/webglCamp4/#20\n  const preMultiplyAlpha =\n    options.preMultiplyAlpha ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.LUMINANCE;\n\n  let { width, height } = options;\n\n  if (defined(source)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !Object.values(CubeMap.FaceName).every((faceName) =>\n        defined(source[faceName]),\n      )\n    ) {\n      throw new DeveloperError(\n        `options.source requires faces ${Object.values(CubeMap.FaceName).join(\n          \", \",\n        )}.`,\n      );\n    }\n    //>>includeEnd('debug');\n\n    ({ width, height } = source.positiveX);\n\n    //>>includeStart('debug', pragmas.debug);\n    for (const faceName of CubeMap.faceNames()) {\n      const face = source[faceName];\n      if (Number(face.width) !== width || Number(face.height) !== height) {\n        throw new DeveloperError(\n          \"Each face in options.source must have the same width and height.\",\n        );\n      }\n    }\n    //>>includeEnd('debug');\n  }\n\n  const size = width;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(width) || !defined(height)) {\n    throw new DeveloperError(\n      \"options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.\",\n    );\n  }\n\n  if (width !== height) {\n    throw new DeveloperError(\"Width must equal height.\");\n  }\n\n  if (size <= 0) {\n    throw new DeveloperError(\"Width and height must be greater than zero.\");\n  }\n\n  if (size > ContextLimits.maximumCubeMapSize) {\n    throw new DeveloperError(\n      `Width and height must be less than or equal to the maximum cube map size (${ContextLimits.maximumCubeMapSize}). Check maximumCubeMapSize.`,\n    );\n  }\n\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid options.pixelFormat.\");\n  }\n\n  if (PixelFormat.isDepthFormat(pixelFormat)) {\n    throw new DeveloperError(\n      \"options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.\",\n    );\n  }\n\n  if (!PixelDatatype.validate(pixelDatatype)) {\n    throw new DeveloperError(\"Invalid options.pixelDatatype.\");\n  }\n\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {\n    throw new DeveloperError(\n      \"When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.\",\n    );\n  }\n\n  if (\n    pixelDatatype === PixelDatatype.HALF_FLOAT &&\n    !context.halfFloatingPointTexture\n  ) {\n    throw new DeveloperError(\n      \"When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const sizeInBytes =\n    PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, size, size) * 6;\n  const internalFormat = PixelFormat.toInternalFormat(\n    pixelFormat,\n    pixelDatatype,\n    context,\n  );\n\n  const gl = context._gl;\n  const textureTarget = gl.TEXTURE_CUBE_MAP;\n  const texture = gl.createTexture();\n\n  this._context = context;\n  this._textureFilterAnisotropic = context._textureFilterAnisotropic;\n  this._textureTarget = textureTarget;\n  this._texture = texture;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._size = size;\n  this._hasMipmap = false;\n  this._sizeInBytes = sizeInBytes;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n\n  const initialized = defined(source);\n  function constructFace(targetFace) {\n    return new CubeMapFace(\n      context,\n      texture,\n      textureTarget,\n      targetFace,\n      internalFormat,\n      pixelFormat,\n      pixelDatatype,\n      size,\n      preMultiplyAlpha,\n      flipY,\n      initialized,\n    );\n  }\n  this._positiveX = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X);\n  this._negativeX = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X);\n  this._positiveY = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y);\n  this._negativeY = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y);\n  this._positiveZ = constructFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z);\n  this._negativeZ = constructFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z);\n\n  this._sampler = sampler;\n  setupSampler(this, sampler);\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(textureTarget, texture);\n\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(\n      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,\n      gl.BROWSER_DEFAULT_WEBGL,\n    );\n  }\n\n  for (const faceName of CubeMap.faceNames()) {\n    loadFace(this[faceName], source?.[faceName], 0);\n  }\n\n  gl.bindTexture(textureTarget, null);\n}\n\n/**\n * Copy an existing texture to a cubemap face.\n * @param {FrameState} frameState The current rendering frameState\n * @param {Texture} texture Texture being copied\n * @param {CubeMap.FaceName} face The face to which to copy\n * @param {number} [mipLevel=0] The mip level at which to copy\n */\nCubeMap.prototype.copyFace = function (frameState, texture, face, mipLevel) {\n  const context = frameState.context;\n  const framebuffer = new Framebuffer({\n    context: context,\n    colorTextures: [texture],\n    destroyAttachments: false,\n  });\n\n  framebuffer._bind();\n\n  this[face].copyMipmapFromFramebuffer(\n    0,\n    0,\n    texture.width,\n    texture.height,\n    defaultValue(mipLevel, 0),\n  );\n  framebuffer._unBind();\n  framebuffer.destroy();\n};\n\n/**\n * An enum defining the names of the faces of a cube map.\n * @alias {CubeMap.FaceName}\n * @enum {string}\n * @private\n */\nCubeMap.FaceName = Object.freeze({\n  POSITIVEX: \"positiveX\",\n  NEGATIVEX: \"negativeX\",\n  POSITIVEY: \"positiveY\",\n  NEGATIVEY: \"negativeY\",\n  POSITIVEZ: \"positiveZ\",\n  NEGATIVEZ: \"negativeZ\",\n});\n\nfunction* makeFaceNamesIterator() {\n  yield CubeMap.FaceName.POSITIVEX;\n  yield CubeMap.FaceName.NEGATIVEX;\n  yield CubeMap.FaceName.POSITIVEY;\n  yield CubeMap.FaceName.NEGATIVEY;\n  yield CubeMap.FaceName.POSITIVEZ;\n  yield CubeMap.FaceName.NEGATIVEZ;\n}\n\n/**\n * Creates an iterator for looping over the cubemap faces.\n * @type {Iterable<CubeMap.FaceName>}\n * @private\n */\nCubeMap.faceNames = function () {\n  return makeFaceNamesIterator();\n};\n\n/**\n * Load texel data into one face of a cube map.\n * @param {CubeMapFace} cubeMapFace The face to which texel values will be loaded.\n * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|CubeMap.BufferSource} [source] The source for texel values to be loaded into the texture.\n * @param {number} [mipLevel=0] The mip level to which the texel values will be loaded.\n * @private\n */\nfunction loadFace(cubeMapFace, source, mipLevel) {\n  mipLevel = defaultValue(mipLevel, 0);\n  const targetFace = cubeMapFace._targetFace;\n  const size = Math.max(Math.floor(cubeMapFace._size / 2 ** mipLevel), 1);\n  const pixelFormat = cubeMapFace._pixelFormat;\n  const pixelDatatype = cubeMapFace._pixelDatatype;\n  const internalFormat = cubeMapFace._internalFormat;\n  const flipY = cubeMapFace._flipY;\n  const preMultiplyAlpha = cubeMapFace._preMultiplyAlpha;\n  const context = cubeMapFace._context;\n  const gl = context._gl;\n\n  if (!defined(source)) {\n    gl.texImage2D(\n      targetFace,\n      mipLevel,\n      internalFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      PixelDatatype.toWebGLConstant(pixelDatatype, context),\n      null,\n    );\n    return;\n  }\n\n  let { arrayBufferView } = source;\n\n  let unpackAlignment = 4;\n  if (defined(arrayBufferView)) {\n    unpackAlignment = PixelFormat.alignmentInBytes(\n      pixelFormat,\n      pixelDatatype,\n      size,\n    );\n  }\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n\n  if (defined(arrayBufferView)) {\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    if (flipY) {\n      arrayBufferView = PixelFormat.flipY(\n        arrayBufferView,\n        pixelFormat,\n        pixelDatatype,\n        size,\n        size,\n      );\n    }\n    gl.texImage2D(\n      targetFace,\n      mipLevel,\n      internalFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      PixelDatatype.toWebGLConstant(pixelDatatype, context),\n      arrayBufferView,\n    );\n  } else {\n    // Only valid for DOM-Element uploads\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n    gl.texImage2D(\n      targetFace,\n      mipLevel,\n      internalFormat,\n      pixelFormat,\n      PixelDatatype.toWebGLConstant(pixelDatatype, context),\n      source,\n    );\n  }\n}\n\nCubeMap.loadFace = loadFace;\n\nObject.defineProperties(CubeMap.prototype, {\n  positiveX: {\n    get: function () {\n      return this._positiveX;\n    },\n  },\n  negativeX: {\n    get: function () {\n      return this._negativeX;\n    },\n  },\n  positiveY: {\n    get: function () {\n      return this._positiveY;\n    },\n  },\n  negativeY: {\n    get: function () {\n      return this._negativeY;\n    },\n  },\n  positiveZ: {\n    get: function () {\n      return this._positiveZ;\n    },\n  },\n  negativeZ: {\n    get: function () {\n      return this._negativeZ;\n    },\n  },\n  sampler: {\n    get: function () {\n      return this._sampler;\n    },\n    set: function (sampler) {\n      setupSampler(this, sampler);\n      this._sampler = sampler;\n    },\n  },\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  width: {\n    get: function () {\n      return this._size;\n    },\n  },\n  height: {\n    get: function () {\n      return this._size;\n    },\n  },\n  sizeInBytes: {\n    get: function () {\n      if (this._hasMipmap) {\n        return Math.floor((this._sizeInBytes * 4) / 3);\n      }\n      return this._sizeInBytes;\n    },\n  },\n  preMultiplyAlpha: {\n    get: function () {\n      return this._preMultiplyAlpha;\n    },\n  },\n  flipY: {\n    get: function () {\n      return this._flipY;\n    },\n  },\n\n  _target: {\n    get: function () {\n      return this._textureTarget;\n    },\n  },\n});\n\n/**\n * Get a vector representing the cubemap face direction\n * @param {CubeMap.FaceName} face The relevant face\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The vector representing the cubemap face direction\n */\nCubeMap.getDirection = function (face, result) {\n  switch (face) {\n    case CubeMap.FaceName.POSITIVEX:\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    case CubeMap.FaceName.NEGATIVEX:\n      return Cartesian3.negate(Cartesian3.UNIT_X, result);\n    case CubeMap.FaceName.POSITIVEY:\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    case CubeMap.FaceName.NEGATIVEY:\n      return Cartesian3.negate(Cartesian3.UNIT_Y, result);\n    case CubeMap.FaceName.POSITIVEZ:\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    case CubeMap.FaceName.NEGATIVEZ:\n      return Cartesian3.negate(Cartesian3.UNIT_Z, result);\n  }\n};\n\n/**\n * Set up a sampler for use with a cube map.\n * @param {CubeMap} cubeMap The cube map containing the texture to be sampled by this sampler.\n * @param {Sampler} sampler Information about how to sample the cubemap texture.\n * @private\n */\nfunction setupSampler(cubeMap, sampler) {\n  let { minificationFilter, magnificationFilter } = sampler;\n\n  const mipmap = [\n    TextureMinificationFilter.NEAREST_MIPMAP_NEAREST,\n    TextureMinificationFilter.NEAREST_MIPMAP_LINEAR,\n    TextureMinificationFilter.LINEAR_MIPMAP_NEAREST,\n    TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n  ].includes(minificationFilter);\n\n  const context = cubeMap._context;\n  const pixelDatatype = cubeMap._pixelDatatype;\n\n  // float textures only support nearest filtering unless the linear extensions are supported\n  if (\n    (pixelDatatype === PixelDatatype.FLOAT && !context.textureFloatLinear) ||\n    (pixelDatatype === PixelDatatype.HALF_FLOAT &&\n      !context.textureHalfFloatLinear)\n  ) {\n    // override the sampler's settings\n    minificationFilter = mipmap\n      ? TextureMinificationFilter.NEAREST_MIPMAP_NEAREST\n      : TextureMinificationFilter.NEAREST;\n    magnificationFilter = TextureMagnificationFilter.NEAREST;\n  }\n\n  const gl = context._gl;\n  const target = cubeMap._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, cubeMap._texture);\n  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);\n  if (defined(cubeMap._textureFilterAnisotropic)) {\n    gl.texParameteri(\n      target,\n      cubeMap._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,\n      sampler.maximumAnisotropy,\n    );\n  }\n  gl.bindTexture(target, null);\n}\n\n/**\n * Load a complete mipmap chain for each cubemap face.\n *\n * @param {CubeMap.Source[]} source The source data for each mip level, beginning at level 1.\n * @param {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.\n *\n * @private\n */\nCubeMap.prototype.loadMipmaps = function (source, skipColorSpaceConversion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"source\", source);\n  if (!Array.isArray(source)) {\n    throw new DeveloperError(`source must be an array`);\n  }\n  const mipCount = Math.log2(this._size);\n  if (source.length !== mipCount) {\n    throw new DeveloperError(`all mip levels must be defined`);\n  }\n  //>>includeEnd('debug');\n\n  skipColorSpaceConversion = defaultValue(skipColorSpaceConversion, false);\n  const gl = this._context._gl;\n  const texture = this._texture;\n  const textureTarget = this._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(textureTarget, texture);\n\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(\n      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,\n      gl.BROWSER_DEFAULT_WEBGL,\n    );\n  }\n\n  for (let i = 0; i < source.length; i++) {\n    const mipSource = source[i];\n    // mipLevel 0 was the base layer, already loaded when the CubeMap was constructed.\n    const mipLevel = i + 1;\n    for (const faceName of CubeMap.faceNames()) {\n      loadFace(this[faceName], mipSource[faceName], mipLevel);\n    }\n  }\n\n  gl.bindTexture(textureTarget, null);\n\n  this._hasMipmap = true;\n};\n\n/**\n * Generates a complete mipmap chain for each cubemap face.\n *\n * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] A performance vs. quality hint.\n *\n * @exception {DeveloperError} hint is invalid.\n * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Generate mipmaps, and then set the sampler so mipmaps are used for\n * // minification when the cube map is sampled.\n * cubeMap.generateMipmap();\n * cubeMap.sampler = new Sampler({\n *   minificationFilter : Cesium.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n * });\n */\nCubeMap.prototype.generateMipmap = function (hint) {\n  hint = defaultValue(hint, MipmapHint.DONT_CARE);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (this._size > 1 && !CesiumMath.isPowerOfTwo(this._size)) {\n    throw new DeveloperError(\n      \"width and height must be a power of two to call generateMipmap().\",\n    );\n  }\n  if (!MipmapHint.validate(hint)) {\n    throw new DeveloperError(\"hint is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._hasMipmap = true;\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.generateMipmap(target);\n  gl.bindTexture(target, null);\n};\n\n/**\n * Create a vertex array that can be used for cubemap shaders.\n * @param {Context} context The rendering context\n * @returns {VertexArray} The created vertex array\n */\nCubeMap.createVertexArray = function (context) {\n  const geometry = BoxGeometry.createGeometry(\n    BoxGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n      vertexFormat: VertexFormat.POSITION_ONLY,\n    }),\n  );\n  const attributeLocations = (this._attributeLocations =\n    GeometryPipeline.createAttributeLocations(geometry));\n\n  return VertexArray.fromGeometry({\n    context: context,\n    geometry: geometry,\n    attributeLocations: attributeLocations,\n    bufferUsage: BufferUsage.STATIC_DRAW,\n  });\n};\n\nCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\n\nCubeMap.prototype.destroy = function () {\n  this._context._gl.deleteTexture(this._texture);\n  this._positiveX = destroyObject(this._positiveX);\n  this._negativeX = destroyObject(this._negativeX);\n  this._positiveY = destroyObject(this._positiveY);\n  this._negativeY = destroyObject(this._negativeY);\n  this._positiveZ = destroyObject(this._positiveZ);\n  this._negativeZ = destroyObject(this._negativeZ);\n  return destroyObject(this);\n};\nexport default CubeMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}