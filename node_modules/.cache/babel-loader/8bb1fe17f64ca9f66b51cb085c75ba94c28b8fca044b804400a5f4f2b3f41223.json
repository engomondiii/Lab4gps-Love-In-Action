{"ast":null,"code":"import ArcType from \"../Core/ArcType.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport Color from \"../Core/Color.js\";\nimport CornerType from \"../Core/CornerType.js\";\nimport Credit from \"../Core/Credit.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport HermitePolynomialApproximation from \"../Core/HermitePolynomialApproximation.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LagrangePolynomialApproximation from \"../Core/LagrangePolynomialApproximation.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Spherical from \"../Core/Spherical.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport Uri from \"urijs\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport BoxGraphics from \"./BoxGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport CheckerboardMaterialProperty from \"./CheckerboardMaterialProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport CompositeMaterialProperty from \"./CompositeMaterialProperty.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport CompositeProperty from \"./CompositeProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport CorridorGraphics from \"./CorridorGraphics.js\";\nimport CylinderGraphics from \"./CylinderGraphics.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport EllipseGraphics from \"./EllipseGraphics.js\";\nimport EllipsoidGraphics from \"./EllipsoidGraphics.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport GridMaterialProperty from \"./GridMaterialProperty.js\";\nimport ImageMaterialProperty from \"./ImageMaterialProperty.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport NodeTransformationProperty from \"./NodeTransformationProperty.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PointGraphics from \"./PointGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineArrowMaterialProperty from \"./PolylineArrowMaterialProperty.js\";\nimport PolylineDashMaterialProperty from \"./PolylineDashMaterialProperty.js\";\nimport PolylineGlowMaterialProperty from \"./PolylineGlowMaterialProperty.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PolylineOutlineMaterialProperty from \"./PolylineOutlineMaterialProperty.js\";\nimport PolylineVolumeGraphics from \"./PolylineVolumeGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport Property from \"./Property.js\";\nimport PropertyArray from \"./PropertyArray.js\";\nimport PropertyBag from \"./PropertyBag.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport Rotation from \"./Rotation.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport StripeMaterialProperty from \"./StripeMaterialProperty.js\";\nimport StripeOrientation from \"./StripeOrientation.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport VelocityOrientationProperty from \"./VelocityOrientationProperty.js\";\nimport VelocityVectorProperty from \"./VelocityVectorProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\nimport Cesium3DTilesetGraphics from \"./Cesium3DTilesetGraphics.js\";\nimport SensorVolumePortionToDisplay from \"../Scene/SensorVolumePortionToDisplay.js\";\n\n// A marker type to distinguish CZML properties where we need to end up with a unit vector.\n// The data is still loaded into Cartesian3 objects but they are normalized.\nfunction UnitCartesian3() {}\nUnitCartesian3.packedLength = Cartesian3.packedLength;\nUnitCartesian3.unpack = Cartesian3.unpack;\nUnitCartesian3.pack = Cartesian3.pack;\n\n// As a side note, for the purposes of CZML, Quaternion always indicates a unit quaternion.\n\nlet currentId;\nfunction createReferenceProperty(entityCollection, referenceString) {\n  if (referenceString[0] === \"#\") {\n    referenceString = currentId + referenceString;\n  }\n  return ReferenceProperty.fromString(entityCollection, referenceString);\n}\nfunction createSpecializedProperty(type, entityCollection, packetData) {\n  if (defined(packetData.reference)) {\n    return createReferenceProperty(entityCollection, packetData.reference);\n  }\n  if (defined(packetData.velocityReference)) {\n    const referenceProperty = createReferenceProperty(entityCollection, packetData.velocityReference);\n    switch (type) {\n      case Cartesian3:\n      case UnitCartesian3:\n        return new VelocityVectorProperty(referenceProperty, type === UnitCartesian3);\n      case Quaternion:\n        return new VelocityOrientationProperty(referenceProperty);\n    }\n  }\n  throw new RuntimeError(`${JSON.stringify(packetData)} is not valid CZML.`);\n}\nfunction createAdapterProperty(property, adapterFunction) {\n  return new CallbackProperty(function (time, result) {\n    return adapterFunction(property.getValue(time, result));\n  }, property.isConstant);\n}\nconst scratchCartesian = new Cartesian3();\nconst scratchSpherical = new Spherical();\nconst scratchCartographic = new Cartographic();\nconst scratchTimeInterval = new TimeInterval();\nconst scratchQuaternion = new Quaternion();\nfunction unwrapColorInterval(czmlInterval) {\n  let rgbaf = czmlInterval.rgbaf;\n  if (defined(rgbaf)) {\n    return rgbaf;\n  }\n  const rgba = czmlInterval.rgba;\n  if (!defined(rgba)) {\n    return undefined;\n  }\n  const length = rgba.length;\n  if (length === Color.packedLength) {\n    return [Color.byteToFloat(rgba[0]), Color.byteToFloat(rgba[1]), Color.byteToFloat(rgba[2]), Color.byteToFloat(rgba[3])];\n  }\n  rgbaf = new Array(length);\n  for (let i = 0; i < length; i += 5) {\n    rgbaf[i] = rgba[i];\n    rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);\n    rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);\n    rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);\n    rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);\n  }\n  return rgbaf;\n}\nfunction unwrapUriInterval(czmlInterval, sourceUri) {\n  const uri = defaultValue(czmlInterval.uri, czmlInterval);\n  if (defined(sourceUri)) {\n    return sourceUri.getDerivedResource({\n      url: uri\n    });\n  }\n  return Resource.createIfNeeded(uri);\n}\nfunction unwrapRectangleInterval(czmlInterval) {\n  let wsen = czmlInterval.wsen;\n  if (defined(wsen)) {\n    return wsen;\n  }\n  const wsenDegrees = czmlInterval.wsenDegrees;\n  if (!defined(wsenDegrees)) {\n    return undefined;\n  }\n  const length = wsenDegrees.length;\n  if (length === Rectangle.packedLength) {\n    return [CesiumMath.toRadians(wsenDegrees[0]), CesiumMath.toRadians(wsenDegrees[1]), CesiumMath.toRadians(wsenDegrees[2]), CesiumMath.toRadians(wsenDegrees[3])];\n  }\n  wsen = new Array(length);\n  for (let i = 0; i < length; i += 5) {\n    wsen[i] = wsenDegrees[i];\n    wsen[i + 1] = CesiumMath.toRadians(wsenDegrees[i + 1]);\n    wsen[i + 2] = CesiumMath.toRadians(wsenDegrees[i + 2]);\n    wsen[i + 3] = CesiumMath.toRadians(wsenDegrees[i + 3]);\n    wsen[i + 4] = CesiumMath.toRadians(wsenDegrees[i + 4]);\n  }\n  return wsen;\n}\nfunction convertUnitSphericalToCartesian(unitSpherical) {\n  const length = unitSpherical.length;\n  scratchSpherical.magnitude = 1.0;\n  if (length === 2) {\n    scratchSpherical.clock = unitSpherical[0];\n    scratchSpherical.cone = unitSpherical[1];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n  const result = new Array(length / 3 * 4);\n  for (let i = 0, j = 0; i < length; i += 3, j += 4) {\n    result[j] = unitSpherical[i];\n    scratchSpherical.clock = unitSpherical[i + 1];\n    scratchSpherical.cone = unitSpherical[i + 2];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    result[j + 1] = scratchCartesian.x;\n    result[j + 2] = scratchCartesian.y;\n    result[j + 3] = scratchCartesian.z;\n  }\n  return result;\n}\nfunction convertSphericalToCartesian(spherical) {\n  const length = spherical.length;\n  if (length === 3) {\n    scratchSpherical.clock = spherical[0];\n    scratchSpherical.cone = spherical[1];\n    scratchSpherical.magnitude = spherical[2];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = spherical[i];\n    scratchSpherical.clock = spherical[i + 1];\n    scratchSpherical.cone = spherical[i + 2];\n    scratchSpherical.magnitude = spherical[i + 3];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\nfunction convertCartographicRadiansToCartesian(cartographicRadians) {\n  const length = cartographicRadians.length;\n  if (length === 3) {\n    scratchCartographic.longitude = cartographicRadians[0];\n    scratchCartographic.latitude = cartographicRadians[1];\n    scratchCartographic.height = cartographicRadians[2];\n    Ellipsoid.default.cartographicToCartesian(scratchCartographic, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = cartographicRadians[i];\n    scratchCartographic.longitude = cartographicRadians[i + 1];\n    scratchCartographic.latitude = cartographicRadians[i + 2];\n    scratchCartographic.height = cartographicRadians[i + 3];\n    Ellipsoid.default.cartographicToCartesian(scratchCartographic, scratchCartesian);\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\nfunction convertCartographicDegreesToCartesian(cartographicDegrees) {\n  const length = cartographicDegrees.length;\n  if (length === 3) {\n    scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[0]);\n    scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);\n    scratchCartographic.height = cartographicDegrees[2];\n    Ellipsoid.default.cartographicToCartesian(scratchCartographic, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = cartographicDegrees[i];\n    scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[i + 1]);\n    scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[i + 2]);\n    scratchCartographic.height = cartographicDegrees[i + 3];\n    Ellipsoid.default.cartographicToCartesian(scratchCartographic, scratchCartesian);\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\nfunction unwrapCartesianInterval(czmlInterval) {\n  const cartesian = czmlInterval.cartesian;\n  if (defined(cartesian)) {\n    return cartesian;\n  }\n  const cartesianVelocity = czmlInterval.cartesianVelocity;\n  if (defined(cartesianVelocity)) {\n    return cartesianVelocity;\n  }\n  const unitCartesian = czmlInterval.unitCartesian;\n  if (defined(unitCartesian)) {\n    return unitCartesian;\n  }\n  const unitSpherical = czmlInterval.unitSpherical;\n  if (defined(unitSpherical)) {\n    return convertUnitSphericalToCartesian(unitSpherical);\n  }\n  const spherical = czmlInterval.spherical;\n  if (defined(spherical)) {\n    return convertSphericalToCartesian(spherical);\n  }\n  const cartographicRadians = czmlInterval.cartographicRadians;\n  if (defined(cartographicRadians)) {\n    return convertCartographicRadiansToCartesian(cartographicRadians);\n  }\n  const cartographicDegrees = czmlInterval.cartographicDegrees;\n  if (defined(cartographicDegrees)) {\n    return convertCartographicDegreesToCartesian(cartographicDegrees);\n  }\n  throw new RuntimeError(`${JSON.stringify(czmlInterval)} is not a valid CZML interval.`);\n}\nfunction normalizePackedCartesianArray(array, startingIndex) {\n  Cartesian3.unpack(array, startingIndex, scratchCartesian);\n  Cartesian3.normalize(scratchCartesian, scratchCartesian);\n  Cartesian3.pack(scratchCartesian, array, startingIndex);\n}\nfunction unwrapUnitCartesianInterval(czmlInterval) {\n  const cartesian = unwrapCartesianInterval(czmlInterval);\n  if (cartesian.length === 3) {\n    normalizePackedCartesianArray(cartesian, 0);\n    return cartesian;\n  }\n  for (let i = 1; i < cartesian.length; i += 4) {\n    normalizePackedCartesianArray(cartesian, i);\n  }\n  return cartesian;\n}\nfunction normalizePackedQuaternionArray(array, startingIndex) {\n  Quaternion.unpack(array, startingIndex, scratchQuaternion);\n  Quaternion.normalize(scratchQuaternion, scratchQuaternion);\n  Quaternion.pack(scratchQuaternion, array, startingIndex);\n}\nfunction unwrapQuaternionInterval(czmlInterval) {\n  const unitQuaternion = czmlInterval.unitQuaternion;\n  if (defined(unitQuaternion)) {\n    if (unitQuaternion.length === 4) {\n      normalizePackedQuaternionArray(unitQuaternion, 0);\n      return unitQuaternion;\n    }\n    for (let i = 1; i < unitQuaternion.length; i += 5) {\n      normalizePackedQuaternionArray(unitQuaternion, i);\n    }\n  }\n  return unitQuaternion;\n}\nfunction getPropertyType(czmlInterval) {\n  // The associations in this function need to be kept in sync with the\n  // associations in unwrapInterval.\n\n  // Intentionally omitted due to conficts in CZML property names:\n  // * Image (conflicts with Uri)\n  // * Rotation (conflicts with Number)\n  //\n  // cartesianVelocity is also omitted due to incomplete support for\n  // derivative information in CZML properties.\n  // (Currently cartesianVelocity is hacked directly into the position processing code)\n  if (typeof czmlInterval === \"boolean\") {\n    return Boolean;\n  } else if (typeof czmlInterval === \"number\") {\n    return Number;\n  } else if (typeof czmlInterval === \"string\") {\n    return String;\n  } else if (czmlInterval.hasOwnProperty(\"array\")) {\n    return Array;\n  } else if (czmlInterval.hasOwnProperty(\"boolean\")) {\n    return Boolean;\n  } else if (czmlInterval.hasOwnProperty(\"boundingRectangle\")) {\n    return BoundingRectangle;\n  } else if (czmlInterval.hasOwnProperty(\"cartesian2\")) {\n    return Cartesian2;\n  } else if (czmlInterval.hasOwnProperty(\"cartesian\") || czmlInterval.hasOwnProperty(\"spherical\") || czmlInterval.hasOwnProperty(\"cartographicRadians\") || czmlInterval.hasOwnProperty(\"cartographicDegrees\")) {\n    return Cartesian3;\n  } else if (czmlInterval.hasOwnProperty(\"unitCartesian\") || czmlInterval.hasOwnProperty(\"unitSpherical\")) {\n    return UnitCartesian3;\n  } else if (czmlInterval.hasOwnProperty(\"rgba\") || czmlInterval.hasOwnProperty(\"rgbaf\")) {\n    return Color;\n  } else if (czmlInterval.hasOwnProperty(\"arcType\")) {\n    return ArcType;\n  } else if (czmlInterval.hasOwnProperty(\"classificationType\")) {\n    return ClassificationType;\n  } else if (czmlInterval.hasOwnProperty(\"colorBlendMode\")) {\n    return ColorBlendMode;\n  } else if (czmlInterval.hasOwnProperty(\"cornerType\")) {\n    return CornerType;\n  } else if (czmlInterval.hasOwnProperty(\"heightReference\")) {\n    return HeightReference;\n  } else if (czmlInterval.hasOwnProperty(\"horizontalOrigin\")) {\n    return HorizontalOrigin;\n  } else if (czmlInterval.hasOwnProperty(\"date\")) {\n    return JulianDate;\n  } else if (czmlInterval.hasOwnProperty(\"labelStyle\")) {\n    return LabelStyle;\n  } else if (czmlInterval.hasOwnProperty(\"number\")) {\n    return Number;\n  } else if (czmlInterval.hasOwnProperty(\"nearFarScalar\")) {\n    return NearFarScalar;\n  } else if (czmlInterval.hasOwnProperty(\"distanceDisplayCondition\")) {\n    return DistanceDisplayCondition;\n  } else if (czmlInterval.hasOwnProperty(\"object\") || czmlInterval.hasOwnProperty(\"value\")) {\n    return Object;\n  } else if (czmlInterval.hasOwnProperty(\"unitQuaternion\")) {\n    return Quaternion;\n  } else if (czmlInterval.hasOwnProperty(\"shadowMode\")) {\n    return ShadowMode;\n  } else if (czmlInterval.hasOwnProperty(\"string\")) {\n    return String;\n  } else if (czmlInterval.hasOwnProperty(\"stripeOrientation\")) {\n    return StripeOrientation;\n  } else if (czmlInterval.hasOwnProperty(\"wsen\") || czmlInterval.hasOwnProperty(\"wsenDegrees\")) {\n    return Rectangle;\n  } else if (czmlInterval.hasOwnProperty(\"uri\")) {\n    return Uri;\n  } else if (czmlInterval.hasOwnProperty(\"verticalOrigin\")) {\n    return VerticalOrigin;\n  }\n  // fallback case\n  return Object;\n}\nfunction unwrapInterval(type, czmlInterval, sourceUri) {\n  // The associations in this function need to be kept in sync with the\n  // associations in getPropertyType\n  switch (type) {\n    case ArcType:\n      return ArcType[defaultValue(czmlInterval.arcType, czmlInterval)];\n    case Array:\n      return czmlInterval.array;\n    case Boolean:\n      return defaultValue(czmlInterval[\"boolean\"], czmlInterval);\n    case BoundingRectangle:\n      return czmlInterval.boundingRectangle;\n    case Cartesian2:\n      return czmlInterval.cartesian2;\n    case Cartesian3:\n      return unwrapCartesianInterval(czmlInterval);\n    case UnitCartesian3:\n      return unwrapUnitCartesianInterval(czmlInterval);\n    case Color:\n      return unwrapColorInterval(czmlInterval);\n    case ClassificationType:\n      return ClassificationType[defaultValue(czmlInterval.classificationType, czmlInterval)];\n    case ColorBlendMode:\n      return ColorBlendMode[defaultValue(czmlInterval.colorBlendMode, czmlInterval)];\n    case CornerType:\n      return CornerType[defaultValue(czmlInterval.cornerType, czmlInterval)];\n    case HeightReference:\n      return HeightReference[defaultValue(czmlInterval.heightReference, czmlInterval)];\n    case HorizontalOrigin:\n      return HorizontalOrigin[defaultValue(czmlInterval.horizontalOrigin, czmlInterval)];\n    case Image:\n      return unwrapUriInterval(czmlInterval, sourceUri);\n    case JulianDate:\n      return JulianDate.fromIso8601(defaultValue(czmlInterval.date, czmlInterval));\n    case LabelStyle:\n      return LabelStyle[defaultValue(czmlInterval.labelStyle, czmlInterval)];\n    case Number:\n      return defaultValue(czmlInterval.number, czmlInterval);\n    case NearFarScalar:\n      return czmlInterval.nearFarScalar;\n    case DistanceDisplayCondition:\n      return czmlInterval.distanceDisplayCondition;\n    case Object:\n      return defaultValue(defaultValue(czmlInterval.object, czmlInterval.value), czmlInterval);\n    case Quaternion:\n      return unwrapQuaternionInterval(czmlInterval);\n    case Rotation:\n      return defaultValue(czmlInterval.number, czmlInterval);\n    case SensorVolumePortionToDisplay:\n      return SensorVolumePortionToDisplay[defaultValue(czmlInterval.portionToDisplay, czmlInterval)];\n    case ShadowMode:\n      return ShadowMode[defaultValue(defaultValue(czmlInterval.shadowMode, czmlInterval.shadows), czmlInterval)];\n    case String:\n      return defaultValue(czmlInterval.string, czmlInterval);\n    case StripeOrientation:\n      return StripeOrientation[defaultValue(czmlInterval.stripeOrientation, czmlInterval)];\n    case Rectangle:\n      return unwrapRectangleInterval(czmlInterval);\n    case Uri:\n      return unwrapUriInterval(czmlInterval, sourceUri);\n    case VerticalOrigin:\n      return VerticalOrigin[defaultValue(czmlInterval.verticalOrigin, czmlInterval)];\n    default:\n      throw new RuntimeError(`Unknown CzmlDataSource interval type: ${type}`);\n  }\n}\nconst interpolators = {\n  HERMITE: HermitePolynomialApproximation,\n  LAGRANGE: LagrangePolynomialApproximation,\n  LINEAR: LinearApproximation\n};\nfunction updateInterpolationSettings(packetData, property) {\n  const interpolationAlgorithm = packetData.interpolationAlgorithm;\n  const interpolationDegree = packetData.interpolationDegree;\n  if (defined(interpolationAlgorithm) || defined(interpolationDegree)) {\n    property.setInterpolationOptions({\n      interpolationAlgorithm: interpolators[interpolationAlgorithm],\n      interpolationDegree: interpolationDegree\n    });\n  }\n  const forwardExtrapolationType = packetData.forwardExtrapolationType;\n  if (defined(forwardExtrapolationType)) {\n    property.forwardExtrapolationType = ExtrapolationType[forwardExtrapolationType];\n  }\n  const forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;\n  if (defined(forwardExtrapolationDuration)) {\n    property.forwardExtrapolationDuration = forwardExtrapolationDuration;\n  }\n  const backwardExtrapolationType = packetData.backwardExtrapolationType;\n  if (defined(backwardExtrapolationType)) {\n    property.backwardExtrapolationType = ExtrapolationType[backwardExtrapolationType];\n  }\n  const backwardExtrapolationDuration = packetData.backwardExtrapolationDuration;\n  if (defined(backwardExtrapolationDuration)) {\n    property.backwardExtrapolationDuration = backwardExtrapolationDuration;\n  }\n}\nconst iso8601Scratch = {\n  iso8601: undefined\n};\nfunction intervalFromString(intervalString) {\n  if (!defined(intervalString)) {\n    return undefined;\n  }\n  iso8601Scratch.iso8601 = intervalString;\n  return TimeInterval.fromIso8601(iso8601Scratch);\n}\nfunction wrapPropertyInInfiniteInterval(property) {\n  const interval = Iso8601.MAXIMUM_INTERVAL.clone();\n  interval.data = property;\n  return interval;\n}\nfunction convertPropertyToComposite(property) {\n  // Create the composite and add the old property, wrapped in an infinite interval.\n  const composite = new CompositeProperty();\n  composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n  return composite;\n}\nfunction convertPositionPropertyToComposite(property) {\n  // Create the composite and add the old property, wrapped in an infinite interval.\n  const composite = new CompositePositionProperty(property.referenceFrame);\n  composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n  return composite;\n}\nfunction processProperty(type, object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n  let packedLength;\n  let unwrappedInterval;\n  let unwrappedIntervalLength;\n\n  // CZML properties can be defined in many ways.  Most ways represent a structure for\n  // encoding a single value (number, string, cartesian, etc.)  Regardless of the value type,\n  // if it encodes a single value it will get loaded into a ConstantProperty eventually.\n  // Alternatively, there are ways of defining a property that require specialized\n  // client-side representation. Currently, these are ReferenceProperty,\n  // and client-side velocity computation properties such as VelocityVectorProperty.\n  const isValue = !defined(packetData.reference) && !defined(packetData.velocityReference);\n  const hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n  if (packetData.delete === true) {\n    // If deleting this property for all time, we can simply set to undefined and return.\n    if (!hasInterval) {\n      object[propertyName] = undefined;\n      return;\n    }\n\n    // Deleting depends on the type of property we have.\n    return removePropertyData(object[propertyName], combinedInterval);\n  }\n  let isSampled = false;\n  if (isValue) {\n    unwrappedInterval = unwrapInterval(type, packetData, sourceUri);\n    if (!defined(unwrappedInterval)) {\n      // not a known value type, bail\n      return;\n    }\n    packedLength = defaultValue(type.packedLength, 1);\n    unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);\n    isSampled = !defined(packetData.array) && typeof unwrappedInterval !== \"string\" && unwrappedIntervalLength > packedLength && type !== Object;\n  }\n\n  // Rotation is a special case because it represents a native type (Number)\n  // and therefore does not need to be unpacked when loaded as a constant value.\n  const needsUnpacking = typeof type.unpack === \"function\" && type !== Rotation;\n\n  // Any time a constant value is assigned, it completely blows away anything else.\n  if (!isSampled && !hasInterval) {\n    if (isValue) {\n      object[propertyName] = new ConstantProperty(needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval);\n    } else {\n      object[propertyName] = createSpecializedProperty(type, entityCollection, packetData);\n    }\n    return;\n  }\n  let property = object[propertyName];\n  let epoch;\n  const packetEpoch = packetData.epoch;\n  if (defined(packetEpoch)) {\n    epoch = JulianDate.fromIso8601(packetEpoch);\n  }\n\n  // Without an interval, any sampled value is infinite, meaning it completely\n  // replaces any non-sampled property that may exist.\n  if (isSampled && !hasInterval) {\n    if (!(property instanceof SampledProperty)) {\n      object[propertyName] = property = new SampledProperty(type);\n    }\n    property.addSamplesPackedArray(unwrappedInterval, epoch);\n    updateInterpolationSettings(packetData, property);\n    return;\n  }\n  let interval;\n\n  // A constant value with an interval is normally part of a TimeIntervalCollection,\n  // However, if the current property is not a time-interval collection, we need\n  // to turn it into a Composite, preserving the old data with the new interval.\n  if (!isSampled && hasInterval) {\n    // Create a new interval for the constant value.\n    combinedInterval = combinedInterval.clone();\n    if (isValue) {\n      combinedInterval.data = needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval;\n    } else {\n      combinedInterval.data = createSpecializedProperty(type, entityCollection, packetData);\n    }\n\n    // If no property exists, simply use a new interval collection\n    if (!defined(property)) {\n      object[propertyName] = property = isValue ? new TimeIntervalCollectionProperty() : new CompositeProperty();\n    }\n    if (isValue && property instanceof TimeIntervalCollectionProperty) {\n      // If we created a collection, or it already was one, use it.\n      property.intervals.addInterval(combinedInterval);\n    } else if (property instanceof CompositeProperty) {\n      // If the collection was already a CompositeProperty, use it.\n      if (isValue) {\n        combinedInterval.data = new ConstantProperty(combinedInterval.data);\n      }\n      property.intervals.addInterval(combinedInterval);\n    } else {\n      // Otherwise, create a CompositeProperty but preserve the existing data.\n      object[propertyName] = property = convertPropertyToComposite(property);\n\n      // Change the new data to a ConstantProperty and add it.\n      if (isValue) {\n        combinedInterval.data = new ConstantProperty(combinedInterval.data);\n      }\n      property.intervals.addInterval(combinedInterval);\n    }\n    return;\n  }\n\n  // isSampled && hasInterval\n  if (!defined(property)) {\n    object[propertyName] = property = new CompositeProperty();\n  }\n\n  // Create a CompositeProperty but preserve the existing data.\n  if (!(property instanceof CompositeProperty)) {\n    object[propertyName] = property = convertPropertyToComposite(property);\n  }\n\n  // Check if the interval already exists in the composite.\n  const intervals = property.intervals;\n  interval = intervals.findInterval(combinedInterval);\n  if (!defined(interval) || !(interval.data instanceof SampledProperty)) {\n    // If not, create a SampledProperty for it.\n    interval = combinedInterval.clone();\n    interval.data = new SampledProperty(type);\n    intervals.addInterval(interval);\n  }\n  interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n  updateInterpolationSettings(packetData, interval.data);\n}\nfunction removePropertyData(property, interval) {\n  if (property instanceof SampledProperty) {\n    property.removeSamples(interval);\n    return;\n  } else if (property instanceof TimeIntervalCollectionProperty) {\n    property.intervals.removeInterval(interval);\n    return;\n  } else if (property instanceof CompositeProperty) {\n    const intervals = property.intervals;\n    for (let i = 0; i < intervals.length; ++i) {\n      const intersection = TimeInterval.intersect(intervals.get(i), interval, scratchTimeInterval);\n      if (!intersection.isEmpty) {\n        // remove data from the contained properties\n        removePropertyData(intersection.data, interval);\n      }\n    }\n    // remove the intervals from the composite\n    intervals.removeInterval(interval);\n    return;\n  }\n}\nfunction processPacketData(type, object, propertyName, packetData, interval, sourceUri, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processProperty(type, object, propertyName, packetData[i], interval, sourceUri, entityCollection);\n    }\n  } else {\n    processProperty(type, object, propertyName, packetData, interval, sourceUri, entityCollection);\n  }\n}\nfunction processPositionProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n  const numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;\n  const packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);\n  let unwrappedInterval;\n  let unwrappedIntervalLength;\n  const isValue = !defined(packetData.reference);\n  const hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n  if (packetData.delete === true) {\n    // If deleting this property for all time, we can simply set to undefined and return.\n    if (!hasInterval) {\n      object[propertyName] = undefined;\n      return;\n    }\n\n    // Deleting depends on the type of property we have.\n    return removePositionPropertyData(object[propertyName], combinedInterval);\n  }\n  let referenceFrame;\n  let isSampled = false;\n  if (isValue) {\n    if (defined(packetData.referenceFrame)) {\n      referenceFrame = ReferenceFrame[packetData.referenceFrame];\n    }\n    referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n    unwrappedInterval = unwrapCartesianInterval(packetData);\n    unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);\n    isSampled = unwrappedIntervalLength > packedLength;\n  }\n\n  // Any time a constant value is assigned, it completely blows away anything else.\n  if (!isSampled && !hasInterval) {\n    if (isValue) {\n      object[propertyName] = new ConstantPositionProperty(Cartesian3.unpack(unwrappedInterval), referenceFrame);\n    } else {\n      object[propertyName] = createReferenceProperty(entityCollection, packetData.reference);\n    }\n    return;\n  }\n  let property = object[propertyName];\n  let epoch;\n  const packetEpoch = packetData.epoch;\n  if (defined(packetEpoch)) {\n    epoch = JulianDate.fromIso8601(packetEpoch);\n  }\n\n  // Without an interval, any sampled value is infinite, meaning it completely\n  // replaces any non-sampled property that may exist.\n  if (isSampled && !hasInterval) {\n    if (!(property instanceof SampledPositionProperty) || defined(referenceFrame) && property.referenceFrame !== referenceFrame) {\n      object[propertyName] = property = new SampledPositionProperty(referenceFrame, numberOfDerivatives);\n    }\n    property.addSamplesPackedArray(unwrappedInterval, epoch);\n    updateInterpolationSettings(packetData, property);\n    return;\n  }\n  let interval;\n\n  // A constant value with an interval is normally part of a TimeIntervalCollection,\n  // However, if the current property is not a time-interval collection, we need\n  // to turn it into a Composite, preserving the old data with the new interval.\n  if (!isSampled && hasInterval) {\n    // Create a new interval for the constant value.\n    combinedInterval = combinedInterval.clone();\n    if (isValue) {\n      combinedInterval.data = Cartesian3.unpack(unwrappedInterval);\n    } else {\n      combinedInterval.data = createReferenceProperty(entityCollection, packetData.reference);\n    }\n\n    // If no property exists, simply use a new interval collection\n    if (!defined(property)) {\n      if (isValue) {\n        property = new TimeIntervalCollectionPositionProperty(referenceFrame);\n      } else {\n        property = new CompositePositionProperty(referenceFrame);\n      }\n      object[propertyName] = property;\n    }\n    if (isValue && property instanceof TimeIntervalCollectionPositionProperty && defined(referenceFrame) && property.referenceFrame === referenceFrame) {\n      // If we create a collection, or it already existed, use it.\n      property.intervals.addInterval(combinedInterval);\n    } else if (property instanceof CompositePositionProperty) {\n      // If the collection was already a CompositePositionProperty, use it.\n      if (isValue) {\n        combinedInterval.data = new ConstantPositionProperty(combinedInterval.data, referenceFrame);\n      }\n      property.intervals.addInterval(combinedInterval);\n    } else {\n      // Otherwise, create a CompositePositionProperty but preserve the existing data.\n      object[propertyName] = property = convertPositionPropertyToComposite(property);\n\n      // Change the new data to a ConstantPositionProperty and add it.\n      if (isValue) {\n        combinedInterval.data = new ConstantPositionProperty(combinedInterval.data, referenceFrame);\n      }\n      property.intervals.addInterval(combinedInterval);\n    }\n    return;\n  }\n\n  // isSampled && hasInterval\n  if (!defined(property)) {\n    object[propertyName] = property = new CompositePositionProperty(referenceFrame);\n  } else if (!(property instanceof CompositePositionProperty)) {\n    // Create a CompositeProperty but preserve the existing data.\n    object[propertyName] = property = convertPositionPropertyToComposite(property);\n  }\n\n  // Check if the interval already exists in the composite.\n  const intervals = property.intervals;\n  interval = intervals.findInterval(combinedInterval);\n  if (!defined(interval) || !(interval.data instanceof SampledPositionProperty) || defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame) {\n    // If not, create a SampledPositionProperty for it.\n    interval = combinedInterval.clone();\n    interval.data = new SampledPositionProperty(referenceFrame, numberOfDerivatives);\n    intervals.addInterval(interval);\n  }\n  interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n  updateInterpolationSettings(packetData, interval.data);\n}\nfunction removePositionPropertyData(property, interval) {\n  if (property instanceof SampledPositionProperty) {\n    property.removeSamples(interval);\n    return;\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    property.intervals.removeInterval(interval);\n    return;\n  } else if (property instanceof CompositePositionProperty) {\n    const intervals = property.intervals;\n    for (let i = 0; i < intervals.length; ++i) {\n      const intersection = TimeInterval.intersect(intervals.get(i), interval, scratchTimeInterval);\n      if (!intersection.isEmpty) {\n        // remove data from the contained properties\n        removePositionPropertyData(intersection.data, interval);\n      }\n    }\n    // remove the intervals from the composite\n    intervals.removeInterval(interval);\n    return;\n  }\n}\nfunction processPositionPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processPositionProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);\n    }\n  } else {\n    processPositionProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);\n  }\n}\nfunction processShapePacketData(object, propertyName, packetData, entityCollection) {\n  if (defined(packetData.references)) {\n    processReferencesArrayPacketData(object, propertyName, packetData.references, packetData.interval, entityCollection, PropertyArray, CompositeProperty);\n  } else {\n    if (defined(packetData.cartesian2)) {\n      packetData.array = Cartesian2.unpackArray(packetData.cartesian2);\n    } else if (defined(packetData.cartesian)) {\n      // for backwards compatibility, also accept `cartesian`\n      packetData.array = Cartesian2.unpackArray(packetData.cartesian);\n    }\n    if (defined(packetData.array)) {\n      processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n    }\n  }\n}\nfunction processMaterialProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n  let property = object[propertyName];\n  let existingMaterial;\n  let existingInterval;\n  if (defined(combinedInterval)) {\n    if (!(property instanceof CompositeMaterialProperty)) {\n      property = new CompositeMaterialProperty();\n      object[propertyName] = property;\n    }\n    //See if we already have data at that interval.\n    const thisIntervals = property.intervals;\n    existingInterval = thisIntervals.findInterval({\n      start: combinedInterval.start,\n      stop: combinedInterval.stop\n    });\n    if (defined(existingInterval)) {\n      //We have an interval, but we need to make sure the\n      //new data is the same type of material as the old data.\n      existingMaterial = existingInterval.data;\n    } else {\n      //If not, create it.\n      existingInterval = combinedInterval.clone();\n      thisIntervals.addInterval(existingInterval);\n    }\n  } else {\n    existingMaterial = property;\n  }\n  let materialData;\n  if (defined(packetData.solidColor)) {\n    if (!(existingMaterial instanceof ColorMaterialProperty)) {\n      existingMaterial = new ColorMaterialProperty();\n    }\n    materialData = packetData.solidColor;\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, undefined, entityCollection);\n  } else if (defined(packetData.grid)) {\n    if (!(existingMaterial instanceof GridMaterialProperty)) {\n      existingMaterial = new GridMaterialProperty();\n    }\n    materialData = packetData.grid;\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"cellAlpha\", materialData.cellAlpha, undefined, sourceUri, entityCollection);\n    processPacketData(Cartesian2, existingMaterial, \"lineCount\", materialData.lineCount, undefined, sourceUri, entityCollection);\n    processPacketData(Cartesian2, existingMaterial, \"lineThickness\", materialData.lineThickness, undefined, sourceUri, entityCollection);\n    processPacketData(Cartesian2, existingMaterial, \"lineOffset\", materialData.lineOffset, undefined, sourceUri, entityCollection);\n  } else if (defined(packetData.image)) {\n    if (!(existingMaterial instanceof ImageMaterialProperty)) {\n      existingMaterial = new ImageMaterialProperty();\n    }\n    materialData = packetData.image;\n    processPacketData(Image, existingMaterial, \"image\", materialData.image, undefined, sourceUri, entityCollection);\n    processPacketData(Cartesian2, existingMaterial, \"repeat\", materialData.repeat, undefined, sourceUri, entityCollection);\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, sourceUri, entityCollection);\n    processPacketData(Boolean, existingMaterial, \"transparent\", materialData.transparent, undefined, sourceUri, entityCollection);\n  } else if (defined(packetData.stripe)) {\n    if (!(existingMaterial instanceof StripeMaterialProperty)) {\n      existingMaterial = new StripeMaterialProperty();\n    }\n    materialData = packetData.stripe;\n    processPacketData(StripeOrientation, existingMaterial, \"orientation\", materialData.orientation, undefined, sourceUri, entityCollection);\n    processPacketData(Color, existingMaterial, \"evenColor\", materialData.evenColor, undefined, sourceUri, entityCollection);\n    processPacketData(Color, existingMaterial, \"oddColor\", materialData.oddColor, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"offset\", materialData.offset, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"repeat\", materialData.repeat, undefined, sourceUri, entityCollection);\n  } else if (defined(packetData.polylineOutline)) {\n    if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {\n      existingMaterial = new PolylineOutlineMaterialProperty();\n    }\n    materialData = packetData.polylineOutline;\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, sourceUri, entityCollection);\n    processPacketData(Color, existingMaterial, \"outlineColor\", materialData.outlineColor, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"outlineWidth\", materialData.outlineWidth, undefined, sourceUri, entityCollection);\n  } else if (defined(packetData.polylineGlow)) {\n    if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {\n      existingMaterial = new PolylineGlowMaterialProperty();\n    }\n    materialData = packetData.polylineGlow;\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"glowPower\", materialData.glowPower, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"taperPower\", materialData.taperPower, undefined, sourceUri, entityCollection);\n  } else if (defined(packetData.polylineArrow)) {\n    if (!(existingMaterial instanceof PolylineArrowMaterialProperty)) {\n      existingMaterial = new PolylineArrowMaterialProperty();\n    }\n    materialData = packetData.polylineArrow;\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, undefined, entityCollection);\n  } else if (defined(packetData.polylineDash)) {\n    if (!(existingMaterial instanceof PolylineDashMaterialProperty)) {\n      existingMaterial = new PolylineDashMaterialProperty();\n    }\n    materialData = packetData.polylineDash;\n    processPacketData(Color, existingMaterial, \"color\", materialData.color, undefined, undefined, entityCollection);\n    processPacketData(Color, existingMaterial, \"gapColor\", materialData.gapColor, undefined, undefined, entityCollection);\n    processPacketData(Number, existingMaterial, \"dashLength\", materialData.dashLength, undefined, sourceUri, entityCollection);\n    processPacketData(Number, existingMaterial, \"dashPattern\", materialData.dashPattern, undefined, sourceUri, entityCollection);\n  } else if (defined(packetData.checkerboard)) {\n    if (!(existingMaterial instanceof CheckerboardMaterialProperty)) {\n      existingMaterial = new CheckerboardMaterialProperty();\n    }\n    materialData = packetData.checkerboard;\n    processPacketData(Color, existingMaterial, \"evenColor\", materialData.evenColor, undefined, sourceUri, entityCollection);\n    processPacketData(Color, existingMaterial, \"oddColor\", materialData.oddColor, undefined, sourceUri, entityCollection);\n    processPacketData(Cartesian2, existingMaterial, \"repeat\", materialData.repeat, undefined, sourceUri, entityCollection);\n  }\n  if (defined(existingInterval)) {\n    existingInterval.data = existingMaterial;\n  } else {\n    object[propertyName] = existingMaterial;\n  }\n}\nfunction processMaterialPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processMaterialProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);\n    }\n  } else {\n    processMaterialProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);\n  }\n}\nfunction processName(entity, packet, entityCollection, sourceUri) {\n  const nameData = packet.name;\n  if (defined(nameData)) {\n    entity.name = packet.name;\n  }\n}\nfunction processDescription(entity, packet, entityCollection, sourceUri) {\n  const descriptionData = packet.description;\n  if (defined(descriptionData)) {\n    processPacketData(String, entity, \"description\", descriptionData, undefined, sourceUri, entityCollection);\n  }\n}\nfunction processPosition(entity, packet, entityCollection, sourceUri) {\n  const positionData = packet.position;\n  if (defined(positionData)) {\n    processPositionPacketData(entity, \"position\", positionData, undefined, sourceUri, entityCollection);\n  }\n}\nfunction processViewFrom(entity, packet, entityCollection, sourceUri) {\n  const viewFromData = packet.viewFrom;\n  if (defined(viewFromData)) {\n    processPacketData(Cartesian3, entity, \"viewFrom\", viewFromData, undefined, sourceUri, entityCollection);\n  }\n}\nfunction processOrientation(entity, packet, entityCollection, sourceUri) {\n  const orientationData = packet.orientation;\n  if (defined(orientationData)) {\n    processPacketData(Quaternion, entity, \"orientation\", orientationData, undefined, sourceUri, entityCollection);\n  }\n}\nfunction processProperties(entity, packet, entityCollection, sourceUri) {\n  const propertiesData = packet.properties;\n  if (defined(propertiesData)) {\n    if (!defined(entity.properties)) {\n      entity.properties = new PropertyBag();\n    }\n\n    // We cannot simply call processPacketData(entity, 'properties', propertyData, undefined, sourceUri, entityCollection)\n    // because each property of \"properties\" may vary separately.\n    // The properties will be accessible as entity.properties.myprop.getValue(time).\n\n    for (const key in propertiesData) {\n      if (propertiesData.hasOwnProperty(key)) {\n        if (!entity.properties.hasProperty(key)) {\n          entity.properties.addProperty(key);\n        }\n        const propertyData = propertiesData[key];\n        if (Array.isArray(propertyData)) {\n          for (let i = 0, len = propertyData.length; i < len; ++i) {\n            processProperty(getPropertyType(propertyData[i]), entity.properties, key, propertyData[i], undefined, sourceUri, entityCollection);\n          }\n        } else {\n          processProperty(getPropertyType(propertyData), entity.properties, key, propertyData, undefined, sourceUri, entityCollection);\n        }\n      }\n    }\n  }\n}\nfunction processReferencesArrayPacketData(object, propertyName, references, interval, entityCollection, PropertyArrayType, CompositePropertyArrayType) {\n  const properties = references.map(function (reference) {\n    return createReferenceProperty(entityCollection, reference);\n  });\n  if (defined(interval)) {\n    interval = intervalFromString(interval);\n    let property = object[propertyName];\n    if (!(property instanceof CompositePropertyArrayType)) {\n      // If the property was not already a CompositeProperty,\n      // create a CompositeProperty but preserve the existing data.\n\n      // Create the composite and add the old property, wrapped in an infinite interval.\n      const composite = new CompositePropertyArrayType();\n      composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n      object[propertyName] = property = composite;\n    }\n    interval.data = new PropertyArrayType(properties);\n    property.intervals.addInterval(interval);\n  } else {\n    object[propertyName] = new PropertyArrayType(properties);\n  }\n}\nfunction processArrayPacketData(object, propertyName, packetData, entityCollection) {\n  const references = packetData.references;\n  if (defined(references)) {\n    processReferencesArrayPacketData(object, propertyName, references, packetData.interval, entityCollection, PropertyArray, CompositeProperty);\n  } else {\n    processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n  }\n}\nfunction processArray(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processArrayPacketData(object, propertyName, packetData[i], entityCollection);\n    }\n  } else {\n    processArrayPacketData(object, propertyName, packetData, entityCollection);\n  }\n}\nfunction processPositionArrayPacketData(object, propertyName, packetData, entityCollection) {\n  const references = packetData.references;\n  if (defined(references)) {\n    processReferencesArrayPacketData(object, propertyName, references, packetData.interval, entityCollection, PositionPropertyArray, CompositePositionProperty);\n  } else {\n    if (defined(packetData.cartesian)) {\n      packetData.array = Cartesian3.unpackArray(packetData.cartesian);\n    } else if (defined(packetData.cartographicRadians)) {\n      packetData.array = Cartesian3.fromRadiansArrayHeights(packetData.cartographicRadians, Ellipsoid.default);\n    } else if (defined(packetData.cartographicDegrees)) {\n      packetData.array = Cartesian3.fromDegreesArrayHeights(packetData.cartographicDegrees, Ellipsoid.default);\n    }\n    if (defined(packetData.array)) {\n      processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n    }\n  }\n}\nfunction processPositionArray(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processPositionArrayPacketData(object, propertyName, packetData[i], entityCollection);\n    }\n  } else {\n    processPositionArrayPacketData(object, propertyName, packetData, entityCollection);\n  }\n}\nfunction unpackCartesianArray(array) {\n  return Cartesian3.unpackArray(array);\n}\nfunction unpackCartographicRadiansArray(array) {\n  return Cartesian3.fromRadiansArrayHeights(array, Ellipsoid.default);\n}\nfunction unpackCartographicDegreesArray(array) {\n  return Cartesian3.fromDegreesArrayHeights(array, Ellipsoid.default);\n}\nfunction processPositionArrayOfArraysPacketData(object, propertyName, packetData, entityCollection) {\n  const references = packetData.references;\n  if (defined(references)) {\n    const properties = references.map(function (referenceArray) {\n      const tempObj = {};\n      processReferencesArrayPacketData(tempObj, \"positions\", referenceArray, packetData.interval, entityCollection, PositionPropertyArray, CompositePositionProperty);\n      return tempObj.positions;\n    });\n    object[propertyName] = new PositionPropertyArray(properties);\n  } else {\n    if (defined(packetData.cartesian)) {\n      packetData.array = packetData.cartesian.map(unpackCartesianArray);\n    } else if (defined(packetData.cartographicRadians)) {\n      packetData.array = packetData.cartographicRadians.map(unpackCartographicRadiansArray);\n    } else if (defined(packetData.cartographicDegrees)) {\n      packetData.array = packetData.cartographicDegrees.map(unpackCartographicDegreesArray);\n    }\n    if (defined(packetData.array)) {\n      processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n    }\n  }\n}\nfunction processPositionArrayOfArrays(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processPositionArrayOfArraysPacketData(object, propertyName, packetData[i], entityCollection);\n    }\n  } else {\n    processPositionArrayOfArraysPacketData(object, propertyName, packetData, entityCollection);\n  }\n}\nfunction processShape(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; i++) {\n      processShapePacketData(object, propertyName, packetData[i], entityCollection);\n    }\n  } else {\n    processShapePacketData(object, propertyName, packetData, entityCollection);\n  }\n}\nfunction processAvailability(entity, packet, entityCollection, sourceUri) {\n  const packetData = packet.availability;\n  if (!defined(packetData)) {\n    return;\n  }\n  let intervals;\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      if (!defined(intervals)) {\n        intervals = new TimeIntervalCollection();\n      }\n      intervals.addInterval(intervalFromString(packetData[i]));\n    }\n  } else {\n    intervals = new TimeIntervalCollection();\n    intervals.addInterval(intervalFromString(packetData));\n  }\n  entity.availability = intervals;\n}\nfunction processAlignedAxis(billboard, packetData, interval, sourceUri, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n  processPacketData(UnitCartesian3, billboard, \"alignedAxis\", packetData, interval, sourceUri, entityCollection);\n}\nfunction processBillboard(entity, packet, entityCollection, sourceUri) {\n  const billboardData = packet.billboard;\n  if (!defined(billboardData)) {\n    return;\n  }\n  const interval = intervalFromString(billboardData.interval);\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    entity.billboard = billboard = new BillboardGraphics();\n  }\n  processPacketData(Boolean, billboard, \"show\", billboardData.show, interval, sourceUri, entityCollection);\n  processPacketData(Image, billboard, \"image\", billboardData.image, interval, sourceUri, entityCollection);\n  processPacketData(Number, billboard, \"scale\", billboardData.scale, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian2, billboard, \"pixelOffset\", billboardData.pixelOffset, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian3, billboard, \"eyeOffset\", billboardData.eyeOffset, interval, sourceUri, entityCollection);\n  processPacketData(HorizontalOrigin, billboard, \"horizontalOrigin\", billboardData.horizontalOrigin, interval, sourceUri, entityCollection);\n  processPacketData(VerticalOrigin, billboard, \"verticalOrigin\", billboardData.verticalOrigin, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, billboard, \"heightReference\", billboardData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Color, billboard, \"color\", billboardData.color, interval, sourceUri, entityCollection);\n  processPacketData(Rotation, billboard, \"rotation\", billboardData.rotation, interval, sourceUri, entityCollection);\n  processAlignedAxis(billboard, billboardData.alignedAxis, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, billboard, \"sizeInMeters\", billboardData.sizeInMeters, interval, sourceUri, entityCollection);\n  processPacketData(Number, billboard, \"width\", billboardData.width, interval, sourceUri, entityCollection);\n  processPacketData(Number, billboard, \"height\", billboardData.height, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, billboard, \"scaleByDistance\", billboardData.scaleByDistance, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, billboard, \"translucencyByDistance\", billboardData.translucencyByDistance, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, billboard, \"pixelOffsetScaleByDistance\", billboardData.pixelOffsetScaleByDistance, interval, sourceUri, entityCollection);\n  processPacketData(BoundingRectangle, billboard, \"imageSubRegion\", billboardData.imageSubRegion, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, billboard, \"distanceDisplayCondition\", billboardData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(Number, billboard, \"disableDepthTestDistance\", billboardData.disableDepthTestDistance, interval, sourceUri, entityCollection);\n}\nfunction processBox(entity, packet, entityCollection, sourceUri) {\n  const boxData = packet.box;\n  if (!defined(boxData)) {\n    return;\n  }\n  const interval = intervalFromString(boxData.interval);\n  let box = entity.box;\n  if (!defined(box)) {\n    entity.box = box = new BoxGraphics();\n  }\n  processPacketData(Boolean, box, \"show\", boxData.show, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian3, box, \"dimensions\", boxData.dimensions, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, box, \"heightReference\", boxData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, box, \"fill\", boxData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(box, \"material\", boxData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, box, \"outline\", boxData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, box, \"outlineColor\", boxData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, box, \"outlineWidth\", boxData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, box, \"shadows\", boxData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, box, \"distanceDisplayCondition\", boxData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n}\nfunction processCorridor(entity, packet, entityCollection, sourceUri) {\n  const corridorData = packet.corridor;\n  if (!defined(corridorData)) {\n    return;\n  }\n  const interval = intervalFromString(corridorData.interval);\n  let corridor = entity.corridor;\n  if (!defined(corridor)) {\n    entity.corridor = corridor = new CorridorGraphics();\n  }\n  processPacketData(Boolean, corridor, \"show\", corridorData.show, interval, sourceUri, entityCollection);\n  processPositionArray(corridor, \"positions\", corridorData.positions, entityCollection);\n  processPacketData(Number, corridor, \"width\", corridorData.width, interval, sourceUri, entityCollection);\n  processPacketData(Number, corridor, \"height\", corridorData.height, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, corridor, \"heightReference\", corridorData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Number, corridor, \"extrudedHeight\", corridorData.extrudedHeight, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, corridor, \"extrudedHeightReference\", corridorData.extrudedHeightReference, interval, sourceUri, entityCollection);\n  processPacketData(CornerType, corridor, \"cornerType\", corridorData.cornerType, interval, sourceUri, entityCollection);\n  processPacketData(Number, corridor, \"granularity\", corridorData.granularity, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, corridor, \"fill\", corridorData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(corridor, \"material\", corridorData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, corridor, \"outline\", corridorData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, corridor, \"outlineColor\", corridorData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, corridor, \"outlineWidth\", corridorData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, corridor, \"shadows\", corridorData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, corridor, \"distanceDisplayCondition\", corridorData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(ClassificationType, corridor, \"classificationType\", corridorData.classificationType, interval, sourceUri, entityCollection);\n  processPacketData(Number, corridor, \"zIndex\", corridorData.zIndex, interval, sourceUri, entityCollection);\n}\nfunction processCylinder(entity, packet, entityCollection, sourceUri) {\n  const cylinderData = packet.cylinder;\n  if (!defined(cylinderData)) {\n    return;\n  }\n  const interval = intervalFromString(cylinderData.interval);\n  let cylinder = entity.cylinder;\n  if (!defined(cylinder)) {\n    entity.cylinder = cylinder = new CylinderGraphics();\n  }\n  processPacketData(Boolean, cylinder, \"show\", cylinderData.show, interval, sourceUri, entityCollection);\n  processPacketData(Number, cylinder, \"length\", cylinderData.length, interval, sourceUri, entityCollection);\n  processPacketData(Number, cylinder, \"topRadius\", cylinderData.topRadius, interval, sourceUri, entityCollection);\n  processPacketData(Number, cylinder, \"bottomRadius\", cylinderData.bottomRadius, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, cylinder, \"heightReference\", cylinderData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, cylinder, \"fill\", cylinderData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(cylinder, \"material\", cylinderData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, cylinder, \"outline\", cylinderData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, cylinder, \"outlineColor\", cylinderData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, cylinder, \"outlineWidth\", cylinderData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(Number, cylinder, \"numberOfVerticalLines\", cylinderData.numberOfVerticalLines, interval, sourceUri, entityCollection);\n  processPacketData(Number, cylinder, \"slices\", cylinderData.slices, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, cylinder, \"shadows\", cylinderData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, cylinder, \"distanceDisplayCondition\", cylinderData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n}\nfunction processDocument(packet, dataSource) {\n  const version = packet.version;\n  if (defined(version)) {\n    if (typeof version === \"string\") {\n      const tokens = version.split(\".\");\n      if (tokens.length === 2) {\n        if (tokens[0] !== \"1\") {\n          throw new RuntimeError(\"Cesium only supports CZML version 1.\");\n        }\n        dataSource._version = version;\n      }\n    }\n  }\n  if (!defined(dataSource._version)) {\n    throw new RuntimeError(\"CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.\");\n  }\n  const documentPacket = dataSource._documentPacket;\n  if (defined(packet.name)) {\n    documentPacket.name = packet.name;\n  }\n  const clockPacket = packet.clock;\n  if (defined(clockPacket)) {\n    const clock = documentPacket.clock;\n    if (!defined(clock)) {\n      documentPacket.clock = {\n        interval: clockPacket.interval,\n        currentTime: clockPacket.currentTime,\n        range: clockPacket.range,\n        step: clockPacket.step,\n        multiplier: clockPacket.multiplier\n      };\n    } else {\n      clock.interval = defaultValue(clockPacket.interval, clock.interval);\n      clock.currentTime = defaultValue(clockPacket.currentTime, clock.currentTime);\n      clock.range = defaultValue(clockPacket.range, clock.range);\n      clock.step = defaultValue(clockPacket.step, clock.step);\n      clock.multiplier = defaultValue(clockPacket.multiplier, clock.multiplier);\n    }\n  }\n}\nfunction processEllipse(entity, packet, entityCollection, sourceUri) {\n  const ellipseData = packet.ellipse;\n  if (!defined(ellipseData)) {\n    return;\n  }\n  const interval = intervalFromString(ellipseData.interval);\n  let ellipse = entity.ellipse;\n  if (!defined(ellipse)) {\n    entity.ellipse = ellipse = new EllipseGraphics();\n  }\n  processPacketData(Boolean, ellipse, \"show\", ellipseData.show, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"semiMajorAxis\", ellipseData.semiMajorAxis, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"semiMinorAxis\", ellipseData.semiMinorAxis, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"height\", ellipseData.height, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, ellipse, \"heightReference\", ellipseData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"extrudedHeight\", ellipseData.extrudedHeight, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, ellipse, \"extrudedHeightReference\", ellipseData.extrudedHeightReference, interval, sourceUri, entityCollection);\n  processPacketData(Rotation, ellipse, \"rotation\", ellipseData.rotation, interval, sourceUri, entityCollection);\n  processPacketData(Rotation, ellipse, \"stRotation\", ellipseData.stRotation, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"granularity\", ellipseData.granularity, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, ellipse, \"fill\", ellipseData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(ellipse, \"material\", ellipseData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, ellipse, \"outline\", ellipseData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, ellipse, \"outlineColor\", ellipseData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"outlineWidth\", ellipseData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"numberOfVerticalLines\", ellipseData.numberOfVerticalLines, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, ellipse, \"shadows\", ellipseData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, ellipse, \"distanceDisplayCondition\", ellipseData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(ClassificationType, ellipse, \"classificationType\", ellipseData.classificationType, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipse, \"zIndex\", ellipseData.zIndex, interval, sourceUri, entityCollection);\n}\nfunction processEllipsoid(entity, packet, entityCollection, sourceUri) {\n  const ellipsoidData = packet.ellipsoid;\n  if (!defined(ellipsoidData)) {\n    return;\n  }\n  const interval = intervalFromString(ellipsoidData.interval);\n  let ellipsoid = entity.ellipsoid;\n  if (!defined(ellipsoid)) {\n    entity.ellipsoid = ellipsoid = new EllipsoidGraphics();\n  }\n  processPacketData(Boolean, ellipsoid, \"show\", ellipsoidData.show, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian3, ellipsoid, \"radii\", ellipsoidData.radii, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian3, ellipsoid, \"innerRadii\", ellipsoidData.innerRadii, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"minimumClock\", ellipsoidData.minimumClock, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"maximumClock\", ellipsoidData.maximumClock, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"minimumCone\", ellipsoidData.minimumCone, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"maximumCone\", ellipsoidData.maximumCone, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, ellipsoid, \"heightReference\", ellipsoidData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, ellipsoid, \"fill\", ellipsoidData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(ellipsoid, \"material\", ellipsoidData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, ellipsoid, \"outline\", ellipsoidData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, ellipsoid, \"outlineColor\", ellipsoidData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"outlineWidth\", ellipsoidData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"stackPartitions\", ellipsoidData.stackPartitions, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"slicePartitions\", ellipsoidData.slicePartitions, interval, sourceUri, entityCollection);\n  processPacketData(Number, ellipsoid, \"subdivisions\", ellipsoidData.subdivisions, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, ellipsoid, \"shadows\", ellipsoidData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, ellipsoid, \"distanceDisplayCondition\", ellipsoidData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n}\nfunction processLabel(entity, packet, entityCollection, sourceUri) {\n  const labelData = packet.label;\n  if (!defined(labelData)) {\n    return;\n  }\n  const interval = intervalFromString(labelData.interval);\n  let label = entity.label;\n  if (!defined(label)) {\n    entity.label = label = new LabelGraphics();\n  }\n  processPacketData(Boolean, label, \"show\", labelData.show, interval, sourceUri, entityCollection);\n  processPacketData(String, label, \"text\", labelData.text, interval, sourceUri, entityCollection);\n  processPacketData(String, label, \"font\", labelData.font, interval, sourceUri, entityCollection);\n  processPacketData(LabelStyle, label, \"style\", labelData.style, interval, sourceUri, entityCollection);\n  processPacketData(Number, label, \"scale\", labelData.scale, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, label, \"showBackground\", labelData.showBackground, interval, sourceUri, entityCollection);\n  processPacketData(Color, label, \"backgroundColor\", labelData.backgroundColor, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian2, label, \"backgroundPadding\", labelData.backgroundPadding, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian2, label, \"pixelOffset\", labelData.pixelOffset, interval, sourceUri, entityCollection);\n  processPacketData(Cartesian3, label, \"eyeOffset\", labelData.eyeOffset, interval, sourceUri, entityCollection);\n  processPacketData(HorizontalOrigin, label, \"horizontalOrigin\", labelData.horizontalOrigin, interval, sourceUri, entityCollection);\n  processPacketData(VerticalOrigin, label, \"verticalOrigin\", labelData.verticalOrigin, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, label, \"heightReference\", labelData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Color, label, \"fillColor\", labelData.fillColor, interval, sourceUri, entityCollection);\n  processPacketData(Color, label, \"outlineColor\", labelData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, label, \"outlineWidth\", labelData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, label, \"translucencyByDistance\", labelData.translucencyByDistance, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, label, \"pixelOffsetScaleByDistance\", labelData.pixelOffsetScaleByDistance, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, label, \"scaleByDistance\", labelData.scaleByDistance, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, label, \"distanceDisplayCondition\", labelData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(Number, label, \"disableDepthTestDistance\", labelData.disableDepthTestDistance, interval, sourceUri, entityCollection);\n}\nfunction processModel(entity, packet, entityCollection, sourceUri) {\n  const modelData = packet.model;\n  if (!defined(modelData)) {\n    return;\n  }\n  const interval = intervalFromString(modelData.interval);\n  let model = entity.model;\n  if (!defined(model)) {\n    entity.model = model = new ModelGraphics();\n  }\n  processPacketData(Boolean, model, \"show\", modelData.show, interval, sourceUri, entityCollection);\n  processPacketData(Uri, model, \"uri\", modelData.gltf, interval, sourceUri, entityCollection);\n  processPacketData(Number, model, \"scale\", modelData.scale, interval, sourceUri, entityCollection);\n  processPacketData(Number, model, \"minimumPixelSize\", modelData.minimumPixelSize, interval, sourceUri, entityCollection);\n  processPacketData(Number, model, \"maximumScale\", modelData.maximumScale, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, model, \"incrementallyLoadTextures\", modelData.incrementallyLoadTextures, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, model, \"runAnimations\", modelData.runAnimations, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, model, \"clampAnimations\", modelData.clampAnimations, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, model, \"shadows\", modelData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, model, \"heightReference\", modelData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Color, model, \"silhouetteColor\", modelData.silhouetteColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, model, \"silhouetteSize\", modelData.silhouetteSize, interval, sourceUri, entityCollection);\n  processPacketData(Color, model, \"color\", modelData.color, interval, sourceUri, entityCollection);\n  processPacketData(ColorBlendMode, model, \"colorBlendMode\", modelData.colorBlendMode, interval, sourceUri, entityCollection);\n  processPacketData(Number, model, \"colorBlendAmount\", modelData.colorBlendAmount, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, model, \"distanceDisplayCondition\", modelData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  let i, len;\n  const nodeTransformationsData = modelData.nodeTransformations;\n  if (defined(nodeTransformationsData)) {\n    if (Array.isArray(nodeTransformationsData)) {\n      for (i = 0, len = nodeTransformationsData.length; i < len; ++i) {\n        processNodeTransformations(model, nodeTransformationsData[i], interval, sourceUri, entityCollection);\n      }\n    } else {\n      processNodeTransformations(model, nodeTransformationsData, interval, sourceUri, entityCollection);\n    }\n  }\n  const articulationsData = modelData.articulations;\n  if (defined(articulationsData)) {\n    if (Array.isArray(articulationsData)) {\n      for (i = 0, len = articulationsData.length; i < len; ++i) {\n        processArticulations(model, articulationsData[i], interval, sourceUri, entityCollection);\n      }\n    } else {\n      processArticulations(model, articulationsData, interval, sourceUri, entityCollection);\n    }\n  }\n}\nfunction processNodeTransformations(model, nodeTransformationsData, constrainedInterval, sourceUri, entityCollection) {\n  let combinedInterval = intervalFromString(nodeTransformationsData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n  let nodeTransformations = model.nodeTransformations;\n  const nodeNames = Object.keys(nodeTransformationsData);\n  for (let i = 0, len = nodeNames.length; i < len; ++i) {\n    const nodeName = nodeNames[i];\n    if (nodeName === \"interval\") {\n      continue;\n    }\n    const nodeTransformationData = nodeTransformationsData[nodeName];\n    if (!defined(nodeTransformationData)) {\n      continue;\n    }\n    if (!defined(nodeTransformations)) {\n      model.nodeTransformations = nodeTransformations = new PropertyBag();\n    }\n    if (!nodeTransformations.hasProperty(nodeName)) {\n      nodeTransformations.addProperty(nodeName);\n    }\n    let nodeTransformation = nodeTransformations[nodeName];\n    if (!defined(nodeTransformation)) {\n      nodeTransformations[nodeName] = nodeTransformation = new NodeTransformationProperty();\n    }\n    processPacketData(Cartesian3, nodeTransformation, \"translation\", nodeTransformationData.translation, combinedInterval, sourceUri, entityCollection);\n    processPacketData(Quaternion, nodeTransformation, \"rotation\", nodeTransformationData.rotation, combinedInterval, sourceUri, entityCollection);\n    processPacketData(Cartesian3, nodeTransformation, \"scale\", nodeTransformationData.scale, combinedInterval, sourceUri, entityCollection);\n  }\n}\nfunction processArticulations(model, articulationsData, constrainedInterval, sourceUri, entityCollection) {\n  let combinedInterval = intervalFromString(articulationsData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n  let articulations = model.articulations;\n  const keys = Object.keys(articulationsData);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const key = keys[i];\n    if (key === \"interval\") {\n      continue;\n    }\n    const articulationStageData = articulationsData[key];\n    if (!defined(articulationStageData)) {\n      continue;\n    }\n    if (!defined(articulations)) {\n      model.articulations = articulations = new PropertyBag();\n    }\n    if (!articulations.hasProperty(key)) {\n      articulations.addProperty(key);\n    }\n    processPacketData(Number, articulations, key, articulationStageData, combinedInterval, sourceUri, entityCollection);\n  }\n}\nfunction processPath(entity, packet, entityCollection, sourceUri) {\n  const pathData = packet.path;\n  if (!defined(pathData)) {\n    return;\n  }\n  const interval = intervalFromString(pathData.interval);\n  let path = entity.path;\n  if (!defined(path)) {\n    entity.path = path = new PathGraphics();\n  }\n  processPacketData(Boolean, path, \"show\", pathData.show, interval, sourceUri, entityCollection);\n  processPacketData(Number, path, \"leadTime\", pathData.leadTime, interval, sourceUri, entityCollection);\n  processPacketData(Number, path, \"trailTime\", pathData.trailTime, interval, sourceUri, entityCollection);\n  processPacketData(Number, path, \"width\", pathData.width, interval, sourceUri, entityCollection);\n  processPacketData(Number, path, \"resolution\", pathData.resolution, interval, sourceUri, entityCollection);\n  processMaterialPacketData(path, \"material\", pathData.material, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, path, \"distanceDisplayCondition\", pathData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n}\nfunction processPoint(entity, packet, entityCollection, sourceUri) {\n  const pointData = packet.point;\n  if (!defined(pointData)) {\n    return;\n  }\n  const interval = intervalFromString(pointData.interval);\n  let point = entity.point;\n  if (!defined(point)) {\n    entity.point = point = new PointGraphics();\n  }\n  processPacketData(Boolean, point, \"show\", pointData.show, interval, sourceUri, entityCollection);\n  processPacketData(Number, point, \"pixelSize\", pointData.pixelSize, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, point, \"heightReference\", pointData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Color, point, \"color\", pointData.color, interval, sourceUri, entityCollection);\n  processPacketData(Color, point, \"outlineColor\", pointData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, point, \"outlineWidth\", pointData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, point, \"scaleByDistance\", pointData.scaleByDistance, interval, sourceUri, entityCollection);\n  processPacketData(NearFarScalar, point, \"translucencyByDistance\", pointData.translucencyByDistance, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, point, \"distanceDisplayCondition\", pointData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(Number, point, \"disableDepthTestDistance\", pointData.disableDepthTestDistance, interval, sourceUri, entityCollection);\n}\nfunction PolygonHierarchyProperty(polygon) {\n  this.polygon = polygon;\n  this._definitionChanged = new Event();\n}\nObject.defineProperties(PolygonHierarchyProperty.prototype, {\n  isConstant: {\n    get: function () {\n      const positions = this.polygon._positions;\n      const holes = this.polygon._holes;\n      return (!defined(positions) || positions.isConstant) && (!defined(holes) || holes.isConstant);\n    }\n  },\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  }\n});\nPolygonHierarchyProperty.prototype.getValue = function (time, result) {\n  let positions;\n  if (defined(this.polygon._positions)) {\n    positions = this.polygon._positions.getValue(time);\n  }\n  let holes;\n  if (defined(this.polygon._holes)) {\n    holes = this.polygon._holes.getValue(time);\n    if (defined(holes)) {\n      holes = holes.map(function (holePositions) {\n        return new PolygonHierarchy(holePositions);\n      });\n    }\n  }\n  if (!defined(result)) {\n    return new PolygonHierarchy(positions, holes);\n  }\n  result.positions = positions;\n  result.holes = holes;\n  return result;\n};\nPolygonHierarchyProperty.prototype.equals = function (other) {\n  return this === other || other instanceof PolygonHierarchyProperty && Property.equals(this.polygon._positions, other.polygon._positions) && Property.equals(this.polygon._holes, other.polygon._holes);\n};\nfunction processPolygon(entity, packet, entityCollection, sourceUri) {\n  const polygonData = packet.polygon;\n  if (!defined(polygonData)) {\n    return;\n  }\n  const interval = intervalFromString(polygonData.interval);\n  let polygon = entity.polygon;\n  if (!defined(polygon)) {\n    entity.polygon = polygon = new PolygonGraphics();\n  }\n  processPacketData(Boolean, polygon, \"show\", polygonData.show, interval, sourceUri, entityCollection);\n\n  // adapt 'position' property producing Cartesian[]\n  // and 'holes' property producing Cartesian[][]\n  // to a single property producing PolygonHierarchy\n  processPositionArray(polygon, \"_positions\", polygonData.positions, entityCollection);\n  processPositionArrayOfArrays(polygon, \"_holes\", polygonData.holes, entityCollection);\n  if (defined(polygon._positions) || defined(polygon._holes)) {\n    polygon.hierarchy = new PolygonHierarchyProperty(polygon);\n  }\n  processPacketData(Number, polygon, \"height\", polygonData.height, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, polygon, \"heightReference\", polygonData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Number, polygon, \"extrudedHeight\", polygonData.extrudedHeight, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, polygon, \"extrudedHeightReference\", polygonData.extrudedHeightReference, interval, sourceUri, entityCollection);\n  processPacketData(Rotation, polygon, \"stRotation\", polygonData.stRotation, interval, sourceUri, entityCollection);\n  processPacketData(Number, polygon, \"granularity\", polygonData.granularity, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polygon, \"fill\", polygonData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(polygon, \"material\", polygonData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polygon, \"outline\", polygonData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, polygon, \"outlineColor\", polygonData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, polygon, \"outlineWidth\", polygonData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polygon, \"perPositionHeight\", polygonData.perPositionHeight, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polygon, \"closeTop\", polygonData.closeTop, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polygon, \"closeBottom\", polygonData.closeBottom, interval, sourceUri, entityCollection);\n  processPacketData(ArcType, polygon, \"arcType\", polygonData.arcType, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, polygon, \"shadows\", polygonData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, polygon, \"distanceDisplayCondition\", polygonData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(ClassificationType, polygon, \"classificationType\", polygonData.classificationType, interval, sourceUri, entityCollection);\n  processPacketData(Number, polygon, \"zIndex\", polygonData.zIndex, interval, sourceUri, entityCollection);\n}\nfunction adaptFollowSurfaceToArcType(followSurface) {\n  return followSurface ? ArcType.GEODESIC : ArcType.NONE;\n}\nfunction processPolyline(entity, packet, entityCollection, sourceUri) {\n  const polylineData = packet.polyline;\n  if (!defined(polylineData)) {\n    return;\n  }\n  const interval = intervalFromString(polylineData.interval);\n  let polyline = entity.polyline;\n  if (!defined(polyline)) {\n    entity.polyline = polyline = new PolylineGraphics();\n  }\n  processPacketData(Boolean, polyline, \"show\", polylineData.show, interval, sourceUri, entityCollection);\n  processPositionArray(polyline, \"positions\", polylineData.positions, entityCollection);\n  processPacketData(Number, polyline, \"width\", polylineData.width, interval, sourceUri, entityCollection);\n  processPacketData(Number, polyline, \"granularity\", polylineData.granularity, interval, sourceUri, entityCollection);\n  processMaterialPacketData(polyline, \"material\", polylineData.material, interval, sourceUri, entityCollection);\n  processMaterialPacketData(polyline, \"depthFailMaterial\", polylineData.depthFailMaterial, interval, sourceUri, entityCollection);\n  processPacketData(ArcType, polyline, \"arcType\", polylineData.arcType, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polyline, \"clampToGround\", polylineData.clampToGround, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, polyline, \"shadows\", polylineData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, polyline, \"distanceDisplayCondition\", polylineData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(ClassificationType, polyline, \"classificationType\", polylineData.classificationType, interval, sourceUri, entityCollection);\n  processPacketData(Number, polyline, \"zIndex\", polylineData.zIndex, interval, sourceUri, entityCollection);\n\n  // for backwards compatibility, adapt CZML followSurface to arcType.\n  if (defined(polylineData.followSurface) && !defined(polylineData.arcType)) {\n    const tempObj = {};\n    processPacketData(Boolean, tempObj, \"followSurface\", polylineData.followSurface, interval, sourceUri, entityCollection);\n    polyline.arcType = createAdapterProperty(tempObj.followSurface, adaptFollowSurfaceToArcType);\n  }\n}\nfunction processPolylineVolume(entity, packet, entityCollection, sourceUri) {\n  const polylineVolumeData = packet.polylineVolume;\n  if (!defined(polylineVolumeData)) {\n    return;\n  }\n  const interval = intervalFromString(polylineVolumeData.interval);\n  let polylineVolume = entity.polylineVolume;\n  if (!defined(polylineVolume)) {\n    entity.polylineVolume = polylineVolume = new PolylineVolumeGraphics();\n  }\n  processPositionArray(polylineVolume, \"positions\", polylineVolumeData.positions, entityCollection);\n  processShape(polylineVolume, \"shape\", polylineVolumeData.shape, entityCollection);\n  processPacketData(Boolean, polylineVolume, \"show\", polylineVolumeData.show, interval, sourceUri, entityCollection);\n  processPacketData(CornerType, polylineVolume, \"cornerType\", polylineVolumeData.cornerType, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polylineVolume, \"fill\", polylineVolumeData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(polylineVolume, \"material\", polylineVolumeData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, polylineVolume, \"outline\", polylineVolumeData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, polylineVolume, \"outlineColor\", polylineVolumeData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, polylineVolume, \"outlineWidth\", polylineVolumeData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(Number, polylineVolume, \"granularity\", polylineVolumeData.granularity, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, polylineVolume, \"shadows\", polylineVolumeData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, polylineVolume, \"distanceDisplayCondition\", polylineVolumeData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n}\nfunction processRectangle(entity, packet, entityCollection, sourceUri) {\n  const rectangleData = packet.rectangle;\n  if (!defined(rectangleData)) {\n    return;\n  }\n  const interval = intervalFromString(rectangleData.interval);\n  let rectangle = entity.rectangle;\n  if (!defined(rectangle)) {\n    entity.rectangle = rectangle = new RectangleGraphics();\n  }\n  processPacketData(Boolean, rectangle, \"show\", rectangleData.show, interval, sourceUri, entityCollection);\n  processPacketData(Rectangle, rectangle, \"coordinates\", rectangleData.coordinates, interval, sourceUri, entityCollection);\n  processPacketData(Number, rectangle, \"height\", rectangleData.height, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, rectangle, \"heightReference\", rectangleData.heightReference, interval, sourceUri, entityCollection);\n  processPacketData(Number, rectangle, \"extrudedHeight\", rectangleData.extrudedHeight, interval, sourceUri, entityCollection);\n  processPacketData(HeightReference, rectangle, \"extrudedHeightReference\", rectangleData.extrudedHeightReference, interval, sourceUri, entityCollection);\n  processPacketData(Rotation, rectangle, \"rotation\", rectangleData.rotation, interval, sourceUri, entityCollection);\n  processPacketData(Rotation, rectangle, \"stRotation\", rectangleData.stRotation, interval, sourceUri, entityCollection);\n  processPacketData(Number, rectangle, \"granularity\", rectangleData.granularity, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, rectangle, \"fill\", rectangleData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(rectangle, \"material\", rectangleData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, rectangle, \"outline\", rectangleData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, rectangle, \"outlineColor\", rectangleData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, rectangle, \"outlineWidth\", rectangleData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, rectangle, \"shadows\", rectangleData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, rectangle, \"distanceDisplayCondition\", rectangleData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n  processPacketData(ClassificationType, rectangle, \"classificationType\", rectangleData.classificationType, interval, sourceUri, entityCollection);\n  processPacketData(Number, rectangle, \"zIndex\", rectangleData.zIndex, interval, sourceUri, entityCollection);\n}\nfunction processTileset(entity, packet, entityCollection, sourceUri) {\n  const tilesetData = packet.tileset;\n  if (!defined(tilesetData)) {\n    return;\n  }\n  const interval = intervalFromString(tilesetData.interval);\n  let tileset = entity.tileset;\n  if (!defined(tileset)) {\n    entity.tileset = tileset = new Cesium3DTilesetGraphics();\n  }\n  processPacketData(Boolean, tileset, \"show\", tilesetData.show, interval, sourceUri, entityCollection);\n  processPacketData(Uri, tileset, \"uri\", tilesetData.uri, interval, sourceUri, entityCollection);\n  processPacketData(Number, tileset, \"maximumScreenSpaceError\", tilesetData.maximumScreenSpaceError, interval, sourceUri, entityCollection);\n}\nfunction processWall(entity, packet, entityCollection, sourceUri) {\n  const wallData = packet.wall;\n  if (!defined(wallData)) {\n    return;\n  }\n  const interval = intervalFromString(wallData.interval);\n  let wall = entity.wall;\n  if (!defined(wall)) {\n    entity.wall = wall = new WallGraphics();\n  }\n  processPacketData(Boolean, wall, \"show\", wallData.show, interval, sourceUri, entityCollection);\n  processPositionArray(wall, \"positions\", wallData.positions, entityCollection);\n  processArray(wall, \"minimumHeights\", wallData.minimumHeights, entityCollection);\n  processArray(wall, \"maximumHeights\", wallData.maximumHeights, entityCollection);\n  processPacketData(Number, wall, \"granularity\", wallData.granularity, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, wall, \"fill\", wallData.fill, interval, sourceUri, entityCollection);\n  processMaterialPacketData(wall, \"material\", wallData.material, interval, sourceUri, entityCollection);\n  processPacketData(Boolean, wall, \"outline\", wallData.outline, interval, sourceUri, entityCollection);\n  processPacketData(Color, wall, \"outlineColor\", wallData.outlineColor, interval, sourceUri, entityCollection);\n  processPacketData(Number, wall, \"outlineWidth\", wallData.outlineWidth, interval, sourceUri, entityCollection);\n  processPacketData(ShadowMode, wall, \"shadows\", wallData.shadows, interval, sourceUri, entityCollection);\n  processPacketData(DistanceDisplayCondition, wall, \"distanceDisplayCondition\", wallData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n}\nfunction processCzmlPacket(packet, entityCollection, updaterFunctions, sourceUri, dataSource) {\n  let objectId = packet.id;\n  if (!defined(objectId)) {\n    objectId = createGuid();\n  }\n  currentId = objectId;\n  if (!defined(dataSource._version) && objectId !== \"document\") {\n    throw new RuntimeError(\"The first CZML packet is required to be the document object.\");\n  }\n  if (packet[\"delete\"] === true) {\n    entityCollection.removeById(objectId);\n  } else if (objectId === \"document\") {\n    processDocument(packet, dataSource);\n  } else {\n    const entity = entityCollection.getOrCreateEntity(objectId);\n    const parentId = packet.parent;\n    if (defined(parentId)) {\n      entity.parent = entityCollection.getOrCreateEntity(parentId);\n    }\n    for (let i = updaterFunctions.length - 1; i > -1; i--) {\n      updaterFunctions[i](entity, packet, entityCollection, sourceUri);\n    }\n  }\n  currentId = undefined;\n}\nfunction updateClock(dataSource) {\n  let clock;\n  const clockPacket = dataSource._documentPacket.clock;\n  if (!defined(clockPacket)) {\n    if (!defined(dataSource._clock)) {\n      const availability = dataSource._entityCollection.computeAvailability();\n      if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {\n        const startTime = availability.start;\n        const stopTime = availability.stop;\n        const totalSeconds = JulianDate.secondsDifference(stopTime, startTime);\n        const multiplier = Math.round(totalSeconds / 120.0);\n        clock = new DataSourceClock();\n        clock.startTime = JulianDate.clone(startTime);\n        clock.stopTime = JulianDate.clone(stopTime);\n        clock.clockRange = ClockRange.LOOP_STOP;\n        clock.multiplier = multiplier;\n        clock.currentTime = JulianDate.clone(startTime);\n        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n        dataSource._clock = clock;\n        return true;\n      }\n    }\n    return false;\n  }\n  if (defined(dataSource._clock)) {\n    clock = dataSource._clock.clone();\n  } else {\n    clock = new DataSourceClock();\n    clock.startTime = Iso8601.MINIMUM_VALUE.clone();\n    clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();\n    clock.currentTime = Iso8601.MINIMUM_VALUE.clone();\n    clock.clockRange = ClockRange.LOOP_STOP;\n    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n    clock.multiplier = 1.0;\n  }\n  const interval = intervalFromString(clockPacket.interval);\n  if (defined(interval)) {\n    clock.startTime = interval.start;\n    clock.stopTime = interval.stop;\n  }\n  if (defined(clockPacket.currentTime)) {\n    clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);\n  }\n  if (defined(clockPacket.range)) {\n    clock.clockRange = defaultValue(ClockRange[clockPacket.range], ClockRange.LOOP_STOP);\n  }\n  if (defined(clockPacket.step)) {\n    clock.clockStep = defaultValue(ClockStep[clockPacket.step], ClockStep.SYSTEM_CLOCK_MULTIPLIER);\n  }\n  if (defined(clockPacket.multiplier)) {\n    clock.multiplier = clockPacket.multiplier;\n  }\n  if (!clock.equals(dataSource._clock)) {\n    dataSource._clock = clock.clone(dataSource._clock);\n    return true;\n  }\n  return false;\n}\nfunction load(dataSource, czml, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(czml)) {\n    throw new DeveloperError(\"czml is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let promise = czml;\n  let sourceUri = options.sourceUri;\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  dataSource._credit = credit;\n\n  // If the czml is a URL\n  if (typeof czml === \"string\" || czml instanceof Resource) {\n    czml = Resource.createIfNeeded(czml);\n    promise = czml.fetchJson();\n    sourceUri = defaultValue(sourceUri, czml.clone());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = czml.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n  sourceUri = Resource.createIfNeeded(sourceUri);\n  DataSource.setLoading(dataSource, true);\n  return Promise.resolve(promise).then(function (czml) {\n    return loadCzml(dataSource, czml, sourceUri, clear);\n  }).catch(function (error) {\n    DataSource.setLoading(dataSource, false);\n    dataSource._error.raiseEvent(dataSource, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n}\nfunction loadCzml(dataSource, czml, sourceUri, clear) {\n  DataSource.setLoading(dataSource, true);\n  const entityCollection = dataSource._entityCollection;\n  if (clear) {\n    dataSource._version = undefined;\n    dataSource._documentPacket = new DocumentPacket();\n    entityCollection.removeAll();\n  }\n  CzmlDataSource._processCzml(czml, entityCollection, sourceUri, undefined, dataSource);\n  let raiseChangedEvent = updateClock(dataSource);\n  const documentPacket = dataSource._documentPacket;\n  if (defined(documentPacket.name) && dataSource._name !== documentPacket.name) {\n    dataSource._name = documentPacket.name;\n    raiseChangedEvent = true;\n  } else if (!defined(dataSource._name) && defined(sourceUri)) {\n    dataSource._name = getFilenameFromUri(sourceUri.getUrlComponent());\n    raiseChangedEvent = true;\n  }\n  DataSource.setLoading(dataSource, false);\n  if (raiseChangedEvent) {\n    dataSource._changed.raiseEvent(dataSource);\n  }\n  return dataSource;\n}\nfunction DocumentPacket() {\n  this.name = undefined;\n  this.clock = undefined;\n}\n\n/**\n * @typedef {object} CzmlDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {Resource|string} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Guide|CZML}.\n * @alias CzmlDataSource\n * @constructor\n *\n * @param {string} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}\n */\nfunction CzmlDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._clock = undefined;\n  this._documentPacket = new DocumentPacket();\n  this._version = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided CZML data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to the new instance once the data is processed.\n */\nCzmlDataSource.load = function (czml, options) {\n  return new CzmlDataSource().load(czml, options);\n};\nObject.defineProperties(CzmlDataSource.prototype, {\n  /**\n   * Gets a human-readable name for this instance.\n   * @memberof CzmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly\n   * defined in the CZML, the combined availability of all objects is returned.  If\n   * only static data exists, this value is undefined.\n   * @memberof CzmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    }\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof CzmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    }\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof CzmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    }\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    }\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof CzmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    }\n  },\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof CzmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    }\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof CzmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  }\n});\n\n/**\n * @callback CzmlDataSource.UpdaterFunction\n *\n * A CZML processing function that adds or updates entities in the provided\n * collection based on the provided CZML packet.\n *\n * @param {Entity} entity\n * @param {object} packet\n * @param {EntityCollection} entityCollection\n * @param {string} sourceUri\n */\n\n/**\n * Gets the array of CZML processing functions.\n * @memberof CzmlDataSource\n * @type {CzmlDataSource.UpdaterFunction[]}\n */\nCzmlDataSource.updaters = [processBillboard, processBox, processCorridor, processCylinder, processEllipse, processEllipsoid, processLabel, processModel, processName, processDescription, processPath, processPoint, processPolygon, processPolyline, processPolylineVolume, processProperties, processRectangle, processPosition, processTileset, processViewFrom, processWall, processOrientation, processAvailability];\n\n/**\n * Add the provided updater to the list of updaters if not already included\n * @private\n * @param {CzmlDataSource.UpdaterFunction} updater\n */\nCzmlDataSource.registerUpdater = function (updater) {\n  if (!CzmlDataSource.updaters.includes(updater)) {\n    CzmlDataSource.updaters.push(updater);\n  }\n};\n\n/**\n * Remove the provided updater from the list of updaters if already included\n * @private\n * @param {CzmlDataSource.UpdaterFunction} updater\n */\nCzmlDataSource.unregisterUpdater = function (updater) {\n  if (CzmlDataSource.updaters.includes(updater)) {\n    const index = CzmlDataSource.updaters.indexOf(updater);\n    CzmlDataSource.updaters.splice(index, 1);\n  }\n};\n\n/**\n * Processes the provided url or CZML object without clearing any existing data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n */\nCzmlDataSource.prototype.process = function (czml, options) {\n  return load(this, czml, options, false);\n};\n\n/**\n * Loads the provided url or CZML object, replacing any existing data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n */\nCzmlDataSource.prototype.load = function (czml, options) {\n  return load(this, czml, options, true);\n};\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nCzmlDataSource.prototype.update = function (time) {\n  return true;\n};\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link Property} from a CZML packet.\n * @function\n *\n * @param {Function} type The constructor function for the property being processed.\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processPacketData = processPacketData;\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link PositionProperty} from a CZML packet.\n * @function\n *\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processPositionPacketData = processPositionPacketData;\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link MaterialProperty} from a CZML packet.\n * @function\n *\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processMaterialPacketData = processMaterialPacketData;\nCzmlDataSource._processCzml = function (czml, entityCollection, sourceUri, updaterFunctions, dataSource) {\n  updaterFunctions = defaultValue(updaterFunctions, CzmlDataSource.updaters);\n  if (Array.isArray(czml)) {\n    for (let i = 0, len = czml.length; i < len; ++i) {\n      processCzmlPacket(czml[i], entityCollection, updaterFunctions, sourceUri, dataSource);\n    }\n  } else {\n    processCzmlPacket(czml, entityCollection, updaterFunctions, sourceUri, dataSource);\n  }\n};\nexport default CzmlDataSource;","map":{"version":3,"names":["ArcType","BoundingRectangle","Cartesian2","Cartesian3","Cartographic","ClockRange","ClockStep","Color","CornerType","Credit","createGuid","defaultValue","defined","DeveloperError","DistanceDisplayCondition","Ellipsoid","Event","ExtrapolationType","getFilenameFromUri","HermitePolynomialApproximation","Iso8601","JulianDate","LagrangePolynomialApproximation","LinearApproximation","CesiumMath","NearFarScalar","PolygonHierarchy","Quaternion","Rectangle","ReferenceFrame","Resource","RuntimeError","Spherical","TimeInterval","TimeIntervalCollection","ClassificationType","ColorBlendMode","HeightReference","HorizontalOrigin","LabelStyle","ShadowMode","VerticalOrigin","Uri","BillboardGraphics","BoxGraphics","CallbackProperty","CheckerboardMaterialProperty","ColorMaterialProperty","CompositeMaterialProperty","CompositePositionProperty","CompositeProperty","ConstantPositionProperty","ConstantProperty","CorridorGraphics","CylinderGraphics","DataSource","DataSourceClock","EllipseGraphics","EllipsoidGraphics","EntityCluster","EntityCollection","GridMaterialProperty","ImageMaterialProperty","LabelGraphics","ModelGraphics","NodeTransformationProperty","PathGraphics","PointGraphics","PolygonGraphics","PolylineArrowMaterialProperty","PolylineDashMaterialProperty","PolylineGlowMaterialProperty","PolylineGraphics","PolylineOutlineMaterialProperty","PolylineVolumeGraphics","PositionPropertyArray","Property","PropertyArray","PropertyBag","RectangleGraphics","ReferenceProperty","Rotation","SampledPositionProperty","SampledProperty","StripeMaterialProperty","StripeOrientation","TimeIntervalCollectionPositionProperty","TimeIntervalCollectionProperty","VelocityOrientationProperty","VelocityVectorProperty","WallGraphics","Cesium3DTilesetGraphics","SensorVolumePortionToDisplay","UnitCartesian3","packedLength","unpack","pack","currentId","createReferenceProperty","entityCollection","referenceString","fromString","createSpecializedProperty","type","packetData","reference","velocityReference","referenceProperty","JSON","stringify","createAdapterProperty","property","adapterFunction","time","result","getValue","isConstant","scratchCartesian","scratchSpherical","scratchCartographic","scratchTimeInterval","scratchQuaternion","unwrapColorInterval","czmlInterval","rgbaf","rgba","undefined","length","byteToFloat","Array","i","unwrapUriInterval","sourceUri","uri","getDerivedResource","url","createIfNeeded","unwrapRectangleInterval","wsen","wsenDegrees","toRadians","convertUnitSphericalToCartesian","unitSpherical","magnitude","clock","cone","fromSpherical","x","y","z","j","convertSphericalToCartesian","spherical","convertCartographicRadiansToCartesian","cartographicRadians","longitude","latitude","height","default","cartographicToCartesian","convertCartographicDegreesToCartesian","cartographicDegrees","unwrapCartesianInterval","cartesian","cartesianVelocity","unitCartesian","normalizePackedCartesianArray","array","startingIndex","normalize","unwrapUnitCartesianInterval","normalizePackedQuaternionArray","unwrapQuaternionInterval","unitQuaternion","getPropertyType","Boolean","Number","String","hasOwnProperty","Object","unwrapInterval","arcType","boundingRectangle","cartesian2","classificationType","colorBlendMode","cornerType","heightReference","horizontalOrigin","Image","fromIso8601","date","labelStyle","number","nearFarScalar","distanceDisplayCondition","object","value","portionToDisplay","shadowMode","shadows","string","stripeOrientation","verticalOrigin","interpolators","HERMITE","LAGRANGE","LINEAR","updateInterpolationSettings","interpolationAlgorithm","interpolationDegree","setInterpolationOptions","forwardExtrapolationType","forwardExtrapolationDuration","backwardExtrapolationType","backwardExtrapolationDuration","iso8601Scratch","iso8601","intervalFromString","intervalString","wrapPropertyInInfiniteInterval","interval","MAXIMUM_INTERVAL","clone","data","convertPropertyToComposite","composite","intervals","addInterval","convertPositionPropertyToComposite","referenceFrame","processProperty","propertyName","constrainedInterval","combinedInterval","intersect","unwrappedInterval","unwrappedIntervalLength","isValue","hasInterval","equals","delete","removePropertyData","isSampled","needsUnpacking","epoch","packetEpoch","addSamplesPackedArray","findInterval","removeSamples","removeInterval","intersection","get","isEmpty","processPacketData","isArray","len","processPositionProperty","numberOfDerivatives","removePositionPropertyData","FIXED","processPositionPacketData","processShapePacketData","references","processReferencesArrayPacketData","unpackArray","processMaterialProperty","existingMaterial","existingInterval","thisIntervals","start","stop","materialData","solidColor","color","grid","cellAlpha","lineCount","lineThickness","lineOffset","image","repeat","transparent","stripe","orientation","evenColor","oddColor","offset","polylineOutline","outlineColor","outlineWidth","polylineGlow","glowPower","taperPower","polylineArrow","polylineDash","gapColor","dashLength","dashPattern","checkerboard","processMaterialPacketData","processName","entity","packet","nameData","name","processDescription","descriptionData","description","processPosition","positionData","position","processViewFrom","viewFromData","viewFrom","processOrientation","orientationData","processProperties","propertiesData","properties","key","hasProperty","addProperty","propertyData","PropertyArrayType","CompositePropertyArrayType","map","processArrayPacketData","processArray","processPositionArrayPacketData","fromRadiansArrayHeights","fromDegreesArrayHeights","processPositionArray","unpackCartesianArray","unpackCartographicRadiansArray","unpackCartographicDegreesArray","processPositionArrayOfArraysPacketData","referenceArray","tempObj","positions","processPositionArrayOfArrays","processShape","processAvailability","availability","processAlignedAxis","billboard","processBillboard","billboardData","show","scale","pixelOffset","eyeOffset","rotation","alignedAxis","sizeInMeters","width","scaleByDistance","translucencyByDistance","pixelOffsetScaleByDistance","imageSubRegion","disableDepthTestDistance","processBox","boxData","box","dimensions","fill","material","outline","processCorridor","corridorData","corridor","extrudedHeight","extrudedHeightReference","granularity","zIndex","processCylinder","cylinderData","cylinder","topRadius","bottomRadius","numberOfVerticalLines","slices","processDocument","dataSource","version","tokens","split","_version","documentPacket","_documentPacket","clockPacket","currentTime","range","step","multiplier","processEllipse","ellipseData","ellipse","semiMajorAxis","semiMinorAxis","stRotation","processEllipsoid","ellipsoidData","ellipsoid","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","processLabel","labelData","label","text","font","style","showBackground","backgroundColor","backgroundPadding","fillColor","processModel","modelData","model","gltf","minimumPixelSize","maximumScale","incrementallyLoadTextures","runAnimations","clampAnimations","silhouetteColor","silhouetteSize","colorBlendAmount","nodeTransformationsData","nodeTransformations","processNodeTransformations","articulationsData","articulations","processArticulations","nodeNames","keys","nodeName","nodeTransformationData","nodeTransformation","translation","articulationStageData","processPath","pathData","path","leadTime","trailTime","resolution","processPoint","pointData","point","pixelSize","PolygonHierarchyProperty","polygon","_definitionChanged","defineProperties","prototype","_positions","holes","_holes","definitionChanged","holePositions","other","processPolygon","polygonData","hierarchy","perPositionHeight","closeTop","closeBottom","adaptFollowSurfaceToArcType","followSurface","GEODESIC","NONE","processPolyline","polylineData","polyline","depthFailMaterial","clampToGround","processPolylineVolume","polylineVolumeData","polylineVolume","shape","processRectangle","rectangleData","rectangle","coordinates","processTileset","tilesetData","tileset","maximumScreenSpaceError","processWall","wallData","wall","minimumHeights","maximumHeights","processCzmlPacket","updaterFunctions","objectId","id","removeById","getOrCreateEntity","parentId","parent","updateClock","_clock","_entityCollection","computeAvailability","MINIMUM_VALUE","startTime","stopTime","totalSeconds","secondsDifference","Math","round","clockRange","LOOP_STOP","clockStep","SYSTEM_CLOCK_MULTIPLIER","MAXIMUM_VALUE","load","czml","options","clear","EMPTY_OBJECT","promise","credit","_credit","fetchJson","resourceCredits","_resourceCredits","credits","push","setLoading","Promise","resolve","then","loadCzml","catch","error","_error","raiseEvent","console","log","reject","DocumentPacket","removeAll","CzmlDataSource","_processCzml","raiseChangedEvent","_name","getUrlComponent","_changed","_isLoading","_loading","_entityCluster","entities","isLoading","changedEvent","errorEvent","loadingEvent","set","clustering","updaters","registerUpdater","updater","includes","unregisterUpdater","index","indexOf","splice","process","update"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/CzmlDataSource.js"],"sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport Color from \"../Core/Color.js\";\nimport CornerType from \"../Core/CornerType.js\";\nimport Credit from \"../Core/Credit.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport HermitePolynomialApproximation from \"../Core/HermitePolynomialApproximation.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LagrangePolynomialApproximation from \"../Core/LagrangePolynomialApproximation.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Spherical from \"../Core/Spherical.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport Uri from \"urijs\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport BoxGraphics from \"./BoxGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport CheckerboardMaterialProperty from \"./CheckerboardMaterialProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport CompositeMaterialProperty from \"./CompositeMaterialProperty.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport CompositeProperty from \"./CompositeProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport CorridorGraphics from \"./CorridorGraphics.js\";\nimport CylinderGraphics from \"./CylinderGraphics.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport EllipseGraphics from \"./EllipseGraphics.js\";\nimport EllipsoidGraphics from \"./EllipsoidGraphics.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport GridMaterialProperty from \"./GridMaterialProperty.js\";\nimport ImageMaterialProperty from \"./ImageMaterialProperty.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport NodeTransformationProperty from \"./NodeTransformationProperty.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PointGraphics from \"./PointGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineArrowMaterialProperty from \"./PolylineArrowMaterialProperty.js\";\nimport PolylineDashMaterialProperty from \"./PolylineDashMaterialProperty.js\";\nimport PolylineGlowMaterialProperty from \"./PolylineGlowMaterialProperty.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PolylineOutlineMaterialProperty from \"./PolylineOutlineMaterialProperty.js\";\nimport PolylineVolumeGraphics from \"./PolylineVolumeGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport Property from \"./Property.js\";\nimport PropertyArray from \"./PropertyArray.js\";\nimport PropertyBag from \"./PropertyBag.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport Rotation from \"./Rotation.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport StripeMaterialProperty from \"./StripeMaterialProperty.js\";\nimport StripeOrientation from \"./StripeOrientation.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport VelocityOrientationProperty from \"./VelocityOrientationProperty.js\";\nimport VelocityVectorProperty from \"./VelocityVectorProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\nimport Cesium3DTilesetGraphics from \"./Cesium3DTilesetGraphics.js\";\nimport SensorVolumePortionToDisplay from \"../Scene/SensorVolumePortionToDisplay.js\";\n\n// A marker type to distinguish CZML properties where we need to end up with a unit vector.\n// The data is still loaded into Cartesian3 objects but they are normalized.\nfunction UnitCartesian3() {}\nUnitCartesian3.packedLength = Cartesian3.packedLength;\nUnitCartesian3.unpack = Cartesian3.unpack;\nUnitCartesian3.pack = Cartesian3.pack;\n\n// As a side note, for the purposes of CZML, Quaternion always indicates a unit quaternion.\n\nlet currentId;\n\nfunction createReferenceProperty(entityCollection, referenceString) {\n  if (referenceString[0] === \"#\") {\n    referenceString = currentId + referenceString;\n  }\n  return ReferenceProperty.fromString(entityCollection, referenceString);\n}\n\nfunction createSpecializedProperty(type, entityCollection, packetData) {\n  if (defined(packetData.reference)) {\n    return createReferenceProperty(entityCollection, packetData.reference);\n  }\n\n  if (defined(packetData.velocityReference)) {\n    const referenceProperty = createReferenceProperty(\n      entityCollection,\n      packetData.velocityReference,\n    );\n    switch (type) {\n      case Cartesian3:\n      case UnitCartesian3:\n        return new VelocityVectorProperty(\n          referenceProperty,\n          type === UnitCartesian3,\n        );\n      case Quaternion:\n        return new VelocityOrientationProperty(referenceProperty);\n    }\n  }\n\n  throw new RuntimeError(`${JSON.stringify(packetData)} is not valid CZML.`);\n}\n\nfunction createAdapterProperty(property, adapterFunction) {\n  return new CallbackProperty(function (time, result) {\n    return adapterFunction(property.getValue(time, result));\n  }, property.isConstant);\n}\n\nconst scratchCartesian = new Cartesian3();\nconst scratchSpherical = new Spherical();\nconst scratchCartographic = new Cartographic();\nconst scratchTimeInterval = new TimeInterval();\nconst scratchQuaternion = new Quaternion();\n\nfunction unwrapColorInterval(czmlInterval) {\n  let rgbaf = czmlInterval.rgbaf;\n  if (defined(rgbaf)) {\n    return rgbaf;\n  }\n\n  const rgba = czmlInterval.rgba;\n  if (!defined(rgba)) {\n    return undefined;\n  }\n\n  const length = rgba.length;\n  if (length === Color.packedLength) {\n    return [\n      Color.byteToFloat(rgba[0]),\n      Color.byteToFloat(rgba[1]),\n      Color.byteToFloat(rgba[2]),\n      Color.byteToFloat(rgba[3]),\n    ];\n  }\n\n  rgbaf = new Array(length);\n  for (let i = 0; i < length; i += 5) {\n    rgbaf[i] = rgba[i];\n    rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);\n    rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);\n    rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);\n    rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);\n  }\n  return rgbaf;\n}\n\nfunction unwrapUriInterval(czmlInterval, sourceUri) {\n  const uri = defaultValue(czmlInterval.uri, czmlInterval);\n  if (defined(sourceUri)) {\n    return sourceUri.getDerivedResource({\n      url: uri,\n    });\n  }\n\n  return Resource.createIfNeeded(uri);\n}\n\nfunction unwrapRectangleInterval(czmlInterval) {\n  let wsen = czmlInterval.wsen;\n  if (defined(wsen)) {\n    return wsen;\n  }\n\n  const wsenDegrees = czmlInterval.wsenDegrees;\n  if (!defined(wsenDegrees)) {\n    return undefined;\n  }\n\n  const length = wsenDegrees.length;\n  if (length === Rectangle.packedLength) {\n    return [\n      CesiumMath.toRadians(wsenDegrees[0]),\n      CesiumMath.toRadians(wsenDegrees[1]),\n      CesiumMath.toRadians(wsenDegrees[2]),\n      CesiumMath.toRadians(wsenDegrees[3]),\n    ];\n  }\n\n  wsen = new Array(length);\n  for (let i = 0; i < length; i += 5) {\n    wsen[i] = wsenDegrees[i];\n    wsen[i + 1] = CesiumMath.toRadians(wsenDegrees[i + 1]);\n    wsen[i + 2] = CesiumMath.toRadians(wsenDegrees[i + 2]);\n    wsen[i + 3] = CesiumMath.toRadians(wsenDegrees[i + 3]);\n    wsen[i + 4] = CesiumMath.toRadians(wsenDegrees[i + 4]);\n  }\n  return wsen;\n}\n\nfunction convertUnitSphericalToCartesian(unitSpherical) {\n  const length = unitSpherical.length;\n  scratchSpherical.magnitude = 1.0;\n  if (length === 2) {\n    scratchSpherical.clock = unitSpherical[0];\n    scratchSpherical.cone = unitSpherical[1];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array((length / 3) * 4);\n  for (let i = 0, j = 0; i < length; i += 3, j += 4) {\n    result[j] = unitSpherical[i];\n\n    scratchSpherical.clock = unitSpherical[i + 1];\n    scratchSpherical.cone = unitSpherical[i + 2];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n\n    result[j + 1] = scratchCartesian.x;\n    result[j + 2] = scratchCartesian.y;\n    result[j + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction convertSphericalToCartesian(spherical) {\n  const length = spherical.length;\n  if (length === 3) {\n    scratchSpherical.clock = spherical[0];\n    scratchSpherical.cone = spherical[1];\n    scratchSpherical.magnitude = spherical[2];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = spherical[i];\n\n    scratchSpherical.clock = spherical[i + 1];\n    scratchSpherical.cone = spherical[i + 2];\n    scratchSpherical.magnitude = spherical[i + 3];\n    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction convertCartographicRadiansToCartesian(cartographicRadians) {\n  const length = cartographicRadians.length;\n  if (length === 3) {\n    scratchCartographic.longitude = cartographicRadians[0];\n    scratchCartographic.latitude = cartographicRadians[1];\n    scratchCartographic.height = cartographicRadians[2];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = cartographicRadians[i];\n\n    scratchCartographic.longitude = cartographicRadians[i + 1];\n    scratchCartographic.latitude = cartographicRadians[i + 2];\n    scratchCartographic.height = cartographicRadians[i + 3];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction convertCartographicDegreesToCartesian(cartographicDegrees) {\n  const length = cartographicDegrees.length;\n  if (length === 3) {\n    scratchCartographic.longitude = CesiumMath.toRadians(\n      cartographicDegrees[0],\n    );\n    scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);\n    scratchCartographic.height = cartographicDegrees[2];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n    return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n  }\n\n  const result = new Array(length);\n  for (let i = 0; i < length; i += 4) {\n    result[i] = cartographicDegrees[i];\n\n    scratchCartographic.longitude = CesiumMath.toRadians(\n      cartographicDegrees[i + 1],\n    );\n    scratchCartographic.latitude = CesiumMath.toRadians(\n      cartographicDegrees[i + 2],\n    );\n    scratchCartographic.height = cartographicDegrees[i + 3];\n    Ellipsoid.default.cartographicToCartesian(\n      scratchCartographic,\n      scratchCartesian,\n    );\n\n    result[i + 1] = scratchCartesian.x;\n    result[i + 2] = scratchCartesian.y;\n    result[i + 3] = scratchCartesian.z;\n  }\n  return result;\n}\n\nfunction unwrapCartesianInterval(czmlInterval) {\n  const cartesian = czmlInterval.cartesian;\n  if (defined(cartesian)) {\n    return cartesian;\n  }\n\n  const cartesianVelocity = czmlInterval.cartesianVelocity;\n  if (defined(cartesianVelocity)) {\n    return cartesianVelocity;\n  }\n\n  const unitCartesian = czmlInterval.unitCartesian;\n  if (defined(unitCartesian)) {\n    return unitCartesian;\n  }\n\n  const unitSpherical = czmlInterval.unitSpherical;\n  if (defined(unitSpherical)) {\n    return convertUnitSphericalToCartesian(unitSpherical);\n  }\n\n  const spherical = czmlInterval.spherical;\n  if (defined(spherical)) {\n    return convertSphericalToCartesian(spherical);\n  }\n\n  const cartographicRadians = czmlInterval.cartographicRadians;\n  if (defined(cartographicRadians)) {\n    return convertCartographicRadiansToCartesian(cartographicRadians);\n  }\n\n  const cartographicDegrees = czmlInterval.cartographicDegrees;\n  if (defined(cartographicDegrees)) {\n    return convertCartographicDegreesToCartesian(cartographicDegrees);\n  }\n\n  throw new RuntimeError(\n    `${JSON.stringify(czmlInterval)} is not a valid CZML interval.`,\n  );\n}\n\nfunction normalizePackedCartesianArray(array, startingIndex) {\n  Cartesian3.unpack(array, startingIndex, scratchCartesian);\n  Cartesian3.normalize(scratchCartesian, scratchCartesian);\n  Cartesian3.pack(scratchCartesian, array, startingIndex);\n}\n\nfunction unwrapUnitCartesianInterval(czmlInterval) {\n  const cartesian = unwrapCartesianInterval(czmlInterval);\n  if (cartesian.length === 3) {\n    normalizePackedCartesianArray(cartesian, 0);\n    return cartesian;\n  }\n\n  for (let i = 1; i < cartesian.length; i += 4) {\n    normalizePackedCartesianArray(cartesian, i);\n  }\n\n  return cartesian;\n}\n\nfunction normalizePackedQuaternionArray(array, startingIndex) {\n  Quaternion.unpack(array, startingIndex, scratchQuaternion);\n  Quaternion.normalize(scratchQuaternion, scratchQuaternion);\n  Quaternion.pack(scratchQuaternion, array, startingIndex);\n}\n\nfunction unwrapQuaternionInterval(czmlInterval) {\n  const unitQuaternion = czmlInterval.unitQuaternion;\n  if (defined(unitQuaternion)) {\n    if (unitQuaternion.length === 4) {\n      normalizePackedQuaternionArray(unitQuaternion, 0);\n      return unitQuaternion;\n    }\n\n    for (let i = 1; i < unitQuaternion.length; i += 5) {\n      normalizePackedQuaternionArray(unitQuaternion, i);\n    }\n  }\n  return unitQuaternion;\n}\n\nfunction getPropertyType(czmlInterval) {\n  // The associations in this function need to be kept in sync with the\n  // associations in unwrapInterval.\n\n  // Intentionally omitted due to conficts in CZML property names:\n  // * Image (conflicts with Uri)\n  // * Rotation (conflicts with Number)\n  //\n  // cartesianVelocity is also omitted due to incomplete support for\n  // derivative information in CZML properties.\n  // (Currently cartesianVelocity is hacked directly into the position processing code)\n  if (typeof czmlInterval === \"boolean\") {\n    return Boolean;\n  } else if (typeof czmlInterval === \"number\") {\n    return Number;\n  } else if (typeof czmlInterval === \"string\") {\n    return String;\n  } else if (czmlInterval.hasOwnProperty(\"array\")) {\n    return Array;\n  } else if (czmlInterval.hasOwnProperty(\"boolean\")) {\n    return Boolean;\n  } else if (czmlInterval.hasOwnProperty(\"boundingRectangle\")) {\n    return BoundingRectangle;\n  } else if (czmlInterval.hasOwnProperty(\"cartesian2\")) {\n    return Cartesian2;\n  } else if (\n    czmlInterval.hasOwnProperty(\"cartesian\") ||\n    czmlInterval.hasOwnProperty(\"spherical\") ||\n    czmlInterval.hasOwnProperty(\"cartographicRadians\") ||\n    czmlInterval.hasOwnProperty(\"cartographicDegrees\")\n  ) {\n    return Cartesian3;\n  } else if (\n    czmlInterval.hasOwnProperty(\"unitCartesian\") ||\n    czmlInterval.hasOwnProperty(\"unitSpherical\")\n  ) {\n    return UnitCartesian3;\n  } else if (\n    czmlInterval.hasOwnProperty(\"rgba\") ||\n    czmlInterval.hasOwnProperty(\"rgbaf\")\n  ) {\n    return Color;\n  } else if (czmlInterval.hasOwnProperty(\"arcType\")) {\n    return ArcType;\n  } else if (czmlInterval.hasOwnProperty(\"classificationType\")) {\n    return ClassificationType;\n  } else if (czmlInterval.hasOwnProperty(\"colorBlendMode\")) {\n    return ColorBlendMode;\n  } else if (czmlInterval.hasOwnProperty(\"cornerType\")) {\n    return CornerType;\n  } else if (czmlInterval.hasOwnProperty(\"heightReference\")) {\n    return HeightReference;\n  } else if (czmlInterval.hasOwnProperty(\"horizontalOrigin\")) {\n    return HorizontalOrigin;\n  } else if (czmlInterval.hasOwnProperty(\"date\")) {\n    return JulianDate;\n  } else if (czmlInterval.hasOwnProperty(\"labelStyle\")) {\n    return LabelStyle;\n  } else if (czmlInterval.hasOwnProperty(\"number\")) {\n    return Number;\n  } else if (czmlInterval.hasOwnProperty(\"nearFarScalar\")) {\n    return NearFarScalar;\n  } else if (czmlInterval.hasOwnProperty(\"distanceDisplayCondition\")) {\n    return DistanceDisplayCondition;\n  } else if (\n    czmlInterval.hasOwnProperty(\"object\") ||\n    czmlInterval.hasOwnProperty(\"value\")\n  ) {\n    return Object;\n  } else if (czmlInterval.hasOwnProperty(\"unitQuaternion\")) {\n    return Quaternion;\n  } else if (czmlInterval.hasOwnProperty(\"shadowMode\")) {\n    return ShadowMode;\n  } else if (czmlInterval.hasOwnProperty(\"string\")) {\n    return String;\n  } else if (czmlInterval.hasOwnProperty(\"stripeOrientation\")) {\n    return StripeOrientation;\n  } else if (\n    czmlInterval.hasOwnProperty(\"wsen\") ||\n    czmlInterval.hasOwnProperty(\"wsenDegrees\")\n  ) {\n    return Rectangle;\n  } else if (czmlInterval.hasOwnProperty(\"uri\")) {\n    return Uri;\n  } else if (czmlInterval.hasOwnProperty(\"verticalOrigin\")) {\n    return VerticalOrigin;\n  }\n  // fallback case\n  return Object;\n}\n\nfunction unwrapInterval(type, czmlInterval, sourceUri) {\n  // The associations in this function need to be kept in sync with the\n  // associations in getPropertyType\n  switch (type) {\n    case ArcType:\n      return ArcType[defaultValue(czmlInterval.arcType, czmlInterval)];\n    case Array:\n      return czmlInterval.array;\n    case Boolean:\n      return defaultValue(czmlInterval[\"boolean\"], czmlInterval);\n    case BoundingRectangle:\n      return czmlInterval.boundingRectangle;\n    case Cartesian2:\n      return czmlInterval.cartesian2;\n    case Cartesian3:\n      return unwrapCartesianInterval(czmlInterval);\n    case UnitCartesian3:\n      return unwrapUnitCartesianInterval(czmlInterval);\n    case Color:\n      return unwrapColorInterval(czmlInterval);\n    case ClassificationType:\n      return ClassificationType[\n        defaultValue(czmlInterval.classificationType, czmlInterval)\n      ];\n    case ColorBlendMode:\n      return ColorBlendMode[\n        defaultValue(czmlInterval.colorBlendMode, czmlInterval)\n      ];\n    case CornerType:\n      return CornerType[defaultValue(czmlInterval.cornerType, czmlInterval)];\n    case HeightReference:\n      return HeightReference[\n        defaultValue(czmlInterval.heightReference, czmlInterval)\n      ];\n    case HorizontalOrigin:\n      return HorizontalOrigin[\n        defaultValue(czmlInterval.horizontalOrigin, czmlInterval)\n      ];\n    case Image:\n      return unwrapUriInterval(czmlInterval, sourceUri);\n    case JulianDate:\n      return JulianDate.fromIso8601(\n        defaultValue(czmlInterval.date, czmlInterval),\n      );\n    case LabelStyle:\n      return LabelStyle[defaultValue(czmlInterval.labelStyle, czmlInterval)];\n    case Number:\n      return defaultValue(czmlInterval.number, czmlInterval);\n    case NearFarScalar:\n      return czmlInterval.nearFarScalar;\n    case DistanceDisplayCondition:\n      return czmlInterval.distanceDisplayCondition;\n    case Object:\n      return defaultValue(\n        defaultValue(czmlInterval.object, czmlInterval.value),\n        czmlInterval,\n      );\n    case Quaternion:\n      return unwrapQuaternionInterval(czmlInterval);\n    case Rotation:\n      return defaultValue(czmlInterval.number, czmlInterval);\n    case SensorVolumePortionToDisplay:\n      return SensorVolumePortionToDisplay[\n        defaultValue(czmlInterval.portionToDisplay, czmlInterval)\n      ];\n    case ShadowMode:\n      return ShadowMode[\n        defaultValue(\n          defaultValue(czmlInterval.shadowMode, czmlInterval.shadows),\n          czmlInterval,\n        )\n      ];\n    case String:\n      return defaultValue(czmlInterval.string, czmlInterval);\n    case StripeOrientation:\n      return StripeOrientation[\n        defaultValue(czmlInterval.stripeOrientation, czmlInterval)\n      ];\n    case Rectangle:\n      return unwrapRectangleInterval(czmlInterval);\n    case Uri:\n      return unwrapUriInterval(czmlInterval, sourceUri);\n    case VerticalOrigin:\n      return VerticalOrigin[\n        defaultValue(czmlInterval.verticalOrigin, czmlInterval)\n      ];\n    default:\n      throw new RuntimeError(`Unknown CzmlDataSource interval type: ${type}`);\n  }\n}\n\nconst interpolators = {\n  HERMITE: HermitePolynomialApproximation,\n  LAGRANGE: LagrangePolynomialApproximation,\n  LINEAR: LinearApproximation,\n};\n\nfunction updateInterpolationSettings(packetData, property) {\n  const interpolationAlgorithm = packetData.interpolationAlgorithm;\n  const interpolationDegree = packetData.interpolationDegree;\n  if (defined(interpolationAlgorithm) || defined(interpolationDegree)) {\n    property.setInterpolationOptions({\n      interpolationAlgorithm: interpolators[interpolationAlgorithm],\n      interpolationDegree: interpolationDegree,\n    });\n  }\n\n  const forwardExtrapolationType = packetData.forwardExtrapolationType;\n  if (defined(forwardExtrapolationType)) {\n    property.forwardExtrapolationType =\n      ExtrapolationType[forwardExtrapolationType];\n  }\n\n  const forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;\n  if (defined(forwardExtrapolationDuration)) {\n    property.forwardExtrapolationDuration = forwardExtrapolationDuration;\n  }\n\n  const backwardExtrapolationType = packetData.backwardExtrapolationType;\n  if (defined(backwardExtrapolationType)) {\n    property.backwardExtrapolationType =\n      ExtrapolationType[backwardExtrapolationType];\n  }\n\n  const backwardExtrapolationDuration =\n    packetData.backwardExtrapolationDuration;\n  if (defined(backwardExtrapolationDuration)) {\n    property.backwardExtrapolationDuration = backwardExtrapolationDuration;\n  }\n}\n\nconst iso8601Scratch = {\n  iso8601: undefined,\n};\n\nfunction intervalFromString(intervalString) {\n  if (!defined(intervalString)) {\n    return undefined;\n  }\n  iso8601Scratch.iso8601 = intervalString;\n  return TimeInterval.fromIso8601(iso8601Scratch);\n}\n\nfunction wrapPropertyInInfiniteInterval(property) {\n  const interval = Iso8601.MAXIMUM_INTERVAL.clone();\n  interval.data = property;\n  return interval;\n}\n\nfunction convertPropertyToComposite(property) {\n  // Create the composite and add the old property, wrapped in an infinite interval.\n  const composite = new CompositeProperty();\n  composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n  return composite;\n}\n\nfunction convertPositionPropertyToComposite(property) {\n  // Create the composite and add the old property, wrapped in an infinite interval.\n  const composite = new CompositePositionProperty(property.referenceFrame);\n  composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n  return composite;\n}\n\nfunction processProperty(\n  type,\n  object,\n  propertyName,\n  packetData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let packedLength;\n  let unwrappedInterval;\n  let unwrappedIntervalLength;\n\n  // CZML properties can be defined in many ways.  Most ways represent a structure for\n  // encoding a single value (number, string, cartesian, etc.)  Regardless of the value type,\n  // if it encodes a single value it will get loaded into a ConstantProperty eventually.\n  // Alternatively, there are ways of defining a property that require specialized\n  // client-side representation. Currently, these are ReferenceProperty,\n  // and client-side velocity computation properties such as VelocityVectorProperty.\n  const isValue =\n    !defined(packetData.reference) && !defined(packetData.velocityReference);\n  const hasInterval =\n    defined(combinedInterval) &&\n    !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n\n  if (packetData.delete === true) {\n    // If deleting this property for all time, we can simply set to undefined and return.\n    if (!hasInterval) {\n      object[propertyName] = undefined;\n      return;\n    }\n\n    // Deleting depends on the type of property we have.\n    return removePropertyData(object[propertyName], combinedInterval);\n  }\n\n  let isSampled = false;\n\n  if (isValue) {\n    unwrappedInterval = unwrapInterval(type, packetData, sourceUri);\n    if (!defined(unwrappedInterval)) {\n      // not a known value type, bail\n      return;\n    }\n    packedLength = defaultValue(type.packedLength, 1);\n    unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);\n    isSampled =\n      !defined(packetData.array) &&\n      typeof unwrappedInterval !== \"string\" &&\n      unwrappedIntervalLength > packedLength &&\n      type !== Object;\n  }\n\n  // Rotation is a special case because it represents a native type (Number)\n  // and therefore does not need to be unpacked when loaded as a constant value.\n  const needsUnpacking = typeof type.unpack === \"function\" && type !== Rotation;\n\n  // Any time a constant value is assigned, it completely blows away anything else.\n  if (!isSampled && !hasInterval) {\n    if (isValue) {\n      object[propertyName] = new ConstantProperty(\n        needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval,\n      );\n    } else {\n      object[propertyName] = createSpecializedProperty(\n        type,\n        entityCollection,\n        packetData,\n      );\n    }\n    return;\n  }\n\n  let property = object[propertyName];\n\n  let epoch;\n  const packetEpoch = packetData.epoch;\n  if (defined(packetEpoch)) {\n    epoch = JulianDate.fromIso8601(packetEpoch);\n  }\n\n  // Without an interval, any sampled value is infinite, meaning it completely\n  // replaces any non-sampled property that may exist.\n  if (isSampled && !hasInterval) {\n    if (!(property instanceof SampledProperty)) {\n      object[propertyName] = property = new SampledProperty(type);\n    }\n    property.addSamplesPackedArray(unwrappedInterval, epoch);\n    updateInterpolationSettings(packetData, property);\n    return;\n  }\n\n  let interval;\n\n  // A constant value with an interval is normally part of a TimeIntervalCollection,\n  // However, if the current property is not a time-interval collection, we need\n  // to turn it into a Composite, preserving the old data with the new interval.\n  if (!isSampled && hasInterval) {\n    // Create a new interval for the constant value.\n    combinedInterval = combinedInterval.clone();\n    if (isValue) {\n      combinedInterval.data = needsUnpacking\n        ? type.unpack(unwrappedInterval, 0)\n        : unwrappedInterval;\n    } else {\n      combinedInterval.data = createSpecializedProperty(\n        type,\n        entityCollection,\n        packetData,\n      );\n    }\n\n    // If no property exists, simply use a new interval collection\n    if (!defined(property)) {\n      object[propertyName] = property = isValue\n        ? new TimeIntervalCollectionProperty()\n        : new CompositeProperty();\n    }\n\n    if (isValue && property instanceof TimeIntervalCollectionProperty) {\n      // If we created a collection, or it already was one, use it.\n      property.intervals.addInterval(combinedInterval);\n    } else if (property instanceof CompositeProperty) {\n      // If the collection was already a CompositeProperty, use it.\n      if (isValue) {\n        combinedInterval.data = new ConstantProperty(combinedInterval.data);\n      }\n      property.intervals.addInterval(combinedInterval);\n    } else {\n      // Otherwise, create a CompositeProperty but preserve the existing data.\n      object[propertyName] = property = convertPropertyToComposite(property);\n\n      // Change the new data to a ConstantProperty and add it.\n      if (isValue) {\n        combinedInterval.data = new ConstantProperty(combinedInterval.data);\n      }\n      property.intervals.addInterval(combinedInterval);\n    }\n\n    return;\n  }\n\n  // isSampled && hasInterval\n  if (!defined(property)) {\n    object[propertyName] = property = new CompositeProperty();\n  }\n\n  // Create a CompositeProperty but preserve the existing data.\n  if (!(property instanceof CompositeProperty)) {\n    object[propertyName] = property = convertPropertyToComposite(property);\n  }\n\n  // Check if the interval already exists in the composite.\n  const intervals = property.intervals;\n  interval = intervals.findInterval(combinedInterval);\n  if (!defined(interval) || !(interval.data instanceof SampledProperty)) {\n    // If not, create a SampledProperty for it.\n    interval = combinedInterval.clone();\n    interval.data = new SampledProperty(type);\n    intervals.addInterval(interval);\n  }\n  interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n  updateInterpolationSettings(packetData, interval.data);\n}\n\nfunction removePropertyData(property, interval) {\n  if (property instanceof SampledProperty) {\n    property.removeSamples(interval);\n    return;\n  } else if (property instanceof TimeIntervalCollectionProperty) {\n    property.intervals.removeInterval(interval);\n    return;\n  } else if (property instanceof CompositeProperty) {\n    const intervals = property.intervals;\n    for (let i = 0; i < intervals.length; ++i) {\n      const intersection = TimeInterval.intersect(\n        intervals.get(i),\n        interval,\n        scratchTimeInterval,\n      );\n      if (!intersection.isEmpty) {\n        // remove data from the contained properties\n        removePropertyData(intersection.data, interval);\n      }\n    }\n    // remove the intervals from the composite\n    intervals.removeInterval(interval);\n    return;\n  }\n}\n\nfunction processPacketData(\n  type,\n  object,\n  propertyName,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processProperty(\n        type,\n        object,\n        propertyName,\n        packetData[i],\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  } else {\n    processProperty(\n      type,\n      object,\n      propertyName,\n      packetData,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processPositionProperty(\n  object,\n  propertyName,\n  packetData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  const numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;\n  const packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);\n  let unwrappedInterval;\n  let unwrappedIntervalLength;\n  const isValue = !defined(packetData.reference);\n  const hasInterval =\n    defined(combinedInterval) &&\n    !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n\n  if (packetData.delete === true) {\n    // If deleting this property for all time, we can simply set to undefined and return.\n    if (!hasInterval) {\n      object[propertyName] = undefined;\n      return;\n    }\n\n    // Deleting depends on the type of property we have.\n    return removePositionPropertyData(object[propertyName], combinedInterval);\n  }\n\n  let referenceFrame;\n  let isSampled = false;\n\n  if (isValue) {\n    if (defined(packetData.referenceFrame)) {\n      referenceFrame = ReferenceFrame[packetData.referenceFrame];\n    }\n    referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n    unwrappedInterval = unwrapCartesianInterval(packetData);\n    unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);\n    isSampled = unwrappedIntervalLength > packedLength;\n  }\n\n  // Any time a constant value is assigned, it completely blows away anything else.\n  if (!isSampled && !hasInterval) {\n    if (isValue) {\n      object[propertyName] = new ConstantPositionProperty(\n        Cartesian3.unpack(unwrappedInterval),\n        referenceFrame,\n      );\n    } else {\n      object[propertyName] = createReferenceProperty(\n        entityCollection,\n        packetData.reference,\n      );\n    }\n    return;\n  }\n\n  let property = object[propertyName];\n\n  let epoch;\n  const packetEpoch = packetData.epoch;\n  if (defined(packetEpoch)) {\n    epoch = JulianDate.fromIso8601(packetEpoch);\n  }\n\n  // Without an interval, any sampled value is infinite, meaning it completely\n  // replaces any non-sampled property that may exist.\n  if (isSampled && !hasInterval) {\n    if (\n      !(property instanceof SampledPositionProperty) ||\n      (defined(referenceFrame) && property.referenceFrame !== referenceFrame)\n    ) {\n      object[propertyName] = property = new SampledPositionProperty(\n        referenceFrame,\n        numberOfDerivatives,\n      );\n    }\n    property.addSamplesPackedArray(unwrappedInterval, epoch);\n    updateInterpolationSettings(packetData, property);\n    return;\n  }\n\n  let interval;\n\n  // A constant value with an interval is normally part of a TimeIntervalCollection,\n  // However, if the current property is not a time-interval collection, we need\n  // to turn it into a Composite, preserving the old data with the new interval.\n  if (!isSampled && hasInterval) {\n    // Create a new interval for the constant value.\n    combinedInterval = combinedInterval.clone();\n    if (isValue) {\n      combinedInterval.data = Cartesian3.unpack(unwrappedInterval);\n    } else {\n      combinedInterval.data = createReferenceProperty(\n        entityCollection,\n        packetData.reference,\n      );\n    }\n\n    // If no property exists, simply use a new interval collection\n    if (!defined(property)) {\n      if (isValue) {\n        property = new TimeIntervalCollectionPositionProperty(referenceFrame);\n      } else {\n        property = new CompositePositionProperty(referenceFrame);\n      }\n      object[propertyName] = property;\n    }\n\n    if (\n      isValue &&\n      property instanceof TimeIntervalCollectionPositionProperty &&\n      defined(referenceFrame) &&\n      property.referenceFrame === referenceFrame\n    ) {\n      // If we create a collection, or it already existed, use it.\n      property.intervals.addInterval(combinedInterval);\n    } else if (property instanceof CompositePositionProperty) {\n      // If the collection was already a CompositePositionProperty, use it.\n      if (isValue) {\n        combinedInterval.data = new ConstantPositionProperty(\n          combinedInterval.data,\n          referenceFrame,\n        );\n      }\n      property.intervals.addInterval(combinedInterval);\n    } else {\n      // Otherwise, create a CompositePositionProperty but preserve the existing data.\n      object[propertyName] = property =\n        convertPositionPropertyToComposite(property);\n\n      // Change the new data to a ConstantPositionProperty and add it.\n      if (isValue) {\n        combinedInterval.data = new ConstantPositionProperty(\n          combinedInterval.data,\n          referenceFrame,\n        );\n      }\n      property.intervals.addInterval(combinedInterval);\n    }\n\n    return;\n  }\n\n  // isSampled && hasInterval\n  if (!defined(property)) {\n    object[propertyName] = property = new CompositePositionProperty(\n      referenceFrame,\n    );\n  } else if (!(property instanceof CompositePositionProperty)) {\n    // Create a CompositeProperty but preserve the existing data.\n    object[propertyName] = property =\n      convertPositionPropertyToComposite(property);\n  }\n\n  // Check if the interval already exists in the composite.\n  const intervals = property.intervals;\n  interval = intervals.findInterval(combinedInterval);\n  if (\n    !defined(interval) ||\n    !(interval.data instanceof SampledPositionProperty) ||\n    (defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame)\n  ) {\n    // If not, create a SampledPositionProperty for it.\n    interval = combinedInterval.clone();\n    interval.data = new SampledPositionProperty(\n      referenceFrame,\n      numberOfDerivatives,\n    );\n    intervals.addInterval(interval);\n  }\n  interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n  updateInterpolationSettings(packetData, interval.data);\n}\n\nfunction removePositionPropertyData(property, interval) {\n  if (property instanceof SampledPositionProperty) {\n    property.removeSamples(interval);\n    return;\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    property.intervals.removeInterval(interval);\n    return;\n  } else if (property instanceof CompositePositionProperty) {\n    const intervals = property.intervals;\n    for (let i = 0; i < intervals.length; ++i) {\n      const intersection = TimeInterval.intersect(\n        intervals.get(i),\n        interval,\n        scratchTimeInterval,\n      );\n      if (!intersection.isEmpty) {\n        // remove data from the contained properties\n        removePositionPropertyData(intersection.data, interval);\n      }\n    }\n    // remove the intervals from the composite\n    intervals.removeInterval(interval);\n    return;\n  }\n}\n\nfunction processPositionPacketData(\n  object,\n  propertyName,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processPositionProperty(\n        object,\n        propertyName,\n        packetData[i],\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  } else {\n    processPositionProperty(\n      object,\n      propertyName,\n      packetData,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processShapePacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  if (defined(packetData.references)) {\n    processReferencesArrayPacketData(\n      object,\n      propertyName,\n      packetData.references,\n      packetData.interval,\n      entityCollection,\n      PropertyArray,\n      CompositeProperty,\n    );\n  } else {\n    if (defined(packetData.cartesian2)) {\n      packetData.array = Cartesian2.unpackArray(packetData.cartesian2);\n    } else if (defined(packetData.cartesian)) {\n      // for backwards compatibility, also accept `cartesian`\n      packetData.array = Cartesian2.unpackArray(packetData.cartesian);\n    }\n\n    if (defined(packetData.array)) {\n      processPacketData(\n        Array,\n        object,\n        propertyName,\n        packetData,\n        undefined,\n        undefined,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processMaterialProperty(\n  object,\n  propertyName,\n  packetData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(packetData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let property = object[propertyName];\n  let existingMaterial;\n  let existingInterval;\n\n  if (defined(combinedInterval)) {\n    if (!(property instanceof CompositeMaterialProperty)) {\n      property = new CompositeMaterialProperty();\n      object[propertyName] = property;\n    }\n    //See if we already have data at that interval.\n    const thisIntervals = property.intervals;\n    existingInterval = thisIntervals.findInterval({\n      start: combinedInterval.start,\n      stop: combinedInterval.stop,\n    });\n    if (defined(existingInterval)) {\n      //We have an interval, but we need to make sure the\n      //new data is the same type of material as the old data.\n      existingMaterial = existingInterval.data;\n    } else {\n      //If not, create it.\n      existingInterval = combinedInterval.clone();\n      thisIntervals.addInterval(existingInterval);\n    }\n  } else {\n    existingMaterial = property;\n  }\n\n  let materialData;\n  if (defined(packetData.solidColor)) {\n    if (!(existingMaterial instanceof ColorMaterialProperty)) {\n      existingMaterial = new ColorMaterialProperty();\n    }\n    materialData = packetData.solidColor;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n  } else if (defined(packetData.grid)) {\n    if (!(existingMaterial instanceof GridMaterialProperty)) {\n      existingMaterial = new GridMaterialProperty();\n    }\n    materialData = packetData.grid;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"cellAlpha\",\n      materialData.cellAlpha,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"lineCount\",\n      materialData.lineCount,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"lineThickness\",\n      materialData.lineThickness,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"lineOffset\",\n      materialData.lineOffset,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.image)) {\n    if (!(existingMaterial instanceof ImageMaterialProperty)) {\n      existingMaterial = new ImageMaterialProperty();\n    }\n    materialData = packetData.image;\n    processPacketData(\n      Image,\n      existingMaterial,\n      \"image\",\n      materialData.image,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"repeat\",\n      materialData.repeat,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Boolean,\n      existingMaterial,\n      \"transparent\",\n      materialData.transparent,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.stripe)) {\n    if (!(existingMaterial instanceof StripeMaterialProperty)) {\n      existingMaterial = new StripeMaterialProperty();\n    }\n    materialData = packetData.stripe;\n    processPacketData(\n      StripeOrientation,\n      existingMaterial,\n      \"orientation\",\n      materialData.orientation,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"evenColor\",\n      materialData.evenColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"oddColor\",\n      materialData.oddColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"offset\",\n      materialData.offset,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"repeat\",\n      materialData.repeat,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineOutline)) {\n    if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {\n      existingMaterial = new PolylineOutlineMaterialProperty();\n    }\n    materialData = packetData.polylineOutline;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"outlineColor\",\n      materialData.outlineColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"outlineWidth\",\n      materialData.outlineWidth,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineGlow)) {\n    if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {\n      existingMaterial = new PolylineGlowMaterialProperty();\n    }\n    materialData = packetData.polylineGlow;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"glowPower\",\n      materialData.glowPower,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"taperPower\",\n      materialData.taperPower,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineArrow)) {\n    if (!(existingMaterial instanceof PolylineArrowMaterialProperty)) {\n      existingMaterial = new PolylineArrowMaterialProperty();\n    }\n    materialData = packetData.polylineArrow;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n  } else if (defined(packetData.polylineDash)) {\n    if (!(existingMaterial instanceof PolylineDashMaterialProperty)) {\n      existingMaterial = new PolylineDashMaterialProperty();\n    }\n    materialData = packetData.polylineDash;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"color\",\n      materialData.color,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"gapColor\",\n      materialData.gapColor,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"dashLength\",\n      materialData.dashLength,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Number,\n      existingMaterial,\n      \"dashPattern\",\n      materialData.dashPattern,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  } else if (defined(packetData.checkerboard)) {\n    if (!(existingMaterial instanceof CheckerboardMaterialProperty)) {\n      existingMaterial = new CheckerboardMaterialProperty();\n    }\n    materialData = packetData.checkerboard;\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"evenColor\",\n      materialData.evenColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Color,\n      existingMaterial,\n      \"oddColor\",\n      materialData.oddColor,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian2,\n      existingMaterial,\n      \"repeat\",\n      materialData.repeat,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n\n  if (defined(existingInterval)) {\n    existingInterval.data = existingMaterial;\n  } else {\n    object[propertyName] = existingMaterial;\n  }\n}\n\nfunction processMaterialPacketData(\n  object,\n  propertyName,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      processMaterialProperty(\n        object,\n        propertyName,\n        packetData[i],\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  } else {\n    processMaterialProperty(\n      object,\n      propertyName,\n      packetData,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processName(entity, packet, entityCollection, sourceUri) {\n  const nameData = packet.name;\n  if (defined(nameData)) {\n    entity.name = packet.name;\n  }\n}\n\nfunction processDescription(entity, packet, entityCollection, sourceUri) {\n  const descriptionData = packet.description;\n  if (defined(descriptionData)) {\n    processPacketData(\n      String,\n      entity,\n      \"description\",\n      descriptionData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processPosition(entity, packet, entityCollection, sourceUri) {\n  const positionData = packet.position;\n  if (defined(positionData)) {\n    processPositionPacketData(\n      entity,\n      \"position\",\n      positionData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processViewFrom(entity, packet, entityCollection, sourceUri) {\n  const viewFromData = packet.viewFrom;\n  if (defined(viewFromData)) {\n    processPacketData(\n      Cartesian3,\n      entity,\n      \"viewFrom\",\n      viewFromData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processOrientation(entity, packet, entityCollection, sourceUri) {\n  const orientationData = packet.orientation;\n  if (defined(orientationData)) {\n    processPacketData(\n      Quaternion,\n      entity,\n      \"orientation\",\n      orientationData,\n      undefined,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processProperties(entity, packet, entityCollection, sourceUri) {\n  const propertiesData = packet.properties;\n  if (defined(propertiesData)) {\n    if (!defined(entity.properties)) {\n      entity.properties = new PropertyBag();\n    }\n\n    // We cannot simply call processPacketData(entity, 'properties', propertyData, undefined, sourceUri, entityCollection)\n    // because each property of \"properties\" may vary separately.\n    // The properties will be accessible as entity.properties.myprop.getValue(time).\n\n    for (const key in propertiesData) {\n      if (propertiesData.hasOwnProperty(key)) {\n        if (!entity.properties.hasProperty(key)) {\n          entity.properties.addProperty(key);\n        }\n\n        const propertyData = propertiesData[key];\n        if (Array.isArray(propertyData)) {\n          for (let i = 0, len = propertyData.length; i < len; ++i) {\n            processProperty(\n              getPropertyType(propertyData[i]),\n              entity.properties,\n              key,\n              propertyData[i],\n              undefined,\n              sourceUri,\n              entityCollection,\n            );\n          }\n        } else {\n          processProperty(\n            getPropertyType(propertyData),\n            entity.properties,\n            key,\n            propertyData,\n            undefined,\n            sourceUri,\n            entityCollection,\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction processReferencesArrayPacketData(\n  object,\n  propertyName,\n  references,\n  interval,\n  entityCollection,\n  PropertyArrayType,\n  CompositePropertyArrayType,\n) {\n  const properties = references.map(function (reference) {\n    return createReferenceProperty(entityCollection, reference);\n  });\n\n  if (defined(interval)) {\n    interval = intervalFromString(interval);\n    let property = object[propertyName];\n    if (!(property instanceof CompositePropertyArrayType)) {\n      // If the property was not already a CompositeProperty,\n      // create a CompositeProperty but preserve the existing data.\n\n      // Create the composite and add the old property, wrapped in an infinite interval.\n      const composite = new CompositePropertyArrayType();\n      composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n\n      object[propertyName] = property = composite;\n    }\n\n    interval.data = new PropertyArrayType(properties);\n    property.intervals.addInterval(interval);\n  } else {\n    object[propertyName] = new PropertyArrayType(properties);\n  }\n}\n\nfunction processArrayPacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  const references = packetData.references;\n  if (defined(references)) {\n    processReferencesArrayPacketData(\n      object,\n      propertyName,\n      references,\n      packetData.interval,\n      entityCollection,\n      PropertyArray,\n      CompositeProperty,\n    );\n  } else {\n    processPacketData(\n      Array,\n      object,\n      propertyName,\n      packetData,\n      undefined,\n      undefined,\n      entityCollection,\n    );\n  }\n}\n\nfunction processArray(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processArrayPacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processArrayPacketData(object, propertyName, packetData, entityCollection);\n  }\n}\n\nfunction processPositionArrayPacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  const references = packetData.references;\n  if (defined(references)) {\n    processReferencesArrayPacketData(\n      object,\n      propertyName,\n      references,\n      packetData.interval,\n      entityCollection,\n      PositionPropertyArray,\n      CompositePositionProperty,\n    );\n  } else {\n    if (defined(packetData.cartesian)) {\n      packetData.array = Cartesian3.unpackArray(packetData.cartesian);\n    } else if (defined(packetData.cartographicRadians)) {\n      packetData.array = Cartesian3.fromRadiansArrayHeights(\n        packetData.cartographicRadians,\n        Ellipsoid.default,\n      );\n    } else if (defined(packetData.cartographicDegrees)) {\n      packetData.array = Cartesian3.fromDegreesArrayHeights(\n        packetData.cartographicDegrees,\n        Ellipsoid.default,\n      );\n    }\n\n    if (defined(packetData.array)) {\n      processPacketData(\n        Array,\n        object,\n        propertyName,\n        packetData,\n        undefined,\n        undefined,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processPositionArray(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processPositionArrayPacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processPositionArrayPacketData(\n      object,\n      propertyName,\n      packetData,\n      entityCollection,\n    );\n  }\n}\n\nfunction unpackCartesianArray(array) {\n  return Cartesian3.unpackArray(array);\n}\n\nfunction unpackCartographicRadiansArray(array) {\n  return Cartesian3.fromRadiansArrayHeights(array, Ellipsoid.default);\n}\n\nfunction unpackCartographicDegreesArray(array) {\n  return Cartesian3.fromDegreesArrayHeights(array, Ellipsoid.default);\n}\n\nfunction processPositionArrayOfArraysPacketData(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  const references = packetData.references;\n  if (defined(references)) {\n    const properties = references.map(function (referenceArray) {\n      const tempObj = {};\n      processReferencesArrayPacketData(\n        tempObj,\n        \"positions\",\n        referenceArray,\n        packetData.interval,\n        entityCollection,\n        PositionPropertyArray,\n        CompositePositionProperty,\n      );\n      return tempObj.positions;\n    });\n    object[propertyName] = new PositionPropertyArray(properties);\n  } else {\n    if (defined(packetData.cartesian)) {\n      packetData.array = packetData.cartesian.map(unpackCartesianArray);\n    } else if (defined(packetData.cartographicRadians)) {\n      packetData.array = packetData.cartographicRadians.map(\n        unpackCartographicRadiansArray,\n      );\n    } else if (defined(packetData.cartographicDegrees)) {\n      packetData.array = packetData.cartographicDegrees.map(\n        unpackCartographicDegreesArray,\n      );\n    }\n\n    if (defined(packetData.array)) {\n      processPacketData(\n        Array,\n        object,\n        propertyName,\n        packetData,\n        undefined,\n        undefined,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processPositionArrayOfArrays(\n  object,\n  propertyName,\n  packetData,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; ++i) {\n      processPositionArrayOfArraysPacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processPositionArrayOfArraysPacketData(\n      object,\n      propertyName,\n      packetData,\n      entityCollection,\n    );\n  }\n}\n\nfunction processShape(object, propertyName, packetData, entityCollection) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  if (Array.isArray(packetData)) {\n    for (let i = 0, length = packetData.length; i < length; i++) {\n      processShapePacketData(\n        object,\n        propertyName,\n        packetData[i],\n        entityCollection,\n      );\n    }\n  } else {\n    processShapePacketData(object, propertyName, packetData, entityCollection);\n  }\n}\n\nfunction processAvailability(entity, packet, entityCollection, sourceUri) {\n  const packetData = packet.availability;\n  if (!defined(packetData)) {\n    return;\n  }\n\n  let intervals;\n  if (Array.isArray(packetData)) {\n    for (let i = 0, len = packetData.length; i < len; ++i) {\n      if (!defined(intervals)) {\n        intervals = new TimeIntervalCollection();\n      }\n      intervals.addInterval(intervalFromString(packetData[i]));\n    }\n  } else {\n    intervals = new TimeIntervalCollection();\n    intervals.addInterval(intervalFromString(packetData));\n  }\n  entity.availability = intervals;\n}\n\nfunction processAlignedAxis(\n  billboard,\n  packetData,\n  interval,\n  sourceUri,\n  entityCollection,\n) {\n  if (!defined(packetData)) {\n    return;\n  }\n\n  processPacketData(\n    UnitCartesian3,\n    billboard,\n    \"alignedAxis\",\n    packetData,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processBillboard(entity, packet, entityCollection, sourceUri) {\n  const billboardData = packet.billboard;\n  if (!defined(billboardData)) {\n    return;\n  }\n\n  const interval = intervalFromString(billboardData.interval);\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    entity.billboard = billboard = new BillboardGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    billboard,\n    \"show\",\n    billboardData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Image,\n    billboard,\n    \"image\",\n    billboardData.image,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"scale\",\n    billboardData.scale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian2,\n    billboard,\n    \"pixelOffset\",\n    billboardData.pixelOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    billboard,\n    \"eyeOffset\",\n    billboardData.eyeOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HorizontalOrigin,\n    billboard,\n    \"horizontalOrigin\",\n    billboardData.horizontalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    VerticalOrigin,\n    billboard,\n    \"verticalOrigin\",\n    billboardData.verticalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    billboard,\n    \"heightReference\",\n    billboardData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    billboard,\n    \"color\",\n    billboardData.color,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    billboard,\n    \"rotation\",\n    billboardData.rotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processAlignedAxis(\n    billboard,\n    billboardData.alignedAxis,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    billboard,\n    \"sizeInMeters\",\n    billboardData.sizeInMeters,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"width\",\n    billboardData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"height\",\n    billboardData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    billboard,\n    \"scaleByDistance\",\n    billboardData.scaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    billboard,\n    \"translucencyByDistance\",\n    billboardData.translucencyByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    billboard,\n    \"pixelOffsetScaleByDistance\",\n    billboardData.pixelOffsetScaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    BoundingRectangle,\n    billboard,\n    \"imageSubRegion\",\n    billboardData.imageSubRegion,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    billboard,\n    \"distanceDisplayCondition\",\n    billboardData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    billboard,\n    \"disableDepthTestDistance\",\n    billboardData.disableDepthTestDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processBox(entity, packet, entityCollection, sourceUri) {\n  const boxData = packet.box;\n  if (!defined(boxData)) {\n    return;\n  }\n\n  const interval = intervalFromString(boxData.interval);\n  let box = entity.box;\n  if (!defined(box)) {\n    entity.box = box = new BoxGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    box,\n    \"show\",\n    boxData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    box,\n    \"dimensions\",\n    boxData.dimensions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    box,\n    \"heightReference\",\n    boxData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    box,\n    \"fill\",\n    boxData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    box,\n    \"material\",\n    boxData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    box,\n    \"outline\",\n    boxData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    box,\n    \"outlineColor\",\n    boxData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    box,\n    \"outlineWidth\",\n    boxData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    box,\n    \"shadows\",\n    boxData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    box,\n    \"distanceDisplayCondition\",\n    boxData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processCorridor(entity, packet, entityCollection, sourceUri) {\n  const corridorData = packet.corridor;\n  if (!defined(corridorData)) {\n    return;\n  }\n\n  const interval = intervalFromString(corridorData.interval);\n  let corridor = entity.corridor;\n  if (!defined(corridor)) {\n    entity.corridor = corridor = new CorridorGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    corridor,\n    \"show\",\n    corridorData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPositionArray(\n    corridor,\n    \"positions\",\n    corridorData.positions,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"width\",\n    corridorData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"height\",\n    corridorData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    corridor,\n    \"heightReference\",\n    corridorData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"extrudedHeight\",\n    corridorData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    corridor,\n    \"extrudedHeightReference\",\n    corridorData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    CornerType,\n    corridor,\n    \"cornerType\",\n    corridorData.cornerType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"granularity\",\n    corridorData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    corridor,\n    \"fill\",\n    corridorData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    corridor,\n    \"material\",\n    corridorData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    corridor,\n    \"outline\",\n    corridorData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    corridor,\n    \"outlineColor\",\n    corridorData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"outlineWidth\",\n    corridorData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    corridor,\n    \"shadows\",\n    corridorData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    corridor,\n    \"distanceDisplayCondition\",\n    corridorData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    corridor,\n    \"classificationType\",\n    corridorData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    corridor,\n    \"zIndex\",\n    corridorData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processCylinder(entity, packet, entityCollection, sourceUri) {\n  const cylinderData = packet.cylinder;\n  if (!defined(cylinderData)) {\n    return;\n  }\n\n  const interval = intervalFromString(cylinderData.interval);\n  let cylinder = entity.cylinder;\n  if (!defined(cylinder)) {\n    entity.cylinder = cylinder = new CylinderGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    cylinder,\n    \"show\",\n    cylinderData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"length\",\n    cylinderData.length,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"topRadius\",\n    cylinderData.topRadius,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"bottomRadius\",\n    cylinderData.bottomRadius,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    cylinder,\n    \"heightReference\",\n    cylinderData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    cylinder,\n    \"fill\",\n    cylinderData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    cylinder,\n    \"material\",\n    cylinderData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    cylinder,\n    \"outline\",\n    cylinderData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    cylinder,\n    \"outlineColor\",\n    cylinderData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"outlineWidth\",\n    cylinderData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"numberOfVerticalLines\",\n    cylinderData.numberOfVerticalLines,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    cylinder,\n    \"slices\",\n    cylinderData.slices,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    cylinder,\n    \"shadows\",\n    cylinderData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    cylinder,\n    \"distanceDisplayCondition\",\n    cylinderData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processDocument(packet, dataSource) {\n  const version = packet.version;\n  if (defined(version)) {\n    if (typeof version === \"string\") {\n      const tokens = version.split(\".\");\n      if (tokens.length === 2) {\n        if (tokens[0] !== \"1\") {\n          throw new RuntimeError(\"Cesium only supports CZML version 1.\");\n        }\n        dataSource._version = version;\n      }\n    }\n  }\n\n  if (!defined(dataSource._version)) {\n    throw new RuntimeError(\n      \"CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.\",\n    );\n  }\n\n  const documentPacket = dataSource._documentPacket;\n\n  if (defined(packet.name)) {\n    documentPacket.name = packet.name;\n  }\n\n  const clockPacket = packet.clock;\n  if (defined(clockPacket)) {\n    const clock = documentPacket.clock;\n    if (!defined(clock)) {\n      documentPacket.clock = {\n        interval: clockPacket.interval,\n        currentTime: clockPacket.currentTime,\n        range: clockPacket.range,\n        step: clockPacket.step,\n        multiplier: clockPacket.multiplier,\n      };\n    } else {\n      clock.interval = defaultValue(clockPacket.interval, clock.interval);\n      clock.currentTime = defaultValue(\n        clockPacket.currentTime,\n        clock.currentTime,\n      );\n      clock.range = defaultValue(clockPacket.range, clock.range);\n      clock.step = defaultValue(clockPacket.step, clock.step);\n      clock.multiplier = defaultValue(clockPacket.multiplier, clock.multiplier);\n    }\n  }\n}\n\nfunction processEllipse(entity, packet, entityCollection, sourceUri) {\n  const ellipseData = packet.ellipse;\n  if (!defined(ellipseData)) {\n    return;\n  }\n\n  const interval = intervalFromString(ellipseData.interval);\n  let ellipse = entity.ellipse;\n  if (!defined(ellipse)) {\n    entity.ellipse = ellipse = new EllipseGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    ellipse,\n    \"show\",\n    ellipseData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"semiMajorAxis\",\n    ellipseData.semiMajorAxis,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"semiMinorAxis\",\n    ellipseData.semiMinorAxis,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"height\",\n    ellipseData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    ellipse,\n    \"heightReference\",\n    ellipseData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"extrudedHeight\",\n    ellipseData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    ellipse,\n    \"extrudedHeightReference\",\n    ellipseData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    ellipse,\n    \"rotation\",\n    ellipseData.rotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    ellipse,\n    \"stRotation\",\n    ellipseData.stRotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"granularity\",\n    ellipseData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipse,\n    \"fill\",\n    ellipseData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    ellipse,\n    \"material\",\n    ellipseData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipse,\n    \"outline\",\n    ellipseData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    ellipse,\n    \"outlineColor\",\n    ellipseData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"outlineWidth\",\n    ellipseData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"numberOfVerticalLines\",\n    ellipseData.numberOfVerticalLines,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    ellipse,\n    \"shadows\",\n    ellipseData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    ellipse,\n    \"distanceDisplayCondition\",\n    ellipseData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    ellipse,\n    \"classificationType\",\n    ellipseData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipse,\n    \"zIndex\",\n    ellipseData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processEllipsoid(entity, packet, entityCollection, sourceUri) {\n  const ellipsoidData = packet.ellipsoid;\n  if (!defined(ellipsoidData)) {\n    return;\n  }\n\n  const interval = intervalFromString(ellipsoidData.interval);\n  let ellipsoid = entity.ellipsoid;\n  if (!defined(ellipsoid)) {\n    entity.ellipsoid = ellipsoid = new EllipsoidGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    ellipsoid,\n    \"show\",\n    ellipsoidData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    ellipsoid,\n    \"radii\",\n    ellipsoidData.radii,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    ellipsoid,\n    \"innerRadii\",\n    ellipsoidData.innerRadii,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"minimumClock\",\n    ellipsoidData.minimumClock,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"maximumClock\",\n    ellipsoidData.maximumClock,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"minimumCone\",\n    ellipsoidData.minimumCone,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"maximumCone\",\n    ellipsoidData.maximumCone,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    ellipsoid,\n    \"heightReference\",\n    ellipsoidData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipsoid,\n    \"fill\",\n    ellipsoidData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    ellipsoid,\n    \"material\",\n    ellipsoidData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    ellipsoid,\n    \"outline\",\n    ellipsoidData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    ellipsoid,\n    \"outlineColor\",\n    ellipsoidData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"outlineWidth\",\n    ellipsoidData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"stackPartitions\",\n    ellipsoidData.stackPartitions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"slicePartitions\",\n    ellipsoidData.slicePartitions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    ellipsoid,\n    \"subdivisions\",\n    ellipsoidData.subdivisions,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    ellipsoid,\n    \"shadows\",\n    ellipsoidData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    ellipsoid,\n    \"distanceDisplayCondition\",\n    ellipsoidData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processLabel(entity, packet, entityCollection, sourceUri) {\n  const labelData = packet.label;\n  if (!defined(labelData)) {\n    return;\n  }\n\n  const interval = intervalFromString(labelData.interval);\n  let label = entity.label;\n  if (!defined(label)) {\n    entity.label = label = new LabelGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    label,\n    \"show\",\n    labelData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    String,\n    label,\n    \"text\",\n    labelData.text,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    String,\n    label,\n    \"font\",\n    labelData.font,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    LabelStyle,\n    label,\n    \"style\",\n    labelData.style,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    label,\n    \"scale\",\n    labelData.scale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    label,\n    \"showBackground\",\n    labelData.showBackground,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    label,\n    \"backgroundColor\",\n    labelData.backgroundColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian2,\n    label,\n    \"backgroundPadding\",\n    labelData.backgroundPadding,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian2,\n    label,\n    \"pixelOffset\",\n    labelData.pixelOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Cartesian3,\n    label,\n    \"eyeOffset\",\n    labelData.eyeOffset,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HorizontalOrigin,\n    label,\n    \"horizontalOrigin\",\n    labelData.horizontalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    VerticalOrigin,\n    label,\n    \"verticalOrigin\",\n    labelData.verticalOrigin,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    label,\n    \"heightReference\",\n    labelData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    label,\n    \"fillColor\",\n    labelData.fillColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    label,\n    \"outlineColor\",\n    labelData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    label,\n    \"outlineWidth\",\n    labelData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    label,\n    \"translucencyByDistance\",\n    labelData.translucencyByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    label,\n    \"pixelOffsetScaleByDistance\",\n    labelData.pixelOffsetScaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    label,\n    \"scaleByDistance\",\n    labelData.scaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    label,\n    \"distanceDisplayCondition\",\n    labelData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    label,\n    \"disableDepthTestDistance\",\n    labelData.disableDepthTestDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processModel(entity, packet, entityCollection, sourceUri) {\n  const modelData = packet.model;\n  if (!defined(modelData)) {\n    return;\n  }\n\n  const interval = intervalFromString(modelData.interval);\n  let model = entity.model;\n  if (!defined(model)) {\n    entity.model = model = new ModelGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    model,\n    \"show\",\n    modelData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Uri,\n    model,\n    \"uri\",\n    modelData.gltf,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"scale\",\n    modelData.scale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"minimumPixelSize\",\n    modelData.minimumPixelSize,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"maximumScale\",\n    modelData.maximumScale,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    model,\n    \"incrementallyLoadTextures\",\n    modelData.incrementallyLoadTextures,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    model,\n    \"runAnimations\",\n    modelData.runAnimations,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    model,\n    \"clampAnimations\",\n    modelData.clampAnimations,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    model,\n    \"shadows\",\n    modelData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    model,\n    \"heightReference\",\n    modelData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    model,\n    \"silhouetteColor\",\n    modelData.silhouetteColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"silhouetteSize\",\n    modelData.silhouetteSize,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    model,\n    \"color\",\n    modelData.color,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ColorBlendMode,\n    model,\n    \"colorBlendMode\",\n    modelData.colorBlendMode,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    model,\n    \"colorBlendAmount\",\n    modelData.colorBlendAmount,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    model,\n    \"distanceDisplayCondition\",\n    modelData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n\n  let i, len;\n  const nodeTransformationsData = modelData.nodeTransformations;\n  if (defined(nodeTransformationsData)) {\n    if (Array.isArray(nodeTransformationsData)) {\n      for (i = 0, len = nodeTransformationsData.length; i < len; ++i) {\n        processNodeTransformations(\n          model,\n          nodeTransformationsData[i],\n          interval,\n          sourceUri,\n          entityCollection,\n        );\n      }\n    } else {\n      processNodeTransformations(\n        model,\n        nodeTransformationsData,\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  }\n\n  const articulationsData = modelData.articulations;\n  if (defined(articulationsData)) {\n    if (Array.isArray(articulationsData)) {\n      for (i = 0, len = articulationsData.length; i < len; ++i) {\n        processArticulations(\n          model,\n          articulationsData[i],\n          interval,\n          sourceUri,\n          entityCollection,\n        );\n      }\n    } else {\n      processArticulations(\n        model,\n        articulationsData,\n        interval,\n        sourceUri,\n        entityCollection,\n      );\n    }\n  }\n}\n\nfunction processNodeTransformations(\n  model,\n  nodeTransformationsData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(nodeTransformationsData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let nodeTransformations = model.nodeTransformations;\n  const nodeNames = Object.keys(nodeTransformationsData);\n  for (let i = 0, len = nodeNames.length; i < len; ++i) {\n    const nodeName = nodeNames[i];\n    if (nodeName === \"interval\") {\n      continue;\n    }\n\n    const nodeTransformationData = nodeTransformationsData[nodeName];\n    if (!defined(nodeTransformationData)) {\n      continue;\n    }\n\n    if (!defined(nodeTransformations)) {\n      model.nodeTransformations = nodeTransformations = new PropertyBag();\n    }\n\n    if (!nodeTransformations.hasProperty(nodeName)) {\n      nodeTransformations.addProperty(nodeName);\n    }\n\n    let nodeTransformation = nodeTransformations[nodeName];\n    if (!defined(nodeTransformation)) {\n      nodeTransformations[nodeName] = nodeTransformation =\n        new NodeTransformationProperty();\n    }\n\n    processPacketData(\n      Cartesian3,\n      nodeTransformation,\n      \"translation\",\n      nodeTransformationData.translation,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Quaternion,\n      nodeTransformation,\n      \"rotation\",\n      nodeTransformationData.rotation,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n    processPacketData(\n      Cartesian3,\n      nodeTransformation,\n      \"scale\",\n      nodeTransformationData.scale,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processArticulations(\n  model,\n  articulationsData,\n  constrainedInterval,\n  sourceUri,\n  entityCollection,\n) {\n  let combinedInterval = intervalFromString(articulationsData.interval);\n  if (defined(constrainedInterval)) {\n    if (defined(combinedInterval)) {\n      combinedInterval = TimeInterval.intersect(\n        combinedInterval,\n        constrainedInterval,\n        scratchTimeInterval,\n      );\n    } else {\n      combinedInterval = constrainedInterval;\n    }\n  }\n\n  let articulations = model.articulations;\n  const keys = Object.keys(articulationsData);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const key = keys[i];\n    if (key === \"interval\") {\n      continue;\n    }\n\n    const articulationStageData = articulationsData[key];\n    if (!defined(articulationStageData)) {\n      continue;\n    }\n\n    if (!defined(articulations)) {\n      model.articulations = articulations = new PropertyBag();\n    }\n\n    if (!articulations.hasProperty(key)) {\n      articulations.addProperty(key);\n    }\n\n    processPacketData(\n      Number,\n      articulations,\n      key,\n      articulationStageData,\n      combinedInterval,\n      sourceUri,\n      entityCollection,\n    );\n  }\n}\n\nfunction processPath(entity, packet, entityCollection, sourceUri) {\n  const pathData = packet.path;\n  if (!defined(pathData)) {\n    return;\n  }\n\n  const interval = intervalFromString(pathData.interval);\n  let path = entity.path;\n  if (!defined(path)) {\n    entity.path = path = new PathGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    path,\n    \"show\",\n    pathData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"leadTime\",\n    pathData.leadTime,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"trailTime\",\n    pathData.trailTime,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"width\",\n    pathData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    path,\n    \"resolution\",\n    pathData.resolution,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    path,\n    \"material\",\n    pathData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    path,\n    \"distanceDisplayCondition\",\n    pathData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processPoint(entity, packet, entityCollection, sourceUri) {\n  const pointData = packet.point;\n  if (!defined(pointData)) {\n    return;\n  }\n\n  const interval = intervalFromString(pointData.interval);\n  let point = entity.point;\n  if (!defined(point)) {\n    entity.point = point = new PointGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    point,\n    \"show\",\n    pointData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    point,\n    \"pixelSize\",\n    pointData.pixelSize,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    point,\n    \"heightReference\",\n    pointData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    point,\n    \"color\",\n    pointData.color,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    point,\n    \"outlineColor\",\n    pointData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    point,\n    \"outlineWidth\",\n    pointData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    point,\n    \"scaleByDistance\",\n    pointData.scaleByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    NearFarScalar,\n    point,\n    \"translucencyByDistance\",\n    pointData.translucencyByDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    point,\n    \"distanceDisplayCondition\",\n    pointData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    point,\n    \"disableDepthTestDistance\",\n    pointData.disableDepthTestDistance,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction PolygonHierarchyProperty(polygon) {\n  this.polygon = polygon;\n  this._definitionChanged = new Event();\n}\n\nObject.defineProperties(PolygonHierarchyProperty.prototype, {\n  isConstant: {\n    get: function () {\n      const positions = this.polygon._positions;\n      const holes = this.polygon._holes;\n      return (\n        (!defined(positions) || positions.isConstant) &&\n        (!defined(holes) || holes.isConstant)\n      );\n    },\n  },\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n});\n\nPolygonHierarchyProperty.prototype.getValue = function (time, result) {\n  let positions;\n  if (defined(this.polygon._positions)) {\n    positions = this.polygon._positions.getValue(time);\n  }\n\n  let holes;\n  if (defined(this.polygon._holes)) {\n    holes = this.polygon._holes.getValue(time);\n    if (defined(holes)) {\n      holes = holes.map(function (holePositions) {\n        return new PolygonHierarchy(holePositions);\n      });\n    }\n  }\n\n  if (!defined(result)) {\n    return new PolygonHierarchy(positions, holes);\n  }\n\n  result.positions = positions;\n  result.holes = holes;\n  return result;\n};\n\nPolygonHierarchyProperty.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (other instanceof PolygonHierarchyProperty &&\n      Property.equals(this.polygon._positions, other.polygon._positions) &&\n      Property.equals(this.polygon._holes, other.polygon._holes))\n  );\n};\n\nfunction processPolygon(entity, packet, entityCollection, sourceUri) {\n  const polygonData = packet.polygon;\n  if (!defined(polygonData)) {\n    return;\n  }\n\n  const interval = intervalFromString(polygonData.interval);\n  let polygon = entity.polygon;\n  if (!defined(polygon)) {\n    entity.polygon = polygon = new PolygonGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    polygon,\n    \"show\",\n    polygonData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n\n  // adapt 'position' property producing Cartesian[]\n  // and 'holes' property producing Cartesian[][]\n  // to a single property producing PolygonHierarchy\n  processPositionArray(\n    polygon,\n    \"_positions\",\n    polygonData.positions,\n    entityCollection,\n  );\n  processPositionArrayOfArrays(\n    polygon,\n    \"_holes\",\n    polygonData.holes,\n    entityCollection,\n  );\n  if (defined(polygon._positions) || defined(polygon._holes)) {\n    polygon.hierarchy = new PolygonHierarchyProperty(polygon);\n  }\n\n  processPacketData(\n    Number,\n    polygon,\n    \"height\",\n    polygonData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    polygon,\n    \"heightReference\",\n    polygonData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"extrudedHeight\",\n    polygonData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    polygon,\n    \"extrudedHeightReference\",\n    polygonData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    polygon,\n    \"stRotation\",\n    polygonData.stRotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"granularity\",\n    polygonData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"fill\",\n    polygonData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polygon,\n    \"material\",\n    polygonData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"outline\",\n    polygonData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    polygon,\n    \"outlineColor\",\n    polygonData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"outlineWidth\",\n    polygonData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"perPositionHeight\",\n    polygonData.perPositionHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"closeTop\",\n    polygonData.closeTop,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polygon,\n    \"closeBottom\",\n    polygonData.closeBottom,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ArcType,\n    polygon,\n    \"arcType\",\n    polygonData.arcType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    polygon,\n    \"shadows\",\n    polygonData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    polygon,\n    \"distanceDisplayCondition\",\n    polygonData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    polygon,\n    \"classificationType\",\n    polygonData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polygon,\n    \"zIndex\",\n    polygonData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction adaptFollowSurfaceToArcType(followSurface) {\n  return followSurface ? ArcType.GEODESIC : ArcType.NONE;\n}\n\nfunction processPolyline(entity, packet, entityCollection, sourceUri) {\n  const polylineData = packet.polyline;\n  if (!defined(polylineData)) {\n    return;\n  }\n\n  const interval = intervalFromString(polylineData.interval);\n  let polyline = entity.polyline;\n  if (!defined(polyline)) {\n    entity.polyline = polyline = new PolylineGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    polyline,\n    \"show\",\n    polylineData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPositionArray(\n    polyline,\n    \"positions\",\n    polylineData.positions,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polyline,\n    \"width\",\n    polylineData.width,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polyline,\n    \"granularity\",\n    polylineData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polyline,\n    \"material\",\n    polylineData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polyline,\n    \"depthFailMaterial\",\n    polylineData.depthFailMaterial,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ArcType,\n    polyline,\n    \"arcType\",\n    polylineData.arcType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polyline,\n    \"clampToGround\",\n    polylineData.clampToGround,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    polyline,\n    \"shadows\",\n    polylineData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    polyline,\n    \"distanceDisplayCondition\",\n    polylineData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    polyline,\n    \"classificationType\",\n    polylineData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polyline,\n    \"zIndex\",\n    polylineData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n\n  // for backwards compatibility, adapt CZML followSurface to arcType.\n  if (defined(polylineData.followSurface) && !defined(polylineData.arcType)) {\n    const tempObj = {};\n    processPacketData(\n      Boolean,\n      tempObj,\n      \"followSurface\",\n      polylineData.followSurface,\n      interval,\n      sourceUri,\n      entityCollection,\n    );\n    polyline.arcType = createAdapterProperty(\n      tempObj.followSurface,\n      adaptFollowSurfaceToArcType,\n    );\n  }\n}\n\nfunction processPolylineVolume(entity, packet, entityCollection, sourceUri) {\n  const polylineVolumeData = packet.polylineVolume;\n  if (!defined(polylineVolumeData)) {\n    return;\n  }\n\n  const interval = intervalFromString(polylineVolumeData.interval);\n  let polylineVolume = entity.polylineVolume;\n  if (!defined(polylineVolume)) {\n    entity.polylineVolume = polylineVolume = new PolylineVolumeGraphics();\n  }\n\n  processPositionArray(\n    polylineVolume,\n    \"positions\",\n    polylineVolumeData.positions,\n    entityCollection,\n  );\n  processShape(\n    polylineVolume,\n    \"shape\",\n    polylineVolumeData.shape,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polylineVolume,\n    \"show\",\n    polylineVolumeData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    CornerType,\n    polylineVolume,\n    \"cornerType\",\n    polylineVolumeData.cornerType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polylineVolume,\n    \"fill\",\n    polylineVolumeData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    polylineVolume,\n    \"material\",\n    polylineVolumeData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    polylineVolume,\n    \"outline\",\n    polylineVolumeData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    polylineVolume,\n    \"outlineColor\",\n    polylineVolumeData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polylineVolume,\n    \"outlineWidth\",\n    polylineVolumeData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    polylineVolume,\n    \"granularity\",\n    polylineVolumeData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    polylineVolume,\n    \"shadows\",\n    polylineVolumeData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    polylineVolume,\n    \"distanceDisplayCondition\",\n    polylineVolumeData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processRectangle(entity, packet, entityCollection, sourceUri) {\n  const rectangleData = packet.rectangle;\n  if (!defined(rectangleData)) {\n    return;\n  }\n\n  const interval = intervalFromString(rectangleData.interval);\n  let rectangle = entity.rectangle;\n  if (!defined(rectangle)) {\n    entity.rectangle = rectangle = new RectangleGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    rectangle,\n    \"show\",\n    rectangleData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rectangle,\n    rectangle,\n    \"coordinates\",\n    rectangleData.coordinates,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"height\",\n    rectangleData.height,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    rectangle,\n    \"heightReference\",\n    rectangleData.heightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"extrudedHeight\",\n    rectangleData.extrudedHeight,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    HeightReference,\n    rectangle,\n    \"extrudedHeightReference\",\n    rectangleData.extrudedHeightReference,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    rectangle,\n    \"rotation\",\n    rectangleData.rotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Rotation,\n    rectangle,\n    \"stRotation\",\n    rectangleData.stRotation,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"granularity\",\n    rectangleData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    rectangle,\n    \"fill\",\n    rectangleData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    rectangle,\n    \"material\",\n    rectangleData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    rectangle,\n    \"outline\",\n    rectangleData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    rectangle,\n    \"outlineColor\",\n    rectangleData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"outlineWidth\",\n    rectangleData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    rectangle,\n    \"shadows\",\n    rectangleData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    rectangle,\n    \"distanceDisplayCondition\",\n    rectangleData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ClassificationType,\n    rectangle,\n    \"classificationType\",\n    rectangleData.classificationType,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    rectangle,\n    \"zIndex\",\n    rectangleData.zIndex,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processTileset(entity, packet, entityCollection, sourceUri) {\n  const tilesetData = packet.tileset;\n  if (!defined(tilesetData)) {\n    return;\n  }\n\n  const interval = intervalFromString(tilesetData.interval);\n  let tileset = entity.tileset;\n  if (!defined(tileset)) {\n    entity.tileset = tileset = new Cesium3DTilesetGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    tileset,\n    \"show\",\n    tilesetData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Uri,\n    tileset,\n    \"uri\",\n    tilesetData.uri,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    tileset,\n    \"maximumScreenSpaceError\",\n    tilesetData.maximumScreenSpaceError,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processWall(entity, packet, entityCollection, sourceUri) {\n  const wallData = packet.wall;\n  if (!defined(wallData)) {\n    return;\n  }\n\n  const interval = intervalFromString(wallData.interval);\n  let wall = entity.wall;\n  if (!defined(wall)) {\n    entity.wall = wall = new WallGraphics();\n  }\n\n  processPacketData(\n    Boolean,\n    wall,\n    \"show\",\n    wallData.show,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPositionArray(wall, \"positions\", wallData.positions, entityCollection);\n  processArray(\n    wall,\n    \"minimumHeights\",\n    wallData.minimumHeights,\n    entityCollection,\n  );\n  processArray(\n    wall,\n    \"maximumHeights\",\n    wallData.maximumHeights,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    wall,\n    \"granularity\",\n    wallData.granularity,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    wall,\n    \"fill\",\n    wallData.fill,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processMaterialPacketData(\n    wall,\n    \"material\",\n    wallData.material,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Boolean,\n    wall,\n    \"outline\",\n    wallData.outline,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Color,\n    wall,\n    \"outlineColor\",\n    wallData.outlineColor,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    Number,\n    wall,\n    \"outlineWidth\",\n    wallData.outlineWidth,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    ShadowMode,\n    wall,\n    \"shadows\",\n    wallData.shadows,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n  processPacketData(\n    DistanceDisplayCondition,\n    wall,\n    \"distanceDisplayCondition\",\n    wallData.distanceDisplayCondition,\n    interval,\n    sourceUri,\n    entityCollection,\n  );\n}\n\nfunction processCzmlPacket(\n  packet,\n  entityCollection,\n  updaterFunctions,\n  sourceUri,\n  dataSource,\n) {\n  let objectId = packet.id;\n  if (!defined(objectId)) {\n    objectId = createGuid();\n  }\n\n  currentId = objectId;\n\n  if (!defined(dataSource._version) && objectId !== \"document\") {\n    throw new RuntimeError(\n      \"The first CZML packet is required to be the document object.\",\n    );\n  }\n\n  if (packet[\"delete\"] === true) {\n    entityCollection.removeById(objectId);\n  } else if (objectId === \"document\") {\n    processDocument(packet, dataSource);\n  } else {\n    const entity = entityCollection.getOrCreateEntity(objectId);\n\n    const parentId = packet.parent;\n    if (defined(parentId)) {\n      entity.parent = entityCollection.getOrCreateEntity(parentId);\n    }\n\n    for (let i = updaterFunctions.length - 1; i > -1; i--) {\n      updaterFunctions[i](entity, packet, entityCollection, sourceUri);\n    }\n  }\n\n  currentId = undefined;\n}\n\nfunction updateClock(dataSource) {\n  let clock;\n  const clockPacket = dataSource._documentPacket.clock;\n  if (!defined(clockPacket)) {\n    if (!defined(dataSource._clock)) {\n      const availability = dataSource._entityCollection.computeAvailability();\n      if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {\n        const startTime = availability.start;\n        const stopTime = availability.stop;\n        const totalSeconds = JulianDate.secondsDifference(stopTime, startTime);\n        const multiplier = Math.round(totalSeconds / 120.0);\n\n        clock = new DataSourceClock();\n        clock.startTime = JulianDate.clone(startTime);\n        clock.stopTime = JulianDate.clone(stopTime);\n        clock.clockRange = ClockRange.LOOP_STOP;\n        clock.multiplier = multiplier;\n        clock.currentTime = JulianDate.clone(startTime);\n        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n        dataSource._clock = clock;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (defined(dataSource._clock)) {\n    clock = dataSource._clock.clone();\n  } else {\n    clock = new DataSourceClock();\n    clock.startTime = Iso8601.MINIMUM_VALUE.clone();\n    clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();\n    clock.currentTime = Iso8601.MINIMUM_VALUE.clone();\n    clock.clockRange = ClockRange.LOOP_STOP;\n    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n    clock.multiplier = 1.0;\n  }\n\n  const interval = intervalFromString(clockPacket.interval);\n  if (defined(interval)) {\n    clock.startTime = interval.start;\n    clock.stopTime = interval.stop;\n  }\n\n  if (defined(clockPacket.currentTime)) {\n    clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);\n  }\n  if (defined(clockPacket.range)) {\n    clock.clockRange = defaultValue(\n      ClockRange[clockPacket.range],\n      ClockRange.LOOP_STOP,\n    );\n  }\n  if (defined(clockPacket.step)) {\n    clock.clockStep = defaultValue(\n      ClockStep[clockPacket.step],\n      ClockStep.SYSTEM_CLOCK_MULTIPLIER,\n    );\n  }\n  if (defined(clockPacket.multiplier)) {\n    clock.multiplier = clockPacket.multiplier;\n  }\n\n  if (!clock.equals(dataSource._clock)) {\n    dataSource._clock = clock.clone(dataSource._clock);\n    return true;\n  }\n\n  return false;\n}\n\nfunction load(dataSource, czml, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(czml)) {\n    throw new DeveloperError(\"czml is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  let promise = czml;\n  let sourceUri = options.sourceUri;\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  dataSource._credit = credit;\n\n  // If the czml is a URL\n  if (typeof czml === \"string\" || czml instanceof Resource) {\n    czml = Resource.createIfNeeded(czml);\n    promise = czml.fetchJson();\n    sourceUri = defaultValue(sourceUri, czml.clone());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = czml.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n\n  sourceUri = Resource.createIfNeeded(sourceUri);\n\n  DataSource.setLoading(dataSource, true);\n\n  return Promise.resolve(promise)\n    .then(function (czml) {\n      return loadCzml(dataSource, czml, sourceUri, clear);\n    })\n    .catch(function (error) {\n      DataSource.setLoading(dataSource, false);\n      dataSource._error.raiseEvent(dataSource, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n}\n\nfunction loadCzml(dataSource, czml, sourceUri, clear) {\n  DataSource.setLoading(dataSource, true);\n  const entityCollection = dataSource._entityCollection;\n\n  if (clear) {\n    dataSource._version = undefined;\n    dataSource._documentPacket = new DocumentPacket();\n    entityCollection.removeAll();\n  }\n\n  CzmlDataSource._processCzml(\n    czml,\n    entityCollection,\n    sourceUri,\n    undefined,\n    dataSource,\n  );\n\n  let raiseChangedEvent = updateClock(dataSource);\n\n  const documentPacket = dataSource._documentPacket;\n  if (\n    defined(documentPacket.name) &&\n    dataSource._name !== documentPacket.name\n  ) {\n    dataSource._name = documentPacket.name;\n    raiseChangedEvent = true;\n  } else if (!defined(dataSource._name) && defined(sourceUri)) {\n    dataSource._name = getFilenameFromUri(sourceUri.getUrlComponent());\n    raiseChangedEvent = true;\n  }\n\n  DataSource.setLoading(dataSource, false);\n  if (raiseChangedEvent) {\n    dataSource._changed.raiseEvent(dataSource);\n  }\n\n  return dataSource;\n}\n\nfunction DocumentPacket() {\n  this.name = undefined;\n  this.clock = undefined;\n}\n\n/**\n * @typedef {object} CzmlDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {Resource|string} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Guide|CZML}.\n * @alias CzmlDataSource\n * @constructor\n *\n * @param {string} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}\n */\nfunction CzmlDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._clock = undefined;\n  this._documentPacket = new DocumentPacket();\n  this._version = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided CZML data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to the new instance once the data is processed.\n */\nCzmlDataSource.load = function (czml, options) {\n  return new CzmlDataSource().load(czml, options);\n};\n\nObject.defineProperties(CzmlDataSource.prototype, {\n  /**\n   * Gets a human-readable name for this instance.\n   * @memberof CzmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly\n   * defined in the CZML, the combined availability of all objects is returned.  If\n   * only static data exists, this value is undefined.\n   * @memberof CzmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof CzmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof CzmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof CzmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof CzmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof CzmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof CzmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\n/**\n * @callback CzmlDataSource.UpdaterFunction\n *\n * A CZML processing function that adds or updates entities in the provided\n * collection based on the provided CZML packet.\n *\n * @param {Entity} entity\n * @param {object} packet\n * @param {EntityCollection} entityCollection\n * @param {string} sourceUri\n */\n\n/**\n * Gets the array of CZML processing functions.\n * @memberof CzmlDataSource\n * @type {CzmlDataSource.UpdaterFunction[]}\n */\nCzmlDataSource.updaters = [\n  processBillboard,\n  processBox,\n  processCorridor,\n  processCylinder,\n  processEllipse,\n  processEllipsoid,\n  processLabel,\n  processModel,\n  processName,\n  processDescription,\n  processPath,\n  processPoint,\n  processPolygon,\n  processPolyline,\n  processPolylineVolume,\n  processProperties,\n  processRectangle,\n  processPosition,\n  processTileset,\n  processViewFrom,\n  processWall,\n  processOrientation,\n  processAvailability,\n];\n\n/**\n * Add the provided updater to the list of updaters if not already included\n * @private\n * @param {CzmlDataSource.UpdaterFunction} updater\n */\nCzmlDataSource.registerUpdater = function (updater) {\n  if (!CzmlDataSource.updaters.includes(updater)) {\n    CzmlDataSource.updaters.push(updater);\n  }\n};\n\n/**\n * Remove the provided updater from the list of updaters if already included\n * @private\n * @param {CzmlDataSource.UpdaterFunction} updater\n */\nCzmlDataSource.unregisterUpdater = function (updater) {\n  if (CzmlDataSource.updaters.includes(updater)) {\n    const index = CzmlDataSource.updaters.indexOf(updater);\n    CzmlDataSource.updaters.splice(index, 1);\n  }\n};\n\n/**\n * Processes the provided url or CZML object without clearing any existing data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n */\nCzmlDataSource.prototype.process = function (czml, options) {\n  return load(this, czml, options, false);\n};\n\n/**\n * Loads the provided url or CZML object, replacing any existing data.\n *\n * @param {Resource|string|object} czml A url or CZML object to be processed.\n * @param {CzmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n */\nCzmlDataSource.prototype.load = function (czml, options) {\n  return load(this, czml, options, true);\n};\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nCzmlDataSource.prototype.update = function (time) {\n  return true;\n};\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link Property} from a CZML packet.\n * @function\n *\n * @param {Function} type The constructor function for the property being processed.\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processPacketData = processPacketData;\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link PositionProperty} from a CZML packet.\n * @function\n *\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processPositionPacketData = processPositionPacketData;\n\n/**\n * A helper function used by custom CZML updater functions\n * which creates or updates a {@link MaterialProperty} from a CZML packet.\n * @function\n *\n * @param {object} object The object on which the property will be added or updated.\n * @param {string} propertyName The name of the property on the object.\n * @param {object} packetData The CZML packet being processed.\n * @param {TimeInterval} interval A constraining interval for which the data is valid.\n * @param {string} sourceUri The originating uri of the data being processed.\n * @param {EntityCollection} entityCollection The collection being processsed.\n */\nCzmlDataSource.processMaterialPacketData = processMaterialPacketData;\n\nCzmlDataSource._processCzml = function (\n  czml,\n  entityCollection,\n  sourceUri,\n  updaterFunctions,\n  dataSource,\n) {\n  updaterFunctions = defaultValue(updaterFunctions, CzmlDataSource.updaters);\n\n  if (Array.isArray(czml)) {\n    for (let i = 0, len = czml.length; i < len; ++i) {\n      processCzmlPacket(\n        czml[i],\n        entityCollection,\n        updaterFunctions,\n        sourceUri,\n        dataSource,\n      );\n    }\n  } else {\n    processCzmlPacket(\n      czml,\n      entityCollection,\n      updaterFunctions,\n      sourceUri,\n      dataSource,\n    );\n  }\n};\nexport default CzmlDataSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}