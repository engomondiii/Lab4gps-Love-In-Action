{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport parseStructuralMetadata from \"./parseStructuralMetadata.js\";\nimport parseFeatureMetadataLegacy from \"./parseFeatureMetadataLegacy.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads glTF structural metadata\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfStructuralMetadataLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {string} [options.extension] The <code>EXT_structural_metadata</code> extension object. If this is undefined, then extensionLegacy must be defined.\n * @param {string} [options.extensionLegacy] The legacy <code>EXT_feature_metadata</code> extension for backwards compatibility.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction GltfStructuralMetadataLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    extension,\n    extensionLegacy,\n    gltfResource,\n    baseResource,\n    supportedImageFormats,\n    frameState,\n    cacheKey,\n    asynchronous = true\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!defined(options.extension) && !defined(options.extensionLegacy)) {\n    throw new DeveloperError(\"One of options.extension or options.extensionLegacy must be specified\");\n  }\n  //>>includeEnd('debug');\n\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._extension = extension;\n  this._extensionLegacy = extensionLegacy;\n  this._supportedImageFormats = supportedImageFormats;\n  this._frameState = frameState;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._bufferViewLoaders = [];\n  this._bufferViewIds = [];\n  this._textureLoaders = [];\n  this._textureIds = [];\n  this._schemaLoader = undefined;\n  this._structuralMetadata = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfStructuralMetadataLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfStructuralMetadataLoader.prototype.constructor = GltfStructuralMetadataLoader;\n}\nObject.defineProperties(GltfStructuralMetadataLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The parsed structural metadata\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._structuralMetadata;\n    }\n  }\n});\nasync function loadResources(loader) {\n  try {\n    const bufferViewsPromise = loadBufferViews(loader);\n    const texturesPromise = loadTextures(loader);\n    const schemaPromise = loadSchema(loader);\n    await Promise.all([bufferViewsPromise, texturesPromise, schemaPromise]);\n    if (loader.isDestroyed()) {\n      return;\n    }\n    loader._gltf = undefined; // No longer need to hold onto the glTF\n\n    loader._state = ResourceLoaderState.LOADED;\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    loader.unload();\n    loader._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load structural metadata\";\n    throw loader.getError(errorMessage, error);\n  }\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfStructuralMetadataLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = loadResources(this);\n  return this._promise;\n};\nfunction gatherBufferViewIdsFromProperties(properties, bufferViewIdSet) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const values = property.values;\n      const arrayOffsets = property.arrayOffsets;\n      const stringOffsets = property.stringOffsets;\n\n      // Using an object like a mathematical set\n      if (defined(values)) {\n        bufferViewIdSet[values] = true;\n      }\n      if (defined(arrayOffsets)) {\n        bufferViewIdSet[arrayOffsets] = true;\n      }\n      if (defined(stringOffsets)) {\n        bufferViewIdSet[stringOffsets] = true;\n      }\n    }\n  }\n}\nfunction gatherBufferViewIdsFromPropertiesLegacy(properties, bufferViewIdSet) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const bufferView = property.bufferView;\n      const arrayOffsetBufferView = property.arrayOffsetBufferView;\n      const stringOffsetBufferView = property.stringOffsetBufferView;\n\n      // Using an object like a mathematical set\n      if (defined(bufferView)) {\n        bufferViewIdSet[bufferView] = true;\n      }\n      if (defined(arrayOffsetBufferView)) {\n        bufferViewIdSet[arrayOffsetBufferView] = true;\n      }\n      if (defined(stringOffsetBufferView)) {\n        bufferViewIdSet[stringOffsetBufferView] = true;\n      }\n    }\n  }\n}\nfunction gatherUsedBufferViewIds(extension) {\n  const propertyTables = extension.propertyTables;\n  const bufferViewIdSet = {};\n  if (defined(propertyTables)) {\n    for (let i = 0; i < propertyTables.length; i++) {\n      const propertyTable = propertyTables[i];\n      gatherBufferViewIdsFromProperties(propertyTable.properties, bufferViewIdSet);\n    }\n  }\n  return bufferViewIdSet;\n}\nfunction gatherUsedBufferViewIdsLegacy(extensionLegacy) {\n  const featureTables = extensionLegacy.featureTables;\n  const bufferViewIdSet = {};\n  if (defined(featureTables)) {\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          gatherBufferViewIdsFromPropertiesLegacy(properties, bufferViewIdSet);\n        }\n      }\n    }\n  }\n  return bufferViewIdSet;\n}\nasync function loadBufferViews(structuralMetadataLoader) {\n  let bufferViewIds;\n  if (defined(structuralMetadataLoader._extension)) {\n    bufferViewIds = gatherUsedBufferViewIds(structuralMetadataLoader._extension);\n  } else {\n    bufferViewIds = gatherUsedBufferViewIdsLegacy(structuralMetadataLoader._extensionLegacy);\n  }\n\n  // Load the buffer views\n  const bufferViewPromises = [];\n  for (const bufferViewId in bufferViewIds) {\n    if (bufferViewIds.hasOwnProperty(bufferViewId)) {\n      const bufferViewLoader = ResourceCache.getBufferViewLoader({\n        gltf: structuralMetadataLoader._gltf,\n        bufferViewId: parseInt(bufferViewId),\n        gltfResource: structuralMetadataLoader._gltfResource,\n        baseResource: structuralMetadataLoader._baseResource\n      });\n      structuralMetadataLoader._bufferViewLoaders.push(bufferViewLoader);\n      structuralMetadataLoader._bufferViewIds.push(bufferViewId);\n      bufferViewPromises.push(bufferViewLoader.load());\n    }\n  }\n  return Promise.all(bufferViewPromises);\n}\nfunction gatherUsedTextureIds(structuralMetadataExtension) {\n  // Gather the used textures\n  const textureIds = {};\n  const propertyTextures = structuralMetadataExtension.propertyTextures;\n  if (defined(propertyTextures)) {\n    for (let i = 0; i < propertyTextures.length; i++) {\n      const propertyTexture = propertyTextures[i];\n      const properties = propertyTexture.properties;\n      if (defined(properties)) {\n        gatherTextureIdsFromProperties(properties, textureIds);\n      }\n    }\n  }\n  return textureIds;\n}\nfunction gatherTextureIdsFromProperties(properties, textureIds) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      // in EXT_structural_metadata the property is a valid textureInfo.\n      const textureInfo = properties[propertyId];\n      textureIds[textureInfo.index] = textureInfo;\n    }\n  }\n}\nfunction gatherUsedTextureIdsLegacy(extensionLegacy) {\n  // Gather the used textures\n  const textureIds = {};\n  const featureTextures = extensionLegacy.featureTextures;\n  if (defined(featureTextures)) {\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          gatherTextureIdsFromPropertiesLegacy(properties, textureIds);\n        }\n      }\n    }\n  }\n  return textureIds;\n}\nfunction gatherTextureIdsFromPropertiesLegacy(properties, textureIds) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const textureInfo = property.texture;\n      textureIds[textureInfo.index] = textureInfo;\n    }\n  }\n}\nfunction loadTextures(structuralMetadataLoader) {\n  let textureIds;\n  if (defined(structuralMetadataLoader._extension)) {\n    textureIds = gatherUsedTextureIds(structuralMetadataLoader._extension);\n  } else {\n    textureIds = gatherUsedTextureIdsLegacy(structuralMetadataLoader._extensionLegacy);\n  }\n  const gltf = structuralMetadataLoader._gltf;\n  const gltfResource = structuralMetadataLoader._gltfResource;\n  const baseResource = structuralMetadataLoader._baseResource;\n  const supportedImageFormats = structuralMetadataLoader._supportedImageFormats;\n  const frameState = structuralMetadataLoader._frameState;\n  const asynchronous = structuralMetadataLoader._asynchronous;\n\n  // Load the textures\n  const texturePromises = [];\n  for (const textureId in textureIds) {\n    if (textureIds.hasOwnProperty(textureId)) {\n      const textureLoader = ResourceCache.getTextureLoader({\n        gltf: gltf,\n        textureInfo: textureIds[textureId],\n        gltfResource: gltfResource,\n        baseResource: baseResource,\n        supportedImageFormats: supportedImageFormats,\n        frameState: frameState,\n        asynchronous: asynchronous\n      });\n      structuralMetadataLoader._textureLoaders.push(textureLoader);\n      structuralMetadataLoader._textureIds.push(textureId);\n      texturePromises.push(textureLoader.load());\n    }\n  }\n  return Promise.all(texturePromises);\n}\nasync function loadSchema(structuralMetadataLoader) {\n  const extension = defaultValue(structuralMetadataLoader._extension, structuralMetadataLoader._extensionLegacy);\n  let schemaLoader;\n  if (defined(extension.schemaUri)) {\n    const resource = structuralMetadataLoader._baseResource.getDerivedResource({\n      url: extension.schemaUri\n    });\n    schemaLoader = ResourceCache.getSchemaLoader({\n      resource: resource\n    });\n  } else {\n    schemaLoader = ResourceCache.getSchemaLoader({\n      schema: extension.schema\n    });\n  }\n  structuralMetadataLoader._schemaLoader = schemaLoader;\n  await schemaLoader.load();\n  if (!schemaLoader.isDestroyed()) {\n    return schemaLoader.schema;\n  }\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED) {\n    return false;\n  }\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  let ready = true;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    const textureLoader = textureLoaders[i];\n    const textureReady = textureLoader.process(frameState);\n    ready = ready && textureReady;\n  }\n  if (!ready) {\n    return false;\n  }\n  const schema = this._schemaLoader.schema;\n  const bufferViews = {};\n  for (let i = 0; i < this._bufferViewIds.length; ++i) {\n    const bufferViewId = this._bufferViewIds[i];\n    const bufferViewLoader = this._bufferViewLoaders[i];\n    if (!bufferViewLoader.isDestroyed()) {\n      // Copy the typed array and let the underlying ArrayBuffer be freed\n      const bufferViewTypedArray = new Uint8Array(bufferViewLoader.typedArray);\n      bufferViews[bufferViewId] = bufferViewTypedArray;\n    }\n  }\n  const textures = {};\n  for (let i = 0; i < this._textureIds.length; ++i) {\n    const textureId = this._textureIds[i];\n    const textureLoader = textureLoaders[i];\n    if (!textureLoader.isDestroyed()) {\n      textures[textureId] = textureLoader.texture;\n    }\n  }\n  if (defined(this._extension)) {\n    this._structuralMetadata = parseStructuralMetadata({\n      extension: this._extension,\n      schema: schema,\n      bufferViews: bufferViews,\n      textures: textures\n    });\n  } else {\n    this._structuralMetadata = parseFeatureMetadataLegacy({\n      extension: this._extensionLegacy,\n      schema: schema,\n      bufferViews: bufferViews,\n      textures: textures\n    });\n  }\n\n  // Buffer views can be unloaded after the data has been copied\n  unloadBufferViews(this);\n  this._state = ResourceLoaderState.READY;\n  return true;\n};\nfunction unloadBufferViews(structuralMetadataLoader) {\n  const bufferViewLoaders = structuralMetadataLoader._bufferViewLoaders;\n  const bufferViewLoadersLength = bufferViewLoaders.length;\n  for (let i = 0; i < bufferViewLoadersLength; ++i) {\n    ResourceCache.unload(bufferViewLoaders[i]);\n  }\n  structuralMetadataLoader._bufferViewLoaders.length = 0;\n  structuralMetadataLoader._bufferViewIds.length = 0;\n}\nfunction unloadTextures(structuralMetadataLoader) {\n  const textureLoaders = structuralMetadataLoader._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  structuralMetadataLoader._textureLoaders.length = 0;\n  structuralMetadataLoader._textureIds.length = 0;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.unload = function () {\n  unloadBufferViews(this);\n  unloadTextures(this);\n  if (defined(this._schemaLoader)) {\n    ResourceCache.unload(this._schemaLoader);\n  }\n  this._schemaLoader = undefined;\n  this._structuralMetadata = undefined;\n};\nexport default GltfStructuralMetadataLoader;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","parseStructuralMetadata","parseFeatureMetadataLegacy","ResourceCache","ResourceLoader","ResourceLoaderState","GltfStructuralMetadataLoader","options","EMPTY_OBJECT","gltf","extension","extensionLegacy","gltfResource","baseResource","supportedImageFormats","frameState","cacheKey","asynchronous","typeOf","object","_gltfResource","_baseResource","_gltf","_extension","_extensionLegacy","_supportedImageFormats","_frameState","_cacheKey","_asynchronous","_bufferViewLoaders","_bufferViewIds","_textureLoaders","_textureIds","_schemaLoader","undefined","_structuralMetadata","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","structuralMetadata","loadResources","loader","bufferViewsPromise","loadBufferViews","texturesPromise","loadTextures","schemaPromise","loadSchema","Promise","all","isDestroyed","LOADED","error","unload","FAILED","errorMessage","getError","load","LOADING","gatherBufferViewIdsFromProperties","properties","bufferViewIdSet","propertyId","hasOwnProperty","property","values","arrayOffsets","stringOffsets","gatherBufferViewIdsFromPropertiesLegacy","bufferView","arrayOffsetBufferView","stringOffsetBufferView","gatherUsedBufferViewIds","propertyTables","i","length","propertyTable","gatherUsedBufferViewIdsLegacy","featureTables","featureTableId","featureTable","structuralMetadataLoader","bufferViewIds","bufferViewPromises","bufferViewId","bufferViewLoader","getBufferViewLoader","parseInt","push","gatherUsedTextureIds","structuralMetadataExtension","textureIds","propertyTextures","propertyTexture","gatherTextureIdsFromProperties","textureInfo","index","gatherUsedTextureIdsLegacy","featureTextures","featureTextureId","featureTexture","gatherTextureIdsFromPropertiesLegacy","texture","texturePromises","textureId","textureLoader","getTextureLoader","schemaLoader","schemaUri","resource","getDerivedResource","url","getSchemaLoader","schema","process","READY","textureLoaders","textureLoadersLength","ready","textureReady","bufferViews","bufferViewTypedArray","Uint8Array","typedArray","textures","unloadBufferViews","bufferViewLoaders","bufferViewLoadersLength","unloadTextures"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfStructuralMetadataLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport parseStructuralMetadata from \"./parseStructuralMetadata.js\";\nimport parseFeatureMetadataLegacy from \"./parseFeatureMetadataLegacy.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads glTF structural metadata\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfStructuralMetadataLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {string} [options.extension] The <code>EXT_structural_metadata</code> extension object. If this is undefined, then extensionLegacy must be defined.\n * @param {string} [options.extensionLegacy] The legacy <code>EXT_feature_metadata</code> extension for backwards compatibility.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction GltfStructuralMetadataLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    extension,\n    extensionLegacy,\n    gltfResource,\n    baseResource,\n    supportedImageFormats,\n    frameState,\n    cacheKey,\n    asynchronous = true,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n\n  if (!defined(options.extension) && !defined(options.extensionLegacy)) {\n    throw new DeveloperError(\n      \"One of options.extension or options.extensionLegacy must be specified\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._extension = extension;\n  this._extensionLegacy = extensionLegacy;\n  this._supportedImageFormats = supportedImageFormats;\n  this._frameState = frameState;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._bufferViewLoaders = [];\n  this._bufferViewIds = [];\n  this._textureLoaders = [];\n  this._textureIds = [];\n  this._schemaLoader = undefined;\n  this._structuralMetadata = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfStructuralMetadataLoader.prototype = Object.create(\n    ResourceLoader.prototype,\n  );\n  GltfStructuralMetadataLoader.prototype.constructor =\n    GltfStructuralMetadataLoader;\n}\n\nObject.defineProperties(GltfStructuralMetadataLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The parsed structural metadata\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._structuralMetadata;\n    },\n  },\n});\n\nasync function loadResources(loader) {\n  try {\n    const bufferViewsPromise = loadBufferViews(loader);\n    const texturesPromise = loadTextures(loader);\n    const schemaPromise = loadSchema(loader);\n\n    await Promise.all([bufferViewsPromise, texturesPromise, schemaPromise]);\n\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    loader._gltf = undefined; // No longer need to hold onto the glTF\n\n    loader._state = ResourceLoaderState.LOADED;\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    loader.unload();\n    loader._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load structural metadata\";\n    throw loader.getError(errorMessage, error);\n  }\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfStructuralMetadataLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = loadResources(this);\n  return this._promise;\n};\n\nfunction gatherBufferViewIdsFromProperties(properties, bufferViewIdSet) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const values = property.values;\n      const arrayOffsets = property.arrayOffsets;\n      const stringOffsets = property.stringOffsets;\n\n      // Using an object like a mathematical set\n      if (defined(values)) {\n        bufferViewIdSet[values] = true;\n      }\n      if (defined(arrayOffsets)) {\n        bufferViewIdSet[arrayOffsets] = true;\n      }\n      if (defined(stringOffsets)) {\n        bufferViewIdSet[stringOffsets] = true;\n      }\n    }\n  }\n}\n\nfunction gatherBufferViewIdsFromPropertiesLegacy(properties, bufferViewIdSet) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const bufferView = property.bufferView;\n      const arrayOffsetBufferView = property.arrayOffsetBufferView;\n      const stringOffsetBufferView = property.stringOffsetBufferView;\n\n      // Using an object like a mathematical set\n      if (defined(bufferView)) {\n        bufferViewIdSet[bufferView] = true;\n      }\n      if (defined(arrayOffsetBufferView)) {\n        bufferViewIdSet[arrayOffsetBufferView] = true;\n      }\n      if (defined(stringOffsetBufferView)) {\n        bufferViewIdSet[stringOffsetBufferView] = true;\n      }\n    }\n  }\n}\n\nfunction gatherUsedBufferViewIds(extension) {\n  const propertyTables = extension.propertyTables;\n  const bufferViewIdSet = {};\n  if (defined(propertyTables)) {\n    for (let i = 0; i < propertyTables.length; i++) {\n      const propertyTable = propertyTables[i];\n      gatherBufferViewIdsFromProperties(\n        propertyTable.properties,\n        bufferViewIdSet,\n      );\n    }\n  }\n  return bufferViewIdSet;\n}\n\nfunction gatherUsedBufferViewIdsLegacy(extensionLegacy) {\n  const featureTables = extensionLegacy.featureTables;\n\n  const bufferViewIdSet = {};\n  if (defined(featureTables)) {\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          gatherBufferViewIdsFromPropertiesLegacy(properties, bufferViewIdSet);\n        }\n      }\n    }\n  }\n  return bufferViewIdSet;\n}\n\nasync function loadBufferViews(structuralMetadataLoader) {\n  let bufferViewIds;\n  if (defined(structuralMetadataLoader._extension)) {\n    bufferViewIds = gatherUsedBufferViewIds(\n      structuralMetadataLoader._extension,\n    );\n  } else {\n    bufferViewIds = gatherUsedBufferViewIdsLegacy(\n      structuralMetadataLoader._extensionLegacy,\n    );\n  }\n\n  // Load the buffer views\n  const bufferViewPromises = [];\n  for (const bufferViewId in bufferViewIds) {\n    if (bufferViewIds.hasOwnProperty(bufferViewId)) {\n      const bufferViewLoader = ResourceCache.getBufferViewLoader({\n        gltf: structuralMetadataLoader._gltf,\n        bufferViewId: parseInt(bufferViewId),\n        gltfResource: structuralMetadataLoader._gltfResource,\n        baseResource: structuralMetadataLoader._baseResource,\n      });\n\n      structuralMetadataLoader._bufferViewLoaders.push(bufferViewLoader);\n      structuralMetadataLoader._bufferViewIds.push(bufferViewId);\n\n      bufferViewPromises.push(bufferViewLoader.load());\n    }\n  }\n\n  return Promise.all(bufferViewPromises);\n}\n\nfunction gatherUsedTextureIds(structuralMetadataExtension) {\n  // Gather the used textures\n  const textureIds = {};\n  const propertyTextures = structuralMetadataExtension.propertyTextures;\n  if (defined(propertyTextures)) {\n    for (let i = 0; i < propertyTextures.length; i++) {\n      const propertyTexture = propertyTextures[i];\n      const properties = propertyTexture.properties;\n      if (defined(properties)) {\n        gatherTextureIdsFromProperties(properties, textureIds);\n      }\n    }\n  }\n  return textureIds;\n}\n\nfunction gatherTextureIdsFromProperties(properties, textureIds) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      // in EXT_structural_metadata the property is a valid textureInfo.\n      const textureInfo = properties[propertyId];\n      textureIds[textureInfo.index] = textureInfo;\n    }\n  }\n}\n\nfunction gatherUsedTextureIdsLegacy(extensionLegacy) {\n  // Gather the used textures\n  const textureIds = {};\n  const featureTextures = extensionLegacy.featureTextures;\n  if (defined(featureTextures)) {\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          gatherTextureIdsFromPropertiesLegacy(properties, textureIds);\n        }\n      }\n    }\n  }\n\n  return textureIds;\n}\n\nfunction gatherTextureIdsFromPropertiesLegacy(properties, textureIds) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const textureInfo = property.texture;\n      textureIds[textureInfo.index] = textureInfo;\n    }\n  }\n}\n\nfunction loadTextures(structuralMetadataLoader) {\n  let textureIds;\n  if (defined(structuralMetadataLoader._extension)) {\n    textureIds = gatherUsedTextureIds(structuralMetadataLoader._extension);\n  } else {\n    textureIds = gatherUsedTextureIdsLegacy(\n      structuralMetadataLoader._extensionLegacy,\n    );\n  }\n\n  const gltf = structuralMetadataLoader._gltf;\n  const gltfResource = structuralMetadataLoader._gltfResource;\n  const baseResource = structuralMetadataLoader._baseResource;\n  const supportedImageFormats = structuralMetadataLoader._supportedImageFormats;\n  const frameState = structuralMetadataLoader._frameState;\n  const asynchronous = structuralMetadataLoader._asynchronous;\n\n  // Load the textures\n  const texturePromises = [];\n  for (const textureId in textureIds) {\n    if (textureIds.hasOwnProperty(textureId)) {\n      const textureLoader = ResourceCache.getTextureLoader({\n        gltf: gltf,\n        textureInfo: textureIds[textureId],\n        gltfResource: gltfResource,\n        baseResource: baseResource,\n        supportedImageFormats: supportedImageFormats,\n        frameState: frameState,\n        asynchronous: asynchronous,\n      });\n      structuralMetadataLoader._textureLoaders.push(textureLoader);\n      structuralMetadataLoader._textureIds.push(textureId);\n      texturePromises.push(textureLoader.load());\n    }\n  }\n\n  return Promise.all(texturePromises);\n}\n\nasync function loadSchema(structuralMetadataLoader) {\n  const extension = defaultValue(\n    structuralMetadataLoader._extension,\n    structuralMetadataLoader._extensionLegacy,\n  );\n\n  let schemaLoader;\n  if (defined(extension.schemaUri)) {\n    const resource = structuralMetadataLoader._baseResource.getDerivedResource({\n      url: extension.schemaUri,\n    });\n    schemaLoader = ResourceCache.getSchemaLoader({\n      resource: resource,\n    });\n  } else {\n    schemaLoader = ResourceCache.getSchemaLoader({\n      schema: extension.schema,\n    });\n  }\n\n  structuralMetadataLoader._schemaLoader = schemaLoader;\n  await schemaLoader.load();\n  if (!schemaLoader.isDestroyed()) {\n    return schemaLoader.schema;\n  }\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state !== ResourceLoaderState.LOADED) {\n    return false;\n  }\n\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  let ready = true;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    const textureLoader = textureLoaders[i];\n    const textureReady = textureLoader.process(frameState);\n    ready = ready && textureReady;\n  }\n\n  if (!ready) {\n    return false;\n  }\n\n  const schema = this._schemaLoader.schema;\n  const bufferViews = {};\n  for (let i = 0; i < this._bufferViewIds.length; ++i) {\n    const bufferViewId = this._bufferViewIds[i];\n    const bufferViewLoader = this._bufferViewLoaders[i];\n    if (!bufferViewLoader.isDestroyed()) {\n      // Copy the typed array and let the underlying ArrayBuffer be freed\n      const bufferViewTypedArray = new Uint8Array(bufferViewLoader.typedArray);\n      bufferViews[bufferViewId] = bufferViewTypedArray;\n    }\n  }\n\n  const textures = {};\n  for (let i = 0; i < this._textureIds.length; ++i) {\n    const textureId = this._textureIds[i];\n    const textureLoader = textureLoaders[i];\n    if (!textureLoader.isDestroyed()) {\n      textures[textureId] = textureLoader.texture;\n    }\n  }\n  if (defined(this._extension)) {\n    this._structuralMetadata = parseStructuralMetadata({\n      extension: this._extension,\n      schema: schema,\n      bufferViews: bufferViews,\n      textures: textures,\n    });\n  } else {\n    this._structuralMetadata = parseFeatureMetadataLegacy({\n      extension: this._extensionLegacy,\n      schema: schema,\n      bufferViews: bufferViews,\n      textures: textures,\n    });\n  }\n\n  // Buffer views can be unloaded after the data has been copied\n  unloadBufferViews(this);\n\n  this._state = ResourceLoaderState.READY;\n  return true;\n};\n\nfunction unloadBufferViews(structuralMetadataLoader) {\n  const bufferViewLoaders = structuralMetadataLoader._bufferViewLoaders;\n  const bufferViewLoadersLength = bufferViewLoaders.length;\n  for (let i = 0; i < bufferViewLoadersLength; ++i) {\n    ResourceCache.unload(bufferViewLoaders[i]);\n  }\n  structuralMetadataLoader._bufferViewLoaders.length = 0;\n  structuralMetadataLoader._bufferViewIds.length = 0;\n}\n\nfunction unloadTextures(structuralMetadataLoader) {\n  const textureLoaders = structuralMetadataLoader._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  structuralMetadataLoader._textureLoaders.length = 0;\n  structuralMetadataLoader._textureIds.length = 0;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.unload = function () {\n  unloadBufferViews(this);\n  unloadTextures(this);\n\n  if (defined(this._schemaLoader)) {\n    ResourceCache.unload(this._schemaLoader);\n  }\n  this._schemaLoader = undefined;\n\n  this._structuralMetadata = undefined;\n};\n\nexport default GltfStructuralMetadataLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}