{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nconst defaultScale = 1.0;\nconst defaultFont = \"30px sans-serif\";\nconst defaultStyle = LabelStyle.FILL;\nconst defaultFillColor = Color.WHITE;\nconst defaultOutlineColor = Color.BLACK;\nconst defaultOutlineWidth = 1.0;\nconst defaultShowBackground = false;\nconst defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\nconst defaultBackgroundPadding = new Cartesian2(7, 5);\nconst defaultPixelOffset = Cartesian2.ZERO;\nconst defaultEyeOffset = Cartesian3.ZERO;\nconst defaultHeightReference = HeightReference.NONE;\nconst defaultHorizontalOrigin = HorizontalOrigin.CENTER;\nconst defaultVerticalOrigin = VerticalOrigin.CENTER;\nconst positionScratch = new Cartesian3();\nconst fillColorScratch = new Color();\nconst outlineColorScratch = new Color();\nconst backgroundColorScratch = new Color();\nconst backgroundPaddingScratch = new Cartesian2();\nconst eyeOffsetScratch = new Cartesian3();\nconst pixelOffsetScratch = new Cartesian2();\nconst translucencyByDistanceScratch = new NearFarScalar();\nconst pixelOffsetScaleByDistanceScratch = new NearFarScalar();\nconst scaleByDistanceScratch = new NearFarScalar();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.label = undefined;\n  this.index = undefined;\n}\n\n/**\n * A {@link Visualizer} which maps the {@link LabelGraphics} instance\n * in {@link Entity#label} to a {@link Label}.\n * @alias LabelVisualizer\n * @constructor\n *\n * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction LabelVisualizer(entityCluster, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entityCluster)) {\n    throw new DeveloperError(\"entityCluster is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n  this._cluster = entityCluster;\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nLabelVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const items = this._items.values;\n  const cluster = this._cluster;\n  for (let i = 0, len = items.length; i < len; i++) {\n    const item = items[i];\n    const entity = item.entity;\n    const labelGraphics = entity._label;\n    let text;\n    let label = item.label;\n    let show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);\n    let position;\n    if (show) {\n      position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n      text = Property.getValueOrUndefined(labelGraphics._text, time);\n      show = defined(position) && defined(text);\n    }\n    if (!show) {\n      //don't bother creating or updating anything else\n      returnPrimitive(item, entity, cluster);\n      continue;\n    }\n    if (!Property.isConstant(entity._position)) {\n      cluster._clusterDirty = true;\n    }\n    let updateClamping = false;\n    const heightReference = Property.getValueOrDefault(labelGraphics._heightReference, time, defaultHeightReference);\n    if (!defined(label)) {\n      label = cluster.getLabel(entity);\n      label.id = entity;\n      item.label = label;\n\n      // If this new label happens to have a position and height reference that match our new values,\n      // label._updateClamping will not be called automatically. That's a problem because the clamped\n      // height may be based on different terrain than is now loaded. So we'll manually call\n      // _updateClamping below.\n      updateClamping = Cartesian3.equals(label.position, position) && label.heightReference === heightReference;\n    }\n    label.show = true;\n    label.position = position;\n    label.text = text;\n    label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);\n    label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);\n    label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);\n    label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColorScratch);\n    label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n    label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);\n    label.showBackground = Property.getValueOrDefault(labelGraphics._showBackground, time, defaultShowBackground);\n    label.backgroundColor = Property.getValueOrDefault(labelGraphics._backgroundColor, time, defaultBackgroundColor, backgroundColorScratch);\n    label.backgroundPadding = Property.getValueOrDefault(labelGraphics._backgroundPadding, time, defaultBackgroundPadding, backgroundPaddingScratch);\n    label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n    label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n    label.heightReference = heightReference;\n    label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n    label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);\n    label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n    label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n    label.scaleByDistance = Property.getValueOrUndefined(labelGraphics._scaleByDistance, time, scaleByDistanceScratch);\n    label.distanceDisplayCondition = Property.getValueOrUndefined(labelGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n    label.disableDepthTestDistance = Property.getValueOrUndefined(labelGraphics._disableDepthTestDistance, time);\n    if (updateClamping) {\n      label._updateClamping();\n    }\n  }\n  return true;\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nLabelVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const item = this._items.get(entity.id);\n  if (!defined(item) || !defined(item.label)) {\n    return BoundingSphereState.FAILED;\n  }\n  const label = item.label;\n  result.center = Cartesian3.clone(defaultValue(label._clampedPosition, label.position), result.center);\n  result.radius = 0;\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nLabelVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nLabelVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n  const entities = this._entityCollection.values;\n  for (let i = 0; i < entities.length; i++) {\n    this._cluster.removeLabel(entities[i]);\n  }\n  return destroyObject(this);\n};\nLabelVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  let i;\n  let entity;\n  const items = this._items;\n  const cluster = this._cluster;\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._label) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._label) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      returnPrimitive(items.get(entity.id), entity, cluster);\n      items.remove(entity.id);\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    returnPrimitive(items.get(entity.id), entity, cluster);\n    items.remove(entity.id);\n  }\n};\nfunction returnPrimitive(item, entity, cluster) {\n  if (defined(item)) {\n    item.label = undefined;\n    cluster.removeLabel(entity);\n  }\n}\nexport default LabelVisualizer;","map":{"version":3,"names":["AssociativeArray","Cartesian2","Cartesian3","Color","defaultValue","defined","destroyObject","DeveloperError","DistanceDisplayCondition","NearFarScalar","HeightReference","HorizontalOrigin","LabelStyle","VerticalOrigin","BoundingSphereState","Property","defaultScale","defaultFont","defaultStyle","FILL","defaultFillColor","WHITE","defaultOutlineColor","BLACK","defaultOutlineWidth","defaultShowBackground","defaultBackgroundColor","defaultBackgroundPadding","defaultPixelOffset","ZERO","defaultEyeOffset","defaultHeightReference","NONE","defaultHorizontalOrigin","CENTER","defaultVerticalOrigin","positionScratch","fillColorScratch","outlineColorScratch","backgroundColorScratch","backgroundPaddingScratch","eyeOffsetScratch","pixelOffsetScratch","translucencyByDistanceScratch","pixelOffsetScaleByDistanceScratch","scaleByDistanceScratch","distanceDisplayConditionScratch","EntityData","entity","label","undefined","index","LabelVisualizer","entityCluster","entityCollection","collectionChanged","addEventListener","prototype","_onCollectionChanged","_cluster","_entityCollection","_items","values","update","time","items","cluster","i","len","length","item","labelGraphics","_label","text","show","isShowing","isAvailable","getValueOrDefault","_show","position","getValueOrUndefined","_position","_text","returnPrimitive","isConstant","_clusterDirty","updateClamping","heightReference","_heightReference","getLabel","id","equals","scale","_scale","font","_font","style","_style","fillColor","_fillColor","outlineColor","_outlineColor","outlineWidth","_outlineWidth","showBackground","_showBackground","backgroundColor","_backgroundColor","backgroundPadding","_backgroundPadding","pixelOffset","_pixelOffset","eyeOffset","_eyeOffset","horizontalOrigin","_horizontalOrigin","verticalOrigin","_verticalOrigin","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","scaleByDistance","_scaleByDistance","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","_updateClamping","getBoundingSphere","result","get","FAILED","center","clone","_clampedPosition","radius","DONE","isDestroyed","destroy","removeEventListener","entities","removeLabel","added","removed","changed","set","contains","remove"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/LabelVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\n\nconst defaultScale = 1.0;\nconst defaultFont = \"30px sans-serif\";\nconst defaultStyle = LabelStyle.FILL;\nconst defaultFillColor = Color.WHITE;\nconst defaultOutlineColor = Color.BLACK;\nconst defaultOutlineWidth = 1.0;\nconst defaultShowBackground = false;\nconst defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\nconst defaultBackgroundPadding = new Cartesian2(7, 5);\nconst defaultPixelOffset = Cartesian2.ZERO;\nconst defaultEyeOffset = Cartesian3.ZERO;\nconst defaultHeightReference = HeightReference.NONE;\nconst defaultHorizontalOrigin = HorizontalOrigin.CENTER;\nconst defaultVerticalOrigin = VerticalOrigin.CENTER;\n\nconst positionScratch = new Cartesian3();\nconst fillColorScratch = new Color();\nconst outlineColorScratch = new Color();\nconst backgroundColorScratch = new Color();\nconst backgroundPaddingScratch = new Cartesian2();\nconst eyeOffsetScratch = new Cartesian3();\nconst pixelOffsetScratch = new Cartesian2();\nconst translucencyByDistanceScratch = new NearFarScalar();\nconst pixelOffsetScaleByDistanceScratch = new NearFarScalar();\nconst scaleByDistanceScratch = new NearFarScalar();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.label = undefined;\n  this.index = undefined;\n}\n\n/**\n * A {@link Visualizer} which maps the {@link LabelGraphics} instance\n * in {@link Entity#label} to a {@link Label}.\n * @alias LabelVisualizer\n * @constructor\n *\n * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction LabelVisualizer(entityCluster, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entityCluster)) {\n    throw new DeveloperError(\"entityCluster is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    LabelVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n\n  this._cluster = entityCluster;\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nLabelVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const items = this._items.values;\n  const cluster = this._cluster;\n\n  for (let i = 0, len = items.length; i < len; i++) {\n    const item = items[i];\n    const entity = item.entity;\n    const labelGraphics = entity._label;\n    let text;\n    let label = item.label;\n    let show =\n      entity.isShowing &&\n      entity.isAvailable(time) &&\n      Property.getValueOrDefault(labelGraphics._show, time, true);\n    let position;\n    if (show) {\n      position = Property.getValueOrUndefined(\n        entity._position,\n        time,\n        positionScratch,\n      );\n      text = Property.getValueOrUndefined(labelGraphics._text, time);\n      show = defined(position) && defined(text);\n    }\n\n    if (!show) {\n      //don't bother creating or updating anything else\n      returnPrimitive(item, entity, cluster);\n      continue;\n    }\n\n    if (!Property.isConstant(entity._position)) {\n      cluster._clusterDirty = true;\n    }\n\n    let updateClamping = false;\n    const heightReference = Property.getValueOrDefault(\n      labelGraphics._heightReference,\n      time,\n      defaultHeightReference,\n    );\n\n    if (!defined(label)) {\n      label = cluster.getLabel(entity);\n      label.id = entity;\n      item.label = label;\n\n      // If this new label happens to have a position and height reference that match our new values,\n      // label._updateClamping will not be called automatically. That's a problem because the clamped\n      // height may be based on different terrain than is now loaded. So we'll manually call\n      // _updateClamping below.\n      updateClamping =\n        Cartesian3.equals(label.position, position) &&\n        label.heightReference === heightReference;\n    }\n\n    label.show = true;\n    label.position = position;\n    label.text = text;\n    label.scale = Property.getValueOrDefault(\n      labelGraphics._scale,\n      time,\n      defaultScale,\n    );\n    label.font = Property.getValueOrDefault(\n      labelGraphics._font,\n      time,\n      defaultFont,\n    );\n    label.style = Property.getValueOrDefault(\n      labelGraphics._style,\n      time,\n      defaultStyle,\n    );\n    label.fillColor = Property.getValueOrDefault(\n      labelGraphics._fillColor,\n      time,\n      defaultFillColor,\n      fillColorScratch,\n    );\n    label.outlineColor = Property.getValueOrDefault(\n      labelGraphics._outlineColor,\n      time,\n      defaultOutlineColor,\n      outlineColorScratch,\n    );\n    label.outlineWidth = Property.getValueOrDefault(\n      labelGraphics._outlineWidth,\n      time,\n      defaultOutlineWidth,\n    );\n    label.showBackground = Property.getValueOrDefault(\n      labelGraphics._showBackground,\n      time,\n      defaultShowBackground,\n    );\n    label.backgroundColor = Property.getValueOrDefault(\n      labelGraphics._backgroundColor,\n      time,\n      defaultBackgroundColor,\n      backgroundColorScratch,\n    );\n    label.backgroundPadding = Property.getValueOrDefault(\n      labelGraphics._backgroundPadding,\n      time,\n      defaultBackgroundPadding,\n      backgroundPaddingScratch,\n    );\n    label.pixelOffset = Property.getValueOrDefault(\n      labelGraphics._pixelOffset,\n      time,\n      defaultPixelOffset,\n      pixelOffsetScratch,\n    );\n    label.eyeOffset = Property.getValueOrDefault(\n      labelGraphics._eyeOffset,\n      time,\n      defaultEyeOffset,\n      eyeOffsetScratch,\n    );\n    label.heightReference = heightReference;\n    label.horizontalOrigin = Property.getValueOrDefault(\n      labelGraphics._horizontalOrigin,\n      time,\n      defaultHorizontalOrigin,\n    );\n    label.verticalOrigin = Property.getValueOrDefault(\n      labelGraphics._verticalOrigin,\n      time,\n      defaultVerticalOrigin,\n    );\n    label.translucencyByDistance = Property.getValueOrUndefined(\n      labelGraphics._translucencyByDistance,\n      time,\n      translucencyByDistanceScratch,\n    );\n    label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(\n      labelGraphics._pixelOffsetScaleByDistance,\n      time,\n      pixelOffsetScaleByDistanceScratch,\n    );\n    label.scaleByDistance = Property.getValueOrUndefined(\n      labelGraphics._scaleByDistance,\n      time,\n      scaleByDistanceScratch,\n    );\n    label.distanceDisplayCondition = Property.getValueOrUndefined(\n      labelGraphics._distanceDisplayCondition,\n      time,\n      distanceDisplayConditionScratch,\n    );\n    label.disableDepthTestDistance = Property.getValueOrUndefined(\n      labelGraphics._disableDepthTestDistance,\n      time,\n    );\n\n    if (updateClamping) {\n      label._updateClamping();\n    }\n  }\n  return true;\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nLabelVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const item = this._items.get(entity.id);\n  if (!defined(item) || !defined(item.label)) {\n    return BoundingSphereState.FAILED;\n  }\n\n  const label = item.label;\n  result.center = Cartesian3.clone(\n    defaultValue(label._clampedPosition, label.position),\n    result.center,\n  );\n  result.radius = 0;\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nLabelVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nLabelVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    LabelVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  const entities = this._entityCollection.values;\n  for (let i = 0; i < entities.length; i++) {\n    this._cluster.removeLabel(entities[i]);\n  }\n  return destroyObject(this);\n};\n\nLabelVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed,\n) {\n  let i;\n  let entity;\n  const items = this._items;\n  const cluster = this._cluster;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._label) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._label) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      returnPrimitive(items.get(entity.id), entity, cluster);\n      items.remove(entity.id);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    returnPrimitive(items.get(entity.id), entity, cluster);\n    items.remove(entity.id);\n  }\n};\n\nfunction returnPrimitive(item, entity, cluster) {\n  if (defined(item)) {\n    item.label = undefined;\n    cluster.removeLabel(entity);\n  }\n}\nexport default LabelVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}