{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nconst scratchCartesian1 = new Cartesian3();\nlet boundingSphereCenter = new Cartesian3();\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n  boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n  const boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n  const positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\n    })\n  });\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices\n  };\n}\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n  topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n  topBoundingSphere.radius = semiMajorAxis;\n  scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n  bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n  bottomBoundingSphere.radius = semiMajorAxis;\n  let positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\n    })\n  });\n  positions = attributes.position.values;\n  const boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n  let length = positions.length / 3;\n  if (defined(options.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, length / 2);\n    } else {\n      const offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n  let numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length / 2);\n  const indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\n  length /= 2;\n  let index = 0;\n  let i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = (i + 1) % length + length;\n  }\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n    const maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\"semiMajorAxis must be greater than or equal to the semiMinorAxis.\");\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (ellipseGeometry._semiMajorAxis <= 0.0 || ellipseGeometry._semiMinorAxis <= 0.0) {\n    return;\n  }\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute\n  });\n};\nexport default EllipseOutlineGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","ComponentDatatype","defaultValue","defined","DeveloperError","EllipseGeometryLibrary","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PrimitiveType","scratchCartesian1","boundingSphereCenter","computeEllipse","options","center","multiplyByScalar","ellipsoid","geodeticSurfaceNormal","height","add","boundingSphere","semiMajorAxis","positions","computeEllipsePositions","outerPositions","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","raisePositionsToHeight","length","indices","createTypedArray","index","i","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","scaledNormal","radius","extrudedHeight","union","offsetAttribute","applyOffset","Uint8Array","TOP","fill","offsetValue","NONE","UNSIGNED_BYTE","numberOfVerticalLines","clamp","numSide","numSideLines","Math","min","round","maxI","EllipseOutlineGeometry","EMPTY_OBJECT","default","semiMinorAxis","granularity","RADIANS_PER_DEGREE","_center","clone","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","rotation","_height","max","_granularity","_extrudedHeight","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchOptions","undefined","unpack","result","createGeometry","ellipseGeometry","extrude","equalsEpsilon","EPSILON2","scaleToGeodeticSurface","geometry","primitiveType","LINES"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EllipseOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter,\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter,\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis,\n  );\n  const positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true,\n  ).outerPositions;\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        false,\n      ),\n    }),\n  });\n\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1,\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center,\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal,\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center,\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  let positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true,\n  ).outerPositions;\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        true,\n      ),\n    }),\n  });\n\n  positions = attributes.position.values;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere,\n  );\n  let length = positions.length / 3;\n\n  if (defined(options.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, length / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = CesiumMath.clamp(\n    numberOfVerticalLines,\n    0,\n    length / 2,\n  );\n\n  const indices = IndexDatatype.createTypedArray(\n    length,\n    length * 2 + numberOfVerticalLines * 2,\n  );\n\n  length /= 2;\n  let index = 0;\n  let i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n\n    const maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\",\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0,\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipseOutlineGeometry.packedLength =\n  Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center,\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\nexport default EllipseOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}