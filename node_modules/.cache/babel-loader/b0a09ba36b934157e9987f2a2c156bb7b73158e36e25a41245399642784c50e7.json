{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\\n\\\n*/\\n\\\n\\n\\\nuniform vec3 u_ellipsoidRadiiUv; // [0,1]\\n\\\nuniform vec2 u_evoluteScale; // (radiiUv.x ^ 2 - radiiUv.z ^ 2) * vec2(1.0, -1.0) / radiiUv;\\n\\\nuniform vec3 u_ellipsoidInverseRadiiSquaredUv;\\n\\\n#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY) || defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY) || defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)\\n\\\n    uniform vec3 u_ellipsoidShapeUvLongitudeMinMaxMid;\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n    uniform vec2 u_ellipsoidUvToShapeUvLongitude; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n    uniform vec2 u_ellipsoidUvToShapeUvLatitude; // x = scale, y = offset\\n\\\n#endif\\n\\\nuniform float u_ellipsoidInverseHeightDifferenceUv;\\n\\\n\\n\\\n// robust iterative solution without trig functions\\n\\\n// https://github.com/0xfaded/ellipse_demo/issues/1\\n\\\n// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\\n\\\n// Extended to return radius of curvature along with the point\\n\\\nvec3 nearestPointAndRadiusOnEllipse(vec2 pos, vec2 radii) {\\n\\\n    vec2 p = abs(pos);\\n\\\n    vec2 inverseRadii = 1.0 / radii;\\n\\\n\\n\\\n    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\\n\\\n    // but store the cos and sin of t in a vec2 for efficiency.\\n\\\n    // Initial guess: t = pi/4\\n\\\n    vec2 tTrigs = vec2(0.7071067811865476);\\n\\\n    // Initial guess of point on ellipsoid\\n\\\n    vec2 v = radii * tTrigs;\\n\\\n    // Center of curvature of the ellipse at v\\n\\\n    vec2 evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n\\n\\\n    const int iterations = 3;\\n\\\n    for (int i = 0; i < iterations; ++i) {\\n\\\n        // Find the (approximate) intersection of p - evolute with the ellipsoid.\\n\\\n        vec2 q = normalize(p - evolute) * length(v - evolute);\\n\\\n        // Update the estimate of t.\\n\\\n        tTrigs = (q + evolute) * inverseRadii;\\n\\\n        tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));\\n\\\n        v = radii * tTrigs;\\n\\\n        evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n    }\\n\\\n\\n\\\n    return vec3(v * sign(pos), length(v - evolute));\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {\\n\\\n    // Convert from UV space [0, 1] to local space [-1, 1]\\n\\\n    vec3 position = positionUv * 2.0 - 1.0;\\n\\\n    // Undo the scaling from ellipsoid to sphere\\n\\\n    position = position * u_ellipsoidRadiiUv;\\n\\\n\\n\\\n    float longitude = atan(position.y, position.x);\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n\\n\\\n    // Convert the 3D position to a 2D position relative to the ellipse (radii.x, radii.z)\\n\\\n    // (assume radii.y == radii.x) and find the nearest point on the ellipse and its normal\\n\\\n    float distanceFromZAxis = length(position.xy);\\n\\\n    vec2 posEllipse = vec2(distanceFromZAxis, position.z);\\n\\\n    vec3 surfacePointAndRadius = nearestPointAndRadiusOnEllipse(posEllipse, u_ellipsoidRadiiUv.xz);\\n\\\n    vec2 surfacePoint = surfacePointAndRadius.xy;\\n\\\n\\n\\\n    vec2 normal2d = normalize(surfacePoint * u_ellipsoidInverseRadiiSquaredUv.xz);\\n\\\n    float latitude = atan(normal2d.y, normal2d.x);\\n\\\n    vec3 north = vec3(-normal2d.y * normalize(position.xy), abs(normal2d.x));\\n\\\n\\n\\\n    float heightSign = length(posEllipse) < length(surfacePoint) ? -1.0 : 1.0;\\n\\\n    float height = heightSign * length(posEllipse - surfacePoint);\\n\\\n    vec3 up = normalize(cross(east, north));\\n\\\n\\n\\\n    vec3 point = vec3(longitude, latitude, height);\\n\\\n    mat3 jacobianT = mat3(east / distanceFromZAxis, north / (surfacePointAndRadius.z + height), up);\\n\\\n    return PointJacobianT(point, jacobianT);\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeToShapeUvSpace(in vec3 positionShape) {\\n\\\n    // Longitude: shift & scale to [0, 1]\\n\\\n    float longitude = (positionShape.x + czm_pi) / czm_twoPi;\\n\\\n\\n\\\n    // Correct the angle when max < min\\n\\\n    // Technically this should compare against min longitude - but it has precision problems so compare against the middle of empty space.\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)\\n\\\n        longitude += float(longitude < u_ellipsoidShapeUvLongitudeMinMaxMid.z);\\n\\\n    #endif\\n\\\n\\n\\\n    // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity.\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY)\\n\\\n        longitude = longitude > u_ellipsoidShapeUvLongitudeMinMaxMid.z ? u_ellipsoidShapeUvLongitudeMinMaxMid.x : longitude;\\n\\\n    #endif\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY)\\n\\\n        longitude = longitude < u_ellipsoidShapeUvLongitudeMinMaxMid.z ? u_ellipsoidShapeUvLongitudeMinMaxMid.y : longitude;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n        longitude = longitude * u_ellipsoidUvToShapeUvLongitude.x + u_ellipsoidUvToShapeUvLongitude.y;\\n\\\n    #endif\\n\\\n\\n\\\n    // Latitude: shift and scale to [0, 1]\\n\\\n    float latitude = (positionShape.y + czm_piOverTwo) / czm_pi;\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n        latitude = latitude * u_ellipsoidUvToShapeUvLatitude.x + u_ellipsoidUvToShapeUvLatitude.y;\\n\\\n    #endif\\n\\\n\\n\\\n    // Height: scale to the range [0, 1]\\n\\\n    float height = 1.0 + positionShape.z * u_ellipsoidInverseHeightDifferenceUv;\\n\\\n\\n\\\n    return vec3(longitude, latitude, height);\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);\\n\\\n    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);\\n\\\n    return pointJacobian;\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    // Convert from [0, 1] to radians [-pi, pi]\\n\\\n    float longitude = shapeUv.x * czm_twoPi;\\n\\\n    #if defined (ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n        longitude /= u_ellipsoidUvToShapeUvLongitude.x;\\n\\\n    #endif\\n\\\n\\n\\\n    // Convert from [0, 1] to radians [-pi/2, pi/2]\\n\\\n    float latitude = shapeUv.y * czm_pi;\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n        latitude /= u_ellipsoidUvToShapeUvLatitude.x;\\n\\\n    #endif\\n\\\n    \\n\\\n    float height = shapeUv.z / u_ellipsoidInverseHeightDifferenceUv;\\n\\\n\\n\\\n    return vec3(longitude, latitude, height);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/convertUvToEllipsoid.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\\n\\\n*/\\n\\\n\\n\\\nuniform vec3 u_ellipsoidRadiiUv; // [0,1]\\n\\\nuniform vec2 u_evoluteScale; // (radiiUv.x ^ 2 - radiiUv.z ^ 2) * vec2(1.0, -1.0) / radiiUv;\\n\\\nuniform vec3 u_ellipsoidInverseRadiiSquaredUv;\\n\\\n#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY) || defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY) || defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)\\n\\\n    uniform vec3 u_ellipsoidShapeUvLongitudeMinMaxMid;\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n    uniform vec2 u_ellipsoidUvToShapeUvLongitude; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n    uniform vec2 u_ellipsoidUvToShapeUvLatitude; // x = scale, y = offset\\n\\\n#endif\\n\\\nuniform float u_ellipsoidInverseHeightDifferenceUv;\\n\\\n\\n\\\n// robust iterative solution without trig functions\\n\\\n// https://github.com/0xfaded/ellipse_demo/issues/1\\n\\\n// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\\n\\\n// Extended to return radius of curvature along with the point\\n\\\nvec3 nearestPointAndRadiusOnEllipse(vec2 pos, vec2 radii) {\\n\\\n    vec2 p = abs(pos);\\n\\\n    vec2 inverseRadii = 1.0 / radii;\\n\\\n\\n\\\n    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\\n\\\n    // but store the cos and sin of t in a vec2 for efficiency.\\n\\\n    // Initial guess: t = pi/4\\n\\\n    vec2 tTrigs = vec2(0.7071067811865476);\\n\\\n    // Initial guess of point on ellipsoid\\n\\\n    vec2 v = radii * tTrigs;\\n\\\n    // Center of curvature of the ellipse at v\\n\\\n    vec2 evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n\\n\\\n    const int iterations = 3;\\n\\\n    for (int i = 0; i < iterations; ++i) {\\n\\\n        // Find the (approximate) intersection of p - evolute with the ellipsoid.\\n\\\n        vec2 q = normalize(p - evolute) * length(v - evolute);\\n\\\n        // Update the estimate of t.\\n\\\n        tTrigs = (q + evolute) * inverseRadii;\\n\\\n        tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));\\n\\\n        v = radii * tTrigs;\\n\\\n        evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n    }\\n\\\n\\n\\\n    return vec3(v * sign(pos), length(v - evolute));\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {\\n\\\n    // Convert from UV space [0, 1] to local space [-1, 1]\\n\\\n    vec3 position = positionUv * 2.0 - 1.0;\\n\\\n    // Undo the scaling from ellipsoid to sphere\\n\\\n    position = position * u_ellipsoidRadiiUv;\\n\\\n\\n\\\n    float longitude = atan(position.y, position.x);\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n\\n\\\n    // Convert the 3D position to a 2D position relative to the ellipse (radii.x, radii.z)\\n\\\n    // (assume radii.y == radii.x) and find the nearest point on the ellipse and its normal\\n\\\n    float distanceFromZAxis = length(position.xy);\\n\\\n    vec2 posEllipse = vec2(distanceFromZAxis, position.z);\\n\\\n    vec3 surfacePointAndRadius = nearestPointAndRadiusOnEllipse(posEllipse, u_ellipsoidRadiiUv.xz);\\n\\\n    vec2 surfacePoint = surfacePointAndRadius.xy;\\n\\\n\\n\\\n    vec2 normal2d = normalize(surfacePoint * u_ellipsoidInverseRadiiSquaredUv.xz);\\n\\\n    float latitude = atan(normal2d.y, normal2d.x);\\n\\\n    vec3 north = vec3(-normal2d.y * normalize(position.xy), abs(normal2d.x));\\n\\\n\\n\\\n    float heightSign = length(posEllipse) < length(surfacePoint) ? -1.0 : 1.0;\\n\\\n    float height = heightSign * length(posEllipse - surfacePoint);\\n\\\n    vec3 up = normalize(cross(east, north));\\n\\\n\\n\\\n    vec3 point = vec3(longitude, latitude, height);\\n\\\n    mat3 jacobianT = mat3(east / distanceFromZAxis, north / (surfacePointAndRadius.z + height), up);\\n\\\n    return PointJacobianT(point, jacobianT);\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeToShapeUvSpace(in vec3 positionShape) {\\n\\\n    // Longitude: shift & scale to [0, 1]\\n\\\n    float longitude = (positionShape.x + czm_pi) / czm_twoPi;\\n\\\n\\n\\\n    // Correct the angle when max < min\\n\\\n    // Technically this should compare against min longitude - but it has precision problems so compare against the middle of empty space.\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)\\n\\\n        longitude += float(longitude < u_ellipsoidShapeUvLongitudeMinMaxMid.z);\\n\\\n    #endif\\n\\\n\\n\\\n    // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity.\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY)\\n\\\n        longitude = longitude > u_ellipsoidShapeUvLongitudeMinMaxMid.z ? u_ellipsoidShapeUvLongitudeMinMaxMid.x : longitude;\\n\\\n    #endif\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY)\\n\\\n        longitude = longitude < u_ellipsoidShapeUvLongitudeMinMaxMid.z ? u_ellipsoidShapeUvLongitudeMinMaxMid.y : longitude;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n        longitude = longitude * u_ellipsoidUvToShapeUvLongitude.x + u_ellipsoidUvToShapeUvLongitude.y;\\n\\\n    #endif\\n\\\n\\n\\\n    // Latitude: shift and scale to [0, 1]\\n\\\n    float latitude = (positionShape.y + czm_piOverTwo) / czm_pi;\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n        latitude = latitude * u_ellipsoidUvToShapeUvLatitude.x + u_ellipsoidUvToShapeUvLatitude.y;\\n\\\n    #endif\\n\\\n\\n\\\n    // Height: scale to the range [0, 1]\\n\\\n    float height = 1.0 + positionShape.z * u_ellipsoidInverseHeightDifferenceUv;\\n\\\n\\n\\\n    return vec3(longitude, latitude, height);\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);\\n\\\n    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);\\n\\\n    return pointJacobian;\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    // Convert from [0, 1] to radians [-pi, pi]\\n\\\n    float longitude = shapeUv.x * czm_twoPi;\\n\\\n    #if defined (ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n        longitude /= u_ellipsoidUvToShapeUvLongitude.x;\\n\\\n    #endif\\n\\\n\\n\\\n    // Convert from [0, 1] to radians [-pi/2, pi/2]\\n\\\n    float latitude = shapeUv.y * czm_pi;\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n        latitude /= u_ellipsoidUvToShapeUvLatitude.x;\\n\\\n    #endif\\n\\\n    \\n\\\n    float height = shapeUv.z / u_ellipsoidInverseHeightDifferenceUv;\\n\\\n\\n\\\n    return vec3(longitude, latitude, height);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}