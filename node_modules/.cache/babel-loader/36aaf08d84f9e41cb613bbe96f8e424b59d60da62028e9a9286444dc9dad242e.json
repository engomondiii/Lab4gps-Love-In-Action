{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport PolygonHierarchy from \"./PolygonHierarchy.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nconst PolygonGeometryLibrary = {};\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (polygonHierarchy, CartesianX) {\n  let numComponents = 0;\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n    numComponents += 2;\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n    if (defined(positions) && positions.length > 0) {\n      numComponents += positions.length * CartesianX.packedLength;\n    }\n    if (defined(holes)) {\n      const length = holes.length;\n      for (let i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n  return numComponents;\n};\nPolygonGeometryLibrary.packPolygonHierarchy = function (polygonHierarchy, array, startingIndex, CartesianX) {\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n    if (defined(positions)) {\n      const positionsLength = positions.length;\n      for (let i = 0; i < positionsLength; ++i, startingIndex += CartesianX.packedLength) {\n        CartesianX.pack(positions[i], array, startingIndex);\n      }\n    }\n    if (defined(holes)) {\n      const holesLength = holes.length;\n      for (let j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n  return startingIndex;\n};\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (array, startingIndex, CartesianX) {\n  const positionsLength = array[startingIndex++];\n  const holesLength = array[startingIndex++];\n  const positions = new Array(positionsLength);\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\n  for (let i = 0; i < positionsLength; ++i, startingIndex += CartesianX.packedLength) {\n    positions[i] = CartesianX.unpack(array, startingIndex);\n  }\n  for (let j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex, CartesianX);\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex\n  };\n};\nconst distance2DScratch = new Cartesian2();\nfunction getPointAtDistance2D(p0, p1, distance, length) {\n  Cartesian2.subtract(p1, p0, distance2DScratch);\n  Cartesian2.multiplyByScalar(distance2DScratch, distance / length, distance2DScratch);\n  Cartesian2.add(p0, distance2DScratch, distance2DScratch);\n  return [distance2DScratch.x, distance2DScratch.y];\n}\nconst distanceScratch = new Cartesian3();\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(distanceScratch, distance / length, distanceScratch);\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  const n = distance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\nconst scratchCartographic2 = new Cartographic();\nconst scratchCartesian0 = new Cartesian3();\nconst scratchRhumbLine = new EllipsoidRhumbLine();\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (ellipsoid, p0, p1, minDistance) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {number} minDistance Minimum distance for a segment.\n * @param {Cartesian2[]} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordLine = function (t0, t1, p0, p1, minDistance, result) {\n  // Compute the number of subdivisions.\n  const subdivisions = PolygonGeometryLibrary.subdivideLineCount(p0, p1, minDistance);\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n  return texcoords;\n};\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(p0, p1, minDistance);\n  const length = Cartesian3.distance(p0, p1);\n  const distanceBetweenVertices = length / numVertices;\n  if (!defined(result)) {\n    result = [];\n  }\n  const positions = result;\n  positions.length = numVertices * 3;\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n  return positions;\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions using a rhumb line.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {number} minDistance Minimum distance for a segment.\n * @param {Cartesian2[]} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordRhumbLine = function (t0, t1, ellipsoid, p0, p1, minDistance, result) {\n  // Compute the surface distance.\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  scratchRhumbLine.setEndPoints(c0, c1);\n  const n = scratchRhumbLine.surfaceDistance / minDistance;\n\n  // Compute the number of subdivisions.\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const subdivisions = Math.pow(2, countDivide);\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n  return texcoords;\n};\nPolygonGeometryLibrary.subdivideRhumbLine = function (ellipsoid, p0, p1, minDistance, result) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const numVertices = Math.pow(2, countDivide);\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n  if (!defined(result)) {\n    result = [];\n  }\n  const positions = result;\n  positions.length = numVertices * 3;\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const c = rhumb.interpolateUsingSurfaceDistance(i * distanceBetweenVertices, scratchCartographic2);\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n  return positions;\n};\nconst scaleToGeodeticHeightN1 = new Cartesian3();\nconst scaleToGeodeticHeightN2 = new Cartesian3();\nconst scaleToGeodeticHeightP1 = new Cartesian3();\nconst scaleToGeodeticHeightP2 = new Cartesian3();\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (geometry, maxHeight, minHeight, ellipsoid, perPositionHeight) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const n1 = scaleToGeodeticHeightN1;\n  let n2 = scaleToGeodeticHeightN2;\n  const p = scaleToGeodeticHeightP1;\n  let p2 = scaleToGeodeticHeightP2;\n  if (defined(geometry) && defined(geometry.attributes) && defined(geometry.attributes.position)) {\n    const positions = geometry.attributes.position.values;\n    const length = positions.length / 2;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n  return geometry;\n};\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (polygonHierarchy, scaleToEllipsoidSurface, ellipsoid) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const polygons = [];\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  let i;\n  let j;\n  let length;\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    outerRing = arrayRemoveDuplicates(outerRing, Cartesian3.equalsEpsilon, true);\n    if (outerRing.length < 3) {\n      continue;\n    }\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\n    // The outer polygon contains inner polygons\n    for (i = 0; i < numChildren; i++) {\n      const hole = outerNode.holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      holePositions = arrayRemoveDuplicates(holePositions, Cartesian3.equalsEpsilon, true);\n      if (holePositions.length < 3) {\n        continue;\n      }\n      polygons.push(holePositions);\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n    polygons.push(outerRing);\n  }\n  return polygons;\n};\nconst scratchRhumbIntersection = new Cartographic();\nfunction computeEquatorIntersectionRhumb(start, end, ellipsoid) {\n  const c0 = ellipsoid.cartesianToCartographic(start, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(end, scratchCartographic1);\n  if (Math.sign(c0.latitude) === Math.sign(c1.latitude)) {\n    return;\n  }\n  scratchRhumbLine.setEndPoints(c0, c1);\n  const intersection = scratchRhumbLine.findIntersectionWithLatitude(0, scratchRhumbIntersection);\n  if (!defined(intersection)) {\n    return;\n  }\n  let minLongitude = Math.min(c0.longitude, c1.longitude);\n  let maxLongitude = Math.max(c0.longitude, c1.longitude);\n  if (Math.abs(maxLongitude - minLongitude) > CesiumMath.PI) {\n    // Crosses IDL, flip min and max\n    const swap = minLongitude;\n    minLongitude = maxLongitude;\n    maxLongitude = swap;\n  }\n  if (intersection.longitude < minLongitude || intersection.longitude > maxLongitude) {\n    return;\n  }\n  return ellipsoid.cartographicToCartesian(intersection);\n}\nfunction computeEquatorIntersection(start, end, ellipsoid, arcType) {\n  if (arcType === ArcType.RHUMB) {\n    return computeEquatorIntersectionRhumb(start, end, ellipsoid);\n  }\n  const intersection = IntersectionTests.lineSegmentPlane(start, end, Plane.ORIGIN_XY_PLANE);\n  if (!defined(intersection)) {\n    return;\n  }\n  return ellipsoid.scaleToGeodeticSurface(intersection, intersection);\n}\nconst scratchCartographic = new Cartographic();\nfunction computeEdgesOnPlane(positions, ellipsoid, arcType) {\n  const edgesOnPlane = [];\n  let startPoint,\n    endPoint,\n    type,\n    next,\n    intersection,\n    i = 0;\n  while (i < positions.length) {\n    startPoint = positions[i];\n    endPoint = positions[(i + 1) % positions.length];\n    type = CesiumMath.sign(startPoint.z);\n    next = CesiumMath.sign(endPoint.z);\n    const getLongitude = position => {\n      const cartographic = ellipsoid.cartesianToCartographic(position, scratchCartographic);\n      return cartographic.longitude;\n    };\n    if (type === 0) {\n      // The start position is on the split\n      edgesOnPlane.push({\n        position: i,\n        type: type,\n        visited: false,\n        next: next,\n        theta: getLongitude(startPoint)\n      });\n    } else if (next !== 0) {\n      intersection = computeEquatorIntersection(startPoint, endPoint, ellipsoid, arcType);\n      ++i;\n      if (!defined(intersection)) {\n        // The line segment is entirely above or below\n        continue;\n      }\n\n      // The line segment passed through\n      positions.splice(i, 0, intersection);\n      edgesOnPlane.push({\n        position: i,\n        type: type,\n        visited: false,\n        next: next,\n        theta: getLongitude(intersection)\n      });\n    }\n    ++i;\n  }\n  return edgesOnPlane;\n}\nfunction wirePolygon(polygons, polygonIndex, positions, edgesOnPlane, toDelete, startIndex, abovePlane) {\n  const polygon = [];\n  let i = startIndex;\n  const getMatchingEdge = i => edge => edge.position === i;\n  const polygonsToWire = [];\n  do {\n    const position = positions[i];\n    polygon.push(position);\n    const edgeIndex = edgesOnPlane.findIndex(getMatchingEdge(i));\n    const edge = edgesOnPlane[edgeIndex];\n    if (!defined(edge)) {\n      // The current segment does not intersect\n      ++i;\n      continue;\n    }\n    const {\n      visited: hasBeenVisited,\n      type,\n      next\n    } = edge;\n    edge.visited = true;\n    if (type === 0) {\n      if (next === 0) {\n        // Special case where we'll need to backtrack along the edge\n        const previousEdge = edgesOnPlane[edgeIndex - (abovePlane ? 1 : -1)];\n        if (previousEdge?.position === i + 1) {\n          previousEdge.visited = true;\n        } else {\n          ++i;\n          continue;\n        }\n      }\n\n      // Special case where 3 polygons meet\n      if (!hasBeenVisited && abovePlane && next > 0 || startIndex === i && !abovePlane && next < 0) {\n        ++i;\n        continue;\n      }\n    }\n    const followEdge = abovePlane ? type >= 0 : type <= 0;\n    if (!followEdge) {\n      ++i;\n      continue;\n    }\n    if (!hasBeenVisited) {\n      // Wire another polygon starting at this position on the other side of the edge\n      polygonsToWire.push(i);\n    }\n\n    // Continue counter-clockwise to the next edge\n    const nextEdgeIndex = edgeIndex + (abovePlane ? 1 : -1);\n    const nextEdge = edgesOnPlane[nextEdgeIndex];\n    if (!defined(nextEdge)) {\n      ++i;\n      continue;\n    }\n    i = nextEdge.position;\n  } while (i < positions.length && i >= 0 && i !== startIndex && polygon.length < positions.length);\n  polygons.splice(polygonIndex, toDelete, polygon);\n  for (const index of polygonsToWire) {\n    polygonIndex = wirePolygon(polygons, ++polygonIndex, positions, edgesOnPlane, 0, index, !abovePlane);\n  }\n  return polygonIndex;\n}\n\n/**\n * Splits an array of polygons, defined as a list of Cartesian3 positions in counter-clockwise winding order, along the equator.\n *\n * @param {Array<Cartesian3[]>} outerRings An array of polygons, defined as a list of Cartesian3 positions in counter-clockwise winding order.\n * @param {Ellipsoid} ellipsoid The ellipsoid to be used as a reference.\n * @param {ArcType} arcType The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Array<Cartesian3[]>} [result] An array of split polygons.\n *\n * @returns {Array<Cartesian3[]>} An array of split polygons.\n */\nPolygonGeometryLibrary.splitPolygonsOnEquator = function (outerRings, ellipsoid, arcType, result) {\n  if (!defined(result)) {\n    result = [];\n  }\n  result.splice(0, 0, ...outerRings);\n  result.length = outerRings.length;\n  let currentPolygon = 0;\n  while (currentPolygon < result.length) {\n    // Adapted from https://www.sciencedirect.com/science/article/abs/pii/B9780125434577500589#:~:text=If%20the%20plane%20intersects%20the,tree%20and%20polygon%20intersection%20libraries\n    const outerRing = result[currentPolygon];\n    const positions = outerRing.slice();\n    if (outerRing.length < 3) {\n      result[currentPolygon] = positions;\n      ++currentPolygon;\n      continue;\n    }\n\n    // Step 1: Get all edges which intersect the split line, splciing any found intersections points into the list of positions\n    const edgesOnPlane = computeEdgesOnPlane(positions, ellipsoid, arcType);\n    // If nothing intersected (no point were added), or there is only a single point on the plane, use the original polygon\n    if (positions.length === outerRing.length || edgesOnPlane.length <= 1) {\n      result[currentPolygon] = positions;\n      ++currentPolygon;\n      continue;\n    }\n\n    // Step 2: Sort the edges along the split line by the distance between their starting points and the starting point of the split line.\n    edgesOnPlane.sort((a, b) => {\n      return a.theta - b.theta;\n    });\n\n    // Step 3: Rewire polygons, splicing each polygon into the array of results\n    const north = positions[0].z >= 0.0;\n    currentPolygon = wirePolygon(result, currentPolygon, positions, edgesOnPlane, 1, 0, north);\n  }\n  return result;\n};\nPolygonGeometryLibrary.polygonsFromHierarchy = function (polygonHierarchy, keepDuplicates, projectPointsTo2D, scaleToEllipsoidSurface, ellipsoid, splitPolygons) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const hierarchy = [];\n  const polygons = [];\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  let split = defined(splitPolygons);\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    const holes = outerNode.holes;\n    let i;\n    let length;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    if (!keepDuplicates) {\n      outerRing = arrayRemoveDuplicates(outerRing, Cartesian3.equalsEpsilon, true);\n    }\n    if (outerRing.length < 3) {\n      continue;\n    }\n    let positions2D = projectPointsTo2D(outerRing);\n    if (!defined(positions2D)) {\n      continue;\n    }\n    const holeIndices = [];\n    let originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n    if (split) {\n      split = false;\n      let polygons = [outerRing];\n      polygons = splitPolygons(polygons, polygons);\n      if (polygons.length > 1) {\n        for (const positions of polygons) {\n          queue.enqueue(new PolygonHierarchy(positions, holes));\n        }\n        continue;\n      }\n    }\n    let positions = outerRing.slice();\n    const numChildren = defined(holes) ? holes.length : 0;\n    const polygonHoles = [];\n    let j;\n    for (i = 0; i < numChildren; i++) {\n      const hole = holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      if (!keepDuplicates) {\n        holePositions = arrayRemoveDuplicates(holePositions, Cartesian3.equalsEpsilon, true);\n      }\n      if (holePositions.length < 3) {\n        continue;\n      }\n      const holePositions2D = projectPointsTo2D(holePositions);\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(holePositions2D);\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices\n    });\n  }\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons\n  };\n};\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\nconst computeBoundingRectangleQuaternion = new Quaternion();\nconst computeBoundingRectangleMatrix3 = new Matrix3();\nPolygonGeometryLibrary.computeBoundingRectangle = function (planeNormal, projectPointTo2D, positions, angle, result) {\n  const rotation = Quaternion.fromAxisAngle(planeNormal, angle, computeBoundingRectangleQuaternion);\n  const textureMatrix = Matrix3.fromQuaternion(rotation, computeBoundingRectangleMatrix3);\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const p = Cartesian3.clone(positions[i], computeBoundingRectangleCartesian3);\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\nPolygonGeometryLibrary.createGeometryFromPositions = function (ellipsoid, polygon, textureCoordinates, granularity, perPositionHeight, vertexFormat, arcType) {\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n  const positions = polygon.positions;\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n  if (perPositionHeight) {\n    const length = positions.length;\n    const flattenedPositions = new Array(length * 3);\n    let index = 0;\n    for (let i = 0; i < length; i++) {\n      const p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n    const geometryOptions = {\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions\n        })\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES\n    };\n    if (hasTexcoords) {\n      geometryOptions.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: Cartesian2.packArray(texcoords)\n      });\n    }\n    const geometry = new Geometry(geometryOptions);\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n    return geometry;\n  }\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(ellipsoid, positions, indices, texcoords, granularity);\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(ellipsoid, positions, indices, texcoords, granularity);\n  }\n};\nconst computeWallTexcoordsSubdivided = [];\nconst computeWallIndicesSubdivided = [];\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nPolygonGeometryLibrary.computeWallGeometry = function (positions, textureCoordinates, ellipsoid, granularity, perPositionHeight, arcType) {\n  let edgePositions;\n  let topEdgeLength;\n  let i;\n  let p1;\n  let p2;\n  let t1;\n  let t2;\n  let edgeTexcoords;\n  let topEdgeTexcoordLength;\n  let length = positions.length;\n  let index = 0;\n  let textureIndex = 0;\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n  if (!perPositionHeight) {\n    const minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n      }\n    }\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = (numVertices + length) * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      let tempPositions;\n      let tempTexcoords;\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n      }\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(p1, p2, minDistance, computeWallIndicesSubdivided);\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordLine(t1, t2, p1, p2, minDistance, computeWallTexcoordsSubdivided);\n        }\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, p1, p2, minDistance, computeWallIndicesSubdivided);\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordRhumbLine(t1, t2, ellipsoid, p1, p2, minDistance, computeWallTexcoordsSubdivided);\n        }\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n      if (hasTexcoords) {\n        const tempTexcoordsLength = tempTexcoords.length;\n        for (let k = 0; k < tempTexcoordsLength; ++k, ++textureIndex) {\n          edgeTexcoords[textureIndex] = tempTexcoords[k];\n          edgeTexcoords[textureIndex + topEdgeTexcoordLength] = tempTexcoords[k];\n        }\n        edgeTexcoords[textureIndex] = t2.x;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = t2.y;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\n        ++textureIndex;\n      }\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = length * 2 * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n        edgeTexcoords[textureIndex] = edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t1.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t1.y;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\n        ++textureIndex;\n      }\n    }\n  }\n  length = edgePositions.length;\n  const indices = IndexDatatype.createTypedArray(length / 3, length - positions.length * 6);\n  let edgeIndex = 0;\n  length /= 6;\n  for (i = 0; i < length; i++) {\n    const UL = i;\n    const UR = UL + 1;\n    const LL = UL + length;\n    const LR = LL + 1;\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10, CesiumMath.EPSILON10)) {\n      //skip corner\n      continue;\n    }\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n  const geometryOptions = {\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions\n      })\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES\n  };\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: edgeTexcoords\n    });\n  }\n  const geometry = new Geometry(geometryOptions);\n  return geometry;\n};\nexport default PolygonGeometryLibrary;","map":{"version":3,"names":["ArcType","arrayRemoveDuplicates","Cartesian2","Cartesian3","Cartographic","ComponentDatatype","defaultValue","defined","Ellipsoid","EllipsoidRhumbLine","Geometry","GeometryAttribute","GeometryAttributes","GeometryPipeline","IndexDatatype","IntersectionTests","CesiumMath","Matrix3","Plane","PolygonHierarchy","PolygonPipeline","PrimitiveType","Quaternion","Queue","WindingOrder","PolygonGeometryLibrary","computeHierarchyPackedLength","polygonHierarchy","CartesianX","numComponents","stack","length","hierarchy","pop","positions","holes","packedLength","i","push","packPolygonHierarchy","array","startingIndex","positionsLength","pack","holesLength","j","unpackPolygonHierarchy","Array","undefined","unpack","distance2DScratch","getPointAtDistance2D","p0","p1","distance","subtract","multiplyByScalar","add","x","y","distanceScratch","getPointAtDistance","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","log2","pow","scratchCartographic0","scratchCartographic1","scratchCartographic2","scratchCartesian0","scratchRhumbLine","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","rhumb","surfaceDistance","subdivideTexcoordLine","t0","t1","result","subdivisions","length2D","distanceBetweenCoords","texcoords","index","t","subdivideLine","numVertices","distanceBetweenVertices","p","subdivideTexcoordRhumbLine","setEndPoints","subdivideRhumbLine","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","default","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","enqueue","outerNode","dequeue","outerRing","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","scratchRhumbIntersection","computeEquatorIntersectionRhumb","start","end","sign","latitude","intersection","findIntersectionWithLatitude","minLongitude","min","longitude","maxLongitude","abs","PI","swap","computeEquatorIntersection","arcType","RHUMB","lineSegmentPlane","ORIGIN_XY_PLANE","scratchCartographic","computeEdgesOnPlane","edgesOnPlane","startPoint","endPoint","type","next","getLongitude","cartographic","visited","theta","splice","wirePolygon","polygonIndex","toDelete","startIndex","abovePlane","polygon","getMatchingEdge","edge","polygonsToWire","edgeIndex","findIndex","hasBeenVisited","previousEdge","followEdge","nextEdgeIndex","nextEdge","splitPolygonsOnEquator","outerRings","currentPolygon","slice","sort","a","b","north","polygonsFromHierarchy","keepDuplicates","projectPointsTo2D","splitPolygons","split","positions2D","holeIndices","originalWindingOrder","computeWindingOrder2D","CLOCKWISE","reverse","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","computeBoundingRectangleMatrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","width","height","createGeometryFromPositions","textureCoordinates","granularity","vertexFormat","indices","triangulate","hasTexcoords","flattenedPositions","geometryOptions","componentDatatype","DOUBLE","componentsPerAttribute","primitiveType","TRIANGLES","FLOAT","packArray","normal","computeNormal","GEODESIC","computeSubdivision","computeRhumbLineSubdivision","computeWallTexcoordsSubdivided","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","t2","edgeTexcoords","topEdgeTexcoordLength","textureIndex","chordLength","maximumRadius","tempPositions","tempTexcoords","tempPositionsLength","tempTexcoordsLength","k","createTypedArray","UL","UR","LL","LR","EPSILON10"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/PolygonGeometryLibrary.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport PolygonHierarchy from \"./PolygonHierarchy.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nconst PolygonGeometryLibrary = {};\n\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\n  polygonHierarchy,\n  CartesianX,\n) {\n  let numComponents = 0;\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    numComponents += 2;\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    if (defined(positions) && positions.length > 0) {\n      numComponents += positions.length * CartesianX.packedLength;\n    }\n\n    if (defined(holes)) {\n      const length = holes.length;\n      for (let i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n\n  return numComponents;\n};\n\nPolygonGeometryLibrary.packPolygonHierarchy = function (\n  polygonHierarchy,\n  array,\n  startingIndex,\n  CartesianX,\n) {\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n\n    if (defined(positions)) {\n      const positionsLength = positions.length;\n      for (\n        let i = 0;\n        i < positionsLength;\n        ++i, startingIndex += CartesianX.packedLength\n      ) {\n        CartesianX.pack(positions[i], array, startingIndex);\n      }\n    }\n\n    if (defined(holes)) {\n      const holesLength = holes.length;\n      for (let j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n\n  return startingIndex;\n};\n\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\n  array,\n  startingIndex,\n  CartesianX,\n) {\n  const positionsLength = array[startingIndex++];\n  const holesLength = array[startingIndex++];\n\n  const positions = new Array(positionsLength);\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\n\n  for (\n    let i = 0;\n    i < positionsLength;\n    ++i, startingIndex += CartesianX.packedLength\n  ) {\n    positions[i] = CartesianX.unpack(array, startingIndex);\n  }\n\n  for (let j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\n      array,\n      startingIndex,\n      CartesianX,\n    );\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex,\n  };\n};\n\nconst distance2DScratch = new Cartesian2();\nfunction getPointAtDistance2D(p0, p1, distance, length) {\n  Cartesian2.subtract(p1, p0, distance2DScratch);\n  Cartesian2.multiplyByScalar(\n    distance2DScratch,\n    distance / length,\n    distance2DScratch,\n  );\n  Cartesian2.add(p0, distance2DScratch, distance2DScratch);\n  return [distance2DScratch.x, distance2DScratch.y];\n}\n\nconst distanceScratch = new Cartesian3();\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(\n    distanceScratch,\n    distance / length,\n    distanceScratch,\n  );\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\n\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  const n = distance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\nconst scratchCartographic2 = new Cartographic();\nconst scratchCartesian0 = new Cartesian3();\nconst scratchRhumbLine = new EllipsoidRhumbLine();\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {number} minDistance Minimum distance for a segment.\n * @param {Cartesian2[]} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordLine = function (\n  t0,\n  t1,\n  p0,\n  p1,\n  minDistance,\n  result,\n) {\n  // Compute the number of subdivisions.\n  const subdivisions = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance,\n  );\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance,\n  );\n  const length = Cartesian3.distance(p0, p1);\n  const distanceBetweenVertices = length / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n\n  return positions;\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions using a rhumb line.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {number} minDistance Minimum distance for a segment.\n * @param {Cartesian2[]} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordRhumbLine = function (\n  t0,\n  t1,\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result,\n) {\n  // Compute the surface distance.\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  scratchRhumbLine.setEndPoints(c0, c1);\n  const n = scratchRhumbLine.surfaceDistance / minDistance;\n\n  // Compute the number of subdivisions.\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const subdivisions = Math.pow(2, countDivide);\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideRhumbLine = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result,\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const numVertices = Math.pow(2, countDivide);\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const c = rhumb.interpolateUsingSurfaceDistance(\n      i * distanceBetweenVertices,\n      scratchCartographic2,\n    );\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n\n  return positions;\n};\n\nconst scaleToGeodeticHeightN1 = new Cartesian3();\nconst scaleToGeodeticHeightN2 = new Cartesian3();\nconst scaleToGeodeticHeightP1 = new Cartesian3();\nconst scaleToGeodeticHeightP2 = new Cartesian3();\n\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\n  geometry,\n  maxHeight,\n  minHeight,\n  ellipsoid,\n  perPositionHeight,\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  const n1 = scaleToGeodeticHeightN1;\n  let n2 = scaleToGeodeticHeightN2;\n  const p = scaleToGeodeticHeightP1;\n  let p2 = scaleToGeodeticHeightP2;\n\n  if (\n    defined(geometry) &&\n    defined(geometry.attributes) &&\n    defined(geometry.attributes.position)\n  ) {\n    const positions = geometry.attributes.position.values;\n    const length = positions.length / 2;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n  return geometry;\n};\n\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\n  polygonHierarchy,\n  scaleToEllipsoidSurface,\n  ellipsoid,\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const polygons = [];\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  let i;\n  let j;\n  let length;\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    outerRing = arrayRemoveDuplicates(\n      outerRing,\n      Cartesian3.equalsEpsilon,\n      true,\n    );\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\n    // The outer polygon contains inner polygons\n    for (i = 0; i < numChildren; i++) {\n      const hole = outerNode.holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      holePositions = arrayRemoveDuplicates(\n        holePositions,\n        Cartesian3.equalsEpsilon,\n        true,\n      );\n      if (holePositions.length < 3) {\n        continue;\n      }\n      polygons.push(holePositions);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    polygons.push(outerRing);\n  }\n\n  return polygons;\n};\n\nconst scratchRhumbIntersection = new Cartographic();\nfunction computeEquatorIntersectionRhumb(start, end, ellipsoid) {\n  const c0 = ellipsoid.cartesianToCartographic(start, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(end, scratchCartographic1);\n\n  if (Math.sign(c0.latitude) === Math.sign(c1.latitude)) {\n    return;\n  }\n\n  scratchRhumbLine.setEndPoints(c0, c1);\n\n  const intersection = scratchRhumbLine.findIntersectionWithLatitude(\n    0,\n    scratchRhumbIntersection,\n  );\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  let minLongitude = Math.min(c0.longitude, c1.longitude);\n  let maxLongitude = Math.max(c0.longitude, c1.longitude);\n\n  if (Math.abs(maxLongitude - minLongitude) > CesiumMath.PI) {\n    // Crosses IDL, flip min and max\n    const swap = minLongitude;\n    minLongitude = maxLongitude;\n    maxLongitude = swap;\n  }\n\n  if (\n    intersection.longitude < minLongitude ||\n    intersection.longitude > maxLongitude\n  ) {\n    return;\n  }\n\n  return ellipsoid.cartographicToCartesian(intersection);\n}\n\nfunction computeEquatorIntersection(start, end, ellipsoid, arcType) {\n  if (arcType === ArcType.RHUMB) {\n    return computeEquatorIntersectionRhumb(start, end, ellipsoid);\n  }\n\n  const intersection = IntersectionTests.lineSegmentPlane(\n    start,\n    end,\n    Plane.ORIGIN_XY_PLANE,\n  );\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  return ellipsoid.scaleToGeodeticSurface(intersection, intersection);\n}\n\nconst scratchCartographic = new Cartographic();\nfunction computeEdgesOnPlane(positions, ellipsoid, arcType) {\n  const edgesOnPlane = [];\n  let startPoint,\n    endPoint,\n    type,\n    next,\n    intersection,\n    i = 0;\n  while (i < positions.length) {\n    startPoint = positions[i];\n    endPoint = positions[(i + 1) % positions.length];\n\n    type = CesiumMath.sign(startPoint.z);\n    next = CesiumMath.sign(endPoint.z);\n\n    const getLongitude = (position) => {\n      const cartographic = ellipsoid.cartesianToCartographic(\n        position,\n        scratchCartographic,\n      );\n      return cartographic.longitude;\n    };\n\n    if (type === 0) {\n      // The start position is on the split\n      edgesOnPlane.push({\n        position: i,\n        type: type,\n        visited: false,\n        next: next,\n        theta: getLongitude(startPoint),\n      });\n    } else if (next !== 0) {\n      intersection = computeEquatorIntersection(\n        startPoint,\n        endPoint,\n        ellipsoid,\n        arcType,\n      );\n\n      ++i;\n      if (!defined(intersection)) {\n        // The line segment is entirely above or below\n        continue;\n      }\n\n      // The line segment passed through\n      positions.splice(i, 0, intersection);\n      edgesOnPlane.push({\n        position: i,\n        type: type,\n        visited: false,\n        next: next,\n        theta: getLongitude(intersection),\n      });\n    }\n\n    ++i;\n  }\n\n  return edgesOnPlane;\n}\n\nfunction wirePolygon(\n  polygons,\n  polygonIndex,\n  positions,\n  edgesOnPlane,\n  toDelete,\n  startIndex,\n  abovePlane,\n) {\n  const polygon = [];\n  let i = startIndex;\n  const getMatchingEdge = (i) => (edge) => edge.position === i;\n  const polygonsToWire = [];\n  do {\n    const position = positions[i];\n    polygon.push(position);\n\n    const edgeIndex = edgesOnPlane.findIndex(getMatchingEdge(i));\n    const edge = edgesOnPlane[edgeIndex];\n    if (!defined(edge)) {\n      // The current segment does not intersect\n      ++i;\n      continue;\n    }\n\n    const { visited: hasBeenVisited, type, next } = edge;\n    edge.visited = true;\n\n    if (type === 0) {\n      if (next === 0) {\n        // Special case where we'll need to backtrack along the edge\n        const previousEdge = edgesOnPlane[edgeIndex - (abovePlane ? 1 : -1)];\n        if (previousEdge?.position === i + 1) {\n          previousEdge.visited = true;\n        } else {\n          ++i;\n          continue;\n        }\n      }\n\n      // Special case where 3 polygons meet\n      if (\n        (!hasBeenVisited && abovePlane && next > 0) ||\n        (startIndex === i && !abovePlane && next < 0)\n      ) {\n        ++i;\n        continue;\n      }\n    }\n\n    const followEdge = abovePlane ? type >= 0 : type <= 0;\n    if (!followEdge) {\n      ++i;\n      continue;\n    }\n\n    if (!hasBeenVisited) {\n      // Wire another polygon starting at this position on the other side of the edge\n      polygonsToWire.push(i);\n    }\n\n    // Continue counter-clockwise to the next edge\n    const nextEdgeIndex = edgeIndex + (abovePlane ? 1 : -1);\n    const nextEdge = edgesOnPlane[nextEdgeIndex];\n    if (!defined(nextEdge)) {\n      ++i;\n      continue;\n    }\n\n    i = nextEdge.position;\n  } while (\n    i < positions.length &&\n    i >= 0 &&\n    i !== startIndex &&\n    polygon.length < positions.length\n  );\n\n  polygons.splice(polygonIndex, toDelete, polygon);\n\n  for (const index of polygonsToWire) {\n    polygonIndex = wirePolygon(\n      polygons,\n      ++polygonIndex,\n      positions,\n      edgesOnPlane,\n      0,\n      index,\n      !abovePlane,\n    );\n  }\n\n  return polygonIndex;\n}\n\n/**\n * Splits an array of polygons, defined as a list of Cartesian3 positions in counter-clockwise winding order, along the equator.\n *\n * @param {Array<Cartesian3[]>} outerRings An array of polygons, defined as a list of Cartesian3 positions in counter-clockwise winding order.\n * @param {Ellipsoid} ellipsoid The ellipsoid to be used as a reference.\n * @param {ArcType} arcType The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Array<Cartesian3[]>} [result] An array of split polygons.\n *\n * @returns {Array<Cartesian3[]>} An array of split polygons.\n */\nPolygonGeometryLibrary.splitPolygonsOnEquator = function (\n  outerRings,\n  ellipsoid,\n  arcType,\n  result,\n) {\n  if (!defined(result)) {\n    result = [];\n  }\n\n  result.splice(0, 0, ...outerRings);\n  result.length = outerRings.length;\n\n  let currentPolygon = 0;\n  while (currentPolygon < result.length) {\n    // Adapted from https://www.sciencedirect.com/science/article/abs/pii/B9780125434577500589#:~:text=If%20the%20plane%20intersects%20the,tree%20and%20polygon%20intersection%20libraries\n    const outerRing = result[currentPolygon];\n    const positions = outerRing.slice();\n\n    if (outerRing.length < 3) {\n      result[currentPolygon] = positions;\n      ++currentPolygon;\n      continue;\n    }\n\n    // Step 1: Get all edges which intersect the split line, splciing any found intersections points into the list of positions\n    const edgesOnPlane = computeEdgesOnPlane(positions, ellipsoid, arcType);\n    // If nothing intersected (no point were added), or there is only a single point on the plane, use the original polygon\n    if (positions.length === outerRing.length || edgesOnPlane.length <= 1) {\n      result[currentPolygon] = positions;\n      ++currentPolygon;\n      continue;\n    }\n\n    // Step 2: Sort the edges along the split line by the distance between their starting points and the starting point of the split line.\n    edgesOnPlane.sort((a, b) => {\n      return a.theta - b.theta;\n    });\n\n    // Step 3: Rewire polygons, splicing each polygon into the array of results\n    const north = positions[0].z >= 0.0;\n    currentPolygon = wirePolygon(\n      result,\n      currentPolygon,\n      positions,\n      edgesOnPlane,\n      1,\n      0,\n      north,\n    );\n  }\n\n  return result;\n};\n\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\n  polygonHierarchy,\n  keepDuplicates,\n  projectPointsTo2D,\n  scaleToEllipsoidSurface,\n  ellipsoid,\n  splitPolygons,\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const hierarchy = [];\n  const polygons = [];\n\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n\n  let split = defined(splitPolygons);\n\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    const holes = outerNode.holes;\n\n    let i;\n    let length;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    if (!keepDuplicates) {\n      outerRing = arrayRemoveDuplicates(\n        outerRing,\n        Cartesian3.equalsEpsilon,\n        true,\n      );\n    }\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    let positions2D = projectPointsTo2D(outerRing);\n    if (!defined(positions2D)) {\n      continue;\n    }\n    const holeIndices = [];\n\n    let originalWindingOrder =\n      PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n\n    if (split) {\n      split = false;\n      let polygons = [outerRing];\n      polygons = splitPolygons(polygons, polygons);\n\n      if (polygons.length > 1) {\n        for (const positions of polygons) {\n          queue.enqueue(new PolygonHierarchy(positions, holes));\n        }\n\n        continue;\n      }\n    }\n\n    let positions = outerRing.slice();\n    const numChildren = defined(holes) ? holes.length : 0;\n    const polygonHoles = [];\n    let j;\n\n    for (i = 0; i < numChildren; i++) {\n      const hole = holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      if (!keepDuplicates) {\n        holePositions = arrayRemoveDuplicates(\n          holePositions,\n          Cartesian3.equalsEpsilon,\n          true,\n        );\n      }\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      const holePositions2D = projectPointsTo2D(holePositions);\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n\n      originalWindingOrder =\n        PolygonPipeline.computeWindingOrder2D(holePositions2D);\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles,\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices,\n    });\n  }\n\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons,\n  };\n};\n\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\nconst computeBoundingRectangleQuaternion = new Quaternion();\nconst computeBoundingRectangleMatrix3 = new Matrix3();\nPolygonGeometryLibrary.computeBoundingRectangle = function (\n  planeNormal,\n  projectPointTo2D,\n  positions,\n  angle,\n  result,\n) {\n  const rotation = Quaternion.fromAxisAngle(\n    planeNormal,\n    angle,\n    computeBoundingRectangleQuaternion,\n  );\n  const textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    computeBoundingRectangleMatrix3,\n  );\n\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const p = Cartesian3.clone(\n      positions[i],\n      computeBoundingRectangleCartesian3,\n    );\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\n\nPolygonGeometryLibrary.createGeometryFromPositions = function (\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  perPositionHeight,\n  vertexFormat,\n  arcType,\n) {\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  const positions = polygon.positions;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (perPositionHeight) {\n    const length = positions.length;\n    const flattenedPositions = new Array(length * 3);\n    let index = 0;\n    for (let i = 0; i < length; i++) {\n      const p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n\n    const geometryOptions = {\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions,\n        }),\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES,\n    };\n\n    if (hasTexcoords) {\n      geometryOptions.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: Cartesian2.packArray(texcoords),\n      });\n    }\n\n    const geometry = new Geometry(geometryOptions);\n\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n\n    return geometry;\n  }\n\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity,\n    );\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity,\n    );\n  }\n};\n\nconst computeWallTexcoordsSubdivided = [];\nconst computeWallIndicesSubdivided = [];\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\n\nPolygonGeometryLibrary.computeWallGeometry = function (\n  positions,\n  textureCoordinates,\n  ellipsoid,\n  granularity,\n  perPositionHeight,\n  arcType,\n) {\n  let edgePositions;\n  let topEdgeLength;\n  let i;\n  let p1;\n  let p2;\n  let t1;\n  let t2;\n  let edgeTexcoords;\n  let topEdgeTexcoordLength;\n\n  let length = positions.length;\n  let index = 0;\n  let textureIndex = 0;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (!perPositionHeight) {\n    const minDistance = CesiumMath.chordLength(\n      granularity,\n      ellipsoid.maximumRadius,\n    );\n\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    }\n\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = (numVertices + length) * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n\n      let tempPositions;\n      let tempTexcoords;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n      }\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided,\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordLine(\n            t1,\n            t2,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided,\n          );\n        }\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided,\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordRhumbLine(\n            t1,\n            t2,\n            ellipsoid,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided,\n          );\n        }\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        const tempTexcoordsLength = tempTexcoords.length;\n        for (let k = 0; k < tempTexcoordsLength; ++k, ++textureIndex) {\n          edgeTexcoords[textureIndex] = tempTexcoords[k];\n          edgeTexcoords[textureIndex + topEdgeTexcoordLength] =\n            tempTexcoords[k];\n        }\n\n        edgeTexcoords[textureIndex] = t2.x;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\n        ++textureIndex;\n\n        edgeTexcoords[textureIndex] = t2.y;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\n        ++textureIndex;\n      }\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = length * 2 * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.y;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.y;\n        ++textureIndex;\n      }\n    }\n  }\n\n  length = edgePositions.length;\n  const indices = IndexDatatype.createTypedArray(\n    length / 3,\n    length - positions.length * 6,\n  );\n  let edgeIndex = 0;\n  length /= 6;\n\n  for (i = 0; i < length; i++) {\n    const UL = i;\n    const UR = UL + 1;\n    const LL = UL + length;\n    const LR = LL + 1;\n\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n    if (\n      Cartesian3.equalsEpsilon(\n        p1,\n        p2,\n        CesiumMath.EPSILON10,\n        CesiumMath.EPSILON10,\n      )\n    ) {\n      //skip corner\n      continue;\n    }\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  const geometryOptions = {\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions,\n      }),\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: edgeTexcoords,\n    });\n  }\n\n  const geometry = new Geometry(geometryOptions);\n\n  return geometry;\n};\nexport default PolygonGeometryLibrary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}