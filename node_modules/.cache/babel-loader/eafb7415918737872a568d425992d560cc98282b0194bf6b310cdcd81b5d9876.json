{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataClassProperty from \"./MetadataClassProperty.js\";\nimport MetadataType from \"./MetadataType.js\";\n\n/**\n * A binary property in a {@MetadataTable}\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension}\n * for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}\n * for glTF. For the legacy glTF extension, see {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension}\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.count The number of elements in each property array.\n * @param {object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n * @param {Object<string, Uint8Array>} options.bufferViews An object mapping bufferView IDs to Uint8Array objects.\n *\n * @alias MetadataTableProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataTableProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const count = options.count;\n  const property = options.property;\n  const classProperty = options.classProperty;\n  const bufferViews = options.bufferViews;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", count, 0);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  Check.typeOf.object(\"options.bufferViews\", bufferViews);\n  //>>includeEnd('debug');\n\n  const type = classProperty.type;\n  const isArray = classProperty.isArray;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  let valueType = classProperty.valueType;\n  const enumType = classProperty.enumType;\n  const hasStrings = type === MetadataType.STRING;\n  const hasBooleans = type === MetadataType.BOOLEAN;\n  let byteLength = 0;\n  let arrayOffsets;\n  if (isVariableLengthArray) {\n    // EXT_structural_metadata uses arrayOffsetType.\n    // EXT_feature_metadata uses offsetType for both arrays and strings\n    let arrayOffsetType = defaultValue(property.arrayOffsetType, property.offsetType);\n    arrayOffsetType = defaultValue(MetadataComponentType[arrayOffsetType], MetadataComponentType.UINT32);\n\n    // EXT_structural_metadata uses arrayOffsets.\n    // EXT_feature_metadata uses arrayOffsetBufferView\n    const arrayOffsetBufferView = defaultValue(property.arrayOffsets, property.arrayOffsetBufferView);\n    arrayOffsets = new BufferView(bufferViews[arrayOffsetBufferView], arrayOffsetType, count + 1);\n    byteLength += arrayOffsets.typedArray.byteLength;\n  }\n  const vectorComponentCount = MetadataType.getComponentCount(type);\n  let arrayComponentCount;\n  if (isVariableLengthArray) {\n    arrayComponentCount = arrayOffsets.get(count) - arrayOffsets.get(0);\n  } else if (isArray) {\n    arrayComponentCount = count * classProperty.arrayLength;\n  } else {\n    arrayComponentCount = count;\n  }\n  const componentCount = vectorComponentCount * arrayComponentCount;\n  let stringOffsets;\n  if (hasStrings) {\n    // EXT_structural_metadata uses stringOffsetType, EXT_feature_metadata uses offsetType for both arrays and strings\n    let stringOffsetType = defaultValue(property.stringOffsetType, property.offsetType);\n    stringOffsetType = defaultValue(MetadataComponentType[stringOffsetType], MetadataComponentType.UINT32);\n\n    // EXT_structural_metadata uses stringOffsets.\n    // EXT_feature_metadata uses stringOffsetBufferView\n    const stringOffsetBufferView = defaultValue(property.stringOffsets, property.stringOffsetBufferView);\n    stringOffsets = new BufferView(bufferViews[stringOffsetBufferView], stringOffsetType, componentCount + 1);\n    byteLength += stringOffsets.typedArray.byteLength;\n  }\n  if (hasStrings || hasBooleans) {\n    // STRING and BOOLEAN types need to be parsed differently than other types\n    valueType = MetadataComponentType.UINT8;\n  }\n  let valueCount;\n  if (hasStrings) {\n    valueCount = stringOffsets.get(componentCount) - stringOffsets.get(0);\n  } else if (hasBooleans) {\n    valueCount = Math.ceil(componentCount / 8);\n  } else {\n    valueCount = componentCount;\n  }\n\n  // EXT_structural_metadata uses values\n  // EXT_feature_metadata uses bufferView\n  const valuesBufferView = defaultValue(property.values, property.bufferView);\n  const values = new BufferView(bufferViews[valuesBufferView], valueType, valueCount);\n  byteLength += values.typedArray.byteLength;\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform = classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the table does not define an offset/scale, it inherits from the\n  // class property. The class property handles setting the default of identity:\n  // (offset 0, scale 1) with the same array shape as the property's type\n  // information.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // Since metadata table properties are stored as packed typed\n  // arrays, flatten the offset/scale to make it easier to apply the\n  // transformation by iteration.\n  offset = flatten(offset);\n  scale = flatten(scale);\n  let getValueFunction;\n  let setValueFunction;\n  const that = this;\n  if (hasStrings) {\n    getValueFunction = function (index) {\n      return getString(index, that._values, that._stringOffsets);\n    };\n  } else if (hasBooleans) {\n    getValueFunction = function (index) {\n      return getBoolean(index, that._values);\n    };\n    setValueFunction = function (index, value) {\n      setBoolean(index, that._values, value);\n    };\n  } else if (defined(enumType)) {\n    getValueFunction = function (index) {\n      const integer = that._values.get(index);\n      return enumType.namesByValue[integer];\n    };\n    setValueFunction = function (index, value) {\n      const integer = enumType.valuesByName[value];\n      that._values.set(index, integer);\n    };\n  } else {\n    getValueFunction = function (index) {\n      return that._values.get(index);\n    };\n    setValueFunction = function (index, value) {\n      that._values.set(index, value);\n    };\n  }\n  this._arrayOffsets = arrayOffsets;\n  this._stringOffsets = stringOffsets;\n  this._values = values;\n  this._classProperty = classProperty;\n  this._count = count;\n  this._vectorComponentCount = vectorComponentCount;\n  this._min = property.min;\n  this._max = property.max;\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n  this._getValue = getValueFunction;\n  this._setValue = setValueFunction;\n  this._unpackedValues = undefined;\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n  this._byteLength = byteLength;\n}\nObject.defineProperties(MetadataTableProperty.prototype, {\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    }\n  },\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    }\n  },\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    }\n  },\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    }\n  },\n  /**\n   * An object containing extensions.\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    }\n  },\n  /**\n   * Size of all typed arrays used by this table property\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {Normal}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    }\n  }\n});\n\n/**\n * Returns a copy of the value at the given index.\n *\n * @param {number} index The index.\n * @returns {*} The value of the property.\n *\n * @private\n */\nMetadataTableProperty.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  checkIndex(this, index);\n  //>>includeEnd('debug');\n\n  let value = get(this, index);\n\n  // handle noData and default\n  value = this._classProperty.handleNoData(value);\n  if (!defined(value)) {\n    value = this._classProperty.default;\n    return this._classProperty.unpackVectorAndMatrixTypes(value);\n  }\n  value = this._classProperty.normalize(value);\n  value = applyValueTransform(this, value);\n  return this._classProperty.unpackVectorAndMatrixTypes(value);\n};\n\n/**\n * Sets the value at the given index.\n *\n * @param {number} index The index.\n * @param {*} value The value of the property.\n *\n * @private\n */\nMetadataTableProperty.prototype.set = function (index, value) {\n  const classProperty = this._classProperty;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  checkIndex(this, index);\n  const errorMessage = classProperty.validate(value);\n  if (defined(errorMessage)) {\n    throw new DeveloperError(errorMessage);\n  }\n  //>>includeEnd('debug');\n\n  value = classProperty.packVectorAndMatrixTypes(value);\n  value = unapplyValueTransform(this, value);\n  value = classProperty.unnormalize(value);\n  set(this, index, value);\n};\n\n/**\n * Returns a typed array containing the property values.\n *\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTableProperty.prototype.getTypedArray = function () {\n  // Note: depending on the class definition some properties are unpacked to\n  // JS arrays when first accessed and values will be undefined. Generally not\n  // a concern for fixed-length arrays of numbers.\n  if (defined(this._values)) {\n    return this._values.typedArray;\n  }\n  return undefined;\n};\nfunction flatten(values) {\n  if (!Array.isArray(values)) {\n    return values;\n  }\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (Array.isArray(value)) {\n      result.push.apply(result, value);\n    } else {\n      result.push(value);\n    }\n  }\n  return result;\n}\nfunction checkIndex(table, index) {\n  const count = table._count;\n  if (!defined(index) || index < 0 || index >= count) {\n    const maximumIndex = count - 1;\n    throw new DeveloperError(`index is required and between zero and count - 1. Actual value: ${maximumIndex}`);\n  }\n}\nfunction get(property, index) {\n  if (requiresUnpackForGet(property)) {\n    unpackProperty(property);\n  }\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n  if (defined(property._unpackedValues)) {\n    const value = property._unpackedValues[index];\n    if (isArray) {\n      return clone(value, true);\n    }\n    return value;\n  }\n\n  // handle single values\n  if (!isArray && componentCount === 1) {\n    return property._getValue(index);\n  }\n  return getArrayValues(property, classProperty, index);\n}\nfunction getArrayValues(property, classProperty, index) {\n  let offset;\n  let length;\n  if (classProperty.isVariableLengthArray) {\n    offset = property._arrayOffsets.get(index);\n    length = property._arrayOffsets.get(index + 1) - offset;\n\n    // for vectors and matrices, the offset and length need to be multiplied\n    // by the component count\n    const componentCount = MetadataType.getComponentCount(classProperty.type);\n    offset *= componentCount;\n    length *= componentCount;\n  } else {\n    const arrayLength = defaultValue(classProperty.arrayLength, 1);\n    const componentCount = arrayLength * property._vectorComponentCount;\n    offset = index * componentCount;\n    length = componentCount;\n  }\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    values[i] = property._getValue(offset + i);\n  }\n  return values;\n}\nfunction set(property, index, value) {\n  if (requiresUnpackForSet(property, index, value)) {\n    unpackProperty(property);\n  }\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n  if (defined(property._unpackedValues)) {\n    if (classProperty.isArray) {\n      value = clone(value, true);\n    }\n    property._unpackedValues[index] = value;\n    return;\n  }\n\n  // Values are unpacked if the length of a variable-size array changes or the\n  // property has strings. No need to handle these cases below.\n\n  // Handle single values\n  if (!isArray && componentCount === 1) {\n    property._setValue(index, value);\n    return;\n  }\n  let offset;\n  let length;\n  if (classProperty.isVariableLengthArray) {\n    offset = property._arrayOffsets.get(index);\n    length = property._arrayOffsets.get(index + 1) - offset;\n  } else {\n    const arrayLength = defaultValue(classProperty.arrayLength, 1);\n    const componentCount = arrayLength * property._vectorComponentCount;\n    offset = index * componentCount;\n    length = componentCount;\n  }\n  for (let i = 0; i < length; ++i) {\n    property._setValue(offset + i, value[i]);\n  }\n}\nfunction getString(index, values, stringOffsets) {\n  const stringByteOffset = stringOffsets.get(index);\n  const stringByteLength = stringOffsets.get(index + 1) - stringByteOffset;\n  return getStringFromTypedArray(values.typedArray, stringByteOffset, stringByteLength);\n}\nfunction getBoolean(index, values) {\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n  return (values.typedArray[byteIndex] >> bitIndex & 1) === 1;\n}\nfunction setBoolean(index, values, value) {\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n  if (value) {\n    values.typedArray[byteIndex] |= 1 << bitIndex;\n  } else {\n    values.typedArray[byteIndex] &= ~(1 << bitIndex);\n  }\n}\nfunction getInt64NumberFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n  let value = 0;\n  const isNegative = (dataView.getUint8(byteOffset + 7) & 0x80) > 0;\n  let carrying = true;\n  for (let i = 0; i < 8; ++i) {\n    let byte = dataView.getUint8(byteOffset + i);\n    if (isNegative) {\n      if (carrying) {\n        if (byte !== 0x00) {\n          byte = ~(byte - 1) & 0xff;\n          carrying = false;\n        }\n      } else {\n        byte = ~byte & 0xff;\n      }\n    }\n    value += byte * Math.pow(256, i);\n  }\n  if (isNegative) {\n    value = -value;\n  }\n  return value;\n}\nfunction getInt64BigIntFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n  // eslint-disable-next-line no-undef\n  let value = BigInt(0);\n  const isNegative = (dataView.getUint8(byteOffset + 7) & 0x80) > 0;\n  let carrying = true;\n  for (let i = 0; i < 8; ++i) {\n    let byte = dataView.getUint8(byteOffset + i);\n    if (isNegative) {\n      if (carrying) {\n        if (byte !== 0x00) {\n          byte = ~(byte - 1) & 0xff;\n          carrying = false;\n        }\n      } else {\n        byte = ~byte & 0xff;\n      }\n    }\n    value += BigInt(byte) * (BigInt(1) << BigInt(i * 8)); // eslint-disable-line\n  }\n  if (isNegative) {\n    value = -value;\n  }\n  return value;\n}\nfunction getUint64NumberFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n\n  // Split 64-bit number into two 32-bit (4-byte) parts\n  const left = dataView.getUint32(byteOffset, true);\n  const right = dataView.getUint32(byteOffset + 4, true);\n\n  // Combine the two 32-bit values\n  const value = left + 4294967296 * right;\n  return value;\n}\nfunction getUint64BigIntFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n\n  // Split 64-bit number into two 32-bit (4-byte) parts\n  // eslint-disable-next-line no-undef\n  const left = BigInt(dataView.getUint32(byteOffset, true));\n\n  // eslint-disable-next-line no-undef\n  const right = BigInt(dataView.getUint32(byteOffset + 4, true));\n\n  // Combine the two 32-bit values\n  // eslint-disable-next-line no-undef\n  const value = left + BigInt(4294967296) * right;\n  return value;\n}\nfunction getComponentDatatype(componentType) {\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n      return ComponentDatatype.BYTE;\n    case MetadataComponentType.UINT8:\n      return ComponentDatatype.UNSIGNED_BYTE;\n    case MetadataComponentType.INT16:\n      return ComponentDatatype.SHORT;\n    case MetadataComponentType.UINT16:\n      return ComponentDatatype.UNSIGNED_SHORT;\n    case MetadataComponentType.INT32:\n      return ComponentDatatype.INT;\n    case MetadataComponentType.UINT32:\n      return ComponentDatatype.UNSIGNED_INT;\n    case MetadataComponentType.FLOAT32:\n      return ComponentDatatype.FLOAT;\n    case MetadataComponentType.FLOAT64:\n      return ComponentDatatype.DOUBLE;\n  }\n}\nfunction requiresUnpackForGet(property) {\n  if (defined(property._unpackedValues)) {\n    return false;\n  }\n  const classProperty = property._classProperty;\n  const type = classProperty.type;\n  const valueType = classProperty.valueType;\n  if (type === MetadataType.STRING) {\n    // Unpack since UTF-8 decoding is expensive\n    return true;\n  }\n  if (valueType === MetadataComponentType.INT64 && !FeatureDetection.supportsBigInt64Array()) {\n    // Unpack since the fallback INT64 getters are expensive\n    return true;\n  }\n  if (valueType === MetadataComponentType.UINT64 && !FeatureDetection.supportsBigUint64Array()) {\n    // Unpack since the fallback UINT64 getters are expensive\n    return true;\n  }\n  return false;\n}\nfunction requiresUnpackForSet(property, index, value) {\n  if (requiresUnpackForGet(property)) {\n    return true;\n  }\n  const arrayOffsets = property._arrayOffsets;\n  if (defined(arrayOffsets)) {\n    // Unpacking is required if a variable-size array changes length since it\n    // would be expensive to repack the binary data\n    const oldLength = arrayOffsets.get(index + 1) - arrayOffsets.get(index);\n    const newLength = value.length;\n    if (oldLength !== newLength) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction unpackProperty(property) {\n  property._unpackedValues = unpackValues(property);\n\n  // Free memory\n  property._arrayOffsets = undefined;\n  property._stringOffsets = undefined;\n  property._values = undefined;\n}\nfunction unpackValues(property) {\n  const count = property._count;\n  const unpackedValues = new Array(count);\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  // Handle single values\n  if (!isArray && componentCount === 1) {\n    for (let i = 0; i < count; ++i) {\n      unpackedValues[i] = property._getValue(i);\n    }\n    return unpackedValues;\n  }\n  for (let i = 0; i < count; i++) {\n    unpackedValues[i] = getArrayValues(property, classProperty, i);\n  }\n  return unpackedValues;\n}\nfunction applyValueTransform(property, value) {\n  const classProperty = property._classProperty;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  if (!property._hasValueTransform || isVariableLengthArray) {\n    return value;\n  }\n  return MetadataClassProperty.valueTransformInPlace(value, property._offset, property._scale, MetadataComponentType.applyValueTransform);\n}\nfunction unapplyValueTransform(property, value) {\n  const classProperty = property._classProperty;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  if (!property._hasValueTransform || isVariableLengthArray) {\n    return value;\n  }\n  return MetadataClassProperty.valueTransformInPlace(value, property._offset, property._scale, MetadataComponentType.unapplyValueTransform);\n}\nfunction BufferView(bufferView, componentType, length) {\n  const that = this;\n  let typedArray;\n  let getFunction;\n  let setFunction;\n  if (componentType === MetadataComponentType.INT64) {\n    if (!FeatureDetection.supportsBigInt()) {\n      oneTimeWarning(\"INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read.\");\n      typedArray = new Uint8Array(bufferView.buffer, bufferView.byteOffset, length * 8);\n      getFunction = function (index) {\n        return getInt64NumberFallback(index, that);\n      };\n    } else if (!FeatureDetection.supportsBigInt64Array()) {\n      typedArray = new Uint8Array(bufferView.buffer, bufferView.byteOffset, length * 8);\n      getFunction = function (index) {\n        return getInt64BigIntFallback(index, that);\n      };\n    } else {\n      // eslint-disable-next-line\n      typedArray = new BigInt64Array(bufferView.buffer, bufferView.byteOffset, length);\n      setFunction = function (index, value) {\n        // Convert the number to a BigInt before setting the value in the typed array\n        that.typedArray[index] = BigInt(value); // eslint-disable-line\n      };\n    }\n  } else if (componentType === MetadataComponentType.UINT64) {\n    if (!FeatureDetection.supportsBigInt()) {\n      oneTimeWarning(\"UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read.\");\n      typedArray = new Uint8Array(bufferView.buffer, bufferView.byteOffset, length * 8);\n      getFunction = function (index) {\n        return getUint64NumberFallback(index, that);\n      };\n    } else if (!FeatureDetection.supportsBigUint64Array()) {\n      typedArray = new Uint8Array(bufferView.buffer, bufferView.byteOffset, length * 8);\n      getFunction = function (index) {\n        return getUint64BigIntFallback(index, that);\n      };\n    } else {\n      // eslint-disable-next-line\n      typedArray = new BigUint64Array(bufferView.buffer, bufferView.byteOffset, length);\n      setFunction = function (index, value) {\n        // Convert the number to a BigInt before setting the value in the typed array\n        that.typedArray[index] = BigInt(value); // eslint-disable-line\n      };\n    }\n  } else {\n    const componentDatatype = getComponentDatatype(componentType);\n    typedArray = ComponentDatatype.createArrayBufferView(componentDatatype, bufferView.buffer, bufferView.byteOffset, length);\n    setFunction = function (index, value) {\n      that.typedArray[index] = value;\n    };\n  }\n  if (!defined(getFunction)) {\n    getFunction = function (index) {\n      return that.typedArray[index];\n    };\n  }\n  this.typedArray = typedArray;\n  this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset);\n  this.get = getFunction;\n  this.set = setFunction;\n\n  // for unit testing\n  this._componentType = componentType;\n}\nexport default MetadataTableProperty;","map":{"version":3,"names":["Check","clone","ComponentDatatype","defaultValue","defined","DeveloperError","FeatureDetection","getStringFromTypedArray","oneTimeWarning","MetadataComponentType","MetadataClassProperty","MetadataType","MetadataTableProperty","options","EMPTY_OBJECT","count","property","classProperty","bufferViews","typeOf","number","greaterThan","object","type","isArray","isVariableLengthArray","valueType","enumType","hasStrings","STRING","hasBooleans","BOOLEAN","byteLength","arrayOffsets","arrayOffsetType","offsetType","UINT32","arrayOffsetBufferView","BufferView","typedArray","vectorComponentCount","getComponentCount","arrayComponentCount","get","arrayLength","componentCount","stringOffsets","stringOffsetType","stringOffsetBufferView","UINT8","valueCount","Math","ceil","valuesBufferView","values","bufferView","offset","scale","hasValueTransform","flatten","getValueFunction","setValueFunction","that","index","getString","_values","_stringOffsets","getBoolean","value","setBoolean","integer","namesByValue","valuesByName","set","_arrayOffsets","_classProperty","_count","_vectorComponentCount","_min","min","_max","max","_offset","_scale","_hasValueTransform","_getValue","_setValue","_unpackedValues","undefined","_extras","extras","_extensions","extensions","_byteLength","Object","defineProperties","prototype","checkIndex","handleNoData","default","unpackVectorAndMatrixTypes","normalize","applyValueTransform","errorMessage","validate","packVectorAndMatrixTypes","unapplyValueTransform","unnormalize","getTypedArray","Array","result","i","length","push","apply","table","maximumIndex","requiresUnpackForGet","unpackProperty","getArrayValues","requiresUnpackForSet","stringByteOffset","stringByteLength","byteIndex","bitIndex","getInt64NumberFallback","dataView","byteOffset","isNegative","getUint8","carrying","byte","pow","getInt64BigIntFallback","BigInt","getUint64NumberFallback","left","getUint32","right","getUint64BigIntFallback","getComponentDatatype","componentType","INT8","BYTE","UNSIGNED_BYTE","INT16","SHORT","UINT16","UNSIGNED_SHORT","INT32","INT","UNSIGNED_INT","FLOAT32","FLOAT","FLOAT64","DOUBLE","INT64","supportsBigInt64Array","UINT64","supportsBigUint64Array","oldLength","newLength","unpackValues","unpackedValues","valueTransformInPlace","getFunction","setFunction","supportsBigInt","Uint8Array","buffer","BigInt64Array","BigUint64Array","componentDatatype","createArrayBufferView","DataView","_componentType"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/MetadataTableProperty.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataClassProperty from \"./MetadataClassProperty.js\";\nimport MetadataType from \"./MetadataType.js\";\n\n/**\n * A binary property in a {@MetadataTable}\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension}\n * for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}\n * for glTF. For the legacy glTF extension, see {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension}\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.count The number of elements in each property array.\n * @param {object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n * @param {Object<string, Uint8Array>} options.bufferViews An object mapping bufferView IDs to Uint8Array objects.\n *\n * @alias MetadataTableProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataTableProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const count = options.count;\n  const property = options.property;\n  const classProperty = options.classProperty;\n  const bufferViews = options.bufferViews;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", count, 0);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  Check.typeOf.object(\"options.bufferViews\", bufferViews);\n  //>>includeEnd('debug');\n\n  const type = classProperty.type;\n  const isArray = classProperty.isArray;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n\n  let valueType = classProperty.valueType;\n  const enumType = classProperty.enumType;\n\n  const hasStrings = type === MetadataType.STRING;\n  const hasBooleans = type === MetadataType.BOOLEAN;\n\n  let byteLength = 0;\n\n  let arrayOffsets;\n  if (isVariableLengthArray) {\n    // EXT_structural_metadata uses arrayOffsetType.\n    // EXT_feature_metadata uses offsetType for both arrays and strings\n    let arrayOffsetType = defaultValue(\n      property.arrayOffsetType,\n      property.offsetType,\n    );\n    arrayOffsetType = defaultValue(\n      MetadataComponentType[arrayOffsetType],\n      MetadataComponentType.UINT32,\n    );\n\n    // EXT_structural_metadata uses arrayOffsets.\n    // EXT_feature_metadata uses arrayOffsetBufferView\n    const arrayOffsetBufferView = defaultValue(\n      property.arrayOffsets,\n      property.arrayOffsetBufferView,\n    );\n    arrayOffsets = new BufferView(\n      bufferViews[arrayOffsetBufferView],\n      arrayOffsetType,\n      count + 1,\n    );\n\n    byteLength += arrayOffsets.typedArray.byteLength;\n  }\n\n  const vectorComponentCount = MetadataType.getComponentCount(type);\n\n  let arrayComponentCount;\n  if (isVariableLengthArray) {\n    arrayComponentCount = arrayOffsets.get(count) - arrayOffsets.get(0);\n  } else if (isArray) {\n    arrayComponentCount = count * classProperty.arrayLength;\n  } else {\n    arrayComponentCount = count;\n  }\n\n  const componentCount = vectorComponentCount * arrayComponentCount;\n\n  let stringOffsets;\n  if (hasStrings) {\n    // EXT_structural_metadata uses stringOffsetType, EXT_feature_metadata uses offsetType for both arrays and strings\n    let stringOffsetType = defaultValue(\n      property.stringOffsetType,\n      property.offsetType,\n    );\n    stringOffsetType = defaultValue(\n      MetadataComponentType[stringOffsetType],\n      MetadataComponentType.UINT32,\n    );\n\n    // EXT_structural_metadata uses stringOffsets.\n    // EXT_feature_metadata uses stringOffsetBufferView\n    const stringOffsetBufferView = defaultValue(\n      property.stringOffsets,\n      property.stringOffsetBufferView,\n    );\n    stringOffsets = new BufferView(\n      bufferViews[stringOffsetBufferView],\n      stringOffsetType,\n      componentCount + 1,\n    );\n\n    byteLength += stringOffsets.typedArray.byteLength;\n  }\n\n  if (hasStrings || hasBooleans) {\n    // STRING and BOOLEAN types need to be parsed differently than other types\n    valueType = MetadataComponentType.UINT8;\n  }\n\n  let valueCount;\n  if (hasStrings) {\n    valueCount = stringOffsets.get(componentCount) - stringOffsets.get(0);\n  } else if (hasBooleans) {\n    valueCount = Math.ceil(componentCount / 8);\n  } else {\n    valueCount = componentCount;\n  }\n\n  // EXT_structural_metadata uses values\n  // EXT_feature_metadata uses bufferView\n  const valuesBufferView = defaultValue(property.values, property.bufferView);\n  const values = new BufferView(\n    bufferViews[valuesBufferView],\n    valueType,\n    valueCount,\n  );\n  byteLength += values.typedArray.byteLength;\n\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform =\n    classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the table does not define an offset/scale, it inherits from the\n  // class property. The class property handles setting the default of identity:\n  // (offset 0, scale 1) with the same array shape as the property's type\n  // information.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // Since metadata table properties are stored as packed typed\n  // arrays, flatten the offset/scale to make it easier to apply the\n  // transformation by iteration.\n  offset = flatten(offset);\n  scale = flatten(scale);\n\n  let getValueFunction;\n  let setValueFunction;\n  const that = this;\n  if (hasStrings) {\n    getValueFunction = function (index) {\n      return getString(index, that._values, that._stringOffsets);\n    };\n  } else if (hasBooleans) {\n    getValueFunction = function (index) {\n      return getBoolean(index, that._values);\n    };\n    setValueFunction = function (index, value) {\n      setBoolean(index, that._values, value);\n    };\n  } else if (defined(enumType)) {\n    getValueFunction = function (index) {\n      const integer = that._values.get(index);\n      return enumType.namesByValue[integer];\n    };\n    setValueFunction = function (index, value) {\n      const integer = enumType.valuesByName[value];\n      that._values.set(index, integer);\n    };\n  } else {\n    getValueFunction = function (index) {\n      return that._values.get(index);\n    };\n    setValueFunction = function (index, value) {\n      that._values.set(index, value);\n    };\n  }\n\n  this._arrayOffsets = arrayOffsets;\n  this._stringOffsets = stringOffsets;\n  this._values = values;\n  this._classProperty = classProperty;\n  this._count = count;\n  this._vectorComponentCount = vectorComponentCount;\n  this._min = property.min;\n  this._max = property.max;\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n  this._getValue = getValueFunction;\n  this._setValue = setValueFunction;\n  this._unpackedValues = undefined;\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n  this._byteLength = byteLength;\n}\n\nObject.defineProperties(MetadataTableProperty.prototype, {\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * An object containing extensions.\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n\n  /**\n   * Size of all typed arrays used by this table property\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {Normal}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    },\n  },\n});\n\n/**\n * Returns a copy of the value at the given index.\n *\n * @param {number} index The index.\n * @returns {*} The value of the property.\n *\n * @private\n */\nMetadataTableProperty.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  checkIndex(this, index);\n  //>>includeEnd('debug');\n\n  let value = get(this, index);\n\n  // handle noData and default\n  value = this._classProperty.handleNoData(value);\n  if (!defined(value)) {\n    value = this._classProperty.default;\n    return this._classProperty.unpackVectorAndMatrixTypes(value);\n  }\n\n  value = this._classProperty.normalize(value);\n  value = applyValueTransform(this, value);\n  return this._classProperty.unpackVectorAndMatrixTypes(value);\n};\n\n/**\n * Sets the value at the given index.\n *\n * @param {number} index The index.\n * @param {*} value The value of the property.\n *\n * @private\n */\nMetadataTableProperty.prototype.set = function (index, value) {\n  const classProperty = this._classProperty;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  checkIndex(this, index);\n  const errorMessage = classProperty.validate(value);\n  if (defined(errorMessage)) {\n    throw new DeveloperError(errorMessage);\n  }\n  //>>includeEnd('debug');\n\n  value = classProperty.packVectorAndMatrixTypes(value);\n  value = unapplyValueTransform(this, value);\n  value = classProperty.unnormalize(value);\n\n  set(this, index, value);\n};\n\n/**\n * Returns a typed array containing the property values.\n *\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTableProperty.prototype.getTypedArray = function () {\n  // Note: depending on the class definition some properties are unpacked to\n  // JS arrays when first accessed and values will be undefined. Generally not\n  // a concern for fixed-length arrays of numbers.\n  if (defined(this._values)) {\n    return this._values.typedArray;\n  }\n\n  return undefined;\n};\n\nfunction flatten(values) {\n  if (!Array.isArray(values)) {\n    return values;\n  }\n\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (Array.isArray(value)) {\n      result.push.apply(result, value);\n    } else {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n\nfunction checkIndex(table, index) {\n  const count = table._count;\n  if (!defined(index) || index < 0 || index >= count) {\n    const maximumIndex = count - 1;\n    throw new DeveloperError(\n      `index is required and between zero and count - 1. Actual value: ${maximumIndex}`,\n    );\n  }\n}\n\nfunction get(property, index) {\n  if (requiresUnpackForGet(property)) {\n    unpackProperty(property);\n  }\n\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  if (defined(property._unpackedValues)) {\n    const value = property._unpackedValues[index];\n    if (isArray) {\n      return clone(value, true);\n    }\n    return value;\n  }\n\n  // handle single values\n  if (!isArray && componentCount === 1) {\n    return property._getValue(index);\n  }\n\n  return getArrayValues(property, classProperty, index);\n}\n\nfunction getArrayValues(property, classProperty, index) {\n  let offset;\n  let length;\n  if (classProperty.isVariableLengthArray) {\n    offset = property._arrayOffsets.get(index);\n    length = property._arrayOffsets.get(index + 1) - offset;\n\n    // for vectors and matrices, the offset and length need to be multiplied\n    // by the component count\n    const componentCount = MetadataType.getComponentCount(classProperty.type);\n    offset *= componentCount;\n    length *= componentCount;\n  } else {\n    const arrayLength = defaultValue(classProperty.arrayLength, 1);\n    const componentCount = arrayLength * property._vectorComponentCount;\n    offset = index * componentCount;\n    length = componentCount;\n  }\n\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    values[i] = property._getValue(offset + i);\n  }\n\n  return values;\n}\n\nfunction set(property, index, value) {\n  if (requiresUnpackForSet(property, index, value)) {\n    unpackProperty(property);\n  }\n\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  if (defined(property._unpackedValues)) {\n    if (classProperty.isArray) {\n      value = clone(value, true);\n    }\n    property._unpackedValues[index] = value;\n    return;\n  }\n\n  // Values are unpacked if the length of a variable-size array changes or the\n  // property has strings. No need to handle these cases below.\n\n  // Handle single values\n  if (!isArray && componentCount === 1) {\n    property._setValue(index, value);\n    return;\n  }\n\n  let offset;\n  let length;\n  if (classProperty.isVariableLengthArray) {\n    offset = property._arrayOffsets.get(index);\n    length = property._arrayOffsets.get(index + 1) - offset;\n  } else {\n    const arrayLength = defaultValue(classProperty.arrayLength, 1);\n    const componentCount = arrayLength * property._vectorComponentCount;\n    offset = index * componentCount;\n    length = componentCount;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    property._setValue(offset + i, value[i]);\n  }\n}\n\nfunction getString(index, values, stringOffsets) {\n  const stringByteOffset = stringOffsets.get(index);\n  const stringByteLength = stringOffsets.get(index + 1) - stringByteOffset;\n  return getStringFromTypedArray(\n    values.typedArray,\n    stringByteOffset,\n    stringByteLength,\n  );\n}\n\nfunction getBoolean(index, values) {\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n  return ((values.typedArray[byteIndex] >> bitIndex) & 1) === 1;\n}\n\nfunction setBoolean(index, values, value) {\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n\n  if (value) {\n    values.typedArray[byteIndex] |= 1 << bitIndex;\n  } else {\n    values.typedArray[byteIndex] &= ~(1 << bitIndex);\n  }\n}\n\nfunction getInt64NumberFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n  let value = 0;\n  const isNegative = (dataView.getUint8(byteOffset + 7) & 0x80) > 0;\n  let carrying = true;\n  for (let i = 0; i < 8; ++i) {\n    let byte = dataView.getUint8(byteOffset + i);\n    if (isNegative) {\n      if (carrying) {\n        if (byte !== 0x00) {\n          byte = ~(byte - 1) & 0xff;\n          carrying = false;\n        }\n      } else {\n        byte = ~byte & 0xff;\n      }\n    }\n    value += byte * Math.pow(256, i);\n  }\n  if (isNegative) {\n    value = -value;\n  }\n  return value;\n}\n\nfunction getInt64BigIntFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n  // eslint-disable-next-line no-undef\n  let value = BigInt(0);\n  const isNegative = (dataView.getUint8(byteOffset + 7) & 0x80) > 0;\n  let carrying = true;\n  for (let i = 0; i < 8; ++i) {\n    let byte = dataView.getUint8(byteOffset + i);\n    if (isNegative) {\n      if (carrying) {\n        if (byte !== 0x00) {\n          byte = ~(byte - 1) & 0xff;\n          carrying = false;\n        }\n      } else {\n        byte = ~byte & 0xff;\n      }\n    }\n    value += BigInt(byte) * (BigInt(1) << BigInt(i * 8)); // eslint-disable-line\n  }\n  if (isNegative) {\n    value = -value;\n  }\n  return value;\n}\n\nfunction getUint64NumberFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n\n  // Split 64-bit number into two 32-bit (4-byte) parts\n  const left = dataView.getUint32(byteOffset, true);\n  const right = dataView.getUint32(byteOffset + 4, true);\n\n  // Combine the two 32-bit values\n  const value = left + 4294967296 * right;\n\n  return value;\n}\n\nfunction getUint64BigIntFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n\n  // Split 64-bit number into two 32-bit (4-byte) parts\n  // eslint-disable-next-line no-undef\n  const left = BigInt(dataView.getUint32(byteOffset, true));\n\n  // eslint-disable-next-line no-undef\n  const right = BigInt(dataView.getUint32(byteOffset + 4, true));\n\n  // Combine the two 32-bit values\n  // eslint-disable-next-line no-undef\n  const value = left + BigInt(4294967296) * right;\n\n  return value;\n}\n\nfunction getComponentDatatype(componentType) {\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n      return ComponentDatatype.BYTE;\n    case MetadataComponentType.UINT8:\n      return ComponentDatatype.UNSIGNED_BYTE;\n    case MetadataComponentType.INT16:\n      return ComponentDatatype.SHORT;\n    case MetadataComponentType.UINT16:\n      return ComponentDatatype.UNSIGNED_SHORT;\n    case MetadataComponentType.INT32:\n      return ComponentDatatype.INT;\n    case MetadataComponentType.UINT32:\n      return ComponentDatatype.UNSIGNED_INT;\n    case MetadataComponentType.FLOAT32:\n      return ComponentDatatype.FLOAT;\n    case MetadataComponentType.FLOAT64:\n      return ComponentDatatype.DOUBLE;\n  }\n}\n\nfunction requiresUnpackForGet(property) {\n  if (defined(property._unpackedValues)) {\n    return false;\n  }\n\n  const classProperty = property._classProperty;\n  const type = classProperty.type;\n  const valueType = classProperty.valueType;\n\n  if (type === MetadataType.STRING) {\n    // Unpack since UTF-8 decoding is expensive\n    return true;\n  }\n\n  if (\n    valueType === MetadataComponentType.INT64 &&\n    !FeatureDetection.supportsBigInt64Array()\n  ) {\n    // Unpack since the fallback INT64 getters are expensive\n    return true;\n  }\n\n  if (\n    valueType === MetadataComponentType.UINT64 &&\n    !FeatureDetection.supportsBigUint64Array()\n  ) {\n    // Unpack since the fallback UINT64 getters are expensive\n    return true;\n  }\n\n  return false;\n}\n\nfunction requiresUnpackForSet(property, index, value) {\n  if (requiresUnpackForGet(property)) {\n    return true;\n  }\n\n  const arrayOffsets = property._arrayOffsets;\n  if (defined(arrayOffsets)) {\n    // Unpacking is required if a variable-size array changes length since it\n    // would be expensive to repack the binary data\n    const oldLength = arrayOffsets.get(index + 1) - arrayOffsets.get(index);\n    const newLength = value.length;\n    if (oldLength !== newLength) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction unpackProperty(property) {\n  property._unpackedValues = unpackValues(property);\n\n  // Free memory\n  property._arrayOffsets = undefined;\n  property._stringOffsets = undefined;\n  property._values = undefined;\n}\n\nfunction unpackValues(property) {\n  const count = property._count;\n  const unpackedValues = new Array(count);\n\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  // Handle single values\n  if (!isArray && componentCount === 1) {\n    for (let i = 0; i < count; ++i) {\n      unpackedValues[i] = property._getValue(i);\n    }\n    return unpackedValues;\n  }\n\n  for (let i = 0; i < count; i++) {\n    unpackedValues[i] = getArrayValues(property, classProperty, i);\n  }\n  return unpackedValues;\n}\n\nfunction applyValueTransform(property, value) {\n  const classProperty = property._classProperty;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  if (!property._hasValueTransform || isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    property._offset,\n    property._scale,\n    MetadataComponentType.applyValueTransform,\n  );\n}\n\nfunction unapplyValueTransform(property, value) {\n  const classProperty = property._classProperty;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  if (!property._hasValueTransform || isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    property._offset,\n    property._scale,\n    MetadataComponentType.unapplyValueTransform,\n  );\n}\n\nfunction BufferView(bufferView, componentType, length) {\n  const that = this;\n\n  let typedArray;\n  let getFunction;\n  let setFunction;\n\n  if (componentType === MetadataComponentType.INT64) {\n    if (!FeatureDetection.supportsBigInt()) {\n      oneTimeWarning(\n        \"INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read.\",\n      );\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8,\n      );\n      getFunction = function (index) {\n        return getInt64NumberFallback(index, that);\n      };\n    } else if (!FeatureDetection.supportsBigInt64Array()) {\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8,\n      );\n      getFunction = function (index) {\n        return getInt64BigIntFallback(index, that);\n      };\n    } else {\n      // eslint-disable-next-line\n      typedArray = new BigInt64Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length,\n      );\n      setFunction = function (index, value) {\n        // Convert the number to a BigInt before setting the value in the typed array\n        that.typedArray[index] = BigInt(value); // eslint-disable-line\n      };\n    }\n  } else if (componentType === MetadataComponentType.UINT64) {\n    if (!FeatureDetection.supportsBigInt()) {\n      oneTimeWarning(\n        \"UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read.\",\n      );\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8,\n      );\n      getFunction = function (index) {\n        return getUint64NumberFallback(index, that);\n      };\n    } else if (!FeatureDetection.supportsBigUint64Array()) {\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8,\n      );\n      getFunction = function (index) {\n        return getUint64BigIntFallback(index, that);\n      };\n    } else {\n      // eslint-disable-next-line\n      typedArray = new BigUint64Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length,\n      );\n      setFunction = function (index, value) {\n        // Convert the number to a BigInt before setting the value in the typed array\n        that.typedArray[index] = BigInt(value); // eslint-disable-line\n      };\n    }\n  } else {\n    const componentDatatype = getComponentDatatype(componentType);\n    typedArray = ComponentDatatype.createArrayBufferView(\n      componentDatatype,\n      bufferView.buffer,\n      bufferView.byteOffset,\n      length,\n    );\n    setFunction = function (index, value) {\n      that.typedArray[index] = value;\n    };\n  }\n\n  if (!defined(getFunction)) {\n    getFunction = function (index) {\n      return that.typedArray[index];\n    };\n  }\n\n  this.typedArray = typedArray;\n  this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset);\n  this.get = getFunction;\n  this.set = setFunction;\n\n  // for unit testing\n  this._componentType = componentType;\n}\n\nexport default MetadataTableProperty;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}