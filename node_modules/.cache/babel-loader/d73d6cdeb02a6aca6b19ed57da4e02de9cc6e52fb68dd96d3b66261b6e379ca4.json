{"ast":null,"code":"import ForEach from \"./ForEach.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensions, gltf.extensionsUsed, gltf.extensionsRequired, and any other objects in the glTF if it is present.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to remove.\n *\n * @returns {*} The extension data removed from gltf.extensions.\n */\nfunction removeExtension(gltf, extension) {\n  removeExtensionsUsed(gltf, extension); // Also removes from extensionsRequired\n\n  if (extension === \"CESIUM_RTC\") {\n    removeCesiumRTC(gltf);\n  }\n  return removeExtensionAndTraverse(gltf, extension);\n}\nfunction removeCesiumRTC(gltf) {\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (uniform.semantic === \"CESIUM_RTC_MODELVIEW\") {\n        uniform.semantic = \"MODELVIEW\";\n      }\n    });\n  });\n}\nfunction removeExtensionAndTraverse(object, extension) {\n  if (Array.isArray(object)) {\n    const length = object.length;\n    for (let i = 0; i < length; ++i) {\n      removeExtensionAndTraverse(object[i], extension);\n    }\n  } else if (object !== null && typeof object === \"object\" && object.constructor === Object) {\n    const extensions = object.extensions;\n    let extensionData;\n    if (defined(extensions)) {\n      extensionData = extensions[extension];\n      if (defined(extensionData)) {\n        delete extensions[extension];\n        if (Object.keys(extensions).length === 0) {\n          delete object.extensions;\n        }\n      }\n    }\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        removeExtensionAndTraverse(object[key], extension);\n      }\n    }\n    return extensionData;\n  }\n}\nexport default removeExtension;","map":{"version":3,"names":["ForEach","removeExtensionsUsed","defined","removeExtension","gltf","extension","removeCesiumRTC","removeExtensionAndTraverse","technique","techniqueUniform","uniform","semantic","object","Array","isArray","length","i","constructor","Object","extensions","extensionData","keys","key","prototype","hasOwnProperty","call"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfPipeline/removeExtension.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensions, gltf.extensionsUsed, gltf.extensionsRequired, and any other objects in the glTF if it is present.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string} extension The extension to remove.\n *\n * @returns {*} The extension data removed from gltf.extensions.\n */\nfunction removeExtension(gltf, extension) {\n  removeExtensionsUsed(gltf, extension); // Also removes from extensionsRequired\n\n  if (extension === \"CESIUM_RTC\") {\n    removeCesiumRTC(gltf);\n  }\n\n  return removeExtensionAndTraverse(gltf, extension);\n}\n\nfunction removeCesiumRTC(gltf) {\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (uniform.semantic === \"CESIUM_RTC_MODELVIEW\") {\n        uniform.semantic = \"MODELVIEW\";\n      }\n    });\n  });\n}\n\nfunction removeExtensionAndTraverse(object, extension) {\n  if (Array.isArray(object)) {\n    const length = object.length;\n    for (let i = 0; i < length; ++i) {\n      removeExtensionAndTraverse(object[i], extension);\n    }\n  } else if (\n    object !== null &&\n    typeof object === \"object\" &&\n    object.constructor === Object\n  ) {\n    const extensions = object.extensions;\n    let extensionData;\n    if (defined(extensions)) {\n      extensionData = extensions[extension];\n      if (defined(extensionData)) {\n        delete extensions[extension];\n        if (Object.keys(extensions).length === 0) {\n          delete object.extensions;\n        }\n      }\n    }\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        removeExtensionAndTraverse(object[key], extension);\n      }\n    }\n    return extensionData;\n  }\n}\n\nexport default removeExtension;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,cAAc;AAClC,OAAOC,oBAAoB,MAAM,2BAA2B;AAC5D,OAAOC,OAAO,MAAM,uBAAuB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,IAAI,EAAEC,SAAS,EAAE;EACxCJ,oBAAoB,CAACG,IAAI,EAAEC,SAAS,CAAC,CAAC,CAAC;;EAEvC,IAAIA,SAAS,KAAK,YAAY,EAAE;IAC9BC,eAAe,CAACF,IAAI,CAAC;EACvB;EAEA,OAAOG,0BAA0B,CAACH,IAAI,EAAEC,SAAS,CAAC;AACpD;AAEA,SAASC,eAAeA,CAACF,IAAI,EAAE;EAC7BJ,OAAO,CAACQ,SAAS,CAACJ,IAAI,EAAE,UAAUI,SAAS,EAAE;IAC3CR,OAAO,CAACS,gBAAgB,CAACD,SAAS,EAAE,UAAUE,OAAO,EAAE;MACrD,IAAIA,OAAO,CAACC,QAAQ,KAAK,sBAAsB,EAAE;QAC/CD,OAAO,CAACC,QAAQ,GAAG,WAAW;MAChC;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,SAASJ,0BAA0BA,CAACK,MAAM,EAAEP,SAAS,EAAE;EACrD,IAAIQ,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;IACzB,MAAMG,MAAM,GAAGH,MAAM,CAACG,MAAM;IAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAE,EAAEC,CAAC,EAAE;MAC/BT,0BAA0B,CAACK,MAAM,CAACI,CAAC,CAAC,EAAEX,SAAS,CAAC;IAClD;EACF,CAAC,MAAM,IACLO,MAAM,KAAK,IAAI,IACf,OAAOA,MAAM,KAAK,QAAQ,IAC1BA,MAAM,CAACK,WAAW,KAAKC,MAAM,EAC7B;IACA,MAAMC,UAAU,GAAGP,MAAM,CAACO,UAAU;IACpC,IAAIC,aAAa;IACjB,IAAIlB,OAAO,CAACiB,UAAU,CAAC,EAAE;MACvBC,aAAa,GAAGD,UAAU,CAACd,SAAS,CAAC;MACrC,IAAIH,OAAO,CAACkB,aAAa,CAAC,EAAE;QAC1B,OAAOD,UAAU,CAACd,SAAS,CAAC;QAC5B,IAAIa,MAAM,CAACG,IAAI,CAACF,UAAU,CAAC,CAACJ,MAAM,KAAK,CAAC,EAAE;UACxC,OAAOH,MAAM,CAACO,UAAU;QAC1B;MACF;IACF;IACA,KAAK,MAAMG,GAAG,IAAIV,MAAM,EAAE;MACxB,IAAIM,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACb,MAAM,EAAEU,GAAG,CAAC,EAAE;QACrDf,0BAA0B,CAACK,MAAM,CAACU,GAAG,CAAC,EAAEjB,SAAS,CAAC;MACpD;IACF;IACA,OAAOe,aAAa;EACtB;AACF;AAEA,eAAejB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}