{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads an index buffer from a glTF accessor.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfIndexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load the index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load the index buffer as a typed array.\n * @private\n */\nfunction GltfIndexBufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const draco = options.draco;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  //>>includeEnd('debug');\n\n  const indexDatatype = gltf.accessors[accessorId].componentType;\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._accessorId = accessorId;\n  this._indexDatatype = indexDatatype;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfIndexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfIndexBufferLoader.prototype.constructor = GltfIndexBufferLoader;\n}\nObject.defineProperties(GltfIndexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The index buffer. This is only defined when <code>loadBuffer</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    }\n  },\n  /**\n   * The typed array containing indices. This is only defined when <code>loadTypedArray</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    }\n  },\n  /**\n   * The index datatype after decode.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {IndexDatatype}\n   * @readonly\n   * @private\n   */\n  indexDatatype: {\n    get: function () {\n      return this._indexDatatype;\n    }\n  }\n});\nconst scratchIndexBufferJob = new CreateIndexBufferJob();\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfIndexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfIndexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  if (defined(this._draco)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\nasync function loadFromDraco(indexBufferLoader) {\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: indexBufferLoader._gltf,\n      draco: indexBufferLoader._draco,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource\n    });\n    indexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    indexBufferLoader._state = ResourceLoaderState.LOADED;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(indexBufferLoader, error);\n  }\n}\nasync function loadFromBufferView(indexBufferLoader) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: gltf,\n      bufferViewId: bufferViewId,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource\n    });\n    indexBufferLoader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    const bufferViewTypedArray = bufferViewLoader.typedArray;\n    indexBufferLoader._typedArray = createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray);\n    indexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(indexBufferLoader, error);\n  }\n}\nfunction createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const count = accessor.count;\n  const indexDatatype = accessor.componentType;\n  const indexSize = IndexDatatype.getSizeInBytes(indexDatatype);\n  let arrayBuffer = bufferViewTypedArray.buffer;\n  let byteOffset = bufferViewTypedArray.byteOffset + accessor.byteOffset;\n  if (byteOffset % indexSize !== 0) {\n    const byteLength = count * indexSize;\n    const view = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n    const copy = new Uint8Array(view);\n    arrayBuffer = copy.buffer;\n    byteOffset = 0;\n    deprecationWarning(\"index-buffer-unaligned\", `The index array is not aligned to a ${indexSize}-byte boundary.`);\n  }\n  let typedArray;\n  if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n    typedArray = new Uint8Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    typedArray = new Uint16Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n    typedArray = new Uint32Array(arrayBuffer, byteOffset, count);\n  }\n  return typedArray;\n}\nfunction handleError(indexBufferLoader, error) {\n  indexBufferLoader.unload();\n  indexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load index buffer\";\n  throw indexBufferLoader.getError(errorMessage, error);\n}\nfunction CreateIndexBufferJob() {\n  this.typedArray = undefined;\n  this.indexDatatype = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\nCreateIndexBufferJob.prototype.set = function (typedArray, indexDatatype, context) {\n  this.typedArray = typedArray;\n  this.indexDatatype = indexDatatype;\n  this.context = context;\n};\nCreateIndexBufferJob.prototype.execute = function () {\n  this.buffer = createIndexBuffer(this.typedArray, this.indexDatatype, this.context);\n};\nfunction createIndexBuffer(typedArray, indexDatatype, context) {\n  const buffer = Buffer.createIndexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfIndexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED && this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n  let typedArray = this._typedArray;\n  let indexDatatype = this._indexDatatype;\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (ready) {\n        const dracoLoader = this._dracoLoader;\n        typedArray = dracoLoader.decodedData.indices.typedArray;\n        this._typedArray = typedArray;\n        // The index datatype may be a smaller datatype after draco decode\n        indexDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        this._indexDatatype = indexDatatype;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n  }\n  if (!defined(typedArray)) {\n    // Buffer view hasn't been loaded yet\n    return false;\n  }\n  let buffer;\n  if (this._loadBuffer && this._asynchronous) {\n    const indexBufferJob = scratchIndexBufferJob;\n    indexBufferJob.set(typedArray, indexDatatype, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(indexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = indexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createIndexBuffer(typedArray, indexDatatype, frameState.context);\n  }\n\n  // Unload everything except the index buffer and/or typed array.\n  this.unload();\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfIndexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n  const resourceCache = this._resourceCache;\n  if (defined(this._bufferViewLoader) && !this._bufferViewLoader.isDestroyed()) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n};\nexport default GltfIndexBufferLoader;","map":{"version":3,"names":["Check","ComponentDatatype","defaultValue","defined","deprecationWarning","DeveloperError","IndexDatatype","Buffer","BufferUsage","JobType","ResourceLoader","ResourceLoaderState","GltfIndexBufferLoader","options","EMPTY_OBJECT","resourceCache","gltf","accessorId","gltfResource","baseResource","draco","cacheKey","asynchronous","loadBuffer","loadTypedArray","typeOf","func","object","number","indexDatatype","accessors","componentType","_resourceCache","_gltfResource","_baseResource","_gltf","_accessorId","_indexDatatype","_draco","_cacheKey","_asynchronous","_loadBuffer","_loadTypedArray","_bufferViewLoader","undefined","_dracoLoader","_typedArray","_buffer","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","buffer","typedArray","scratchIndexBufferJob","CreateIndexBufferJob","load","loadFromDraco","loadFromBufferView","indexBufferLoader","LOADING","dracoLoader","getDracoLoader","isDestroyed","LOADED","error","handleError","accessor","bufferViewId","bufferView","bufferViewLoader","getBufferViewLoader","bufferViewTypedArray","createIndicesTypedArray","PROCESSING","count","indexSize","getSizeInBytes","arrayBuffer","byteOffset","byteLength","view","Uint8Array","copy","UNSIGNED_BYTE","UNSIGNED_SHORT","Uint16Array","UNSIGNED_INT","Uint32Array","unload","FAILED","errorMessage","getError","context","set","execute","createIndexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","process","frameState","READY","ready","decodedData","indices","fromTypedArray","indexBufferJob","jobScheduler","BUFFER","statistics","addGeometryLoader","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfIndexBufferLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads an index buffer from a glTF accessor.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfIndexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load the index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load the index buffer as a typed array.\n * @private\n */\nfunction GltfIndexBufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const draco = options.draco;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indexDatatype = gltf.accessors[accessorId].componentType;\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._accessorId = accessorId;\n  this._indexDatatype = indexDatatype;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfIndexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfIndexBufferLoader.prototype.constructor = GltfIndexBufferLoader;\n}\n\nObject.defineProperties(GltfIndexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The index buffer. This is only defined when <code>loadBuffer</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The typed array containing indices. This is only defined when <code>loadTypedArray</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n\n  /**\n   * The index datatype after decode.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {IndexDatatype}\n   * @readonly\n   * @private\n   */\n  indexDatatype: {\n    get: function () {\n      return this._indexDatatype;\n    },\n  },\n});\n\nconst scratchIndexBufferJob = new CreateIndexBufferJob();\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfIndexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfIndexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  if (defined(this._draco)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\n\nasync function loadFromDraco(indexBufferLoader) {\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: indexBufferLoader._gltf,\n      draco: indexBufferLoader._draco,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource,\n    });\n    indexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    indexBufferLoader._state = ResourceLoaderState.LOADED;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(indexBufferLoader, error);\n  }\n}\n\nasync function loadFromBufferView(indexBufferLoader) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: gltf,\n      bufferViewId: bufferViewId,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource,\n    });\n    indexBufferLoader._bufferViewLoader = bufferViewLoader;\n\n    await bufferViewLoader.load();\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    const bufferViewTypedArray = bufferViewLoader.typedArray;\n    indexBufferLoader._typedArray = createIndicesTypedArray(\n      indexBufferLoader,\n      bufferViewTypedArray,\n    );\n    indexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(indexBufferLoader, error);\n  }\n}\n\nfunction createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const count = accessor.count;\n  const indexDatatype = accessor.componentType;\n  const indexSize = IndexDatatype.getSizeInBytes(indexDatatype);\n\n  let arrayBuffer = bufferViewTypedArray.buffer;\n  let byteOffset = bufferViewTypedArray.byteOffset + accessor.byteOffset;\n\n  if (byteOffset % indexSize !== 0) {\n    const byteLength = count * indexSize;\n    const view = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n    const copy = new Uint8Array(view);\n    arrayBuffer = copy.buffer;\n    byteOffset = 0;\n    deprecationWarning(\n      \"index-buffer-unaligned\",\n      `The index array is not aligned to a ${indexSize}-byte boundary.`,\n    );\n  }\n\n  let typedArray;\n  if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n    typedArray = new Uint8Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    typedArray = new Uint16Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n    typedArray = new Uint32Array(arrayBuffer, byteOffset, count);\n  }\n\n  return typedArray;\n}\n\nfunction handleError(indexBufferLoader, error) {\n  indexBufferLoader.unload();\n  indexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load index buffer\";\n  throw indexBufferLoader.getError(errorMessage, error);\n}\n\nfunction CreateIndexBufferJob() {\n  this.typedArray = undefined;\n  this.indexDatatype = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\n\nCreateIndexBufferJob.prototype.set = function (\n  typedArray,\n  indexDatatype,\n  context,\n) {\n  this.typedArray = typedArray;\n  this.indexDatatype = indexDatatype;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  this.buffer = createIndexBuffer(\n    this.typedArray,\n    this.indexDatatype,\n    this.context,\n  );\n};\n\nfunction createIndexBuffer(typedArray, indexDatatype, context) {\n  const buffer = Buffer.createIndexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfIndexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (\n    this._state !== ResourceLoaderState.LOADED &&\n    this._state !== ResourceLoaderState.PROCESSING\n  ) {\n    return false;\n  }\n\n  let typedArray = this._typedArray;\n  let indexDatatype = this._indexDatatype;\n\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (ready) {\n        const dracoLoader = this._dracoLoader;\n        typedArray = dracoLoader.decodedData.indices.typedArray;\n        this._typedArray = typedArray;\n        // The index datatype may be a smaller datatype after draco decode\n        indexDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        this._indexDatatype = indexDatatype;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n  }\n\n  if (!defined(typedArray)) {\n    // Buffer view hasn't been loaded yet\n    return false;\n  }\n\n  let buffer;\n  if (this._loadBuffer && this._asynchronous) {\n    const indexBufferJob = scratchIndexBufferJob;\n    indexBufferJob.set(typedArray, indexDatatype, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(indexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = indexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createIndexBuffer(typedArray, indexDatatype, frameState.context);\n  }\n\n  // Unload everything except the index buffer and/or typed array.\n  this.unload();\n\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfIndexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n\n  const resourceCache = this._resourceCache;\n\n  if (\n    defined(this._bufferViewLoader) &&\n    !this._bufferViewLoader.isDestroyed()\n  ) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n};\n\nexport default GltfIndexBufferLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}