{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// robust iterative solution without trig functions\\n\\\n// https://github.com/0xfaded/ellipse_demo/issues/1\\n\\\n// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\\n\\\n//\\n\\\n// This version uses only a single iteration for best performance. For fog\\n\\\n// rendering, the difference is negligible.\\n\\\nvec2 nearestPointOnEllipseFast(vec2 pos, vec2 radii) {\\n\\\n    vec2 p = abs(pos);\\n\\\n    vec2 inverseRadii = 1.0 / radii;\\n\\\n    vec2 evoluteScale = (radii.x * radii.x - radii.y * radii.y) * vec2(1.0, -1.0) * inverseRadii;\\n\\\n\\n\\\n    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\\n\\\n    // but store the cos and sin of t in a vec2 for efficiency.\\n\\\n    // Initial guess: t = cos(pi/4)\\n\\\n    vec2 tTrigs = vec2(0.70710678118);\\n\\\n    vec2 v = radii * tTrigs;\\n\\\n\\n\\\n    // Find the evolute of the ellipse (center of curvature) at v.\\n\\\n    vec2 evolute = evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n    // Find the (approximate) intersection of p - evolute with the ellipsoid.\\n\\\n    vec2 q = normalize(p - evolute) * length(v - evolute);\\n\\\n    // Update the estimate of t.\\n\\\n    tTrigs = (q + evolute) * inverseRadii;\\n\\\n    tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));\\n\\\n    v = radii * tTrigs;\\n\\\n\\n\\\n    return v * sign(pos);\\n\\\n}\\n\\\n\\n\\\nvec3 computeEllipsoidPositionWC(vec3 positionMC) {\\n\\\n    // Get the world-space position and project onto a meridian plane of\\n\\\n    // the ellipsoid\\n\\\n    vec3 positionWC = (czm_model * vec4(positionMC, 1.0)).xyz;\\n\\\n\\n\\\n    vec2 positionEllipse = vec2(length(positionWC.xy), positionWC.z);\\n\\\n    vec2 nearestPoint = nearestPointOnEllipseFast(positionEllipse, czm_ellipsoidRadii.xz);\\n\\\n\\n\\\n    // Reconstruct a 3D point in world space\\n\\\n    return vec3(nearestPoint.x * normalize(positionWC.xy), nearestPoint.y);\\n\\\n}\\n\\\n\\n\\\nvoid applyFog(inout vec4 color, vec4 groundAtmosphereColor, vec3 lightDirection, float distanceToCamera) {\\n\\\n\\n\\\n    vec3 fogColor = groundAtmosphereColor.rgb;\\n\\\n\\n\\\n    // If there is dynamic lighting, apply that to the fog.\\n\\\n    const float NONE = 0.0;\\n\\\n    if (czm_atmosphereDynamicLighting != NONE) {\\n\\\n        float darken = clamp(dot(normalize(czm_viewerPositionWC), lightDirection), czm_fogMinimumBrightness, 1.0);\\n\\\n        fogColor *= darken;\\n\\\n    }\\n\\\n\\n\\\n    // Tonemap if HDR rendering is disabled\\n\\\n    #ifndef HDR\\n\\\n        fogColor.rgb = czm_pbrNeutralTonemapping(fogColor.rgb);\\n\\\n        fogColor.rgb = czm_inverseGamma(fogColor.rgb);\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 withFog = czm_fog(distanceToCamera, color.rgb, fogColor, czm_fogVisualDensityScalar);\\n\\\n    color = vec4(withFog, color.a);\\n\\\n}\\n\\\n\\n\\\nvoid atmosphereStage(inout vec4 color, in ProcessedAttributes attributes) {\\n\\\n    vec3 rayleighColor;\\n\\\n    vec3 mieColor;\\n\\\n    float opacity;\\n\\\n\\n\\\n    vec3 positionWC;\\n\\\n    vec3 lightDirection;\\n\\\n\\n\\\n    // When the camera is in space, compute the position per-fragment for\\n\\\n    // more accurate ground atmosphere. All other cases will use\\n\\\n    //\\n\\\n    // The if condition will be added in https://github.com/CesiumGS/cesium/issues/11717\\n\\\n    if (false) {\\n\\\n        positionWC = computeEllipsoidPositionWC(attributes.positionMC);\\n\\\n        lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC, czm_atmosphereDynamicLighting);\\n\\\n\\n\\\n        // The fog color is derived from the ground atmosphere color\\n\\\n        czm_computeGroundAtmosphereScattering(\\n\\\n            positionWC,\\n\\\n            lightDirection,\\n\\\n            rayleighColor,\\n\\\n            mieColor,\\n\\\n            opacity\\n\\\n        );\\n\\\n    } else {\\n\\\n        positionWC = attributes.positionWC;\\n\\\n        lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC, czm_atmosphereDynamicLighting);\\n\\\n        rayleighColor = v_atmosphereRayleighColor;\\n\\\n        mieColor = v_atmosphereMieColor;\\n\\\n        opacity = v_atmosphereOpacity;\\n\\\n    }\\n\\\n\\n\\\n    //color correct rayleigh and mie colors\\n\\\n    const bool ignoreBlackPixels = true;\\n\\\n    rayleighColor = czm_applyHSBShift(rayleighColor, czm_atmosphereHsbShift, ignoreBlackPixels);\\n\\\n    mieColor = czm_applyHSBShift(mieColor, czm_atmosphereHsbShift, ignoreBlackPixels);\\n\\\n\\n\\\n    vec4 groundAtmosphereColor = czm_computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n    if (u_isInFog) {\\n\\\n        float distanceToCamera = length(attributes.positionEC);\\n\\\n        applyFog(color, groundAtmosphereColor, lightDirection, distanceToCamera);\\n\\\n    } else {\\n\\\n        // Ground atmosphere\\n\\\n    }\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Model/AtmosphereStageFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// robust iterative solution without trig functions\\n\\\n// https://github.com/0xfaded/ellipse_demo/issues/1\\n\\\n// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\\n\\\n//\\n\\\n// This version uses only a single iteration for best performance. For fog\\n\\\n// rendering, the difference is negligible.\\n\\\nvec2 nearestPointOnEllipseFast(vec2 pos, vec2 radii) {\\n\\\n    vec2 p = abs(pos);\\n\\\n    vec2 inverseRadii = 1.0 / radii;\\n\\\n    vec2 evoluteScale = (radii.x * radii.x - radii.y * radii.y) * vec2(1.0, -1.0) * inverseRadii;\\n\\\n\\n\\\n    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\\n\\\n    // but store the cos and sin of t in a vec2 for efficiency.\\n\\\n    // Initial guess: t = cos(pi/4)\\n\\\n    vec2 tTrigs = vec2(0.70710678118);\\n\\\n    vec2 v = radii * tTrigs;\\n\\\n\\n\\\n    // Find the evolute of the ellipse (center of curvature) at v.\\n\\\n    vec2 evolute = evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n    // Find the (approximate) intersection of p - evolute with the ellipsoid.\\n\\\n    vec2 q = normalize(p - evolute) * length(v - evolute);\\n\\\n    // Update the estimate of t.\\n\\\n    tTrigs = (q + evolute) * inverseRadii;\\n\\\n    tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));\\n\\\n    v = radii * tTrigs;\\n\\\n\\n\\\n    return v * sign(pos);\\n\\\n}\\n\\\n\\n\\\nvec3 computeEllipsoidPositionWC(vec3 positionMC) {\\n\\\n    // Get the world-space position and project onto a meridian plane of\\n\\\n    // the ellipsoid\\n\\\n    vec3 positionWC = (czm_model * vec4(positionMC, 1.0)).xyz;\\n\\\n\\n\\\n    vec2 positionEllipse = vec2(length(positionWC.xy), positionWC.z);\\n\\\n    vec2 nearestPoint = nearestPointOnEllipseFast(positionEllipse, czm_ellipsoidRadii.xz);\\n\\\n\\n\\\n    // Reconstruct a 3D point in world space\\n\\\n    return vec3(nearestPoint.x * normalize(positionWC.xy), nearestPoint.y);\\n\\\n}\\n\\\n\\n\\\nvoid applyFog(inout vec4 color, vec4 groundAtmosphereColor, vec3 lightDirection, float distanceToCamera) {\\n\\\n\\n\\\n    vec3 fogColor = groundAtmosphereColor.rgb;\\n\\\n\\n\\\n    // If there is dynamic lighting, apply that to the fog.\\n\\\n    const float NONE = 0.0;\\n\\\n    if (czm_atmosphereDynamicLighting != NONE) {\\n\\\n        float darken = clamp(dot(normalize(czm_viewerPositionWC), lightDirection), czm_fogMinimumBrightness, 1.0);\\n\\\n        fogColor *= darken;\\n\\\n    }\\n\\\n\\n\\\n    // Tonemap if HDR rendering is disabled\\n\\\n    #ifndef HDR\\n\\\n        fogColor.rgb = czm_pbrNeutralTonemapping(fogColor.rgb);\\n\\\n        fogColor.rgb = czm_inverseGamma(fogColor.rgb);\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 withFog = czm_fog(distanceToCamera, color.rgb, fogColor, czm_fogVisualDensityScalar);\\n\\\n    color = vec4(withFog, color.a);\\n\\\n}\\n\\\n\\n\\\nvoid atmosphereStage(inout vec4 color, in ProcessedAttributes attributes) {\\n\\\n    vec3 rayleighColor;\\n\\\n    vec3 mieColor;\\n\\\n    float opacity;\\n\\\n\\n\\\n    vec3 positionWC;\\n\\\n    vec3 lightDirection;\\n\\\n\\n\\\n    // When the camera is in space, compute the position per-fragment for\\n\\\n    // more accurate ground atmosphere. All other cases will use\\n\\\n    //\\n\\\n    // The if condition will be added in https://github.com/CesiumGS/cesium/issues/11717\\n\\\n    if (false) {\\n\\\n        positionWC = computeEllipsoidPositionWC(attributes.positionMC);\\n\\\n        lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC, czm_atmosphereDynamicLighting);\\n\\\n\\n\\\n        // The fog color is derived from the ground atmosphere color\\n\\\n        czm_computeGroundAtmosphereScattering(\\n\\\n            positionWC,\\n\\\n            lightDirection,\\n\\\n            rayleighColor,\\n\\\n            mieColor,\\n\\\n            opacity\\n\\\n        );\\n\\\n    } else {\\n\\\n        positionWC = attributes.positionWC;\\n\\\n        lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC, czm_atmosphereDynamicLighting);\\n\\\n        rayleighColor = v_atmosphereRayleighColor;\\n\\\n        mieColor = v_atmosphereMieColor;\\n\\\n        opacity = v_atmosphereOpacity;\\n\\\n    }\\n\\\n\\n\\\n    //color correct rayleigh and mie colors\\n\\\n    const bool ignoreBlackPixels = true;\\n\\\n    rayleighColor = czm_applyHSBShift(rayleighColor, czm_atmosphereHsbShift, ignoreBlackPixels);\\n\\\n    mieColor = czm_applyHSBShift(mieColor, czm_atmosphereHsbShift, ignoreBlackPixels);\\n\\\n\\n\\\n    vec4 groundAtmosphereColor = czm_computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n    if (u_isInFog) {\\n\\\n        float distanceToCamera = length(attributes.positionEC);\\n\\\n        applyFog(color, groundAtmosphereColor, lightDirection, distanceToCamera);\\n\\\n    } else {\\n\\\n        // Ground atmosphere\\n\\\n    }\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}