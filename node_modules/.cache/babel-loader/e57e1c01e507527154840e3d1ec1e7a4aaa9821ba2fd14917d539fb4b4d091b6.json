{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport JsonMetadataTable from \"./JsonMetadataTable.js\";\n\n/**\n * A property table for use with the <code>EXT_structural_metadata</code> extension or\n * legacy <code>EXT_feature_metadata</code> glTF extension. It also includes some\n * options to be compatible with the 3D Tiles 1.0 batch table.\n * <p>\n * For batch tables, properties are resolved in the following order:\n * </p>\n * <ol>\n *   <li>binary properties from options.metadataTable</li>\n *   <li>JSON properties from options.jsonMetadataTable</li>\n *   <li>batch table hierarchy properties from options.batchTableHierarchy</li>\n * </ol>\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} [options.name] Human-readable name to describe the table\n * @param {string|number} [options.id] A unique id to identify the property table, useful for debugging. For <code>EXT_structural_metadata</code>, this is the array index in the property tables array, for <code>EXT_feature_metadata</code> this is the dictionary key in the property tables dictionary.\n * @param {number} options.count The number of features in the table.\n * @param {MetadataTable} [options.metadataTable] A table of binary properties.\n * @param {JsonMetadataTable} [options.jsonMetadataTable] For compatibility with the old batch table, free-form JSON properties can be passed in.\n * @param {BatchTableHierarchy} [options.batchTableHierarchy] For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, a hierarchy can be provided.\n * @param {object} [options.extras] Extra user-defined properties\n * @param {object} [options.extensions] An object containing extensions\n *\n * @alias PropertyTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTable(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.count\", options.count);\n  //>>includeEnd('debug');\n\n  this._name = options.name;\n  this._id = options.id;\n  this._count = options.count;\n  this._extras = options.extras;\n  this._extensions = options.extensions;\n  this._metadataTable = options.metadataTable;\n  this._jsonMetadataTable = options.jsonMetadataTable;\n  this._batchTableHierarchy = options.batchTableHierarchy;\n}\nObject.defineProperties(PropertyTable.prototype, {\n  /**\n   * A human-readable name for this table\n   *\n   * @memberof PropertyTable.prototype\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * An identifier for this table. Useful for debugging.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {string|number}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * The number of features in the table.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  count: {\n    get: function () {\n      return this._count;\n    }\n  },\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {MetadataClass}\n   * @readonly\n   */\n  class: {\n    get: function () {\n      if (defined(this._metadataTable)) {\n        return this._metadataTable.class;\n      }\n      return undefined;\n    }\n  },\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    }\n  },\n  /**\n   * An object containing extensions.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    }\n  },\n  /**\n   * Get the total amount of binary metadata stored in memory. This does\n   * not include JSON metadata\n   *\n   * @memberof PropertyTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      let totalByteLength = 0;\n      if (defined(this._metadataTable)) {\n        totalByteLength += this._metadataTable.byteLength;\n      }\n      if (defined(this._batchTableHierarchy)) {\n        totalByteLength += this._batchTableHierarchy.byteLength;\n      }\n      return totalByteLength;\n    }\n  }\n});\n\n/**\n * Returns whether the feature has this property. For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, this is computed for a specific feature.\n *\n * @param {number} index The index of the feature.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the feature has this property.\n * @private\n */\nPropertyTable.prototype.hasProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable) && this._metadataTable.hasProperty(propertyId)) {\n    return true;\n  }\n  if (defined(this._batchTableHierarchy) && this._batchTableHierarchy.hasProperty(index, propertyId)) {\n    return true;\n  }\n  if (defined(this._jsonMetadataTable) && this._jsonMetadataTable.hasProperty(propertyId)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns whether the feature has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether the feature has a property with the given semantic.\n * @private\n */\nPropertyTable.prototype.hasPropertyBySemantic = function (index, semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.hasPropertyBySemantic(semantic);\n  }\n  return false;\n};\n\n/**\n * Returns whether any feature has this property.\n * This is mainly useful for checking whether a property exists in the class\n * hierarchy when using the <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether any feature has this property.\n * @private\n */\nPropertyTable.prototype.propertyExists = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable) && this._metadataTable.hasProperty(propertyId)) {\n    return true;\n  }\n  if (defined(this._batchTableHierarchy) && this._batchTableHierarchy.propertyExists(propertyId)) {\n    return true;\n  }\n  if (defined(this._jsonMetadataTable) && this._jsonMetadataTable.hasProperty(propertyId)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns whether any feature has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether any feature has a property with the given semantic.\n * @private\n */\nPropertyTable.prototype.propertyExistsBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.hasPropertyBySemantic(semantic);\n  }\n  return false;\n};\nconst scratchResults = [];\n\n/**\n * Returns an array of property IDs. For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, this is computed for a specific feature.\n *\n * @param {number} index The index of the feature.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nPropertyTable.prototype.getPropertyIds = function (index, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n  if (defined(this._metadataTable)) {\n    // concat in place to avoid unnecessary array allocation\n    results.push.apply(results, this._metadataTable.getPropertyIds(scratchResults));\n  }\n  if (defined(this._batchTableHierarchy)) {\n    results.push.apply(results, this._batchTableHierarchy.getPropertyIds(index, scratchResults));\n  }\n  if (defined(this._jsonMetadataTable)) {\n    results.push.apply(results, this._jsonMetadataTable.getPropertyIds(scratchResults));\n  }\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nPropertyTable.prototype.getProperty = function (index, propertyId) {\n  let result;\n  if (defined(this._metadataTable)) {\n    result = this._metadataTable.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n  if (defined(this._batchTableHierarchy)) {\n    result = this._batchTableHierarchy.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n  if (defined(this._jsonMetadataTable)) {\n    result = this._jsonMetadataTable.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given ID. If the property did not\n * exist, it will be created as a JSON metadata property\n *\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @private\n */\nPropertyTable.prototype.setProperty = function (index, propertyId, value) {\n  if (defined(this._metadataTable) && this._metadataTable.setProperty(index, propertyId, value)) {\n    return;\n  }\n  if (defined(this._batchTableHierarchy) && this._batchTableHierarchy.setProperty(index, propertyId, value)) {\n    return;\n  }\n\n  // Ensure we have a table for JSON properties\n  if (!defined(this._jsonMetadataTable)) {\n    this._jsonMetadataTable = new JsonMetadataTable({\n      count: this._count,\n      properties: {}\n    });\n  }\n\n  // JsonMetadataTable will handle creating a new property at runtime.\n  this._jsonMetadataTable.setProperty(index, propertyId, value);\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this semantic.\n * @private\n */\nPropertyTable.prototype.getPropertyBySemantic = function (index, semantic) {\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyBySemantic(index, semantic);\n  }\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nPropertyTable.prototype.setPropertyBySemantic = function (index, semantic, value) {\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.setPropertyBySemantic(index, semantic, value);\n  }\n  return false;\n};\n\n/**\n * Returns a typed array containing the property values for a given propertyId.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not store\n * values in typed arrays.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nPropertyTable.prototype.getPropertyTypedArray = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyTypedArray(propertyId);\n  }\n  return undefined;\n};\n\n/**\n * Returns a typed array containing the property values for the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nPropertyTable.prototype.getPropertyTypedArrayBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyTypedArrayBySemantic(semantic);\n  }\n  return undefined;\n};\nfunction checkFeatureId(featureId, featuresLength) {\n  if (!defined(featureId) || featureId < 0 || featureId >= featuresLength) {\n    throw new DeveloperError(`featureId is required and must be between zero and featuresLength - 1 (${featuresLength}` - +\").\");\n  }\n}\nPropertyTable.prototype.isClass = function (featureId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkFeatureId(featureId, this.count);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return false;\n  }\n  return hierarchy.isClass(featureId, className);\n};\nPropertyTable.prototype.isExactClass = function (featureId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkFeatureId(featureId, this.count);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  return this.getExactClassName(featureId) === className;\n};\nPropertyTable.prototype.getExactClassName = function (featureId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkFeatureId(featureId, this.count);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n  return hierarchy.getClassName(featureId);\n};\nexport default PropertyTable;","map":{"version":3,"names":["Check","defaultValue","DeveloperError","defined","JsonMetadataTable","PropertyTable","options","EMPTY_OBJECT","typeOf","number","count","_name","name","_id","id","_count","_extras","extras","_extensions","extensions","_metadataTable","metadataTable","_jsonMetadataTable","jsonMetadataTable","_batchTableHierarchy","batchTableHierarchy","Object","defineProperties","prototype","get","class","undefined","byteLength","totalByteLength","hasProperty","index","propertyId","string","hasPropertyBySemantic","semantic","propertyExists","propertyExistsBySemantic","scratchResults","getPropertyIds","results","length","push","apply","getProperty","result","setProperty","value","properties","getPropertyBySemantic","setPropertyBySemantic","getPropertyTypedArray","getPropertyTypedArrayBySemantic","checkFeatureId","featureId","featuresLength","isClass","className","hierarchy","isExactClass","getExactClassName","getClassName"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PropertyTable.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport JsonMetadataTable from \"./JsonMetadataTable.js\";\n\n/**\n * A property table for use with the <code>EXT_structural_metadata</code> extension or\n * legacy <code>EXT_feature_metadata</code> glTF extension. It also includes some\n * options to be compatible with the 3D Tiles 1.0 batch table.\n * <p>\n * For batch tables, properties are resolved in the following order:\n * </p>\n * <ol>\n *   <li>binary properties from options.metadataTable</li>\n *   <li>JSON properties from options.jsonMetadataTable</li>\n *   <li>batch table hierarchy properties from options.batchTableHierarchy</li>\n * </ol>\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} [options.name] Human-readable name to describe the table\n * @param {string|number} [options.id] A unique id to identify the property table, useful for debugging. For <code>EXT_structural_metadata</code>, this is the array index in the property tables array, for <code>EXT_feature_metadata</code> this is the dictionary key in the property tables dictionary.\n * @param {number} options.count The number of features in the table.\n * @param {MetadataTable} [options.metadataTable] A table of binary properties.\n * @param {JsonMetadataTable} [options.jsonMetadataTable] For compatibility with the old batch table, free-form JSON properties can be passed in.\n * @param {BatchTableHierarchy} [options.batchTableHierarchy] For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, a hierarchy can be provided.\n * @param {object} [options.extras] Extra user-defined properties\n * @param {object} [options.extensions] An object containing extensions\n *\n * @alias PropertyTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTable(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.count\", options.count);\n  //>>includeEnd('debug');\n\n  this._name = options.name;\n  this._id = options.id;\n  this._count = options.count;\n  this._extras = options.extras;\n  this._extensions = options.extensions;\n  this._metadataTable = options.metadataTable;\n  this._jsonMetadataTable = options.jsonMetadataTable;\n  this._batchTableHierarchy = options.batchTableHierarchy;\n}\n\nObject.defineProperties(PropertyTable.prototype, {\n  /**\n   * A human-readable name for this table\n   *\n   * @memberof PropertyTable.prototype\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * An identifier for this table. Useful for debugging.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {string|number}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * The number of features in the table.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  count: {\n    get: function () {\n      return this._count;\n    },\n  },\n\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {MetadataClass}\n   * @readonly\n   */\n  class: {\n    get: function () {\n      if (defined(this._metadataTable)) {\n        return this._metadataTable.class;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * An object containing extensions.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n\n  /**\n   * Get the total amount of binary metadata stored in memory. This does\n   * not include JSON metadata\n   *\n   * @memberof PropertyTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      let totalByteLength = 0;\n      if (defined(this._metadataTable)) {\n        totalByteLength += this._metadataTable.byteLength;\n      }\n\n      if (defined(this._batchTableHierarchy)) {\n        totalByteLength += this._batchTableHierarchy.byteLength;\n      }\n\n      return totalByteLength;\n    },\n  },\n});\n\n/**\n * Returns whether the feature has this property. For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, this is computed for a specific feature.\n *\n * @param {number} index The index of the feature.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the feature has this property.\n * @private\n */\nPropertyTable.prototype.hasProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (\n    defined(this._metadataTable) &&\n    this._metadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._batchTableHierarchy) &&\n    this._batchTableHierarchy.hasProperty(index, propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._jsonMetadataTable) &&\n    this._jsonMetadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns whether the feature has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether the feature has a property with the given semantic.\n * @private\n */\nPropertyTable.prototype.hasPropertyBySemantic = function (index, semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.hasPropertyBySemantic(semantic);\n  }\n\n  return false;\n};\n\n/**\n * Returns whether any feature has this property.\n * This is mainly useful for checking whether a property exists in the class\n * hierarchy when using the <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether any feature has this property.\n * @private\n */\nPropertyTable.prototype.propertyExists = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (\n    defined(this._metadataTable) &&\n    this._metadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._batchTableHierarchy) &&\n    this._batchTableHierarchy.propertyExists(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._jsonMetadataTable) &&\n    this._jsonMetadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns whether any feature has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether any feature has a property with the given semantic.\n * @private\n */\nPropertyTable.prototype.propertyExistsBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.hasPropertyBySemantic(semantic);\n  }\n\n  return false;\n};\n\nconst scratchResults = [];\n\n/**\n * Returns an array of property IDs. For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, this is computed for a specific feature.\n *\n * @param {number} index The index of the feature.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nPropertyTable.prototype.getPropertyIds = function (index, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  if (defined(this._metadataTable)) {\n    // concat in place to avoid unnecessary array allocation\n    results.push.apply(\n      results,\n      this._metadataTable.getPropertyIds(scratchResults),\n    );\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    results.push.apply(\n      results,\n      this._batchTableHierarchy.getPropertyIds(index, scratchResults),\n    );\n  }\n\n  if (defined(this._jsonMetadataTable)) {\n    results.push.apply(\n      results,\n      this._jsonMetadataTable.getPropertyIds(scratchResults),\n    );\n  }\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nPropertyTable.prototype.getProperty = function (index, propertyId) {\n  let result;\n  if (defined(this._metadataTable)) {\n    result = this._metadataTable.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    result = this._batchTableHierarchy.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n\n  if (defined(this._jsonMetadataTable)) {\n    result = this._jsonMetadataTable.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given ID. If the property did not\n * exist, it will be created as a JSON metadata property\n *\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @private\n */\nPropertyTable.prototype.setProperty = function (index, propertyId, value) {\n  if (\n    defined(this._metadataTable) &&\n    this._metadataTable.setProperty(index, propertyId, value)\n  ) {\n    return;\n  }\n\n  if (\n    defined(this._batchTableHierarchy) &&\n    this._batchTableHierarchy.setProperty(index, propertyId, value)\n  ) {\n    return;\n  }\n\n  // Ensure we have a table for JSON properties\n  if (!defined(this._jsonMetadataTable)) {\n    this._jsonMetadataTable = new JsonMetadataTable({\n      count: this._count,\n      properties: {},\n    });\n  }\n\n  // JsonMetadataTable will handle creating a new property at runtime.\n  this._jsonMetadataTable.setProperty(index, propertyId, value);\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this semantic.\n * @private\n */\nPropertyTable.prototype.getPropertyBySemantic = function (index, semantic) {\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyBySemantic(index, semantic);\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {number} index The index of the feature.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nPropertyTable.prototype.setPropertyBySemantic = function (\n  index,\n  semantic,\n  value,\n) {\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.setPropertyBySemantic(index, semantic, value);\n  }\n\n  return false;\n};\n\n/**\n * Returns a typed array containing the property values for a given propertyId.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not store\n * values in typed arrays.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nPropertyTable.prototype.getPropertyTypedArray = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyTypedArray(propertyId);\n  }\n\n  return undefined;\n};\n\n/**\n * Returns a typed array containing the property values for the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nPropertyTable.prototype.getPropertyTypedArrayBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyTypedArrayBySemantic(semantic);\n  }\n\n  return undefined;\n};\n\nfunction checkFeatureId(featureId, featuresLength) {\n  if (!defined(featureId) || featureId < 0 || featureId >= featuresLength) {\n    throw new DeveloperError(\n      `featureId is required and must be between zero and featuresLength - 1 (${featuresLength}` -\n        +\").\",\n    );\n  }\n}\n\nPropertyTable.prototype.isClass = function (featureId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkFeatureId(featureId, this.count);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return false;\n  }\n\n  return hierarchy.isClass(featureId, className);\n};\n\nPropertyTable.prototype.isExactClass = function (featureId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkFeatureId(featureId, this.count);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  return this.getExactClassName(featureId) === className;\n};\n\nPropertyTable.prototype.getExactClassName = function (featureId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkFeatureId(featureId, this.count);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n\n  return hierarchy.getClassName(featureId);\n};\n\nexport default PropertyTable;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}