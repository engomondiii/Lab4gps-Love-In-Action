{"ast":null,"code":"import ArcType from \"../Core/ArcType.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolylineGeometry from \"../Core/PolylineGeometry.js\";\nimport PolylinePipeline from \"../Core/PolylinePipeline.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Entity from \"../DataSources/Entity.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport GroundPolylinePrimitive from \"../Scene/GroundPolylinePrimitive.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nconst defaultZIndex = new ConstantProperty(0);\n\n//We use this object to create one polyline collection per-scene.\nconst polylineCollections = {};\nconst scratchColor = new Color();\nconst defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nconst defaultShow = new ConstantProperty(true);\nconst defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\nconst defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\nconst defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\nfunction GeometryOptions() {\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\nfunction GroundGeometryOptions() {\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for polylines.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias PolylineGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction PolylineGeometryUpdater(entity, scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._entity = entity;\n  this._scene = scene;\n  this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);\n  this._fillEnabled = false;\n  this._dynamic = false;\n  this._geometryChanged = new Event();\n  this._showProperty = undefined;\n  this._materialProperty = undefined;\n  this._shadowsProperty = undefined;\n  this._distanceDisplayConditionProperty = undefined;\n  this._classificationTypeProperty = undefined;\n  this._depthFailMaterialProperty = undefined;\n  this._geometryOptions = new GeometryOptions();\n  this._groundGeometryOptions = new GroundGeometryOptions();\n  this._id = `polyline-${entity.id}`;\n  this._clampToGround = false;\n  this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n  this._zIndex = 0;\n  this._onEntityPropertyChanged(entity, \"polyline\", entity.polyline, undefined);\n}\nObject.defineProperties(PolylineGeometryUpdater.prototype, {\n  /**\n   * Gets the unique ID associated with this updater\n   * @memberof PolylineGeometryUpdater.prototype\n   * @type {string}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * Gets the entity associated with this geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Entity}\n   * @readonly\n   */\n  entity: {\n    get: function () {\n      return this._entity;\n    }\n  },\n  /**\n   * Gets a value indicating if the geometry has a fill component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  fillEnabled: {\n    get: function () {\n      return this._fillEnabled;\n    }\n  },\n  /**\n   * Gets a value indicating if fill visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  hasConstantFill: {\n    get: function () {\n      return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty);\n    }\n  },\n  /**\n   * Gets the material property used to fill the geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  fillMaterialProperty: {\n    get: function () {\n      return this._materialProperty;\n    }\n  },\n  /**\n   * Gets the material property used to fill the geometry when it fails the depth test.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  depthFailMaterialProperty: {\n    get: function () {\n      return this._depthFailMaterialProperty;\n    }\n  },\n  /**\n   * Gets a value indicating if the geometry has an outline component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  outlineEnabled: {\n    value: false\n  },\n  /**\n   * Gets a value indicating if outline visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  hasConstantOutline: {\n    value: true\n  },\n  /**\n   * Gets the {@link Color} property for the geometry outline.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  outlineColorProperty: {\n    value: undefined\n  },\n  /**\n   * Gets the property specifying whether the geometry\n   * casts or receives shadows from light sources.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  shadowsProperty: {\n    get: function () {\n      return this._shadowsProperty;\n    }\n  },\n  /**\n   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  distanceDisplayConditionProperty: {\n    get: function () {\n      return this._distanceDisplayConditionProperty;\n    }\n  },\n  /**\n   * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  classificationTypeProperty: {\n    get: function () {\n      return this._classificationTypeProperty;\n    }\n  },\n  /**\n   * Gets a value indicating if the geometry is time-varying.\n   *\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isDynamic: {\n    get: function () {\n      return this._dynamic;\n    }\n  },\n  /**\n   * Gets a value indicating if the geometry is closed.\n   * This property is only valid for static geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isClosed: {\n    value: false\n  },\n  /**\n   * Gets an event that is raised whenever the public properties\n   * of this updater change.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  geometryChanged: {\n    get: function () {\n      return this._geometryChanged;\n    }\n  },\n  /**\n   * Gets a value indicating if the path of the line.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {ArcType}\n   * @readonly\n   */\n  arcType: {\n    get: function () {\n      return this._arcType;\n    }\n  },\n  /**\n   * Gets a value indicating if the geometry is clamped to the ground.\n   * Returns false if polylines on terrain is not supported.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  clampToGround: {\n    get: function () {\n      return this._clampToGround && this._supportsPolylinesOnTerrain;\n    }\n  },\n  /**\n   * Gets the zindex\n   * @type {number}\n   * @memberof PolylineGeometryUpdater.prototype\n   * @readonly\n   */\n  zIndex: {\n    get: function () {\n      return this._zIndex;\n    }\n  }\n});\n\n/**\n * Checks if the geometry is outlined at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {boolean} true if geometry is outlined at the provided time, false otherwise.\n */\nPolylineGeometryUpdater.prototype.isOutlineVisible = function (time) {\n  return false;\n};\n\n/**\n * Checks if the geometry is filled at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {boolean} true if geometry is filled at the provided time, false otherwise.\n */\nPolylineGeometryUpdater.prototype.isFilled = function (time) {\n  const entity = this._entity;\n  const visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);\n  return defaultValue(visible, false);\n};\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nPolylineGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute\n  };\n  let currentColor;\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (this.clampToGround) {\n    return new GeometryInstance({\n      id: entity,\n      geometry: new GroundPolylineGeometry(this._groundGeometryOptions),\n      attributes: attributes\n    });\n  }\n  if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {\n    if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new PolylineGeometry(this._geometryOptions),\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nPolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  //>>includeEnd('debug');\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPolylineGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nPolylineGeometryUpdater.prototype.destroy = function () {\n  this._entitySubscription();\n  destroyObject(this);\n};\nPolylineGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {\n  if (!(propertyName === \"availability\" || propertyName === \"polyline\")) {\n    return;\n  }\n  const polyline = this._entity.polyline;\n  if (!defined(polyline)) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n      this._geometryChanged.raiseEvent(this);\n    }\n    return;\n  }\n  const positionsProperty = polyline.positions;\n  const show = polyline.show;\n  if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) ||\n  //\n  !defined(positionsProperty)) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n      this._geometryChanged.raiseEvent(this);\n    }\n    return;\n  }\n  const zIndex = polyline.zIndex;\n  const material = defaultValue(polyline.material, defaultMaterial);\n  const isColorMaterial = material instanceof ColorMaterialProperty;\n  this._materialProperty = material;\n  this._depthFailMaterialProperty = polyline.depthFailMaterial;\n  this._showProperty = defaultValue(show, defaultShow);\n  this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n  this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);\n  this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);\n  this._fillEnabled = true;\n  this._zIndex = defaultValue(zIndex, defaultZIndex);\n  const width = polyline.width;\n  const arcType = polyline.arcType;\n  const clampToGround = polyline.clampToGround;\n  const granularity = polyline.granularity;\n  if (!positionsProperty.isConstant || !Property.isConstant(width) || !Property.isConstant(arcType) || !Property.isConstant(granularity) || !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {\n    if (!this._dynamic) {\n      this._dynamic = true;\n      this._geometryChanged.raiseEvent(this);\n    }\n  } else {\n    const geometryOptions = this._geometryOptions;\n    const positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions);\n\n    //Because of the way we currently handle reference properties,\n    //we can't automatically assume the positions are always valid.\n    if (!defined(positions) || positions.length < 2) {\n      if (this._fillEnabled) {\n        this._fillEnabled = false;\n        this._geometryChanged.raiseEvent(this);\n      }\n      return;\n    }\n    let vertexFormat;\n    if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n      vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n    } else {\n      vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n    }\n    geometryOptions.vertexFormat = vertexFormat;\n    geometryOptions.positions = positions;\n    geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    const groundGeometryOptions = this._groundGeometryOptions;\n    groundGeometryOptions.positions = positions;\n    groundGeometryOptions.width = geometryOptions.width;\n    groundGeometryOptions.arcType = geometryOptions.arcType;\n    groundGeometryOptions.granularity = geometryOptions.granularity;\n    this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;\n    if (!this._clampToGround && defined(zIndex)) {\n      oneTimeWarning(\"Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.\");\n    }\n    this._dynamic = false;\n    this._geometryChanged.raiseEvent(this);\n  }\n};\n\n/**\n * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n *\n * @param {PrimitiveCollection} primitives The primitive collection to use.\n * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n *\n * @exception {DeveloperError} This instance does not represent dynamic geometry.\n * @private\n */\nPolylineGeometryUpdater.prototype.createDynamicUpdater = function (primitives, groundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"groundPrimitives\", groundPrimitives);\n  if (!this._dynamic) {\n    throw new DeveloperError(\"This instance does not represent dynamic geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n};\n\n/**\n * @private\n */\nconst generateCartesianArcOptions = {\n  positions: undefined,\n  granularity: undefined,\n  height: undefined,\n  ellipsoid: undefined\n};\nfunction DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n  this._line = undefined;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._groundPolylinePrimitive = undefined;\n  this._material = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._positions = [];\n}\nfunction getLine(dynamicGeometryUpdater) {\n  if (defined(dynamicGeometryUpdater._line)) {\n    return dynamicGeometryUpdater._line;\n  }\n  const primitives = dynamicGeometryUpdater._primitives;\n  const polylineCollectionId = dynamicGeometryUpdater._geometryUpdater._scene.id + primitives._guid;\n  let polylineCollection = polylineCollections[polylineCollectionId];\n  if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n    polylineCollection = new PolylineCollection();\n    polylineCollections[polylineCollectionId] = polylineCollection;\n    primitives.add(polylineCollection);\n  } else if (!primitives.contains(polylineCollection)) {\n    primitives.add(polylineCollection);\n  }\n  const line = polylineCollection.add();\n  line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n  dynamicGeometryUpdater._line = line;\n  return line;\n}\nDynamicGeometryUpdater.prototype.update = function (time) {\n  const geometryUpdater = this._geometryUpdater;\n  const entity = geometryUpdater._entity;\n  const polyline = entity.polyline;\n  const positionsProperty = polyline.positions;\n  let positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);\n\n  // Synchronize with geometryUpdater for GroundPolylinePrimitive\n  geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);\n  geometryUpdater._groundGeometryOptions.positions = positions;\n  geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);\n  geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);\n  geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);\n  const groundPrimitives = this._groundPrimitives;\n  if (defined(this._groundPolylinePrimitive)) {\n    groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n    this._groundPolylinePrimitive = undefined;\n  }\n  if (geometryUpdater.clampToGround) {\n    if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n      return;\n    }\n    if (!defined(positions) || positions.length < 2) {\n      return;\n    }\n    const fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    let appearance;\n    if (fillMaterialProperty instanceof ColorMaterialProperty) {\n      appearance = new PolylineColorAppearance();\n    } else {\n      const material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n      appearance = new PolylineMaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent()\n      });\n      this._material = material;\n    }\n    this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({\n      geometryInstances: geometryUpdater.createFillGeometryInstance(time),\n      appearance: appearance,\n      classificationType: geometryUpdater.classificationTypeProperty.getValue(time),\n      asynchronous: false\n    }), Property.getValueOrUndefined(geometryUpdater.zIndex, time));\n\n    // Hide the polyline in the collection, if any\n    if (defined(this._line)) {\n      this._line.show = false;\n    }\n    return;\n  }\n  const line = getLine(this);\n  if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n    line.show = false;\n    return;\n  }\n  if (!defined(positions) || positions.length < 2) {\n    line.show = false;\n    return;\n  }\n  let arcType = ArcType.GEODESIC;\n  arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n  const globe = geometryUpdater._scene.globe;\n  const ellipsoid = geometryUpdater._scene.ellipsoid;\n  if (arcType !== ArcType.NONE && defined(globe)) {\n    generateCartesianArcOptions.ellipsoid = ellipsoid;\n    generateCartesianArcOptions.positions = positions;\n    generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);\n    generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, ellipsoid);\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc(generateCartesianArcOptions);\n    }\n  }\n  line.show = true;\n  line.positions = positions.slice();\n  line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);\n  line.width = Property.getValueOrDefault(polyline._width, time, 1);\n  line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);\n};\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!this._geometryUpdater.clampToGround) {\n    const line = getLine(this);\n    if (line.show && line.positions.length > 0) {\n      BoundingSphere.fromPoints(line.positions, result);\n      return BoundingSphereState.DONE;\n    }\n  } else {\n    const groundPolylinePrimitive = this._groundPolylinePrimitive;\n    if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {\n      const attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);\n      if (defined(attributes) && defined(attributes.boundingSphere)) {\n        BoundingSphere.clone(attributes.boundingSphere, result);\n        return BoundingSphereState.DONE;\n      }\n    }\n    if (defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready) {\n      return BoundingSphereState.PENDING;\n    }\n    return BoundingSphereState.DONE;\n  }\n  return BoundingSphereState.FAILED;\n};\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\nDynamicGeometryUpdater.prototype.destroy = function () {\n  const geometryUpdater = this._geometryUpdater;\n  const polylineCollectionId = geometryUpdater._scene.id + this._primitives._guid;\n  const polylineCollection = polylineCollections[polylineCollectionId];\n  if (defined(polylineCollection)) {\n    polylineCollection.remove(this._line);\n    if (polylineCollection.length === 0) {\n      this._primitives.removeAndDestroy(polylineCollection);\n      delete polylineCollections[polylineCollectionId];\n    }\n  }\n  if (defined(this._groundPolylinePrimitive)) {\n    this._groundPrimitives.remove(this._groundPolylinePrimitive);\n  }\n  destroyObject(this);\n};\nexport default PolylineGeometryUpdater;","map":{"version":3,"names":["ArcType","BoundingSphere","Check","Color","ColorGeometryInstanceAttribute","defaultValue","defined","destroyObject","DeveloperError","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","Event","GeometryInstance","GroundPolylineGeometry","Iso8601","oneTimeWarning","PolylineGeometry","PolylinePipeline","ShowGeometryInstanceAttribute","Entity","ClassificationType","GroundPolylinePrimitive","PolylineCollection","PolylineColorAppearance","PolylineMaterialAppearance","ShadowMode","BoundingSphereState","ColorMaterialProperty","ConstantProperty","MaterialProperty","Property","defaultZIndex","polylineCollections","scratchColor","defaultMaterial","WHITE","defaultShow","defaultShadows","DISABLED","defaultDistanceDisplayCondition","defaultClassificationType","BOTH","GeometryOptions","vertexFormat","undefined","positions","width","arcType","granularity","GroundGeometryOptions","PolylineGeometryUpdater","entity","scene","_entity","_scene","_entitySubscription","definitionChanged","addEventListener","prototype","_onEntityPropertyChanged","_fillEnabled","_dynamic","_geometryChanged","_showProperty","_materialProperty","_shadowsProperty","_distanceDisplayConditionProperty","_classificationTypeProperty","_depthFailMaterialProperty","_geometryOptions","_groundGeometryOptions","_id","id","_clampToGround","_supportsPolylinesOnTerrain","supportsPolylinesOnTerrain","_zIndex","polyline","Object","defineProperties","get","fillEnabled","hasConstantFill","availability","isConstant","fillMaterialProperty","depthFailMaterialProperty","outlineEnabled","value","hasConstantOutline","outlineColorProperty","shadowsProperty","distanceDisplayConditionProperty","classificationTypeProperty","isDynamic","isClosed","geometryChanged","_arcType","clampToGround","zIndex","isOutlineVisible","time","isFilled","visible","isAvailable","getValue","createFillGeometryInstance","show","isShowing","distanceDisplayCondition","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","attributes","currentColor","color","fromColor","geometry","depthFailColor","createOutlineGeometryInstance","isDestroyed","destroy","propertyName","newValue","oldValue","raiseEvent","positionsProperty","MINIMUM_VALUE","material","isColorMaterial","depthFailMaterial","shadows","classificationType","geometryOptions","length","VERTEX_FORMAT","groundGeometryOptions","createDynamicUpdater","primitives","groundPrimitives","DynamicGeometryUpdater","generateCartesianArcOptions","height","ellipsoid","geometryUpdater","_line","_primitives","_groundPrimitives","_groundPolylinePrimitive","_material","_geometryUpdater","_positions","getLine","dynamicGeometryUpdater","polylineCollectionId","_guid","polylineCollection","add","contains","line","update","getValueOrUndefined","getValueOrDefault","_width","GEODESIC","_granularity","remove","_show","appearance","translucent","isTranslucent","geometryInstances","asynchronous","globe","NONE","extractHeights","generateCartesianArc","generateCartesianRhumbArc","slice","_distanceDisplayCondition","getBoundingSphere","result","fromPoints","DONE","groundPolylinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","clone","PENDING","FAILED","removeAndDestroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/PolylineGeometryUpdater.js"],"sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolylineGeometry from \"../Core/PolylineGeometry.js\";\nimport PolylinePipeline from \"../Core/PolylinePipeline.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Entity from \"../DataSources/Entity.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport GroundPolylinePrimitive from \"../Scene/GroundPolylinePrimitive.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nconst defaultZIndex = new ConstantProperty(0);\n\n//We use this object to create one polyline collection per-scene.\nconst polylineCollections = {};\n\nconst scratchColor = new Color();\nconst defaultMaterial = new ColorMaterialProperty(Color.WHITE);\nconst defaultShow = new ConstantProperty(true);\nconst defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\nconst defaultDistanceDisplayCondition = new ConstantProperty(\n  new DistanceDisplayCondition(),\n);\nconst defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\nfunction GeometryOptions() {\n  this.vertexFormat = undefined;\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n\nfunction GroundGeometryOptions() {\n  this.positions = undefined;\n  this.width = undefined;\n  this.arcType = undefined;\n  this.granularity = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for polylines.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias PolylineGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction PolylineGeometryUpdater(entity, scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._entity = entity;\n  this._scene = scene;\n  this._entitySubscription = entity.definitionChanged.addEventListener(\n    PolylineGeometryUpdater.prototype._onEntityPropertyChanged,\n    this,\n  );\n  this._fillEnabled = false;\n  this._dynamic = false;\n  this._geometryChanged = new Event();\n  this._showProperty = undefined;\n  this._materialProperty = undefined;\n  this._shadowsProperty = undefined;\n  this._distanceDisplayConditionProperty = undefined;\n  this._classificationTypeProperty = undefined;\n  this._depthFailMaterialProperty = undefined;\n  this._geometryOptions = new GeometryOptions();\n  this._groundGeometryOptions = new GroundGeometryOptions();\n  this._id = `polyline-${entity.id}`;\n  this._clampToGround = false;\n  this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n\n  this._zIndex = 0;\n\n  this._onEntityPropertyChanged(entity, \"polyline\", entity.polyline, undefined);\n}\n\nObject.defineProperties(PolylineGeometryUpdater.prototype, {\n  /**\n   * Gets the unique ID associated with this updater\n   * @memberof PolylineGeometryUpdater.prototype\n   * @type {string}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * Gets the entity associated with this geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Entity}\n   * @readonly\n   */\n  entity: {\n    get: function () {\n      return this._entity;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry has a fill component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  fillEnabled: {\n    get: function () {\n      return this._fillEnabled;\n    },\n  },\n  /**\n   * Gets a value indicating if fill visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  hasConstantFill: {\n    get: function () {\n      return (\n        !this._fillEnabled ||\n        (!defined(this._entity.availability) &&\n          Property.isConstant(this._showProperty))\n      );\n    },\n  },\n  /**\n   * Gets the material property used to fill the geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  fillMaterialProperty: {\n    get: function () {\n      return this._materialProperty;\n    },\n  },\n  /**\n   * Gets the material property used to fill the geometry when it fails the depth test.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {MaterialProperty}\n   * @readonly\n   */\n  depthFailMaterialProperty: {\n    get: function () {\n      return this._depthFailMaterialProperty;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry has an outline component.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  outlineEnabled: {\n    value: false,\n  },\n  /**\n   * Gets a value indicating if outline visibility varies with simulation time.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  hasConstantOutline: {\n    value: true,\n  },\n  /**\n   * Gets the {@link Color} property for the geometry outline.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  outlineColorProperty: {\n    value: undefined,\n  },\n  /**\n   * Gets the property specifying whether the geometry\n   * casts or receives shadows from light sources.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  shadowsProperty: {\n    get: function () {\n      return this._shadowsProperty;\n    },\n  },\n  /**\n   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  distanceDisplayConditionProperty: {\n    get: function () {\n      return this._distanceDisplayConditionProperty;\n    },\n  },\n  /**\n   * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {Property}\n   * @readonly\n   */\n  classificationTypeProperty: {\n    get: function () {\n      return this._classificationTypeProperty;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry is time-varying.\n   *\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isDynamic: {\n    get: function () {\n      return this._dynamic;\n    },\n  },\n  /**\n   * Gets a value indicating if the geometry is closed.\n   * This property is only valid for static geometry.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isClosed: {\n    value: false,\n  },\n  /**\n   * Gets an event that is raised whenever the public properties\n   * of this updater change.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  geometryChanged: {\n    get: function () {\n      return this._geometryChanged;\n    },\n  },\n\n  /**\n   * Gets a value indicating if the path of the line.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {ArcType}\n   * @readonly\n   */\n  arcType: {\n    get: function () {\n      return this._arcType;\n    },\n  },\n\n  /**\n   * Gets a value indicating if the geometry is clamped to the ground.\n   * Returns false if polylines on terrain is not supported.\n   * @memberof PolylineGeometryUpdater.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  clampToGround: {\n    get: function () {\n      return this._clampToGround && this._supportsPolylinesOnTerrain;\n    },\n  },\n\n  /**\n   * Gets the zindex\n   * @type {number}\n   * @memberof PolylineGeometryUpdater.prototype\n   * @readonly\n   */\n  zIndex: {\n    get: function () {\n      return this._zIndex;\n    },\n  },\n});\n\n/**\n * Checks if the geometry is outlined at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {boolean} true if geometry is outlined at the provided time, false otherwise.\n */\nPolylineGeometryUpdater.prototype.isOutlineVisible = function (time) {\n  return false;\n};\n\n/**\n * Checks if the geometry is filled at the provided time.\n *\n * @param {JulianDate} time The time for which to retrieve visibility.\n * @returns {boolean} true if geometry is filled at the provided time, false otherwise.\n */\nPolylineGeometryUpdater.prototype.isFilled = function (time) {\n  const entity = this._entity;\n  const visible =\n    this._fillEnabled &&\n    entity.isAvailable(time) &&\n    this._showProperty.getValue(time);\n  return defaultValue(visible, false);\n};\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nPolylineGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const show = new ShowGeometryInstanceAttribute(\n    isAvailable && entity.isShowing && this._showProperty.getValue(time),\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute =\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition,\n    );\n\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n  };\n\n  let currentColor;\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (this.clampToGround) {\n    return new GeometryInstance({\n      id: entity,\n      geometry: new GroundPolylineGeometry(this._groundGeometryOptions),\n      attributes: attributes,\n    });\n  }\n\n  if (\n    defined(this._depthFailMaterialProperty) &&\n    this._depthFailMaterialProperty instanceof ColorMaterialProperty\n  ) {\n    if (\n      defined(this._depthFailMaterialProperty.color) &&\n      (this._depthFailMaterialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._depthFailMaterialProperty.color.getValue(\n        time,\n        scratchColor,\n      );\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.depthFailColor =\n      ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new PolylineGeometry(this._geometryOptions),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nPolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"This instance does not represent an outlined geometry.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPolylineGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nPolylineGeometryUpdater.prototype.destroy = function () {\n  this._entitySubscription();\n  destroyObject(this);\n};\n\nPolylineGeometryUpdater.prototype._onEntityPropertyChanged = function (\n  entity,\n  propertyName,\n  newValue,\n  oldValue,\n) {\n  if (!(propertyName === \"availability\" || propertyName === \"polyline\")) {\n    return;\n  }\n\n  const polyline = this._entity.polyline;\n\n  if (!defined(polyline)) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n      this._geometryChanged.raiseEvent(this);\n    }\n    return;\n  }\n\n  const positionsProperty = polyline.positions;\n\n  const show = polyline.show;\n  if (\n    (defined(show) &&\n      show.isConstant &&\n      !show.getValue(Iso8601.MINIMUM_VALUE)) || //\n    !defined(positionsProperty)\n  ) {\n    if (this._fillEnabled) {\n      this._fillEnabled = false;\n      this._geometryChanged.raiseEvent(this);\n    }\n    return;\n  }\n\n  const zIndex = polyline.zIndex;\n  const material = defaultValue(polyline.material, defaultMaterial);\n  const isColorMaterial = material instanceof ColorMaterialProperty;\n  this._materialProperty = material;\n  this._depthFailMaterialProperty = polyline.depthFailMaterial;\n  this._showProperty = defaultValue(show, defaultShow);\n  this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n  this._distanceDisplayConditionProperty = defaultValue(\n    polyline.distanceDisplayCondition,\n    defaultDistanceDisplayCondition,\n  );\n  this._classificationTypeProperty = defaultValue(\n    polyline.classificationType,\n    defaultClassificationType,\n  );\n  this._fillEnabled = true;\n  this._zIndex = defaultValue(zIndex, defaultZIndex);\n\n  const width = polyline.width;\n  const arcType = polyline.arcType;\n  const clampToGround = polyline.clampToGround;\n  const granularity = polyline.granularity;\n\n  if (\n    !positionsProperty.isConstant ||\n    !Property.isConstant(width) ||\n    !Property.isConstant(arcType) ||\n    !Property.isConstant(granularity) ||\n    !Property.isConstant(clampToGround) ||\n    !Property.isConstant(zIndex)\n  ) {\n    if (!this._dynamic) {\n      this._dynamic = true;\n      this._geometryChanged.raiseEvent(this);\n    }\n  } else {\n    const geometryOptions = this._geometryOptions;\n    const positions = positionsProperty.getValue(\n      Iso8601.MINIMUM_VALUE,\n      geometryOptions.positions,\n    );\n\n    //Because of the way we currently handle reference properties,\n    //we can't automatically assume the positions are always valid.\n    if (!defined(positions) || positions.length < 2) {\n      if (this._fillEnabled) {\n        this._fillEnabled = false;\n        this._geometryChanged.raiseEvent(this);\n      }\n      return;\n    }\n\n    let vertexFormat;\n    if (\n      isColorMaterial &&\n      (!defined(this._depthFailMaterialProperty) ||\n        this._depthFailMaterialProperty instanceof ColorMaterialProperty)\n    ) {\n      vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n    } else {\n      vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n    }\n\n    geometryOptions.vertexFormat = vertexFormat;\n    geometryOptions.positions = positions;\n    geometryOptions.width = defined(width)\n      ? width.getValue(Iso8601.MINIMUM_VALUE)\n      : undefined;\n    geometryOptions.arcType = defined(arcType)\n      ? arcType.getValue(Iso8601.MINIMUM_VALUE)\n      : undefined;\n    geometryOptions.granularity = defined(granularity)\n      ? granularity.getValue(Iso8601.MINIMUM_VALUE)\n      : undefined;\n\n    const groundGeometryOptions = this._groundGeometryOptions;\n    groundGeometryOptions.positions = positions;\n    groundGeometryOptions.width = geometryOptions.width;\n    groundGeometryOptions.arcType = geometryOptions.arcType;\n    groundGeometryOptions.granularity = geometryOptions.granularity;\n\n    this._clampToGround = defined(clampToGround)\n      ? clampToGround.getValue(Iso8601.MINIMUM_VALUE)\n      : false;\n\n    if (!this._clampToGround && defined(zIndex)) {\n      oneTimeWarning(\n        \"Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.\",\n      );\n    }\n\n    this._dynamic = false;\n    this._geometryChanged.raiseEvent(this);\n  }\n};\n\n/**\n * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n *\n * @param {PrimitiveCollection} primitives The primitive collection to use.\n * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n *\n * @exception {DeveloperError} This instance does not represent dynamic geometry.\n * @private\n */\nPolylineGeometryUpdater.prototype.createDynamicUpdater = function (\n  primitives,\n  groundPrimitives,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"primitives\", primitives);\n  Check.defined(\"groundPrimitives\", groundPrimitives);\n\n  if (!this._dynamic) {\n    throw new DeveloperError(\n      \"This instance does not represent dynamic geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n};\n\n/**\n * @private\n */\nconst generateCartesianArcOptions = {\n  positions: undefined,\n  granularity: undefined,\n  height: undefined,\n  ellipsoid: undefined,\n};\n\nfunction DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n  this._line = undefined;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._groundPolylinePrimitive = undefined;\n  this._material = undefined;\n  this._geometryUpdater = geometryUpdater;\n  this._positions = [];\n}\n\nfunction getLine(dynamicGeometryUpdater) {\n  if (defined(dynamicGeometryUpdater._line)) {\n    return dynamicGeometryUpdater._line;\n  }\n\n  const primitives = dynamicGeometryUpdater._primitives;\n  const polylineCollectionId =\n    dynamicGeometryUpdater._geometryUpdater._scene.id + primitives._guid;\n  let polylineCollection = polylineCollections[polylineCollectionId];\n  if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n    polylineCollection = new PolylineCollection();\n    polylineCollections[polylineCollectionId] = polylineCollection;\n    primitives.add(polylineCollection);\n  } else if (!primitives.contains(polylineCollection)) {\n    primitives.add(polylineCollection);\n  }\n\n  const line = polylineCollection.add();\n  line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n  dynamicGeometryUpdater._line = line;\n  return line;\n}\n\nDynamicGeometryUpdater.prototype.update = function (time) {\n  const geometryUpdater = this._geometryUpdater;\n  const entity = geometryUpdater._entity;\n  const polyline = entity.polyline;\n\n  const positionsProperty = polyline.positions;\n  let positions = Property.getValueOrUndefined(\n    positionsProperty,\n    time,\n    this._positions,\n  );\n\n  // Synchronize with geometryUpdater for GroundPolylinePrimitive\n  geometryUpdater._clampToGround = Property.getValueOrDefault(\n    polyline._clampToGround,\n    time,\n    false,\n  );\n  geometryUpdater._groundGeometryOptions.positions = positions;\n  geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(\n    polyline._width,\n    time,\n    1,\n  );\n  geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(\n    polyline._arcType,\n    time,\n    ArcType.GEODESIC,\n  );\n  geometryUpdater._groundGeometryOptions.granularity =\n    Property.getValueOrDefault(polyline._granularity, time, 9999);\n\n  const groundPrimitives = this._groundPrimitives;\n\n  if (defined(this._groundPolylinePrimitive)) {\n    groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n    this._groundPolylinePrimitive = undefined;\n  }\n\n  if (geometryUpdater.clampToGround) {\n    if (\n      !entity.isShowing ||\n      !entity.isAvailable(time) ||\n      !Property.getValueOrDefault(polyline._show, time, true)\n    ) {\n      return;\n    }\n\n    if (!defined(positions) || positions.length < 2) {\n      return;\n    }\n\n    const fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n    let appearance;\n    if (fillMaterialProperty instanceof ColorMaterialProperty) {\n      appearance = new PolylineColorAppearance();\n    } else {\n      const material = MaterialProperty.getValue(\n        time,\n        fillMaterialProperty,\n        this._material,\n      );\n      appearance = new PolylineMaterialAppearance({\n        material: material,\n        translucent: material.isTranslucent(),\n      });\n      this._material = material;\n    }\n\n    this._groundPolylinePrimitive = groundPrimitives.add(\n      new GroundPolylinePrimitive({\n        geometryInstances: geometryUpdater.createFillGeometryInstance(time),\n        appearance: appearance,\n        classificationType:\n          geometryUpdater.classificationTypeProperty.getValue(time),\n        asynchronous: false,\n      }),\n      Property.getValueOrUndefined(geometryUpdater.zIndex, time),\n    );\n\n    // Hide the polyline in the collection, if any\n    if (defined(this._line)) {\n      this._line.show = false;\n    }\n    return;\n  }\n\n  const line = getLine(this);\n\n  if (\n    !entity.isShowing ||\n    !entity.isAvailable(time) ||\n    !Property.getValueOrDefault(polyline._show, time, true)\n  ) {\n    line.show = false;\n    return;\n  }\n\n  if (!defined(positions) || positions.length < 2) {\n    line.show = false;\n    return;\n  }\n\n  let arcType = ArcType.GEODESIC;\n  arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n\n  const globe = geometryUpdater._scene.globe;\n  const ellipsoid = geometryUpdater._scene.ellipsoid;\n  if (arcType !== ArcType.NONE && defined(globe)) {\n    generateCartesianArcOptions.ellipsoid = ellipsoid;\n    generateCartesianArcOptions.positions = positions;\n    generateCartesianArcOptions.granularity = Property.getValueOrUndefined(\n      polyline._granularity,\n      time,\n    );\n    generateCartesianArcOptions.height = PolylinePipeline.extractHeights(\n      positions,\n      ellipsoid,\n    );\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc(\n        generateCartesianArcOptions,\n      );\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc(\n        generateCartesianArcOptions,\n      );\n    }\n  }\n\n  line.show = true;\n  line.positions = positions.slice();\n  line.material = MaterialProperty.getValue(\n    time,\n    geometryUpdater.fillMaterialProperty,\n    line.material,\n  );\n  line.width = Property.getValueOrDefault(polyline._width, time, 1);\n  line.distanceDisplayCondition = Property.getValueOrUndefined(\n    polyline._distanceDisplayCondition,\n    time,\n    line.distanceDisplayCondition,\n  );\n};\n\nDynamicGeometryUpdater.prototype.getBoundingSphere = function (result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!this._geometryUpdater.clampToGround) {\n    const line = getLine(this);\n    if (line.show && line.positions.length > 0) {\n      BoundingSphere.fromPoints(line.positions, result);\n      return BoundingSphereState.DONE;\n    }\n  } else {\n    const groundPolylinePrimitive = this._groundPolylinePrimitive;\n    if (\n      defined(groundPolylinePrimitive) &&\n      groundPolylinePrimitive.show &&\n      groundPolylinePrimitive.ready\n    ) {\n      const attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(\n        this._geometryUpdater._entity,\n      );\n      if (defined(attributes) && defined(attributes.boundingSphere)) {\n        BoundingSphere.clone(attributes.boundingSphere, result);\n        return BoundingSphereState.DONE;\n      }\n    }\n\n    if (defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready) {\n      return BoundingSphereState.PENDING;\n    }\n\n    return BoundingSphereState.DONE;\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\nDynamicGeometryUpdater.prototype.isDestroyed = function () {\n  return false;\n};\n\nDynamicGeometryUpdater.prototype.destroy = function () {\n  const geometryUpdater = this._geometryUpdater;\n  const polylineCollectionId =\n    geometryUpdater._scene.id + this._primitives._guid;\n  const polylineCollection = polylineCollections[polylineCollectionId];\n  if (defined(polylineCollection)) {\n    polylineCollection.remove(this._line);\n    if (polylineCollection.length === 0) {\n      this._primitives.removeAndDestroy(polylineCollection);\n      delete polylineCollections[polylineCollectionId];\n    }\n  }\n  if (defined(this._groundPolylinePrimitive)) {\n    this._groundPrimitives.remove(this._groundPolylinePrimitive);\n  }\n  destroyObject(this);\n};\nexport default PolylineGeometryUpdater;\n"],"mappings":"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AAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEsB,oBAAoB,EAAE;IACpBL,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAChB,iBAAiB;IAC/B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEsB,yBAAyB,EAAE;IACzBN,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACZ,0BAA0B;IACxC;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEmB,cAAc,EAAE;IACdC,KAAK,EAAE;EACT,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,kBAAkB,EAAE;IAClBD,KAAK,EAAE;EACT,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,oBAAoB,EAAE;IACpBF,KAAK,EAAE5C;EACT,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE+C,eAAe,EAAE;IACfX,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,gBAAgB;IAC9B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACE2B,gCAAgC,EAAE;IAChCZ,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACd,iCAAiC;IAC/C;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACE2B,0BAA0B,EAAE;IAC1Bb,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACb,2BAA2B;IACzC;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE2B,SAAS,EAAE;IACTd,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACnB,QAAQ;IACtB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEkC,QAAQ,EAAE;IACRP,KAAK,EAAE;EACT,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEQ,eAAe,EAAE;IACfhB,GAAG,EAAE,SAAAA,CAAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}