{"ast":null,"code":"import { alphaNumericAndMarksRe, digitRe } from '../regex-lib';\nimport { UrlMatch } from '../match/url-match';\nimport { remove, assertNever } from '../utils';\nimport { httpSchemeRe, isDomainLabelChar, isDomainLabelStartChar, isPathChar, isSchemeChar, isSchemeStartChar, isUrlSuffixStartChar, isValidIpV4Address, isValidSchemeUrl, isValidTldMatch, urlSuffixedCharsNotAllowedAtEndRe } from './uri-utils';\nimport { isEmailLocalPartChar, isEmailLocalPartStartChar, isValidEmail, mailtoSchemePrefixRe } from './email-utils';\nimport { EmailMatch } from '../match/email-match';\nimport { isHashtagTextChar, isValidHashtag } from './hashtag-utils';\nimport { HashtagMatch } from '../match/hashtag-match';\nimport { isMentionTextChar, isValidMention } from './mention-utils';\nimport { MentionMatch } from '../match/mention-match';\nimport { isPhoneNumberSeparatorChar, isPhoneNumberControlChar, isValidPhoneNumber } from './phone-number-utils';\nimport { PhoneMatch } from '../match/phone-match';\n// For debugging: search for and uncomment other \"For debugging\" lines\n// import CliTable from 'cli-table';\n/**\n * Parses URL, email, twitter, mention, and hashtag matches from the given\n * `text`.\n */\nexport function parseMatches(text, args) {\n  var tagBuilder = args.tagBuilder;\n  var stripPrefix = args.stripPrefix;\n  var stripTrailingSlash = args.stripTrailingSlash;\n  var decodePercentEncoding = args.decodePercentEncoding;\n  var hashtagServiceName = args.hashtagServiceName;\n  var mentionServiceName = args.mentionServiceName;\n  var matches = [];\n  var textLen = text.length;\n  // An array of all active state machines. Empty array means we're in the\n  // \"no url\" state\n  var stateMachines = [];\n  // For debugging: search for and uncomment other \"For debugging\" lines\n  // const table = new CliTable({\n  //     head: ['charIdx', 'char', 'code', 'type', 'states', 'charIdx', 'startIdx', 'reached accept state'],\n  // });\n  var charIdx = 0;\n  for (; charIdx < textLen; charIdx++) {\n    var char = text.charAt(charIdx);\n    if (stateMachines.length === 0) {\n      stateNoMatch(char);\n    } else {\n      // Must loop through the state machines backwards for when one\n      // is removed\n      for (var stateIdx = stateMachines.length - 1; stateIdx >= 0; stateIdx--) {\n        var stateMachine = stateMachines[stateIdx];\n        switch (stateMachine.state) {\n          // Protocol-relative URL states\n          case 11 /* ProtocolRelativeSlash1 */:\n            stateProtocolRelativeSlash1(stateMachine, char);\n            break;\n          case 12 /* ProtocolRelativeSlash2 */:\n            stateProtocolRelativeSlash2(stateMachine, char);\n            break;\n          case 0 /* SchemeChar */:\n            stateSchemeChar(stateMachine, char);\n            break;\n          case 1 /* SchemeHyphen */:\n            stateSchemeHyphen(stateMachine, char);\n            break;\n          case 2 /* SchemeColon */:\n            stateSchemeColon(stateMachine, char);\n            break;\n          case 3 /* SchemeSlash1 */:\n            stateSchemeSlash1(stateMachine, char);\n            break;\n          case 4 /* SchemeSlash2 */:\n            stateSchemeSlash2(stateMachine, char);\n            break;\n          case 5 /* DomainLabelChar */:\n            stateDomainLabelChar(stateMachine, char);\n            break;\n          case 6 /* DomainHyphen */:\n            stateDomainHyphen(stateMachine, char);\n            break;\n          case 7 /* DomainDot */:\n            stateDomainDot(stateMachine, char);\n            break;\n          case 13 /* IpV4Digit */:\n            stateIpV4Digit(stateMachine, char);\n            break;\n          case 14 /* IpV4Dot */:\n            stateIPv4Dot(stateMachine, char);\n            break;\n          case 8 /* PortColon */:\n            statePortColon(stateMachine, char);\n            break;\n          case 9 /* PortNumber */:\n            statePortNumber(stateMachine, char);\n            break;\n          case 10 /* Path */:\n            statePath(stateMachine, char);\n            break;\n          // Email States\n          case 15 /* EmailMailto_M */:\n            stateEmailMailto_M(stateMachine, char);\n            break;\n          case 16 /* EmailMailto_A */:\n            stateEmailMailto_A(stateMachine, char);\n            break;\n          case 17 /* EmailMailto_I */:\n            stateEmailMailto_I(stateMachine, char);\n            break;\n          case 18 /* EmailMailto_L */:\n            stateEmailMailto_L(stateMachine, char);\n            break;\n          case 19 /* EmailMailto_T */:\n            stateEmailMailto_T(stateMachine, char);\n            break;\n          case 20 /* EmailMailto_O */:\n            stateEmailMailto_O(stateMachine, char);\n            break;\n          case 21 /* EmailMailto_Colon */:\n            stateEmailMailtoColon(stateMachine, char);\n            break;\n          case 22 /* EmailLocalPart */:\n            stateEmailLocalPart(stateMachine, char);\n            break;\n          case 23 /* EmailLocalPartDot */:\n            stateEmailLocalPartDot(stateMachine, char);\n            break;\n          case 24 /* EmailAtSign */:\n            stateEmailAtSign(stateMachine, char);\n            break;\n          case 25 /* EmailDomainChar */:\n            stateEmailDomainChar(stateMachine, char);\n            break;\n          case 26 /* EmailDomainHyphen */:\n            stateEmailDomainHyphen(stateMachine, char);\n            break;\n          case 27 /* EmailDomainDot */:\n            stateEmailDomainDot(stateMachine, char);\n            break;\n          // Hashtag states\n          case 28 /* HashtagHashChar */:\n            stateHashtagHashChar(stateMachine, char);\n            break;\n          case 29 /* HashtagTextChar */:\n            stateHashtagTextChar(stateMachine, char);\n            break;\n          // Mention states\n          case 30 /* MentionAtChar */:\n            stateMentionAtChar(stateMachine, char);\n            break;\n          case 31 /* MentionTextChar */:\n            stateMentionTextChar(stateMachine, char);\n            break;\n          // Phone number states\n          case 32 /* PhoneNumberOpenParen */:\n            statePhoneNumberOpenParen(stateMachine, char);\n            break;\n          case 33 /* PhoneNumberAreaCodeDigit1 */:\n            statePhoneNumberAreaCodeDigit1(stateMachine, char);\n            break;\n          case 34 /* PhoneNumberAreaCodeDigit2 */:\n            statePhoneNumberAreaCodeDigit2(stateMachine, char);\n            break;\n          case 35 /* PhoneNumberAreaCodeDigit3 */:\n            statePhoneNumberAreaCodeDigit3(stateMachine, char);\n            break;\n          case 36 /* PhoneNumberCloseParen */:\n            statePhoneNumberCloseParen(stateMachine, char);\n            break;\n          case 37 /* PhoneNumberPlus */:\n            statePhoneNumberPlus(stateMachine, char);\n            break;\n          case 38 /* PhoneNumberDigit */:\n            statePhoneNumberDigit(stateMachine, char);\n            break;\n          case 39 /* PhoneNumberSeparator */:\n            statePhoneNumberSeparator(stateMachine, char);\n            break;\n          case 40 /* PhoneNumberControlChar */:\n            statePhoneNumberControlChar(stateMachine, char);\n            break;\n          case 41 /* PhoneNumberPoundChar */:\n            statePhoneNumberPoundChar(stateMachine, char);\n            break;\n          default:\n            assertNever(stateMachine.state);\n        }\n      }\n      // Special case for handling a colon (or other non-alphanumeric)\n      // when preceded by another character, such as in the text:\n      //     Link 1:http://google.com\n      // In this case, the 'h' character after the colon wouldn't start a\n      // new scheme url because we'd be in a ipv4 or tld url and the colon\n      // would be interpreted as a port ':' char. Also, only start a new\n      // scheme url machine if there isn't currently one so we don't start\n      // new ones for colons inside a url\n      if (charIdx > 0 && isSchemeStartChar(char)) {\n        var prevChar = text.charAt(charIdx - 1);\n        if (!isSchemeStartChar(prevChar) && !stateMachines.some(isSchemeUrlStateMachine)) {\n          stateMachines.push(createSchemeUrlStateMachine(charIdx, 0 /* SchemeChar */));\n        }\n      }\n    }\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // table.push([\n    //     charIdx,\n    //     char,\n    //     `10: ${char.charCodeAt(0)}\\n0x: ${char.charCodeAt(0).toString(16)}\\nU+${char.codePointAt(0)}`,\n    //     stateMachines.map(machine => `${machine.type}${'matchType' in machine ? ` (${machine.matchType})` : ''}`).join('\\n') || '(none)',\n    //     stateMachines.map(machine => State[machine.state]).join('\\n') || '(none)',\n    //     charIdx,\n    //     stateMachines.map(m => m.startIdx).join('\\n'),\n    //     stateMachines.map(m => m.acceptStateReached).join('\\n'),\n    // ]);\n  }\n  // Capture any valid match at the end of the string\n  // Note: this loop must happen in reverse because\n  // captureMatchIfValidAndRemove() removes state machines from the array\n  // and we'll end up skipping every other one if we remove while looping\n  // forward\n  for (var i = stateMachines.length - 1; i >= 0; i--) {\n    stateMachines.forEach(function (stateMachine) {\n      return captureMatchIfValidAndRemove(stateMachine);\n    });\n  }\n  // For debugging: search for and uncomment other \"For debugging\" lines\n  // console.log(`\\nRead string:\\n  ${text}`);\n  // console.log(table.toString());\n  return matches;\n  // Handles the state when we're not in a URL/email/etc. (i.e. when no state machines exist)\n  function stateNoMatch(char) {\n    if (char === '#') {\n      // Hash char, start a Hashtag match\n      stateMachines.push(createHashtagStateMachine(charIdx, 28 /* HashtagHashChar */));\n    } else if (char === '@') {\n      // '@' char, start a Mention match\n      stateMachines.push(createMentionStateMachine(charIdx, 30 /* MentionAtChar */));\n    } else if (char === '/') {\n      // A slash could begin a protocol-relative URL\n      stateMachines.push(createTldUrlStateMachine(charIdx, 11 /* ProtocolRelativeSlash1 */));\n    } else if (char === '+') {\n      // A '+' char can start a Phone number\n      stateMachines.push(createPhoneNumberStateMachine(charIdx, 37 /* PhoneNumberPlus */));\n    } else if (char === '(') {\n      stateMachines.push(createPhoneNumberStateMachine(charIdx, 32 /* PhoneNumberOpenParen */));\n    } else {\n      if (digitRe.test(char)) {\n        // A digit could start a phone number\n        stateMachines.push(createPhoneNumberStateMachine(charIdx, 38 /* PhoneNumberDigit */));\n        // A digit could start an IP address\n        stateMachines.push(createIpV4UrlStateMachine(charIdx, 13 /* IpV4Digit */));\n      }\n      if (isEmailLocalPartStartChar(char)) {\n        // Any email local part. An 'm' character in particular could\n        // start a 'mailto:' match\n        var startState = char.toLowerCase() === 'm' ? 15 /* EmailMailto_M */ : 22 /* EmailLocalPart */;\n        stateMachines.push(createEmailStateMachine(charIdx, startState));\n      }\n      if (isSchemeStartChar(char)) {\n        // An uppercase or lowercase letter may start a scheme match\n        stateMachines.push(createSchemeUrlStateMachine(charIdx, 0 /* SchemeChar */));\n      }\n      if (alphaNumericAndMarksRe.test(char)) {\n        // A unicode alpha character or digit could start a domain name\n        // label for a TLD match\n        stateMachines.push(createTldUrlStateMachine(charIdx, 5 /* DomainLabelChar */));\n      }\n    }\n    // Anything else, remain in the \"non-url\" state by not creating any\n    // state machines\n  }\n  // Implements ABNF: ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  function stateSchemeChar(stateMachine, char) {\n    if (char === ':') {\n      stateMachine.state = 2 /* SchemeColon */;\n    } else if (char === '-') {\n      stateMachine.state = 1 /* SchemeHyphen */;\n    } else if (isSchemeChar(char)) {\n      // Stay in SchemeChar state\n    } else {\n      // Any other character, not a scheme\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function stateSchemeHyphen(stateMachine, char) {\n    if (char === '-') {\n      // Stay in SchemeHyphen state\n      // TODO: Should a colon following a dash be counted as the end of the scheme?\n      // } else if (char === ':') {\n      //     stateMachine.state = State.SchemeColon;\n    } else if (char === '/') {\n      // Not a valid scheme match, but may be the start of a\n      // protocol-relative match (such as //google.com)\n      remove(stateMachines, stateMachine);\n      stateMachines.push(createTldUrlStateMachine(charIdx, 11 /* ProtocolRelativeSlash1 */));\n    } else if (isSchemeChar(char)) {\n      stateMachine.state = 0 /* SchemeChar */;\n    } else {\n      // Any other character, not a scheme\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function stateSchemeColon(stateMachine, char) {\n    if (char === '/') {\n      stateMachine.state = 3 /* SchemeSlash1 */;\n    } else if (char === '.') {\n      // We've read something like 'hello:.' - don't capture\n      remove(stateMachines, stateMachine);\n    } else if (isDomainLabelStartChar(char)) {\n      stateMachine.state = 5 /* DomainLabelChar */;\n      // It's possible that we read an \"introduction\" piece of text,\n      // and the character after the current colon actually starts an\n      // actual scheme. An example of this is:\n      //     \"The link:http://google.com\"\n      // Hence, start a new machine to capture this match if so\n      if (isSchemeStartChar(char)) {\n        stateMachines.push(createSchemeUrlStateMachine(charIdx, 0 /* SchemeChar */));\n      }\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function stateSchemeSlash1(stateMachine, char) {\n    if (char === '/') {\n      stateMachine.state = 4 /* SchemeSlash2 */;\n    } else if (isPathChar(char)) {\n      stateMachine.state = 10 /* Path */;\n      stateMachine.acceptStateReached = true;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateSchemeSlash2(stateMachine, char) {\n    if (char === '/') {\n      // 3rd slash, must be an absolute path (path-absolute in the\n      // ABNF), such as in a file:///c:/windows/etc. See\n      // https://tools.ietf.org/html/rfc3986#appendix-A\n      stateMachine.state = 10 /* Path */;\n    } else if (isDomainLabelStartChar(char)) {\n      // start of \"authority\" section - see https://tools.ietf.org/html/rfc3986#appendix-A\n      stateMachine.state = 5 /* DomainLabelChar */;\n      stateMachine.acceptStateReached = true;\n    } else {\n      // not valid\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles reading a '/' from the NonUrl state\n  function stateProtocolRelativeSlash1(stateMachine, char) {\n    if (char === '/') {\n      stateMachine.state = 12 /* ProtocolRelativeSlash2 */;\n    } else {\n      // Anything else, cannot be the start of a protocol-relative\n      // URL.\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles reading a second '/', which could start a protocol-relative URL\n  function stateProtocolRelativeSlash2(stateMachine, char) {\n    if (isDomainLabelStartChar(char)) {\n      stateMachine.state = 5 /* DomainLabelChar */;\n    } else {\n      // Anything else, not a URL\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles when we have read a domain label character\n  function stateDomainLabelChar(stateMachine, char) {\n    if (char === '.') {\n      stateMachine.state = 7 /* DomainDot */;\n    } else if (char === '-') {\n      stateMachine.state = 6 /* DomainHyphen */;\n    } else if (char === ':') {\n      // Beginning of a port number, end the domain name\n      stateMachine.state = 8 /* PortColon */;\n    } else if (isUrlSuffixStartChar(char)) {\n      // '/', '?', or '#'\n      stateMachine.state = 10 /* Path */;\n    } else if (isDomainLabelChar(char)) {\n      // Stay in the DomainLabelChar state\n    } else {\n      // Anything else, end the domain name\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateDomainHyphen(stateMachine, char) {\n    if (char === '-') {\n      // Remain in the DomainHyphen state\n    } else if (char === '.') {\n      // Not valid to have a '-.' in a domain label\n      captureMatchIfValidAndRemove(stateMachine);\n    } else if (isDomainLabelStartChar(char)) {\n      stateMachine.state = 5 /* DomainLabelChar */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateDomainDot(stateMachine, char) {\n    if (char === '.') {\n      // domain names cannot have multiple '.'s next to each other.\n      // It's possible we've already read a valid domain name though,\n      // and that the '..' sequence just forms an ellipsis at the end\n      // of a sentence\n      captureMatchIfValidAndRemove(stateMachine);\n    } else if (isDomainLabelStartChar(char)) {\n      stateMachine.state = 5 /* DomainLabelChar */;\n      stateMachine.acceptStateReached = true; // after hitting a dot, and then another domain label, we've reached an accept state\n    } else {\n      // Anything else, end the domain name\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateIpV4Digit(stateMachine, char) {\n    if (char === '.') {\n      stateMachine.state = 14 /* IpV4Dot */;\n    } else if (char === ':') {\n      // Beginning of a port number\n      stateMachine.state = 8 /* PortColon */;\n    } else if (digitRe.test(char)) {\n      // stay in the IPv4 digit state\n    } else if (isUrlSuffixStartChar(char)) {\n      stateMachine.state = 10 /* Path */;\n    } else if (alphaNumericAndMarksRe.test(char)) {\n      // If we hit an alpha character, must not be an IPv4\n      // Example of this: 1.2.3.4abc\n      remove(stateMachines, stateMachine);\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateIPv4Dot(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.octetsEncountered++;\n      // Once we have encountered 4 octets, it's *potentially* a valid\n      // IPv4 address. Our IPv4 regex will confirm the match later\n      // though to make sure each octet is in the 0-255 range, and\n      // there's exactly 4 octets (not 5 or more)\n      if (stateMachine.octetsEncountered === 4) {\n        stateMachine.acceptStateReached = true;\n      }\n      stateMachine.state = 13 /* IpV4Digit */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function statePortColon(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 9 /* PortNumber */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function statePortNumber(stateMachine, char) {\n    if (digitRe.test(char)) {\n      // Stay in port number state\n    } else if (isUrlSuffixStartChar(char)) {\n      // '/', '?', or '#'\n      stateMachine.state = 10 /* Path */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function statePath(stateMachine, char) {\n    if (isPathChar(char)) {\n      // Stay in the path state\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  // Handles if we're reading a 'mailto:' prefix on the string\n  function stateEmailMailto_M(stateMachine, char) {\n    if (char.toLowerCase() === 'a') {\n      stateMachine.state = 16 /* EmailMailto_A */;\n    } else {\n      stateEmailLocalPart(stateMachine, char);\n    }\n  }\n  function stateEmailMailto_A(stateMachine, char) {\n    if (char.toLowerCase() === 'i') {\n      stateMachine.state = 17 /* EmailMailto_I */;\n    } else {\n      stateEmailLocalPart(stateMachine, char);\n    }\n  }\n  function stateEmailMailto_I(stateMachine, char) {\n    if (char.toLowerCase() === 'l') {\n      stateMachine.state = 18 /* EmailMailto_L */;\n    } else {\n      stateEmailLocalPart(stateMachine, char);\n    }\n  }\n  function stateEmailMailto_L(stateMachine, char) {\n    if (char.toLowerCase() === 't') {\n      stateMachine.state = 19 /* EmailMailto_T */;\n    } else {\n      stateEmailLocalPart(stateMachine, char);\n    }\n  }\n  function stateEmailMailto_T(stateMachine, char) {\n    if (char.toLowerCase() === 'o') {\n      stateMachine.state = 20 /* EmailMailto_O */;\n    } else {\n      stateEmailLocalPart(stateMachine, char);\n    }\n  }\n  function stateEmailMailto_O(stateMachine, char) {\n    if (char.toLowerCase() === ':') {\n      stateMachine.state = 21 /* EmailMailto_Colon */;\n    } else {\n      stateEmailLocalPart(stateMachine, char);\n    }\n  }\n  function stateEmailMailtoColon(stateMachine, char) {\n    if (isEmailLocalPartChar(char)) {\n      stateMachine.state = 22 /* EmailLocalPart */;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles the state when we're currently in the \"local part\" of an\n  // email address (as opposed to the \"domain part\")\n  function stateEmailLocalPart(stateMachine, char) {\n    if (char === '.') {\n      stateMachine.state = 23 /* EmailLocalPartDot */;\n    } else if (char === '@') {\n      stateMachine.state = 24 /* EmailAtSign */;\n    } else if (isEmailLocalPartChar(char)) {\n      // stay in the \"local part\" of the email address\n      // Note: because stateEmailLocalPart() is called from the\n      // 'mailto' states (when the 'mailto' prefix itself has been\n      // broken), make sure to set the state to EmailLocalPart\n      stateMachine.state = 22 /* EmailLocalPart */;\n    } else {\n      // not an email address character\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles the state where we've read\n  function stateEmailLocalPartDot(stateMachine, char) {\n    if (char === '.') {\n      // We read a second '.' in a row, not a valid email address\n      // local part\n      remove(stateMachines, stateMachine);\n    } else if (char === '@') {\n      // We read the '@' character immediately after a dot ('.'), not\n      // an email address\n      remove(stateMachines, stateMachine);\n    } else if (isEmailLocalPartChar(char)) {\n      stateMachine.state = 22 /* EmailLocalPart */;\n    } else {\n      // Anything else, not an email address\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function stateEmailAtSign(stateMachine, char) {\n    if (isDomainLabelStartChar(char)) {\n      stateMachine.state = 25 /* EmailDomainChar */;\n    } else {\n      // Anything else, not an email address\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function stateEmailDomainChar(stateMachine, char) {\n    if (char === '.') {\n      stateMachine.state = 27 /* EmailDomainDot */;\n    } else if (char === '-') {\n      stateMachine.state = 26 /* EmailDomainHyphen */;\n    } else if (isDomainLabelChar(char)) {\n      // Stay in the DomainChar state\n    } else {\n      // Anything else, we potentially matched if the criteria has\n      // been met\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateEmailDomainHyphen(stateMachine, char) {\n    if (char === '-' || char === '.') {\n      // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n      captureMatchIfValidAndRemove(stateMachine);\n    } else if (isDomainLabelChar(char)) {\n      stateMachine.state = 25 /* EmailDomainChar */;\n    } else {\n      // Anything else\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function stateEmailDomainDot(stateMachine, char) {\n    if (char === '.' || char === '-') {\n      // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n      captureMatchIfValidAndRemove(stateMachine);\n    } else if (isDomainLabelStartChar(char)) {\n      stateMachine.state = 25 /* EmailDomainChar */;\n      // After having read a '.' and then a valid domain character,\n      // we now know that the domain part of the email is valid, and\n      // we have found at least a partial EmailMatch (however, the\n      // email address may have additional characters from this point)\n      stateMachine.acceptStateReached = true;\n    } else {\n      // Anything else\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  // Handles the state when we've just encountered a '#' character\n  function stateHashtagHashChar(stateMachine, char) {\n    if (isHashtagTextChar(char)) {\n      // '#' char with valid hash text char following\n      stateMachine.state = 29 /* HashtagTextChar */;\n      stateMachine.acceptStateReached = true;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles the state when we're currently in the hash tag's text chars\n  function stateHashtagTextChar(stateMachine, char) {\n    if (isHashtagTextChar(char)) {\n      // Continue reading characters in the HashtagText state\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  // Handles the state when we've just encountered a '@' character\n  function stateMentionAtChar(stateMachine, char) {\n    if (isMentionTextChar(char)) {\n      // '@' char with valid mention text char following\n      stateMachine.state = 31 /* MentionTextChar */;\n      stateMachine.acceptStateReached = true;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  // Handles the state when we're currently in the mention's text chars\n  function stateMentionTextChar(stateMachine, char) {\n    if (isMentionTextChar(char)) {\n      // Continue reading characters in the HashtagText state\n    } else if (alphaNumericAndMarksRe.test(char)) {\n      // Char is invalid for a mention text char, not a valid match.\n      // Note that ascii alphanumeric chars are okay (which are tested\n      // in the previous 'if' statement, but others are not)\n      remove(stateMachines, stateMachine);\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  function statePhoneNumberPlus(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 38 /* PhoneNumberDigit */;\n    } else {\n      remove(stateMachines, stateMachine);\n      // This character may start a new match. Add states for it\n      stateNoMatch(char);\n    }\n  }\n  function statePhoneNumberOpenParen(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 33 /* PhoneNumberAreaCodeDigit1 */;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n    // It's also possible that the paren was just an open brace for\n    // a piece of text. Start other machines\n    stateNoMatch(char);\n  }\n  function statePhoneNumberAreaCodeDigit1(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 34 /* PhoneNumberAreaCodeDigit2 */;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function statePhoneNumberAreaCodeDigit2(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 35 /* PhoneNumberAreaCodeDigit3 */;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function statePhoneNumberAreaCodeDigit3(stateMachine, char) {\n    if (char === ')') {\n      stateMachine.state = 36 /* PhoneNumberCloseParen */;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function statePhoneNumberCloseParen(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 38 /* PhoneNumberDigit */;\n    } else if (isPhoneNumberSeparatorChar(char)) {\n      stateMachine.state = 39 /* PhoneNumberSeparator */;\n    } else {\n      remove(stateMachines, stateMachine);\n    }\n  }\n  function statePhoneNumberDigit(stateMachine, char) {\n    // For now, if we've reached any digits, we'll say that the machine\n    // has reached its accept state. The phone regex will confirm the\n    // match later.\n    // Alternatively, we could count the number of digits to avoid\n    // invoking the phone number regex\n    stateMachine.acceptStateReached = true;\n    if (isPhoneNumberControlChar(char)) {\n      stateMachine.state = 40 /* PhoneNumberControlChar */;\n    } else if (char === '#') {\n      stateMachine.state = 41 /* PhoneNumberPoundChar */;\n    } else if (digitRe.test(char)) {\n      // Stay in the phone number digit state\n    } else if (char === '(') {\n      stateMachine.state = 32 /* PhoneNumberOpenParen */;\n    } else if (isPhoneNumberSeparatorChar(char)) {\n      stateMachine.state = 39 /* PhoneNumberSeparator */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n      // The transition from a digit character to a letter can be the\n      // start of a new scheme URL match\n      if (isSchemeStartChar(char)) {\n        stateMachines.push(createSchemeUrlStateMachine(charIdx, 0 /* SchemeChar */));\n      }\n    }\n  }\n  function statePhoneNumberSeparator(stateMachine, char) {\n    if (digitRe.test(char)) {\n      stateMachine.state = 38 /* PhoneNumberDigit */;\n    } else if (char === '(') {\n      stateMachine.state = 32 /* PhoneNumberOpenParen */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n      // This character may start a new match. Add states for it\n      stateNoMatch(char);\n    }\n  }\n  // The \";\" characters is \"wait\" in a phone number\n  // The \",\" characters is \"pause\" in a phone number\n  function statePhoneNumberControlChar(stateMachine, char) {\n    if (isPhoneNumberControlChar(char)) {\n      // Stay in the \"control char\" state\n    } else if (char === '#') {\n      stateMachine.state = 41 /* PhoneNumberPoundChar */;\n    } else if (digitRe.test(char)) {\n      stateMachine.state = 38 /* PhoneNumberDigit */;\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  // The \"#\" characters is \"pound\" in a phone number\n  function statePhoneNumberPoundChar(stateMachine, char) {\n    if (isPhoneNumberControlChar(char)) {\n      stateMachine.state = 40 /* PhoneNumberControlChar */;\n    } else if (digitRe.test(char)) {\n      // According to some of the older tests, if there's a digit\n      // after a '#' sign, the match is invalid. TODO: Revisit if this is true\n      remove(stateMachines, stateMachine);\n    } else {\n      captureMatchIfValidAndRemove(stateMachine);\n    }\n  }\n  /*\n   * Captures a match if it is valid (i.e. has a full domain name for a\n   * TLD match). If a match is not valid, it is possible that we want to\n   * keep reading characters in order to make a full match.\n   */\n  function captureMatchIfValidAndRemove(stateMachine) {\n    // Remove the state machine first. There are a number of code paths\n    // which return out of this function early, so make sure we have\n    // this done\n    remove(stateMachines, stateMachine);\n    // Make sure the state machine being checked has actually reached an\n    // \"accept\" state. If it hasn't reach one, it can't be a match\n    if (!stateMachine.acceptStateReached) {\n      return;\n    }\n    var startIdx = stateMachine.startIdx;\n    var matchedText = text.slice(stateMachine.startIdx, charIdx);\n    // Handle any unbalanced braces (parens, square brackets, or curly\n    // brackets) inside the URL. This handles situations like:\n    //     The link (google.com)\n    // and\n    //     Check out this link here (en.wikipedia.org/wiki/IANA_(disambiguation))\n    //\n    // And also remove any punctuation chars at the end such as:\n    //     '?', ',', ':', '.', etc.\n    matchedText = excludeUnbalancedTrailingBracesAndPunctuation(matchedText);\n    if (stateMachine.type === 'url') {\n      // We don't want to accidentally match a URL that is preceded by an\n      // '@' character, which would be an email address\n      var charBeforeUrlMatch = text.charAt(stateMachine.startIdx - 1);\n      if (charBeforeUrlMatch === '@') {\n        return;\n      }\n      // For the purpose of this parser, we've generalized 'www'\n      // matches as part of 'tld' matches. However, for backward\n      // compatibility, we distinguish beween TLD matches and matches\n      // that begin with 'www.' so that users may turn off 'www'\n      // matches. As such, we need to correct for that now if the\n      // URL begins with 'www.'\n      var urlMatchType = stateMachine.matchType;\n      if (urlMatchType === 'scheme') {\n        // Autolinker accepts many characters in a url's scheme (like `fake://test.com`).\n        // However, in cases where a URL is missing whitespace before an obvious link,\n        // (for example: `nowhitespacehttp://www.test.com`), we only want the match to start\n        // at the http:// part. We will check if the match contains a common scheme and then\n        // shift the match to start from there.\n        var httpSchemeMatch = httpSchemeRe.exec(matchedText);\n        if (httpSchemeMatch) {\n          // If we found an overmatched URL, we want to find the index\n          // of where the match should start and shift the match to\n          // start from the beginning of the common scheme\n          startIdx = startIdx + httpSchemeMatch.index;\n          matchedText = matchedText.slice(httpSchemeMatch.index);\n        }\n        if (!isValidSchemeUrl(matchedText)) {\n          return; // not a valid match\n        }\n      } else if (urlMatchType === 'tld') {\n        if (!isValidTldMatch(matchedText)) {\n          return; // not a valid match\n        }\n      } else if (urlMatchType === 'ipV4') {\n        if (!isValidIpV4Address(matchedText)) {\n          return; // not a valid match\n        }\n      } else {\n        assertNever(urlMatchType);\n      }\n      matches.push(new UrlMatch({\n        tagBuilder: tagBuilder,\n        matchedText: matchedText,\n        offset: startIdx,\n        urlMatchType: urlMatchType,\n        url: matchedText,\n        protocolRelativeMatch: matchedText.slice(0, 2) === '//',\n        // TODO: Do these settings need to be passed to the match,\n        // or should we handle them here in UrlMatcher?\n        stripPrefix: stripPrefix,\n        stripTrailingSlash: stripTrailingSlash,\n        decodePercentEncoding: decodePercentEncoding\n      }));\n    } else if (stateMachine.type === 'email') {\n      // if the email address has a valid TLD, add it to the list of matches\n      if (isValidEmail(matchedText)) {\n        matches.push(new EmailMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: startIdx,\n          email: matchedText.replace(mailtoSchemePrefixRe, '')\n        }));\n      }\n    } else if (stateMachine.type === 'hashtag') {\n      if (isValidHashtag(matchedText)) {\n        matches.push(new HashtagMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: startIdx,\n          serviceName: hashtagServiceName,\n          hashtag: matchedText.slice(1)\n        }));\n      }\n    } else if (stateMachine.type === 'mention') {\n      if (isValidMention(matchedText, mentionServiceName)) {\n        matches.push(new MentionMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: startIdx,\n          serviceName: mentionServiceName,\n          mention: matchedText.slice(1) // strip off the '@' character at the beginning\n        }));\n      }\n    } else if (stateMachine.type === 'phone') {\n      // remove any trailing spaces that were considered as \"separator\"\n      // chars by the state machine\n      matchedText = matchedText.replace(/ +$/g, '');\n      if (isValidPhoneNumber(matchedText)) {\n        var cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''); // strip out non-digit characters exclude comma semicolon and #\n        matches.push(new PhoneMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: startIdx,\n          number: cleanNumber,\n          plusSign: matchedText.charAt(0) === '+'\n        }));\n      }\n    } else {\n      assertNever(stateMachine);\n    }\n  }\n}\nvar openBraceRe = /[\\(\\{\\[]/;\nvar closeBraceRe = /[\\)\\}\\]]/;\nvar oppositeBrace = {\n  ')': '(',\n  '}': '{',\n  ']': '['\n};\n/**\n * Determines if a match found has unmatched closing parenthesis,\n * square brackets or curly brackets. If so, these unbalanced symbol(s) will be\n * removed from the URL match itself.\n *\n * A match may have an extra closing parenthesis/square brackets/curly brackets\n * at the end of the match because these are valid URL path characters. For\n * example, \"wikipedia.com/something_(disambiguation)\" should be auto-linked.\n *\n * However, an extra parenthesis *will* be included when the URL itself is\n * wrapped in parenthesis, such as in the case of:\n *\n *     \"(wikipedia.com/something_(disambiguation))\"\n *\n * In this case, the last closing parenthesis should *not* be part of the\n * URL itself, and this method will exclude it from the returned URL.\n *\n * For square brackets in URLs such as in PHP arrays, the same behavior as\n * parenthesis discussed above should happen:\n *\n *     \"[http://www.example.com/foo.php?bar[]=1&bar[]=2&bar[]=3]\"\n *\n * The very last closing square bracket should not be part of the URL itself,\n * and therefore this method will remove it.\n *\n * @param matchedText The full matched URL/email/hashtag/etc. from the state\n *   machine parser.\n * @return The updated matched text with extraneous suffix characters removed.\n */\nexport function excludeUnbalancedTrailingBracesAndPunctuation(matchedText) {\n  var braceCounts = {\n    '(': 0,\n    '{': 0,\n    '[': 0\n  };\n  for (var i = 0; i < matchedText.length; i++) {\n    var char_1 = matchedText.charAt(i);\n    if (openBraceRe.test(char_1)) {\n      braceCounts[char_1]++;\n    } else if (closeBraceRe.test(char_1)) {\n      braceCounts[oppositeBrace[char_1]]--;\n    }\n  }\n  var endIdx = matchedText.length - 1;\n  var char;\n  while (endIdx >= 0) {\n    char = matchedText.charAt(endIdx);\n    if (closeBraceRe.test(char)) {\n      var oppositeBraceChar = oppositeBrace[char];\n      if (braceCounts[oppositeBraceChar] < 0) {\n        braceCounts[oppositeBraceChar]++;\n        endIdx--;\n      } else {\n        break;\n      }\n    } else if (urlSuffixedCharsNotAllowedAtEndRe.test(char)) {\n      // Walk back a punctuation char like '?', ',', ':', '.', etc.\n      endIdx--;\n    } else {\n      break;\n    }\n  }\n  return matchedText.slice(0, endIdx + 1);\n}\nfunction createSchemeUrlStateMachine(startIdx, state) {\n  return {\n    type: 'url',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false,\n    matchType: 'scheme'\n  };\n}\nfunction createTldUrlStateMachine(startIdx, state) {\n  return {\n    type: 'url',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false,\n    matchType: 'tld'\n  };\n}\nfunction createIpV4UrlStateMachine(startIdx, state) {\n  return {\n    type: 'url',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false,\n    matchType: 'ipV4',\n    octetsEncountered: 1 // starts at 1 because we create this machine when encountering the first octet\n  };\n}\nfunction createEmailStateMachine(startIdx, state) {\n  return {\n    type: 'email',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction createHashtagStateMachine(startIdx, state) {\n  return {\n    type: 'hashtag',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction createMentionStateMachine(startIdx, state) {\n  return {\n    type: 'mention',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction createPhoneNumberStateMachine(startIdx, state) {\n  return {\n    type: 'phone',\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction isSchemeUrlStateMachine(machine) {\n  return machine.type === 'url' && machine.matchType === 'scheme';\n}","map":{"version":3,"names":["alphaNumericAndMarksRe","digitRe","UrlMatch","remove","assertNever","httpSchemeRe","isDomainLabelChar","isDomainLabelStartChar","isPathChar","isSchemeChar","isSchemeStartChar","isUrlSuffixStartChar","isValidIpV4Address","isValidSchemeUrl","isValidTldMatch","urlSuffixedCharsNotAllowedAtEndRe","isEmailLocalPartChar","isEmailLocalPartStartChar","isValidEmail","mailtoSchemePrefixRe","EmailMatch","isHashtagTextChar","isValidHashtag","HashtagMatch","isMentionTextChar","isValidMention","MentionMatch","isPhoneNumberSeparatorChar","isPhoneNumberControlChar","isValidPhoneNumber","PhoneMatch","parseMatches","text","args","tagBuilder","stripPrefix","stripTrailingSlash","decodePercentEncoding","hashtagServiceName","mentionServiceName","matches","textLen","length","stateMachines","charIdx","char","charAt","stateNoMatch","stateIdx","stateMachine","state","stateProtocolRelativeSlash1","stateProtocolRelativeSlash2","stateSchemeChar","stateSchemeHyphen","stateSchemeColon","stateSchemeSlash1","stateSchemeSlash2","stateDomainLabelChar","stateDomainHyphen","stateDomainDot","stateIpV4Digit","stateIPv4Dot","statePortColon","statePortNumber","statePath","stateEmailMailto_M","stateEmailMailto_A","stateEmailMailto_I","stateEmailMailto_L","stateEmailMailto_T","stateEmailMailto_O","stateEmailMailtoColon","stateEmailLocalPart","stateEmailLocalPartDot","stateEmailAtSign","stateEmailDomainChar","stateEmailDomainHyphen","stateEmailDomainDot","stateHashtagHashChar","stateHashtagTextChar","stateMentionAtChar","stateMentionTextChar","statePhoneNumberOpenParen","statePhoneNumberAreaCodeDigit1","statePhoneNumberAreaCodeDigit2","statePhoneNumberAreaCodeDigit3","statePhoneNumberCloseParen","statePhoneNumberPlus","statePhoneNumberDigit","statePhoneNumberSeparator","statePhoneNumberControlChar","statePhoneNumberPoundChar","prevChar","some","isSchemeUrlStateMachine","push","createSchemeUrlStateMachine","i","forEach","captureMatchIfValidAndRemove","createHashtagStateMachine","createMentionStateMachine","createTldUrlStateMachine","createPhoneNumberStateMachine","test","createIpV4UrlStateMachine","startState","toLowerCase","createEmailStateMachine","acceptStateReached","octetsEncountered","startIdx","matchedText","slice","excludeUnbalancedTrailingBracesAndPunctuation","type","charBeforeUrlMatch","urlMatchType","matchType","httpSchemeMatch","exec","index","offset","url","protocolRelativeMatch","email","replace","serviceName","hashtag","mention","cleanNumber","number","plusSign","openBraceRe","closeBraceRe","oppositeBrace","braceCounts","char_1","endIdx","oppositeBraceChar","machine"],"sources":["../../../src/parser/parse-matches.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}