{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nconst IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const normal = plane.normal;\n  const denominator = Cartesian3.dot(normal, direction);\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n  const t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n  if (t < 0) {\n    return undefined;\n  }\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\nconst scratchEdge0 = new Cartesian3();\nconst scratchEdge1 = new Cartesian3();\nconst scratchPVec = new Cartesian3();\nconst scratchTVec = new Cartesian3();\nconst scratchQVec = new Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (ray, p0, p1, p2, cullBackFaces) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, false);\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  const edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n  const p = Cartesian3.cross(direction, edge1, scratchPVec);\n  const det = Cartesian3.dot(edge0, p);\n  let tvec;\n  let q;\n  let u;\n  let v;\n  let t;\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n    v = Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    const invDet = 1.0 / det;\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n    v = Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (ray, p0, p1, p2, cullBackFaces, result) {\n  const t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nconst scratchLineSegmentTriangleRay = new Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (v0, v1, p0, p1, p2, cullBackFaces, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n  const t = IntersectionTests.rayTriangleParametric(ray, p0, p1, p2, cullBackFaces);\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nfunction solveQuadratic(a, b, c, result) {\n  const det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    const denom = 1.0 / (2.0 * a);\n    const disc = Math.sqrt(det);\n    const root0 = (-b + disc) * denom;\n    const root1 = (-b - disc) * denom;\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n    return result;\n  }\n  const root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n  result.root0 = result.root1 = root;\n  return result;\n}\nconst raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0\n};\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const center = sphere.center;\n  const radiusSquared = sphere.radius * sphere.radius;\n  const diff = Cartesian3.subtract(origin, center, scratchPVec);\n  const a = Cartesian3.dot(direction, direction);\n  const b = 2.0 * Cartesian3.dot(direction, diff);\n  const c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n  const roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!defined(roots)) {\n    return undefined;\n  }\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\nconst scratchLineSegmentRay = new Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  const direction = Cartesian3.subtract(p1, p0, ray.direction);\n  const maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\nconst scratchQ = new Cartesian3();\nconst scratchW = new Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseRadii = ellipsoid.oneOverRadii;\n  const q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  const w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);\n  const q2 = Cartesian3.magnitudeSquared(q);\n  const qw = Cartesian3.dot(q, w);\n  let difference, w2, product, discriminant, temp;\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    const qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      const root0 = temp / w2;\n      const root1 = difference / temp;\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n      return {\n        start: root1,\n        stop: root0\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    const root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (CesiumMath.sign(left) !== CesiumMath.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {\n    return 0.0;\n  }\n  return difference;\n}\n\n/**\n * @private\n */\nIntersectionTests.quadraticVectorExpression = function (A, b, c, x, w) {\n  const xSquared = x * x;\n  const wSquared = w * w;\n  const l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  const l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);\n  const l0 = A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared + x * b.x + c;\n  const r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);\n  const r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);\n  let cosines;\n  const solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n    const cosine0 = cosines[0];\n    const sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n    if (cosines.length === 2) {\n      const cosine1 = cosines[1];\n      const sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n    return solutions;\n  }\n  const r0Squared = r0 * r0;\n  const r1Squared = r1 * r1;\n  const l2Squared = l2 * l2;\n  const r0r1 = r0 * r1;\n  const c4 = l2Squared + r1Squared;\n  const c3 = 2.0 * (l1 * l2 + r0r1);\n  const c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  const c1 = 2.0 * (l0 * l1 - r0r1);\n  const c0 = l0 * l0 - r0Squared;\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  const length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n  for (let i = 0; i < length; ++i) {\n    const cosine = cosines[i];\n    const cosineSquared = cosine * cosine;\n    const sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    const sine = Math.sqrt(sineSquared);\n\n    //const left = l2 * cosineSquared + l1 * cosine + l0;\n    let left;\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);\n    } else {\n      left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);\n    }\n    const right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);\n    const product = left * right;\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n  return solutions;\n};\nconst firstAxisScratch = new Cartesian3();\nconst secondAxisScratch = new Cartesian3();\nconst thirdAxisScratch = new Cartesian3();\nconst referenceScratch = new Cartesian3();\nconst bCart = new Cartesian3();\nconst bScratch = new Matrix3();\nconst btScratch = new Matrix3();\nconst diScratch = new Matrix3();\nconst dScratch = new Matrix3();\nconst cScratch = new Matrix3();\nconst tempMatrix = new Matrix3();\nconst aScratch = new Matrix3();\nconst sScratch = new Cartesian3();\nconst closestScratch = new Cartesian3();\nconst surfPointScratch = new Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const position = ray.origin;\n  const direction = ray.direction;\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    const normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n  const intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  const f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  const firstAxis = Cartesian3.normalize(f, f);\n  const reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  const secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);\n  const thirdAxis = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);\n  const B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n  const B_T = Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  const D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  const D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n  const C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n  const temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);\n  const A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);\n  const b = Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  const solutions = IntersectionTests.quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);\n  let s;\n  let altitude;\n  const length = solutions.length;\n  if (length > 0) {\n    let closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    let maximumValue = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);\n      const v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);\n      const dotProduct = Cartesian3.dot(v, direction);\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n    const surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n  return undefined;\n};\nconst lineSegmentPlaneDifference = new Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (endPoint0, endPoint1, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  const difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);\n  const normal = plane.normal;\n  const nDotDiff = Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n  const nDotP0 = Cartesian3.dot(normal, endPoint0);\n  const t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planeNormal = plane.normal;\n  const planeD = plane.distance;\n  const p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  const p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  const p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n  let u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n        // Behind\n        0, 3, 4,\n        // In front\n        1, 2, 4, 1, 4, 3]\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n        // Behind\n        1, 3, 4,\n        // In front\n        2, 0, 4, 2, 4, 3]\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n        // Behind\n        2, 3, 4,\n        // In front\n        0, 1, 4, 0, 4, 3]\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n        // Behind\n        1, 2, 4, 1, 4, 3,\n        // In front\n        0, 3, 4]\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n        // Behind\n        2, 0, 4, 2, 4, 3,\n        // In front\n        1, 3, 4]\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n        // Behind\n        0, 1, 4, 0, 4, 3,\n        // In front\n        2, 3, 4]\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\nexport default IntersectionTests;","map":{"version":3,"names":["Cartesian3","Cartographic","defaultValue","defined","DeveloperError","Interval","CesiumMath","Matrix3","QuadraticRealPolynomial","QuarticRealPolynomial","Ray","IntersectionTests","rayPlane","ray","plane","result","origin","direction","normal","denominator","dot","Math","abs","EPSILON15","undefined","t","distance","multiplyByScalar","add","scratchEdge0","scratchEdge1","scratchPVec","scratchTVec","scratchQVec","rayTriangleParametric","p0","p1","p2","cullBackFaces","edge0","subtract","edge1","p","cross","det","tvec","q","u","v","EPSILON6","invDet","rayTriangle","scratchLineSegmentTriangleRay","lineSegmentTriangle","v0","v1","clone","normalize","solveQuadratic","a","b","c","denom","disc","sqrt","root0","root1","root","raySphereRoots","raySphere","sphere","center","radiusSquared","radius","diff","magnitudeSquared","roots","start","stop","max","scratchLineSegmentRay","lineSegmentSphere","maxT","magnitude","min","scratchQ","scratchW","rayEllipsoid","ellipsoid","inverseRadii","oneOverRadii","multiplyComponents","w","q2","qw","difference","w2","product","discriminant","temp","qw2","addWithCancellationCheck","left","right","tolerance","sign","quadraticVectorExpression","A","x","xSquared","wSquared","l2","COLUMN1ROW1","COLUMN2ROW2","l1","COLUMN1ROW0","COLUMN0ROW1","y","l0","COLUMN0ROW0","r1","COLUMN2ROW1","COLUMN1ROW2","r0","COLUMN2ROW0","COLUMN0ROW2","z","cosines","solutions","computeRealRoots","length","cosine0","sine0","push","cosine1","sine1","r0Squared","r1Squared","l2Squared","r0r1","c4","c3","c2","c1","c0","i","cosine","cosineSquared","sineSquared","sine","EPSILON12","firstAxisScratch","secondAxisScratch","thirdAxisScratch","referenceScratch","bCart","bScratch","btScratch","diScratch","dScratch","cScratch","tempMatrix","aScratch","sScratch","closestScratch","surfPointScratch","grazingAltitudeLocation","position","equals","ZERO","geodeticSurfaceNormal","intersects","f","transformPositionToScaledSpace","firstAxis","reference","mostOrthogonalAxis","secondAxis","thirdAxis","B","B_T","transpose","D_I","fromScale","radii","D","C","multiply","multiplyByVector","negate","s","altitude","closest","maximumValue","Number","NEGATIVE_INFINITY","dotProduct","surfacePoint","cartesianToCartographic","clamp","height","cartographicToCartesian","lineSegmentPlaneDifference","lineSegmentPlane","endPoint0","endPoint1","nDotDiff","nDotP0","trianglePlaneIntersection","planeNormal","planeD","p0Behind","p1Behind","p2Behind","numBehind","u1","u2","positions","indices"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/IntersectionTests.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nconst IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const normal = plane.normal;\n  const denominator = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  const t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\n\nconst scratchEdge0 = new Cartesian3();\nconst scratchEdge1 = new Cartesian3();\nconst scratchPVec = new Cartesian3();\nconst scratchTVec = new Cartesian3();\nconst scratchQVec = new Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, false);\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  const edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n\n  const p = Cartesian3.cross(direction, edge1, scratchPVec);\n  const det = Cartesian3.dot(edge0, p);\n\n  let tvec;\n  let q;\n\n  let u;\n  let v;\n  let t;\n\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    const invDet = 1.0 / det;\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result,\n) {\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces,\n  );\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nconst scratchLineSegmentTriangleRay = new Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces,\n  );\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  const det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    const denom = 1.0 / (2.0 * a);\n    const disc = Math.sqrt(det);\n    const root0 = (-b + disc) * denom;\n    const root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  const root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nconst raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const center = sphere.center;\n  const radiusSquared = sphere.radius * sphere.radius;\n\n  const diff = Cartesian3.subtract(origin, center, scratchPVec);\n\n  const a = Cartesian3.dot(direction, direction);\n  const b = 2.0 * Cartesian3.dot(direction, diff);\n  const c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n  const roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nconst scratchLineSegmentRay = new Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  const direction = Cartesian3.subtract(p1, p0, ray.direction);\n\n  const maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nconst scratchQ = new Cartesian3();\nconst scratchW = new Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseRadii = ellipsoid.oneOverRadii;\n  const q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  const w = Cartesian3.multiplyComponents(\n    inverseRadii,\n    ray.direction,\n    scratchW,\n  );\n\n  const q2 = Cartesian3.magnitudeSquared(q);\n  const qw = Cartesian3.dot(q, w);\n\n  let difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    const qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      const root0 = temp / w2;\n      const root1 = difference / temp;\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    const root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\n/**\n * @private\n */\nIntersectionTests.quadraticVectorExpression = function (A, b, c, x, w) {\n  const xSquared = x * x;\n  const wSquared = w * w;\n\n  const l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  const l1 =\n    w *\n    (x *\n      addWithCancellationCheck(\n        A[Matrix3.COLUMN1ROW0],\n        A[Matrix3.COLUMN0ROW1],\n        CesiumMath.EPSILON15,\n      ) +\n      b.y);\n  const l0 =\n    A[Matrix3.COLUMN0ROW0] * xSquared +\n    A[Matrix3.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  const r1 =\n    wSquared *\n    addWithCancellationCheck(\n      A[Matrix3.COLUMN2ROW1],\n      A[Matrix3.COLUMN1ROW2],\n      CesiumMath.EPSILON15,\n    );\n  const r0 =\n    w *\n    (x *\n      addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) +\n      b.z);\n\n  let cosines;\n  const solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    const cosine0 = cosines[0];\n    const sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      const cosine1 = cosines[1];\n      const sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  const r0Squared = r0 * r0;\n  const r1Squared = r1 * r1;\n  const l2Squared = l2 * l2;\n  const r0r1 = r0 * r1;\n\n  const c4 = l2Squared + r1Squared;\n  const c3 = 2.0 * (l1 * l2 + r0r1);\n  const c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  const c1 = 2.0 * (l0 * l1 - r0r1);\n  const c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  const length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const cosine = cosines[i];\n    const cosineSquared = cosine * cosine;\n    const sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    const sine = Math.sqrt(sineSquared);\n\n    //const left = l2 * cosineSquared + l1 * cosine + l0;\n    let left;\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        CesiumMath.EPSILON12,\n      );\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        CesiumMath.EPSILON12,\n      );\n    } else {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        CesiumMath.EPSILON12,\n      );\n    }\n\n    const right = addWithCancellationCheck(\n      r1 * cosine,\n      r0,\n      CesiumMath.EPSILON15,\n    );\n    const product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n};\n\nconst firstAxisScratch = new Cartesian3();\nconst secondAxisScratch = new Cartesian3();\nconst thirdAxisScratch = new Cartesian3();\nconst referenceScratch = new Cartesian3();\nconst bCart = new Cartesian3();\nconst bScratch = new Matrix3();\nconst btScratch = new Matrix3();\nconst diScratch = new Matrix3();\nconst dScratch = new Matrix3();\nconst cScratch = new Matrix3();\nconst tempMatrix = new Matrix3();\nconst aScratch = new Matrix3();\nconst sScratch = new Cartesian3();\nconst closestScratch = new Cartesian3();\nconst surfPointScratch = new Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const position = ray.origin;\n  const direction = ray.direction;\n\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    const normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  const intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  const f = ellipsoid.transformPositionToScaledSpace(\n    direction,\n    firstAxisScratch,\n  );\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  const firstAxis = Cartesian3.normalize(f, f);\n  const reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  const secondAxis = Cartesian3.normalize(\n    Cartesian3.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch,\n  );\n  const thirdAxis = Cartesian3.normalize(\n    Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch,\n  );\n  const B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  const B_T = Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  const D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  const D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  const C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  const temp = Matrix3.multiply(\n    Matrix3.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix,\n  );\n  const A = Matrix3.multiply(\n    Matrix3.multiply(temp, D_I, aScratch),\n    B,\n    aScratch,\n  );\n  const b = Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  const solutions = IntersectionTests.quadraticVectorExpression(\n    A,\n    Cartesian3.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0,\n  );\n\n  let s;\n  let altitude;\n  const length = solutions.length;\n  if (length > 0) {\n    let closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    let maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(\n        D_I,\n        Matrix3.multiplyByVector(B, solutions[i], sScratch),\n        sScratch,\n      );\n      const v = Cartesian3.normalize(\n        Cartesian3.subtract(s, position, referenceScratch),\n        referenceScratch,\n      );\n      const dotProduct = Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n\n    const surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch,\n    );\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      Cartesian3.magnitude(\n        Cartesian3.subtract(closest, position, referenceScratch),\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n\n  return undefined;\n};\n\nconst lineSegmentPlaneDifference = new Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const difference = Cartesian3.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference,\n  );\n  const normal = plane.normal;\n  const nDotDiff = Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n\n  const nDotP0 = Cartesian3.dot(normal, endPoint0);\n  const t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planeNormal = plane.normal;\n  const planeD = plane.distance;\n  const p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  const p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  const p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  let u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0, 3, 4,\n\n          // In front\n          1, 2, 4, 1, 4, 3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1, 3, 4,\n\n          // In front\n          2, 0, 4, 2, 4, 3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2, 3, 4,\n\n          // In front\n          0, 1, 4, 0, 4, 3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1, 2, 4, 1, 4, 3,\n\n          // In front\n          0, 3, 4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2, 0, 4, 2, 4, 3,\n\n          // In front\n          1, 3, 4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0, 1, 4, 0, 4, 3,\n\n          // In front\n          2, 3, 4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\nexport default IntersectionTests;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}