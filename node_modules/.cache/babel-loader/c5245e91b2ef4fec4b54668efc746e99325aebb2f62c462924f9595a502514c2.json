{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"float interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n\\n\\\nvoid computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity, out float underTranslucentGlobe)\\n\\\n{\\n\\\n    float ellipsoidRadiiDifference = czm_ellipsoidRadii.x - czm_ellipsoidRadii.z;\\n\\\n\\n\\\n    // Adjustment to the atmosphere radius applied based on the camera height.\\n\\\n    float distanceAdjustMin = czm_ellipsoidRadii.x / 4.0;\\n\\\n    float distanceAdjustMax = czm_ellipsoidRadii.x;\\n\\\n    float distanceAdjustModifier = ellipsoidRadiiDifference / 2.0;\\n\\\n    float distanceAdjust = distanceAdjustModifier * clamp((czm_eyeHeight - distanceAdjustMin) / (distanceAdjustMax - distanceAdjustMin), 0.0, 1.0);\\n\\\n\\n\\\n    // Since atmosphere scattering assumes the atmosphere is a spherical shell, we compute an inner radius of the atmosphere best fit\\n\\\n    // for the position on the ellipsoid.\\n\\\n    float radiusAdjust = (ellipsoidRadiiDifference / 4.0) + distanceAdjust;\\n\\\n    float atmosphereInnerRadius = (length(czm_viewerPositionWC) - czm_eyeHeight) - radiusAdjust;\\n\\\n\\n\\\n    // Setup the primary ray: from the camera position to the vertex position.\\n\\\n    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;\\n\\\n    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);\\n\\\n    czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);\\n\\\n\\n\\\n    underTranslucentGlobe = 0.0;\\n\\\n\\n\\\n    // Brighten the sky atmosphere under the Earth's atmosphere when translucency is enabled.\\n\\\n    #if defined(GLOBE_TRANSLUCENT)\\n\\\n\\n\\\n        // Check for intersection with the inner radius of the atmopshere.\\n\\\n        czm_raySegment primaryRayEarthIntersect = czm_raySphereIntersectionInterval(primaryRay, vec3(0.0), atmosphereInnerRadius + radiusAdjust);\\n\\\n        if (primaryRayEarthIntersect.start > 0.0 && primaryRayEarthIntersect.stop > 0.0) {\\n\\\n\\n\\\n            // Compute position on globe.\\n\\\n            vec3 direction = normalize(positionWC);\\n\\\n            czm_ray ellipsoidRay = czm_ray(positionWC, -direction);\\n\\\n            czm_raySegment ellipsoidIntersection = czm_rayEllipsoidIntersectionInterval(ellipsoidRay, vec3(0.0), czm_ellipsoidInverseRadii);\\n\\\n            vec3 onEarth = positionWC - (direction * ellipsoidIntersection.start);\\n\\\n\\n\\\n            // Control the color using the camera angle.\\n\\\n            float angle = dot(normalize(czm_viewerPositionWC), normalize(onEarth));\\n\\\n\\n\\\n            // Control the opacity using the distance from Earth.\\n\\\n            opacity = interpolateByDistance(vec4(0.0, 1.0, czm_ellipsoidRadii.x, 0.0), length(czm_viewerPositionWC - onEarth));\\n\\\n            vec3 horizonColor = vec3(0.1, 0.2, 0.3);\\n\\\n            vec3 nearColor = vec3(0.0);\\n\\\n\\n\\\n            rayleighColor = mix(nearColor, horizonColor, exp(-angle) * opacity);\\n\\\n\\n\\\n            // Set the traslucent flag to avoid alpha adjustment in computeFinalColor funciton.\\n\\\n            underTranslucentGlobe = 1.0;\\n\\\n            return;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    computeScattering(\\n\\\n        primaryRay,\\n\\\n        length(cameraToPositionWC),\\n\\\n        lightDirection,\\n\\\n        atmosphereInnerRadius,\\n\\\n        rayleighColor,\\n\\\n        mieColor,\\n\\\n        opacity\\n\\\n    );\\n\\\n\\n\\\n    // Alter the opacity based on how close the viewer is to the ground.\\n\\\n    // (0.0 = At edge of atmosphere, 1.0 = On ground)\\n\\\n    float cameraHeight = czm_eyeHeight + atmosphereInnerRadius;\\n\\\n    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;\\n\\\n    opacity = clamp((atmosphereOuterRadius - cameraHeight) / (atmosphereOuterRadius - atmosphereInnerRadius), 0.0, 1.0);\\n\\\n\\n\\\n    // Alter alpha based on time of day (0.0 = night , 1.0 = day)\\n\\\n    float nightAlpha = (u_radiiAndDynamicAtmosphereColor.z != 0.0) ? clamp(dot(normalize(positionWC), lightDirection), 0.0, 1.0) : 1.0;\\n\\\n    opacity *= pow(nightAlpha, 0.5);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/SkyAtmosphereCommon.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"float interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n\\n\\\nvoid computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity, out float underTranslucentGlobe)\\n\\\n{\\n\\\n    float ellipsoidRadiiDifference = czm_ellipsoidRadii.x - czm_ellipsoidRadii.z;\\n\\\n\\n\\\n    // Adjustment to the atmosphere radius applied based on the camera height.\\n\\\n    float distanceAdjustMin = czm_ellipsoidRadii.x / 4.0;\\n\\\n    float distanceAdjustMax = czm_ellipsoidRadii.x;\\n\\\n    float distanceAdjustModifier = ellipsoidRadiiDifference / 2.0;\\n\\\n    float distanceAdjust = distanceAdjustModifier * clamp((czm_eyeHeight - distanceAdjustMin) / (distanceAdjustMax - distanceAdjustMin), 0.0, 1.0);\\n\\\n\\n\\\n    // Since atmosphere scattering assumes the atmosphere is a spherical shell, we compute an inner radius of the atmosphere best fit\\n\\\n    // for the position on the ellipsoid.\\n\\\n    float radiusAdjust = (ellipsoidRadiiDifference / 4.0) + distanceAdjust;\\n\\\n    float atmosphereInnerRadius = (length(czm_viewerPositionWC) - czm_eyeHeight) - radiusAdjust;\\n\\\n\\n\\\n    // Setup the primary ray: from the camera position to the vertex position.\\n\\\n    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;\\n\\\n    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);\\n\\\n    czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);\\n\\\n\\n\\\n    underTranslucentGlobe = 0.0;\\n\\\n\\n\\\n    // Brighten the sky atmosphere under the Earth's atmosphere when translucency is enabled.\\n\\\n    #if defined(GLOBE_TRANSLUCENT)\\n\\\n\\n\\\n        // Check for intersection with the inner radius of the atmopshere.\\n\\\n        czm_raySegment primaryRayEarthIntersect = czm_raySphereIntersectionInterval(primaryRay, vec3(0.0), atmosphereInnerRadius + radiusAdjust);\\n\\\n        if (primaryRayEarthIntersect.start > 0.0 && primaryRayEarthIntersect.stop > 0.0) {\\n\\\n\\n\\\n            // Compute position on globe.\\n\\\n            vec3 direction = normalize(positionWC);\\n\\\n            czm_ray ellipsoidRay = czm_ray(positionWC, -direction);\\n\\\n            czm_raySegment ellipsoidIntersection = czm_rayEllipsoidIntersectionInterval(ellipsoidRay, vec3(0.0), czm_ellipsoidInverseRadii);\\n\\\n            vec3 onEarth = positionWC - (direction * ellipsoidIntersection.start);\\n\\\n\\n\\\n            // Control the color using the camera angle.\\n\\\n            float angle = dot(normalize(czm_viewerPositionWC), normalize(onEarth));\\n\\\n\\n\\\n            // Control the opacity using the distance from Earth.\\n\\\n            opacity = interpolateByDistance(vec4(0.0, 1.0, czm_ellipsoidRadii.x, 0.0), length(czm_viewerPositionWC - onEarth));\\n\\\n            vec3 horizonColor = vec3(0.1, 0.2, 0.3);\\n\\\n            vec3 nearColor = vec3(0.0);\\n\\\n\\n\\\n            rayleighColor = mix(nearColor, horizonColor, exp(-angle) * opacity);\\n\\\n\\n\\\n            // Set the traslucent flag to avoid alpha adjustment in computeFinalColor funciton.\\n\\\n            underTranslucentGlobe = 1.0;\\n\\\n            return;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    computeScattering(\\n\\\n        primaryRay,\\n\\\n        length(cameraToPositionWC),\\n\\\n        lightDirection,\\n\\\n        atmosphereInnerRadius,\\n\\\n        rayleighColor,\\n\\\n        mieColor,\\n\\\n        opacity\\n\\\n    );\\n\\\n\\n\\\n    // Alter the opacity based on how close the viewer is to the ground.\\n\\\n    // (0.0 = At edge of atmosphere, 1.0 = On ground)\\n\\\n    float cameraHeight = czm_eyeHeight + atmosphereInnerRadius;\\n\\\n    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;\\n\\\n    opacity = clamp((atmosphereOuterRadius - cameraHeight) / (atmosphereOuterRadius - atmosphereInnerRadius), 0.0, 1.0);\\n\\\n\\n\\\n    // Alter alpha based on time of day (0.0 = night , 1.0 = day)\\n\\\n    float nightAlpha = (u_radiiAndDynamicAtmosphereColor.z != 0.0) ? clamp(dot(normalize(positionWC), lightDirection), 0.0, 1.0) : 1.0;\\n\\\n    opacity *= pow(nightAlpha, 0.5);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}