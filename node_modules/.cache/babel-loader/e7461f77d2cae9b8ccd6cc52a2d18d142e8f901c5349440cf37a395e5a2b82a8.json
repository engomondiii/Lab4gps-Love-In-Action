{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * Utilities for parsing bounding volume semantics from 3D Tiles 1.1 metadata.\n *\n * @namespace BoundingVolumeSemantics\n * @private\n */\nconst BoundingVolumeSemantics = {};\n\n/**\n * Parse the bounding volume-related semantics such as\n * <code>TILE_BOUNDING_BOX</code> and <code>CONTENT_BOUNDING_REGION</code> from\n * implicit tile metadata. Results are returned as a JSON object for use when\n * transcoding tiles (see {@link Implicit3DTileContent}).\n * <p>\n * Bounding volumes are checked in the order box, region, then sphere. Only\n * the first valid bounding volume is returned.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/Semantics|3D Metadata Semantic Reference} for the various bounding volumes and minimum/maximum heights.\n *\n * @param {TileMetadata} tileMetadata The metadata object for looking up values by semantic. In practice, this will typically be a {@link ImplicitMetadataView}\n * @return {object} An object containing a <code>tile</code> property and a <code>content</code> property. These contain the bounding volume, and any minimum or maximum height.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nBoundingVolumeSemantics.parseAllBoundingVolumeSemantics = function (tileMetadata) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  return {\n    tile: {\n      boundingVolume: BoundingVolumeSemantics.parseBoundingVolumeSemantic(\"TILE\", tileMetadata),\n      minimumHeight: BoundingVolumeSemantics._parseMinimumHeight(\"TILE\", tileMetadata),\n      maximumHeight: BoundingVolumeSemantics._parseMaximumHeight(\"TILE\", tileMetadata)\n    },\n    content: {\n      boundingVolume: BoundingVolumeSemantics.parseBoundingVolumeSemantic(\"CONTENT\", tileMetadata),\n      minimumHeight: BoundingVolumeSemantics._parseMinimumHeight(\"CONTENT\", tileMetadata),\n      maximumHeight: BoundingVolumeSemantics._parseMaximumHeight(\"CONTENT\", tileMetadata)\n    }\n  };\n};\n\n/**\n * Parse the bounding volume from a tile metadata. If the metadata specify\n * multiple bounding volumes, only the first one is returned. Bounding volumes\n * are checked in the order box, region, then sphere.\n *\n * This handles both tile and content bounding volumes, as the only difference\n * is the prefix. e.g. <code>TILE_BOUNDING_BOX</code> and\n * <code>CONTENT_BOUNDING_BOX</code> have the same memory layout.\n *\n * @param {string} prefix Either \"TILE\" or \"CONTENT\"\n * @param {TileMetadata} tileMetadata The tileMetadata for looking up values\n * @return {object} An object representing the JSON description of the tile metadata\n * @private\n */\nBoundingVolumeSemantics.parseBoundingVolumeSemantic = function (prefix, tileMetadata) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"prefix\", prefix);\n  if (prefix !== \"TILE\" && prefix !== \"CONTENT\") {\n    throw new DeveloperError(\"prefix must be either 'TILE' or 'CONTENT'\");\n  }\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  const boundingBoxSemantic = `${prefix}_BOUNDING_BOX`;\n  const boundingBox = tileMetadata.getPropertyBySemantic(boundingBoxSemantic);\n  if (defined(boundingBox)) {\n    return {\n      box: boundingBox\n    };\n  }\n  const boundingRegionSemantic = `${prefix}_BOUNDING_REGION`;\n  const boundingRegion = tileMetadata.getPropertyBySemantic(boundingRegionSemantic);\n  if (defined(boundingRegion)) {\n    return {\n      region: boundingRegion\n    };\n  }\n  const boundingSphereSemantic = `${prefix}_BOUNDING_SPHERE`;\n  const boundingSphere = tileMetadata.getPropertyBySemantic(boundingSphereSemantic);\n  if (defined(boundingSphere)) {\n    // ARRAY with 4 elements is automatically converted to a Cartesian4\n    return {\n      sphere: boundingSphere\n    };\n  }\n  return undefined;\n};\n\n/**\n * Parse the minimum height from tile metadata. This is used for making tighter\n * quadtree bounds for implicit tiling. This works for both\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>CONTENT_MINIMUM_HEIGHT</code>\n *\n * @param {string} prefix Either \"TILE\" or \"CONTENT\"\n * @param {TileMetadata} tileMetadata The tileMetadata for looking up values\n * @return {number} The minimum height\n * @private\n */\nBoundingVolumeSemantics._parseMinimumHeight = function (prefix, tileMetadata) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"prefix\", prefix);\n  if (prefix !== \"TILE\" && prefix !== \"CONTENT\") {\n    throw new DeveloperError(\"prefix must be either 'TILE' or 'CONTENT'\");\n  }\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  const minimumHeightSemantic = `${prefix}_MINIMUM_HEIGHT`;\n  return tileMetadata.getPropertyBySemantic(minimumHeightSemantic);\n};\n\n/**\n * Parse the maximum height from tile metadata. This is used for making tighter\n * quadtree bounds for implicit tiling. This works for both\n * <code>TILE_MAXIMUM_HEIGHT</code> and <code>CONTENT_MAXIMUM_HEIGHT</code>\n *\n * @param {string} prefix Either \"TILE\" or \"CONTENT\"\n * @param {TileMetadata} tileMetadata The tileMetadata for looking up values\n * @return {number} The maximum height\n * @private\n */\nBoundingVolumeSemantics._parseMaximumHeight = function (prefix, tileMetadata) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"prefix\", prefix);\n  if (prefix !== \"TILE\" && prefix !== \"CONTENT\") {\n    throw new DeveloperError(\"prefix must be either 'TILE' or 'CONTENT'\");\n  }\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  const maximumHeightSemantic = `${prefix}_MAXIMUM_HEIGHT`;\n  return tileMetadata.getPropertyBySemantic(maximumHeightSemantic);\n};\nexport default BoundingVolumeSemantics;","map":{"version":3,"names":["Check","defined","DeveloperError","BoundingVolumeSemantics","parseAllBoundingVolumeSemantics","tileMetadata","typeOf","object","tile","boundingVolume","parseBoundingVolumeSemantic","minimumHeight","_parseMinimumHeight","maximumHeight","_parseMaximumHeight","content","prefix","string","boundingBoxSemantic","boundingBox","getPropertyBySemantic","box","boundingRegionSemantic","boundingRegion","region","boundingSphereSemantic","boundingSphere","sphere","undefined","minimumHeightSemantic","maximumHeightSemantic"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/BoundingVolumeSemantics.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * Utilities for parsing bounding volume semantics from 3D Tiles 1.1 metadata.\n *\n * @namespace BoundingVolumeSemantics\n * @private\n */\nconst BoundingVolumeSemantics = {};\n\n/**\n * Parse the bounding volume-related semantics such as\n * <code>TILE_BOUNDING_BOX</code> and <code>CONTENT_BOUNDING_REGION</code> from\n * implicit tile metadata. Results are returned as a JSON object for use when\n * transcoding tiles (see {@link Implicit3DTileContent}).\n * <p>\n * Bounding volumes are checked in the order box, region, then sphere. Only\n * the first valid bounding volume is returned.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/Semantics|3D Metadata Semantic Reference} for the various bounding volumes and minimum/maximum heights.\n *\n * @param {TileMetadata} tileMetadata The metadata object for looking up values by semantic. In practice, this will typically be a {@link ImplicitMetadataView}\n * @return {object} An object containing a <code>tile</code> property and a <code>content</code> property. These contain the bounding volume, and any minimum or maximum height.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nBoundingVolumeSemantics.parseAllBoundingVolumeSemantics = function (\n  tileMetadata,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  return {\n    tile: {\n      boundingVolume: BoundingVolumeSemantics.parseBoundingVolumeSemantic(\n        \"TILE\",\n        tileMetadata,\n      ),\n      minimumHeight: BoundingVolumeSemantics._parseMinimumHeight(\n        \"TILE\",\n        tileMetadata,\n      ),\n      maximumHeight: BoundingVolumeSemantics._parseMaximumHeight(\n        \"TILE\",\n        tileMetadata,\n      ),\n    },\n    content: {\n      boundingVolume: BoundingVolumeSemantics.parseBoundingVolumeSemantic(\n        \"CONTENT\",\n        tileMetadata,\n      ),\n      minimumHeight: BoundingVolumeSemantics._parseMinimumHeight(\n        \"CONTENT\",\n        tileMetadata,\n      ),\n      maximumHeight: BoundingVolumeSemantics._parseMaximumHeight(\n        \"CONTENT\",\n        tileMetadata,\n      ),\n    },\n  };\n};\n\n/**\n * Parse the bounding volume from a tile metadata. If the metadata specify\n * multiple bounding volumes, only the first one is returned. Bounding volumes\n * are checked in the order box, region, then sphere.\n *\n * This handles both tile and content bounding volumes, as the only difference\n * is the prefix. e.g. <code>TILE_BOUNDING_BOX</code> and\n * <code>CONTENT_BOUNDING_BOX</code> have the same memory layout.\n *\n * @param {string} prefix Either \"TILE\" or \"CONTENT\"\n * @param {TileMetadata} tileMetadata The tileMetadata for looking up values\n * @return {object} An object representing the JSON description of the tile metadata\n * @private\n */\nBoundingVolumeSemantics.parseBoundingVolumeSemantic = function (\n  prefix,\n  tileMetadata,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"prefix\", prefix);\n  if (prefix !== \"TILE\" && prefix !== \"CONTENT\") {\n    throw new DeveloperError(\"prefix must be either 'TILE' or 'CONTENT'\");\n  }\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  const boundingBoxSemantic = `${prefix}_BOUNDING_BOX`;\n  const boundingBox = tileMetadata.getPropertyBySemantic(boundingBoxSemantic);\n\n  if (defined(boundingBox)) {\n    return {\n      box: boundingBox,\n    };\n  }\n\n  const boundingRegionSemantic = `${prefix}_BOUNDING_REGION`;\n  const boundingRegion = tileMetadata.getPropertyBySemantic(\n    boundingRegionSemantic,\n  );\n\n  if (defined(boundingRegion)) {\n    return {\n      region: boundingRegion,\n    };\n  }\n\n  const boundingSphereSemantic = `${prefix}_BOUNDING_SPHERE`;\n  const boundingSphere = tileMetadata.getPropertyBySemantic(\n    boundingSphereSemantic,\n  );\n\n  if (defined(boundingSphere)) {\n    // ARRAY with 4 elements is automatically converted to a Cartesian4\n    return {\n      sphere: boundingSphere,\n    };\n  }\n\n  return undefined;\n};\n\n/**\n * Parse the minimum height from tile metadata. This is used for making tighter\n * quadtree bounds for implicit tiling. This works for both\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>CONTENT_MINIMUM_HEIGHT</code>\n *\n * @param {string} prefix Either \"TILE\" or \"CONTENT\"\n * @param {TileMetadata} tileMetadata The tileMetadata for looking up values\n * @return {number} The minimum height\n * @private\n */\nBoundingVolumeSemantics._parseMinimumHeight = function (prefix, tileMetadata) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"prefix\", prefix);\n  if (prefix !== \"TILE\" && prefix !== \"CONTENT\") {\n    throw new DeveloperError(\"prefix must be either 'TILE' or 'CONTENT'\");\n  }\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  const minimumHeightSemantic = `${prefix}_MINIMUM_HEIGHT`;\n  return tileMetadata.getPropertyBySemantic(minimumHeightSemantic);\n};\n\n/**\n * Parse the maximum height from tile metadata. This is used for making tighter\n * quadtree bounds for implicit tiling. This works for both\n * <code>TILE_MAXIMUM_HEIGHT</code> and <code>CONTENT_MAXIMUM_HEIGHT</code>\n *\n * @param {string} prefix Either \"TILE\" or \"CONTENT\"\n * @param {TileMetadata} tileMetadata The tileMetadata for looking up values\n * @return {number} The maximum height\n * @private\n */\nBoundingVolumeSemantics._parseMaximumHeight = function (prefix, tileMetadata) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"prefix\", prefix);\n  if (prefix !== \"TILE\" && prefix !== \"CONTENT\") {\n    throw new DeveloperError(\"prefix must be either 'TILE' or 'CONTENT'\");\n  }\n  Check.typeOf.object(\"tileMetadata\", tileMetadata);\n  //>>includeEnd('debug');\n\n  const maximumHeightSemantic = `${prefix}_MAXIMUM_HEIGHT`;\n  return tileMetadata.getPropertyBySemantic(maximumHeightSemantic);\n};\n\nexport default BoundingVolumeSemantics;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}