{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport Vector3DTilePoints from \"./Vector3DTilePoints.js\";\nimport Vector3DTilePolygons from \"./Vector3DTilePolygons.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\nimport Vector3DTileClampedPolylines from \"./Vector3DTileClampedPolylines.js\";\nimport decodeVectorPolylinePositions from \"../Core/decodeVectorPolylinePositions.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/vctr/TileFormats/VectorData|Vector}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Vector3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Vector3DTileContent(tileset, tile, resource, arrayBuffer, byteOffset) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._polygons = undefined;\n  this._polylines = undefined;\n  this._points = undefined;\n  this._metadata = undefined;\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n  this._ready = false;\n  initialize(this, arrayBuffer, byteOffset);\n}\nObject.defineProperties(Vector3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    }\n  },\n  pointsLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.pointsLength;\n      }\n      return 0;\n    }\n  },\n  trianglesLength: {\n    get: function () {\n      let trianglesLength = 0;\n      if (defined(this._polygons)) {\n        trianglesLength += this._polygons.trianglesLength;\n      }\n      if (defined(this._polylines)) {\n        trianglesLength += this._polylines.trianglesLength;\n      }\n      return trianglesLength;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      let geometryByteLength = 0;\n      if (defined(this._polygons)) {\n        geometryByteLength += this._polygons.geometryByteLength;\n      }\n      if (defined(this._polylines)) {\n        geometryByteLength += this._polylines.geometryByteLength;\n      }\n      return geometryByteLength;\n    }\n  },\n  texturesByteLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.texturesByteLength;\n      }\n      return 0;\n    }\n  },\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.batchTableByteLength : 0;\n    }\n  },\n  innerContents: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Vector3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    }\n  },\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    }\n  },\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    }\n  },\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    }\n  }\n});\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._polygons)) {\n      content._polygons.updateCommands(batchId, color);\n    }\n  };\n}\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  let polygonBatchIds;\n  let polylineBatchIds;\n  let pointBatchIds;\n  let i;\n  const numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  const numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  const numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n  if (numberOfPolygons > 0 && defined(featureTableJson.POLYGON_BATCH_IDS)) {\n    const polygonBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.POLYGON_BATCH_IDS.byteOffset;\n    polygonBatchIds = new Uint16Array(featureTableBinary.buffer, polygonBatchIdsByteOffset, numberOfPolygons);\n  }\n  if (numberOfPolylines > 0 && defined(featureTableJson.POLYLINE_BATCH_IDS)) {\n    const polylineBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.POLYLINE_BATCH_IDS.byteOffset;\n    polylineBatchIds = new Uint16Array(featureTableBinary.buffer, polylineBatchIdsByteOffset, numberOfPolylines);\n  }\n  if (numberOfPoints > 0 && defined(featureTableJson.POINT_BATCH_IDS)) {\n    const pointBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.POINT_BATCH_IDS.byteOffset;\n    pointBatchIds = new Uint16Array(featureTableBinary.buffer, pointBatchIdsByteOffset, numberOfPoints);\n  }\n  const atLeastOneDefined = defined(polygonBatchIds) || defined(polylineBatchIds) || defined(pointBatchIds);\n  const atLeastOneUndefined = numberOfPolygons > 0 && !defined(polygonBatchIds) || numberOfPolylines > 0 && !defined(polylineBatchIds) || numberOfPoints > 0 && !defined(pointBatchIds);\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\"If one group of batch ids is defined, then all batch ids must be defined\");\n  }\n  const allUndefinedBatchIds = !defined(polygonBatchIds) && !defined(polylineBatchIds) && !defined(pointBatchIds);\n  if (allUndefinedBatchIds) {\n    let id = 0;\n    if (!defined(polygonBatchIds) && numberOfPolygons > 0) {\n      polygonBatchIds = new Uint16Array(numberOfPolygons);\n      for (i = 0; i < numberOfPolygons; ++i) {\n        polygonBatchIds[i] = id++;\n      }\n    }\n    if (!defined(polylineBatchIds) && numberOfPolylines > 0) {\n      polylineBatchIds = new Uint16Array(numberOfPolylines);\n      for (i = 0; i < numberOfPolylines; ++i) {\n        polylineBatchIds[i] = id++;\n      }\n    }\n    if (!defined(pointBatchIds) && numberOfPoints > 0) {\n      pointBatchIds = new Uint16Array(numberOfPoints);\n      for (i = 0; i < numberOfPoints; ++i) {\n        pointBatchIds[i] = id++;\n      }\n    }\n  }\n  return {\n    polygons: polygonBatchIds,\n    polylines: polylineBatchIds,\n    points: pointBatchIds\n  };\n}\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nfunction createFloatingPolylines(options) {\n  return new Vector3DTilePolylines(options);\n}\nfunction createClampedPolylines(options) {\n  return new Vector3DTileClampedPolylines(options);\n}\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(`Only Vector tile version 1 is supported.  Version ${version} is not.`);\n  }\n  byteOffset += sizeOfUint32;\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  if (byteLength === 0) {\n    content._ready = true;\n    return;\n  }\n  const featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const indicesByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const positionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const polylinePositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const pointsPositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const featureTableJson = getJsonFromTypedArray(uint8Array, byteOffset, featureTableJSONByteLength);\n  byteOffset += featureTableJSONByteLength;\n  const featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(uint8Array, byteOffset, batchTableJSONByteLength);\n    byteOffset += batchTableJSONByteLength;\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n  const numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  const numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  const numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n  const totalPrimitives = numberOfPolygons + numberOfPolylines + numberOfPoints;\n  const batchTable = new Cesium3DTileBatchTable(content, totalPrimitives, batchTableJson, batchTableBinary, createColorChangedCallback(content));\n  content._batchTable = batchTable;\n  if (totalPrimitives === 0) {\n    return;\n  }\n  const featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  const region = featureTable.getGlobalProperty(\"REGION\");\n  if (!defined(region)) {\n    throw new RuntimeError(\"Feature table global property: REGION must be defined\");\n  }\n  const rectangle = Rectangle.unpack(region);\n  const minHeight = region[4];\n  const maxHeight = region[5];\n  const modelMatrix = content._tile.computedTransform;\n  let center = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n  if (defined(center)) {\n    center = Cartesian3.unpack(center);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  } else {\n    center = Rectangle.center(rectangle);\n    center.height = CesiumMath.lerp(minHeight, maxHeight, 0.5);\n    center = Ellipsoid.WGS84.cartographicToCartesian(center);\n  }\n  const batchIds = getBatchIds(featureTableJson, featureTableBinary);\n  byteOffset += (4 - byteOffset % 4) % 4;\n  if (numberOfPolygons > 0) {\n    featureTable.featuresLength = numberOfPolygons;\n    const polygonCounts = defaultValue(featureTable.getPropertyArray(\"POLYGON_COUNTS\", ComponentDatatype.UNSIGNED_INT, 1), featureTable.getPropertyArray(\"POLYGON_COUNT\", ComponentDatatype.UNSIGNED_INT, 1) // Workaround for old vector tilesets using the non-plural name\n    );\n    if (!defined(polygonCounts)) {\n      throw new RuntimeError(\"Feature table property: POLYGON_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\");\n    }\n    const polygonIndexCounts = defaultValue(featureTable.getPropertyArray(\"POLYGON_INDEX_COUNTS\", ComponentDatatype.UNSIGNED_INT, 1), featureTable.getPropertyArray(\"POLYGON_INDEX_COUNT\", ComponentDatatype.UNSIGNED_INT, 1) // Workaround for old vector tilesets using the non-plural name\n    );\n    if (!defined(polygonIndexCounts)) {\n      throw new RuntimeError(\"Feature table property: POLYGON_INDEX_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\");\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    const numPolygonPositions = polygonCounts.reduce(function (total, count) {\n      return total + count * 2;\n    }, 0);\n    const numPolygonIndices = polygonIndexCounts.reduce(function (total, count) {\n      return total + count;\n    }, 0);\n    const indices = new Uint32Array(arrayBuffer, byteOffset, numPolygonIndices);\n    byteOffset += indicesByteLength;\n    const polygonPositions = new Uint16Array(arrayBuffer, byteOffset, numPolygonPositions);\n    byteOffset += positionByteLength;\n    let polygonMinimumHeights;\n    let polygonMaximumHeights;\n    if (defined(featureTableJson.POLYGON_MINIMUM_HEIGHTS) && defined(featureTableJson.POLYGON_MAXIMUM_HEIGHTS)) {\n      polygonMinimumHeights = featureTable.getPropertyArray(\"POLYGON_MINIMUM_HEIGHTS\", ComponentDatatype.FLOAT, 1);\n      polygonMaximumHeights = featureTable.getPropertyArray(\"POLYGON_MAXIMUM_HEIGHTS\", ComponentDatatype.FLOAT, 1);\n    }\n    content._polygons = new Vector3DTilePolygons({\n      positions: polygonPositions,\n      counts: polygonCounts,\n      indexCounts: polygonIndexCounts,\n      indices: indices,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      polygonMinimumHeights: polygonMinimumHeights,\n      polygonMaximumHeights: polygonMaximumHeights,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      batchIds: batchIds.polygons,\n      modelMatrix: modelMatrix\n    });\n  }\n  if (numberOfPolylines > 0) {\n    featureTable.featuresLength = numberOfPolylines;\n    const polylineCounts = defaultValue(featureTable.getPropertyArray(\"POLYLINE_COUNTS\", ComponentDatatype.UNSIGNED_INT, 1), featureTable.getPropertyArray(\"POLYLINE_COUNT\", ComponentDatatype.UNSIGNED_INT, 1) // Workaround for old vector tilesets using the non-plural name\n    );\n    if (!defined(polylineCounts)) {\n      throw new RuntimeError(\"Feature table property: POLYLINE_COUNTS must be defined when POLYLINES_LENGTH is greater than 0\");\n    }\n    let widths = featureTable.getPropertyArray(\"POLYLINE_WIDTHS\", ComponentDatatype.UNSIGNED_SHORT, 1);\n    if (!defined(widths)) {\n      widths = new Uint16Array(numberOfPolylines);\n      for (let i = 0; i < numberOfPolylines; ++i) {\n        widths[i] = 2.0;\n      }\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    const numPolylinePositions = polylineCounts.reduce(function (total, count) {\n      return total + count * 3;\n    }, 0);\n    const polylinePositions = new Uint16Array(arrayBuffer, byteOffset, numPolylinePositions);\n    byteOffset += polylinePositionByteLength;\n    const tileset = content._tileset;\n    const examineVectorLinesFunction = tileset.examineVectorLinesFunction;\n    if (defined(examineVectorLinesFunction)) {\n      const decodedPositions = decodeVectorPolylinePositions(new Uint16Array(polylinePositions), rectangle, minHeight, maxHeight, Ellipsoid.WGS84);\n      examineVectorLines(decodedPositions, polylineCounts, batchIds.polylines, batchTable, content.url, examineVectorLinesFunction);\n    }\n    let createPolylines = createFloatingPolylines;\n    if (defined(tileset.classificationType)) {\n      createPolylines = createClampedPolylines;\n    }\n    content._polylines = createPolylines({\n      positions: polylinePositions,\n      widths: widths,\n      counts: polylineCounts,\n      batchIds: batchIds.polylines,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      classificationType: tileset.classificationType,\n      keepDecodedPositions: tileset.vectorKeepDecodedPositions\n    });\n  }\n  if (numberOfPoints > 0) {\n    const pointPositions = new Uint16Array(arrayBuffer, byteOffset, numberOfPoints * 3);\n    byteOffset += pointsPositionByteLength;\n    content._points = new Vector3DTilePoints({\n      positions: pointPositions,\n      batchIds: batchIds.points,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      rectangle: rectangle,\n      batchTable: batchTable\n    });\n  }\n}\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    if (defined(content._polygons)) {\n      content._polygons.createFeatures(content, features);\n    }\n    if (defined(content._polylines)) {\n      content._polylines.createFeatures(content, features);\n    }\n    if (defined(content._points)) {\n      content._points.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\nVector3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\nVector3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(`batchId is required and between zero and featuresLength - 1 (${featuresLength - 1}).`);\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(this._features)) {\n    createFeatures(this);\n  }\n  return this._features[batchId];\n};\nVector3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._polygons)) {\n    this._polygons.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._points)) {\n    this._points.applyDebugSettings(enabled, color);\n  }\n};\nVector3DTileContent.prototype.applyStyle = function (style) {\n  if (!defined(this._features)) {\n    createFeatures(this);\n  }\n  if (defined(this._polygons)) {\n    this._polygons.applyStyle(style, this._features);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyStyle(style, this._features);\n  }\n  if (defined(this._points)) {\n    this._points.applyStyle(style, this._features);\n  }\n};\nVector3DTileContent.prototype.update = function (tileset, frameState) {\n  let ready = true;\n  if (defined(this._polygons)) {\n    this._polygons.classificationType = this._tileset.classificationType;\n    this._polygons.debugWireframe = this._tileset.debugWireframe;\n    this._polygons.update(frameState);\n    ready = ready && this._polygons.ready;\n  }\n  if (defined(this._polylines)) {\n    this._polylines.update(frameState);\n    ready = ready && this._polylines.ready;\n  }\n  if (defined(this._points)) {\n    this._points.update(frameState);\n    ready = ready && this._points.ready;\n  }\n  if (defined(this._batchTable) && ready) {\n    if (!defined(this._features)) {\n      createFeatures(this);\n    }\n    this._batchTable.update(tileset, frameState);\n    this._ready = true;\n  }\n};\nVector3DTileContent.prototype.pick = function (ray, frameState, result) {\n  return undefined;\n};\nVector3DTileContent.prototype.getPolylinePositions = function (batchId) {\n  const polylines = this._polylines;\n  if (!defined(polylines)) {\n    return undefined;\n  }\n  return polylines.getPositions(batchId);\n};\nVector3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\nVector3DTileContent.prototype.destroy = function () {\n  this._polygons = this._polygons && this._polygons.destroy();\n  this._polylines = this._polylines && this._polylines.destroy();\n  this._points = this._points && this._points.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nfunction examineVectorLines(positions, counts, batchIds, batchTable, url, callback) {\n  const countsLength = counts.length;\n  let polylineStart = 0;\n  for (let i = 0; i < countsLength; i++) {\n    const count = counts[i] * 3;\n    const linePositions = positions.slice(polylineStart, polylineStart + count);\n    polylineStart += count;\n    callback(linePositions, batchIds[i], url, batchTable);\n  }\n}\nexport default Vector3DTileContent;","map":{"version":3,"names":["Cartesian3","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","getJsonFromTypedArray","ComponentDatatype","CesiumMath","Matrix4","Rectangle","RuntimeError","Cesium3DTileBatchTable","Cesium3DTileFeatureTable","Vector3DTilePoints","Vector3DTilePolygons","Vector3DTilePolylines","Vector3DTileClampedPolylines","decodeVectorPolylinePositions","Vector3DTileContent","tileset","tile","resource","arrayBuffer","byteOffset","_tileset","_tile","_resource","_polygons","undefined","_polylines","_points","_metadata","_batchTable","_features","featurePropertiesDirty","_group","_ready","initialize","Object","defineProperties","prototype","featuresLength","get","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","innerContents","ready","url","getUrlComponent","metadata","set","value","batchTable","group","createColorChangedCallback","content","batchId","color","updateCommands","getBatchIds","featureTableJson","featureTableBinary","polygonBatchIds","polylineBatchIds","pointBatchIds","i","numberOfPolygons","POLYGONS_LENGTH","numberOfPolylines","POLYLINES_LENGTH","numberOfPoints","POINTS_LENGTH","POLYGON_BATCH_IDS","polygonBatchIdsByteOffset","Uint16Array","buffer","POLYLINE_BATCH_IDS","polylineBatchIdsByteOffset","POINT_BATCH_IDS","pointBatchIdsByteOffset","atLeastOneDefined","atLeastOneUndefined","allUndefinedBatchIds","id","polygons","polylines","points","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","createFloatingPolylines","options","createClampedPolylines","uint8Array","Uint8Array","view","DataView","version","getUint32","byteLength","featureTableJSONByteLength","featureTableBinaryByteLength","batchTableJSONByteLength","batchTableBinaryByteLength","indicesByteLength","positionByteLength","polylinePositionByteLength","pointsPositionByteLength","batchTableJson","batchTableBinary","totalPrimitives","featureTable","region","getGlobalProperty","rectangle","unpack","minHeight","maxHeight","modelMatrix","computedTransform","center","FLOAT","multiplyByPoint","height","lerp","WGS84","cartographicToCartesian","batchIds","polygonCounts","getPropertyArray","UNSIGNED_INT","polygonIndexCounts","numPolygonPositions","reduce","total","count","numPolygonIndices","indices","polygonPositions","polygonMinimumHeights","polygonMaximumHeights","POLYGON_MINIMUM_HEIGHTS","POLYGON_MAXIMUM_HEIGHTS","positions","counts","indexCounts","minimumHeight","maximumHeight","boundingVolume","polylineCounts","widths","UNSIGNED_SHORT","numPolylinePositions","polylinePositions","examineVectorLinesFunction","decodedPositions","examineVectorLines","createPolylines","classificationType","keepDecodedPositions","vectorKeepDecodedPositions","pointPositions","createFeatures","features","Array","hasProperty","name","getFeature","applyDebugSettings","enabled","applyStyle","style","update","frameState","debugWireframe","pick","ray","result","getPolylinePositions","getPositions","isDestroyed","destroy","callback","countsLength","length","polylineStart","linePositions","slice"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Vector3DTileContent.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport Vector3DTilePoints from \"./Vector3DTilePoints.js\";\nimport Vector3DTilePolygons from \"./Vector3DTilePolygons.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\nimport Vector3DTileClampedPolylines from \"./Vector3DTileClampedPolylines.js\";\nimport decodeVectorPolylinePositions from \"../Core/decodeVectorPolylinePositions.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/vctr/TileFormats/VectorData|Vector}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Vector3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Vector3DTileContent(tileset, tile, resource, arrayBuffer, byteOffset) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._polygons = undefined;\n  this._polylines = undefined;\n  this._points = undefined;\n\n  this._metadata = undefined;\n\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  this._ready = false;\n\n  initialize(this, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Vector3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.pointsLength;\n      }\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      let trianglesLength = 0;\n      if (defined(this._polygons)) {\n        trianglesLength += this._polygons.trianglesLength;\n      }\n      if (defined(this._polylines)) {\n        trianglesLength += this._polylines.trianglesLength;\n      }\n      return trianglesLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      let geometryByteLength = 0;\n      if (defined(this._polygons)) {\n        geometryByteLength += this._polygons.geometryByteLength;\n      }\n      if (defined(this._polylines)) {\n        geometryByteLength += this._polylines.geometryByteLength;\n      }\n      return geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.texturesByteLength;\n      }\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable)\n        ? this._batchTable.batchTableByteLength\n        : 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Vector3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._polygons)) {\n      content._polygons.updateCommands(batchId, color);\n    }\n  };\n}\n\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  let polygonBatchIds;\n  let polylineBatchIds;\n  let pointBatchIds;\n  let i;\n\n  const numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  const numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  const numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n\n  if (numberOfPolygons > 0 && defined(featureTableJson.POLYGON_BATCH_IDS)) {\n    const polygonBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POLYGON_BATCH_IDS.byteOffset;\n    polygonBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      polygonBatchIdsByteOffset,\n      numberOfPolygons,\n    );\n  }\n\n  if (numberOfPolylines > 0 && defined(featureTableJson.POLYLINE_BATCH_IDS)) {\n    const polylineBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POLYLINE_BATCH_IDS.byteOffset;\n    polylineBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      polylineBatchIdsByteOffset,\n      numberOfPolylines,\n    );\n  }\n\n  if (numberOfPoints > 0 && defined(featureTableJson.POINT_BATCH_IDS)) {\n    const pointBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POINT_BATCH_IDS.byteOffset;\n    pointBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      pointBatchIdsByteOffset,\n      numberOfPoints,\n    );\n  }\n\n  const atLeastOneDefined =\n    defined(polygonBatchIds) ||\n    defined(polylineBatchIds) ||\n    defined(pointBatchIds);\n  const atLeastOneUndefined =\n    (numberOfPolygons > 0 && !defined(polygonBatchIds)) ||\n    (numberOfPolylines > 0 && !defined(polylineBatchIds)) ||\n    (numberOfPoints > 0 && !defined(pointBatchIds));\n\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\n      \"If one group of batch ids is defined, then all batch ids must be defined\",\n    );\n  }\n\n  const allUndefinedBatchIds =\n    !defined(polygonBatchIds) &&\n    !defined(polylineBatchIds) &&\n    !defined(pointBatchIds);\n  if (allUndefinedBatchIds) {\n    let id = 0;\n    if (!defined(polygonBatchIds) && numberOfPolygons > 0) {\n      polygonBatchIds = new Uint16Array(numberOfPolygons);\n      for (i = 0; i < numberOfPolygons; ++i) {\n        polygonBatchIds[i] = id++;\n      }\n    }\n    if (!defined(polylineBatchIds) && numberOfPolylines > 0) {\n      polylineBatchIds = new Uint16Array(numberOfPolylines);\n      for (i = 0; i < numberOfPolylines; ++i) {\n        polylineBatchIds[i] = id++;\n      }\n    }\n    if (!defined(pointBatchIds) && numberOfPoints > 0) {\n      pointBatchIds = new Uint16Array(numberOfPoints);\n      for (i = 0; i < numberOfPoints; ++i) {\n        pointBatchIds[i] = id++;\n      }\n    }\n  }\n\n  return {\n    polygons: polygonBatchIds,\n    polylines: polylineBatchIds,\n    points: pointBatchIds,\n  };\n}\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction createFloatingPolylines(options) {\n  return new Vector3DTilePolylines(options);\n}\n\nfunction createClampedPolylines(options) {\n  return new Vector3DTileClampedPolylines(options);\n}\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Vector tile version 1 is supported.  Version ${version} is not.`,\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (byteLength === 0) {\n    content._ready = true;\n    return;\n  }\n\n  const featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\",\n    );\n  }\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const indicesByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const positionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const polylinePositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const pointsPositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJSONByteLength,\n  );\n  byteOffset += featureTableJSONByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength,\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJSONByteLength,\n    );\n    byteOffset += batchTableJSONByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength,\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  const numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  const numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n  const totalPrimitives = numberOfPolygons + numberOfPolylines + numberOfPoints;\n\n  const batchTable = new Cesium3DTileBatchTable(\n    content,\n    totalPrimitives,\n    batchTableJson,\n    batchTableBinary,\n    createColorChangedCallback(content),\n  );\n  content._batchTable = batchTable;\n\n  if (totalPrimitives === 0) {\n    return;\n  }\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary,\n  );\n  const region = featureTable.getGlobalProperty(\"REGION\");\n  if (!defined(region)) {\n    throw new RuntimeError(\n      \"Feature table global property: REGION must be defined\",\n    );\n  }\n  const rectangle = Rectangle.unpack(region);\n  const minHeight = region[4];\n  const maxHeight = region[5];\n\n  const modelMatrix = content._tile.computedTransform;\n\n  let center = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n  if (defined(center)) {\n    center = Cartesian3.unpack(center);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  } else {\n    center = Rectangle.center(rectangle);\n    center.height = CesiumMath.lerp(minHeight, maxHeight, 0.5);\n    center = Ellipsoid.WGS84.cartographicToCartesian(center);\n  }\n\n  const batchIds = getBatchIds(featureTableJson, featureTableBinary);\n  byteOffset += (4 - (byteOffset % 4)) % 4;\n\n  if (numberOfPolygons > 0) {\n    featureTable.featuresLength = numberOfPolygons;\n\n    const polygonCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYGON_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1,\n      ),\n      featureTable.getPropertyArray(\n        \"POLYGON_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1,\n      ), // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYGON_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\",\n      );\n    }\n\n    const polygonIndexCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYGON_INDEX_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1,\n      ),\n      featureTable.getPropertyArray(\n        \"POLYGON_INDEX_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1,\n      ), // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonIndexCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYGON_INDEX_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\",\n      );\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    const numPolygonPositions = polygonCounts.reduce(function (total, count) {\n      return total + count * 2;\n    }, 0);\n\n    const numPolygonIndices = polygonIndexCounts.reduce(function (\n      total,\n      count,\n    ) {\n      return total + count;\n    }, 0);\n\n    const indices = new Uint32Array(arrayBuffer, byteOffset, numPolygonIndices);\n    byteOffset += indicesByteLength;\n\n    const polygonPositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numPolygonPositions,\n    );\n    byteOffset += positionByteLength;\n\n    let polygonMinimumHeights;\n    let polygonMaximumHeights;\n    if (\n      defined(featureTableJson.POLYGON_MINIMUM_HEIGHTS) &&\n      defined(featureTableJson.POLYGON_MAXIMUM_HEIGHTS)\n    ) {\n      polygonMinimumHeights = featureTable.getPropertyArray(\n        \"POLYGON_MINIMUM_HEIGHTS\",\n        ComponentDatatype.FLOAT,\n        1,\n      );\n      polygonMaximumHeights = featureTable.getPropertyArray(\n        \"POLYGON_MAXIMUM_HEIGHTS\",\n        ComponentDatatype.FLOAT,\n        1,\n      );\n    }\n\n    content._polygons = new Vector3DTilePolygons({\n      positions: polygonPositions,\n      counts: polygonCounts,\n      indexCounts: polygonIndexCounts,\n      indices: indices,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      polygonMinimumHeights: polygonMinimumHeights,\n      polygonMaximumHeights: polygonMaximumHeights,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      batchIds: batchIds.polygons,\n      modelMatrix: modelMatrix,\n    });\n  }\n\n  if (numberOfPolylines > 0) {\n    featureTable.featuresLength = numberOfPolylines;\n\n    const polylineCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYLINE_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1,\n      ),\n      featureTable.getPropertyArray(\n        \"POLYLINE_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1,\n      ), // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polylineCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYLINE_COUNTS must be defined when POLYLINES_LENGTH is greater than 0\",\n      );\n    }\n\n    let widths = featureTable.getPropertyArray(\n      \"POLYLINE_WIDTHS\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n    );\n    if (!defined(widths)) {\n      widths = new Uint16Array(numberOfPolylines);\n      for (let i = 0; i < numberOfPolylines; ++i) {\n        widths[i] = 2.0;\n      }\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    const numPolylinePositions = polylineCounts.reduce(function (total, count) {\n      return total + count * 3;\n    }, 0);\n    const polylinePositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numPolylinePositions,\n    );\n    byteOffset += polylinePositionByteLength;\n\n    const tileset = content._tileset;\n    const examineVectorLinesFunction = tileset.examineVectorLinesFunction;\n    if (defined(examineVectorLinesFunction)) {\n      const decodedPositions = decodeVectorPolylinePositions(\n        new Uint16Array(polylinePositions),\n        rectangle,\n        minHeight,\n        maxHeight,\n        Ellipsoid.WGS84,\n      );\n      examineVectorLines(\n        decodedPositions,\n        polylineCounts,\n        batchIds.polylines,\n        batchTable,\n        content.url,\n        examineVectorLinesFunction,\n      );\n    }\n\n    let createPolylines = createFloatingPolylines;\n    if (defined(tileset.classificationType)) {\n      createPolylines = createClampedPolylines;\n    }\n\n    content._polylines = createPolylines({\n      positions: polylinePositions,\n      widths: widths,\n      counts: polylineCounts,\n      batchIds: batchIds.polylines,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      classificationType: tileset.classificationType,\n      keepDecodedPositions: tileset.vectorKeepDecodedPositions,\n    });\n  }\n\n  if (numberOfPoints > 0) {\n    const pointPositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numberOfPoints * 3,\n    );\n    byteOffset += pointsPositionByteLength;\n    content._points = new Vector3DTilePoints({\n      positions: pointPositions,\n      batchIds: batchIds.points,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      rectangle: rectangle,\n      batchTable: batchTable,\n    });\n  }\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n\n    if (defined(content._polygons)) {\n      content._polygons.createFeatures(content, features);\n    }\n    if (defined(content._polylines)) {\n      content._polylines.createFeatures(content, features);\n    }\n    if (defined(content._points)) {\n      content._points.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\n\nVector3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nVector3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(this._features)) {\n    createFeatures(this);\n  }\n\n  return this._features[batchId];\n};\n\nVector3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._polygons)) {\n    this._polygons.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._points)) {\n    this._points.applyDebugSettings(enabled, color);\n  }\n};\n\nVector3DTileContent.prototype.applyStyle = function (style) {\n  if (!defined(this._features)) {\n    createFeatures(this);\n  }\n  if (defined(this._polygons)) {\n    this._polygons.applyStyle(style, this._features);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyStyle(style, this._features);\n  }\n  if (defined(this._points)) {\n    this._points.applyStyle(style, this._features);\n  }\n};\n\nVector3DTileContent.prototype.update = function (tileset, frameState) {\n  let ready = true;\n  if (defined(this._polygons)) {\n    this._polygons.classificationType = this._tileset.classificationType;\n    this._polygons.debugWireframe = this._tileset.debugWireframe;\n    this._polygons.update(frameState);\n    ready = ready && this._polygons.ready;\n  }\n  if (defined(this._polylines)) {\n    this._polylines.update(frameState);\n    ready = ready && this._polylines.ready;\n  }\n  if (defined(this._points)) {\n    this._points.update(frameState);\n    ready = ready && this._points.ready;\n  }\n  if (defined(this._batchTable) && ready) {\n    if (!defined(this._features)) {\n      createFeatures(this);\n    }\n    this._batchTable.update(tileset, frameState);\n    this._ready = true;\n  }\n};\n\nVector3DTileContent.prototype.pick = function (ray, frameState, result) {\n  return undefined;\n};\n\nVector3DTileContent.prototype.getPolylinePositions = function (batchId) {\n  const polylines = this._polylines;\n  if (!defined(polylines)) {\n    return undefined;\n  }\n\n  return polylines.getPositions(batchId);\n};\n\nVector3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nVector3DTileContent.prototype.destroy = function () {\n  this._polygons = this._polygons && this._polygons.destroy();\n  this._polylines = this._polylines && this._polylines.destroy();\n  this._points = this._points && this._points.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nfunction examineVectorLines(\n  positions,\n  counts,\n  batchIds,\n  batchTable,\n  url,\n  callback,\n) {\n  const countsLength = counts.length;\n  let polylineStart = 0;\n  for (let i = 0; i < countsLength; i++) {\n    const count = counts[i] * 3;\n    const linePositions = positions.slice(polylineStart, polylineStart + count);\n    polylineStart += count;\n\n    callback(linePositions, batchIds[i], url, batchTable);\n  }\n}\n\nexport default Vector3DTileContent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}