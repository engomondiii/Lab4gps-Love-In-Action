{"ast":null,"code":"import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CoplanarPolygonGeometryLibrary from \"./CoplanarPolygonGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nfunction createGeometryFromPositions(positions) {\n  const length = positions.length;\n  const flatPositions = new Float64Array(length * 3);\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n  let positionIndex = 0;\n  let index = 0;\n  for (let i = 0; i < length; i++) {\n    const position = positions[i];\n    flatPositions[positionIndex++] = position.x;\n    flatPositions[positionIndex++] = position.y;\n    flatPositions[positionIndex++] = position.z;\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: flatPositions\n    })\n  });\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES\n  });\n}\n\n/**\n * A description of the outline of a polygon composed of arbitrary coplanar positions.\n *\n * @alias CoplanarPolygonOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n *\n * @see CoplanarPolygonOutlineGeometry.createGeometry\n *\n * @example\n * const polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * const geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n */\nfunction CoplanarPolygonOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const polygonHierarchy = options.polygonHierarchy;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.polygonHierarchy\", polygonHierarchy);\n  //>>includeEnd('debug');\n\n  this._polygonHierarchy = polygonHierarchy;\n  this._workerName = \"createCoplanarPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy, Cartesian3) + 1;\n}\n\n/**\n * A description of a coplanar polygon outline from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @returns {CoplanarPolygonOutlineGeometry}\n */\nCoplanarPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions\n    }\n  };\n  return new CoplanarPolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCoplanarPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex, Cartesian3);\n  array[startingIndex] = value.packedLength;\n  return array;\n};\nconst scratchOptions = {\n  polygonHierarchy: {}\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n */\nCoplanarPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex, Cartesian3);\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  const packedLength = array[startingIndex];\n  if (!defined(result)) {\n    result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n  }\n  result._polygonHierarchy = polygonHierarchy;\n  result.packedLength = packedLength;\n  return result;\n};\n\n/**\n * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCoplanarPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  let outerPositions = polygonHierarchy.positions;\n  outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n  if (outerPositions.length < 3) {\n    return;\n  }\n  const isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n  if (!isValid) {\n    return undefined;\n  }\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, false);\n  if (polygons.length === 0) {\n    return undefined;\n  }\n  const geometries = [];\n  for (let i = 0; i < polygons.length; i++) {\n    const geometryInstance = new GeometryInstance({\n      geometry: createGeometryFromPositions(polygons[i])\n    });\n    geometries.push(geometryInstance);\n  }\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere\n  });\n};\nexport default CoplanarPolygonOutlineGeometry;","map":{"version":3,"names":["arrayRemoveDuplicates","BoundingSphere","Cartesian3","Check","ComponentDatatype","CoplanarPolygonGeometryLibrary","defaultValue","defined","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryPipeline","IndexDatatype","PolygonGeometryLibrary","PrimitiveType","createGeometryFromPositions","positions","length","flatPositions","Float64Array","indices","createTypedArray","positionIndex","index","i","position","x","y","z","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","LINES","CoplanarPolygonOutlineGeometry","options","EMPTY_OBJECT","polygonHierarchy","_polygonHierarchy","_workerName","packedLength","computeHierarchyPackedLength","fromPositions","newOptions","pack","value","array","startingIndex","typeOf","object","packPolygonHierarchy","scratchOptions","unpack","result","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","equalsEpsilon","isValid","validOutline","undefined","polygons","polygonOutlinesFromHierarchy","geometries","geometryInstance","geometry","push","combineInstances","boundingSphere","fromPoints"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CoplanarPolygonOutlineGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CoplanarPolygonGeometryLibrary from \"./CoplanarPolygonGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nfunction createGeometryFromPositions(positions) {\n  const length = positions.length;\n  const flatPositions = new Float64Array(length * 3);\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n\n  let positionIndex = 0;\n  let index = 0;\n\n  for (let i = 0; i < length; i++) {\n    const position = positions[i];\n    flatPositions[positionIndex++] = position.x;\n    flatPositions[positionIndex++] = position.y;\n    flatPositions[positionIndex++] = position.z;\n\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: flatPositions,\n    }),\n  });\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n  });\n}\n\n/**\n * A description of the outline of a polygon composed of arbitrary coplanar positions.\n *\n * @alias CoplanarPolygonOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n *\n * @see CoplanarPolygonOutlineGeometry.createGeometry\n *\n * @example\n * const polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n *      -90.0, 30.0, 0.0,\n *      -90.0, 30.0, 1000.0,\n *      -80.0, 30.0, 1000.0,\n *      -80.0, 30.0, 0.0\n *   ])\n * });\n * const geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n */\nfunction CoplanarPolygonOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const polygonHierarchy = options.polygonHierarchy;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.polygonHierarchy\", polygonHierarchy);\n  //>>includeEnd('debug');\n\n  this._polygonHierarchy = polygonHierarchy;\n  this._workerName = \"createCoplanarPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) + 1;\n}\n\n/**\n * A description of a coplanar polygon outline from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @returns {CoplanarPolygonOutlineGeometry}\n */\nCoplanarPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n  };\n  return new CoplanarPolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCoplanarPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nconst scratchOptions = {\n  polygonHierarchy: {},\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n */\nCoplanarPolygonOutlineGeometry.unpack = function (\n  array,\n  startingIndex,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  const packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCoplanarPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n\n  let outerPositions = polygonHierarchy.positions;\n  outerPositions = arrayRemoveDuplicates(\n    outerPositions,\n    Cartesian3.equalsEpsilon,\n    true,\n  );\n  if (outerPositions.length < 3) {\n    return;\n  }\n  const isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n  if (!isValid) {\n    return undefined;\n  }\n\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    false,\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  const geometries = [];\n\n  for (let i = 0; i < polygons.length; i++) {\n    const geometryInstance = new GeometryInstance({\n      geometry: createGeometryFromPositions(polygons[i]),\n    });\n    geometries.push(geometryInstance);\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n  });\n};\nexport default CoplanarPolygonOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}