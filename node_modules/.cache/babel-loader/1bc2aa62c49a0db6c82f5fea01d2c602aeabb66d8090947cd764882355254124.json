{"ast":null,"code":"import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * Reads a string from a Uint8Array.\n *\n * @function\n *\n * @param {Uint8Array} uint8Array The Uint8Array to read from.\n * @param {number} [byteOffset=0] The byte offset to start reading from.\n * @param {number} [byteLength] The byte length to read. If byteLength is omitted the remainder of the buffer is read.\n * @returns {string} The string.\n *\n * @private\n */\nfunction getStringFromTypedArray(uint8Array, byteOffset, byteLength) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uint8Array)) {\n    throw new DeveloperError(\"uint8Array is required.\");\n  }\n  if (byteOffset < 0) {\n    throw new DeveloperError(\"byteOffset cannot be negative.\");\n  }\n  if (byteLength < 0) {\n    throw new DeveloperError(\"byteLength cannot be negative.\");\n  }\n  if (byteOffset + byteLength > uint8Array.byteLength) {\n    throw new DeveloperError(\"sub-region exceeds array bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = defaultValue(byteOffset, 0);\n  byteLength = defaultValue(byteLength, uint8Array.byteLength - byteOffset);\n  uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);\n  return getStringFromTypedArray.decode(uint8Array);\n}\n\n// Exposed functions for testing\ngetStringFromTypedArray.decodeWithTextDecoder = function (view) {\n  const decoder = new TextDecoder(\"utf-8\");\n  return decoder.decode(view);\n};\ngetStringFromTypedArray.decodeWithFromCharCode = function (view) {\n  let result = \"\";\n  const codePoints = utf8Handler(view);\n  const length = codePoints.length;\n  for (let i = 0; i < length; ++i) {\n    let cp = codePoints[i];\n    if (cp <= 0xffff) {\n      result += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return result;\n};\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n// This code is inspired by public domain code found here: https://github.com/inexorabletash/text-encoding\nfunction utf8Handler(utfBytes) {\n  let codePoint = 0;\n  let bytesSeen = 0;\n  let bytesNeeded = 0;\n  let lowerBoundary = 0x80;\n  let upperBoundary = 0xbf;\n  const codePoints = [];\n  const length = utfBytes.length;\n  for (let i = 0; i < length; ++i) {\n    const currentByte = utfBytes[i];\n\n    // If bytesNeeded = 0, then we are starting a new character\n    if (bytesNeeded === 0) {\n      // 1 Byte Ascii character\n      if (inRange(currentByte, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        codePoints.push(currentByte);\n        continue;\n      }\n\n      // 2 Byte character\n      if (inRange(currentByte, 0xc2, 0xdf)) {\n        bytesNeeded = 1;\n        codePoint = currentByte & 0x1f;\n        continue;\n      }\n\n      // 3 Byte character\n      if (inRange(currentByte, 0xe0, 0xef)) {\n        // If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (currentByte === 0xe0) {\n          lowerBoundary = 0xa0;\n        }\n        // If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (currentByte === 0xed) {\n          upperBoundary = 0x9f;\n        }\n        bytesNeeded = 2;\n        codePoint = currentByte & 0xf;\n        continue;\n      }\n\n      // 4 Byte character\n      if (inRange(currentByte, 0xf0, 0xf4)) {\n        // If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (currentByte === 0xf0) {\n          lowerBoundary = 0x90;\n        }\n        // If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (currentByte === 0xf4) {\n          upperBoundary = 0x8f;\n        }\n        bytesNeeded = 3;\n        codePoint = currentByte & 0x7;\n        continue;\n      }\n      throw new RuntimeError(\"String decoding failed.\");\n    }\n\n    // Out of range, so ignore the first part(s) of the character and continue with this byte on its own\n    if (!inRange(currentByte, lowerBoundary, upperBoundary)) {\n      codePoint = bytesNeeded = bytesSeen = 0;\n      lowerBoundary = 0x80;\n      upperBoundary = 0xbf;\n      --i;\n      continue;\n    }\n\n    // Set appropriate boundaries, since we've now checked byte 2 of a potential longer character\n    lowerBoundary = 0x80;\n    upperBoundary = 0xbf;\n\n    // Add byte to code point\n    codePoint = codePoint << 6 | currentByte & 0x3f;\n\n    // We have the correct number of bytes, so push and reset for next character\n    ++bytesSeen;\n    if (bytesSeen === bytesNeeded) {\n      codePoints.push(codePoint);\n      codePoint = bytesNeeded = bytesSeen = 0;\n    }\n  }\n  return codePoints;\n}\nif (typeof TextDecoder !== \"undefined\") {\n  getStringFromTypedArray.decode = getStringFromTypedArray.decodeWithTextDecoder;\n} else {\n  getStringFromTypedArray.decode = getStringFromTypedArray.decodeWithFromCharCode;\n}\nexport default getStringFromTypedArray;","map":{"version":3,"names":["defaultValue","defined","DeveloperError","RuntimeError","getStringFromTypedArray","uint8Array","byteOffset","byteLength","subarray","decode","decodeWithTextDecoder","view","decoder","TextDecoder","decodeWithFromCharCode","result","codePoints","utf8Handler","length","i","cp","String","fromCharCode","inRange","a","min","max","utfBytes","codePoint","bytesSeen","bytesNeeded","lowerBoundary","upperBoundary","currentByte","push"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/getStringFromTypedArray.js"],"sourcesContent":["import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * Reads a string from a Uint8Array.\n *\n * @function\n *\n * @param {Uint8Array} uint8Array The Uint8Array to read from.\n * @param {number} [byteOffset=0] The byte offset to start reading from.\n * @param {number} [byteLength] The byte length to read. If byteLength is omitted the remainder of the buffer is read.\n * @returns {string} The string.\n *\n * @private\n */\nfunction getStringFromTypedArray(uint8Array, byteOffset, byteLength) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uint8Array)) {\n    throw new DeveloperError(\"uint8Array is required.\");\n  }\n  if (byteOffset < 0) {\n    throw new DeveloperError(\"byteOffset cannot be negative.\");\n  }\n  if (byteLength < 0) {\n    throw new DeveloperError(\"byteLength cannot be negative.\");\n  }\n  if (byteOffset + byteLength > uint8Array.byteLength) {\n    throw new DeveloperError(\"sub-region exceeds array bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  byteOffset = defaultValue(byteOffset, 0);\n  byteLength = defaultValue(byteLength, uint8Array.byteLength - byteOffset);\n\n  uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);\n\n  return getStringFromTypedArray.decode(uint8Array);\n}\n\n// Exposed functions for testing\ngetStringFromTypedArray.decodeWithTextDecoder = function (view) {\n  const decoder = new TextDecoder(\"utf-8\");\n  return decoder.decode(view);\n};\n\ngetStringFromTypedArray.decodeWithFromCharCode = function (view) {\n  let result = \"\";\n  const codePoints = utf8Handler(view);\n  const length = codePoints.length;\n  for (let i = 0; i < length; ++i) {\n    let cp = codePoints[i];\n    if (cp <= 0xffff) {\n      result += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return result;\n};\n\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n// This code is inspired by public domain code found here: https://github.com/inexorabletash/text-encoding\nfunction utf8Handler(utfBytes) {\n  let codePoint = 0;\n  let bytesSeen = 0;\n  let bytesNeeded = 0;\n  let lowerBoundary = 0x80;\n  let upperBoundary = 0xbf;\n\n  const codePoints = [];\n  const length = utfBytes.length;\n  for (let i = 0; i < length; ++i) {\n    const currentByte = utfBytes[i];\n\n    // If bytesNeeded = 0, then we are starting a new character\n    if (bytesNeeded === 0) {\n      // 1 Byte Ascii character\n      if (inRange(currentByte, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        codePoints.push(currentByte);\n        continue;\n      }\n\n      // 2 Byte character\n      if (inRange(currentByte, 0xc2, 0xdf)) {\n        bytesNeeded = 1;\n        codePoint = currentByte & 0x1f;\n        continue;\n      }\n\n      // 3 Byte character\n      if (inRange(currentByte, 0xe0, 0xef)) {\n        // If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (currentByte === 0xe0) {\n          lowerBoundary = 0xa0;\n        }\n        // If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (currentByte === 0xed) {\n          upperBoundary = 0x9f;\n        }\n\n        bytesNeeded = 2;\n        codePoint = currentByte & 0xf;\n        continue;\n      }\n\n      // 4 Byte character\n      if (inRange(currentByte, 0xf0, 0xf4)) {\n        // If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (currentByte === 0xf0) {\n          lowerBoundary = 0x90;\n        }\n        // If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (currentByte === 0xf4) {\n          upperBoundary = 0x8f;\n        }\n\n        bytesNeeded = 3;\n        codePoint = currentByte & 0x7;\n        continue;\n      }\n\n      throw new RuntimeError(\"String decoding failed.\");\n    }\n\n    // Out of range, so ignore the first part(s) of the character and continue with this byte on its own\n    if (!inRange(currentByte, lowerBoundary, upperBoundary)) {\n      codePoint = bytesNeeded = bytesSeen = 0;\n      lowerBoundary = 0x80;\n      upperBoundary = 0xbf;\n      --i;\n      continue;\n    }\n\n    // Set appropriate boundaries, since we've now checked byte 2 of a potential longer character\n    lowerBoundary = 0x80;\n    upperBoundary = 0xbf;\n\n    // Add byte to code point\n    codePoint = (codePoint << 6) | (currentByte & 0x3f);\n\n    // We have the correct number of bytes, so push and reset for next character\n    ++bytesSeen;\n    if (bytesSeen === bytesNeeded) {\n      codePoints.push(codePoint);\n      codePoint = bytesNeeded = bytesSeen = 0;\n    }\n  }\n\n  return codePoints;\n}\n\nif (typeof TextDecoder !== \"undefined\") {\n  getStringFromTypedArray.decode =\n    getStringFromTypedArray.decodeWithTextDecoder;\n} else {\n  getStringFromTypedArray.decode =\n    getStringFromTypedArray.decodeWithFromCharCode;\n}\nexport default getStringFromTypedArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}