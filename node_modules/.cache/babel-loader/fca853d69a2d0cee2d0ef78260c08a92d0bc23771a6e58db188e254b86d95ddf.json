{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Renderbuffer from \"../Renderer/Renderbuffer.js\";\nimport RenderbufferFormat from \"../Renderer/RenderbufferFormat.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport Camera from \"./Camera.js\";\nimport CullFace from \"./CullFace.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport ShadowMapShader from \"./ShadowMapShader.js\";\n\n/**\n * <div class=\"notice\">\n * Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.\n * </div>\n *\n * <p>\n * The normalOffset bias pushes the shadows forward slightly, and may be disabled\n * for applications that require ultra precise shadows.\n * </p>\n *\n * @alias ShadowMap\n * @internalConstructor\n * @class\n *\n * @privateParam {object} options An object containing the following properties:\n * @privateParam {Context} options.context The context\n * @privateParam {Camera} options.lightCamera A camera representing the light source.\n * @privateParam {boolean} [options.enabled=true] Whether the shadow map is enabled.\n * @privateParam {boolean} [options.isPointLight=false] Whether the light source is a point light. Point light shadows do not use cascades.\n * @privateParam {number} [options.pointLightRadius=100.0] Radius of the point light.\n * @privateParam {boolean} [options.cascadesEnabled=true] Use multiple shadow maps to cover different partitions of the view frustum.\n * @privateParam {number} [options.numberOfCascades=4] The number of cascades to use for the shadow map. Supported values are one and four.\n * @privateParam {number} [options.maximumDistance=5000.0] The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.\n * @privateParam {number} [options.size=2048] The width and height, in pixels, of each shadow map.\n * @privateParam {boolean} [options.softShadows=false] Whether percentage-closer-filtering is enabled for producing softer shadows.\n * @privateParam {number} [options.darkness=0.3] The shadow darkness.\n * @privateParam {boolean} [options.normalOffset=true] Whether a normal bias is applied to shadows.\n * @privateParam {boolean} [options.fadingEnabled=true] Whether shadows start to fade out once the light gets closer to the horizon.\n *\n * @exception {DeveloperError} Only one or four cascades are supported.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Shadows.html|Cesium Sandcastle Shadows Demo}\n */\nfunction ShadowMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const context = options.context;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (!defined(options.lightCamera)) {\n    throw new DeveloperError(\"lightCamera is required.\");\n  }\n  if (defined(options.numberOfCascades) && options.numberOfCascades !== 1 && options.numberOfCascades !== 4) {\n    throw new DeveloperError(\"Only one or four cascades are supported.\");\n  }\n  //>>includeEnd('debug');\n\n  this._enabled = defaultValue(options.enabled, true);\n  this._softShadows = defaultValue(options.softShadows, false);\n  this._normalOffset = defaultValue(options.normalOffset, true);\n  this.dirty = true;\n\n  /**\n   * Specifies whether the shadow map originates from a light source. Shadow maps that are used for analytical\n   * purposes should set this to false so as not to affect scene rendering.\n   *\n   * @private\n   */\n  this.fromLightSource = defaultValue(options.fromLightSource, true);\n\n  /**\n   * Determines the darkness of the shadows.\n   *\n   * @type {number}\n   * @default 0.3\n   */\n  this.darkness = defaultValue(options.darkness, 0.3);\n  this._darkness = this.darkness;\n\n  /**\n   * Determines whether shadows start to fade out once the light gets closer to the horizon.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.fadingEnabled = defaultValue(options.fadingEnabled, true);\n\n  /**\n   * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.\n   *\n   * @type {number}\n   * @default 5000.0\n   */\n  this.maximumDistance = defaultValue(options.maximumDistance, 5000.0);\n  this._outOfView = false;\n  this._outOfViewPrevious = false;\n  this._needsUpdate = true;\n\n  // In IE11 and Edge polygon offset is not functional.\n  // TODO : Also disabled for instances of Firefox and Chrome running ANGLE that do not support depth textures.\n  // Re-enable once https://github.com/CesiumGS/cesium/issues/4560 is resolved.\n  let polygonOffsetSupported = true;\n  if (FeatureDetection.isInternetExplorer() || FeatureDetection.isEdge() || (FeatureDetection.isChrome() || FeatureDetection.isFirefox()) && FeatureDetection.isWindows() && !context.depthTexture) {\n    polygonOffsetSupported = false;\n  }\n  this._polygonOffsetSupported = polygonOffsetSupported;\n  this._terrainBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.5,\n    normalShading: true,\n    normalShadingSmooth: 0.3,\n    depthBias: 0.0001\n  };\n  this._primitiveBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.1,\n    normalShading: true,\n    normalShadingSmooth: 0.05,\n    depthBias: 0.00002\n  };\n  this._pointBias = {\n    polygonOffset: false,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.0,\n    normalShading: true,\n    normalShadingSmooth: 0.1,\n    depthBias: 0.0005\n  };\n\n  // Framebuffer resources\n  this._depthAttachment = undefined;\n  this._colorAttachment = undefined;\n\n  // Uniforms\n  this._shadowMapMatrix = new Matrix4();\n  this._shadowMapTexture = undefined;\n  this._lightDirectionEC = new Cartesian3();\n  this._lightPositionEC = new Cartesian4();\n  this._distance = 0.0;\n  this._lightCamera = options.lightCamera;\n  this._shadowMapCamera = new ShadowMapCamera();\n  this._shadowMapCullingVolume = undefined;\n  this._sceneCamera = undefined;\n  this._boundingSphere = new BoundingSphere();\n  this._isPointLight = defaultValue(options.isPointLight, false);\n  this._pointLightRadius = defaultValue(options.pointLightRadius, 100.0);\n  this._cascadesEnabled = this._isPointLight ? false : defaultValue(options.cascadesEnabled, true);\n  this._numberOfCascades = !this._cascadesEnabled ? 0 : defaultValue(options.numberOfCascades, 4);\n  this._fitNearFar = true;\n  this._maximumCascadeDistances = [25.0, 150.0, 700.0, Number.MAX_VALUE];\n  this._textureSize = new Cartesian2();\n  this._isSpotLight = false;\n  if (this._cascadesEnabled) {\n    // Cascaded shadows are always orthographic. The frustum dimensions are calculated on the fly.\n    this._shadowMapCamera.frustum = new OrthographicOffCenterFrustum();\n  } else if (defined(this._lightCamera.frustum.fov)) {\n    // If the light camera uses a perspective frustum, then the light source is a spot light\n    this._isSpotLight = true;\n  }\n\n  // Uniforms\n  this._cascadeSplits = [new Cartesian4(), new Cartesian4()];\n  this._cascadeMatrices = [new Matrix4(), new Matrix4(), new Matrix4(), new Matrix4()];\n  this._cascadeDistances = new Cartesian4();\n  let numberOfPasses;\n  if (this._isPointLight) {\n    numberOfPasses = 6; // One shadow map for each direction\n  } else if (!this._cascadesEnabled) {\n    numberOfPasses = 1;\n  } else {\n    numberOfPasses = this._numberOfCascades;\n  }\n  this._passes = new Array(numberOfPasses);\n  for (let i = 0; i < numberOfPasses; ++i) {\n    this._passes[i] = new ShadowPass(context);\n  }\n  this.debugShow = false;\n  this.debugFreezeFrame = false;\n  this._debugFreezeFrame = false;\n  this._debugCascadeColors = false;\n  this._debugLightFrustum = undefined;\n  this._debugCameraFrustum = undefined;\n  this._debugCascadeFrustums = new Array(this._numberOfCascades);\n  this._debugShadowViewCommand = undefined;\n  this._usesDepthTexture = context.depthTexture;\n  if (this._isPointLight) {\n    this._usesDepthTexture = false;\n  }\n\n  // Create render states for shadow casters\n  this._primitiveRenderState = undefined;\n  this._terrainRenderState = undefined;\n  this._pointRenderState = undefined;\n  createRenderStates(this);\n\n  // For clearing the shadow map texture every frame\n  this._clearCommand = new ClearCommand({\n    depth: 1.0,\n    color: new Color()\n  });\n  this._clearPassState = new PassState(context);\n  this._size = defaultValue(options.size, 2048);\n  this.size = this._size;\n}\n\n/**\n * Global maximum shadow distance used to prevent far off receivers from extending\n * the shadow far plane. This helps set a tighter near/far when viewing objects from space.\n *\n * @private\n */\nShadowMap.MAXIMUM_DISTANCE = 20000.0;\nfunction ShadowPass(context) {\n  this.camera = new ShadowMapCamera();\n  this.passState = new PassState(context);\n  this.framebuffer = undefined;\n  this.textureOffsets = undefined;\n  this.commandList = [];\n  this.cullingVolume = undefined;\n}\nfunction createRenderState(colorMask, bias) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK\n    },\n    depthTest: {\n      enabled: true\n    },\n    colorMask: {\n      red: colorMask,\n      green: colorMask,\n      blue: colorMask,\n      alpha: colorMask\n    },\n    depthMask: true,\n    polygonOffset: {\n      enabled: bias.polygonOffset,\n      factor: bias.polygonOffsetFactor,\n      units: bias.polygonOffsetUnits\n    }\n  });\n}\nfunction createRenderStates(shadowMap) {\n  // Enable the color mask if the shadow map is backed by a color texture, e.g. when depth textures aren't supported\n  const colorMask = !shadowMap._usesDepthTexture;\n  shadowMap._primitiveRenderState = createRenderState(colorMask, shadowMap._primitiveBias);\n  shadowMap._terrainRenderState = createRenderState(colorMask, shadowMap._terrainBias);\n  shadowMap._pointRenderState = createRenderState(colorMask, shadowMap._pointBias);\n}\n\n/**\n * @private\n */\nShadowMap.prototype.debugCreateRenderStates = function () {\n  createRenderStates(this);\n};\nObject.defineProperties(ShadowMap.prototype, {\n  /**\n   * Determines if the shadow map will be shown.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this.dirty = this._enabled !== value;\n      this._enabled = value;\n    }\n  },\n  /**\n   * Determines if a normal bias will be applied to shadows.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default true\n   */\n  normalOffset: {\n    get: function () {\n      return this._normalOffset;\n    },\n    set: function (value) {\n      this.dirty = this._normalOffset !== value;\n      this._normalOffset = value;\n      this._terrainBias.normalOffset = value;\n      this._primitiveBias.normalOffset = value;\n      this._pointBias.normalOffset = value;\n    }\n  },\n  /**\n   * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default false\n   */\n  softShadows: {\n    get: function () {\n      return this._softShadows;\n    },\n    set: function (value) {\n      this.dirty = this._softShadows !== value;\n      this._softShadows = value;\n    }\n  },\n  /**\n   * The width and height, in pixels, of each shadow map.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {number}\n   * @default 2048\n   */\n  size: {\n    get: function () {\n      return this._size;\n    },\n    set: function (value) {\n      resize(this, value);\n    }\n  },\n  /**\n   * Whether the shadow map is out of view of the scene camera.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  outOfView: {\n    get: function () {\n      return this._outOfView;\n    }\n  },\n  /**\n   * The culling volume of the shadow frustum.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {CullingVolume}\n   * @readonly\n   * @private\n   */\n  shadowMapCullingVolume: {\n    get: function () {\n      return this._shadowMapCullingVolume;\n    }\n  },\n  /**\n   * The passes used for rendering shadows. Each face of a point light or each cascade for a cascaded shadow map is a separate pass.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {ShadowPass[]}\n   * @readonly\n   * @private\n   */\n  passes: {\n    get: function () {\n      return this._passes;\n    }\n  },\n  /**\n   * Whether the light source is a point light.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  isPointLight: {\n    get: function () {\n      return this._isPointLight;\n    }\n  },\n  /**\n   * Debug option for visualizing the cascades by color.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  debugCascadeColors: {\n    get: function () {\n      return this._debugCascadeColors;\n    },\n    set: function (value) {\n      this.dirty = this._debugCascadeColors !== value;\n      this._debugCascadeColors = value;\n    }\n  }\n});\nfunction destroyFramebuffer(shadowMap) {\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    const framebuffer = pass.framebuffer;\n    if (defined(framebuffer) && !framebuffer.isDestroyed()) {\n      framebuffer.destroy();\n    }\n    pass.framebuffer = undefined;\n  }\n\n  // Destroy the framebuffer attachments\n  shadowMap._depthAttachment = shadowMap._depthAttachment && shadowMap._depthAttachment.destroy();\n  shadowMap._colorAttachment = shadowMap._colorAttachment && shadowMap._colorAttachment.destroy();\n}\nfunction createFramebufferColor(shadowMap, context) {\n  const depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16\n  });\n  const colorTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST\n  });\n  const framebuffer = new Framebuffer({\n    context: context,\n    depthRenderbuffer: depthRenderbuffer,\n    colorTextures: [colorTexture],\n    destroyAttachments: false\n  });\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n  shadowMap._shadowMapTexture = colorTexture;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = colorTexture;\n}\nfunction createFramebufferDepth(shadowMap, context) {\n  const depthStencilTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.DEPTH_STENCIL,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n    sampler: Sampler.NEAREST\n  });\n  const framebuffer = new Framebuffer({\n    context: context,\n    depthStencilTexture: depthStencilTexture,\n    destroyAttachments: false\n  });\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n  shadowMap._shadowMapTexture = depthStencilTexture;\n  shadowMap._depthAttachment = depthStencilTexture;\n}\nfunction createFramebufferCube(shadowMap, context) {\n  const depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16\n  });\n  const cubeMap = new CubeMap({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST\n  });\n  const faces = [cubeMap.negativeX, cubeMap.negativeY, cubeMap.negativeZ, cubeMap.positiveX, cubeMap.positiveY, cubeMap.positiveZ];\n  for (let i = 0; i < 6; ++i) {\n    const framebuffer = new Framebuffer({\n      context: context,\n      depthRenderbuffer: depthRenderbuffer,\n      colorTextures: [faces[i]],\n      destroyAttachments: false\n    });\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n  shadowMap._shadowMapTexture = cubeMap;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = cubeMap;\n}\nfunction createFramebuffer(shadowMap, context) {\n  if (shadowMap._isPointLight) {\n    createFramebufferCube(shadowMap, context);\n  } else if (shadowMap._usesDepthTexture) {\n    createFramebufferDepth(shadowMap, context);\n  } else {\n    createFramebufferColor(shadowMap, context);\n  }\n}\nfunction checkFramebuffer(shadowMap, context) {\n  // Attempt to make an FBO with only a depth texture. If it fails, fallback to a color texture.\n  if (shadowMap._usesDepthTexture && shadowMap._passes[0].framebuffer.status !== WebGLConstants.FRAMEBUFFER_COMPLETE) {\n    shadowMap._usesDepthTexture = false;\n    createRenderStates(shadowMap);\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n  }\n}\nfunction updateFramebuffer(shadowMap, context) {\n  if (!defined(shadowMap._passes[0].framebuffer) || shadowMap._shadowMapTexture.width !== shadowMap._textureSize.x) {\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n    checkFramebuffer(shadowMap, context);\n    clearFramebuffer(shadowMap, context);\n  }\n}\nfunction clearFramebuffer(shadowMap, context, shadowPass) {\n  shadowPass = defaultValue(shadowPass, 0);\n  if (shadowMap._isPointLight || shadowPass === 0) {\n    shadowMap._clearCommand.framebuffer = shadowMap._passes[shadowPass].framebuffer;\n    shadowMap._clearCommand.execute(context, shadowMap._clearPassState);\n  }\n}\nfunction resize(shadowMap, size) {\n  shadowMap._size = size;\n  const passes = shadowMap._passes;\n  const numberOfPasses = passes.length;\n  const textureSize = shadowMap._textureSize;\n  if (shadowMap._isPointLight) {\n    size = ContextLimits.maximumCubeMapSize >= size ? size : ContextLimits.maximumCubeMapSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    const faceViewport = new BoundingRectangle(0, 0, size, size);\n    passes[0].passState.viewport = faceViewport;\n    passes[1].passState.viewport = faceViewport;\n    passes[2].passState.viewport = faceViewport;\n    passes[3].passState.viewport = faceViewport;\n    passes[4].passState.viewport = faceViewport;\n    passes[5].passState.viewport = faceViewport;\n  } else if (numberOfPasses === 1) {\n    // +----+\n    // |  1 |\n    // +----+\n    size = ContextLimits.maximumTextureSize >= size ? size : ContextLimits.maximumTextureSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n  } else if (numberOfPasses === 4) {\n    // +----+----+\n    // |  3 |  4 |\n    // +----+----+\n    // |  1 |  2 |\n    // +----+----+\n    size = ContextLimits.maximumTextureSize >= size * 2 ? size : ContextLimits.maximumTextureSize / 2;\n    textureSize.x = size * 2;\n    textureSize.y = size * 2;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n    passes[1].passState.viewport = new BoundingRectangle(size, 0, size, size);\n    passes[2].passState.viewport = new BoundingRectangle(0, size, size, size);\n    passes[3].passState.viewport = new BoundingRectangle(size, size, size, size);\n  }\n\n  // Update clear pass state\n  shadowMap._clearPassState.viewport = new BoundingRectangle(0, 0, textureSize.x, textureSize.y);\n\n  // Transforms shadow coordinates [0, 1] into the pass's region of the texture\n  for (let i = 0; i < numberOfPasses; ++i) {\n    const pass = passes[i];\n    const viewport = pass.passState.viewport;\n    const biasX = viewport.x / textureSize.x;\n    const biasY = viewport.y / textureSize.y;\n    const scaleX = viewport.width / textureSize.x;\n    const scaleY = viewport.height / textureSize.y;\n    pass.textureOffsets = new Matrix4(scaleX, 0.0, 0.0, biasX, 0.0, scaleY, 0.0, biasY, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  }\n}\nconst scratchViewport = new BoundingRectangle();\nfunction createDebugShadowViewCommand(shadowMap, context) {\n  let fs;\n  if (shadowMap._isPointLight) {\n    fs = \"uniform samplerCube shadowMap_textureCube; \\n\" + \"in vec2 v_textureCoordinates; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 uv = v_textureCoordinates; \\n\" + \"    vec3 dir; \\n\" + \" \\n\" + \"    if (uv.y < 0.5) \\n\" + \"    { \\n\" + \"        if (uv.x < 0.333) \\n\" + \"        { \\n\" + \"            dir.x = -1.0; \\n\" + \"            dir.y = uv.x * 6.0 - 1.0; \\n\" + \"            dir.z = uv.y * 4.0 - 1.0; \\n\" + \"        } \\n\" + \"        else if (uv.x < 0.666) \\n\" + \"        { \\n\" + \"            dir.y = -1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 3.0; \\n\" + \"            dir.z = uv.y * 4.0 - 1.0; \\n\" + \"        } \\n\" + \"        else \\n\" + \"        { \\n\" + \"            dir.z = -1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 5.0; \\n\" + \"            dir.y = uv.y * 4.0 - 1.0; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        if (uv.x < 0.333) \\n\" + \"        { \\n\" + \"            dir.x = 1.0; \\n\" + \"            dir.y = uv.x * 6.0 - 1.0; \\n\" + \"            dir.z = uv.y * 4.0 - 3.0; \\n\" + \"        } \\n\" + \"        else if (uv.x < 0.666) \\n\" + \"        { \\n\" + \"            dir.y = 1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 3.0; \\n\" + \"            dir.z = uv.y * 4.0 - 3.0; \\n\" + \"        } \\n\" + \"        else \\n\" + \"        { \\n\" + \"            dir.z = 1.0; \\n\" + \"            dir.x = uv.x * 6.0 - 5.0; \\n\" + \"            dir.y = uv.y * 4.0 - 3.0; \\n\" + \"        } \\n\" + \"    } \\n\" + \" \\n\" + \"    float shadow = czm_unpackDepth(czm_textureCube(shadowMap_textureCube, dir)); \\n\" + \"    out_FragColor = vec4(vec3(shadow), 1.0); \\n\" + \"} \\n\";\n  } else {\n    fs = `${\"uniform sampler2D shadowMap_texture; \\n\" + \"in vec2 v_textureCoordinates; \\n\" + \"void main() \\n\" + \"{ \\n\"}${shadowMap._usesDepthTexture ? \"    float shadow = texture(shadowMap_texture, v_textureCoordinates).r; \\n\" : \"    float shadow = czm_unpackDepth(texture(shadowMap_texture, v_textureCoordinates)); \\n\"}    out_FragColor = vec4(vec3(shadow), 1.0); \\n` + `} \\n`;\n  }\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      shadowMap_texture: function () {\n        return shadowMap._shadowMapTexture;\n      },\n      shadowMap_textureCube: function () {\n        return shadowMap._shadowMapTexture;\n      }\n    }\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\nfunction updateDebugShadowViewCommand(shadowMap, frameState) {\n  // Draws the shadow map on the bottom-right corner of the screen\n  const context = frameState.context;\n  const screenWidth = frameState.context.drawingBufferWidth;\n  const screenHeight = frameState.context.drawingBufferHeight;\n  const size = Math.min(screenWidth, screenHeight) * 0.3;\n  const viewport = scratchViewport;\n  viewport.x = screenWidth - size;\n  viewport.y = 0;\n  viewport.width = size;\n  viewport.height = size;\n  let debugCommand = shadowMap._debugShadowViewCommand;\n  if (!defined(debugCommand)) {\n    debugCommand = createDebugShadowViewCommand(shadowMap, context);\n    shadowMap._debugShadowViewCommand = debugCommand;\n  }\n\n  // Get a new RenderState for the updated viewport size\n  if (!defined(debugCommand.renderState) || !BoundingRectangle.equals(debugCommand.renderState.viewport, viewport)) {\n    debugCommand.renderState = RenderState.fromCache({\n      viewport: BoundingRectangle.clone(viewport)\n    });\n  }\n  frameState.commandList.push(shadowMap._debugShadowViewCommand);\n}\nconst frustumCornersNDC = new Array(8);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[4] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[5] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[6] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[7] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\nconst scratchMatrix = new Matrix4();\nconst scratchFrustumCorners = new Array(8);\nfor (let i = 0; i < 8; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\nfunction createDebugPointLight(modelMatrix, color) {\n  const box = new GeometryInstance({\n    geometry: new BoxOutlineGeometry({\n      minimum: new Cartesian3(-0.5, -0.5, -0.5),\n      maximum: new Cartesian3(0.5, 0.5, 0.5)\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  const sphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 0.5\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: [box, sphere],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false,\n    modelMatrix: modelMatrix\n  });\n}\nconst debugOutlineColors = [Color.RED, Color.GREEN, Color.BLUE, Color.MAGENTA];\nconst scratchScale = new Cartesian3();\nfunction applyDebugSettings(shadowMap, frameState) {\n  updateDebugShadowViewCommand(shadowMap, frameState);\n  const enterFreezeFrame = shadowMap.debugFreezeFrame && !shadowMap._debugFreezeFrame;\n  shadowMap._debugFreezeFrame = shadowMap.debugFreezeFrame;\n\n  // Draw scene camera in freeze frame mode\n  if (shadowMap.debugFreezeFrame) {\n    if (enterFreezeFrame) {\n      // Recreate debug camera when entering freeze frame mode\n      shadowMap._debugCameraFrustum = shadowMap._debugCameraFrustum && shadowMap._debugCameraFrustum.destroy();\n      shadowMap._debugCameraFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._sceneCamera,\n        color: Color.CYAN,\n        updateOnChange: false\n      });\n    }\n    shadowMap._debugCameraFrustum.update(frameState);\n  }\n  if (shadowMap._cascadesEnabled) {\n    // Draw cascades only in freeze frame mode\n    if (shadowMap.debugFreezeFrame) {\n      if (enterFreezeFrame) {\n        // Recreate debug frustum when entering freeze frame mode\n        shadowMap._debugLightFrustum = shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n        shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n          camera: shadowMap._shadowMapCamera,\n          color: Color.YELLOW,\n          updateOnChange: false\n        });\n      }\n      shadowMap._debugLightFrustum.update(frameState);\n      for (let i = 0; i < shadowMap._numberOfCascades; ++i) {\n        if (enterFreezeFrame) {\n          // Recreate debug frustum when entering freeze frame mode\n          shadowMap._debugCascadeFrustums[i] = shadowMap._debugCascadeFrustums[i] && shadowMap._debugCascadeFrustums[i].destroy();\n          shadowMap._debugCascadeFrustums[i] = new DebugCameraPrimitive({\n            camera: shadowMap._passes[i].camera,\n            color: debugOutlineColors[i],\n            updateOnChange: false\n          });\n        }\n        shadowMap._debugCascadeFrustums[i].update(frameState);\n      }\n    }\n  } else if (shadowMap._isPointLight) {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      const translation = shadowMap._shadowMapCamera.positionWC;\n      const rotation = Quaternion.IDENTITY;\n      const uniformScale = shadowMap._pointLightRadius * 2.0;\n      const scale = Cartesian3.fromElements(uniformScale, uniformScale, uniformScale, scratchScale);\n      const modelMatrix = Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, scratchMatrix);\n      shadowMap._debugLightFrustum = shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n      shadowMap._debugLightFrustum = createDebugPointLight(modelMatrix, Color.YELLOW);\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  } else {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._shadowMapCamera,\n        color: Color.YELLOW,\n        updateOnChange: false\n      });\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  }\n}\nfunction ShadowMapCamera() {\n  this.viewMatrix = new Matrix4();\n  this.inverseViewMatrix = new Matrix4();\n  this.frustum = undefined;\n  this.positionCartographic = new Cartographic();\n  this.positionWC = new Cartesian3();\n  this.directionWC = Cartesian3.clone(Cartesian3.UNIT_Z);\n  this.upWC = Cartesian3.clone(Cartesian3.UNIT_Y);\n  this.rightWC = Cartesian3.clone(Cartesian3.UNIT_X);\n  this.viewProjectionMatrix = new Matrix4();\n}\nShadowMapCamera.prototype.clone = function (camera) {\n  Matrix4.clone(camera.viewMatrix, this.viewMatrix);\n  Matrix4.clone(camera.inverseViewMatrix, this.inverseViewMatrix);\n  this.frustum = camera.frustum.clone(this.frustum);\n  Cartographic.clone(camera.positionCartographic, this.positionCartographic);\n  Cartesian3.clone(camera.positionWC, this.positionWC);\n  Cartesian3.clone(camera.directionWC, this.directionWC);\n  Cartesian3.clone(camera.upWC, this.upWC);\n  Cartesian3.clone(camera.rightWC, this.rightWC);\n};\n\n// Converts from NDC space to texture space\nconst scaleBiasMatrix = new Matrix4(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\nShadowMapCamera.prototype.getViewProjection = function () {\n  const view = this.viewMatrix;\n  const projection = this.frustum.projectionMatrix;\n  Matrix4.multiply(projection, view, this.viewProjectionMatrix);\n  Matrix4.multiply(scaleBiasMatrix, this.viewProjectionMatrix, this.viewProjectionMatrix);\n  return this.viewProjectionMatrix;\n};\nconst scratchSplits = new Array(5);\nconst scratchFrustum = new PerspectiveFrustum();\nconst scratchCascadeDistances = new Array(4);\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nfunction computeCascades(shadowMap, frameState) {\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const sceneCamera = shadowMap._sceneCamera;\n  const cameraNear = sceneCamera.frustum.near;\n  const cameraFar = sceneCamera.frustum.far;\n  const numberOfCascades = shadowMap._numberOfCascades;\n\n  // Split cascades. Use a mix of linear and log splits.\n  let i;\n  const range = cameraFar - cameraNear;\n  const ratio = cameraFar / cameraNear;\n  let lambda = 0.9;\n  let clampCascadeDistances = false;\n\n  // When the camera is close to a relatively small model, provide more detail in the closer cascades.\n  // If the camera is near or inside a large model, such as the root tile of a city, then use the default values.\n  // To get the most accurate cascade splits we would need to find the min and max values from the depth texture.\n  if (frameState.shadowState.closestObjectSize < 200.0) {\n    clampCascadeDistances = true;\n    lambda = 0.9;\n  }\n  const cascadeDistances = scratchCascadeDistances;\n  const splits = scratchSplits;\n  splits[0] = cameraNear;\n  splits[numberOfCascades] = cameraFar;\n\n  // Find initial splits\n  for (i = 0; i < numberOfCascades; ++i) {\n    const p = (i + 1) / numberOfCascades;\n    const logScale = cameraNear * Math.pow(ratio, p);\n    const uniformScale = cameraNear + range * p;\n    const split = CesiumMath.lerp(uniformScale, logScale, lambda);\n    splits[i + 1] = split;\n    cascadeDistances[i] = split - splits[i];\n  }\n  if (clampCascadeDistances) {\n    // Clamp each cascade to its maximum distance\n    for (i = 0; i < numberOfCascades; ++i) {\n      cascadeDistances[i] = Math.min(cascadeDistances[i], shadowMap._maximumCascadeDistances[i]);\n    }\n\n    // Recompute splits\n    let distance = splits[0];\n    for (i = 0; i < numberOfCascades - 1; ++i) {\n      distance += cascadeDistances[i];\n      splits[i + 1] = distance;\n    }\n  }\n  Cartesian4.unpack(splits, 0, shadowMap._cascadeSplits[0]);\n  Cartesian4.unpack(splits, 1, shadowMap._cascadeSplits[1]);\n  Cartesian4.unpack(cascadeDistances, 0, shadowMap._cascadeDistances);\n  const shadowFrustum = shadowMapCamera.frustum;\n  const left = shadowFrustum.left;\n  const right = shadowFrustum.right;\n  const bottom = shadowFrustum.bottom;\n  const top = shadowFrustum.top;\n  const near = shadowFrustum.near;\n  const far = shadowFrustum.far;\n  const position = shadowMapCamera.positionWC;\n  const direction = shadowMapCamera.directionWC;\n  const up = shadowMapCamera.upWC;\n  const cascadeSubFrustum = sceneCamera.frustum.clone(scratchFrustum);\n  const shadowViewProjection = shadowMapCamera.getViewProjection();\n  for (i = 0; i < numberOfCascades; ++i) {\n    // Find the bounding box of the camera sub-frustum in shadow map texture space\n    cascadeSubFrustum.near = splits[i];\n    cascadeSubFrustum.far = splits[i + 1];\n    const viewProjection = Matrix4.multiply(cascadeSubFrustum.projectionMatrix, sceneCamera.viewMatrix, scratchMatrix);\n    const inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n    const shadowMapMatrix = Matrix4.multiply(shadowViewProjection, inverseViewProjection, scratchMatrix);\n\n    // Project each corner from camera NDC space to shadow map texture space. Min and max will be from 0 to 1.\n    const min = Cartesian3.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, scratchMin);\n    const max = Cartesian3.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, scratchMax);\n    for (let k = 0; k < 8; ++k) {\n      const corner = Cartesian4.clone(frustumCornersNDC[k], scratchFrustumCorners[k]);\n      Matrix4.multiplyByVector(shadowMapMatrix, corner, corner);\n      Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n      Cartesian3.minimumByComponent(corner, min, min);\n      Cartesian3.maximumByComponent(corner, max, max);\n    }\n\n    // Limit light-space coordinates to the [0, 1] range\n    min.x = Math.max(min.x, 0.0);\n    min.y = Math.max(min.y, 0.0);\n    min.z = 0.0; // Always start cascade frustum at the top of the light frustum to capture objects in the light's path\n    max.x = Math.min(max.x, 1.0);\n    max.y = Math.min(max.y, 1.0);\n    max.z = Math.min(max.z, 1.0);\n    const pass = shadowMap._passes[i];\n    const cascadeCamera = pass.camera;\n    cascadeCamera.clone(shadowMapCamera); // PERFORMANCE_IDEA : could do a shallow clone for all properties except the frustum\n\n    const frustum = cascadeCamera.frustum;\n    frustum.left = left + min.x * (right - left);\n    frustum.right = left + max.x * (right - left);\n    frustum.bottom = bottom + min.y * (top - bottom);\n    frustum.top = bottom + max.y * (top - bottom);\n    frustum.near = near + min.z * (far - near);\n    frustum.far = near + max.z * (far - near);\n    pass.cullingVolume = cascadeCamera.frustum.computeCullingVolume(position, direction, up);\n\n    // Transforms from eye space to the cascade's texture space\n    const cascadeMatrix = shadowMap._cascadeMatrices[i];\n    Matrix4.multiply(cascadeCamera.getViewProjection(), sceneCamera.inverseViewMatrix, cascadeMatrix);\n    Matrix4.multiply(pass.textureOffsets, cascadeMatrix, cascadeMatrix);\n  }\n}\nconst scratchLightView = new Matrix4();\nconst scratchRight = new Cartesian3();\nconst scratchUp = new Cartesian3();\nconst scratchTranslation = new Cartesian3();\nfunction fitShadowMapToScene(shadowMap, frameState) {\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const sceneCamera = shadowMap._sceneCamera;\n\n  // 1. First find a tight bounding box in light space that contains the entire camera frustum.\n  const viewProjection = Matrix4.multiply(sceneCamera.frustum.projectionMatrix, sceneCamera.viewMatrix, scratchMatrix);\n  const inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n\n  // Start to construct the light view matrix. Set translation later once the bounding box is found.\n  const lightDir = shadowMapCamera.directionWC;\n  let lightUp = sceneCamera.directionWC; // Align shadows to the camera view.\n  if (Cartesian3.equalsEpsilon(lightDir, lightUp, CesiumMath.EPSILON10)) {\n    lightUp = sceneCamera.upWC;\n  }\n  const lightRight = Cartesian3.cross(lightDir, lightUp, scratchRight);\n  lightUp = Cartesian3.cross(lightRight, lightDir, scratchUp); // Recalculate up now that right is derived\n  Cartesian3.normalize(lightUp, lightUp);\n  Cartesian3.normalize(lightRight, lightRight);\n  const lightPosition = Cartesian3.fromElements(0.0, 0.0, 0.0, scratchTranslation);\n  let lightView = Matrix4.computeView(lightPosition, lightDir, lightUp, lightRight, scratchLightView);\n  const cameraToLight = Matrix4.multiply(lightView, inverseViewProjection, scratchMatrix);\n\n  // Project each corner from NDC space to light view space, and calculate a min and max in light view space\n  const min = Cartesian3.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, scratchMin);\n  const max = Cartesian3.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, scratchMax);\n  for (let i = 0; i < 8; ++i) {\n    const corner = Cartesian4.clone(frustumCornersNDC[i], scratchFrustumCorners[i]);\n    Matrix4.multiplyByVector(cameraToLight, corner, corner);\n    Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n    Cartesian3.minimumByComponent(corner, min, min);\n    Cartesian3.maximumByComponent(corner, max, max);\n  }\n\n  // 2. Set bounding box back to include objects in the light's view\n  max.z += 1000.0; // Note: in light space, a positive number is behind the camera\n  min.z -= 10.0; // Extend the shadow volume forward slightly to avoid problems right at the edge\n\n  // 3. Adjust light view matrix so that it is centered on the bounding volume\n  const translation = scratchTranslation;\n  translation.x = -(0.5 * (min.x + max.x));\n  translation.y = -(0.5 * (min.y + max.y));\n  translation.z = -max.z;\n  const translationMatrix = Matrix4.fromTranslation(translation, scratchMatrix);\n  lightView = Matrix4.multiply(translationMatrix, lightView, lightView);\n\n  // 4. Create an orthographic frustum that covers the bounding box extents\n  const halfWidth = 0.5 * (max.x - min.x);\n  const halfHeight = 0.5 * (max.y - min.y);\n  const depth = max.z - min.z;\n  const frustum = shadowMapCamera.frustum;\n  frustum.left = -halfWidth;\n  frustum.right = halfWidth;\n  frustum.bottom = -halfHeight;\n  frustum.top = halfHeight;\n  frustum.near = 0.01;\n  frustum.far = depth;\n\n  // 5. Update the shadow map camera\n  Matrix4.clone(lightView, shadowMapCamera.viewMatrix);\n  Matrix4.inverse(lightView, shadowMapCamera.inverseViewMatrix);\n  Matrix4.getTranslation(shadowMapCamera.inverseViewMatrix, shadowMapCamera.positionWC);\n  frameState.mapProjection.ellipsoid.cartesianToCartographic(shadowMapCamera.positionWC, shadowMapCamera.positionCartographic);\n  Cartesian3.clone(lightDir, shadowMapCamera.directionWC);\n  Cartesian3.clone(lightUp, shadowMapCamera.upWC);\n  Cartesian3.clone(lightRight, shadowMapCamera.rightWC);\n}\nconst directions = [new Cartesian3(-1.0, 0.0, 0.0), new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, 0.0, -1.0), new Cartesian3(1.0, 0.0, 0.0), new Cartesian3(0.0, 1.0, 0.0), new Cartesian3(0.0, 0.0, 1.0)];\nconst ups = [new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, 0.0, -1.0), new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, -1.0, 0.0), new Cartesian3(0.0, 0.0, 1.0), new Cartesian3(0.0, -1.0, 0.0)];\nconst rights = [new Cartesian3(0.0, 0.0, 1.0), new Cartesian3(1.0, 0.0, 0.0), new Cartesian3(-1.0, 0.0, 0.0), new Cartesian3(0.0, 0.0, -1.0), new Cartesian3(1.0, 0.0, 0.0), new Cartesian3(1.0, 0.0, 0.0)];\nfunction computeOmnidirectional(shadowMap, frameState) {\n  // All sides share the same frustum\n  const frustum = new PerspectiveFrustum();\n  frustum.fov = CesiumMath.PI_OVER_TWO;\n  frustum.near = 1.0;\n  frustum.far = shadowMap._pointLightRadius;\n  frustum.aspectRatio = 1.0;\n  for (let i = 0; i < 6; ++i) {\n    const camera = shadowMap._passes[i].camera;\n    camera.positionWC = shadowMap._shadowMapCamera.positionWC;\n    camera.positionCartographic = frameState.mapProjection.ellipsoid.cartesianToCartographic(camera.positionWC, camera.positionCartographic);\n    camera.directionWC = directions[i];\n    camera.upWC = ups[i];\n    camera.rightWC = rights[i];\n    Matrix4.computeView(camera.positionWC, camera.directionWC, camera.upWC, camera.rightWC, camera.viewMatrix);\n    Matrix4.inverse(camera.viewMatrix, camera.inverseViewMatrix);\n    camera.frustum = frustum;\n  }\n}\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\nconst scratchCenter = scratchBoundingSphere.center;\nfunction checkVisibility(shadowMap, frameState) {\n  const sceneCamera = shadowMap._sceneCamera;\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const boundingSphere = scratchBoundingSphere;\n\n  // Check whether the shadow map is in view and needs to be updated\n  if (shadowMap._cascadesEnabled) {\n    // If the nearest shadow receiver is further than the shadow map's maximum distance then the shadow map is out of view.\n    if (sceneCamera.frustum.near >= shadowMap.maximumDistance) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // If the light source is below the horizon then the shadow map is out of view\n    const surfaceNormal = frameState.mapProjection.ellipsoid.geodeticSurfaceNormal(sceneCamera.positionWC, scratchCartesian1);\n    const lightDirection = Cartesian3.negate(shadowMapCamera.directionWC, scratchCartesian2);\n    const dot = Cartesian3.dot(surfaceNormal, lightDirection);\n    if (shadowMap.fadingEnabled) {\n      // Shadows start to fade out once the light gets closer to the horizon.\n      // At this point the globe uses vertex lighting alone to darken the surface.\n      const darknessAmount = CesiumMath.clamp(dot / 0.1, 0.0, 1.0);\n      shadowMap._darkness = CesiumMath.lerp(1.0, shadowMap.darkness, darknessAmount);\n    } else {\n      shadowMap._darkness = shadowMap.darkness;\n    }\n    if (dot < 0.0) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // By default cascaded shadows need to update and are always in view\n    shadowMap._needsUpdate = true;\n    shadowMap._outOfView = false;\n  } else if (shadowMap._isPointLight) {\n    // Sphere-frustum intersection test\n    boundingSphere.center = shadowMapCamera.positionWC;\n    boundingSphere.radius = shadowMap._pointLightRadius;\n    shadowMap._outOfView = frameState.cullingVolume.computeVisibility(boundingSphere) === Intersect.OUTSIDE;\n    shadowMap._needsUpdate = !shadowMap._outOfView && !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  } else {\n    // Simplify frustum-frustum intersection test as a sphere-frustum test\n    const frustumRadius = shadowMapCamera.frustum.far / 2.0;\n    const frustumCenter = Cartesian3.add(shadowMapCamera.positionWC, Cartesian3.multiplyByScalar(shadowMapCamera.directionWC, frustumRadius, scratchCenter), scratchCenter);\n    boundingSphere.center = frustumCenter;\n    boundingSphere.radius = frustumRadius;\n    shadowMap._outOfView = frameState.cullingVolume.computeVisibility(boundingSphere) === Intersect.OUTSIDE;\n    shadowMap._needsUpdate = !shadowMap._outOfView && !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  }\n}\nfunction updateCameras(shadowMap, frameState) {\n  const camera = frameState.camera; // The actual camera in the scene\n  const lightCamera = shadowMap._lightCamera; // The external camera representing the light source\n  const sceneCamera = shadowMap._sceneCamera; // Clone of camera, with clamped near and far planes\n  const shadowMapCamera = shadowMap._shadowMapCamera; // Camera representing the shadow volume, initially cloned from lightCamera\n\n  // Clone light camera into the shadow map camera\n  if (shadowMap._cascadesEnabled) {\n    Cartesian3.clone(lightCamera.directionWC, shadowMapCamera.directionWC);\n  } else if (shadowMap._isPointLight) {\n    Cartesian3.clone(lightCamera.positionWC, shadowMapCamera.positionWC);\n  } else {\n    shadowMapCamera.clone(lightCamera);\n  }\n\n  // Get the light direction in eye coordinates\n  const lightDirection = shadowMap._lightDirectionEC;\n  Matrix4.multiplyByPointAsVector(camera.viewMatrix, shadowMapCamera.directionWC, lightDirection);\n  Cartesian3.normalize(lightDirection, lightDirection);\n  Cartesian3.negate(lightDirection, lightDirection);\n\n  // Get the light position in eye coordinates\n  Matrix4.multiplyByPoint(camera.viewMatrix, shadowMapCamera.positionWC, shadowMap._lightPositionEC);\n  shadowMap._lightPositionEC.w = shadowMap._pointLightRadius;\n\n  // Get the near and far of the scene camera\n  let near;\n  let far;\n  if (shadowMap._fitNearFar) {\n    // shadowFar can be very large, so limit to shadowMap.maximumDistance\n    // Push the far plane slightly further than the near plane to avoid degenerate frustum\n    near = Math.min(frameState.shadowState.nearPlane, shadowMap.maximumDistance);\n    far = Math.min(frameState.shadowState.farPlane, shadowMap.maximumDistance);\n    far = Math.max(far, near + 1.0);\n  } else {\n    near = camera.frustum.near;\n    far = shadowMap.maximumDistance;\n  }\n  shadowMap._sceneCamera = Camera.clone(camera, sceneCamera);\n  camera.frustum.clone(shadowMap._sceneCamera.frustum);\n  shadowMap._sceneCamera.frustum.near = near;\n  shadowMap._sceneCamera.frustum.far = far;\n  shadowMap._distance = far - near;\n  checkVisibility(shadowMap, frameState);\n  if (!shadowMap._outOfViewPrevious && shadowMap._outOfView) {\n    shadowMap._needsUpdate = true;\n  }\n  shadowMap._outOfViewPrevious = shadowMap._outOfView;\n}\n\n/**\n * @private\n */\nShadowMap.prototype.update = function (frameState) {\n  updateCameras(this, frameState);\n  if (this._needsUpdate) {\n    updateFramebuffer(this, frameState.context);\n    if (this._isPointLight) {\n      computeOmnidirectional(this, frameState);\n    }\n    if (this._cascadesEnabled) {\n      fitShadowMapToScene(this, frameState);\n      if (this._numberOfCascades > 1) {\n        computeCascades(this, frameState);\n      }\n    }\n    if (!this._isPointLight) {\n      // Compute the culling volume\n      const shadowMapCamera = this._shadowMapCamera;\n      const position = shadowMapCamera.positionWC;\n      const direction = shadowMapCamera.directionWC;\n      const up = shadowMapCamera.upWC;\n      this._shadowMapCullingVolume = shadowMapCamera.frustum.computeCullingVolume(position, direction, up);\n      if (this._passes.length === 1) {\n        // Since there is only one pass, use the shadow map camera as the pass camera.\n        this._passes[0].camera.clone(shadowMapCamera);\n      }\n    } else {\n      this._shadowMapCullingVolume = CullingVolume.fromBoundingSphere(this._boundingSphere);\n    }\n  }\n  if (this._passes.length === 1) {\n    // Transforms from eye space to shadow texture space.\n    // Always requires an update since the scene camera constantly changes.\n    const inverseView = this._sceneCamera.inverseViewMatrix;\n    Matrix4.multiply(this._shadowMapCamera.getViewProjection(), inverseView, this._shadowMapMatrix);\n  }\n  if (this.debugShow) {\n    applyDebugSettings(this, frameState);\n  }\n};\n\n/**\n * @private\n */\nShadowMap.prototype.updatePass = function (context, shadowPass) {\n  clearFramebuffer(this, context, shadowPass);\n};\nconst scratchTexelStepSize = new Cartesian2();\nfunction combineUniforms(shadowMap, uniforms, isTerrain) {\n  const bias = shadowMap._isPointLight ? shadowMap._pointBias : isTerrain ? shadowMap._terrainBias : shadowMap._primitiveBias;\n  const mapUniforms = {\n    shadowMap_texture: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_textureCube: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_matrix: function () {\n      return shadowMap._shadowMapMatrix;\n    },\n    shadowMap_cascadeSplits: function () {\n      return shadowMap._cascadeSplits;\n    },\n    shadowMap_cascadeMatrices: function () {\n      return shadowMap._cascadeMatrices;\n    },\n    shadowMap_lightDirectionEC: function () {\n      return shadowMap._lightDirectionEC;\n    },\n    shadowMap_lightPositionEC: function () {\n      return shadowMap._lightPositionEC;\n    },\n    shadowMap_cascadeDistances: function () {\n      return shadowMap._cascadeDistances;\n    },\n    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function () {\n      const texelStepSize = scratchTexelStepSize;\n      texelStepSize.x = 1.0 / shadowMap._textureSize.x;\n      texelStepSize.y = 1.0 / shadowMap._textureSize.y;\n      return Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);\n    },\n    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function () {\n      return Cartesian4.fromElements(bias.normalOffsetScale, shadowMap._distance, shadowMap.maximumDistance, shadowMap._darkness, this.combinedUniforms2);\n    },\n    combinedUniforms1: new Cartesian4(),\n    combinedUniforms2: new Cartesian4()\n  };\n  return combine(uniforms, mapUniforms, false);\n}\nfunction createCastDerivedCommand(shadowMap, shadowsDirty, command, context, oldShaderId, result) {\n  let castShader;\n  let castRenderState;\n  let castUniformMap;\n  if (defined(result)) {\n    castShader = result.shaderProgram;\n    castRenderState = result.renderState;\n    castUniformMap = result.uniformMap;\n  }\n  result = DrawCommand.shallowClone(command, result);\n  result.castShadows = true;\n  result.receiveShadows = false;\n  if (!defined(castShader) || oldShaderId !== command.shaderProgram.id || shadowsDirty) {\n    const shaderProgram = command.shaderProgram;\n    const isTerrain = command.pass === Pass.GLOBE;\n    const isOpaque = command.pass !== Pass.TRANSLUCENT;\n    const isPointLight = shadowMap._isPointLight;\n    const usesDepthTexture = shadowMap._usesDepthTexture;\n    const keyword = ShadowMapShader.getShadowCastShaderKeyword(isPointLight, isTerrain, usesDepthTexture, isOpaque);\n    castShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n    if (!defined(castShader)) {\n      const vertexShaderSource = shaderProgram.vertexShaderSource;\n      const fragmentShaderSource = shaderProgram.fragmentShaderSource;\n      const castVS = ShadowMapShader.createShadowCastVertexShader(vertexShaderSource, isPointLight, isTerrain);\n      const castFS = ShadowMapShader.createShadowCastFragmentShader(fragmentShaderSource, isPointLight, usesDepthTexture, isOpaque);\n      castShader = context.shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n        vertexShaderSource: castVS,\n        fragmentShaderSource: castFS,\n        attributeLocations: shaderProgram._attributeLocations\n      });\n    }\n    castRenderState = shadowMap._primitiveRenderState;\n    if (isPointLight) {\n      castRenderState = shadowMap._pointRenderState;\n    } else if (isTerrain) {\n      castRenderState = shadowMap._terrainRenderState;\n    }\n\n    // Modify the render state for commands that do not use back-face culling, e.g. flat textured walls\n    const cullEnabled = command.renderState.cull.enabled;\n    if (!cullEnabled) {\n      castRenderState = clone(castRenderState, false);\n      castRenderState.cull = clone(castRenderState.cull, false);\n      castRenderState.cull.enabled = false;\n      castRenderState = RenderState.fromCache(castRenderState);\n    }\n    castUniformMap = combineUniforms(shadowMap, command.uniformMap, isTerrain);\n  }\n  result.shaderProgram = castShader;\n  result.renderState = castRenderState;\n  result.uniformMap = castUniformMap;\n  return result;\n}\nShadowMap.createReceiveDerivedCommand = function (lightShadowMaps, command, shadowsDirty, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  const lightShadowMapsEnabled = lightShadowMaps.length > 0;\n  const shaderProgram = command.shaderProgram;\n  const vertexShaderSource = shaderProgram.vertexShaderSource;\n  const fragmentShaderSource = shaderProgram.fragmentShaderSource;\n  const isTerrain = command.pass === Pass.GLOBE;\n  let hasTerrainNormal = false;\n  if (isTerrain) {\n    hasTerrainNormal = command.owner.data.renderedMesh.encoding.hasVertexNormals;\n  }\n  if (command.receiveShadows && lightShadowMapsEnabled) {\n    // Only generate a receiveCommand if there is a shadow map originating from a light source.\n    let receiveShader;\n    let receiveUniformMap;\n    if (defined(result.receiveCommand)) {\n      receiveShader = result.receiveCommand.shaderProgram;\n      receiveUniformMap = result.receiveCommand.uniformMap;\n    }\n    result.receiveCommand = DrawCommand.shallowClone(command, result.receiveCommand);\n    result.castShadows = false;\n    result.receiveShadows = true;\n\n    // If castShadows changed, recompile the receive shadows shader. The normal shading technique simulates\n    // self-shadowing so it should be turned off if castShadows is false.\n    const castShadowsDirty = result.receiveShaderCastShadows !== command.castShadows;\n    const shaderDirty = result.receiveShaderProgramId !== command.shaderProgram.id;\n    if (!defined(receiveShader) || shaderDirty || shadowsDirty || castShadowsDirty) {\n      const keyword = ShadowMapShader.getShadowReceiveShaderKeyword(lightShadowMaps[0], command.castShadows, isTerrain, hasTerrainNormal);\n      receiveShader = context.shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n      if (!defined(receiveShader)) {\n        const receiveVS = ShadowMapShader.createShadowReceiveVertexShader(vertexShaderSource, isTerrain, hasTerrainNormal);\n        const receiveFS = ShadowMapShader.createShadowReceiveFragmentShader(fragmentShaderSource, lightShadowMaps[0], command.castShadows, isTerrain, hasTerrainNormal);\n        receiveShader = context.shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n          vertexShaderSource: receiveVS,\n          fragmentShaderSource: receiveFS,\n          attributeLocations: shaderProgram._attributeLocations\n        });\n      }\n      receiveUniformMap = combineUniforms(lightShadowMaps[0], command.uniformMap, isTerrain);\n    }\n    result.receiveCommand.shaderProgram = receiveShader;\n    result.receiveCommand.uniformMap = receiveUniformMap;\n    result.receiveShaderProgramId = command.shaderProgram.id;\n    result.receiveShaderCastShadows = command.castShadows;\n  }\n  return result;\n};\nShadowMap.createCastDerivedCommand = function (shadowMaps, command, shadowsDirty, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  if (command.castShadows) {\n    let castCommands = result.castCommands;\n    if (!defined(castCommands)) {\n      castCommands = result.castCommands = [];\n    }\n    const oldShaderId = result.castShaderProgramId;\n    const shadowMapLength = shadowMaps.length;\n    castCommands.length = shadowMapLength;\n    for (let i = 0; i < shadowMapLength; ++i) {\n      castCommands[i] = createCastDerivedCommand(shadowMaps[i], shadowsDirty, command, context, oldShaderId, castCommands[i]);\n    }\n    result.castShaderProgramId = command.shaderProgram.id;\n  }\n  return result;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.destroy = function () {\n  destroyFramebuffer(this);\n  this._debugLightFrustum = this._debugLightFrustum && this._debugLightFrustum.destroy();\n  this._debugCameraFrustum = this._debugCameraFrustum && this._debugCameraFrustum.destroy();\n  this._debugShadowViewCommand = this._debugShadowViewCommand && this._debugShadowViewCommand.shaderProgram && this._debugShadowViewCommand.shaderProgram.destroy();\n  for (let i = 0; i < this._numberOfCascades; ++i) {\n    this._debugCascadeFrustums[i] = this._debugCascadeFrustums[i] && this._debugCascadeFrustums[i].destroy();\n  }\n  return destroyObject(this);\n};\nexport default ShadowMap;","map":{"version":3,"names":["BoundingRectangle","BoundingSphere","BoxOutlineGeometry","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","ColorGeometryInstanceAttribute","combine","CullingVolume","defaultValue","defined","destroyObject","DeveloperError","FeatureDetection","GeometryInstance","Intersect","CesiumMath","Matrix4","OrthographicOffCenterFrustum","PerspectiveFrustum","PixelFormat","Quaternion","SphereOutlineGeometry","WebGLConstants","ClearCommand","ContextLimits","CubeMap","DrawCommand","Framebuffer","Pass","PassState","PixelDatatype","Renderbuffer","RenderbufferFormat","RenderState","Sampler","Texture","Camera","CullFace","DebugCameraPrimitive","PerInstanceColorAppearance","Primitive","ShadowMapShader","ShadowMap","options","EMPTY_OBJECT","context","lightCamera","numberOfCascades","_enabled","enabled","_softShadows","softShadows","_normalOffset","normalOffset","dirty","fromLightSource","darkness","_darkness","fadingEnabled","maximumDistance","_outOfView","_outOfViewPrevious","_needsUpdate","polygonOffsetSupported","isInternetExplorer","isEdge","isChrome","isFirefox","isWindows","depthTexture","_polygonOffsetSupported","_terrainBias","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","normalOffsetScale","normalShading","normalShadingSmooth","depthBias","_primitiveBias","_pointBias","_depthAttachment","undefined","_colorAttachment","_shadowMapMatrix","_shadowMapTexture","_lightDirectionEC","_lightPositionEC","_distance","_lightCamera","_shadowMapCamera","ShadowMapCamera","_shadowMapCullingVolume","_sceneCamera","_boundingSphere","_isPointLight","isPointLight","_pointLightRadius","pointLightRadius","_cascadesEnabled","cascadesEnabled","_numberOfCascades","_fitNearFar","_maximumCascadeDistances","Number","MAX_VALUE","_textureSize","_isSpotLight","frustum","fov","_cascadeSplits","_cascadeMatrices","_cascadeDistances","numberOfPasses","_passes","Array","i","ShadowPass","debugShow","debugFreezeFrame","_debugFreezeFrame","_debugCascadeColors","_debugLightFrustum","_debugCameraFrustum","_debugCascadeFrustums","_debugShadowViewCommand","_usesDepthTexture","_primitiveRenderState","_terrainRenderState","_pointRenderState","createRenderStates","_clearCommand","depth","color","_clearPassState","_size","size","MAXIMUM_DISTANCE","camera","passState","framebuffer","textureOffsets","commandList","cullingVolume","createRenderState","colorMask","bias","fromCache","cull","face","BACK","depthTest","red","green","blue","alpha","depthMask","factor","units","shadowMap","prototype","debugCreateRenderStates","Object","defineProperties","get","set","value","resize","outOfView","shadowMapCullingVolume","passes","debugCascadeColors","destroyFramebuffer","length","pass","isDestroyed","destroy","createFramebufferColor","depthRenderbuffer","width","x","height","y","format","DEPTH_COMPONENT16","colorTexture","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","sampler","NEAREST","colorTextures","destroyAttachments","createFramebufferDepth","depthStencilTexture","DEPTH_STENCIL","UNSIGNED_INT_24_8","createFramebufferCube","cubeMap","faces","negativeX","negativeY","negativeZ","positiveX","positiveY","positiveZ","createFramebuffer","checkFramebuffer","status","FRAMEBUFFER_COMPLETE","updateFramebuffer","clearFramebuffer","shadowPass","execute","textureSize","maximumCubeMapSize","faceViewport","viewport","maximumTextureSize","biasX","biasY","scaleX","scaleY","scratchViewport","createDebugShadowViewCommand","fs","drawCommand","createViewportQuadCommand","uniformMap","shadowMap_texture","shadowMap_textureCube","OVERLAY","updateDebugShadowViewCommand","frameState","screenWidth","drawingBufferWidth","screenHeight","drawingBufferHeight","Math","min","debugCommand","renderState","equals","push","frustumCornersNDC","scratchMatrix","scratchFrustumCorners","createDebugPointLight","modelMatrix","box","geometry","minimum","maximum","attributes","fromColor","sphere","radius","geometryInstances","appearance","translucent","flat","asynchronous","debugOutlineColors","RED","GREEN","BLUE","MAGENTA","scratchScale","applyDebugSettings","enterFreezeFrame","CYAN","updateOnChange","update","YELLOW","translation","positionWC","rotation","IDENTITY","uniformScale","scale","fromElements","fromTranslationQuaternionRotationScale","viewMatrix","inverseViewMatrix","positionCartographic","directionWC","UNIT_Z","upWC","UNIT_Y","rightWC","UNIT_X","viewProjectionMatrix","scaleBiasMatrix","getViewProjection","view","projection","projectionMatrix","multiply","scratchSplits","scratchFrustum","scratchCascadeDistances","scratchMin","scratchMax","computeCascades","shadowMapCamera","sceneCamera","cameraNear","near","cameraFar","far","range","ratio","lambda","clampCascadeDistances","shadowState","closestObjectSize","cascadeDistances","splits","p","logScale","pow","split","lerp","distance","unpack","shadowFrustum","left","right","bottom","top","position","direction","up","cascadeSubFrustum","shadowViewProjection","viewProjection","inverseViewProjection","inverse","shadowMapMatrix","max","k","corner","multiplyByVector","divideByScalar","w","minimumByComponent","maximumByComponent","z","cascadeCamera","computeCullingVolume","cascadeMatrix","scratchLightView","scratchRight","scratchUp","scratchTranslation","fitShadowMapToScene","lightDir","lightUp","equalsEpsilon","EPSILON10","lightRight","cross","normalize","lightPosition","lightView","computeView","cameraToLight","translationMatrix","fromTranslation","halfWidth","halfHeight","getTranslation","mapProjection","ellipsoid","cartesianToCartographic","directions","ups","rights","computeOmnidirectional","PI_OVER_TWO","aspectRatio","scratchCartesian1","scratchCartesian2","scratchBoundingSphere","scratchCenter","center","checkVisibility","boundingSphere","surfaceNormal","geodeticSurfaceNormal","lightDirection","negate","dot","darknessAmount","clamp","computeVisibility","OUTSIDE","frustumRadius","frustumCenter","add","multiplyByScalar","updateCameras","multiplyByPointAsVector","multiplyByPoint","nearPlane","farPlane","fromBoundingSphere","inverseView","updatePass","scratchTexelStepSize","combineUniforms","uniforms","isTerrain","mapUniforms","shadowMap_matrix","shadowMap_cascadeSplits","shadowMap_cascadeMatrices","shadowMap_lightDirectionEC","shadowMap_lightPositionEC","shadowMap_cascadeDistances","shadowMap_texelSizeDepthBiasAndNormalShadingSmooth","texelStepSize","combinedUniforms1","shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness","combinedUniforms2","createCastDerivedCommand","shadowsDirty","command","oldShaderId","result","castShader","castRenderState","castUniformMap","shaderProgram","shallowClone","castShadows","receiveShadows","id","GLOBE","isOpaque","TRANSLUCENT","usesDepthTexture","keyword","getShadowCastShaderKeyword","shaderCache","getDerivedShaderProgram","vertexShaderSource","fragmentShaderSource","castVS","createShadowCastVertexShader","castFS","createShadowCastFragmentShader","createDerivedShaderProgram","attributeLocations","_attributeLocations","cullEnabled","createReceiveDerivedCommand","lightShadowMaps","lightShadowMapsEnabled","hasTerrainNormal","owner","data","renderedMesh","encoding","hasVertexNormals","receiveShader","receiveUniformMap","receiveCommand","castShadowsDirty","receiveShaderCastShadows","shaderDirty","receiveShaderProgramId","getShadowReceiveShaderKeyword","receiveVS","createShadowReceiveVertexShader","receiveFS","createShadowReceiveFragmentShader","shadowMaps","castCommands","castShaderProgramId","shadowMapLength"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ShadowMap.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Renderbuffer from \"../Renderer/Renderbuffer.js\";\nimport RenderbufferFormat from \"../Renderer/RenderbufferFormat.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport Camera from \"./Camera.js\";\nimport CullFace from \"./CullFace.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport ShadowMapShader from \"./ShadowMapShader.js\";\n\n/**\n * <div class=\"notice\">\n * Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.\n * </div>\n *\n * <p>\n * The normalOffset bias pushes the shadows forward slightly, and may be disabled\n * for applications that require ultra precise shadows.\n * </p>\n *\n * @alias ShadowMap\n * @internalConstructor\n * @class\n *\n * @privateParam {object} options An object containing the following properties:\n * @privateParam {Context} options.context The context\n * @privateParam {Camera} options.lightCamera A camera representing the light source.\n * @privateParam {boolean} [options.enabled=true] Whether the shadow map is enabled.\n * @privateParam {boolean} [options.isPointLight=false] Whether the light source is a point light. Point light shadows do not use cascades.\n * @privateParam {number} [options.pointLightRadius=100.0] Radius of the point light.\n * @privateParam {boolean} [options.cascadesEnabled=true] Use multiple shadow maps to cover different partitions of the view frustum.\n * @privateParam {number} [options.numberOfCascades=4] The number of cascades to use for the shadow map. Supported values are one and four.\n * @privateParam {number} [options.maximumDistance=5000.0] The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.\n * @privateParam {number} [options.size=2048] The width and height, in pixels, of each shadow map.\n * @privateParam {boolean} [options.softShadows=false] Whether percentage-closer-filtering is enabled for producing softer shadows.\n * @privateParam {number} [options.darkness=0.3] The shadow darkness.\n * @privateParam {boolean} [options.normalOffset=true] Whether a normal bias is applied to shadows.\n * @privateParam {boolean} [options.fadingEnabled=true] Whether shadows start to fade out once the light gets closer to the horizon.\n *\n * @exception {DeveloperError} Only one or four cascades are supported.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Shadows.html|Cesium Sandcastle Shadows Demo}\n */\nfunction ShadowMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const context = options.context;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (!defined(options.lightCamera)) {\n    throw new DeveloperError(\"lightCamera is required.\");\n  }\n  if (\n    defined(options.numberOfCascades) &&\n    options.numberOfCascades !== 1 &&\n    options.numberOfCascades !== 4\n  ) {\n    throw new DeveloperError(\"Only one or four cascades are supported.\");\n  }\n  //>>includeEnd('debug');\n\n  this._enabled = defaultValue(options.enabled, true);\n  this._softShadows = defaultValue(options.softShadows, false);\n  this._normalOffset = defaultValue(options.normalOffset, true);\n  this.dirty = true;\n\n  /**\n   * Specifies whether the shadow map originates from a light source. Shadow maps that are used for analytical\n   * purposes should set this to false so as not to affect scene rendering.\n   *\n   * @private\n   */\n  this.fromLightSource = defaultValue(options.fromLightSource, true);\n\n  /**\n   * Determines the darkness of the shadows.\n   *\n   * @type {number}\n   * @default 0.3\n   */\n  this.darkness = defaultValue(options.darkness, 0.3);\n  this._darkness = this.darkness;\n\n  /**\n   * Determines whether shadows start to fade out once the light gets closer to the horizon.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.fadingEnabled = defaultValue(options.fadingEnabled, true);\n\n  /**\n   * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.\n   *\n   * @type {number}\n   * @default 5000.0\n   */\n  this.maximumDistance = defaultValue(options.maximumDistance, 5000.0);\n\n  this._outOfView = false;\n  this._outOfViewPrevious = false;\n  this._needsUpdate = true;\n\n  // In IE11 and Edge polygon offset is not functional.\n  // TODO : Also disabled for instances of Firefox and Chrome running ANGLE that do not support depth textures.\n  // Re-enable once https://github.com/CesiumGS/cesium/issues/4560 is resolved.\n  let polygonOffsetSupported = true;\n  if (\n    FeatureDetection.isInternetExplorer() ||\n    FeatureDetection.isEdge() ||\n    ((FeatureDetection.isChrome() || FeatureDetection.isFirefox()) &&\n      FeatureDetection.isWindows() &&\n      !context.depthTexture)\n  ) {\n    polygonOffsetSupported = false;\n  }\n  this._polygonOffsetSupported = polygonOffsetSupported;\n\n  this._terrainBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.5,\n    normalShading: true,\n    normalShadingSmooth: 0.3,\n    depthBias: 0.0001,\n  };\n\n  this._primitiveBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.1,\n    normalShading: true,\n    normalShadingSmooth: 0.05,\n    depthBias: 0.00002,\n  };\n\n  this._pointBias = {\n    polygonOffset: false,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.0,\n    normalShading: true,\n    normalShadingSmooth: 0.1,\n    depthBias: 0.0005,\n  };\n\n  // Framebuffer resources\n  this._depthAttachment = undefined;\n  this._colorAttachment = undefined;\n\n  // Uniforms\n  this._shadowMapMatrix = new Matrix4();\n  this._shadowMapTexture = undefined;\n  this._lightDirectionEC = new Cartesian3();\n  this._lightPositionEC = new Cartesian4();\n  this._distance = 0.0;\n\n  this._lightCamera = options.lightCamera;\n  this._shadowMapCamera = new ShadowMapCamera();\n  this._shadowMapCullingVolume = undefined;\n  this._sceneCamera = undefined;\n  this._boundingSphere = new BoundingSphere();\n\n  this._isPointLight = defaultValue(options.isPointLight, false);\n  this._pointLightRadius = defaultValue(options.pointLightRadius, 100.0);\n\n  this._cascadesEnabled = this._isPointLight\n    ? false\n    : defaultValue(options.cascadesEnabled, true);\n  this._numberOfCascades = !this._cascadesEnabled\n    ? 0\n    : defaultValue(options.numberOfCascades, 4);\n  this._fitNearFar = true;\n  this._maximumCascadeDistances = [25.0, 150.0, 700.0, Number.MAX_VALUE];\n\n  this._textureSize = new Cartesian2();\n\n  this._isSpotLight = false;\n  if (this._cascadesEnabled) {\n    // Cascaded shadows are always orthographic. The frustum dimensions are calculated on the fly.\n    this._shadowMapCamera.frustum = new OrthographicOffCenterFrustum();\n  } else if (defined(this._lightCamera.frustum.fov)) {\n    // If the light camera uses a perspective frustum, then the light source is a spot light\n    this._isSpotLight = true;\n  }\n\n  // Uniforms\n  this._cascadeSplits = [new Cartesian4(), new Cartesian4()];\n  this._cascadeMatrices = [\n    new Matrix4(),\n    new Matrix4(),\n    new Matrix4(),\n    new Matrix4(),\n  ];\n  this._cascadeDistances = new Cartesian4();\n\n  let numberOfPasses;\n  if (this._isPointLight) {\n    numberOfPasses = 6; // One shadow map for each direction\n  } else if (!this._cascadesEnabled) {\n    numberOfPasses = 1;\n  } else {\n    numberOfPasses = this._numberOfCascades;\n  }\n\n  this._passes = new Array(numberOfPasses);\n  for (let i = 0; i < numberOfPasses; ++i) {\n    this._passes[i] = new ShadowPass(context);\n  }\n\n  this.debugShow = false;\n  this.debugFreezeFrame = false;\n  this._debugFreezeFrame = false;\n  this._debugCascadeColors = false;\n  this._debugLightFrustum = undefined;\n  this._debugCameraFrustum = undefined;\n  this._debugCascadeFrustums = new Array(this._numberOfCascades);\n  this._debugShadowViewCommand = undefined;\n\n  this._usesDepthTexture = context.depthTexture;\n\n  if (this._isPointLight) {\n    this._usesDepthTexture = false;\n  }\n\n  // Create render states for shadow casters\n  this._primitiveRenderState = undefined;\n  this._terrainRenderState = undefined;\n  this._pointRenderState = undefined;\n  createRenderStates(this);\n\n  // For clearing the shadow map texture every frame\n  this._clearCommand = new ClearCommand({\n    depth: 1.0,\n    color: new Color(),\n  });\n\n  this._clearPassState = new PassState(context);\n\n  this._size = defaultValue(options.size, 2048);\n  this.size = this._size;\n}\n\n/**\n * Global maximum shadow distance used to prevent far off receivers from extending\n * the shadow far plane. This helps set a tighter near/far when viewing objects from space.\n *\n * @private\n */\nShadowMap.MAXIMUM_DISTANCE = 20000.0;\n\nfunction ShadowPass(context) {\n  this.camera = new ShadowMapCamera();\n  this.passState = new PassState(context);\n  this.framebuffer = undefined;\n  this.textureOffsets = undefined;\n  this.commandList = [];\n  this.cullingVolume = undefined;\n}\n\nfunction createRenderState(colorMask, bias) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK,\n    },\n    depthTest: {\n      enabled: true,\n    },\n    colorMask: {\n      red: colorMask,\n      green: colorMask,\n      blue: colorMask,\n      alpha: colorMask,\n    },\n    depthMask: true,\n    polygonOffset: {\n      enabled: bias.polygonOffset,\n      factor: bias.polygonOffsetFactor,\n      units: bias.polygonOffsetUnits,\n    },\n  });\n}\n\nfunction createRenderStates(shadowMap) {\n  // Enable the color mask if the shadow map is backed by a color texture, e.g. when depth textures aren't supported\n  const colorMask = !shadowMap._usesDepthTexture;\n  shadowMap._primitiveRenderState = createRenderState(\n    colorMask,\n    shadowMap._primitiveBias,\n  );\n  shadowMap._terrainRenderState = createRenderState(\n    colorMask,\n    shadowMap._terrainBias,\n  );\n  shadowMap._pointRenderState = createRenderState(\n    colorMask,\n    shadowMap._pointBias,\n  );\n}\n\n/**\n * @private\n */\nShadowMap.prototype.debugCreateRenderStates = function () {\n  createRenderStates(this);\n};\n\nObject.defineProperties(ShadowMap.prototype, {\n  /**\n   * Determines if the shadow map will be shown.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this.dirty = this._enabled !== value;\n      this._enabled = value;\n    },\n  },\n\n  /**\n   * Determines if a normal bias will be applied to shadows.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default true\n   */\n  normalOffset: {\n    get: function () {\n      return this._normalOffset;\n    },\n    set: function (value) {\n      this.dirty = this._normalOffset !== value;\n      this._normalOffset = value;\n      this._terrainBias.normalOffset = value;\n      this._primitiveBias.normalOffset = value;\n      this._pointBias.normalOffset = value;\n    },\n  },\n\n  /**\n   * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default false\n   */\n  softShadows: {\n    get: function () {\n      return this._softShadows;\n    },\n    set: function (value) {\n      this.dirty = this._softShadows !== value;\n      this._softShadows = value;\n    },\n  },\n\n  /**\n   * The width and height, in pixels, of each shadow map.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {number}\n   * @default 2048\n   */\n  size: {\n    get: function () {\n      return this._size;\n    },\n    set: function (value) {\n      resize(this, value);\n    },\n  },\n\n  /**\n   * Whether the shadow map is out of view of the scene camera.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  outOfView: {\n    get: function () {\n      return this._outOfView;\n    },\n  },\n\n  /**\n   * The culling volume of the shadow frustum.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {CullingVolume}\n   * @readonly\n   * @private\n   */\n  shadowMapCullingVolume: {\n    get: function () {\n      return this._shadowMapCullingVolume;\n    },\n  },\n\n  /**\n   * The passes used for rendering shadows. Each face of a point light or each cascade for a cascaded shadow map is a separate pass.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {ShadowPass[]}\n   * @readonly\n   * @private\n   */\n  passes: {\n    get: function () {\n      return this._passes;\n    },\n  },\n\n  /**\n   * Whether the light source is a point light.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  isPointLight: {\n    get: function () {\n      return this._isPointLight;\n    },\n  },\n\n  /**\n   * Debug option for visualizing the cascades by color.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {boolean}\n   * @default false\n   * @private\n   */\n  debugCascadeColors: {\n    get: function () {\n      return this._debugCascadeColors;\n    },\n    set: function (value) {\n      this.dirty = this._debugCascadeColors !== value;\n      this._debugCascadeColors = value;\n    },\n  },\n});\n\nfunction destroyFramebuffer(shadowMap) {\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    const framebuffer = pass.framebuffer;\n    if (defined(framebuffer) && !framebuffer.isDestroyed()) {\n      framebuffer.destroy();\n    }\n    pass.framebuffer = undefined;\n  }\n\n  // Destroy the framebuffer attachments\n  shadowMap._depthAttachment =\n    shadowMap._depthAttachment && shadowMap._depthAttachment.destroy();\n  shadowMap._colorAttachment =\n    shadowMap._colorAttachment && shadowMap._colorAttachment.destroy();\n}\n\nfunction createFramebufferColor(shadowMap, context) {\n  const depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16,\n  });\n\n  const colorTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST,\n  });\n\n  const framebuffer = new Framebuffer({\n    context: context,\n    depthRenderbuffer: depthRenderbuffer,\n    colorTextures: [colorTexture],\n    destroyAttachments: false,\n  });\n\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = colorTexture;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = colorTexture;\n}\n\nfunction createFramebufferDepth(shadowMap, context) {\n  const depthStencilTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.DEPTH_STENCIL,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n    sampler: Sampler.NEAREST,\n  });\n\n  const framebuffer = new Framebuffer({\n    context: context,\n    depthStencilTexture: depthStencilTexture,\n    destroyAttachments: false,\n  });\n\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = depthStencilTexture;\n  shadowMap._depthAttachment = depthStencilTexture;\n}\n\nfunction createFramebufferCube(shadowMap, context) {\n  const depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16,\n  });\n\n  const cubeMap = new CubeMap({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST,\n  });\n\n  const faces = [\n    cubeMap.negativeX,\n    cubeMap.negativeY,\n    cubeMap.negativeZ,\n    cubeMap.positiveX,\n    cubeMap.positiveY,\n    cubeMap.positiveZ,\n  ];\n\n  for (let i = 0; i < 6; ++i) {\n    const framebuffer = new Framebuffer({\n      context: context,\n      depthRenderbuffer: depthRenderbuffer,\n      colorTextures: [faces[i]],\n      destroyAttachments: false,\n    });\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = cubeMap;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = cubeMap;\n}\n\nfunction createFramebuffer(shadowMap, context) {\n  if (shadowMap._isPointLight) {\n    createFramebufferCube(shadowMap, context);\n  } else if (shadowMap._usesDepthTexture) {\n    createFramebufferDepth(shadowMap, context);\n  } else {\n    createFramebufferColor(shadowMap, context);\n  }\n}\n\nfunction checkFramebuffer(shadowMap, context) {\n  // Attempt to make an FBO with only a depth texture. If it fails, fallback to a color texture.\n  if (\n    shadowMap._usesDepthTexture &&\n    shadowMap._passes[0].framebuffer.status !==\n      WebGLConstants.FRAMEBUFFER_COMPLETE\n  ) {\n    shadowMap._usesDepthTexture = false;\n    createRenderStates(shadowMap);\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n  }\n}\n\nfunction updateFramebuffer(shadowMap, context) {\n  if (\n    !defined(shadowMap._passes[0].framebuffer) ||\n    shadowMap._shadowMapTexture.width !== shadowMap._textureSize.x\n  ) {\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n    checkFramebuffer(shadowMap, context);\n    clearFramebuffer(shadowMap, context);\n  }\n}\n\nfunction clearFramebuffer(shadowMap, context, shadowPass) {\n  shadowPass = defaultValue(shadowPass, 0);\n  if (shadowMap._isPointLight || shadowPass === 0) {\n    shadowMap._clearCommand.framebuffer =\n      shadowMap._passes[shadowPass].framebuffer;\n    shadowMap._clearCommand.execute(context, shadowMap._clearPassState);\n  }\n}\n\nfunction resize(shadowMap, size) {\n  shadowMap._size = size;\n  const passes = shadowMap._passes;\n  const numberOfPasses = passes.length;\n  const textureSize = shadowMap._textureSize;\n\n  if (shadowMap._isPointLight) {\n    size =\n      ContextLimits.maximumCubeMapSize >= size\n        ? size\n        : ContextLimits.maximumCubeMapSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    const faceViewport = new BoundingRectangle(0, 0, size, size);\n    passes[0].passState.viewport = faceViewport;\n    passes[1].passState.viewport = faceViewport;\n    passes[2].passState.viewport = faceViewport;\n    passes[3].passState.viewport = faceViewport;\n    passes[4].passState.viewport = faceViewport;\n    passes[5].passState.viewport = faceViewport;\n  } else if (numberOfPasses === 1) {\n    // +----+\n    // |  1 |\n    // +----+\n    size =\n      ContextLimits.maximumTextureSize >= size\n        ? size\n        : ContextLimits.maximumTextureSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n  } else if (numberOfPasses === 4) {\n    // +----+----+\n    // |  3 |  4 |\n    // +----+----+\n    // |  1 |  2 |\n    // +----+----+\n    size =\n      ContextLimits.maximumTextureSize >= size * 2\n        ? size\n        : ContextLimits.maximumTextureSize / 2;\n    textureSize.x = size * 2;\n    textureSize.y = size * 2;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n    passes[1].passState.viewport = new BoundingRectangle(size, 0, size, size);\n    passes[2].passState.viewport = new BoundingRectangle(0, size, size, size);\n    passes[3].passState.viewport = new BoundingRectangle(\n      size,\n      size,\n      size,\n      size,\n    );\n  }\n\n  // Update clear pass state\n  shadowMap._clearPassState.viewport = new BoundingRectangle(\n    0,\n    0,\n    textureSize.x,\n    textureSize.y,\n  );\n\n  // Transforms shadow coordinates [0, 1] into the pass's region of the texture\n  for (let i = 0; i < numberOfPasses; ++i) {\n    const pass = passes[i];\n    const viewport = pass.passState.viewport;\n    const biasX = viewport.x / textureSize.x;\n    const biasY = viewport.y / textureSize.y;\n    const scaleX = viewport.width / textureSize.x;\n    const scaleY = viewport.height / textureSize.y;\n    pass.textureOffsets = new Matrix4(\n      scaleX,\n      0.0,\n      0.0,\n      biasX,\n      0.0,\n      scaleY,\n      0.0,\n      biasY,\n      0.0,\n      0.0,\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    );\n  }\n}\n\nconst scratchViewport = new BoundingRectangle();\n\nfunction createDebugShadowViewCommand(shadowMap, context) {\n  let fs;\n  if (shadowMap._isPointLight) {\n    fs =\n      \"uniform samplerCube shadowMap_textureCube; \\n\" +\n      \"in vec2 v_textureCoordinates; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    vec2 uv = v_textureCoordinates; \\n\" +\n      \"    vec3 dir; \\n\" +\n      \" \\n\" +\n      \"    if (uv.y < 0.5) \\n\" +\n      \"    { \\n\" +\n      \"        if (uv.x < 0.333) \\n\" +\n      \"        { \\n\" +\n      \"            dir.x = -1.0; \\n\" +\n      \"            dir.y = uv.x * 6.0 - 1.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"        else if (uv.x < 0.666) \\n\" +\n      \"        { \\n\" +\n      \"            dir.y = -1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 3.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"        else \\n\" +\n      \"        { \\n\" +\n      \"            dir.z = -1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 5.0; \\n\" +\n      \"            dir.y = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"    } \\n\" +\n      \"    else \\n\" +\n      \"    { \\n\" +\n      \"        if (uv.x < 0.333) \\n\" +\n      \"        { \\n\" +\n      \"            dir.x = 1.0; \\n\" +\n      \"            dir.y = uv.x * 6.0 - 1.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"        else if (uv.x < 0.666) \\n\" +\n      \"        { \\n\" +\n      \"            dir.y = 1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 3.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"        else \\n\" +\n      \"        { \\n\" +\n      \"            dir.z = 1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 5.0; \\n\" +\n      \"            dir.y = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"    } \\n\" +\n      \" \\n\" +\n      \"    float shadow = czm_unpackDepth(czm_textureCube(shadowMap_textureCube, dir)); \\n\" +\n      \"    out_FragColor = vec4(vec3(shadow), 1.0); \\n\" +\n      \"} \\n\";\n  } else {\n    fs =\n      `${\n        \"uniform sampler2D shadowMap_texture; \\n\" +\n        \"in vec2 v_textureCoordinates; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\"\n      }${\n        shadowMap._usesDepthTexture\n          ? \"    float shadow = texture(shadowMap_texture, v_textureCoordinates).r; \\n\"\n          : \"    float shadow = czm_unpackDepth(texture(shadowMap_texture, v_textureCoordinates)); \\n\"\n      }    out_FragColor = vec4(vec3(shadow), 1.0); \\n` + `} \\n`;\n  }\n\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      shadowMap_texture: function () {\n        return shadowMap._shadowMapTexture;\n      },\n      shadowMap_textureCube: function () {\n        return shadowMap._shadowMapTexture;\n      },\n    },\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nfunction updateDebugShadowViewCommand(shadowMap, frameState) {\n  // Draws the shadow map on the bottom-right corner of the screen\n  const context = frameState.context;\n  const screenWidth = frameState.context.drawingBufferWidth;\n  const screenHeight = frameState.context.drawingBufferHeight;\n  const size = Math.min(screenWidth, screenHeight) * 0.3;\n\n  const viewport = scratchViewport;\n  viewport.x = screenWidth - size;\n  viewport.y = 0;\n  viewport.width = size;\n  viewport.height = size;\n\n  let debugCommand = shadowMap._debugShadowViewCommand;\n  if (!defined(debugCommand)) {\n    debugCommand = createDebugShadowViewCommand(shadowMap, context);\n    shadowMap._debugShadowViewCommand = debugCommand;\n  }\n\n  // Get a new RenderState for the updated viewport size\n  if (\n    !defined(debugCommand.renderState) ||\n    !BoundingRectangle.equals(debugCommand.renderState.viewport, viewport)\n  ) {\n    debugCommand.renderState = RenderState.fromCache({\n      viewport: BoundingRectangle.clone(viewport),\n    });\n  }\n\n  frameState.commandList.push(shadowMap._debugShadowViewCommand);\n}\n\nconst frustumCornersNDC = new Array(8);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[4] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[5] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[6] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[7] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nconst scratchMatrix = new Matrix4();\nconst scratchFrustumCorners = new Array(8);\nfor (let i = 0; i < 8; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nfunction createDebugPointLight(modelMatrix, color) {\n  const box = new GeometryInstance({\n    geometry: new BoxOutlineGeometry({\n      minimum: new Cartesian3(-0.5, -0.5, -0.5),\n      maximum: new Cartesian3(0.5, 0.5, 0.5),\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  const sphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 0.5,\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: [box, sphere],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n    modelMatrix: modelMatrix,\n  });\n}\n\nconst debugOutlineColors = [Color.RED, Color.GREEN, Color.BLUE, Color.MAGENTA];\nconst scratchScale = new Cartesian3();\n\nfunction applyDebugSettings(shadowMap, frameState) {\n  updateDebugShadowViewCommand(shadowMap, frameState);\n\n  const enterFreezeFrame =\n    shadowMap.debugFreezeFrame && !shadowMap._debugFreezeFrame;\n  shadowMap._debugFreezeFrame = shadowMap.debugFreezeFrame;\n\n  // Draw scene camera in freeze frame mode\n  if (shadowMap.debugFreezeFrame) {\n    if (enterFreezeFrame) {\n      // Recreate debug camera when entering freeze frame mode\n      shadowMap._debugCameraFrustum =\n        shadowMap._debugCameraFrustum &&\n        shadowMap._debugCameraFrustum.destroy();\n      shadowMap._debugCameraFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._sceneCamera,\n        color: Color.CYAN,\n        updateOnChange: false,\n      });\n    }\n    shadowMap._debugCameraFrustum.update(frameState);\n  }\n\n  if (shadowMap._cascadesEnabled) {\n    // Draw cascades only in freeze frame mode\n    if (shadowMap.debugFreezeFrame) {\n      if (enterFreezeFrame) {\n        // Recreate debug frustum when entering freeze frame mode\n        shadowMap._debugLightFrustum =\n          shadowMap._debugLightFrustum &&\n          shadowMap._debugLightFrustum.destroy();\n        shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n          camera: shadowMap._shadowMapCamera,\n          color: Color.YELLOW,\n          updateOnChange: false,\n        });\n      }\n      shadowMap._debugLightFrustum.update(frameState);\n\n      for (let i = 0; i < shadowMap._numberOfCascades; ++i) {\n        if (enterFreezeFrame) {\n          // Recreate debug frustum when entering freeze frame mode\n          shadowMap._debugCascadeFrustums[i] =\n            shadowMap._debugCascadeFrustums[i] &&\n            shadowMap._debugCascadeFrustums[i].destroy();\n          shadowMap._debugCascadeFrustums[i] = new DebugCameraPrimitive({\n            camera: shadowMap._passes[i].camera,\n            color: debugOutlineColors[i],\n            updateOnChange: false,\n          });\n        }\n        shadowMap._debugCascadeFrustums[i].update(frameState);\n      }\n    }\n  } else if (shadowMap._isPointLight) {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      const translation = shadowMap._shadowMapCamera.positionWC;\n      const rotation = Quaternion.IDENTITY;\n      const uniformScale = shadowMap._pointLightRadius * 2.0;\n      const scale = Cartesian3.fromElements(\n        uniformScale,\n        uniformScale,\n        uniformScale,\n        scratchScale,\n      );\n      const modelMatrix = Matrix4.fromTranslationQuaternionRotationScale(\n        translation,\n        rotation,\n        scale,\n        scratchMatrix,\n      );\n\n      shadowMap._debugLightFrustum =\n        shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n      shadowMap._debugLightFrustum = createDebugPointLight(\n        modelMatrix,\n        Color.YELLOW,\n      );\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  } else {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._shadowMapCamera,\n        color: Color.YELLOW,\n        updateOnChange: false,\n      });\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  }\n}\n\nfunction ShadowMapCamera() {\n  this.viewMatrix = new Matrix4();\n  this.inverseViewMatrix = new Matrix4();\n  this.frustum = undefined;\n  this.positionCartographic = new Cartographic();\n  this.positionWC = new Cartesian3();\n  this.directionWC = Cartesian3.clone(Cartesian3.UNIT_Z);\n  this.upWC = Cartesian3.clone(Cartesian3.UNIT_Y);\n  this.rightWC = Cartesian3.clone(Cartesian3.UNIT_X);\n  this.viewProjectionMatrix = new Matrix4();\n}\n\nShadowMapCamera.prototype.clone = function (camera) {\n  Matrix4.clone(camera.viewMatrix, this.viewMatrix);\n  Matrix4.clone(camera.inverseViewMatrix, this.inverseViewMatrix);\n  this.frustum = camera.frustum.clone(this.frustum);\n  Cartographic.clone(camera.positionCartographic, this.positionCartographic);\n  Cartesian3.clone(camera.positionWC, this.positionWC);\n  Cartesian3.clone(camera.directionWC, this.directionWC);\n  Cartesian3.clone(camera.upWC, this.upWC);\n  Cartesian3.clone(camera.rightWC, this.rightWC);\n};\n\n// Converts from NDC space to texture space\nconst scaleBiasMatrix = new Matrix4(\n  0.5,\n  0.0,\n  0.0,\n  0.5,\n  0.0,\n  0.5,\n  0.0,\n  0.5,\n  0.0,\n  0.0,\n  0.5,\n  0.5,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n);\n\nShadowMapCamera.prototype.getViewProjection = function () {\n  const view = this.viewMatrix;\n  const projection = this.frustum.projectionMatrix;\n  Matrix4.multiply(projection, view, this.viewProjectionMatrix);\n  Matrix4.multiply(\n    scaleBiasMatrix,\n    this.viewProjectionMatrix,\n    this.viewProjectionMatrix,\n  );\n  return this.viewProjectionMatrix;\n};\n\nconst scratchSplits = new Array(5);\nconst scratchFrustum = new PerspectiveFrustum();\nconst scratchCascadeDistances = new Array(4);\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\n\nfunction computeCascades(shadowMap, frameState) {\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const sceneCamera = shadowMap._sceneCamera;\n  const cameraNear = sceneCamera.frustum.near;\n  const cameraFar = sceneCamera.frustum.far;\n  const numberOfCascades = shadowMap._numberOfCascades;\n\n  // Split cascades. Use a mix of linear and log splits.\n  let i;\n  const range = cameraFar - cameraNear;\n  const ratio = cameraFar / cameraNear;\n\n  let lambda = 0.9;\n  let clampCascadeDistances = false;\n\n  // When the camera is close to a relatively small model, provide more detail in the closer cascades.\n  // If the camera is near or inside a large model, such as the root tile of a city, then use the default values.\n  // To get the most accurate cascade splits we would need to find the min and max values from the depth texture.\n  if (frameState.shadowState.closestObjectSize < 200.0) {\n    clampCascadeDistances = true;\n    lambda = 0.9;\n  }\n\n  const cascadeDistances = scratchCascadeDistances;\n  const splits = scratchSplits;\n  splits[0] = cameraNear;\n  splits[numberOfCascades] = cameraFar;\n\n  // Find initial splits\n  for (i = 0; i < numberOfCascades; ++i) {\n    const p = (i + 1) / numberOfCascades;\n    const logScale = cameraNear * Math.pow(ratio, p);\n    const uniformScale = cameraNear + range * p;\n    const split = CesiumMath.lerp(uniformScale, logScale, lambda);\n    splits[i + 1] = split;\n    cascadeDistances[i] = split - splits[i];\n  }\n\n  if (clampCascadeDistances) {\n    // Clamp each cascade to its maximum distance\n    for (i = 0; i < numberOfCascades; ++i) {\n      cascadeDistances[i] = Math.min(\n        cascadeDistances[i],\n        shadowMap._maximumCascadeDistances[i],\n      );\n    }\n\n    // Recompute splits\n    let distance = splits[0];\n    for (i = 0; i < numberOfCascades - 1; ++i) {\n      distance += cascadeDistances[i];\n      splits[i + 1] = distance;\n    }\n  }\n\n  Cartesian4.unpack(splits, 0, shadowMap._cascadeSplits[0]);\n  Cartesian4.unpack(splits, 1, shadowMap._cascadeSplits[1]);\n  Cartesian4.unpack(cascadeDistances, 0, shadowMap._cascadeDistances);\n\n  const shadowFrustum = shadowMapCamera.frustum;\n  const left = shadowFrustum.left;\n  const right = shadowFrustum.right;\n  const bottom = shadowFrustum.bottom;\n  const top = shadowFrustum.top;\n  const near = shadowFrustum.near;\n  const far = shadowFrustum.far;\n\n  const position = shadowMapCamera.positionWC;\n  const direction = shadowMapCamera.directionWC;\n  const up = shadowMapCamera.upWC;\n\n  const cascadeSubFrustum = sceneCamera.frustum.clone(scratchFrustum);\n  const shadowViewProjection = shadowMapCamera.getViewProjection();\n\n  for (i = 0; i < numberOfCascades; ++i) {\n    // Find the bounding box of the camera sub-frustum in shadow map texture space\n    cascadeSubFrustum.near = splits[i];\n    cascadeSubFrustum.far = splits[i + 1];\n    const viewProjection = Matrix4.multiply(\n      cascadeSubFrustum.projectionMatrix,\n      sceneCamera.viewMatrix,\n      scratchMatrix,\n    );\n    const inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchMatrix,\n    );\n    const shadowMapMatrix = Matrix4.multiply(\n      shadowViewProjection,\n      inverseViewProjection,\n      scratchMatrix,\n    );\n\n    // Project each corner from camera NDC space to shadow map texture space. Min and max will be from 0 to 1.\n    const min = Cartesian3.fromElements(\n      Number.MAX_VALUE,\n      Number.MAX_VALUE,\n      Number.MAX_VALUE,\n      scratchMin,\n    );\n    const max = Cartesian3.fromElements(\n      -Number.MAX_VALUE,\n      -Number.MAX_VALUE,\n      -Number.MAX_VALUE,\n      scratchMax,\n    );\n\n    for (let k = 0; k < 8; ++k) {\n      const corner = Cartesian4.clone(\n        frustumCornersNDC[k],\n        scratchFrustumCorners[k],\n      );\n      Matrix4.multiplyByVector(shadowMapMatrix, corner, corner);\n      Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n      Cartesian3.minimumByComponent(corner, min, min);\n      Cartesian3.maximumByComponent(corner, max, max);\n    }\n\n    // Limit light-space coordinates to the [0, 1] range\n    min.x = Math.max(min.x, 0.0);\n    min.y = Math.max(min.y, 0.0);\n    min.z = 0.0; // Always start cascade frustum at the top of the light frustum to capture objects in the light's path\n    max.x = Math.min(max.x, 1.0);\n    max.y = Math.min(max.y, 1.0);\n    max.z = Math.min(max.z, 1.0);\n\n    const pass = shadowMap._passes[i];\n    const cascadeCamera = pass.camera;\n    cascadeCamera.clone(shadowMapCamera); // PERFORMANCE_IDEA : could do a shallow clone for all properties except the frustum\n\n    const frustum = cascadeCamera.frustum;\n    frustum.left = left + min.x * (right - left);\n    frustum.right = left + max.x * (right - left);\n    frustum.bottom = bottom + min.y * (top - bottom);\n    frustum.top = bottom + max.y * (top - bottom);\n    frustum.near = near + min.z * (far - near);\n    frustum.far = near + max.z * (far - near);\n\n    pass.cullingVolume = cascadeCamera.frustum.computeCullingVolume(\n      position,\n      direction,\n      up,\n    );\n\n    // Transforms from eye space to the cascade's texture space\n    const cascadeMatrix = shadowMap._cascadeMatrices[i];\n    Matrix4.multiply(\n      cascadeCamera.getViewProjection(),\n      sceneCamera.inverseViewMatrix,\n      cascadeMatrix,\n    );\n    Matrix4.multiply(pass.textureOffsets, cascadeMatrix, cascadeMatrix);\n  }\n}\n\nconst scratchLightView = new Matrix4();\nconst scratchRight = new Cartesian3();\nconst scratchUp = new Cartesian3();\nconst scratchTranslation = new Cartesian3();\n\nfunction fitShadowMapToScene(shadowMap, frameState) {\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const sceneCamera = shadowMap._sceneCamera;\n\n  // 1. First find a tight bounding box in light space that contains the entire camera frustum.\n  const viewProjection = Matrix4.multiply(\n    sceneCamera.frustum.projectionMatrix,\n    sceneCamera.viewMatrix,\n    scratchMatrix,\n  );\n  const inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n\n  // Start to construct the light view matrix. Set translation later once the bounding box is found.\n  const lightDir = shadowMapCamera.directionWC;\n  let lightUp = sceneCamera.directionWC; // Align shadows to the camera view.\n  if (Cartesian3.equalsEpsilon(lightDir, lightUp, CesiumMath.EPSILON10)) {\n    lightUp = sceneCamera.upWC;\n  }\n  const lightRight = Cartesian3.cross(lightDir, lightUp, scratchRight);\n  lightUp = Cartesian3.cross(lightRight, lightDir, scratchUp); // Recalculate up now that right is derived\n  Cartesian3.normalize(lightUp, lightUp);\n  Cartesian3.normalize(lightRight, lightRight);\n  const lightPosition = Cartesian3.fromElements(\n    0.0,\n    0.0,\n    0.0,\n    scratchTranslation,\n  );\n\n  let lightView = Matrix4.computeView(\n    lightPosition,\n    lightDir,\n    lightUp,\n    lightRight,\n    scratchLightView,\n  );\n  const cameraToLight = Matrix4.multiply(\n    lightView,\n    inverseViewProjection,\n    scratchMatrix,\n  );\n\n  // Project each corner from NDC space to light view space, and calculate a min and max in light view space\n  const min = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchMin,\n  );\n  const max = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchMax,\n  );\n\n  for (let i = 0; i < 8; ++i) {\n    const corner = Cartesian4.clone(\n      frustumCornersNDC[i],\n      scratchFrustumCorners[i],\n    );\n    Matrix4.multiplyByVector(cameraToLight, corner, corner);\n    Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n    Cartesian3.minimumByComponent(corner, min, min);\n    Cartesian3.maximumByComponent(corner, max, max);\n  }\n\n  // 2. Set bounding box back to include objects in the light's view\n  max.z += 1000.0; // Note: in light space, a positive number is behind the camera\n  min.z -= 10.0; // Extend the shadow volume forward slightly to avoid problems right at the edge\n\n  // 3. Adjust light view matrix so that it is centered on the bounding volume\n  const translation = scratchTranslation;\n  translation.x = -(0.5 * (min.x + max.x));\n  translation.y = -(0.5 * (min.y + max.y));\n  translation.z = -max.z;\n\n  const translationMatrix = Matrix4.fromTranslation(translation, scratchMatrix);\n  lightView = Matrix4.multiply(translationMatrix, lightView, lightView);\n\n  // 4. Create an orthographic frustum that covers the bounding box extents\n  const halfWidth = 0.5 * (max.x - min.x);\n  const halfHeight = 0.5 * (max.y - min.y);\n  const depth = max.z - min.z;\n\n  const frustum = shadowMapCamera.frustum;\n  frustum.left = -halfWidth;\n  frustum.right = halfWidth;\n  frustum.bottom = -halfHeight;\n  frustum.top = halfHeight;\n  frustum.near = 0.01;\n  frustum.far = depth;\n\n  // 5. Update the shadow map camera\n  Matrix4.clone(lightView, shadowMapCamera.viewMatrix);\n  Matrix4.inverse(lightView, shadowMapCamera.inverseViewMatrix);\n  Matrix4.getTranslation(\n    shadowMapCamera.inverseViewMatrix,\n    shadowMapCamera.positionWC,\n  );\n  frameState.mapProjection.ellipsoid.cartesianToCartographic(\n    shadowMapCamera.positionWC,\n    shadowMapCamera.positionCartographic,\n  );\n  Cartesian3.clone(lightDir, shadowMapCamera.directionWC);\n  Cartesian3.clone(lightUp, shadowMapCamera.upWC);\n  Cartesian3.clone(lightRight, shadowMapCamera.rightWC);\n}\n\nconst directions = [\n  new Cartesian3(-1.0, 0.0, 0.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(0.0, 1.0, 0.0),\n  new Cartesian3(0.0, 0.0, 1.0),\n];\n\nconst ups = [\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, 1.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n];\n\nconst rights = [\n  new Cartesian3(0.0, 0.0, 1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(-1.0, 0.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n];\n\nfunction computeOmnidirectional(shadowMap, frameState) {\n  // All sides share the same frustum\n  const frustum = new PerspectiveFrustum();\n  frustum.fov = CesiumMath.PI_OVER_TWO;\n  frustum.near = 1.0;\n  frustum.far = shadowMap._pointLightRadius;\n  frustum.aspectRatio = 1.0;\n\n  for (let i = 0; i < 6; ++i) {\n    const camera = shadowMap._passes[i].camera;\n    camera.positionWC = shadowMap._shadowMapCamera.positionWC;\n    camera.positionCartographic =\n      frameState.mapProjection.ellipsoid.cartesianToCartographic(\n        camera.positionWC,\n        camera.positionCartographic,\n      );\n    camera.directionWC = directions[i];\n    camera.upWC = ups[i];\n    camera.rightWC = rights[i];\n\n    Matrix4.computeView(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC,\n      camera.rightWC,\n      camera.viewMatrix,\n    );\n    Matrix4.inverse(camera.viewMatrix, camera.inverseViewMatrix);\n\n    camera.frustum = frustum;\n  }\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\nconst scratchCenter = scratchBoundingSphere.center;\n\nfunction checkVisibility(shadowMap, frameState) {\n  const sceneCamera = shadowMap._sceneCamera;\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n\n  const boundingSphere = scratchBoundingSphere;\n\n  // Check whether the shadow map is in view and needs to be updated\n  if (shadowMap._cascadesEnabled) {\n    // If the nearest shadow receiver is further than the shadow map's maximum distance then the shadow map is out of view.\n    if (sceneCamera.frustum.near >= shadowMap.maximumDistance) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // If the light source is below the horizon then the shadow map is out of view\n    const surfaceNormal =\n      frameState.mapProjection.ellipsoid.geodeticSurfaceNormal(\n        sceneCamera.positionWC,\n        scratchCartesian1,\n      );\n    const lightDirection = Cartesian3.negate(\n      shadowMapCamera.directionWC,\n      scratchCartesian2,\n    );\n    const dot = Cartesian3.dot(surfaceNormal, lightDirection);\n    if (shadowMap.fadingEnabled) {\n      // Shadows start to fade out once the light gets closer to the horizon.\n      // At this point the globe uses vertex lighting alone to darken the surface.\n      const darknessAmount = CesiumMath.clamp(dot / 0.1, 0.0, 1.0);\n      shadowMap._darkness = CesiumMath.lerp(\n        1.0,\n        shadowMap.darkness,\n        darknessAmount,\n      );\n    } else {\n      shadowMap._darkness = shadowMap.darkness;\n    }\n\n    if (dot < 0.0) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // By default cascaded shadows need to update and are always in view\n    shadowMap._needsUpdate = true;\n    shadowMap._outOfView = false;\n  } else if (shadowMap._isPointLight) {\n    // Sphere-frustum intersection test\n    boundingSphere.center = shadowMapCamera.positionWC;\n    boundingSphere.radius = shadowMap._pointLightRadius;\n    shadowMap._outOfView =\n      frameState.cullingVolume.computeVisibility(boundingSphere) ===\n      Intersect.OUTSIDE;\n    shadowMap._needsUpdate =\n      !shadowMap._outOfView &&\n      !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  } else {\n    // Simplify frustum-frustum intersection test as a sphere-frustum test\n    const frustumRadius = shadowMapCamera.frustum.far / 2.0;\n    const frustumCenter = Cartesian3.add(\n      shadowMapCamera.positionWC,\n      Cartesian3.multiplyByScalar(\n        shadowMapCamera.directionWC,\n        frustumRadius,\n        scratchCenter,\n      ),\n      scratchCenter,\n    );\n    boundingSphere.center = frustumCenter;\n    boundingSphere.radius = frustumRadius;\n    shadowMap._outOfView =\n      frameState.cullingVolume.computeVisibility(boundingSphere) ===\n      Intersect.OUTSIDE;\n    shadowMap._needsUpdate =\n      !shadowMap._outOfView &&\n      !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  }\n}\n\nfunction updateCameras(shadowMap, frameState) {\n  const camera = frameState.camera; // The actual camera in the scene\n  const lightCamera = shadowMap._lightCamera; // The external camera representing the light source\n  const sceneCamera = shadowMap._sceneCamera; // Clone of camera, with clamped near and far planes\n  const shadowMapCamera = shadowMap._shadowMapCamera; // Camera representing the shadow volume, initially cloned from lightCamera\n\n  // Clone light camera into the shadow map camera\n  if (shadowMap._cascadesEnabled) {\n    Cartesian3.clone(lightCamera.directionWC, shadowMapCamera.directionWC);\n  } else if (shadowMap._isPointLight) {\n    Cartesian3.clone(lightCamera.positionWC, shadowMapCamera.positionWC);\n  } else {\n    shadowMapCamera.clone(lightCamera);\n  }\n\n  // Get the light direction in eye coordinates\n  const lightDirection = shadowMap._lightDirectionEC;\n  Matrix4.multiplyByPointAsVector(\n    camera.viewMatrix,\n    shadowMapCamera.directionWC,\n    lightDirection,\n  );\n  Cartesian3.normalize(lightDirection, lightDirection);\n  Cartesian3.negate(lightDirection, lightDirection);\n\n  // Get the light position in eye coordinates\n  Matrix4.multiplyByPoint(\n    camera.viewMatrix,\n    shadowMapCamera.positionWC,\n    shadowMap._lightPositionEC,\n  );\n  shadowMap._lightPositionEC.w = shadowMap._pointLightRadius;\n\n  // Get the near and far of the scene camera\n  let near;\n  let far;\n  if (shadowMap._fitNearFar) {\n    // shadowFar can be very large, so limit to shadowMap.maximumDistance\n    // Push the far plane slightly further than the near plane to avoid degenerate frustum\n    near = Math.min(\n      frameState.shadowState.nearPlane,\n      shadowMap.maximumDistance,\n    );\n    far = Math.min(frameState.shadowState.farPlane, shadowMap.maximumDistance);\n    far = Math.max(far, near + 1.0);\n  } else {\n    near = camera.frustum.near;\n    far = shadowMap.maximumDistance;\n  }\n\n  shadowMap._sceneCamera = Camera.clone(camera, sceneCamera);\n  camera.frustum.clone(shadowMap._sceneCamera.frustum);\n  shadowMap._sceneCamera.frustum.near = near;\n  shadowMap._sceneCamera.frustum.far = far;\n  shadowMap._distance = far - near;\n\n  checkVisibility(shadowMap, frameState);\n\n  if (!shadowMap._outOfViewPrevious && shadowMap._outOfView) {\n    shadowMap._needsUpdate = true;\n  }\n  shadowMap._outOfViewPrevious = shadowMap._outOfView;\n}\n\n/**\n * @private\n */\nShadowMap.prototype.update = function (frameState) {\n  updateCameras(this, frameState);\n\n  if (this._needsUpdate) {\n    updateFramebuffer(this, frameState.context);\n\n    if (this._isPointLight) {\n      computeOmnidirectional(this, frameState);\n    }\n\n    if (this._cascadesEnabled) {\n      fitShadowMapToScene(this, frameState);\n\n      if (this._numberOfCascades > 1) {\n        computeCascades(this, frameState);\n      }\n    }\n\n    if (!this._isPointLight) {\n      // Compute the culling volume\n      const shadowMapCamera = this._shadowMapCamera;\n      const position = shadowMapCamera.positionWC;\n      const direction = shadowMapCamera.directionWC;\n      const up = shadowMapCamera.upWC;\n      this._shadowMapCullingVolume =\n        shadowMapCamera.frustum.computeCullingVolume(position, direction, up);\n\n      if (this._passes.length === 1) {\n        // Since there is only one pass, use the shadow map camera as the pass camera.\n        this._passes[0].camera.clone(shadowMapCamera);\n      }\n    } else {\n      this._shadowMapCullingVolume = CullingVolume.fromBoundingSphere(\n        this._boundingSphere,\n      );\n    }\n  }\n\n  if (this._passes.length === 1) {\n    // Transforms from eye space to shadow texture space.\n    // Always requires an update since the scene camera constantly changes.\n    const inverseView = this._sceneCamera.inverseViewMatrix;\n    Matrix4.multiply(\n      this._shadowMapCamera.getViewProjection(),\n      inverseView,\n      this._shadowMapMatrix,\n    );\n  }\n\n  if (this.debugShow) {\n    applyDebugSettings(this, frameState);\n  }\n};\n\n/**\n * @private\n */\nShadowMap.prototype.updatePass = function (context, shadowPass) {\n  clearFramebuffer(this, context, shadowPass);\n};\n\nconst scratchTexelStepSize = new Cartesian2();\n\nfunction combineUniforms(shadowMap, uniforms, isTerrain) {\n  const bias = shadowMap._isPointLight\n    ? shadowMap._pointBias\n    : isTerrain\n      ? shadowMap._terrainBias\n      : shadowMap._primitiveBias;\n\n  const mapUniforms = {\n    shadowMap_texture: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_textureCube: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_matrix: function () {\n      return shadowMap._shadowMapMatrix;\n    },\n    shadowMap_cascadeSplits: function () {\n      return shadowMap._cascadeSplits;\n    },\n    shadowMap_cascadeMatrices: function () {\n      return shadowMap._cascadeMatrices;\n    },\n    shadowMap_lightDirectionEC: function () {\n      return shadowMap._lightDirectionEC;\n    },\n    shadowMap_lightPositionEC: function () {\n      return shadowMap._lightPositionEC;\n    },\n    shadowMap_cascadeDistances: function () {\n      return shadowMap._cascadeDistances;\n    },\n    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function () {\n      const texelStepSize = scratchTexelStepSize;\n      texelStepSize.x = 1.0 / shadowMap._textureSize.x;\n      texelStepSize.y = 1.0 / shadowMap._textureSize.y;\n\n      return Cartesian4.fromElements(\n        texelStepSize.x,\n        texelStepSize.y,\n        bias.depthBias,\n        bias.normalShadingSmooth,\n        this.combinedUniforms1,\n      );\n    },\n    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function () {\n      return Cartesian4.fromElements(\n        bias.normalOffsetScale,\n        shadowMap._distance,\n        shadowMap.maximumDistance,\n        shadowMap._darkness,\n        this.combinedUniforms2,\n      );\n    },\n\n    combinedUniforms1: new Cartesian4(),\n    combinedUniforms2: new Cartesian4(),\n  };\n\n  return combine(uniforms, mapUniforms, false);\n}\n\nfunction createCastDerivedCommand(\n  shadowMap,\n  shadowsDirty,\n  command,\n  context,\n  oldShaderId,\n  result,\n) {\n  let castShader;\n  let castRenderState;\n  let castUniformMap;\n  if (defined(result)) {\n    castShader = result.shaderProgram;\n    castRenderState = result.renderState;\n    castUniformMap = result.uniformMap;\n  }\n\n  result = DrawCommand.shallowClone(command, result);\n  result.castShadows = true;\n  result.receiveShadows = false;\n\n  if (\n    !defined(castShader) ||\n    oldShaderId !== command.shaderProgram.id ||\n    shadowsDirty\n  ) {\n    const shaderProgram = command.shaderProgram;\n\n    const isTerrain = command.pass === Pass.GLOBE;\n    const isOpaque = command.pass !== Pass.TRANSLUCENT;\n    const isPointLight = shadowMap._isPointLight;\n    const usesDepthTexture = shadowMap._usesDepthTexture;\n\n    const keyword = ShadowMapShader.getShadowCastShaderKeyword(\n      isPointLight,\n      isTerrain,\n      usesDepthTexture,\n      isOpaque,\n    );\n    castShader = context.shaderCache.getDerivedShaderProgram(\n      shaderProgram,\n      keyword,\n    );\n    if (!defined(castShader)) {\n      const vertexShaderSource = shaderProgram.vertexShaderSource;\n      const fragmentShaderSource = shaderProgram.fragmentShaderSource;\n\n      const castVS = ShadowMapShader.createShadowCastVertexShader(\n        vertexShaderSource,\n        isPointLight,\n        isTerrain,\n      );\n      const castFS = ShadowMapShader.createShadowCastFragmentShader(\n        fragmentShaderSource,\n        isPointLight,\n        usesDepthTexture,\n        isOpaque,\n      );\n\n      castShader = context.shaderCache.createDerivedShaderProgram(\n        shaderProgram,\n        keyword,\n        {\n          vertexShaderSource: castVS,\n          fragmentShaderSource: castFS,\n          attributeLocations: shaderProgram._attributeLocations,\n        },\n      );\n    }\n\n    castRenderState = shadowMap._primitiveRenderState;\n    if (isPointLight) {\n      castRenderState = shadowMap._pointRenderState;\n    } else if (isTerrain) {\n      castRenderState = shadowMap._terrainRenderState;\n    }\n\n    // Modify the render state for commands that do not use back-face culling, e.g. flat textured walls\n    const cullEnabled = command.renderState.cull.enabled;\n    if (!cullEnabled) {\n      castRenderState = clone(castRenderState, false);\n      castRenderState.cull = clone(castRenderState.cull, false);\n      castRenderState.cull.enabled = false;\n      castRenderState = RenderState.fromCache(castRenderState);\n    }\n\n    castUniformMap = combineUniforms(shadowMap, command.uniformMap, isTerrain);\n  }\n\n  result.shaderProgram = castShader;\n  result.renderState = castRenderState;\n  result.uniformMap = castUniformMap;\n\n  return result;\n}\n\nShadowMap.createReceiveDerivedCommand = function (\n  lightShadowMaps,\n  command,\n  shadowsDirty,\n  context,\n  result,\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const lightShadowMapsEnabled = lightShadowMaps.length > 0;\n  const shaderProgram = command.shaderProgram;\n  const vertexShaderSource = shaderProgram.vertexShaderSource;\n  const fragmentShaderSource = shaderProgram.fragmentShaderSource;\n  const isTerrain = command.pass === Pass.GLOBE;\n\n  let hasTerrainNormal = false;\n  if (isTerrain) {\n    hasTerrainNormal =\n      command.owner.data.renderedMesh.encoding.hasVertexNormals;\n  }\n\n  if (command.receiveShadows && lightShadowMapsEnabled) {\n    // Only generate a receiveCommand if there is a shadow map originating from a light source.\n    let receiveShader;\n    let receiveUniformMap;\n    if (defined(result.receiveCommand)) {\n      receiveShader = result.receiveCommand.shaderProgram;\n      receiveUniformMap = result.receiveCommand.uniformMap;\n    }\n\n    result.receiveCommand = DrawCommand.shallowClone(\n      command,\n      result.receiveCommand,\n    );\n    result.castShadows = false;\n    result.receiveShadows = true;\n\n    // If castShadows changed, recompile the receive shadows shader. The normal shading technique simulates\n    // self-shadowing so it should be turned off if castShadows is false.\n    const castShadowsDirty =\n      result.receiveShaderCastShadows !== command.castShadows;\n    const shaderDirty =\n      result.receiveShaderProgramId !== command.shaderProgram.id;\n\n    if (\n      !defined(receiveShader) ||\n      shaderDirty ||\n      shadowsDirty ||\n      castShadowsDirty\n    ) {\n      const keyword = ShadowMapShader.getShadowReceiveShaderKeyword(\n        lightShadowMaps[0],\n        command.castShadows,\n        isTerrain,\n        hasTerrainNormal,\n      );\n      receiveShader = context.shaderCache.getDerivedShaderProgram(\n        shaderProgram,\n        keyword,\n      );\n      if (!defined(receiveShader)) {\n        const receiveVS = ShadowMapShader.createShadowReceiveVertexShader(\n          vertexShaderSource,\n          isTerrain,\n          hasTerrainNormal,\n        );\n        const receiveFS = ShadowMapShader.createShadowReceiveFragmentShader(\n          fragmentShaderSource,\n          lightShadowMaps[0],\n          command.castShadows,\n          isTerrain,\n          hasTerrainNormal,\n        );\n\n        receiveShader = context.shaderCache.createDerivedShaderProgram(\n          shaderProgram,\n          keyword,\n          {\n            vertexShaderSource: receiveVS,\n            fragmentShaderSource: receiveFS,\n            attributeLocations: shaderProgram._attributeLocations,\n          },\n        );\n      }\n\n      receiveUniformMap = combineUniforms(\n        lightShadowMaps[0],\n        command.uniformMap,\n        isTerrain,\n      );\n    }\n\n    result.receiveCommand.shaderProgram = receiveShader;\n    result.receiveCommand.uniformMap = receiveUniformMap;\n    result.receiveShaderProgramId = command.shaderProgram.id;\n    result.receiveShaderCastShadows = command.castShadows;\n  }\n\n  return result;\n};\n\nShadowMap.createCastDerivedCommand = function (\n  shadowMaps,\n  command,\n  shadowsDirty,\n  context,\n  result,\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  if (command.castShadows) {\n    let castCommands = result.castCommands;\n    if (!defined(castCommands)) {\n      castCommands = result.castCommands = [];\n    }\n\n    const oldShaderId = result.castShaderProgramId;\n\n    const shadowMapLength = shadowMaps.length;\n    castCommands.length = shadowMapLength;\n\n    for (let i = 0; i < shadowMapLength; ++i) {\n      castCommands[i] = createCastDerivedCommand(\n        shadowMaps[i],\n        shadowsDirty,\n        command,\n        context,\n        oldShaderId,\n        castCommands[i],\n      );\n    }\n\n    result.castShaderProgramId = command.shaderProgram.id;\n  }\n\n  return result;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.destroy = function () {\n  destroyFramebuffer(this);\n\n  this._debugLightFrustum =\n    this._debugLightFrustum && this._debugLightFrustum.destroy();\n  this._debugCameraFrustum =\n    this._debugCameraFrustum && this._debugCameraFrustum.destroy();\n  this._debugShadowViewCommand =\n    this._debugShadowViewCommand &&\n    this._debugShadowViewCommand.shaderProgram &&\n    this._debugShadowViewCommand.shaderProgram.destroy();\n\n  for (let i = 0; i < this._numberOfCascades; ++i) {\n    this._debugCascadeFrustums[i] =\n      this._debugCascadeFrustums[i] && this._debugCascadeFrustums[i].destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default ShadowMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}