{"ast":null,"code":"import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * An {@link InterpolationAlgorithm} for performing linear interpolation.\n *\n * @namespace LinearApproximation\n */\nconst LinearApproximation = {\n  type: \"Linear\"\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n * Since linear interpolation can only generate a first degree polynomial, this function\n * always returns 2.\n * @param {number} degree The desired degree of interpolation.\n * @returns {number} This function always returns 2.\n *\n */\nLinearApproximation.getRequiredDataPoints = function (degree) {\n  return 2;\n};\n\n/**\n * Interpolates values using linear approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number[]} [result] An existing array into which to store the result.\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nLinearApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (xTable.length !== 2) {\n    throw new DeveloperError(\"The xTable provided to the linear interpolator must have exactly two elements.\");\n  } else if (yStride <= 0) {\n    throw new DeveloperError(\"There must be at least 1 dependent variable for each independent variable.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n  let i;\n  let y0;\n  let y1;\n  const x0 = xTable[0];\n  const x1 = xTable[1];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (x0 === x1) {\n    throw new DeveloperError(\"Divide by zero error: xTable[0] and xTable[1] are equal\");\n  }\n  //>>includeEnd('debug');\n\n  for (i = 0; i < yStride; i++) {\n    y0 = yTable[i];\n    y1 = yTable[i + yStride];\n    result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);\n  }\n  return result;\n};\nexport default LinearApproximation;","map":{"version":3,"names":["defined","DeveloperError","LinearApproximation","type","getRequiredDataPoints","degree","interpolateOrderZero","x","xTable","yTable","yStride","result","length","Array","i","y0","y1","x0","x1"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/LinearApproximation.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * An {@link InterpolationAlgorithm} for performing linear interpolation.\n *\n * @namespace LinearApproximation\n */\nconst LinearApproximation = {\n  type: \"Linear\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n * Since linear interpolation can only generate a first degree polynomial, this function\n * always returns 2.\n * @param {number} degree The desired degree of interpolation.\n * @returns {number} This function always returns 2.\n *\n */\nLinearApproximation.getRequiredDataPoints = function (degree) {\n  return 2;\n};\n\n/**\n * Interpolates values using linear approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number[]} [result] An existing array into which to store the result.\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nLinearApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (xTable.length !== 2) {\n    throw new DeveloperError(\n      \"The xTable provided to the linear interpolator must have exactly two elements.\",\n    );\n  } else if (yStride <= 0) {\n    throw new DeveloperError(\n      \"There must be at least 1 dependent variable for each independent variable.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  let i;\n  let y0;\n  let y1;\n  const x0 = xTable[0];\n  const x1 = xTable[1];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (x0 === x1) {\n    throw new DeveloperError(\n      \"Divide by zero error: xTable[0] and xTable[1] are equal\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  for (i = 0; i < yStride; i++) {\n    y0 = yTable[i];\n    y1 = yTable[i + yStride];\n    result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);\n  }\n\n  return result;\n};\nexport default LinearApproximation;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;;AAEhD;AACA;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG;EAC1BC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,mBAAmB,CAACE,qBAAqB,GAAG,UAAUC,MAAM,EAAE;EAC5D,OAAO,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,mBAAmB,CAACI,oBAAoB,GAAG,UACzCC,CAAC,EACDC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,MAAM,EACN;EACA;EACA,IAAIH,MAAM,CAACI,MAAM,KAAK,CAAC,EAAE;IACvB,MAAM,IAAIX,cAAc,CACtB,gFACF,CAAC;EACH,CAAC,MAAM,IAAIS,OAAO,IAAI,CAAC,EAAE;IACvB,MAAM,IAAIT,cAAc,CACtB,4EACF,CAAC;EACH;EACA;;EAEA,IAAI,CAACD,OAAO,CAACW,MAAM,CAAC,EAAE;IACpBA,MAAM,GAAG,IAAIE,KAAK,CAACH,OAAO,CAAC;EAC7B;EAEA,IAAII,CAAC;EACL,IAAIC,EAAE;EACN,IAAIC,EAAE;EACN,MAAMC,EAAE,GAAGT,MAAM,CAAC,CAAC,CAAC;EACpB,MAAMU,EAAE,GAAGV,MAAM,CAAC,CAAC,CAAC;;EAEpB;EACA,IAAIS,EAAE,KAAKC,EAAE,EAAE;IACb,MAAM,IAAIjB,cAAc,CACtB,yDACF,CAAC;EACH;EACA;;EAEA,KAAKa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,OAAO,EAAEI,CAAC,EAAE,EAAE;IAC5BC,EAAE,GAAGN,MAAM,CAACK,CAAC,CAAC;IACdE,EAAE,GAAGP,MAAM,CAACK,CAAC,GAAGJ,OAAO,CAAC;IACxBC,MAAM,CAACG,CAAC,CAAC,GAAG,CAAC,CAACE,EAAE,GAAGD,EAAE,IAAIR,CAAC,GAAGW,EAAE,GAAGH,EAAE,GAAGE,EAAE,GAAGD,EAAE,KAAKE,EAAE,GAAGD,EAAE,CAAC;EAC7D;EAEA,OAAON,MAAM;AACf,CAAC;AACD,eAAeT,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}