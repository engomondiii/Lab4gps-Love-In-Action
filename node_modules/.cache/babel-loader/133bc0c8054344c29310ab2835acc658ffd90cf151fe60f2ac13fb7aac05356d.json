{"ast":null,"code":"import Color from \"./Color.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nfunction measureText(context2D, textString, font, stroke, fill) {\n  const metrics = context2D.measureText(textString);\n  const isSpace = !/\\S/.test(textString);\n  if (!isSpace) {\n    const fontSize = document.defaultView.getComputedStyle(context2D.canvas).getPropertyValue(\"font-size\").replace(\"px\", \"\");\n    const canvas = document.createElement(\"canvas\");\n    const padding = 100;\n    const width = metrics.width + padding | 0;\n    const height = 3 * fontSize;\n    const baseline = height / 2;\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.font = font;\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvas.width + 1, canvas.height + 1);\n    if (stroke) {\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = context2D.lineWidth;\n      ctx.strokeText(textString, padding / 2, baseline);\n    }\n    if (fill) {\n      ctx.fillStyle = \"black\";\n      ctx.fillText(textString, padding / 2, baseline);\n    }\n\n    // Context image data has width * height * 4 elements, because\n    // each pixel's R, G, B and A are consecutive values in the array.\n    const pixelData = ctx.getImageData(0, 0, width, height).data;\n    const length = pixelData.length;\n    const width4 = width * 4;\n    let i, j;\n    let ascent, descent;\n    // Find the number of rows (from the top) until the first non-white pixel\n    for (i = 0; i < length; ++i) {\n      if (pixelData[i] !== 255) {\n        ascent = i / width4 | 0;\n        break;\n      }\n    }\n\n    // Find the number of rows (from the bottom) until the first non-white pixel\n    for (i = length - 1; i >= 0; --i) {\n      if (pixelData[i] !== 255) {\n        descent = i / width4 | 0;\n        break;\n      }\n    }\n    let minx = -1;\n    // For each column, for each row, check for first non-white pixel\n    for (i = 0; i < width && minx === -1; ++i) {\n      for (j = 0; j < height; ++j) {\n        const pixelIndex = i * 4 + j * width4;\n        if (pixelData[pixelIndex] !== 255 || pixelData[pixelIndex + 1] !== 255 || pixelData[pixelIndex + 2] !== 255 || pixelData[pixelIndex + 3] !== 255) {\n          minx = i;\n          break;\n        }\n      }\n    }\n    return {\n      width: metrics.width,\n      height: descent - ascent,\n      ascent: baseline - ascent,\n      descent: descent - baseline,\n      minx: minx - padding / 2\n    };\n  }\n  return {\n    width: metrics.width,\n    height: 0,\n    ascent: 0,\n    descent: 0,\n    minx: 0\n  };\n}\nlet imageSmoothingEnabledName;\n\n/**\n * Writes the given text into a new canvas.  The canvas will be sized to fit the text.\n * If text is blank, returns undefined.\n *\n * @param {string} text The text to write.\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.font='10px sans-serif'] The CSS font to use.\n * @param {string} [options.textBaseline='bottom'] The baseline of the text.\n * @param {boolean} [options.fill=true] Whether to fill the text.\n * @param {boolean} [options.stroke=false] Whether to stroke the text.\n * @param {Color} [options.fillColor=Color.WHITE] The fill color.\n * @param {Color} [options.strokeColor=Color.BLACK] The stroke color.\n * @param {number} [options.strokeWidth=1] The stroke width.\n * @param {Color} [options.backgroundColor=Color.TRANSPARENT] The background color of the canvas.\n * @param {number} [options.padding=0] The pixel size of the padding to add around the text.\n * @returns {HTMLCanvasElement|undefined} A new canvas with the given text drawn into it.  The dimensions object\n *                   from measureText will also be added to the returned canvas. If text is\n *                   blank, returns undefined.\n * @function writeTextToCanvas\n */\nfunction writeTextToCanvas(text, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(text)) {\n    throw new DeveloperError(\"text is required.\");\n  }\n  //>>includeEnd('debug');\n  if (text === \"\") {\n    return undefined;\n  }\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const font = defaultValue(options.font, \"10px sans-serif\");\n  const stroke = defaultValue(options.stroke, false);\n  const fill = defaultValue(options.fill, true);\n  const strokeWidth = defaultValue(options.strokeWidth, 1);\n  const backgroundColor = defaultValue(options.backgroundColor, Color.TRANSPARENT);\n  const padding = defaultValue(options.padding, 0);\n  const doublePadding = padding * 2.0;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  canvas.style.font = font;\n  // Since multiple read-back operations are expected for labels, use the willReadFrequently option â€“ See https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently\n  const context2D = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  if (!defined(imageSmoothingEnabledName)) {\n    if (defined(context2D.imageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"imageSmoothingEnabled\";\n    } else if (defined(context2D.mozImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"mozImageSmoothingEnabled\";\n    } else if (defined(context2D.webkitImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"webkitImageSmoothingEnabled\";\n    } else if (defined(context2D.msImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"msImageSmoothingEnabled\";\n    }\n  }\n  context2D.font = font;\n  context2D.lineJoin = \"round\";\n  context2D.lineWidth = strokeWidth;\n  context2D[imageSmoothingEnabledName] = false;\n\n  // in order for measureText to calculate style, the canvas has to be\n  // (temporarily) added to the DOM.\n  canvas.style.visibility = \"hidden\";\n  document.body.appendChild(canvas);\n  const dimensions = measureText(context2D, text, font, stroke, fill);\n  // Set canvas.dimensions to be accessed in LabelCollection\n  canvas.dimensions = dimensions;\n  document.body.removeChild(canvas);\n  canvas.style.visibility = \"\";\n\n  // Some characters, such as the letter j, have a non-zero starting position.\n  // This value is used for kerning later, but we need to take it into account\n  // now in order to draw the text completely on the canvas\n  const x = -dimensions.minx;\n\n  // Expand the width to include the starting position.\n  const width = Math.ceil(dimensions.width) + x + doublePadding;\n\n  // While the height of the letter is correct, we need to adjust\n  // where we start drawing it so that letters like j and y properly dip\n  // below the line.\n\n  const height = dimensions.height + doublePadding;\n  const baseline = height - dimensions.ascent + padding;\n  const y = height - baseline + doublePadding;\n  canvas.width = width;\n  canvas.height = height;\n\n  // Properties must be explicitly set again after changing width and height\n  context2D.font = font;\n  context2D.lineJoin = \"round\";\n  context2D.lineWidth = strokeWidth;\n  context2D[imageSmoothingEnabledName] = false;\n\n  // Draw background\n  if (backgroundColor !== Color.TRANSPARENT) {\n    context2D.fillStyle = backgroundColor.toCssColorString();\n    context2D.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  if (stroke) {\n    const strokeColor = defaultValue(options.strokeColor, Color.BLACK);\n    context2D.strokeStyle = strokeColor.toCssColorString();\n    context2D.strokeText(text, x + padding, y);\n  }\n  if (fill) {\n    const fillColor = defaultValue(options.fillColor, Color.WHITE);\n    context2D.fillStyle = fillColor.toCssColorString();\n    context2D.fillText(text, x + padding, y);\n  }\n  return canvas;\n}\nexport default writeTextToCanvas;","map":{"version":3,"names":["Color","defaultValue","defined","DeveloperError","measureText","context2D","textString","font","stroke","fill","metrics","isSpace","test","fontSize","document","defaultView","getComputedStyle","canvas","getPropertyValue","replace","createElement","padding","width","height","baseline","ctx","getContext","fillStyle","fillRect","strokeStyle","lineWidth","strokeText","fillText","pixelData","getImageData","data","length","width4","i","j","ascent","descent","minx","pixelIndex","imageSmoothingEnabledName","writeTextToCanvas","text","options","undefined","EMPTY_OBJECT","strokeWidth","backgroundColor","TRANSPARENT","doublePadding","style","willReadFrequently","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","lineJoin","visibility","body","appendChild","dimensions","removeChild","x","Math","ceil","y","toCssColorString","strokeColor","BLACK","fillColor","WHITE"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/writeTextToCanvas.js"],"sourcesContent":["import Color from \"./Color.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\nfunction measureText(context2D, textString, font, stroke, fill) {\n  const metrics = context2D.measureText(textString);\n  const isSpace = !/\\S/.test(textString);\n\n  if (!isSpace) {\n    const fontSize = document.defaultView\n      .getComputedStyle(context2D.canvas)\n      .getPropertyValue(\"font-size\")\n      .replace(\"px\", \"\");\n    const canvas = document.createElement(\"canvas\");\n    const padding = 100;\n    const width = (metrics.width + padding) | 0;\n    const height = 3 * fontSize;\n    const baseline = height / 2;\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext(\"2d\");\n    ctx.font = font;\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvas.width + 1, canvas.height + 1);\n\n    if (stroke) {\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = context2D.lineWidth;\n      ctx.strokeText(textString, padding / 2, baseline);\n    }\n\n    if (fill) {\n      ctx.fillStyle = \"black\";\n      ctx.fillText(textString, padding / 2, baseline);\n    }\n\n    // Context image data has width * height * 4 elements, because\n    // each pixel's R, G, B and A are consecutive values in the array.\n    const pixelData = ctx.getImageData(0, 0, width, height).data;\n    const length = pixelData.length;\n    const width4 = width * 4;\n    let i, j;\n\n    let ascent, descent;\n    // Find the number of rows (from the top) until the first non-white pixel\n    for (i = 0; i < length; ++i) {\n      if (pixelData[i] !== 255) {\n        ascent = (i / width4) | 0;\n        break;\n      }\n    }\n\n    // Find the number of rows (from the bottom) until the first non-white pixel\n    for (i = length - 1; i >= 0; --i) {\n      if (pixelData[i] !== 255) {\n        descent = (i / width4) | 0;\n        break;\n      }\n    }\n\n    let minx = -1;\n    // For each column, for each row, check for first non-white pixel\n    for (i = 0; i < width && minx === -1; ++i) {\n      for (j = 0; j < height; ++j) {\n        const pixelIndex = i * 4 + j * width4;\n        if (\n          pixelData[pixelIndex] !== 255 ||\n          pixelData[pixelIndex + 1] !== 255 ||\n          pixelData[pixelIndex + 2] !== 255 ||\n          pixelData[pixelIndex + 3] !== 255\n        ) {\n          minx = i;\n          break;\n        }\n      }\n    }\n\n    return {\n      width: metrics.width,\n      height: descent - ascent,\n      ascent: baseline - ascent,\n      descent: descent - baseline,\n      minx: minx - padding / 2,\n    };\n  }\n\n  return {\n    width: metrics.width,\n    height: 0,\n    ascent: 0,\n    descent: 0,\n    minx: 0,\n  };\n}\n\nlet imageSmoothingEnabledName;\n\n/**\n * Writes the given text into a new canvas.  The canvas will be sized to fit the text.\n * If text is blank, returns undefined.\n *\n * @param {string} text The text to write.\n * @param {object} [options] Object with the following properties:\n * @param {string} [options.font='10px sans-serif'] The CSS font to use.\n * @param {string} [options.textBaseline='bottom'] The baseline of the text.\n * @param {boolean} [options.fill=true] Whether to fill the text.\n * @param {boolean} [options.stroke=false] Whether to stroke the text.\n * @param {Color} [options.fillColor=Color.WHITE] The fill color.\n * @param {Color} [options.strokeColor=Color.BLACK] The stroke color.\n * @param {number} [options.strokeWidth=1] The stroke width.\n * @param {Color} [options.backgroundColor=Color.TRANSPARENT] The background color of the canvas.\n * @param {number} [options.padding=0] The pixel size of the padding to add around the text.\n * @returns {HTMLCanvasElement|undefined} A new canvas with the given text drawn into it.  The dimensions object\n *                   from measureText will also be added to the returned canvas. If text is\n *                   blank, returns undefined.\n * @function writeTextToCanvas\n */\nfunction writeTextToCanvas(text, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(text)) {\n    throw new DeveloperError(\"text is required.\");\n  }\n  //>>includeEnd('debug');\n  if (text === \"\") {\n    return undefined;\n  }\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const font = defaultValue(options.font, \"10px sans-serif\");\n  const stroke = defaultValue(options.stroke, false);\n  const fill = defaultValue(options.fill, true);\n  const strokeWidth = defaultValue(options.strokeWidth, 1);\n  const backgroundColor = defaultValue(\n    options.backgroundColor,\n    Color.TRANSPARENT,\n  );\n  const padding = defaultValue(options.padding, 0);\n  const doublePadding = padding * 2.0;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  canvas.style.font = font;\n  // Since multiple read-back operations are expected for labels, use the willReadFrequently option â€“ See https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently\n  const context2D = canvas.getContext(\"2d\", { willReadFrequently: true });\n\n  if (!defined(imageSmoothingEnabledName)) {\n    if (defined(context2D.imageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"imageSmoothingEnabled\";\n    } else if (defined(context2D.mozImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"mozImageSmoothingEnabled\";\n    } else if (defined(context2D.webkitImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"webkitImageSmoothingEnabled\";\n    } else if (defined(context2D.msImageSmoothingEnabled)) {\n      imageSmoothingEnabledName = \"msImageSmoothingEnabled\";\n    }\n  }\n\n  context2D.font = font;\n  context2D.lineJoin = \"round\";\n  context2D.lineWidth = strokeWidth;\n  context2D[imageSmoothingEnabledName] = false;\n\n  // in order for measureText to calculate style, the canvas has to be\n  // (temporarily) added to the DOM.\n  canvas.style.visibility = \"hidden\";\n  document.body.appendChild(canvas);\n\n  const dimensions = measureText(context2D, text, font, stroke, fill);\n  // Set canvas.dimensions to be accessed in LabelCollection\n  canvas.dimensions = dimensions;\n\n  document.body.removeChild(canvas);\n  canvas.style.visibility = \"\";\n\n  // Some characters, such as the letter j, have a non-zero starting position.\n  // This value is used for kerning later, but we need to take it into account\n  // now in order to draw the text completely on the canvas\n  const x = -dimensions.minx;\n\n  // Expand the width to include the starting position.\n  const width = Math.ceil(dimensions.width) + x + doublePadding;\n\n  // While the height of the letter is correct, we need to adjust\n  // where we start drawing it so that letters like j and y properly dip\n  // below the line.\n\n  const height = dimensions.height + doublePadding;\n  const baseline = height - dimensions.ascent + padding;\n  const y = height - baseline + doublePadding;\n\n  canvas.width = width;\n  canvas.height = height;\n\n  // Properties must be explicitly set again after changing width and height\n  context2D.font = font;\n  context2D.lineJoin = \"round\";\n  context2D.lineWidth = strokeWidth;\n  context2D[imageSmoothingEnabledName] = false;\n\n  // Draw background\n  if (backgroundColor !== Color.TRANSPARENT) {\n    context2D.fillStyle = backgroundColor.toCssColorString();\n    context2D.fillRect(0, 0, canvas.width, canvas.height);\n  }\n\n  if (stroke) {\n    const strokeColor = defaultValue(options.strokeColor, Color.BLACK);\n    context2D.strokeStyle = strokeColor.toCssColorString();\n    context2D.strokeText(text, x + padding, y);\n  }\n\n  if (fill) {\n    const fillColor = defaultValue(options.fillColor, Color.WHITE);\n    context2D.fillStyle = fillColor.toCssColorString();\n    context2D.fillText(text, x + padding, y);\n  }\n\n  return canvas;\n}\nexport default writeTextToCanvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}