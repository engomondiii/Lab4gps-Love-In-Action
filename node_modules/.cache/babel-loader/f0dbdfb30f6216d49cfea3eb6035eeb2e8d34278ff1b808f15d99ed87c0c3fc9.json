{"ast":null,"code":"import defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport ModelAnimation from \"./ModelAnimation.js\";\nimport ModelAnimationLoop from \".././ModelAnimationLoop.js\";\nimport ModelAnimationState from \".././ModelAnimationState.js\";\n\n/**\n * <div class=\"notice\">\n * Access a model's animations {@link Model#activeAnimations}. Do not call the constructor directly\n * </div>\n *\n * A collection of active model animations.\n *\n * @alias ModelAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see Model#activeAnimations\n */\nfunction ModelAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log(`Animation added: ${animation.name}`);\n   * });\n   */\n  this.animationAdded = new Event();\n\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log(`Animation removed: ${animation.name}`);\n   * });\n   */\n  this.animationRemoved = new Event();\n\n  /**\n   * When true, the animation will play even when the scene time is paused. However,\n   * whether animation takes place will depend on the animationTime functions assigned\n   * to the model's animations. By default, this is based on scene time, so models using\n   * the default will not animate regardless of this setting.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.animateWhilePaused = false;\n  this._model = model;\n  this._runtimeAnimations = [];\n  this._previousTime = undefined;\n}\nObject.defineProperties(ModelAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._runtimeAnimations.length;\n    }\n  },\n  /**\n   * The model that owns this animation collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {Model}\n   * @readonly\n   */\n  model: {\n    get: function () {\n      return this._model;\n    }\n  }\n});\nfunction addAnimation(collection, animation, options) {\n  const model = collection._model;\n  const runtimeAnimation = new ModelAnimation(model, animation, options);\n  collection._runtimeAnimations.push(runtimeAnimation);\n  collection.animationAdded.raiseEvent(model, runtimeAnimation);\n  return runtimeAnimation;\n}\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for this animation.\n * @returns {ModelAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#ready} to return trues.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * @example\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * const startTime = Cesium.JulianDate.now();\n *\n * const animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                                 // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                        // Do not remove when animation stops (default)\n *   multiplier : 2.0,                            // Play at double speed\n *   reverse : true,                              // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log(`Animation started: ${animation.name}`);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log(`Animation stopped: ${animation.name}`);\n * });\n */\nModelAnimationCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\"Animations are not loaded.  Wait for Model.ready to be true.\");\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\"Either options.name or options.index must be defined.\");\n  }\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  if (defined(options.index) && (options.index >= animations.length || options.index < 0)) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = options.index;\n  if (defined(index)) {\n    return addAnimation(this, animations[index], options);\n  }\n\n  // Find the index of the animation with the given name\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  }\n  //>>includeEnd('debug');\n\n  return addAnimation(this, animations[index], options);\n};\n\n/**\n * Creates and adds animations with the specified initial properties to the collection\n * for all animations in the model.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations. When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations. When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for all of the animations.\n * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded. Wait for the {@link Model#ready} to return true.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                            // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\nModelAnimationCollection.prototype.addAll = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\"Animations are not loaded.  Wait for Model.ready to be true.\");\n  }\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n  const addedAnimations = [];\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    const animation = addAnimation(this, animations[i], options);\n    addedAnimations.push(animation);\n  }\n  return addedAnimations;\n};\n\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelAnimationCollection#removeOnStop} to\n * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelAnimation} runtimeAnimation The runtime animation to remove.\n * @returns {boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\nModelAnimationCollection.prototype.remove = function (runtimeAnimation) {\n  if (!defined(runtimeAnimation)) {\n    return false;\n  }\n  const animations = this._runtimeAnimations;\n  const i = animations.indexOf(runtimeAnimation);\n  if (i !== -1) {\n    animations.splice(i, 1);\n    this.animationRemoved.raiseEvent(this._model, runtimeAnimation);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\nModelAnimationCollection.prototype.removeAll = function () {\n  const model = this._model;\n  const animations = this._runtimeAnimations;\n  const length = animations.length;\n  this._runtimeAnimations.length = 0;\n  for (let i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelAnimation} runtimeAnimation The runtime animation to check for.\n * @returns {boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\nModelAnimationCollection.prototype.contains = function (runtimeAnimation) {\n  if (defined(runtimeAnimation)) {\n    return this._runtimeAnimations.indexOf(runtimeAnimation) !== -1;\n  }\n  return false;\n};\n\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {number} index The zero-based index of the animation.\n * @returns {ModelAnimation} The runtime animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\nModelAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  if (index >= this._runtimeAnimations.length || index < 0) {\n    throw new DeveloperError(\"index must be valid within the range of the collection\");\n  }\n  //>>includeEnd('debug');\n\n  return this._runtimeAnimations[index];\n};\nconst animationsToRemove = [];\nfunction createAnimationRemovedFunction(modelAnimationCollection, model, animation) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n\n/**\n * Updates the runtime animations in this collection, removing any animations\n * that have stopped.\n *\n * @param {FrameState} frameState The current frame state.\n * @returns {boolean} <code>true</code> if an animation played during this update, <code>false</code> otherwise.\n *\n * @private\n */\nModelAnimationCollection.prototype.update = function (frameState) {\n  const runtimeAnimations = this._runtimeAnimations;\n  let length = runtimeAnimations.length;\n  if (length === 0) {\n    this._previousTime = undefined;\n    return false;\n  }\n  if (!this.animateWhilePaused && JulianDate.equals(frameState.time, this._previousTime)) {\n    return false;\n  }\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n  let animationOccurred = false;\n  const sceneTime = frameState.time;\n  const model = this._model;\n  for (let i = 0; i < length; ++i) {\n    const runtimeAnimation = runtimeAnimations[i];\n    if (!defined(runtimeAnimation._computedStartTime)) {\n      runtimeAnimation._computedStartTime = JulianDate.addSeconds(defaultValue(runtimeAnimation.startTime, sceneTime), runtimeAnimation.delay, new JulianDate());\n    }\n    if (!defined(runtimeAnimation._duration)) {\n      runtimeAnimation._duration = runtimeAnimation.localStopTime * (1.0 / runtimeAnimation.multiplier);\n    }\n    const startTime = runtimeAnimation._computedStartTime;\n    const duration = runtimeAnimation._duration;\n    const stopTime = runtimeAnimation.stopTime;\n    const pastStartTime = JulianDate.lessThanOrEquals(startTime, sceneTime);\n    const reachedStopTime = defined(stopTime) && JulianDate.greaterThan(sceneTime, stopTime);\n\n    // [0.0, 1.0] normalized local animation time\n    let delta = 0.0;\n    if (duration !== 0.0) {\n      const seconds = JulianDate.secondsDifference(reachedStopTime ? stopTime : sceneTime, startTime);\n      delta = defined(runtimeAnimation._animationTime) ? runtimeAnimation._animationTime(duration, seconds) : seconds / duration;\n    }\n\n    // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    const repeat = runtimeAnimation.loop === ModelAnimationLoop.REPEAT || runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n    const play = (pastStartTime || repeat && !defined(runtimeAnimation.startTime)) && (delta <= 1.0 || repeat) && !reachedStopTime;\n    if (delta === runtimeAnimation._prevAnimationDelta) {\n      const animationStopped = runtimeAnimation._state === ModelAnimationState.STOPPED;\n      // no change to delta, and no change to the animation state means we can\n      // skip the update this time around.\n      if (play !== animationStopped) {\n        continue;\n      }\n    }\n    runtimeAnimation._prevAnimationDelta = delta;\n\n    // If it IS, or WAS, animating...\n    if (play || runtimeAnimation._state === ModelAnimationState.ANIMATING) {\n      // ...transition from STOPPED to ANIMATING\n      if (play && runtimeAnimation._state === ModelAnimationState.STOPPED) {\n        runtimeAnimation._state = ModelAnimationState.ANIMATING;\n        if (runtimeAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStartEvent);\n        }\n      }\n\n      // Truncate to [0.0, 1.0] for repeating animations\n      if (runtimeAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {\n        const floor = Math.floor(delta);\n        const fract = delta - floor;\n        // When odd use (1.0 - fract) to mirror repeat\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n      if (runtimeAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n      let localAnimationTime = delta * duration * runtimeAnimation.multiplier;\n      // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n      localAnimationTime = CesiumMath.clamp(localAnimationTime, runtimeAnimation.localStartTime, runtimeAnimation.localStopTime);\n      runtimeAnimation.animate(localAnimationTime);\n      if (runtimeAnimation.update.numberOfListeners > 0) {\n        runtimeAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(runtimeAnimation._raiseUpdateEvent);\n      }\n      animationOccurred = true;\n      if (!play) {\n        // transition from ANIMATING to STOPPED\n        runtimeAnimation._state = ModelAnimationState.STOPPED;\n        if (runtimeAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStopEvent);\n        }\n        if (runtimeAnimation.removeOnStop) {\n          animationsToRemove.push(runtimeAnimation);\n        }\n      }\n    }\n  }\n\n  // Remove animations that stopped\n  length = animationsToRemove.length;\n  for (let j = 0; j < length; ++j) {\n    const animationToRemove = animationsToRemove[j];\n    runtimeAnimations.splice(runtimeAnimations.indexOf(animationToRemove), 1);\n    frameState.afterRender.push(createAnimationRemovedFunction(this, model, animationToRemove));\n  }\n  animationsToRemove.length = 0;\n  return animationOccurred;\n};\nexport default ModelAnimationCollection;","map":{"version":3,"names":["defaultValue","defined","DeveloperError","Event","JulianDate","CesiumMath","ModelAnimation","ModelAnimationLoop","ModelAnimationState","ModelAnimationCollection","model","animationAdded","animationRemoved","animateWhilePaused","_model","_runtimeAnimations","_previousTime","undefined","Object","defineProperties","prototype","length","get","addAnimation","collection","animation","options","runtimeAnimation","push","raiseEvent","add","EMPTY_OBJECT","ready","animations","sceneGraph","components","name","index","multiplier","i","addAll","addedAnimations","remove","indexOf","splice","removeAll","contains","animationsToRemove","createAnimationRemovedFunction","modelAnimationCollection","update","frameState","runtimeAnimations","equals","time","clone","animationOccurred","sceneTime","_computedStartTime","addSeconds","startTime","delay","_duration","localStopTime","duration","stopTime","pastStartTime","lessThanOrEquals","reachedStopTime","greaterThan","delta","seconds","secondsDifference","_animationTime","repeat","loop","REPEAT","MIRRORED_REPEAT","play","_prevAnimationDelta","animationStopped","_state","STOPPED","ANIMATING","start","numberOfListeners","afterRender","_raiseStartEvent","Math","floor","fract","reverse","localAnimationTime","clamp","localStartTime","animate","_updateEventTime","_raiseUpdateEvent","stop","_raiseStopEvent","removeOnStop","j","animationToRemove"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelAnimationCollection.js"],"sourcesContent":["import defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport ModelAnimation from \"./ModelAnimation.js\";\nimport ModelAnimationLoop from \".././ModelAnimationLoop.js\";\nimport ModelAnimationState from \".././ModelAnimationState.js\";\n\n/**\n * <div class=\"notice\">\n * Access a model's animations {@link Model#activeAnimations}. Do not call the constructor directly\n * </div>\n *\n * A collection of active model animations.\n *\n * @alias ModelAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see Model#activeAnimations\n */\nfunction ModelAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log(`Animation added: ${animation.name}`);\n   * });\n   */\n  this.animationAdded = new Event();\n\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log(`Animation removed: ${animation.name}`);\n   * });\n   */\n  this.animationRemoved = new Event();\n\n  /**\n   * When true, the animation will play even when the scene time is paused. However,\n   * whether animation takes place will depend on the animationTime functions assigned\n   * to the model's animations. By default, this is based on scene time, so models using\n   * the default will not animate regardless of this setting.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.animateWhilePaused = false;\n\n  this._model = model;\n  this._runtimeAnimations = [];\n  this._previousTime = undefined;\n}\n\nObject.defineProperties(ModelAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._runtimeAnimations.length;\n    },\n  },\n\n  /**\n   * The model that owns this animation collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {Model}\n   * @readonly\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n});\n\nfunction addAnimation(collection, animation, options) {\n  const model = collection._model;\n  const runtimeAnimation = new ModelAnimation(model, animation, options);\n  collection._runtimeAnimations.push(runtimeAnimation);\n  collection.animationAdded.raiseEvent(model, runtimeAnimation);\n  return runtimeAnimation;\n}\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for this animation.\n * @returns {ModelAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#ready} to return trues.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * @example\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * const startTime = Cesium.JulianDate.now();\n *\n * const animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                                 // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                        // Do not remove when animation stops (default)\n *   multiplier : 2.0,                            // Play at double speed\n *   reverse : true,                              // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log(`Animation started: ${animation.name}`);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log(`Animation stopped: ${animation.name}`);\n * });\n */\nModelAnimationCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.ready to be true.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\n      \"Either options.name or options.index must be defined.\",\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n\n  if (\n    defined(options.index) &&\n    (options.index >= animations.length || options.index < 0)\n  ) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = options.index;\n  if (defined(index)) {\n    return addAnimation(this, animations[index], options);\n  }\n\n  // Find the index of the animation with the given name\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  }\n  //>>includeEnd('debug');\n\n  return addAnimation(this, animations[index], options);\n};\n\n/**\n * Creates and adds animations with the specified initial properties to the collection\n * for all animations in the model.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations. When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations. When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for all of the animations.\n * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded. Wait for the {@link Model#ready} to return true.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                            // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\nModelAnimationCollection.prototype.addAll = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.ready to be true.\",\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  const addedAnimations = [];\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    const animation = addAnimation(this, animations[i], options);\n    addedAnimations.push(animation);\n  }\n  return addedAnimations;\n};\n\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelAnimationCollection#removeOnStop} to\n * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelAnimation} runtimeAnimation The runtime animation to remove.\n * @returns {boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\nModelAnimationCollection.prototype.remove = function (runtimeAnimation) {\n  if (!defined(runtimeAnimation)) {\n    return false;\n  }\n\n  const animations = this._runtimeAnimations;\n  const i = animations.indexOf(runtimeAnimation);\n  if (i !== -1) {\n    animations.splice(i, 1);\n    this.animationRemoved.raiseEvent(this._model, runtimeAnimation);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\nModelAnimationCollection.prototype.removeAll = function () {\n  const model = this._model;\n  const animations = this._runtimeAnimations;\n  const length = animations.length;\n\n  this._runtimeAnimations.length = 0;\n\n  for (let i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelAnimation} runtimeAnimation The runtime animation to check for.\n * @returns {boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\nModelAnimationCollection.prototype.contains = function (runtimeAnimation) {\n  if (defined(runtimeAnimation)) {\n    return this._runtimeAnimations.indexOf(runtimeAnimation) !== -1;\n  }\n\n  return false;\n};\n\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {number} index The zero-based index of the animation.\n * @returns {ModelAnimation} The runtime animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\nModelAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n\n  if (index >= this._runtimeAnimations.length || index < 0) {\n    throw new DeveloperError(\n      \"index must be valid within the range of the collection\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this._runtimeAnimations[index];\n};\n\nconst animationsToRemove = [];\n\nfunction createAnimationRemovedFunction(\n  modelAnimationCollection,\n  model,\n  animation,\n) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n\n/**\n * Updates the runtime animations in this collection, removing any animations\n * that have stopped.\n *\n * @param {FrameState} frameState The current frame state.\n * @returns {boolean} <code>true</code> if an animation played during this update, <code>false</code> otherwise.\n *\n * @private\n */\nModelAnimationCollection.prototype.update = function (frameState) {\n  const runtimeAnimations = this._runtimeAnimations;\n  let length = runtimeAnimations.length;\n\n  if (length === 0) {\n    this._previousTime = undefined;\n    return false;\n  }\n\n  if (\n    !this.animateWhilePaused &&\n    JulianDate.equals(frameState.time, this._previousTime)\n  ) {\n    return false;\n  }\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n\n  let animationOccurred = false;\n  const sceneTime = frameState.time;\n  const model = this._model;\n\n  for (let i = 0; i < length; ++i) {\n    const runtimeAnimation = runtimeAnimations[i];\n\n    if (!defined(runtimeAnimation._computedStartTime)) {\n      runtimeAnimation._computedStartTime = JulianDate.addSeconds(\n        defaultValue(runtimeAnimation.startTime, sceneTime),\n        runtimeAnimation.delay,\n        new JulianDate(),\n      );\n    }\n\n    if (!defined(runtimeAnimation._duration)) {\n      runtimeAnimation._duration =\n        runtimeAnimation.localStopTime * (1.0 / runtimeAnimation.multiplier);\n    }\n\n    const startTime = runtimeAnimation._computedStartTime;\n    const duration = runtimeAnimation._duration;\n    const stopTime = runtimeAnimation.stopTime;\n\n    const pastStartTime = JulianDate.lessThanOrEquals(startTime, sceneTime);\n    const reachedStopTime =\n      defined(stopTime) && JulianDate.greaterThan(sceneTime, stopTime);\n\n    // [0.0, 1.0] normalized local animation time\n    let delta = 0.0;\n    if (duration !== 0.0) {\n      const seconds = JulianDate.secondsDifference(\n        reachedStopTime ? stopTime : sceneTime,\n        startTime,\n      );\n      delta = defined(runtimeAnimation._animationTime)\n        ? runtimeAnimation._animationTime(duration, seconds)\n        : seconds / duration;\n    }\n\n    // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    const repeat =\n      runtimeAnimation.loop === ModelAnimationLoop.REPEAT ||\n      runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n\n    const play =\n      (pastStartTime || (repeat && !defined(runtimeAnimation.startTime))) &&\n      (delta <= 1.0 || repeat) &&\n      !reachedStopTime;\n\n    if (delta === runtimeAnimation._prevAnimationDelta) {\n      const animationStopped =\n        runtimeAnimation._state === ModelAnimationState.STOPPED;\n      // no change to delta, and no change to the animation state means we can\n      // skip the update this time around.\n      if (play !== animationStopped) {\n        continue;\n      }\n    }\n    runtimeAnimation._prevAnimationDelta = delta;\n\n    // If it IS, or WAS, animating...\n    if (play || runtimeAnimation._state === ModelAnimationState.ANIMATING) {\n      // ...transition from STOPPED to ANIMATING\n      if (play && runtimeAnimation._state === ModelAnimationState.STOPPED) {\n        runtimeAnimation._state = ModelAnimationState.ANIMATING;\n        if (runtimeAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStartEvent);\n        }\n      }\n\n      // Truncate to [0.0, 1.0] for repeating animations\n      if (runtimeAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {\n        const floor = Math.floor(delta);\n        const fract = delta - floor;\n        // When odd use (1.0 - fract) to mirror repeat\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n\n      if (runtimeAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n\n      let localAnimationTime = delta * duration * runtimeAnimation.multiplier;\n      // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n      localAnimationTime = CesiumMath.clamp(\n        localAnimationTime,\n        runtimeAnimation.localStartTime,\n        runtimeAnimation.localStopTime,\n      );\n\n      runtimeAnimation.animate(localAnimationTime);\n\n      if (runtimeAnimation.update.numberOfListeners > 0) {\n        runtimeAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(runtimeAnimation._raiseUpdateEvent);\n      }\n      animationOccurred = true;\n\n      if (!play) {\n        // transition from ANIMATING to STOPPED\n        runtimeAnimation._state = ModelAnimationState.STOPPED;\n        if (runtimeAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStopEvent);\n        }\n\n        if (runtimeAnimation.removeOnStop) {\n          animationsToRemove.push(runtimeAnimation);\n        }\n      }\n    }\n  }\n\n  // Remove animations that stopped\n  length = animationsToRemove.length;\n  for (let j = 0; j < length; ++j) {\n    const animationToRemove = animationsToRemove[j];\n    runtimeAnimations.splice(runtimeAnimations.indexOf(animationToRemove), 1);\n    frameState.afterRender.push(\n      createAnimationRemovedFunction(this, model, animationToRemove),\n    );\n  }\n  animationsToRemove.length = 0;\n\n  return animationOccurred;\n};\n\nexport default ModelAnimationCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}