{"ast":null,"code":"import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport GeometryStageFS from \"../../Shaders/Model/GeometryStageFS.js\";\nimport GeometryStageVS from \"../../Shaders/Model/GeometryStageVS.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SelectedFeatureIdPipelineStage from \"./SelectedFeatureIdPipelineStage.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The geometry pipeline stage processes the vertex attributes of a primitive.\n *\n * @namespace GeometryPipelineStage\n *\n * @private\n */\nconst GeometryPipelineStage = {\n  name: \"GeometryPipelineStage\",\n  // Helps with debugging\n\n  STRUCT_ID_PROCESSED_ATTRIBUTES_VS: \"ProcessedAttributesVS\",\n  STRUCT_ID_PROCESSED_ATTRIBUTES_FS: \"ProcessedAttributesFS\",\n  STRUCT_NAME_PROCESSED_ATTRIBUTES: \"ProcessedAttributes\",\n  FUNCTION_ID_INITIALIZE_ATTRIBUTES: \"initializeAttributes\",\n  FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES: \"void initializeAttributes(out ProcessedAttributes attributes)\",\n  FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS: \"setDynamicVaryingsVS\",\n  FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS: \"setDynamicVaryingsFS\",\n  FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS: \"void setDynamicVaryings(inout ProcessedAttributes attributes)\"\n};\n\n/**\n * This pipeline stage processes the vertex attributes of a primitive,\n * adding attribute declarations to the shaders, adding attribute objects to the\n * render resources, and setting define flags as needed.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute and varying declarations for the vertex attributes in the vertex and fragment shaders\n *  <li> creates the objects required to create VertexArrays\n *  <li> sets the flag for point primitive types\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds a struct field for the 2D positions\n *  <li> adds an additional attribute object and declaration if the node containing this primitive is not instanced\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nGeometryPipelineStage.process = function (renderResources, primitive, frameState) {\n  const {\n    shaderBuilder,\n    model\n  } = renderResources;\n\n  // These structs are similar, though the fragment shader version has a couple\n  // additional fields.\n  shaderBuilder.addStruct(GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS, \"ProcessedAttributes\", ShaderDestination.VERTEX);\n  shaderBuilder.addStruct(GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, \"ProcessedAttributes\", ShaderDestination.FRAGMENT);\n\n  // The Feature struct is always added since it's required for compilation.\n  // It may be unused if features are not present.\n  shaderBuilder.addStruct(SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE, SelectedFeatureIdPipelineStage.STRUCT_NAME_SELECTED_FEATURE, ShaderDestination.BOTH);\n\n  // This initialization function is only needed in the vertex shader,\n  // it assigns the non-quantized attribute struct fields from the\n  // physical attributes\n  shaderBuilder.addFunction(GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES, GeometryPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES, ShaderDestination.VERTEX);\n\n  // Positions in other coordinate systems need more variables\n  shaderBuilder.addVarying(\"vec3\", \"v_positionWC\");\n  shaderBuilder.addVarying(\"vec3\", \"v_positionEC\");\n  shaderBuilder.addStructField(GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, \"vec3\", \"positionWC\");\n  shaderBuilder.addStructField(GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, \"vec3\", \"positionEC\");\n\n  // Though they have identical signatures, the implementation is different\n  // between vertex and fragment shaders. The VS stores attributes in\n  // varyings, while the FS unpacks the varyings for use by other stages.\n  shaderBuilder.addFunction(GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS, GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS, ShaderDestination.VERTEX);\n  shaderBuilder.addFunction(GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS, GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS, ShaderDestination.FRAGMENT);\n\n  // .pnts point clouds store sRGB color rather than linear color\n  if (model.type === ModelType.TILE_PNTS) {\n    shaderBuilder.addDefine(\"HAS_SRGB_COLOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n\n  // Attributes, structs, and functions will need to be modified for 2D / CV.\n  const use2D = frameState.mode !== SceneMode.SCENE3D && !frameState.scene3DOnly && model._projectTo2D;\n\n  // If the model is instanced, the work for 2D projection will have been done\n  // in InstancingPipelineStage. The attribute struct will be updated with\n  // position2D, but nothing else should be modified.\n  const instanced = defined(renderResources.runtimeNode.node.instances);\n\n  // If the scene is in 3D or the model is instanced, the 2D position attribute\n  // is not needed, so don't increment attributeIndex.\n  const incrementIndexFor2D = use2D && !instanced;\n  const length = primitive.attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = primitive.attributes[i];\n    const attributeLocationCount = AttributeType.getAttributeLocationCount(attribute.type);\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(attribute.buffer) && !defined(attribute.constant)) {\n      throw new DeveloperError(\"Attributes must be provided as a Buffer or constant value\");\n    }\n    //>>includeEnd('debug');\n\n    const isPositionAttribute = attribute.semantic === VertexAttributeSemantic.POSITION;\n    let index;\n    if (attributeLocationCount > 1) {\n      index = renderResources.attributeIndex;\n      renderResources.attributeIndex += attributeLocationCount;\n    } else if (isPositionAttribute && !incrementIndexFor2D) {\n      index = 0;\n    } else {\n      index = renderResources.attributeIndex++;\n    }\n    processAttribute(renderResources, attribute, index, attributeLocationCount, use2D, instanced);\n  }\n  handleBitangents(shaderBuilder, primitive.attributes);\n  if (primitive.primitiveType === PrimitiveType.POINTS) {\n    shaderBuilder.addDefine(\"PRIMITIVE_TYPE_POINTS\");\n  }\n  shaderBuilder.addVertexLines(GeometryStageVS);\n  shaderBuilder.addFragmentLines(GeometryStageFS);\n};\nfunction processAttribute(renderResources, attribute, attributeIndex, attributeLocationCount, use2D, instanced) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const attributeInfo = ModelUtility.getAttributeInfo(attribute);\n\n  // This indicates to only modify the resources for 2D if the model is\n  // not instanced.\n  const modifyFor2D = use2D && !instanced;\n  if (attributeLocationCount > 1) {\n    // Matrices are stored as multiple attributes, one per column vector.\n    addMatrixAttributeToRenderResources(renderResources, attribute, attributeIndex, attributeLocationCount);\n  } else {\n    addAttributeToRenderResources(renderResources, attribute, attributeIndex, modifyFor2D);\n  }\n  addAttributeDeclaration(shaderBuilder, attributeInfo, modifyFor2D);\n  addVaryingDeclaration(shaderBuilder, attributeInfo);\n\n  // For common attributes like normals and tangents, the code is\n  // already in GeometryStageVS, we just need to enable it.\n  if (defined(attribute.semantic)) {\n    addSemanticDefine(shaderBuilder, attribute);\n  }\n\n  // Dynamically generate GLSL code for the current attribute.\n  // For 2D projection, the position2D field will always be added\n  // to the attributes struct, even if the model is instanced.\n  updateAttributesStruct(shaderBuilder, attributeInfo, use2D);\n  updateInitializeAttributesFunction(shaderBuilder, attributeInfo, modifyFor2D);\n  updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo);\n}\nfunction addSemanticDefine(shaderBuilder, attribute) {\n  const {\n    semantic,\n    setIndex\n  } = attribute;\n  switch (semantic) {\n    case VertexAttributeSemantic.NORMAL:\n      shaderBuilder.addDefine(\"HAS_NORMALS\");\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      shaderBuilder.addDefine(\"HAS_TANGENTS\");\n      break;\n    case VertexAttributeSemantic.FEATURE_ID:\n      // `_FEATURE_ID starts with an underscore so no need to double the\n      // underscore.\n      shaderBuilder.addDefine(`HAS${semantic}_${setIndex}`);\n      break;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n      shaderBuilder.addDefine(`HAS_${semantic}_${setIndex}`);\n  }\n}\nfunction addAttributeToRenderResources(renderResources, attribute, attributeIndex, modifyFor2D) {\n  const {\n    quantization,\n    semantic,\n    setIndex\n  } = attribute;\n  const {\n    type,\n    componentDatatype\n  } = defined(quantization) ? quantization : attribute;\n  if (semantic === VertexAttributeSemantic.FEATURE_ID && setIndex >= renderResources.featureIdVertexAttributeSetIndex) {\n    renderResources.featureIdVertexAttributeSetIndex = setIndex + 1;\n  }\n\n  // The position attribute should always be in the first index.\n  const isPositionAttribute = semantic === VertexAttributeSemantic.POSITION;\n  const index = isPositionAttribute ? 0 : attributeIndex;\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n  const vertexAttribute = {\n    index: index,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized\n  };\n  renderResources.attributes.push(vertexAttribute);\n  if (!isPositionAttribute || !modifyFor2D) {\n    return;\n  }\n\n  // Add an additional attribute for the projected positions in 2D / CV.\n  const buffer2D = renderResources.runtimePrimitive.positionBuffer2D;\n  const positionAttribute2D = {\n    index: attributeIndex,\n    vertexBuffer: buffer2D,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: ComponentDatatype.FLOAT,\n    // Projected positions will always be floats.\n    offsetInBytes: 0,\n    strideInBytes: undefined,\n    normalize: attribute.normalized\n  };\n  renderResources.attributes.push(positionAttribute2D);\n}\nfunction addMatrixAttributeToRenderResources(renderResources, attribute, attributeIndex, columnCount) {\n  const {\n    quantization,\n    normalized\n  } = attribute;\n  const {\n    type,\n    componentDatatype\n  } = defined(quantization) ? quantization : attribute;\n\n  // componentCount is either 4, 9 or 16\n  const componentCount = AttributeType.getNumberOfComponents(type);\n  // componentsPerColumn is either 2, 3, or 4\n  const componentsPerColumn = componentCount / columnCount;\n  const componentSizeInBytes = ComponentDatatype.getSizeInBytes(componentDatatype);\n  const columnLengthInBytes = componentsPerColumn * componentSizeInBytes;\n\n  // The stride between corresponding columns of two matrices is constant\n  // regardless of where you start\n  const strideInBytes = attribute.byteStride;\n  for (let i = 0; i < columnCount; i++) {\n    const offsetInBytes = attribute.byteOffset + i * columnLengthInBytes;\n\n    // upload a single column vector.\n    const columnAttribute = {\n      index: attributeIndex + i,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: componentsPerColumn,\n      componentDatatype: componentDatatype,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n      normalize: normalized\n    };\n    renderResources.attributes.push(columnAttribute);\n  }\n}\nfunction addVaryingDeclaration(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  let varyingName = `v_${variableName}`;\n  let glslType;\n  if (variableName === \"normalMC\") {\n    // though the attribute is in model coordinates, the varying is\n    // in eye coordinates.\n    varyingName = \"v_normalEC\";\n    glslType = attributeInfo.glslType;\n  } else if (variableName === \"tangentMC\") {\n    // Tangent's glslType is vec4, but in the shader it is split into\n    // vec3 tangent and vec3 bitangent\n    glslType = \"vec3\";\n    // like normalMC, the varying is converted to eye coordinates\n    varyingName = \"v_tangentEC\";\n  } else {\n    glslType = attributeInfo.glslType;\n  }\n  shaderBuilder.addVarying(glslType, varyingName);\n}\nfunction addAttributeDeclaration(shaderBuilder, attributeInfo, modifyFor2D) {\n  const semantic = attributeInfo.attribute.semantic;\n  const variableName = attributeInfo.variableName;\n  let attributeName;\n  let glslType;\n  if (attributeInfo.isQuantized) {\n    attributeName = `a_quantized_${variableName}`;\n    glslType = attributeInfo.quantizedGlslType;\n  } else {\n    attributeName = `a_${variableName}`;\n    glslType = attributeInfo.glslType;\n  }\n  const isPosition = semantic === VertexAttributeSemantic.POSITION;\n  if (isPosition) {\n    shaderBuilder.setPositionAttribute(glslType, attributeName);\n  } else {\n    shaderBuilder.addAttribute(glslType, attributeName);\n  }\n  if (isPosition && modifyFor2D) {\n    shaderBuilder.addAttribute(\"vec3\", \"a_position2D\");\n  }\n}\nfunction updateAttributesStruct(shaderBuilder, attributeInfo, use2D) {\n  const vsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS;\n  const fsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS;\n  const {\n    variableName,\n    glslType\n  } = attributeInfo;\n  if (variableName === \"tangentMC\") {\n    // The w component of the tangent is only used for computing the bitangent,\n    // so it can be separated from the other tangent components.\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"tangentMC\");\n    shaderBuilder.addStructField(vsStructId, \"float\", \"tangentSignMC\");\n    // The tangent is in model coordinates in the vertex shader\n    // but in eye space in the fragment coordinates\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"tangentEC\");\n  } else if (variableName === \"normalMC\") {\n    // Normals are in model coordinates in the vertex shader but in eye\n    // coordinates in the fragment shader\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"normalMC\");\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"normalEC\");\n  } else {\n    shaderBuilder.addStructField(vsStructId, glslType, variableName);\n    shaderBuilder.addStructField(fsStructId, glslType, variableName);\n  }\n  if (variableName === \"positionMC\" && use2D) {\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"position2D\");\n  }\n}\nfunction updateInitializeAttributesFunction(shaderBuilder, attributeInfo, use2D) {\n  const functionId = GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES;\n  const variableName = attributeInfo.variableName;\n\n  // If the scene is in 2D / CV mode, this line should always be added\n  // regardless of whether the data is quantized.\n  const use2DPosition = variableName === \"positionMC\" && use2D;\n  if (use2DPosition) {\n    const line = \"attributes.position2D = a_position2D;\";\n    shaderBuilder.addFunctionLines(functionId, [line]);\n  }\n  if (attributeInfo.isQuantized) {\n    // Skip initialization, it will be handled in the dequantization stage.\n    return;\n  }\n  const lines = [];\n  if (variableName === \"tangentMC\") {\n    lines.push(\"attributes.tangentMC = a_tangentMC.xyz;\");\n    lines.push(\"attributes.tangentSignMC = a_tangentMC.w;\");\n  } else {\n    lines.push(`attributes.${variableName} = a_${variableName};`);\n  }\n  shaderBuilder.addFunctionLines(functionId, lines);\n}\nfunction updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo) {\n  const {\n    semantic,\n    setIndex\n  } = attributeInfo.attribute;\n  if (defined(semantic) && !defined(setIndex)) {\n    // positions, normals, and tangents are handled statically in\n    // GeometryStageVS\n    return;\n  }\n\n  // In the vertex shader, we want things like\n  // v_texCoord_1 = attributes.texCoord_1;\n  let functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS;\n  const variableName = attributeInfo.variableName;\n  let line = `v_${variableName} = attributes.${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n\n  // In the fragment shader, we do the opposite:\n  // attributes.texCoord_1 = v_texCoord_1;\n  functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS;\n  line = `attributes.${variableName} = v_${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n}\nfunction handleBitangents(shaderBuilder, attributes) {\n  let hasNormals = false;\n  let hasTangents = false;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic === VertexAttributeSemantic.NORMAL) {\n      hasNormals = true;\n    } else if (attribute.semantic === VertexAttributeSemantic.TANGENT) {\n      hasTangents = true;\n    }\n  }\n\n  // Bitangents are only defined if we have normals and tangents\n  if (!hasNormals || !hasTangents) {\n    return;\n  }\n  shaderBuilder.addDefine(\"HAS_BITANGENTS\");\n  shaderBuilder.addVarying(\"vec3\", \"v_bitangentEC\");\n  shaderBuilder.addStructField(GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS, \"vec3\", \"bitangentMC\");\n  shaderBuilder.addStructField(GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS, \"vec3\", \"bitangentEC\");\n}\nexport default GeometryPipelineStage;","map":{"version":3,"names":["ComponentDatatype","defined","DeveloperError","PrimitiveType","ShaderDestination","GeometryStageFS","GeometryStageVS","AttributeType","SceneMode","ModelType","ModelUtility","SelectedFeatureIdPipelineStage","VertexAttributeSemantic","GeometryPipelineStage","name","STRUCT_ID_PROCESSED_ATTRIBUTES_VS","STRUCT_ID_PROCESSED_ATTRIBUTES_FS","STRUCT_NAME_PROCESSED_ATTRIBUTES","FUNCTION_ID_INITIALIZE_ATTRIBUTES","FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES","FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS","FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS","FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS","process","renderResources","primitive","frameState","shaderBuilder","model","addStruct","VERTEX","FRAGMENT","STRUCT_ID_SELECTED_FEATURE","STRUCT_NAME_SELECTED_FEATURE","BOTH","addFunction","addVarying","addStructField","type","TILE_PNTS","addDefine","undefined","use2D","mode","SCENE3D","scene3DOnly","_projectTo2D","instanced","runtimeNode","node","instances","incrementIndexFor2D","length","attributes","i","attribute","attributeLocationCount","getAttributeLocationCount","buffer","constant","isPositionAttribute","semantic","POSITION","index","attributeIndex","processAttribute","handleBitangents","primitiveType","POINTS","addVertexLines","addFragmentLines","attributeInfo","getAttributeInfo","modifyFor2D","addMatrixAttributeToRenderResources","addAttributeToRenderResources","addAttributeDeclaration","addVaryingDeclaration","addSemanticDefine","updateAttributesStruct","updateInitializeAttributesFunction","updateSetDynamicVaryingsFunction","setIndex","NORMAL","TANGENT","FEATURE_ID","TEXCOORD","COLOR","quantization","componentDatatype","featureIdVertexAttributeSetIndex","componentsPerAttribute","getNumberOfComponents","vertexAttribute","value","vertexBuffer","count","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","push","buffer2D","runtimePrimitive","positionBuffer2D","positionAttribute2D","FLOAT","columnCount","componentCount","componentsPerColumn","componentSizeInBytes","getSizeInBytes","columnLengthInBytes","columnAttribute","variableName","varyingName","glslType","attributeName","isQuantized","quantizedGlslType","isPosition","setPositionAttribute","addAttribute","vsStructId","fsStructId","functionId","use2DPosition","line","addFunctionLines","lines","hasNormals","hasTangents"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/GeometryPipelineStage.js"],"sourcesContent":["import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport GeometryStageFS from \"../../Shaders/Model/GeometryStageFS.js\";\nimport GeometryStageVS from \"../../Shaders/Model/GeometryStageVS.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ModelType from \"./ModelType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SelectedFeatureIdPipelineStage from \"./SelectedFeatureIdPipelineStage.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The geometry pipeline stage processes the vertex attributes of a primitive.\n *\n * @namespace GeometryPipelineStage\n *\n * @private\n */\nconst GeometryPipelineStage = {\n  name: \"GeometryPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_PROCESSED_ATTRIBUTES_VS: \"ProcessedAttributesVS\",\n  STRUCT_ID_PROCESSED_ATTRIBUTES_FS: \"ProcessedAttributesFS\",\n  STRUCT_NAME_PROCESSED_ATTRIBUTES: \"ProcessedAttributes\",\n  FUNCTION_ID_INITIALIZE_ATTRIBUTES: \"initializeAttributes\",\n  FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES:\n    \"void initializeAttributes(out ProcessedAttributes attributes)\",\n  FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS: \"setDynamicVaryingsVS\",\n  FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS: \"setDynamicVaryingsFS\",\n  FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS:\n    \"void setDynamicVaryings(inout ProcessedAttributes attributes)\",\n};\n\n/**\n * This pipeline stage processes the vertex attributes of a primitive,\n * adding attribute declarations to the shaders, adding attribute objects to the\n * render resources, and setting define flags as needed.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute and varying declarations for the vertex attributes in the vertex and fragment shaders\n *  <li> creates the objects required to create VertexArrays\n *  <li> sets the flag for point primitive types\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds a struct field for the 2D positions\n *  <li> adds an additional attribute object and declaration if the node containing this primitive is not instanced\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nGeometryPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, model } = renderResources;\n\n  // These structs are similar, though the fragment shader version has a couple\n  // additional fields.\n  shaderBuilder.addStruct(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\n    \"ProcessedAttributes\",\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"ProcessedAttributes\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  // The Feature struct is always added since it's required for compilation.\n  // It may be unused if features are not present.\n  shaderBuilder.addStruct(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    SelectedFeatureIdPipelineStage.STRUCT_NAME_SELECTED_FEATURE,\n    ShaderDestination.BOTH,\n  );\n\n  // This initialization function is only needed in the vertex shader,\n  // it assigns the non-quantized attribute struct fields from the\n  // physical attributes\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES,\n    ShaderDestination.VERTEX,\n  );\n\n  // Positions in other coordinate systems need more variables\n  shaderBuilder.addVarying(\"vec3\", \"v_positionWC\");\n  shaderBuilder.addVarying(\"vec3\", \"v_positionEC\");\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"positionWC\",\n  );\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"positionEC\",\n  );\n\n  // Though they have identical signatures, the implementation is different\n  // between vertex and fragment shaders. The VS stores attributes in\n  // varyings, while the FS unpacks the varyings for use by other stages.\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // .pnts point clouds store sRGB color rather than linear color\n  if (model.type === ModelType.TILE_PNTS) {\n    shaderBuilder.addDefine(\n      \"HAS_SRGB_COLOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  // Attributes, structs, and functions will need to be modified for 2D / CV.\n  const use2D =\n    frameState.mode !== SceneMode.SCENE3D &&\n    !frameState.scene3DOnly &&\n    model._projectTo2D;\n\n  // If the model is instanced, the work for 2D projection will have been done\n  // in InstancingPipelineStage. The attribute struct will be updated with\n  // position2D, but nothing else should be modified.\n  const instanced = defined(renderResources.runtimeNode.node.instances);\n\n  // If the scene is in 3D or the model is instanced, the 2D position attribute\n  // is not needed, so don't increment attributeIndex.\n  const incrementIndexFor2D = use2D && !instanced;\n  const length = primitive.attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = primitive.attributes[i];\n    const attributeLocationCount = AttributeType.getAttributeLocationCount(\n      attribute.type,\n    );\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(attribute.buffer) && !defined(attribute.constant)) {\n      throw new DeveloperError(\n        \"Attributes must be provided as a Buffer or constant value\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    const isPositionAttribute =\n      attribute.semantic === VertexAttributeSemantic.POSITION;\n\n    let index;\n    if (attributeLocationCount > 1) {\n      index = renderResources.attributeIndex;\n      renderResources.attributeIndex += attributeLocationCount;\n    } else if (isPositionAttribute && !incrementIndexFor2D) {\n      index = 0;\n    } else {\n      index = renderResources.attributeIndex++;\n    }\n\n    processAttribute(\n      renderResources,\n      attribute,\n      index,\n      attributeLocationCount,\n      use2D,\n      instanced,\n    );\n  }\n\n  handleBitangents(shaderBuilder, primitive.attributes);\n\n  if (primitive.primitiveType === PrimitiveType.POINTS) {\n    shaderBuilder.addDefine(\"PRIMITIVE_TYPE_POINTS\");\n  }\n\n  shaderBuilder.addVertexLines(GeometryStageVS);\n  shaderBuilder.addFragmentLines(GeometryStageFS);\n};\n\nfunction processAttribute(\n  renderResources,\n  attribute,\n  attributeIndex,\n  attributeLocationCount,\n  use2D,\n  instanced,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const attributeInfo = ModelUtility.getAttributeInfo(attribute);\n\n  // This indicates to only modify the resources for 2D if the model is\n  // not instanced.\n  const modifyFor2D = use2D && !instanced;\n\n  if (attributeLocationCount > 1) {\n    // Matrices are stored as multiple attributes, one per column vector.\n    addMatrixAttributeToRenderResources(\n      renderResources,\n      attribute,\n      attributeIndex,\n      attributeLocationCount,\n    );\n  } else {\n    addAttributeToRenderResources(\n      renderResources,\n      attribute,\n      attributeIndex,\n      modifyFor2D,\n    );\n  }\n\n  addAttributeDeclaration(shaderBuilder, attributeInfo, modifyFor2D);\n  addVaryingDeclaration(shaderBuilder, attributeInfo);\n\n  // For common attributes like normals and tangents, the code is\n  // already in GeometryStageVS, we just need to enable it.\n  if (defined(attribute.semantic)) {\n    addSemanticDefine(shaderBuilder, attribute);\n  }\n\n  // Dynamically generate GLSL code for the current attribute.\n  // For 2D projection, the position2D field will always be added\n  // to the attributes struct, even if the model is instanced.\n  updateAttributesStruct(shaderBuilder, attributeInfo, use2D);\n  updateInitializeAttributesFunction(shaderBuilder, attributeInfo, modifyFor2D);\n  updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo);\n}\n\nfunction addSemanticDefine(shaderBuilder, attribute) {\n  const { semantic, setIndex } = attribute;\n  switch (semantic) {\n    case VertexAttributeSemantic.NORMAL:\n      shaderBuilder.addDefine(\"HAS_NORMALS\");\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      shaderBuilder.addDefine(\"HAS_TANGENTS\");\n      break;\n    case VertexAttributeSemantic.FEATURE_ID:\n      // `_FEATURE_ID starts with an underscore so no need to double the\n      // underscore.\n      shaderBuilder.addDefine(`HAS${semantic}_${setIndex}`);\n      break;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n      shaderBuilder.addDefine(`HAS_${semantic}_${setIndex}`);\n  }\n}\n\nfunction addAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n  modifyFor2D,\n) {\n  const { quantization, semantic, setIndex } = attribute;\n  const { type, componentDatatype } = defined(quantization)\n    ? quantization\n    : attribute;\n\n  if (\n    semantic === VertexAttributeSemantic.FEATURE_ID &&\n    setIndex >= renderResources.featureIdVertexAttributeSetIndex\n  ) {\n    renderResources.featureIdVertexAttributeSetIndex = setIndex + 1;\n  }\n\n  // The position attribute should always be in the first index.\n  const isPositionAttribute = semantic === VertexAttributeSemantic.POSITION;\n  const index = isPositionAttribute ? 0 : attributeIndex;\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n\n  const vertexAttribute = {\n    index: index,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(vertexAttribute);\n\n  if (!isPositionAttribute || !modifyFor2D) {\n    return;\n  }\n\n  // Add an additional attribute for the projected positions in 2D / CV.\n  const buffer2D = renderResources.runtimePrimitive.positionBuffer2D;\n  const positionAttribute2D = {\n    index: attributeIndex,\n    vertexBuffer: buffer2D,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: ComponentDatatype.FLOAT, // Projected positions will always be floats.\n    offsetInBytes: 0,\n    strideInBytes: undefined,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(positionAttribute2D);\n}\n\nfunction addMatrixAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n  columnCount,\n) {\n  const { quantization, normalized } = attribute;\n  const { type, componentDatatype } = defined(quantization)\n    ? quantization\n    : attribute;\n\n  // componentCount is either 4, 9 or 16\n  const componentCount = AttributeType.getNumberOfComponents(type);\n  // componentsPerColumn is either 2, 3, or 4\n  const componentsPerColumn = componentCount / columnCount;\n\n  const componentSizeInBytes =\n    ComponentDatatype.getSizeInBytes(componentDatatype);\n\n  const columnLengthInBytes = componentsPerColumn * componentSizeInBytes;\n\n  // The stride between corresponding columns of two matrices is constant\n  // regardless of where you start\n  const strideInBytes = attribute.byteStride;\n\n  for (let i = 0; i < columnCount; i++) {\n    const offsetInBytes = attribute.byteOffset + i * columnLengthInBytes;\n\n    // upload a single column vector.\n    const columnAttribute = {\n      index: attributeIndex + i,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: componentsPerColumn,\n      componentDatatype: componentDatatype,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n      normalize: normalized,\n    };\n\n    renderResources.attributes.push(columnAttribute);\n  }\n}\n\nfunction addVaryingDeclaration(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  let varyingName = `v_${variableName}`;\n\n  let glslType;\n  if (variableName === \"normalMC\") {\n    // though the attribute is in model coordinates, the varying is\n    // in eye coordinates.\n    varyingName = \"v_normalEC\";\n    glslType = attributeInfo.glslType;\n  } else if (variableName === \"tangentMC\") {\n    // Tangent's glslType is vec4, but in the shader it is split into\n    // vec3 tangent and vec3 bitangent\n    glslType = \"vec3\";\n    // like normalMC, the varying is converted to eye coordinates\n    varyingName = \"v_tangentEC\";\n  } else {\n    glslType = attributeInfo.glslType;\n  }\n\n  shaderBuilder.addVarying(glslType, varyingName);\n}\n\nfunction addAttributeDeclaration(shaderBuilder, attributeInfo, modifyFor2D) {\n  const semantic = attributeInfo.attribute.semantic;\n  const variableName = attributeInfo.variableName;\n\n  let attributeName;\n  let glslType;\n  if (attributeInfo.isQuantized) {\n    attributeName = `a_quantized_${variableName}`;\n    glslType = attributeInfo.quantizedGlslType;\n  } else {\n    attributeName = `a_${variableName}`;\n    glslType = attributeInfo.glslType;\n  }\n\n  const isPosition = semantic === VertexAttributeSemantic.POSITION;\n  if (isPosition) {\n    shaderBuilder.setPositionAttribute(glslType, attributeName);\n  } else {\n    shaderBuilder.addAttribute(glslType, attributeName);\n  }\n\n  if (isPosition && modifyFor2D) {\n    shaderBuilder.addAttribute(\"vec3\", \"a_position2D\");\n  }\n}\n\nfunction updateAttributesStruct(shaderBuilder, attributeInfo, use2D) {\n  const vsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS;\n  const fsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS;\n  const { variableName, glslType } = attributeInfo;\n\n  if (variableName === \"tangentMC\") {\n    // The w component of the tangent is only used for computing the bitangent,\n    // so it can be separated from the other tangent components.\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"tangentMC\");\n    shaderBuilder.addStructField(vsStructId, \"float\", \"tangentSignMC\");\n    // The tangent is in model coordinates in the vertex shader\n    // but in eye space in the fragment coordinates\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"tangentEC\");\n  } else if (variableName === \"normalMC\") {\n    // Normals are in model coordinates in the vertex shader but in eye\n    // coordinates in the fragment shader\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"normalMC\");\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"normalEC\");\n  } else {\n    shaderBuilder.addStructField(vsStructId, glslType, variableName);\n    shaderBuilder.addStructField(fsStructId, glslType, variableName);\n  }\n\n  if (variableName === \"positionMC\" && use2D) {\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"position2D\");\n  }\n}\n\nfunction updateInitializeAttributesFunction(\n  shaderBuilder,\n  attributeInfo,\n  use2D,\n) {\n  const functionId = GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES;\n  const variableName = attributeInfo.variableName;\n\n  // If the scene is in 2D / CV mode, this line should always be added\n  // regardless of whether the data is quantized.\n  const use2DPosition = variableName === \"positionMC\" && use2D;\n  if (use2DPosition) {\n    const line = \"attributes.position2D = a_position2D;\";\n    shaderBuilder.addFunctionLines(functionId, [line]);\n  }\n\n  if (attributeInfo.isQuantized) {\n    // Skip initialization, it will be handled in the dequantization stage.\n    return;\n  }\n\n  const lines = [];\n  if (variableName === \"tangentMC\") {\n    lines.push(\"attributes.tangentMC = a_tangentMC.xyz;\");\n    lines.push(\"attributes.tangentSignMC = a_tangentMC.w;\");\n  } else {\n    lines.push(`attributes.${variableName} = a_${variableName};`);\n  }\n\n  shaderBuilder.addFunctionLines(functionId, lines);\n}\n\nfunction updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo) {\n  const { semantic, setIndex } = attributeInfo.attribute;\n  if (defined(semantic) && !defined(setIndex)) {\n    // positions, normals, and tangents are handled statically in\n    // GeometryStageVS\n    return;\n  }\n\n  // In the vertex shader, we want things like\n  // v_texCoord_1 = attributes.texCoord_1;\n  let functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS;\n  const variableName = attributeInfo.variableName;\n  let line = `v_${variableName} = attributes.${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n\n  // In the fragment shader, we do the opposite:\n  // attributes.texCoord_1 = v_texCoord_1;\n  functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS;\n  line = `attributes.${variableName} = v_${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n}\n\nfunction handleBitangents(shaderBuilder, attributes) {\n  let hasNormals = false;\n  let hasTangents = false;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic === VertexAttributeSemantic.NORMAL) {\n      hasNormals = true;\n    } else if (attribute.semantic === VertexAttributeSemantic.TANGENT) {\n      hasTangents = true;\n    }\n  }\n\n  // Bitangents are only defined if we have normals and tangents\n  if (!hasNormals || !hasTangents) {\n    return;\n  }\n\n  shaderBuilder.addDefine(\"HAS_BITANGENTS\");\n\n  shaderBuilder.addVarying(\"vec3\", \"v_bitangentEC\");\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\n    \"vec3\",\n    \"bitangentMC\",\n  );\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"bitangentEC\",\n  );\n}\n\nexport default GeometryPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}