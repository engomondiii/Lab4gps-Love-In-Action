{"ast":null,"code":"import Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ImageryLayerFeatureInfo from \"./ImageryLayerFeatureInfo.js\";\n\n/**\n * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.\n *\n * @alias GetFeatureInfoFormat\n * @constructor\n *\n * @param {string} type The type of response to expect from a GetFeatureInfo request.  Valid\n *        values are 'json', 'xml', 'html', or 'text'.\n * @param {string} [format] The info format to request from the WMS server.  This is usually a\n *        MIME type such as 'application/json' or text/xml'.  If this parameter is not specified, the provider will request 'json'\n *        using 'application/json', 'xml' using 'text/xml', 'html' using 'text/html', and 'text' using 'text/plain'.\n * @param {Function} [callback] A function to invoke with the GetFeatureInfo response from the WMS server\n *        in order to produce an array of picked {@link ImageryLayerFeatureInfo} instances.  If this parameter is not specified,\n *        a default function for the type of response is used.\n */\nfunction GetFeatureInfoFormat(type, format, callback) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.type = type;\n  if (!defined(format)) {\n    if (type === \"json\") {\n      format = \"application/json\";\n    } else if (type === \"xml\") {\n      format = \"text/xml\";\n    } else if (type === \"html\") {\n      format = \"text/html\";\n    } else if (type === \"text\") {\n      format = \"text/plain\";\n    }\n    //>>includeStart('debug', pragmas.debug);\n    else {\n      throw new DeveloperError('format is required when type is not \"json\", \"xml\", \"html\", or \"text\".');\n    }\n    //>>includeEnd('debug');\n  }\n  this.format = format;\n  if (!defined(callback)) {\n    if (type === \"json\") {\n      callback = geoJsonToFeatureInfo;\n    } else if (type === \"xml\") {\n      callback = xmlToFeatureInfo;\n    } else if (type === \"html\") {\n      callback = textToFeatureInfo;\n    } else if (type === \"text\") {\n      callback = textToFeatureInfo;\n    }\n    //>>includeStart('debug', pragmas.debug);\n    else {\n      throw new DeveloperError('callback is required when type is not \"json\", \"xml\", \"html\", or \"text\".');\n    }\n    //>>includeEnd('debug');\n  }\n  this.callback = callback;\n}\nfunction geoJsonToFeatureInfo(json) {\n  const result = [];\n  const features = json.features;\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const featureInfo = new ImageryLayerFeatureInfo();\n    featureInfo.data = feature;\n    featureInfo.properties = feature.properties;\n    featureInfo.configureNameFromProperties(feature.properties);\n    featureInfo.configureDescriptionFromProperties(feature.properties);\n\n    // If this is a point feature, use the coordinates of the point.\n    if (defined(feature.geometry) && feature.geometry.type === \"Point\") {\n      const longitude = feature.geometry.coordinates[0];\n      const latitude = feature.geometry.coordinates[1];\n      featureInfo.position = Cartographic.fromDegrees(longitude, latitude);\n    }\n    result.push(featureInfo);\n  }\n  return result;\n}\nconst mapInfoMxpNamespace = \"http://www.mapinfo.com/mxp\";\nconst esriWmsNamespace = \"http://www.esri.com/wms\";\nconst wfsNamespace = \"http://www.opengis.net/wfs\";\nconst gmlNamespace = \"http://www.opengis.net/gml\";\nfunction xmlToFeatureInfo(xml) {\n  const documentElement = xml.documentElement;\n  if (documentElement.localName === \"MultiFeatureCollection\" && documentElement.namespaceURI === mapInfoMxpNamespace) {\n    // This looks like a MapInfo MXP response\n    return mapInfoXmlToFeatureInfo(xml);\n  } else if (documentElement.localName === \"FeatureInfoResponse\" && documentElement.namespaceURI === esriWmsNamespace) {\n    // This looks like an Esri WMS response\n    return esriXmlToFeatureInfo(xml);\n  } else if (documentElement.localName === \"FeatureCollection\" && documentElement.namespaceURI === wfsNamespace) {\n    // This looks like a WFS/GML response.\n    return gmlToFeatureInfo(xml);\n  } else if (documentElement.localName === \"ServiceExceptionReport\") {\n    // This looks like a WMS server error, so no features picked.\n    throw new RuntimeError(new XMLSerializer().serializeToString(documentElement));\n  } else if (documentElement.localName === \"msGMLOutput\") {\n    return msGmlToFeatureInfo(xml);\n  } else {\n    // Unknown response type, so just dump the XML itself into the description.\n    return unknownXmlToFeatureInfo(xml);\n  }\n}\nfunction mapInfoXmlToFeatureInfo(xml) {\n  const result = [];\n  const multiFeatureCollection = xml.documentElement;\n  const features = multiFeatureCollection.getElementsByTagNameNS(mapInfoMxpNamespace, \"Feature\");\n  for (let featureIndex = 0; featureIndex < features.length; ++featureIndex) {\n    const feature = features[featureIndex];\n    const properties = {};\n    const propertyElements = feature.getElementsByTagNameNS(mapInfoMxpNamespace, \"Val\");\n    for (let propertyIndex = 0; propertyIndex < propertyElements.length; ++propertyIndex) {\n      const propertyElement = propertyElements[propertyIndex];\n      if (propertyElement.hasAttribute(\"ref\")) {\n        const name = propertyElement.getAttribute(\"ref\");\n        const value = propertyElement.textContent.trim();\n        properties[name] = value;\n      }\n    }\n    const featureInfo = new ImageryLayerFeatureInfo();\n    featureInfo.data = feature;\n    featureInfo.properties = properties;\n    featureInfo.configureNameFromProperties(properties);\n    featureInfo.configureDescriptionFromProperties(properties);\n    result.push(featureInfo);\n  }\n  return result;\n}\nfunction esriXmlToFeatureInfo(xml) {\n  const featureInfoResponse = xml.documentElement;\n  const result = [];\n  let properties;\n  const features = featureInfoResponse.getElementsByTagNameNS(\"*\", \"FIELDS\");\n  if (features.length > 0) {\n    // Standard esri format\n    for (let featureIndex = 0; featureIndex < features.length; ++featureIndex) {\n      const feature = features[featureIndex];\n      properties = {};\n      const propertyAttributes = feature.attributes;\n      for (let attributeIndex = 0; attributeIndex < propertyAttributes.length; ++attributeIndex) {\n        const attribute = propertyAttributes[attributeIndex];\n        properties[attribute.name] = attribute.value;\n      }\n      result.push(imageryLayerFeatureInfoFromDataAndProperties(feature, properties));\n    }\n  } else {\n    // Thredds format -- looks like esri, but instead of containing FIELDS, contains FeatureInfo element\n    const featureInfoElements = featureInfoResponse.getElementsByTagNameNS(\"*\", \"FeatureInfo\");\n    for (let featureInfoElementIndex = 0; featureInfoElementIndex < featureInfoElements.length; ++featureInfoElementIndex) {\n      const featureInfoElement = featureInfoElements[featureInfoElementIndex];\n      properties = {};\n\n      // node.children is not supported in IE9-11, so use childNodes and check that child.nodeType is an element\n      const featureInfoChildren = featureInfoElement.childNodes;\n      for (let childIndex = 0; childIndex < featureInfoChildren.length; ++childIndex) {\n        const child = featureInfoChildren[childIndex];\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          properties[child.localName] = child.textContent;\n        }\n      }\n      result.push(imageryLayerFeatureInfoFromDataAndProperties(featureInfoElement, properties));\n    }\n  }\n  return result;\n}\nfunction gmlToFeatureInfo(xml) {\n  const result = [];\n  const featureCollection = xml.documentElement;\n  const featureMembers = featureCollection.getElementsByTagNameNS(gmlNamespace, \"featureMember\");\n  for (let featureIndex = 0; featureIndex < featureMembers.length; ++featureIndex) {\n    const featureMember = featureMembers[featureIndex];\n    const properties = {};\n    getGmlPropertiesRecursively(featureMember, properties);\n    result.push(imageryLayerFeatureInfoFromDataAndProperties(featureMember, properties));\n  }\n  return result;\n}\n\n// msGmlToFeatureInfo is similar to gmlToFeatureInfo, but assumes different XML structure\n// eg. <msGMLOutput> <ABC_layer> <ABC_feature> <foo>bar</foo> ... </ABC_feature> </ABC_layer> </msGMLOutput>\n\nfunction msGmlToFeatureInfo(xml) {\n  const result = [];\n\n  // Find the first child. Except for IE, this would work:\n  // const layer = xml.documentElement.children[0];\n  let layer;\n  const children = xml.documentElement.childNodes;\n  for (let i = 0; i < children.length; i++) {\n    if (children[i].nodeType === Node.ELEMENT_NODE) {\n      layer = children[i];\n      break;\n    }\n  }\n  if (!defined(layer)) {\n    throw new RuntimeError(\"Unable to find first child of the feature info xml document\");\n  }\n  const featureMembers = layer.childNodes;\n  for (let featureIndex = 0; featureIndex < featureMembers.length; ++featureIndex) {\n    const featureMember = featureMembers[featureIndex];\n    if (featureMember.nodeType === Node.ELEMENT_NODE) {\n      const properties = {};\n      getGmlPropertiesRecursively(featureMember, properties);\n      result.push(imageryLayerFeatureInfoFromDataAndProperties(featureMember, properties));\n    }\n  }\n  return result;\n}\nfunction getGmlPropertiesRecursively(gmlNode, properties) {\n  let isSingleValue = true;\n  for (let i = 0; i < gmlNode.childNodes.length; ++i) {\n    const child = gmlNode.childNodes[i];\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      isSingleValue = false;\n    }\n    if (child.localName === \"Point\" || child.localName === \"LineString\" || child.localName === \"Polygon\" || child.localName === \"boundedBy\") {\n      continue;\n    }\n    if (child.hasChildNodes() && getGmlPropertiesRecursively(child, properties)) {\n      properties[child.localName] = child.textContent;\n    }\n  }\n  return isSingleValue;\n}\nfunction imageryLayerFeatureInfoFromDataAndProperties(data, properties) {\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.data = data;\n  featureInfo.properties = properties;\n  featureInfo.configureNameFromProperties(properties);\n  featureInfo.configureDescriptionFromProperties(properties);\n  return featureInfo;\n}\nfunction unknownXmlToFeatureInfo(xml) {\n  const xmlText = new XMLSerializer().serializeToString(xml);\n  const element = document.createElement(\"div\");\n  const pre = document.createElement(\"pre\");\n  pre.textContent = xmlText;\n  element.appendChild(pre);\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.data = xml;\n  featureInfo.description = element.innerHTML;\n  return [featureInfo];\n}\nconst emptyBodyRegex = /<body>\\s*<\\/body>/im;\nconst wmsServiceExceptionReportRegex = /<ServiceExceptionReport([\\s\\S]*)<\\/ServiceExceptionReport>/im;\nconst titleRegex = /<title>([\\s\\S]*)<\\/title>/im;\nfunction textToFeatureInfo(text) {\n  // If the text is HTML and it has an empty body tag, assume it means no features were found.\n  if (emptyBodyRegex.test(text)) {\n    return undefined;\n  }\n\n  // If this is a WMS exception report, treat it as \"no features found\" rather than showing\n  // bogus feature info.\n  if (wmsServiceExceptionReportRegex.test(text)) {\n    return undefined;\n  }\n\n  // If the text has a <title> element, use it as the name.\n  let name;\n  const title = titleRegex.exec(text);\n  if (title && title.length > 1) {\n    name = title[1];\n  }\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.name = name;\n  featureInfo.description = text;\n  featureInfo.data = text;\n  return [featureInfo];\n}\nexport default GetFeatureInfoFormat;","map":{"version":3,"names":["Cartographic","defined","DeveloperError","RuntimeError","ImageryLayerFeatureInfo","GetFeatureInfoFormat","type","format","callback","geoJsonToFeatureInfo","xmlToFeatureInfo","textToFeatureInfo","json","result","features","i","length","feature","featureInfo","data","properties","configureNameFromProperties","configureDescriptionFromProperties","geometry","longitude","coordinates","latitude","position","fromDegrees","push","mapInfoMxpNamespace","esriWmsNamespace","wfsNamespace","gmlNamespace","xml","documentElement","localName","namespaceURI","mapInfoXmlToFeatureInfo","esriXmlToFeatureInfo","gmlToFeatureInfo","XMLSerializer","serializeToString","msGmlToFeatureInfo","unknownXmlToFeatureInfo","multiFeatureCollection","getElementsByTagNameNS","featureIndex","propertyElements","propertyIndex","propertyElement","hasAttribute","name","getAttribute","value","textContent","trim","featureInfoResponse","propertyAttributes","attributes","attributeIndex","attribute","imageryLayerFeatureInfoFromDataAndProperties","featureInfoElements","featureInfoElementIndex","featureInfoElement","featureInfoChildren","childNodes","childIndex","child","nodeType","Node","ELEMENT_NODE","featureCollection","featureMembers","featureMember","getGmlPropertiesRecursively","layer","children","gmlNode","isSingleValue","hasChildNodes","xmlText","element","document","createElement","pre","appendChild","description","innerHTML","emptyBodyRegex","wmsServiceExceptionReportRegex","titleRegex","text","test","undefined","title","exec"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GetFeatureInfoFormat.js"],"sourcesContent":["import Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ImageryLayerFeatureInfo from \"./ImageryLayerFeatureInfo.js\";\n\n/**\n * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.\n *\n * @alias GetFeatureInfoFormat\n * @constructor\n *\n * @param {string} type The type of response to expect from a GetFeatureInfo request.  Valid\n *        values are 'json', 'xml', 'html', or 'text'.\n * @param {string} [format] The info format to request from the WMS server.  This is usually a\n *        MIME type such as 'application/json' or text/xml'.  If this parameter is not specified, the provider will request 'json'\n *        using 'application/json', 'xml' using 'text/xml', 'html' using 'text/html', and 'text' using 'text/plain'.\n * @param {Function} [callback] A function to invoke with the GetFeatureInfo response from the WMS server\n *        in order to produce an array of picked {@link ImageryLayerFeatureInfo} instances.  If this parameter is not specified,\n *        a default function for the type of response is used.\n */\nfunction GetFeatureInfoFormat(type, format, callback) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.type = type;\n\n  if (!defined(format)) {\n    if (type === \"json\") {\n      format = \"application/json\";\n    } else if (type === \"xml\") {\n      format = \"text/xml\";\n    } else if (type === \"html\") {\n      format = \"text/html\";\n    } else if (type === \"text\") {\n      format = \"text/plain\";\n    }\n    //>>includeStart('debug', pragmas.debug);\n    else {\n      throw new DeveloperError(\n        'format is required when type is not \"json\", \"xml\", \"html\", or \"text\".',\n      );\n    }\n    //>>includeEnd('debug');\n  }\n\n  this.format = format;\n\n  if (!defined(callback)) {\n    if (type === \"json\") {\n      callback = geoJsonToFeatureInfo;\n    } else if (type === \"xml\") {\n      callback = xmlToFeatureInfo;\n    } else if (type === \"html\") {\n      callback = textToFeatureInfo;\n    } else if (type === \"text\") {\n      callback = textToFeatureInfo;\n    }\n    //>>includeStart('debug', pragmas.debug);\n    else {\n      throw new DeveloperError(\n        'callback is required when type is not \"json\", \"xml\", \"html\", or \"text\".',\n      );\n    }\n    //>>includeEnd('debug');\n  }\n\n  this.callback = callback;\n}\n\nfunction geoJsonToFeatureInfo(json) {\n  const result = [];\n\n  const features = json.features;\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n\n    const featureInfo = new ImageryLayerFeatureInfo();\n    featureInfo.data = feature;\n    featureInfo.properties = feature.properties;\n    featureInfo.configureNameFromProperties(feature.properties);\n    featureInfo.configureDescriptionFromProperties(feature.properties);\n\n    // If this is a point feature, use the coordinates of the point.\n    if (defined(feature.geometry) && feature.geometry.type === \"Point\") {\n      const longitude = feature.geometry.coordinates[0];\n      const latitude = feature.geometry.coordinates[1];\n      featureInfo.position = Cartographic.fromDegrees(longitude, latitude);\n    }\n\n    result.push(featureInfo);\n  }\n\n  return result;\n}\n\nconst mapInfoMxpNamespace = \"http://www.mapinfo.com/mxp\";\nconst esriWmsNamespace = \"http://www.esri.com/wms\";\nconst wfsNamespace = \"http://www.opengis.net/wfs\";\nconst gmlNamespace = \"http://www.opengis.net/gml\";\n\nfunction xmlToFeatureInfo(xml) {\n  const documentElement = xml.documentElement;\n  if (\n    documentElement.localName === \"MultiFeatureCollection\" &&\n    documentElement.namespaceURI === mapInfoMxpNamespace\n  ) {\n    // This looks like a MapInfo MXP response\n    return mapInfoXmlToFeatureInfo(xml);\n  } else if (\n    documentElement.localName === \"FeatureInfoResponse\" &&\n    documentElement.namespaceURI === esriWmsNamespace\n  ) {\n    // This looks like an Esri WMS response\n    return esriXmlToFeatureInfo(xml);\n  } else if (\n    documentElement.localName === \"FeatureCollection\" &&\n    documentElement.namespaceURI === wfsNamespace\n  ) {\n    // This looks like a WFS/GML response.\n    return gmlToFeatureInfo(xml);\n  } else if (documentElement.localName === \"ServiceExceptionReport\") {\n    // This looks like a WMS server error, so no features picked.\n    throw new RuntimeError(\n      new XMLSerializer().serializeToString(documentElement),\n    );\n  } else if (documentElement.localName === \"msGMLOutput\") {\n    return msGmlToFeatureInfo(xml);\n  } else {\n    // Unknown response type, so just dump the XML itself into the description.\n    return unknownXmlToFeatureInfo(xml);\n  }\n}\n\nfunction mapInfoXmlToFeatureInfo(xml) {\n  const result = [];\n\n  const multiFeatureCollection = xml.documentElement;\n\n  const features = multiFeatureCollection.getElementsByTagNameNS(\n    mapInfoMxpNamespace,\n    \"Feature\",\n  );\n  for (let featureIndex = 0; featureIndex < features.length; ++featureIndex) {\n    const feature = features[featureIndex];\n\n    const properties = {};\n\n    const propertyElements = feature.getElementsByTagNameNS(\n      mapInfoMxpNamespace,\n      \"Val\",\n    );\n    for (\n      let propertyIndex = 0;\n      propertyIndex < propertyElements.length;\n      ++propertyIndex\n    ) {\n      const propertyElement = propertyElements[propertyIndex];\n      if (propertyElement.hasAttribute(\"ref\")) {\n        const name = propertyElement.getAttribute(\"ref\");\n        const value = propertyElement.textContent.trim();\n        properties[name] = value;\n      }\n    }\n\n    const featureInfo = new ImageryLayerFeatureInfo();\n    featureInfo.data = feature;\n    featureInfo.properties = properties;\n    featureInfo.configureNameFromProperties(properties);\n    featureInfo.configureDescriptionFromProperties(properties);\n    result.push(featureInfo);\n  }\n\n  return result;\n}\n\nfunction esriXmlToFeatureInfo(xml) {\n  const featureInfoResponse = xml.documentElement;\n  const result = [];\n  let properties;\n\n  const features = featureInfoResponse.getElementsByTagNameNS(\"*\", \"FIELDS\");\n  if (features.length > 0) {\n    // Standard esri format\n    for (let featureIndex = 0; featureIndex < features.length; ++featureIndex) {\n      const feature = features[featureIndex];\n\n      properties = {};\n\n      const propertyAttributes = feature.attributes;\n      for (\n        let attributeIndex = 0;\n        attributeIndex < propertyAttributes.length;\n        ++attributeIndex\n      ) {\n        const attribute = propertyAttributes[attributeIndex];\n        properties[attribute.name] = attribute.value;\n      }\n\n      result.push(\n        imageryLayerFeatureInfoFromDataAndProperties(feature, properties),\n      );\n    }\n  } else {\n    // Thredds format -- looks like esri, but instead of containing FIELDS, contains FeatureInfo element\n    const featureInfoElements = featureInfoResponse.getElementsByTagNameNS(\n      \"*\",\n      \"FeatureInfo\",\n    );\n    for (\n      let featureInfoElementIndex = 0;\n      featureInfoElementIndex < featureInfoElements.length;\n      ++featureInfoElementIndex\n    ) {\n      const featureInfoElement = featureInfoElements[featureInfoElementIndex];\n\n      properties = {};\n\n      // node.children is not supported in IE9-11, so use childNodes and check that child.nodeType is an element\n      const featureInfoChildren = featureInfoElement.childNodes;\n      for (\n        let childIndex = 0;\n        childIndex < featureInfoChildren.length;\n        ++childIndex\n      ) {\n        const child = featureInfoChildren[childIndex];\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          properties[child.localName] = child.textContent;\n        }\n      }\n\n      result.push(\n        imageryLayerFeatureInfoFromDataAndProperties(\n          featureInfoElement,\n          properties,\n        ),\n      );\n    }\n  }\n\n  return result;\n}\n\nfunction gmlToFeatureInfo(xml) {\n  const result = [];\n\n  const featureCollection = xml.documentElement;\n\n  const featureMembers = featureCollection.getElementsByTagNameNS(\n    gmlNamespace,\n    \"featureMember\",\n  );\n  for (\n    let featureIndex = 0;\n    featureIndex < featureMembers.length;\n    ++featureIndex\n  ) {\n    const featureMember = featureMembers[featureIndex];\n\n    const properties = {};\n    getGmlPropertiesRecursively(featureMember, properties);\n    result.push(\n      imageryLayerFeatureInfoFromDataAndProperties(featureMember, properties),\n    );\n  }\n\n  return result;\n}\n\n// msGmlToFeatureInfo is similar to gmlToFeatureInfo, but assumes different XML structure\n// eg. <msGMLOutput> <ABC_layer> <ABC_feature> <foo>bar</foo> ... </ABC_feature> </ABC_layer> </msGMLOutput>\n\nfunction msGmlToFeatureInfo(xml) {\n  const result = [];\n\n  // Find the first child. Except for IE, this would work:\n  // const layer = xml.documentElement.children[0];\n  let layer;\n  const children = xml.documentElement.childNodes;\n  for (let i = 0; i < children.length; i++) {\n    if (children[i].nodeType === Node.ELEMENT_NODE) {\n      layer = children[i];\n      break;\n    }\n  }\n  if (!defined(layer)) {\n    throw new RuntimeError(\n      \"Unable to find first child of the feature info xml document\",\n    );\n  }\n  const featureMembers = layer.childNodes;\n  for (\n    let featureIndex = 0;\n    featureIndex < featureMembers.length;\n    ++featureIndex\n  ) {\n    const featureMember = featureMembers[featureIndex];\n    if (featureMember.nodeType === Node.ELEMENT_NODE) {\n      const properties = {};\n      getGmlPropertiesRecursively(featureMember, properties);\n      result.push(\n        imageryLayerFeatureInfoFromDataAndProperties(featureMember, properties),\n      );\n    }\n  }\n\n  return result;\n}\n\nfunction getGmlPropertiesRecursively(gmlNode, properties) {\n  let isSingleValue = true;\n\n  for (let i = 0; i < gmlNode.childNodes.length; ++i) {\n    const child = gmlNode.childNodes[i];\n\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      isSingleValue = false;\n    }\n\n    if (\n      child.localName === \"Point\" ||\n      child.localName === \"LineString\" ||\n      child.localName === \"Polygon\" ||\n      child.localName === \"boundedBy\"\n    ) {\n      continue;\n    }\n\n    if (\n      child.hasChildNodes() &&\n      getGmlPropertiesRecursively(child, properties)\n    ) {\n      properties[child.localName] = child.textContent;\n    }\n  }\n\n  return isSingleValue;\n}\n\nfunction imageryLayerFeatureInfoFromDataAndProperties(data, properties) {\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.data = data;\n  featureInfo.properties = properties;\n  featureInfo.configureNameFromProperties(properties);\n  featureInfo.configureDescriptionFromProperties(properties);\n  return featureInfo;\n}\n\nfunction unknownXmlToFeatureInfo(xml) {\n  const xmlText = new XMLSerializer().serializeToString(xml);\n\n  const element = document.createElement(\"div\");\n  const pre = document.createElement(\"pre\");\n  pre.textContent = xmlText;\n  element.appendChild(pre);\n\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.data = xml;\n  featureInfo.description = element.innerHTML;\n  return [featureInfo];\n}\n\nconst emptyBodyRegex = /<body>\\s*<\\/body>/im;\nconst wmsServiceExceptionReportRegex =\n  /<ServiceExceptionReport([\\s\\S]*)<\\/ServiceExceptionReport>/im;\nconst titleRegex = /<title>([\\s\\S]*)<\\/title>/im;\n\nfunction textToFeatureInfo(text) {\n  // If the text is HTML and it has an empty body tag, assume it means no features were found.\n  if (emptyBodyRegex.test(text)) {\n    return undefined;\n  }\n\n  // If this is a WMS exception report, treat it as \"no features found\" rather than showing\n  // bogus feature info.\n  if (wmsServiceExceptionReportRegex.test(text)) {\n    return undefined;\n  }\n\n  // If the text has a <title> element, use it as the name.\n  let name;\n  const title = titleRegex.exec(text);\n  if (title && title.length > 1) {\n    name = title[1];\n  }\n\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.name = name;\n  featureInfo.description = text;\n  featureInfo.data = text;\n  return [featureInfo];\n}\nexport default GetFeatureInfoFormat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}