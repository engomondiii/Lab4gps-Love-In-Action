{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * An instance of a metadata value.<br>\n * <br>\n * This can be one of the following types:\n * <ul>\n *   <li><code>number</code> for type <code>SCALAR</code> and numeric component types except for <code>INT64</code> or <code>UINT64</code></li>\n *   <li><code>bigint</code> for type <code>SCALAR</code> and component type <code>INT64</code> or <code>UINT64</code></li>\n *   <li><code>string</code> for type <code>STRING</code> or <code>ENUM</code></li>\n *   <li><code>boolean</code> for type <code>BOOLEAN</code></li>\n *   <li><code>Cartesian2</code> for type <code>VEC2</code></li>\n *   <li><code>Cartesian3</code> for type <code>VEC3</code></li>\n *   <li><code>Cartesian4</code> for type <code>VEC4</code></li>\n *   <li><code>Matrix2</code> for type <code>MAT2</code></li>\n *   <li><code>Matrix3</code> for type <code>MAT3</code></li>\n *   <li><code>Matrix4</code> for type <code>MAT4</code></li>\n *   <li>Arrays of these types when the metadata value is an array</li>\n * </ul>\n * @typedef {(number|bigint|string|boolean|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|number[]|bigint[]|string[]|boolean[]|Cartesian2[]|Cartesian3[]|Cartesian4[]|Matrix2[]|Matrix3[]|Matrix4[])} MetadataValue\n */\n\n/**\n * An enum of metadata types. These metadata types are containers containing\n * one or more components of type {@link MetadataComponentType}\n *\n * @enum {string}\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst MetadataType = {\n  /**\n   * A single component\n   *\n   * @type {string}\n   * @constant\n   */\n  SCALAR: \"SCALAR\",\n  /**\n   * A vector with two components\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC2: \"VEC2\",\n  /**\n   * A vector with three components\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC3: \"VEC3\",\n  /**\n   * A vector with four components\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC4: \"VEC4\",\n  /**\n   * A 2x2 matrix, stored in column-major format.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT2: \"MAT2\",\n  /**\n   * A 3x3 matrix, stored in column-major format.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT3: \"MAT3\",\n  /**\n   * A 4x4 matrix, stored in column-major format.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT4: \"MAT4\",\n  /**\n   * A boolean (true/false) value\n   *\n   * @type {string}\n   * @constant\n   */\n  BOOLEAN: \"BOOLEAN\",\n  /**\n   * A UTF-8 encoded string value\n   *\n   * @type {string}\n   * @constant\n   */\n  STRING: \"STRING\",\n  /**\n   * An enumerated value. This type is used in conjunction with a {@link MetadataEnum} to describe the valid values.\n   *\n   * @see MetadataEnum\n   *\n   * @type {string}\n   * @constant\n   */\n  ENUM: \"ENUM\"\n};\n\n/**\n * Check if a type is VEC2, VEC3 or VEC4\n *\n * @param {MetadataType} type The type\n * @return {boolean} <code>true</code> if the type is a vector, <code>false</code> otherwise\n * @private\n */\nMetadataType.isVectorType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.VEC2:\n    case MetadataType.VEC3:\n    case MetadataType.VEC4:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Check if a type is MAT2, MAT3 or MAT4\n *\n * @param {MetadataType} type The type\n * @return {boolean} <code>true</code> if the type is a matrix, <code>false</code> otherwise\n * @private\n */\nMetadataType.isMatrixType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.MAT2:\n    case MetadataType.MAT3:\n    case MetadataType.MAT4:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Get the number of components for a vector or matrix type. e.g.\n * a VECN returns N, and a MATN returns N*N. All other types return 1.\n *\n * @param {MetadataType} type The type to get the component count for\n * @return {number} The number of components\n * @private\n */\nMetadataType.getComponentCount = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.SCALAR:\n    case MetadataType.STRING:\n    case MetadataType.ENUM:\n    case MetadataType.BOOLEAN:\n      return 1;\n    case MetadataType.VEC2:\n      return 2;\n    case MetadataType.VEC3:\n      return 3;\n    case MetadataType.VEC4:\n      return 4;\n    case MetadataType.MAT2:\n      return 4;\n    case MetadataType.MAT3:\n      return 9;\n    case MetadataType.MAT4:\n      return 16;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(`Invalid metadata type ${type}`);\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Get the corresponding vector or matrix class. This is used to simplify\n * packing and unpacking code.\n * @param {MetadataType} type The metadata type\n * @return {object} The appropriate CartesianN class for vector types, MatrixN class for matrix types, or undefined otherwise.\n * @private\n */\nMetadataType.getMathType = function (type) {\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2;\n    case MetadataType.VEC3:\n      return Cartesian3;\n    case MetadataType.VEC4:\n      return Cartesian4;\n    case MetadataType.MAT2:\n      return Matrix2;\n    case MetadataType.MAT3:\n      return Matrix3;\n    case MetadataType.MAT4:\n      return Matrix4;\n    default:\n      return undefined;\n  }\n};\nexport default Object.freeze(MetadataType);","map":{"version":3,"names":["Check","Cartesian2","Cartesian3","Cartesian4","DeveloperError","Matrix2","Matrix3","Matrix4","MetadataType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BOOLEAN","STRING","ENUM","isVectorType","type","typeOf","string","isMatrixType","getComponentCount","getMathType","undefined","Object","freeze"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/MetadataType.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * An instance of a metadata value.<br>\n * <br>\n * This can be one of the following types:\n * <ul>\n *   <li><code>number</code> for type <code>SCALAR</code> and numeric component types except for <code>INT64</code> or <code>UINT64</code></li>\n *   <li><code>bigint</code> for type <code>SCALAR</code> and component type <code>INT64</code> or <code>UINT64</code></li>\n *   <li><code>string</code> for type <code>STRING</code> or <code>ENUM</code></li>\n *   <li><code>boolean</code> for type <code>BOOLEAN</code></li>\n *   <li><code>Cartesian2</code> for type <code>VEC2</code></li>\n *   <li><code>Cartesian3</code> for type <code>VEC3</code></li>\n *   <li><code>Cartesian4</code> for type <code>VEC4</code></li>\n *   <li><code>Matrix2</code> for type <code>MAT2</code></li>\n *   <li><code>Matrix3</code> for type <code>MAT3</code></li>\n *   <li><code>Matrix4</code> for type <code>MAT4</code></li>\n *   <li>Arrays of these types when the metadata value is an array</li>\n * </ul>\n * @typedef {(number|bigint|string|boolean|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|number[]|bigint[]|string[]|boolean[]|Cartesian2[]|Cartesian3[]|Cartesian4[]|Matrix2[]|Matrix3[]|Matrix4[])} MetadataValue\n */\n\n/**\n * An enum of metadata types. These metadata types are containers containing\n * one or more components of type {@link MetadataComponentType}\n *\n * @enum {string}\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst MetadataType = {\n  /**\n   * A single component\n   *\n   * @type {string}\n   * @constant\n   */\n  SCALAR: \"SCALAR\",\n  /**\n   * A vector with two components\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC2: \"VEC2\",\n  /**\n   * A vector with three components\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC3: \"VEC3\",\n  /**\n   * A vector with four components\n   *\n   * @type {string}\n   * @constant\n   */\n  VEC4: \"VEC4\",\n  /**\n   * A 2x2 matrix, stored in column-major format.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT2: \"MAT2\",\n  /**\n   * A 3x3 matrix, stored in column-major format.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT3: \"MAT3\",\n  /**\n   * A 4x4 matrix, stored in column-major format.\n   *\n   * @type {string}\n   * @constant\n   */\n  MAT4: \"MAT4\",\n  /**\n   * A boolean (true/false) value\n   *\n   * @type {string}\n   * @constant\n   */\n  BOOLEAN: \"BOOLEAN\",\n  /**\n   * A UTF-8 encoded string value\n   *\n   * @type {string}\n   * @constant\n   */\n  STRING: \"STRING\",\n  /**\n   * An enumerated value. This type is used in conjunction with a {@link MetadataEnum} to describe the valid values.\n   *\n   * @see MetadataEnum\n   *\n   * @type {string}\n   * @constant\n   */\n  ENUM: \"ENUM\",\n};\n\n/**\n * Check if a type is VEC2, VEC3 or VEC4\n *\n * @param {MetadataType} type The type\n * @return {boolean} <code>true</code> if the type is a vector, <code>false</code> otherwise\n * @private\n */\nMetadataType.isVectorType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.VEC2:\n    case MetadataType.VEC3:\n    case MetadataType.VEC4:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Check if a type is MAT2, MAT3 or MAT4\n *\n * @param {MetadataType} type The type\n * @return {boolean} <code>true</code> if the type is a matrix, <code>false</code> otherwise\n * @private\n */\nMetadataType.isMatrixType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.MAT2:\n    case MetadataType.MAT3:\n    case MetadataType.MAT4:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Get the number of components for a vector or matrix type. e.g.\n * a VECN returns N, and a MATN returns N*N. All other types return 1.\n *\n * @param {MetadataType} type The type to get the component count for\n * @return {number} The number of components\n * @private\n */\nMetadataType.getComponentCount = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.SCALAR:\n    case MetadataType.STRING:\n    case MetadataType.ENUM:\n    case MetadataType.BOOLEAN:\n      return 1;\n    case MetadataType.VEC2:\n      return 2;\n    case MetadataType.VEC3:\n      return 3;\n    case MetadataType.VEC4:\n      return 4;\n    case MetadataType.MAT2:\n      return 4;\n    case MetadataType.MAT3:\n      return 9;\n    case MetadataType.MAT4:\n      return 16;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(`Invalid metadata type ${type}`);\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Get the corresponding vector or matrix class. This is used to simplify\n * packing and unpacking code.\n * @param {MetadataType} type The metadata type\n * @return {object} The appropriate CartesianN class for vector types, MatrixN class for matrix types, or undefined otherwise.\n * @private\n */\nMetadataType.getMathType = function (type) {\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2;\n    case MetadataType.VEC3:\n      return Cartesian3;\n    case MetadataType.VEC4:\n      return Cartesian4;\n    case MetadataType.MAT2:\n      return Matrix2;\n    case MetadataType.MAT3:\n      return Matrix3;\n    case MetadataType.MAT4:\n      return Matrix4;\n    default:\n      return undefined;\n  }\n};\n\nexport default Object.freeze(MetadataType);\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAG;EACnB;AACF;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,QAAQ;EAChB;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,OAAO,EAAE,SAAS;EAClB;AACF;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,QAAQ;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,YAAY,CAACW,YAAY,GAAG,UAAUC,IAAI,EAAE;EAC1C;EACApB,KAAK,CAACqB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,YAAY,CAACE,IAAI;IACtB,KAAKF,YAAY,CAACG,IAAI;IACtB,KAAKH,YAAY,CAACI,IAAI;MACpB,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,YAAY,CAACe,YAAY,GAAG,UAAUH,IAAI,EAAE;EAC1C;EACApB,KAAK,CAACqB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,YAAY,CAACK,IAAI;IACtB,KAAKL,YAAY,CAACM,IAAI;IACtB,KAAKN,YAAY,CAACO,IAAI;MACpB,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAP,YAAY,CAACgB,iBAAiB,GAAG,UAAUJ,IAAI,EAAE;EAC/C;EACApB,KAAK,CAACqB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,YAAY,CAACC,MAAM;IACxB,KAAKD,YAAY,CAACS,MAAM;IACxB,KAAKT,YAAY,CAACU,IAAI;IACtB,KAAKV,YAAY,CAACQ,OAAO;MACvB,OAAO,CAAC;IACV,KAAKR,YAAY,CAACE,IAAI;MACpB,OAAO,CAAC;IACV,KAAKF,YAAY,CAACG,IAAI;MACpB,OAAO,CAAC;IACV,KAAKH,YAAY,CAACI,IAAI;MACpB,OAAO,CAAC;IACV,KAAKJ,YAAY,CAACK,IAAI;MACpB,OAAO,CAAC;IACV,KAAKL,YAAY,CAACM,IAAI;MACpB,OAAO,CAAC;IACV,KAAKN,YAAY,CAACO,IAAI;MACpB,OAAO,EAAE;IACX;IACA;MACE,MAAM,IAAIX,cAAc,CAAC,yBAAyBgB,IAAI,EAAE,CAAC;IAC3D;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,YAAY,CAACiB,WAAW,GAAG,UAAUL,IAAI,EAAE;EACzC,QAAQA,IAAI;IACV,KAAKZ,YAAY,CAACE,IAAI;MACpB,OAAOT,UAAU;IACnB,KAAKO,YAAY,CAACG,IAAI;MACpB,OAAOT,UAAU;IACnB,KAAKM,YAAY,CAACI,IAAI;MACpB,OAAOT,UAAU;IACnB,KAAKK,YAAY,CAACK,IAAI;MACpB,OAAOR,OAAO;IAChB,KAAKG,YAAY,CAACM,IAAI;MACpB,OAAOR,OAAO;IAChB,KAAKE,YAAY,CAACO,IAAI;MACpB,OAAOR,OAAO;IAChB;MACE,OAAOmB,SAAS;EACpB;AACF,CAAC;AAED,eAAeC,MAAM,CAACC,MAAM,CAACpB,YAAY,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}