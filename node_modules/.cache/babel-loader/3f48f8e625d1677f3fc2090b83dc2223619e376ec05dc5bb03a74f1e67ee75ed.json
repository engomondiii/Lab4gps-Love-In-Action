{"ast":null,"code":"import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\nconst scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(origin)) {\n    throw new DeveloperError(\"origin must not be at the center of the ellipsoid.\");\n  }\n  //>>includeEnd('debug');\n\n  const eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));\n  this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));\n  const normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    }\n  },\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    }\n  },\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    }\n  },\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    }\n  },\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    }\n  }\n});\nconst tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n  let intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n  }\n  if (defined(intersectionPoint)) {\n    const v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n    const x = Cartesian3.dot(this._xAxis, v);\n    const y = Cartesian3.dot(this._yAxis, v);\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n  let count = 0;\n  const length = cartesians.length;\n  for (let i = 0; i < length; i++) {\n    const p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n  let intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n  }\n  const v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n  const x = Cartesian3.dot(this._xAxis, v);\n  const y = Cartesian3.dot(this._yAxis, v);\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n  const length = cartesians.length;\n  result.length = length;\n  for (let i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\nconst projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  const ellipsoid = this._ellipsoid;\n  const origin = this._origin;\n  const xAxis = this._xAxis;\n  const yAxis = this._yAxis;\n  const tmp = projectPointsOntoEllipsoidScratch;\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n  return result;\n};\nexport default EllipsoidTangentPlane;","map":{"version":3,"names":["AxisAlignedBoundingBox","Cartesian2","Cartesian3","Cartesian4","Check","defaultValue","defined","DeveloperError","Ellipsoid","IntersectionTests","Matrix4","Plane","Ray","Transforms","scratchCart4","EllipsoidTangentPlane","origin","ellipsoid","default","scaleToGeodeticSurface","eastNorthUp","eastNorthUpToFixedFrame","_ellipsoid","_origin","_xAxis","fromCartesian4","getColumn","_yAxis","normal","_plane","fromPointNormal","Object","defineProperties","prototype","get","plane","xAxis","yAxis","zAxis","tmp","fromPoints","cartesians","box","center","scratchProjectPointOntoPlaneRay","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","cartesian","result","ray","normalize","direction","intersectionPoint","rayPlane","negate","v","subtract","x","dot","y","undefined","projectPointsOntoPlane","count","length","i","p","projectPointToNearestOnPlane","clone","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","multiplyByScalar","add","scaleToGeocentricSurface","projectPointsOntoEllipsoid","Array"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EllipsoidTangentPlane.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\n\nconst scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(origin)) {\n    throw new DeveloperError(\n      \"origin must not be at the center of the ellipsoid.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 0, scratchCart4),\n  );\n  this._yAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 1, scratchCart4),\n  );\n\n  const normal = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 2, scratchCart4),\n  );\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    },\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    },\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    },\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    },\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    },\n  },\n});\n\nconst tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\n  cartesian,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n\n  let intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3,\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3,\n    );\n  }\n\n  if (defined(intersectionPoint)) {\n    const v = Cartesian3.subtract(\n      intersectionPoint,\n      this._origin,\n      intersectionPoint,\n    );\n    const x = Cartesian3.dot(this._xAxis, v);\n    const y = Cartesian3.dot(this._yAxis, v);\n\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  let count = 0;\n  const length = cartesians.length;\n  for (let i = 0; i < length; i++) {\n    const p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\n  cartesian,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n\n  let intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3,\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3,\n    );\n  }\n\n  const v = Cartesian3.subtract(\n    intersectionPoint,\n    this._origin,\n    intersectionPoint,\n  );\n  const x = Cartesian3.dot(this._xAxis, v);\n  const y = Cartesian3.dot(this._yAxis, v);\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const length = cartesians.length;\n  result.length = length;\n  for (let i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\n\nconst projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\n  cartesian,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const ellipsoid = this._ellipsoid;\n  const origin = this._origin;\n  const xAxis = this._xAxis;\n  const yAxis = this._yAxis;\n  const tmp = projectPointsOntoEllipsoidScratch;\n\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\n  cartesians,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\nexport default EllipsoidTangentPlane;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}