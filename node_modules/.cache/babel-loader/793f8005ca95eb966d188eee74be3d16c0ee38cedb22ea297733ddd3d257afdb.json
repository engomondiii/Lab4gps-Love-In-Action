{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\n\n/**\n * Update the shader with defines, structs, and functions to handle\n * voxel properties and statistics\n * @function\n *\n * @param {VoxelRenderResources} renderResources\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction processVoxelProperties(renderResources, primitive) {\n  const {\n    shaderBuilder\n  } = renderResources;\n  const {\n    names,\n    types,\n    componentTypes,\n    minimumValues,\n    maximumValues\n  } = primitive._provider;\n  const attributeLength = types.length;\n  const hasStatistics = defined(minimumValues) && defined(maximumValues);\n  shaderBuilder.addDefine(\"METADATA_COUNT\", attributeLength, ShaderDestination.FRAGMENT);\n  if (hasStatistics) {\n    shaderBuilder.addDefine(\"STATISTICS\", undefined, ShaderDestination.FRAGMENT);\n  }\n\n  // PropertyStatistics structs\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const propertyStatisticsStructId = `PropertyStatistics_${name}`;\n    const propertyStatisticsStructName = `PropertyStatistics_${name}`;\n    shaderBuilder.addStruct(propertyStatisticsStructId, propertyStatisticsStructName, ShaderDestination.FRAGMENT);\n    const glslType = getGlslType(type);\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"min\");\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"max\");\n  }\n\n  // Statistics struct\n  const statisticsStructId = \"Statistics\";\n  const statisticsStructName = \"Statistics\";\n  const statisticsFieldName = \"statistics\";\n  shaderBuilder.addStruct(statisticsStructId, statisticsStructName, ShaderDestination.FRAGMENT);\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const propertyStructName = `PropertyStatistics_${name}`;\n    const propertyFieldName = name;\n    shaderBuilder.addStructField(statisticsStructId, propertyStructName, propertyFieldName);\n  }\n\n  // Metadata struct\n  const metadataStructId = \"Metadata\";\n  const metadataStructName = \"Metadata\";\n  const metadataFieldName = \"metadata\";\n  shaderBuilder.addStruct(metadataStructId, metadataStructName, ShaderDestination.FRAGMENT);\n  shaderBuilder.addStructField(metadataStructId, statisticsStructName, statisticsFieldName);\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const glslType = getGlslType(type);\n    shaderBuilder.addStructField(metadataStructId, glslType, name);\n  }\n\n  // VoxelProperty structs\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const glslType = getGlslPartialDerivativeType(type);\n    const voxelPropertyStructId = `VoxelProperty_${name}`;\n    const voxelPropertyStructName = `VoxelProperty_${name}`;\n    shaderBuilder.addStruct(voxelPropertyStructId, voxelPropertyStructName, ShaderDestination.FRAGMENT);\n    shaderBuilder.addStructField(voxelPropertyStructId, glslType, \"partialDerivativeLocal\");\n    shaderBuilder.addStructField(voxelPropertyStructId, glslType, \"partialDerivativeWorld\");\n    shaderBuilder.addStructField(voxelPropertyStructId, glslType, \"partialDerivativeView\");\n    shaderBuilder.addStructField(voxelPropertyStructId, glslType, \"partialDerivativeValid\");\n  }\n\n  // Voxel struct\n  const voxelStructId = \"Voxel\";\n  const voxelStructName = \"Voxel\";\n  const voxelFieldName = \"voxel\";\n  shaderBuilder.addStruct(voxelStructId, voxelStructName, ShaderDestination.FRAGMENT);\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const voxelPropertyStructName = `VoxelProperty_${name}`;\n    shaderBuilder.addStructField(voxelStructId, voxelPropertyStructName, name);\n  }\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionEC\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionUv\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionShapeUv\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionUvLocal\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"viewDirUv\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"viewDirWorld\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"surfaceNormal\");\n  shaderBuilder.addStructField(voxelStructId, \"float\", \"travelDistance\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"stepCount\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"tileIndex\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"sampleIndex\");\n\n  // FragmentInput struct\n  const fragmentInputStructId = \"FragmentInput\";\n  const fragmentInputStructName = \"FragmentInput\";\n  shaderBuilder.addStruct(fragmentInputStructId, fragmentInputStructName, ShaderDestination.FRAGMENT);\n  shaderBuilder.addStructField(fragmentInputStructId, metadataStructName, metadataFieldName);\n  shaderBuilder.addStructField(fragmentInputStructId, voxelStructName, voxelFieldName);\n\n  // Properties struct\n  const propertiesStructId = \"Properties\";\n  const propertiesStructName = \"Properties\";\n  const propertiesFieldName = \"properties\";\n  shaderBuilder.addStruct(propertiesStructId, propertiesStructName, ShaderDestination.FRAGMENT);\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const glslType = getGlslType(type);\n    shaderBuilder.addStructField(propertiesStructId, glslType, name);\n  }\n\n  // Fragment shader functions\n\n  // clearProperties function\n  {\n    const functionId = \"clearProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} clearProperties()`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentType = componentTypes[i];\n      const glslType = getGlslType(type, componentType);\n      shaderBuilder.addFunctionLines(functionId, [`${propertiesFieldName}.${name} = ${glslType}(0.0);`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n\n  // sumProperties function\n  {\n    const functionId = \"sumProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} sumProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`${propertiesFieldName}.${name} = propertiesA.${name} + propertiesB.${name};`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n\n  // scaleProperties function\n  {\n    const functionId = \"scaleProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} scaleProperties(${propertiesStructName} ${propertiesFieldName}, float scale)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} scaledProperties = ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`scaledProperties.${name} *= scale;`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return scaledProperties;`]);\n  }\n\n  // mixProperties\n  {\n    const functionId = \"mixProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} mixProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB, float mixFactor)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`${propertiesFieldName}.${name} = mix(propertiesA.${name}, propertiesB.${name}, mixFactor);`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n\n  // copyPropertiesToMetadata\n  {\n    const functionId = \"copyPropertiesToMetadata\";\n    shaderBuilder.addFunction(functionId, `void copyPropertiesToMetadata(in ${propertiesStructName} ${propertiesFieldName}, inout ${metadataStructName} ${metadataFieldName})`, ShaderDestination.FRAGMENT);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`${metadataFieldName}.${name} = ${propertiesFieldName}.${name};`]);\n    }\n  }\n\n  // setStatistics function\n  if (hasStatistics) {\n    const functionId = \"setStatistics\";\n    shaderBuilder.addFunction(functionId, `void setStatistics(inout ${statisticsStructName} ${statisticsFieldName})`, ShaderDestination.FRAGMENT);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentCount = MetadataType.getComponentCount(type);\n      for (let j = 0; j < componentCount; j++) {\n        const glslField = getGlslField(type, j);\n        const minimumValue = minimumValues[i][j];\n        const maximumValue = maximumValues[i][j];\n        shaderBuilder.addFunctionLines(functionId, [`${statisticsFieldName}.${name}.min${glslField} = ${getGlslNumberAsFloat(minimumValue)};`, `${statisticsFieldName}.${name}.max${glslField} = ${getGlslNumberAsFloat(maximumValue)};`]);\n      }\n    }\n  }\n\n  // getPropertiesFromMegatextureAtUv\n  {\n    const functionId = \"getPropertiesFromMegatextureAtUv\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} getPropertiesFromMegatextureAtUv(vec2 texcoord)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentType = componentTypes[i];\n      const glslTextureSwizzle = getGlslTextureSwizzle(type, componentType);\n      shaderBuilder.addFunctionLines(functionId, [`properties.${name} = texture(u_megatextureTextures[${i}], texcoord)${glslTextureSwizzle};`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n}\n\n/**\n * Converts a {@link MetadataType} to a GLSL type.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL type.\n *\n * @private\n */\nfunction getGlslType(type) {\n  if (type === MetadataType.SCALAR) {\n    return \"float\";\n  } else if (type === MetadataType.VEC2) {\n    return \"vec2\";\n  } else if (type === MetadataType.VEC3) {\n    return \"vec3\";\n  } else if (type === MetadataType.VEC4) {\n    return \"vec4\";\n  }\n}\n\n/**\n * Gets the GLSL swizzle when reading data from a texture.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL swizzle.\n *\n * @private\n */\nfunction getGlslTextureSwizzle(type) {\n  if (type === MetadataType.SCALAR) {\n    return \".r\";\n  } else if (type === MetadataType.VEC2) {\n    return \".ra\";\n  } else if (type === MetadataType.VEC3) {\n    return \".rgb\";\n  } else if (type === MetadataType.VEC4) {\n    return \"\";\n  }\n}\n\n/**\n * Gets the GLSL type of the partial derivative of {@link MetadataType}.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL type.\n *\n * @private\n */\nfunction getGlslPartialDerivativeType(type) {\n  if (type === MetadataType.SCALAR) {\n    return \"vec3\";\n  } else if (type === MetadataType.VEC2) {\n    return \"mat2\";\n  } else if (type === MetadataType.VEC3) {\n    return \"mat3\";\n  } else if (type === MetadataType.VEC4) {\n    return \"mat4\";\n  }\n}\n\n/**\n * GLSL needs to have `.0` at the end of whole number floats or else it's\n * treated like an integer.\n *\n * @function\n *\n * @param {number} number The number to convert.\n * @returns {string} The number as floating point in GLSL.\n *\n * @private\n */\nfunction getGlslNumberAsFloat(number) {\n  let numberString = number.toString();\n  if (numberString.indexOf(\".\") === -1) {\n    numberString = `${number}.0`;\n  }\n  return numberString;\n}\n\n/**\n * Gets the GLSL field\n *\n * @function\n *\n * @param {MetadataType} type\n * @param {number} index\n * @returns {string}\n *\n * @private\n */\nfunction getGlslField(type, index) {\n  if (type === MetadataType.SCALAR) {\n    return \"\";\n  }\n  return `[${index}]`;\n}\nexport default processVoxelProperties;","map":{"version":3,"names":["defined","MetadataType","ShaderDestination","processVoxelProperties","renderResources","primitive","shaderBuilder","names","types","componentTypes","minimumValues","maximumValues","_provider","attributeLength","length","hasStatistics","addDefine","FRAGMENT","undefined","i","name","type","propertyStatisticsStructId","propertyStatisticsStructName","addStruct","glslType","getGlslType","addStructField","statisticsStructId","statisticsStructName","statisticsFieldName","propertyStructName","propertyFieldName","metadataStructId","metadataStructName","metadataFieldName","getGlslPartialDerivativeType","voxelPropertyStructId","voxelPropertyStructName","voxelStructId","voxelStructName","voxelFieldName","fragmentInputStructId","fragmentInputStructName","propertiesStructId","propertiesStructName","propertiesFieldName","functionId","addFunction","addFunctionLines","componentType","componentCount","getComponentCount","j","glslField","getGlslField","minimumValue","maximumValue","getGlslNumberAsFloat","glslTextureSwizzle","getGlslTextureSwizzle","SCALAR","VEC2","VEC3","VEC4","number","numberString","toString","indexOf","index"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/processVoxelProperties.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\n\n/**\n * Update the shader with defines, structs, and functions to handle\n * voxel properties and statistics\n * @function\n *\n * @param {VoxelRenderResources} renderResources\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction processVoxelProperties(renderResources, primitive) {\n  const { shaderBuilder } = renderResources;\n\n  const { names, types, componentTypes, minimumValues, maximumValues } =\n    primitive._provider;\n\n  const attributeLength = types.length;\n  const hasStatistics = defined(minimumValues) && defined(maximumValues);\n\n  shaderBuilder.addDefine(\n    \"METADATA_COUNT\",\n    attributeLength,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (hasStatistics) {\n    shaderBuilder.addDefine(\n      \"STATISTICS\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  // PropertyStatistics structs\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const propertyStatisticsStructId = `PropertyStatistics_${name}`;\n    const propertyStatisticsStructName = `PropertyStatistics_${name}`;\n    shaderBuilder.addStruct(\n      propertyStatisticsStructId,\n      propertyStatisticsStructName,\n      ShaderDestination.FRAGMENT,\n    );\n    const glslType = getGlslType(type);\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"min\");\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"max\");\n  }\n\n  // Statistics struct\n  const statisticsStructId = \"Statistics\";\n  const statisticsStructName = \"Statistics\";\n  const statisticsFieldName = \"statistics\";\n  shaderBuilder.addStruct(\n    statisticsStructId,\n    statisticsStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const propertyStructName = `PropertyStatistics_${name}`;\n    const propertyFieldName = name;\n    shaderBuilder.addStructField(\n      statisticsStructId,\n      propertyStructName,\n      propertyFieldName,\n    );\n  }\n\n  // Metadata struct\n  const metadataStructId = \"Metadata\";\n  const metadataStructName = \"Metadata\";\n  const metadataFieldName = \"metadata\";\n  shaderBuilder.addStruct(\n    metadataStructId,\n    metadataStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(\n    metadataStructId,\n    statisticsStructName,\n    statisticsFieldName,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const glslType = getGlslType(type);\n    shaderBuilder.addStructField(metadataStructId, glslType, name);\n  }\n\n  // VoxelProperty structs\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const glslType = getGlslPartialDerivativeType(type);\n    const voxelPropertyStructId = `VoxelProperty_${name}`;\n    const voxelPropertyStructName = `VoxelProperty_${name}`;\n    shaderBuilder.addStruct(\n      voxelPropertyStructId,\n      voxelPropertyStructName,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addStructField(\n      voxelPropertyStructId,\n      glslType,\n      \"partialDerivativeLocal\",\n    );\n    shaderBuilder.addStructField(\n      voxelPropertyStructId,\n      glslType,\n      \"partialDerivativeWorld\",\n    );\n    shaderBuilder.addStructField(\n      voxelPropertyStructId,\n      glslType,\n      \"partialDerivativeView\",\n    );\n    shaderBuilder.addStructField(\n      voxelPropertyStructId,\n      glslType,\n      \"partialDerivativeValid\",\n    );\n  }\n\n  // Voxel struct\n  const voxelStructId = \"Voxel\";\n  const voxelStructName = \"Voxel\";\n  const voxelFieldName = \"voxel\";\n  shaderBuilder.addStruct(\n    voxelStructId,\n    voxelStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const voxelPropertyStructName = `VoxelProperty_${name}`;\n    shaderBuilder.addStructField(voxelStructId, voxelPropertyStructName, name);\n  }\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionEC\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionUv\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionShapeUv\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"positionUvLocal\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"viewDirUv\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"viewDirWorld\");\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"surfaceNormal\");\n  shaderBuilder.addStructField(voxelStructId, \"float\", \"travelDistance\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"stepCount\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"tileIndex\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"sampleIndex\");\n\n  // FragmentInput struct\n  const fragmentInputStructId = \"FragmentInput\";\n  const fragmentInputStructName = \"FragmentInput\";\n  shaderBuilder.addStruct(\n    fragmentInputStructId,\n    fragmentInputStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(\n    fragmentInputStructId,\n    metadataStructName,\n    metadataFieldName,\n  );\n  shaderBuilder.addStructField(\n    fragmentInputStructId,\n    voxelStructName,\n    voxelFieldName,\n  );\n\n  // Properties struct\n  const propertiesStructId = \"Properties\";\n  const propertiesStructName = \"Properties\";\n  const propertiesFieldName = \"properties\";\n  shaderBuilder.addStruct(\n    propertiesStructId,\n    propertiesStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const type = types[i];\n    const glslType = getGlslType(type);\n    shaderBuilder.addStructField(propertiesStructId, glslType, name);\n  }\n\n  // Fragment shader functions\n\n  // clearProperties function\n  {\n    const functionId = \"clearProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} clearProperties()`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentType = componentTypes[i];\n      const glslType = getGlslType(type, componentType);\n      shaderBuilder.addFunctionLines(functionId, [\n        `${propertiesFieldName}.${name} = ${glslType}(0.0);`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n\n  // sumProperties function\n  {\n    const functionId = \"sumProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} sumProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `${propertiesFieldName}.${name} = propertiesA.${name} + propertiesB.${name};`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n\n  // scaleProperties function\n  {\n    const functionId = \"scaleProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} scaleProperties(${propertiesStructName} ${propertiesFieldName}, float scale)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} scaledProperties = ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `scaledProperties.${name} *= scale;`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return scaledProperties;`]);\n  }\n\n  // mixProperties\n  {\n    const functionId = \"mixProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} mixProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB, float mixFactor)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `${propertiesFieldName}.${name} = mix(propertiesA.${name}, propertiesB.${name}, mixFactor);`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n\n  // copyPropertiesToMetadata\n  {\n    const functionId = \"copyPropertiesToMetadata\";\n    shaderBuilder.addFunction(\n      functionId,\n      `void copyPropertiesToMetadata(in ${propertiesStructName} ${propertiesFieldName}, inout ${metadataStructName} ${metadataFieldName})`,\n      ShaderDestination.FRAGMENT,\n    );\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `${metadataFieldName}.${name} = ${propertiesFieldName}.${name};`,\n      ]);\n    }\n  }\n\n  // setStatistics function\n  if (hasStatistics) {\n    const functionId = \"setStatistics\";\n    shaderBuilder.addFunction(\n      functionId,\n      `void setStatistics(inout ${statisticsStructName} ${statisticsFieldName})`,\n      ShaderDestination.FRAGMENT,\n    );\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentCount = MetadataType.getComponentCount(type);\n      for (let j = 0; j < componentCount; j++) {\n        const glslField = getGlslField(type, j);\n        const minimumValue = minimumValues[i][j];\n        const maximumValue = maximumValues[i][j];\n        shaderBuilder.addFunctionLines(functionId, [\n          `${statisticsFieldName}.${name}.min${glslField} = ${getGlslNumberAsFloat(\n            minimumValue,\n          )};`,\n          `${statisticsFieldName}.${name}.max${glslField} = ${getGlslNumberAsFloat(\n            maximumValue,\n          )};`,\n        ]);\n      }\n    }\n  }\n\n  // getPropertiesFromMegatextureAtUv\n  {\n    const functionId = \"getPropertiesFromMegatextureAtUv\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} getPropertiesFromMegatextureAtUv(vec2 texcoord)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentType = componentTypes[i];\n      const glslTextureSwizzle = getGlslTextureSwizzle(type, componentType);\n      shaderBuilder.addFunctionLines(functionId, [\n        `properties.${name} = texture(u_megatextureTextures[${i}], texcoord)${glslTextureSwizzle};`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n}\n\n/**\n * Converts a {@link MetadataType} to a GLSL type.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL type.\n *\n * @private\n */\nfunction getGlslType(type) {\n  if (type === MetadataType.SCALAR) {\n    return \"float\";\n  } else if (type === MetadataType.VEC2) {\n    return \"vec2\";\n  } else if (type === MetadataType.VEC3) {\n    return \"vec3\";\n  } else if (type === MetadataType.VEC4) {\n    return \"vec4\";\n  }\n}\n\n/**\n * Gets the GLSL swizzle when reading data from a texture.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL swizzle.\n *\n * @private\n */\nfunction getGlslTextureSwizzle(type) {\n  if (type === MetadataType.SCALAR) {\n    return \".r\";\n  } else if (type === MetadataType.VEC2) {\n    return \".ra\";\n  } else if (type === MetadataType.VEC3) {\n    return \".rgb\";\n  } else if (type === MetadataType.VEC4) {\n    return \"\";\n  }\n}\n\n/**\n * Gets the GLSL type of the partial derivative of {@link MetadataType}.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL type.\n *\n * @private\n */\nfunction getGlslPartialDerivativeType(type) {\n  if (type === MetadataType.SCALAR) {\n    return \"vec3\";\n  } else if (type === MetadataType.VEC2) {\n    return \"mat2\";\n  } else if (type === MetadataType.VEC3) {\n    return \"mat3\";\n  } else if (type === MetadataType.VEC4) {\n    return \"mat4\";\n  }\n}\n\n/**\n * GLSL needs to have `.0` at the end of whole number floats or else it's\n * treated like an integer.\n *\n * @function\n *\n * @param {number} number The number to convert.\n * @returns {string} The number as floating point in GLSL.\n *\n * @private\n */\nfunction getGlslNumberAsFloat(number) {\n  let numberString = number.toString();\n  if (numberString.indexOf(\".\") === -1) {\n    numberString = `${number}.0`;\n  }\n  return numberString;\n}\n\n/**\n * Gets the GLSL field\n *\n * @function\n *\n * @param {MetadataType} type\n * @param {number} index\n * @returns {string}\n *\n * @private\n */\nfunction getGlslField(type, index) {\n  if (type === MetadataType.SCALAR) {\n    return \"\";\n  }\n  return `[${index}]`;\n}\n\nexport default processVoxelProperties;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}