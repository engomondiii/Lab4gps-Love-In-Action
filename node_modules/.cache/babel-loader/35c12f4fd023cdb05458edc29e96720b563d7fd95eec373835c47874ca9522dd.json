{"ast":null,"code":"import CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport MortonOrder from \"../Core/MortonOrder.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\n\n/**\n * The coordinates for a tile in an implicit tileset. The coordinates\n * are (level, x, y) for quadtrees or (level, x, y, z) for octrees.\n * <p>\n * Level numbers are 0-indexed and typically start at the root of the implicit\n * tileset (the tile with either implicitTiling in its JSON (3D Tiles 1.1) or\n * the <code>3DTILES_implicit_tiling</code> extension).\n * This object can also represent the relative offset from one set of coordinates\n * to another. See {@link ImplicitTileCoordinates#getOffsetCoordinates}. The term\n * local coordinates refers to coordinates that are relative to the root of a\n * subtree and the term global coordinates refers to coordinates relative to the\n * root of an implicit tileset.\n * </p>\n * <p>\n * For box bounding volumes, x, y, z increase along the +x, +y, and +z\n * directions defined by the half axes.\n * </p>\n * <p>\n * For region bounding volumes, x increases in the +longitude direction, y\n * increases in the +latitude direction, and z increases in the +height\n * direction.\n * </p>\n * <p>\n * Care must be taken when converting between implicit coordinates and Morton\n * indices because there is a 16-bit limit on {@link MortonOrder#encode2D} and\n * a 10-bit limit on {@link MortonOrder#encode3D}. Typically these conversions\n * should be done on local coordinates, not global coordinates, and the maximum\n * number of levels in the subtree should be 15 for quadtree and 9 for octree (to\n * account for the extra level needed by child subtree coordinates).\n * </p>\n *\n * @alias ImplicitTileCoordinates\n * @constructor\n *\n * @param {object} options An object with the following properties:\n * @param {ImplicitSubdivisionScheme} options.subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {number} options.subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {number} options.level The level of a tile relative to the tile with the extension\n * @param {number} options.x The x coordinate of the tile\n * @param {number} options.y The y coordinate of the tile\n * @param {number} [options.z] The z coordinate of the tile. Only required when options.subdivisionScheme is ImplicitSubdivisionScheme.OCTREE\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitTileCoordinates(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.subdivisionScheme\", options.subdivisionScheme);\n  Check.typeOf.number(\"options.subtreeLevels\", options.subtreeLevels);\n  Check.typeOf.number(\"options.level\", options.level);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    Check.typeOf.number(\"options.z\", options.z);\n  }\n  // Check for values that are negative\n  if (options.level < 0) {\n    throw new DeveloperError(\"level must be non-negative\");\n  }\n  if (options.x < 0) {\n    throw new DeveloperError(\"x must be non-negative\");\n  }\n  if (options.y < 0) {\n    throw new DeveloperError(\"y must be non-negative\");\n  }\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    if (options.z < 0) {\n      throw new DeveloperError(\"z must be non-negative\");\n    }\n  }\n\n  // Check for values that are too large\n  const dimensionAtLevel = 1 << options.level;\n  if (options.x >= dimensionAtLevel) {\n    throw new DeveloperError(\"x is out of range\");\n  }\n  if (options.y >= dimensionAtLevel) {\n    throw new DeveloperError(\"y is out of range\");\n  }\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    if (options.z >= dimensionAtLevel) {\n      throw new DeveloperError(\"z is out of range\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Whether the tileset is a quadtree or octree\n   *\n   * @type {ImplicitSubdivisionScheme}\n   * @readonly\n   * @private\n   */\n  this.subdivisionScheme = options.subdivisionScheme;\n\n  /**\n   * The number of distinct levels within the coordinate's subtree\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.subtreeLevels = options.subtreeLevels;\n\n  /**\n   * Level of this tile, relative to the tile with implicit tiling in its JSON\n   * (3D Tiles 1.1) or the <code>3DTILES_implicit_tiling</code> extension.\n   * Level numbers start at 0.\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.level = options.level;\n\n  /**\n   * X coordinate of this tile\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.x = options.x;\n\n  /**\n   * Y coordinate of this tile\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.y = options.y;\n\n  /**\n   * Z coordinate of this tile. Only defined for octrees.\n   *\n   * @type {number|undefined}\n   * @readonly\n   * @private\n   */\n  this.z = undefined;\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    this.z = options.z;\n  }\n}\nObject.defineProperties(ImplicitTileCoordinates.prototype, {\n  /**\n   * An index in the range of [0, branchingFactor) that indicates\n   * which child of the parent cell these coordinates correspond to.\n   * This can be viewed as a morton index within the parent tile.\n   * <p>\n   * This is the last 3 bits of the morton index of the tile, but it can\n   * be computed more directly by concatenating the bits [z0] y0 x0\n   * </p>\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  childIndex: {\n    get: function () {\n      let childIndex = 0;\n      childIndex |= this.x & 1;\n      childIndex |= (this.y & 1) << 1;\n      if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n        childIndex |= (this.z & 1) << 2;\n      }\n      return childIndex;\n    }\n  },\n  /**\n   * Get the Morton index for this tile within the current level by interleaving\n   * the bits of the x, y and z coordinates.\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  mortonIndex: {\n    get: function () {\n      if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n        return MortonOrder.encode3D(this.x, this.y, this.z);\n      }\n      return MortonOrder.encode2D(this.x, this.y);\n    }\n  },\n  /**\n   * Get the tile index by adding the Morton index to the level offset\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  tileIndex: {\n    get: function () {\n      const levelOffset = this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE ?\n      // (8^N - 1) / (8-1)\n      ((1 << 3 * this.level) - 1) / 7 :\n      // (4^N - 1) / (4-1)\n      ((1 << 2 * this.level) - 1) / 3;\n      const mortonIndex = this.mortonIndex;\n      return levelOffset + mortonIndex;\n    }\n  }\n});\n\n/**\n * Check that the two coordinates are compatible\n * @param {ImplicitTileCoordinates} a\n * @param {ImplicitTileCoordinates} b\n * @private\n */\nfunction checkMatchingSubtreeShape(a, b) {\n  if (a.subdivisionScheme !== b.subdivisionScheme) {\n    throw new DeveloperError(\"coordinates must have same subdivisionScheme\");\n  }\n  if (a.subtreeLevels !== b.subtreeLevels) {\n    throw new DeveloperError(\"coordinates must have same subtreeLevels\");\n  }\n}\n\n/**\n * Compute the coordinates of a tile deeper in the tree with a (level, x, y, [z]) relative offset.\n *\n * @param {ImplicitTileCoordinates} offsetCoordinates The offset from the ancestor\n * @returns {ImplicitTileCoordinates} The coordinates of the descendant\n * @private\n */\nImplicitTileCoordinates.prototype.getDescendantCoordinates = function (offsetCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"offsetCoordinates\", offsetCoordinates);\n  checkMatchingSubtreeShape(this, offsetCoordinates);\n  //>>includeEnd('debug');\n\n  const descendantLevel = this.level + offsetCoordinates.level;\n  const descendantX = (this.x << offsetCoordinates.level) + offsetCoordinates.x;\n  const descendantY = (this.y << offsetCoordinates.level) + offsetCoordinates.y;\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const descendantZ = (this.z << offsetCoordinates.level) + offsetCoordinates.z;\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: descendantLevel,\n      x: descendantX,\n      y: descendantY,\n      z: descendantZ\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: descendantLevel,\n    x: descendantX,\n    y: descendantY\n  });\n};\n\n/**\n * Compute the coordinates of a tile higher up in the tree by going up a number of levels.\n *\n * @param {number} offsetLevels The number of levels to go up in the tree\n * @returns {ImplicitTileCoordinates} The coordinates of the ancestor\n * @private\n */\nImplicitTileCoordinates.prototype.getAncestorCoordinates = function (offsetLevels) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"offsetLevels\", offsetLevels);\n  if (offsetLevels < 0) {\n    throw new DeveloperError(\"offsetLevels must be non-negative\");\n  }\n  if (offsetLevels > this.level) {\n    throw new DeveloperError(\"ancestor cannot be above the tileset root\");\n  }\n  //>>includeEnd('debug');\n\n  const divisor = 1 << offsetLevels;\n  const ancestorLevel = this.level - offsetLevels;\n  const ancestorX = Math.floor(this.x / divisor);\n  const ancestorY = Math.floor(this.y / divisor);\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const ancestorZ = Math.floor(this.z / divisor);\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: ancestorLevel,\n      x: ancestorX,\n      y: ancestorY,\n      z: ancestorZ\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: ancestorLevel,\n    x: ancestorX,\n    y: ancestorY\n  });\n};\n\n/**\n * Compute the (level, x, y, [z]) offset to a descendant\n *\n * @param {ImplicitTileCoordinates} descendantCoordinates The descendant coordinates\n * @returns {ImplicitTileCoordinates} The offset between the ancestor and the descendant\n */\nImplicitTileCoordinates.prototype.getOffsetCoordinates = function (descendantCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"descendantCoordinates\", descendantCoordinates);\n  if (!this.isEqual(descendantCoordinates) && !this.isAncestor(descendantCoordinates)) {\n    throw new DeveloperError(\"this is not an ancestor of descendant\");\n  }\n  checkMatchingSubtreeShape(this, descendantCoordinates);\n  //>>includeEnd('debug');\n\n  const offsetLevel = descendantCoordinates.level - this.level;\n  const dimensionAtOffsetLevel = 1 << offsetLevel;\n  const offsetX = descendantCoordinates.x % dimensionAtOffsetLevel;\n  const offsetY = descendantCoordinates.y % dimensionAtOffsetLevel;\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const offsetZ = descendantCoordinates.z % dimensionAtOffsetLevel;\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: offsetLevel,\n      x: offsetX,\n      y: offsetY,\n      z: offsetZ\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: offsetLevel,\n    x: offsetX,\n    y: offsetY\n  });\n};\n\n/**\n * Given the morton index of the child, compute the coordinates of the child.\n * This is a special case of {@link ImplicitTileCoordinates#getDescendantCoordinates}.\n *\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @returns {ImplicitTileCoordinates} The tile coordinates of the child\n * @private\n */\nImplicitTileCoordinates.prototype.getChildCoordinates = function (childIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"childIndex\", childIndex);\n  const branchingFactor = ImplicitSubdivisionScheme.getBranchingFactor(this.subdivisionScheme);\n  if (childIndex < 0 || branchingFactor <= childIndex) {\n    throw new DeveloperError(`childIndex must be at least 0 and less than ${branchingFactor}`);\n  }\n  //>>includeEnd('debug');\n\n  const level = this.level + 1;\n  const x = 2 * this.x + childIndex % 2;\n  const y = 2 * this.y + Math.floor(childIndex / 2) % 2;\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const z = 2 * this.z + Math.floor(childIndex / 4) % 2;\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: level,\n      x: x,\n      y: y,\n      z: z\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: level,\n    x: x,\n    y: y\n  });\n};\n\n/**\n * Get the coordinates of the subtree that contains this tile. If the tile is\n * the root of the subtree, the root of the subtree is returned.\n *\n * @returns {ImplicitTileCoordinates} The subtree that contains this tile\n * @private\n */\nImplicitTileCoordinates.prototype.getSubtreeCoordinates = function () {\n  return this.getAncestorCoordinates(this.level % this.subtreeLevels);\n};\n\n/**\n * Get the coordinates of the parent subtree that contains this tile\n *\n * @returns {ImplicitTileCoordinates} The parent subtree that contains this tile\n * @private\n */\nImplicitTileCoordinates.prototype.getParentSubtreeCoordinates = function () {\n  return this.getAncestorCoordinates(this.level % this.subtreeLevels + this.subtreeLevels);\n};\n\n/**\n * Returns whether this tile is an ancestor of another tile\n *\n * @param {ImplicitTileCoordinates} descendantCoordinates the descendant coordinates\n * @returns {boolean} <code>true</code> if this tile is an ancestor of the other tile\n * @private\n */\nImplicitTileCoordinates.prototype.isAncestor = function (descendantCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"descendantCoordinates\", descendantCoordinates);\n  checkMatchingSubtreeShape(this, descendantCoordinates);\n  //>>includeEnd('debug');\n\n  const levelDifference = descendantCoordinates.level - this.level;\n  if (levelDifference <= 0) {\n    return false;\n  }\n  const ancestorX = descendantCoordinates.x >> levelDifference;\n  const ancestorY = descendantCoordinates.y >> levelDifference;\n  const isAncestorX = this.x === ancestorX;\n  const isAncestorY = this.y === ancestorY;\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const ancestorZ = descendantCoordinates.z >> levelDifference;\n    const isAncestorZ = this.z === ancestorZ;\n    return isAncestorX && isAncestorY && isAncestorZ;\n  }\n\n  // Quadtree\n  return isAncestorX && isAncestorY;\n};\n\n/**\n * Returns whether the provided coordinates are equal to this coordinate\n *\n * @param {ImplicitTileCoordinates} otherCoordinates the other coordinates\n * @returns {boolean} <code>true</code> if the coordinates are equal\n * @private\n */\nImplicitTileCoordinates.prototype.isEqual = function (otherCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"otherCoordinates\", otherCoordinates);\n  //>>includeEnd('debug');\n\n  return this.subdivisionScheme === otherCoordinates.subdivisionScheme && this.subtreeLevels === otherCoordinates.subtreeLevels && this.level === otherCoordinates.level && this.x === otherCoordinates.x && this.y === otherCoordinates.y && (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE ? this.z === otherCoordinates.z : true);\n};\n\n/**\n * Returns whether this tile is the root of the implicit tileset\n *\n * @returns {boolean} <code>true</code> if this tile is the root\n * @private\n */\nImplicitTileCoordinates.prototype.isImplicitTilesetRoot = function () {\n  return this.level === 0;\n};\n\n/**\n * Returns whether this tile is the root of the subtree\n *\n * @returns {boolean} <code>true</code> if this tile is the root of the subtree\n * @private\n */\nImplicitTileCoordinates.prototype.isSubtreeRoot = function () {\n  return this.level % this.subtreeLevels === 0;\n};\n\n/**\n * Returns whether this tile is on the last row of tiles in the subtree\n *\n * @returns {boolean} <code>true</code> if this tile is on the last row of tiles in the subtree\n * @private\n */\nImplicitTileCoordinates.prototype.isBottomOfSubtree = function () {\n  return this.level % this.subtreeLevels === this.subtreeLevels - 1;\n};\n\n/**\n * Get a dictionary of values for templating into an implicit template URI.\n *\n * @returns {object} An object suitable for use with {@link Resource#getDerivedResource}\n * @private\n */\nImplicitTileCoordinates.prototype.getTemplateValues = function () {\n  const values = {\n    level: this.level,\n    x: this.x,\n    y: this.y\n  };\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    values.z = this.z;\n  }\n  return values;\n};\nconst scratchCoordinatesArray = [0, 0, 0];\n\n/**\n * Given a level number, morton index, and whether the tileset is an\n * octree/quadtree, compute the (level, x, y, [z]) coordinates\n *\n * @param {ImplicitSubdivisionScheme} subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {number} subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {number} level The level of the tree\n * @param {number} mortonIndex The morton index of the tile.\n * @returns {ImplicitTileCoordinates} The coordinates of the tile with the given Morton index\n * @private\n */\nImplicitTileCoordinates.fromMortonIndex = function (subdivisionScheme, subtreeLevels, level, mortonIndex) {\n  let coordinatesArray;\n  if (subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    coordinatesArray = MortonOrder.decode3D(mortonIndex, scratchCoordinatesArray);\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: subdivisionScheme,\n      subtreeLevels: subtreeLevels,\n      level: level,\n      x: coordinatesArray[0],\n      y: coordinatesArray[1],\n      z: coordinatesArray[2]\n    });\n  }\n  coordinatesArray = MortonOrder.decode2D(mortonIndex, scratchCoordinatesArray);\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: subdivisionScheme,\n    subtreeLevels: subtreeLevels,\n    level: level,\n    x: coordinatesArray[0],\n    y: coordinatesArray[1]\n  });\n};\n\n/**\n * Given a tile index and whether the tileset is an octree/quadtree, compute\n * the (level, x, y, [z]) coordinates\n *\n * @param {ImplicitSubdivisionScheme} subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {number} subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {number} tileIndex The tile's index\n * @returns {ImplicitTileCoordinates} The coordinates of the tile with the given tile index\n * @private\n */\nImplicitTileCoordinates.fromTileIndex = function (subdivisionScheme, subtreeLevels, tileIndex) {\n  let level;\n  let levelOffset;\n  let mortonIndex;\n  if (subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    // Node count up to octree level: (8^L - 1) / (8-1)\n    // (8^L - 1) / (8-1) <= X < (8^(L+1) - 1) / (8-1)\n    // 8^L <= (7x + 1) < 8^(L+1)\n    // L <= log8(7x + 1) < L + 1\n    // L = floor(log8(7x + 1))\n    // L = floor(log2(7x + 1) / log2(8))\n    // L = floor(log2(7x + 1) / 3)\n    level = Math.floor(CesiumMath.log2(7 * tileIndex + 1) / 3);\n    levelOffset = ((1 << 3 * level) - 1) / 7;\n    mortonIndex = tileIndex - levelOffset;\n  } else {\n    // Node count up to quadtree level: (4^L - 1) / (4-1)\n    // (4^L - 1) / (4-1) <= X < (4^(L+1) - 1) / (4-1)\n    // 4^L <= (3x + 1) < 4^(L+1)\n    // L <= log4(3x + 1) < L + 1\n    // L = floor(log4(3x + 1))\n    // L = floor(log2(3x + 1) / log2(4))\n    // L = floor(log2(3x + 1) / 2)\n    level = Math.floor(CesiumMath.log2(3 * tileIndex + 1) / 2);\n    levelOffset = ((1 << 2 * level) - 1) / 3;\n    mortonIndex = tileIndex - levelOffset;\n  }\n  return ImplicitTileCoordinates.fromMortonIndex(subdivisionScheme, subtreeLevels, level, mortonIndex);\n};\nexport default ImplicitTileCoordinates;","map":{"version":3,"names":["CesiumMath","Check","DeveloperError","MortonOrder","ImplicitSubdivisionScheme","ImplicitTileCoordinates","options","typeOf","string","subdivisionScheme","number","subtreeLevels","level","x","y","OCTREE","z","dimensionAtLevel","undefined","Object","defineProperties","prototype","childIndex","get","mortonIndex","encode3D","encode2D","tileIndex","levelOffset","checkMatchingSubtreeShape","a","b","getDescendantCoordinates","offsetCoordinates","object","descendantLevel","descendantX","descendantY","descendantZ","getAncestorCoordinates","offsetLevels","divisor","ancestorLevel","ancestorX","Math","floor","ancestorY","ancestorZ","getOffsetCoordinates","descendantCoordinates","isEqual","isAncestor","offsetLevel","dimensionAtOffsetLevel","offsetX","offsetY","offsetZ","getChildCoordinates","branchingFactor","getBranchingFactor","getSubtreeCoordinates","getParentSubtreeCoordinates","levelDifference","isAncestorX","isAncestorY","isAncestorZ","otherCoordinates","isImplicitTilesetRoot","isSubtreeRoot","isBottomOfSubtree","getTemplateValues","values","scratchCoordinatesArray","fromMortonIndex","coordinatesArray","decode3D","decode2D","fromTileIndex","log2"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ImplicitTileCoordinates.js"],"sourcesContent":["import CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport MortonOrder from \"../Core/MortonOrder.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\n\n/**\n * The coordinates for a tile in an implicit tileset. The coordinates\n * are (level, x, y) for quadtrees or (level, x, y, z) for octrees.\n * <p>\n * Level numbers are 0-indexed and typically start at the root of the implicit\n * tileset (the tile with either implicitTiling in its JSON (3D Tiles 1.1) or\n * the <code>3DTILES_implicit_tiling</code> extension).\n * This object can also represent the relative offset from one set of coordinates\n * to another. See {@link ImplicitTileCoordinates#getOffsetCoordinates}. The term\n * local coordinates refers to coordinates that are relative to the root of a\n * subtree and the term global coordinates refers to coordinates relative to the\n * root of an implicit tileset.\n * </p>\n * <p>\n * For box bounding volumes, x, y, z increase along the +x, +y, and +z\n * directions defined by the half axes.\n * </p>\n * <p>\n * For region bounding volumes, x increases in the +longitude direction, y\n * increases in the +latitude direction, and z increases in the +height\n * direction.\n * </p>\n * <p>\n * Care must be taken when converting between implicit coordinates and Morton\n * indices because there is a 16-bit limit on {@link MortonOrder#encode2D} and\n * a 10-bit limit on {@link MortonOrder#encode3D}. Typically these conversions\n * should be done on local coordinates, not global coordinates, and the maximum\n * number of levels in the subtree should be 15 for quadtree and 9 for octree (to\n * account for the extra level needed by child subtree coordinates).\n * </p>\n *\n * @alias ImplicitTileCoordinates\n * @constructor\n *\n * @param {object} options An object with the following properties:\n * @param {ImplicitSubdivisionScheme} options.subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {number} options.subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {number} options.level The level of a tile relative to the tile with the extension\n * @param {number} options.x The x coordinate of the tile\n * @param {number} options.y The y coordinate of the tile\n * @param {number} [options.z] The z coordinate of the tile. Only required when options.subdivisionScheme is ImplicitSubdivisionScheme.OCTREE\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitTileCoordinates(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.subdivisionScheme\", options.subdivisionScheme);\n  Check.typeOf.number(\"options.subtreeLevels\", options.subtreeLevels);\n  Check.typeOf.number(\"options.level\", options.level);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    Check.typeOf.number(\"options.z\", options.z);\n  }\n  // Check for values that are negative\n  if (options.level < 0) {\n    throw new DeveloperError(\"level must be non-negative\");\n  }\n  if (options.x < 0) {\n    throw new DeveloperError(\"x must be non-negative\");\n  }\n  if (options.y < 0) {\n    throw new DeveloperError(\"y must be non-negative\");\n  }\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    if (options.z < 0) {\n      throw new DeveloperError(\"z must be non-negative\");\n    }\n  }\n\n  // Check for values that are too large\n  const dimensionAtLevel = 1 << options.level;\n  if (options.x >= dimensionAtLevel) {\n    throw new DeveloperError(\"x is out of range\");\n  }\n  if (options.y >= dimensionAtLevel) {\n    throw new DeveloperError(\"y is out of range\");\n  }\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    if (options.z >= dimensionAtLevel) {\n      throw new DeveloperError(\"z is out of range\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Whether the tileset is a quadtree or octree\n   *\n   * @type {ImplicitSubdivisionScheme}\n   * @readonly\n   * @private\n   */\n  this.subdivisionScheme = options.subdivisionScheme;\n\n  /**\n   * The number of distinct levels within the coordinate's subtree\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.subtreeLevels = options.subtreeLevels;\n\n  /**\n   * Level of this tile, relative to the tile with implicit tiling in its JSON\n   * (3D Tiles 1.1) or the <code>3DTILES_implicit_tiling</code> extension.\n   * Level numbers start at 0.\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.level = options.level;\n\n  /**\n   * X coordinate of this tile\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.x = options.x;\n\n  /**\n   * Y coordinate of this tile\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  this.y = options.y;\n\n  /**\n   * Z coordinate of this tile. Only defined for octrees.\n   *\n   * @type {number|undefined}\n   * @readonly\n   * @private\n   */\n  this.z = undefined;\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    this.z = options.z;\n  }\n}\n\nObject.defineProperties(ImplicitTileCoordinates.prototype, {\n  /**\n   * An index in the range of [0, branchingFactor) that indicates\n   * which child of the parent cell these coordinates correspond to.\n   * This can be viewed as a morton index within the parent tile.\n   * <p>\n   * This is the last 3 bits of the morton index of the tile, but it can\n   * be computed more directly by concatenating the bits [z0] y0 x0\n   * </p>\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  childIndex: {\n    get: function () {\n      let childIndex = 0;\n      childIndex |= this.x & 1;\n      childIndex |= (this.y & 1) << 1;\n      if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n        childIndex |= (this.z & 1) << 2;\n      }\n\n      return childIndex;\n    },\n  },\n\n  /**\n   * Get the Morton index for this tile within the current level by interleaving\n   * the bits of the x, y and z coordinates.\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  mortonIndex: {\n    get: function () {\n      if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n        return MortonOrder.encode3D(this.x, this.y, this.z);\n      }\n      return MortonOrder.encode2D(this.x, this.y);\n    },\n  },\n\n  /**\n   * Get the tile index by adding the Morton index to the level offset\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  tileIndex: {\n    get: function () {\n      const levelOffset =\n        this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE\n          ? // (8^N - 1) / (8-1)\n            ((1 << (3 * this.level)) - 1) / 7\n          : // (4^N - 1) / (4-1)\n            ((1 << (2 * this.level)) - 1) / 3;\n\n      const mortonIndex = this.mortonIndex;\n      return levelOffset + mortonIndex;\n    },\n  },\n});\n\n/**\n * Check that the two coordinates are compatible\n * @param {ImplicitTileCoordinates} a\n * @param {ImplicitTileCoordinates} b\n * @private\n */\nfunction checkMatchingSubtreeShape(a, b) {\n  if (a.subdivisionScheme !== b.subdivisionScheme) {\n    throw new DeveloperError(\"coordinates must have same subdivisionScheme\");\n  }\n  if (a.subtreeLevels !== b.subtreeLevels) {\n    throw new DeveloperError(\"coordinates must have same subtreeLevels\");\n  }\n}\n\n/**\n * Compute the coordinates of a tile deeper in the tree with a (level, x, y, [z]) relative offset.\n *\n * @param {ImplicitTileCoordinates} offsetCoordinates The offset from the ancestor\n * @returns {ImplicitTileCoordinates} The coordinates of the descendant\n * @private\n */\nImplicitTileCoordinates.prototype.getDescendantCoordinates = function (\n  offsetCoordinates,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"offsetCoordinates\", offsetCoordinates);\n  checkMatchingSubtreeShape(this, offsetCoordinates);\n  //>>includeEnd('debug');\n\n  const descendantLevel = this.level + offsetCoordinates.level;\n  const descendantX = (this.x << offsetCoordinates.level) + offsetCoordinates.x;\n  const descendantY = (this.y << offsetCoordinates.level) + offsetCoordinates.y;\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const descendantZ =\n      (this.z << offsetCoordinates.level) + offsetCoordinates.z;\n\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: descendantLevel,\n      x: descendantX,\n      y: descendantY,\n      z: descendantZ,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: descendantLevel,\n    x: descendantX,\n    y: descendantY,\n  });\n};\n\n/**\n * Compute the coordinates of a tile higher up in the tree by going up a number of levels.\n *\n * @param {number} offsetLevels The number of levels to go up in the tree\n * @returns {ImplicitTileCoordinates} The coordinates of the ancestor\n * @private\n */\nImplicitTileCoordinates.prototype.getAncestorCoordinates = function (\n  offsetLevels,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"offsetLevels\", offsetLevels);\n  if (offsetLevels < 0) {\n    throw new DeveloperError(\"offsetLevels must be non-negative\");\n  }\n  if (offsetLevels > this.level) {\n    throw new DeveloperError(\"ancestor cannot be above the tileset root\");\n  }\n  //>>includeEnd('debug');\n\n  const divisor = 1 << offsetLevels;\n  const ancestorLevel = this.level - offsetLevels;\n  const ancestorX = Math.floor(this.x / divisor);\n  const ancestorY = Math.floor(this.y / divisor);\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const ancestorZ = Math.floor(this.z / divisor);\n\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: ancestorLevel,\n      x: ancestorX,\n      y: ancestorY,\n      z: ancestorZ,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: ancestorLevel,\n    x: ancestorX,\n    y: ancestorY,\n  });\n};\n\n/**\n * Compute the (level, x, y, [z]) offset to a descendant\n *\n * @param {ImplicitTileCoordinates} descendantCoordinates The descendant coordinates\n * @returns {ImplicitTileCoordinates} The offset between the ancestor and the descendant\n */\nImplicitTileCoordinates.prototype.getOffsetCoordinates = function (\n  descendantCoordinates,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"descendantCoordinates\", descendantCoordinates);\n  if (\n    !this.isEqual(descendantCoordinates) &&\n    !this.isAncestor(descendantCoordinates)\n  ) {\n    throw new DeveloperError(\"this is not an ancestor of descendant\");\n  }\n  checkMatchingSubtreeShape(this, descendantCoordinates);\n  //>>includeEnd('debug');\n\n  const offsetLevel = descendantCoordinates.level - this.level;\n  const dimensionAtOffsetLevel = 1 << offsetLevel;\n\n  const offsetX = descendantCoordinates.x % dimensionAtOffsetLevel;\n  const offsetY = descendantCoordinates.y % dimensionAtOffsetLevel;\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const offsetZ = descendantCoordinates.z % dimensionAtOffsetLevel;\n\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: offsetLevel,\n      x: offsetX,\n      y: offsetY,\n      z: offsetZ,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: offsetLevel,\n    x: offsetX,\n    y: offsetY,\n  });\n};\n\n/**\n * Given the morton index of the child, compute the coordinates of the child.\n * This is a special case of {@link ImplicitTileCoordinates#getDescendantCoordinates}.\n *\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @returns {ImplicitTileCoordinates} The tile coordinates of the child\n * @private\n */\nImplicitTileCoordinates.prototype.getChildCoordinates = function (childIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"childIndex\", childIndex);\n  const branchingFactor = ImplicitSubdivisionScheme.getBranchingFactor(\n    this.subdivisionScheme,\n  );\n  if (childIndex < 0 || branchingFactor <= childIndex) {\n    throw new DeveloperError(\n      `childIndex must be at least 0 and less than ${branchingFactor}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const level = this.level + 1;\n  const x = 2 * this.x + (childIndex % 2);\n  const y = 2 * this.y + (Math.floor(childIndex / 2) % 2);\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const z = 2 * this.z + (Math.floor(childIndex / 4) % 2);\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: level,\n      x: x,\n      y: y,\n      z: z,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: level,\n    x: x,\n    y: y,\n  });\n};\n\n/**\n * Get the coordinates of the subtree that contains this tile. If the tile is\n * the root of the subtree, the root of the subtree is returned.\n *\n * @returns {ImplicitTileCoordinates} The subtree that contains this tile\n * @private\n */\nImplicitTileCoordinates.prototype.getSubtreeCoordinates = function () {\n  return this.getAncestorCoordinates(this.level % this.subtreeLevels);\n};\n\n/**\n * Get the coordinates of the parent subtree that contains this tile\n *\n * @returns {ImplicitTileCoordinates} The parent subtree that contains this tile\n * @private\n */\nImplicitTileCoordinates.prototype.getParentSubtreeCoordinates = function () {\n  return this.getAncestorCoordinates(\n    (this.level % this.subtreeLevels) + this.subtreeLevels,\n  );\n};\n\n/**\n * Returns whether this tile is an ancestor of another tile\n *\n * @param {ImplicitTileCoordinates} descendantCoordinates the descendant coordinates\n * @returns {boolean} <code>true</code> if this tile is an ancestor of the other tile\n * @private\n */\nImplicitTileCoordinates.prototype.isAncestor = function (\n  descendantCoordinates,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"descendantCoordinates\", descendantCoordinates);\n  checkMatchingSubtreeShape(this, descendantCoordinates);\n  //>>includeEnd('debug');\n\n  const levelDifference = descendantCoordinates.level - this.level;\n  if (levelDifference <= 0) {\n    return false;\n  }\n\n  const ancestorX = descendantCoordinates.x >> levelDifference;\n  const ancestorY = descendantCoordinates.y >> levelDifference;\n  const isAncestorX = this.x === ancestorX;\n  const isAncestorY = this.y === ancestorY;\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const ancestorZ = descendantCoordinates.z >> levelDifference;\n    const isAncestorZ = this.z === ancestorZ;\n    return isAncestorX && isAncestorY && isAncestorZ;\n  }\n\n  // Quadtree\n  return isAncestorX && isAncestorY;\n};\n\n/**\n * Returns whether the provided coordinates are equal to this coordinate\n *\n * @param {ImplicitTileCoordinates} otherCoordinates the other coordinates\n * @returns {boolean} <code>true</code> if the coordinates are equal\n * @private\n */\nImplicitTileCoordinates.prototype.isEqual = function (otherCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"otherCoordinates\", otherCoordinates);\n  //>>includeEnd('debug');\n\n  return (\n    this.subdivisionScheme === otherCoordinates.subdivisionScheme &&\n    this.subtreeLevels === otherCoordinates.subtreeLevels &&\n    this.level === otherCoordinates.level &&\n    this.x === otherCoordinates.x &&\n    this.y === otherCoordinates.y &&\n    (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE\n      ? this.z === otherCoordinates.z\n      : true)\n  );\n};\n\n/**\n * Returns whether this tile is the root of the implicit tileset\n *\n * @returns {boolean} <code>true</code> if this tile is the root\n * @private\n */\nImplicitTileCoordinates.prototype.isImplicitTilesetRoot = function () {\n  return this.level === 0;\n};\n\n/**\n * Returns whether this tile is the root of the subtree\n *\n * @returns {boolean} <code>true</code> if this tile is the root of the subtree\n * @private\n */\nImplicitTileCoordinates.prototype.isSubtreeRoot = function () {\n  return this.level % this.subtreeLevels === 0;\n};\n\n/**\n * Returns whether this tile is on the last row of tiles in the subtree\n *\n * @returns {boolean} <code>true</code> if this tile is on the last row of tiles in the subtree\n * @private\n */\nImplicitTileCoordinates.prototype.isBottomOfSubtree = function () {\n  return this.level % this.subtreeLevels === this.subtreeLevels - 1;\n};\n\n/**\n * Get a dictionary of values for templating into an implicit template URI.\n *\n * @returns {object} An object suitable for use with {@link Resource#getDerivedResource}\n * @private\n */\nImplicitTileCoordinates.prototype.getTemplateValues = function () {\n  const values = {\n    level: this.level,\n    x: this.x,\n    y: this.y,\n  };\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    values.z = this.z;\n  }\n\n  return values;\n};\n\nconst scratchCoordinatesArray = [0, 0, 0];\n\n/**\n * Given a level number, morton index, and whether the tileset is an\n * octree/quadtree, compute the (level, x, y, [z]) coordinates\n *\n * @param {ImplicitSubdivisionScheme} subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {number} subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {number} level The level of the tree\n * @param {number} mortonIndex The morton index of the tile.\n * @returns {ImplicitTileCoordinates} The coordinates of the tile with the given Morton index\n * @private\n */\nImplicitTileCoordinates.fromMortonIndex = function (\n  subdivisionScheme,\n  subtreeLevels,\n  level,\n  mortonIndex,\n) {\n  let coordinatesArray;\n  if (subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    coordinatesArray = MortonOrder.decode3D(\n      mortonIndex,\n      scratchCoordinatesArray,\n    );\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: subdivisionScheme,\n      subtreeLevels: subtreeLevels,\n      level: level,\n      x: coordinatesArray[0],\n      y: coordinatesArray[1],\n      z: coordinatesArray[2],\n    });\n  }\n\n  coordinatesArray = MortonOrder.decode2D(mortonIndex, scratchCoordinatesArray);\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: subdivisionScheme,\n    subtreeLevels: subtreeLevels,\n    level: level,\n    x: coordinatesArray[0],\n    y: coordinatesArray[1],\n  });\n};\n\n/**\n * Given a tile index and whether the tileset is an octree/quadtree, compute\n * the (level, x, y, [z]) coordinates\n *\n * @param {ImplicitSubdivisionScheme} subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {number} subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {number} tileIndex The tile's index\n * @returns {ImplicitTileCoordinates} The coordinates of the tile with the given tile index\n * @private\n */\nImplicitTileCoordinates.fromTileIndex = function (\n  subdivisionScheme,\n  subtreeLevels,\n  tileIndex,\n) {\n  let level;\n  let levelOffset;\n  let mortonIndex;\n\n  if (subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    // Node count up to octree level: (8^L - 1) / (8-1)\n    // (8^L - 1) / (8-1) <= X < (8^(L+1) - 1) / (8-1)\n    // 8^L <= (7x + 1) < 8^(L+1)\n    // L <= log8(7x + 1) < L + 1\n    // L = floor(log8(7x + 1))\n    // L = floor(log2(7x + 1) / log2(8))\n    // L = floor(log2(7x + 1) / 3)\n    level = Math.floor(CesiumMath.log2(7 * tileIndex + 1) / 3);\n    levelOffset = ((1 << (3 * level)) - 1) / 7;\n    mortonIndex = tileIndex - levelOffset;\n  } else {\n    // Node count up to quadtree level: (4^L - 1) / (4-1)\n    // (4^L - 1) / (4-1) <= X < (4^(L+1) - 1) / (4-1)\n    // 4^L <= (3x + 1) < 4^(L+1)\n    // L <= log4(3x + 1) < L + 1\n    // L = floor(log4(3x + 1))\n    // L = floor(log2(3x + 1) / log2(4))\n    // L = floor(log2(3x + 1) / 2)\n    level = Math.floor(CesiumMath.log2(3 * tileIndex + 1) / 2);\n    levelOffset = ((1 << (2 * level)) - 1) / 3;\n    mortonIndex = tileIndex - levelOffset;\n  }\n\n  return ImplicitTileCoordinates.fromMortonIndex(\n    subdivisionScheme,\n    subtreeLevels,\n    level,\n    mortonIndex,\n  );\n};\n\nexport default ImplicitTileCoordinates;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}