{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport Interval from \"../Core/Interval.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport Camera from \"./Camera.js\";\nimport FrustumCommands from \"./FrustumCommands.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport GlobeTranslucencyFramebuffer from \"./GlobeTranslucencyFramebuffer.js\";\nimport OIT from \"./OIT.js\";\nimport PickDepthFramebuffer from \"./PickDepthFramebuffer.js\";\nimport PickFramebuffer from \"./PickFramebuffer.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMap from \"./ShadowMap.js\";\nimport TranslucentTileClassification from \"./TranslucentTileClassification.js\";\nfunction CommandExtent() {\n  this.command = undefined;\n  this.near = undefined;\n  this.far = undefined;\n}\n\n/**\n * @alias View\n * @constructor\n *\n * @param {Scene} scene\n * @param {Camera} camera\n * @param {BoundingRectangle} viewport\n *\n * @private\n */\nfunction View(scene, camera, viewport) {\n  const context = scene.context;\n  let globeDepth;\n  if (context.depthTexture) {\n    globeDepth = new GlobeDepth();\n  }\n  let oit;\n  if (scene._useOIT && context.depthTexture) {\n    oit = new OIT(context);\n  }\n  const passState = new PassState(context);\n  passState.viewport = BoundingRectangle.clone(viewport);\n  this.camera = camera;\n  this._cameraClone = Camera.clone(camera);\n  this._cameraStartFired = false;\n  this._cameraMovedTime = undefined;\n  this.viewport = viewport;\n  this.passState = passState;\n  this.pickFramebuffer = new PickFramebuffer(context);\n  this.pickDepthFramebuffer = new PickDepthFramebuffer();\n  this.sceneFramebuffer = new SceneFramebuffer();\n  this.globeDepth = globeDepth;\n  this.globeTranslucencyFramebuffer = new GlobeTranslucencyFramebuffer();\n  this.oit = oit;\n  this.translucentTileClassification = new TranslucentTileClassification(context);\n  /**\n   * @type {PickDepth[]}\n   */\n  this.pickDepths = [];\n  this.frustumCommandsList = [];\n  this.debugFrustumStatistics = undefined;\n\n  // Array of all commands that get rendered into frustums along with their near / far values.\n  // Acts similar to a ManagedArray.\n  this._commandExtents = [];\n}\nconst scratchPosition0 = new Cartesian3();\nconst scratchPosition1 = new Cartesian3();\n/**\n * Check if two cameras have the same view.\n *\n * @param {Camera} camera0 The first camera for comparison.\n * @param {Camera} camera1 The second camera for comparison.\n * @param {number} epsilon The epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if the cameras are equal.\n *\n * @private\n */\nfunction cameraEqual(camera0, camera1, epsilon) {\n  const maximumPositionComponent = Math.max(Cartesian3.maximumComponent(Cartesian3.abs(camera0.position, scratchPosition0)), Cartesian3.maximumComponent(Cartesian3.abs(camera1.position, scratchPosition1)));\n  const scalar = 1 / Math.max(1, maximumPositionComponent);\n  Cartesian3.multiplyByScalar(camera0.position, scalar, scratchPosition0);\n  Cartesian3.multiplyByScalar(camera1.position, scalar, scratchPosition1);\n  return Cartesian3.equalsEpsilon(scratchPosition0, scratchPosition1, epsilon) && Cartesian3.equalsEpsilon(camera0.direction, camera1.direction, epsilon) && Cartesian3.equalsEpsilon(camera0.up, camera1.up, epsilon) && Cartesian3.equalsEpsilon(camera0.right, camera1.right, epsilon) && Matrix4.equalsEpsilon(camera0.transform, camera1.transform, epsilon) && camera0.frustum.equalsEpsilon(camera1.frustum, epsilon);\n}\n\n/**\n * Check if the camera position or direction has changed.\n *\n * @param {Scene} scene\n * @returns {boolean} <code>true</code> if the camera has been updated\n *\n * @private\n */\nView.prototype.checkForCameraUpdates = function (scene) {\n  const camera = this.camera;\n  const cameraClone = this._cameraClone;\n  if (!cameraEqual(camera, cameraClone, CesiumMath.EPSILON15)) {\n    if (!this._cameraStartFired) {\n      camera.moveStart.raiseEvent();\n      this._cameraStartFired = true;\n    }\n    this._cameraMovedTime = getTimestamp();\n    Camera.clone(camera, cameraClone);\n    return true;\n  }\n  if (this._cameraStartFired && getTimestamp() - this._cameraMovedTime > scene.cameraEventWaitTime) {\n    camera.moveEnd.raiseEvent();\n    this._cameraStartFired = false;\n  }\n  return false;\n};\n\n/**\n * Split the depth range of the scene into multiple frustums, and initialize\n * a list of {@link FrustumCommands} with the distances to the near and far\n * planes for each frustum.\n *\n * @param {View} view The view to which the frustum commands list is attached.\n * @param {Scene} scene The scene to be rendered.\n * @param {number} near The distance to the nearest object in the scene.\n * @param {number} far The distance to the farthest object in the scene.\n *\n * @private\n */\nfunction updateFrustums(view, scene, near, far) {\n  const {\n    frameState\n  } = scene;\n  const {\n    camera,\n    useLogDepth\n  } = frameState;\n  const farToNearRatio = useLogDepth ? scene.logarithmicDepthFarToNearRatio : scene.farToNearRatio;\n  const is2D = scene.mode === SceneMode.SCENE2D;\n  const nearToFarDistance2D = scene.nearToFarDistance2D;\n\n  // Extend the far plane slightly further to prevent geometry clipping against the far plane.\n  far *= 1.0 + CesiumMath.EPSILON2;\n\n  // The computed near plane must be between the user defined near and far planes.\n  // The computed far plane must between the user defined far and computed near.\n  // This will handle the case where the computed near plane is further than the user defined far plane.\n  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);\n  far = Math.max(Math.min(far, camera.frustum.far), near);\n  let numFrustums;\n  if (is2D) {\n    // The multifrustum for 2D is uniformly distributed. To avoid z-fighting in 2D,\n    // the camera is moved to just before the frustum and the frustum depth is scaled\n    // to be in [1.0, nearToFarDistance2D].\n    far = Math.min(far, camera.position.z + scene.nearToFarDistance2D);\n    near = Math.min(near, far);\n    numFrustums = Math.ceil(Math.max(1.0, far - near) / scene.nearToFarDistance2D);\n  } else {\n    // The multifrustum for 3D/CV is non-uniformly distributed.\n    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  }\n  const {\n    frustumCommandsList\n  } = view;\n  frustumCommandsList.length = numFrustums;\n  for (let m = 0; m < numFrustums; ++m) {\n    let curNear;\n    let curFar;\n    if (is2D) {\n      curNear = Math.min(far - nearToFarDistance2D, near + m * nearToFarDistance2D);\n      curFar = Math.min(far, curNear + nearToFarDistance2D);\n    } else {\n      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);\n      curFar = Math.min(far, farToNearRatio * curNear);\n    }\n    let frustumCommands = frustumCommandsList[m];\n    if (!defined(frustumCommands)) {\n      frustumCommands = frustumCommandsList[m] = new FrustumCommands(curNear, curFar);\n    } else {\n      frustumCommands.near = curNear;\n      frustumCommands.far = curFar;\n    }\n  }\n}\n\n/**\n * Insert a command into the appropriate {@link FrustumCommands} based on the\n * range of depths covered by its bounding volume.\n *\n * @param {View} view\n * @param {Scene} scene\n * @param {CommandExtent} commandExtent\n *\n * @private\n */\nfunction insertIntoBin(view, scene, commandExtent) {\n  const {\n    command,\n    near,\n    far\n  } = commandExtent;\n  if (scene.debugShowFrustums) {\n    command.debugOverlappingFrustums = 0;\n  }\n  const {\n    frustumCommandsList\n  } = view;\n  for (let i = 0; i < frustumCommandsList.length; ++i) {\n    const frustumCommands = frustumCommandsList[i];\n    if (near > frustumCommands.far) {\n      continue;\n    }\n    if (far < frustumCommands.near) {\n      break;\n    }\n    const pass = command.pass;\n    const index = frustumCommands.indices[pass]++;\n    frustumCommands.commands[pass][index] = command;\n    if (scene.debugShowFrustums) {\n      command.debugOverlappingFrustums |= 1 << i;\n    }\n    if (command.executeInClosestFrustum) {\n      break;\n    }\n  }\n  if (scene.debugShowFrustums) {\n    const {\n      debugFrustumStatistics\n    } = view;\n    const {\n      debugOverlappingFrustums\n    } = command;\n    const cf = debugFrustumStatistics.commandsInFrustums;\n    cf[debugOverlappingFrustums] = defined(cf[debugOverlappingFrustums]) ? cf[debugOverlappingFrustums] + 1 : 1;\n    ++debugFrustumStatistics.totalCommands;\n  }\n  scene.updateDerivedCommands(command);\n}\nconst scratchCullingVolume = new CullingVolume();\nconst scratchNearFarInterval = new Interval();\nView.prototype.createPotentiallyVisibleSet = function (scene) {\n  const {\n    frameState\n  } = scene;\n  const {\n    camera,\n    commandList,\n    shadowState\n  } = frameState;\n  const {\n    positionWC,\n    directionWC,\n    frustum\n  } = camera;\n  const computeList = scene._computeCommandList;\n  const overlayList = scene._overlayCommandList;\n  if (scene.debugShowFrustums) {\n    this.debugFrustumStatistics = {\n      totalCommands: 0,\n      commandsInFrustums: {}\n    };\n  }\n  const frustumCommandsList = this.frustumCommandsList;\n  for (let n = 0; n < frustumCommandsList.length; ++n) {\n    for (let p = 0; p < Pass.NUMBER_OF_PASSES; ++p) {\n      frustumCommandsList[n].indices[p] = 0;\n    }\n  }\n  computeList.length = 0;\n  overlayList.length = 0;\n  const commandExtents = this._commandExtents;\n  const commandExtentCapacity = commandExtents.length;\n  let commandExtentCount = 0;\n  let near = +Number.MAX_VALUE;\n  let far = -Number.MAX_VALUE;\n  const {\n    shadowsEnabled\n  } = shadowState;\n  let shadowNear = +Number.MAX_VALUE;\n  let shadowFar = -Number.MAX_VALUE;\n  let shadowClosestObjectSize = Number.MAX_VALUE;\n  const occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n\n  // get user culling volume minus the far plane.\n  let {\n    cullingVolume\n  } = frameState;\n  const planes = scratchCullingVolume.planes;\n  for (let k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n  cullingVolume = scratchCullingVolume;\n  for (let i = 0; i < commandList.length; ++i) {\n    const command = commandList[i];\n    const {\n      pass,\n      boundingVolume\n    } = command;\n    if (pass === Pass.COMPUTE) {\n      computeList.push(command);\n    } else if (pass === Pass.OVERLAY) {\n      overlayList.push(command);\n    } else {\n      let commandNear;\n      let commandFar;\n      if (defined(boundingVolume)) {\n        if (!scene.isVisible(cullingVolume, command, occluder)) {\n          continue;\n        }\n        const nearFarInterval = boundingVolume.computePlaneDistances(positionWC, directionWC, scratchNearFarInterval);\n        commandNear = nearFarInterval.start;\n        commandFar = nearFarInterval.stop;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n\n        // Compute a tight near and far plane for commands that receive shadows. This helps compute\n        // good splits for cascaded shadow maps. Ignore commands that exceed the maximum distance.\n        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes\n        // throw off the near/far fitting for the shadow map. Only update for globe tiles that the\n        // camera isn't inside.\n        if (shadowsEnabled && command.receiveShadows && commandNear < ShadowMap.MAXIMUM_DISTANCE && !(pass === Pass.GLOBE && commandNear < -100.0 && commandFar > 100.0)) {\n          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.\n          const size = commandFar - commandNear;\n          if (pass !== Pass.GLOBE && commandNear < 100.0) {\n            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);\n          }\n          shadowNear = Math.min(shadowNear, commandNear);\n          shadowFar = Math.max(shadowFar, commandFar);\n        }\n      } else if (command instanceof ClearCommand) {\n        // Clear commands don't need a bounding volume - just add the clear to all frustums.\n        commandNear = frustum.near;\n        commandFar = frustum.far;\n      } else {\n        // If command has no bounding volume we need to use the camera's\n        // worst-case near and far planes to avoid clipping something important.\n        commandNear = frustum.near;\n        commandFar = frustum.far;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n      }\n      let extent = commandExtents[commandExtentCount];\n      if (!defined(extent)) {\n        extent = commandExtents[commandExtentCount] = new CommandExtent();\n      }\n      extent.command = command;\n      extent.near = commandNear;\n      extent.far = commandFar;\n      commandExtentCount++;\n    }\n  }\n  if (shadowsEnabled) {\n    shadowNear = Math.min(Math.max(shadowNear, frustum.near), frustum.far);\n    shadowFar = Math.max(Math.min(shadowFar, frustum.far), shadowNear);\n    // Use the computed near and far for shadows\n    shadowState.nearPlane = shadowNear;\n    shadowState.farPlane = shadowFar;\n    shadowState.closestObjectSize = shadowClosestObjectSize;\n  }\n  updateFrustums(this, scene, near, far);\n  for (let c = 0; c < commandExtentCount; c++) {\n    insertIntoBin(this, scene, commandExtents[c]);\n  }\n\n  // Dereference old commands\n  if (commandExtentCount < commandExtentCapacity) {\n    for (let c = commandExtentCount; c < commandExtentCapacity; c++) {\n      const commandExtent = commandExtents[c];\n      if (!defined(commandExtent.command)) {\n        // If the command is undefined, it's assumed that all\n        // subsequent commmands were set to undefined as well,\n        // so no need to loop over them all\n        break;\n      }\n      commandExtent.command = undefined;\n    }\n  }\n  const numFrustums = frustumCommandsList.length;\n  const {\n    frustumSplits\n  } = frameState;\n  frustumSplits.length = numFrustums + 1;\n  for (let j = 0; j < numFrustums; ++j) {\n    frustumSplits[j] = frustumCommandsList[j].near;\n    if (j === numFrustums - 1) {\n      frustumSplits[j + 1] = frustumCommandsList[j].far;\n    }\n  }\n};\nView.prototype.destroy = function () {\n  this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy();\n  this.pickDepthFramebuffer = this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy();\n  this.sceneFramebuffer = this.sceneFramebuffer && this.sceneFramebuffer.destroy();\n  this.globeDepth = this.globeDepth && this.globeDepth.destroy();\n  this.oit = this.oit && this.oit.destroy();\n  this.translucentTileClassification = this.translucentTileClassification && this.translucentTileClassification.destroy();\n  this.globeTranslucencyFramebuffer = this.globeTranslucencyFramebuffer && this.globeTranslucencyFramebuffer.destroy();\n  const pickDepths = this.pickDepths;\n  for (let i = 0; i < pickDepths.length; ++i) {\n    pickDepths[i].destroy();\n  }\n};\nexport default View;","map":{"version":3,"names":["BoundingRectangle","Cartesian3","CullingVolume","defined","getTimestamp","Interval","CesiumMath","Matrix4","ClearCommand","Pass","PassState","Camera","FrustumCommands","GlobeDepth","GlobeTranslucencyFramebuffer","OIT","PickDepthFramebuffer","PickFramebuffer","SceneFramebuffer","SceneMode","ShadowMap","TranslucentTileClassification","CommandExtent","command","undefined","near","far","View","scene","camera","viewport","context","globeDepth","depthTexture","oit","_useOIT","passState","clone","_cameraClone","_cameraStartFired","_cameraMovedTime","pickFramebuffer","pickDepthFramebuffer","sceneFramebuffer","globeTranslucencyFramebuffer","translucentTileClassification","pickDepths","frustumCommandsList","debugFrustumStatistics","_commandExtents","scratchPosition0","scratchPosition1","cameraEqual","camera0","camera1","epsilon","maximumPositionComponent","Math","max","maximumComponent","abs","position","scalar","multiplyByScalar","equalsEpsilon","direction","up","right","transform","frustum","prototype","checkForCameraUpdates","cameraClone","EPSILON15","moveStart","raiseEvent","cameraEventWaitTime","moveEnd","updateFrustums","view","frameState","useLogDepth","farToNearRatio","logarithmicDepthFarToNearRatio","is2D","mode","SCENE2D","nearToFarDistance2D","EPSILON2","min","numFrustums","z","ceil","log","length","m","curNear","curFar","pow","frustumCommands","insertIntoBin","commandExtent","debugShowFrustums","debugOverlappingFrustums","i","pass","index","indices","commands","executeInClosestFrustum","cf","commandsInFrustums","totalCommands","updateDerivedCommands","scratchCullingVolume","scratchNearFarInterval","createPotentiallyVisibleSet","commandList","shadowState","positionWC","directionWC","computeList","_computeCommandList","overlayList","_overlayCommandList","n","p","NUMBER_OF_PASSES","commandExtents","commandExtentCapacity","commandExtentCount","Number","MAX_VALUE","shadowsEnabled","shadowNear","shadowFar","shadowClosestObjectSize","occluder","SCENE3D","cullingVolume","planes","k","boundingVolume","COMPUTE","push","OVERLAY","commandNear","commandFar","isVisible","nearFarInterval","computePlaneDistances","start","stop","receiveShadows","MAXIMUM_DISTANCE","GLOBE","size","extent","nearPlane","farPlane","closestObjectSize","c","frustumSplits","j","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/View.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport Interval from \"../Core/Interval.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport Camera from \"./Camera.js\";\nimport FrustumCommands from \"./FrustumCommands.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport GlobeTranslucencyFramebuffer from \"./GlobeTranslucencyFramebuffer.js\";\nimport OIT from \"./OIT.js\";\nimport PickDepthFramebuffer from \"./PickDepthFramebuffer.js\";\nimport PickFramebuffer from \"./PickFramebuffer.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMap from \"./ShadowMap.js\";\nimport TranslucentTileClassification from \"./TranslucentTileClassification.js\";\n\nfunction CommandExtent() {\n  this.command = undefined;\n  this.near = undefined;\n  this.far = undefined;\n}\n\n/**\n * @alias View\n * @constructor\n *\n * @param {Scene} scene\n * @param {Camera} camera\n * @param {BoundingRectangle} viewport\n *\n * @private\n */\nfunction View(scene, camera, viewport) {\n  const context = scene.context;\n\n  let globeDepth;\n  if (context.depthTexture) {\n    globeDepth = new GlobeDepth();\n  }\n\n  let oit;\n  if (scene._useOIT && context.depthTexture) {\n    oit = new OIT(context);\n  }\n\n  const passState = new PassState(context);\n  passState.viewport = BoundingRectangle.clone(viewport);\n\n  this.camera = camera;\n  this._cameraClone = Camera.clone(camera);\n  this._cameraStartFired = false;\n  this._cameraMovedTime = undefined;\n\n  this.viewport = viewport;\n  this.passState = passState;\n  this.pickFramebuffer = new PickFramebuffer(context);\n  this.pickDepthFramebuffer = new PickDepthFramebuffer();\n  this.sceneFramebuffer = new SceneFramebuffer();\n  this.globeDepth = globeDepth;\n  this.globeTranslucencyFramebuffer = new GlobeTranslucencyFramebuffer();\n  this.oit = oit;\n  this.translucentTileClassification = new TranslucentTileClassification(\n    context,\n  );\n  /**\n   * @type {PickDepth[]}\n   */\n  this.pickDepths = [];\n  this.frustumCommandsList = [];\n  this.debugFrustumStatistics = undefined;\n\n  // Array of all commands that get rendered into frustums along with their near / far values.\n  // Acts similar to a ManagedArray.\n  this._commandExtents = [];\n}\n\nconst scratchPosition0 = new Cartesian3();\nconst scratchPosition1 = new Cartesian3();\n/**\n * Check if two cameras have the same view.\n *\n * @param {Camera} camera0 The first camera for comparison.\n * @param {Camera} camera1 The second camera for comparison.\n * @param {number} epsilon The epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if the cameras are equal.\n *\n * @private\n */\nfunction cameraEqual(camera0, camera1, epsilon) {\n  const maximumPositionComponent = Math.max(\n    Cartesian3.maximumComponent(\n      Cartesian3.abs(camera0.position, scratchPosition0),\n    ),\n    Cartesian3.maximumComponent(\n      Cartesian3.abs(camera1.position, scratchPosition1),\n    ),\n  );\n  const scalar = 1 / Math.max(1, maximumPositionComponent);\n  Cartesian3.multiplyByScalar(camera0.position, scalar, scratchPosition0);\n  Cartesian3.multiplyByScalar(camera1.position, scalar, scratchPosition1);\n  return (\n    Cartesian3.equalsEpsilon(scratchPosition0, scratchPosition1, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.direction, camera1.direction, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.up, camera1.up, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.right, camera1.right, epsilon) &&\n    Matrix4.equalsEpsilon(camera0.transform, camera1.transform, epsilon) &&\n    camera0.frustum.equalsEpsilon(camera1.frustum, epsilon)\n  );\n}\n\n/**\n * Check if the camera position or direction has changed.\n *\n * @param {Scene} scene\n * @returns {boolean} <code>true</code> if the camera has been updated\n *\n * @private\n */\nView.prototype.checkForCameraUpdates = function (scene) {\n  const camera = this.camera;\n  const cameraClone = this._cameraClone;\n  if (!cameraEqual(camera, cameraClone, CesiumMath.EPSILON15)) {\n    if (!this._cameraStartFired) {\n      camera.moveStart.raiseEvent();\n      this._cameraStartFired = true;\n    }\n    this._cameraMovedTime = getTimestamp();\n    Camera.clone(camera, cameraClone);\n\n    return true;\n  }\n\n  if (\n    this._cameraStartFired &&\n    getTimestamp() - this._cameraMovedTime > scene.cameraEventWaitTime\n  ) {\n    camera.moveEnd.raiseEvent();\n    this._cameraStartFired = false;\n  }\n\n  return false;\n};\n\n/**\n * Split the depth range of the scene into multiple frustums, and initialize\n * a list of {@link FrustumCommands} with the distances to the near and far\n * planes for each frustum.\n *\n * @param {View} view The view to which the frustum commands list is attached.\n * @param {Scene} scene The scene to be rendered.\n * @param {number} near The distance to the nearest object in the scene.\n * @param {number} far The distance to the farthest object in the scene.\n *\n * @private\n */\nfunction updateFrustums(view, scene, near, far) {\n  const { frameState } = scene;\n  const { camera, useLogDepth } = frameState;\n  const farToNearRatio = useLogDepth\n    ? scene.logarithmicDepthFarToNearRatio\n    : scene.farToNearRatio;\n  const is2D = scene.mode === SceneMode.SCENE2D;\n  const nearToFarDistance2D = scene.nearToFarDistance2D;\n\n  // Extend the far plane slightly further to prevent geometry clipping against the far plane.\n  far *= 1.0 + CesiumMath.EPSILON2;\n\n  // The computed near plane must be between the user defined near and far planes.\n  // The computed far plane must between the user defined far and computed near.\n  // This will handle the case where the computed near plane is further than the user defined far plane.\n  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);\n  far = Math.max(Math.min(far, camera.frustum.far), near);\n\n  let numFrustums;\n  if (is2D) {\n    // The multifrustum for 2D is uniformly distributed. To avoid z-fighting in 2D,\n    // the camera is moved to just before the frustum and the frustum depth is scaled\n    // to be in [1.0, nearToFarDistance2D].\n    far = Math.min(far, camera.position.z + scene.nearToFarDistance2D);\n    near = Math.min(near, far);\n    numFrustums = Math.ceil(\n      Math.max(1.0, far - near) / scene.nearToFarDistance2D,\n    );\n  } else {\n    // The multifrustum for 3D/CV is non-uniformly distributed.\n    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  }\n\n  const { frustumCommandsList } = view;\n  frustumCommandsList.length = numFrustums;\n  for (let m = 0; m < numFrustums; ++m) {\n    let curNear;\n    let curFar;\n\n    if (is2D) {\n      curNear = Math.min(\n        far - nearToFarDistance2D,\n        near + m * nearToFarDistance2D,\n      );\n      curFar = Math.min(far, curNear + nearToFarDistance2D);\n    } else {\n      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);\n      curFar = Math.min(far, farToNearRatio * curNear);\n    }\n    let frustumCommands = frustumCommandsList[m];\n    if (!defined(frustumCommands)) {\n      frustumCommands = frustumCommandsList[m] = new FrustumCommands(\n        curNear,\n        curFar,\n      );\n    } else {\n      frustumCommands.near = curNear;\n      frustumCommands.far = curFar;\n    }\n  }\n}\n\n/**\n * Insert a command into the appropriate {@link FrustumCommands} based on the\n * range of depths covered by its bounding volume.\n *\n * @param {View} view\n * @param {Scene} scene\n * @param {CommandExtent} commandExtent\n *\n * @private\n */\nfunction insertIntoBin(view, scene, commandExtent) {\n  const { command, near, far } = commandExtent;\n\n  if (scene.debugShowFrustums) {\n    command.debugOverlappingFrustums = 0;\n  }\n\n  const { frustumCommandsList } = view;\n\n  for (let i = 0; i < frustumCommandsList.length; ++i) {\n    const frustumCommands = frustumCommandsList[i];\n\n    if (near > frustumCommands.far) {\n      continue;\n    }\n\n    if (far < frustumCommands.near) {\n      break;\n    }\n\n    const pass = command.pass;\n    const index = frustumCommands.indices[pass]++;\n    frustumCommands.commands[pass][index] = command;\n\n    if (scene.debugShowFrustums) {\n      command.debugOverlappingFrustums |= 1 << i;\n    }\n\n    if (command.executeInClosestFrustum) {\n      break;\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    const { debugFrustumStatistics } = view;\n    const { debugOverlappingFrustums } = command;\n    const cf = debugFrustumStatistics.commandsInFrustums;\n    cf[debugOverlappingFrustums] = defined(cf[debugOverlappingFrustums])\n      ? cf[debugOverlappingFrustums] + 1\n      : 1;\n    ++debugFrustumStatistics.totalCommands;\n  }\n\n  scene.updateDerivedCommands(command);\n}\n\nconst scratchCullingVolume = new CullingVolume();\nconst scratchNearFarInterval = new Interval();\n\nView.prototype.createPotentiallyVisibleSet = function (scene) {\n  const { frameState } = scene;\n  const { camera, commandList, shadowState } = frameState;\n  const { positionWC, directionWC, frustum } = camera;\n\n  const computeList = scene._computeCommandList;\n  const overlayList = scene._overlayCommandList;\n\n  if (scene.debugShowFrustums) {\n    this.debugFrustumStatistics = {\n      totalCommands: 0,\n      commandsInFrustums: {},\n    };\n  }\n\n  const frustumCommandsList = this.frustumCommandsList;\n  for (let n = 0; n < frustumCommandsList.length; ++n) {\n    for (let p = 0; p < Pass.NUMBER_OF_PASSES; ++p) {\n      frustumCommandsList[n].indices[p] = 0;\n    }\n  }\n\n  computeList.length = 0;\n  overlayList.length = 0;\n\n  const commandExtents = this._commandExtents;\n  const commandExtentCapacity = commandExtents.length;\n  let commandExtentCount = 0;\n\n  let near = +Number.MAX_VALUE;\n  let far = -Number.MAX_VALUE;\n\n  const { shadowsEnabled } = shadowState;\n  let shadowNear = +Number.MAX_VALUE;\n  let shadowFar = -Number.MAX_VALUE;\n  let shadowClosestObjectSize = Number.MAX_VALUE;\n\n  const occluder =\n    frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n\n  // get user culling volume minus the far plane.\n  let { cullingVolume } = frameState;\n  const planes = scratchCullingVolume.planes;\n  for (let k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n  cullingVolume = scratchCullingVolume;\n\n  for (let i = 0; i < commandList.length; ++i) {\n    const command = commandList[i];\n    const { pass, boundingVolume } = command;\n\n    if (pass === Pass.COMPUTE) {\n      computeList.push(command);\n    } else if (pass === Pass.OVERLAY) {\n      overlayList.push(command);\n    } else {\n      let commandNear;\n      let commandFar;\n\n      if (defined(boundingVolume)) {\n        if (!scene.isVisible(cullingVolume, command, occluder)) {\n          continue;\n        }\n\n        const nearFarInterval = boundingVolume.computePlaneDistances(\n          positionWC,\n          directionWC,\n          scratchNearFarInterval,\n        );\n        commandNear = nearFarInterval.start;\n        commandFar = nearFarInterval.stop;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n\n        // Compute a tight near and far plane for commands that receive shadows. This helps compute\n        // good splits for cascaded shadow maps. Ignore commands that exceed the maximum distance.\n        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes\n        // throw off the near/far fitting for the shadow map. Only update for globe tiles that the\n        // camera isn't inside.\n        if (\n          shadowsEnabled &&\n          command.receiveShadows &&\n          commandNear < ShadowMap.MAXIMUM_DISTANCE &&\n          !(pass === Pass.GLOBE && commandNear < -100.0 && commandFar > 100.0)\n        ) {\n          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.\n          const size = commandFar - commandNear;\n          if (pass !== Pass.GLOBE && commandNear < 100.0) {\n            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);\n          }\n          shadowNear = Math.min(shadowNear, commandNear);\n          shadowFar = Math.max(shadowFar, commandFar);\n        }\n      } else if (command instanceof ClearCommand) {\n        // Clear commands don't need a bounding volume - just add the clear to all frustums.\n        commandNear = frustum.near;\n        commandFar = frustum.far;\n      } else {\n        // If command has no bounding volume we need to use the camera's\n        // worst-case near and far planes to avoid clipping something important.\n        commandNear = frustum.near;\n        commandFar = frustum.far;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n      }\n\n      let extent = commandExtents[commandExtentCount];\n      if (!defined(extent)) {\n        extent = commandExtents[commandExtentCount] = new CommandExtent();\n      }\n      extent.command = command;\n      extent.near = commandNear;\n      extent.far = commandFar;\n      commandExtentCount++;\n    }\n  }\n\n  if (shadowsEnabled) {\n    shadowNear = Math.min(Math.max(shadowNear, frustum.near), frustum.far);\n    shadowFar = Math.max(Math.min(shadowFar, frustum.far), shadowNear);\n    // Use the computed near and far for shadows\n    shadowState.nearPlane = shadowNear;\n    shadowState.farPlane = shadowFar;\n    shadowState.closestObjectSize = shadowClosestObjectSize;\n  }\n\n  updateFrustums(this, scene, near, far);\n\n  for (let c = 0; c < commandExtentCount; c++) {\n    insertIntoBin(this, scene, commandExtents[c]);\n  }\n\n  // Dereference old commands\n  if (commandExtentCount < commandExtentCapacity) {\n    for (let c = commandExtentCount; c < commandExtentCapacity; c++) {\n      const commandExtent = commandExtents[c];\n      if (!defined(commandExtent.command)) {\n        // If the command is undefined, it's assumed that all\n        // subsequent commmands were set to undefined as well,\n        // so no need to loop over them all\n        break;\n      }\n      commandExtent.command = undefined;\n    }\n  }\n\n  const numFrustums = frustumCommandsList.length;\n  const { frustumSplits } = frameState;\n  frustumSplits.length = numFrustums + 1;\n  for (let j = 0; j < numFrustums; ++j) {\n    frustumSplits[j] = frustumCommandsList[j].near;\n    if (j === numFrustums - 1) {\n      frustumSplits[j + 1] = frustumCommandsList[j].far;\n    }\n  }\n};\n\nView.prototype.destroy = function () {\n  this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy();\n  this.pickDepthFramebuffer =\n    this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy();\n  this.sceneFramebuffer =\n    this.sceneFramebuffer && this.sceneFramebuffer.destroy();\n  this.globeDepth = this.globeDepth && this.globeDepth.destroy();\n  this.oit = this.oit && this.oit.destroy();\n  this.translucentTileClassification =\n    this.translucentTileClassification &&\n    this.translucentTileClassification.destroy();\n  this.globeTranslucencyFramebuffer =\n    this.globeTranslucencyFramebuffer &&\n    this.globeTranslucencyFramebuffer.destroy();\n\n  const pickDepths = this.pickDepths;\n  for (let i = 0; i < pickDepths.length; ++i) {\n    pickDepths[i].destroy();\n  }\n};\nexport default View;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}