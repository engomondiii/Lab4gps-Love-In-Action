{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\nconst ALL_CHILDREN = 15;\n\n/**\n * @typedef {Object} ArcGISTiledElevationTerrainProvider.ConstructorOptions\n *\n * Initialization options for the ArcGISTiledElevationTerrainProvider constructor\n *\n * @property {string} [token] The authorization token to use to connect to the service.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.\n *                    If neither parameter is specified, the default ellipsoid is used.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {ArcGISTiledElevationTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n */\nfunction TerrainProviderBuilder(options) {\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  this.credit = undefined;\n  this.tilingScheme = undefined;\n  this.height = undefined;\n  this.width = undefined;\n  this.encoding = undefined;\n  this.lodCount = undefined;\n  this.hasAvailability = false;\n  this.tilesAvailable = undefined;\n  this.tilesAvailabilityLoaded = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.terrainDataStructure = undefined;\n}\n\n/**\n * Complete ArcGISTiledElevationTerrainProvider creation based on builder values.\n *\n * @private\n *\n * @param {ArcGISTiledElevationTerrainProvider} provider\n */\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._credit = this.credit;\n  provider._tilingScheme = this.tilingScheme;\n  provider._height = this.height;\n  provider._width = this.width;\n  provider._encoding = this.encoding;\n  provider._lodCount = this.lodCount;\n  provider._hasAvailability = this.hasAvailability;\n  provider._tilesAvailable = this.tilesAvailable;\n  provider._tilesAvailabilityLoaded = this.tilesAvailabilityLoaded;\n  provider._levelZeroMaximumGeometricError = this.levelZeroMaximumGeometricError;\n  provider._terrainDataStructure = this.terrainDataStructure;\n};\nfunction parseMetadataSuccess(terrainProviderBuilder, metadata) {\n  const copyrightText = metadata.copyrightText;\n  if (defined(copyrightText)) {\n    terrainProviderBuilder.credit = new Credit(copyrightText);\n  }\n  const spatialReference = metadata.spatialReference;\n  const wkid = defaultValue(spatialReference.latestWkid, spatialReference.wkid);\n  const extent = metadata.extent;\n  const tilingSchemeOptions = {\n    ellipsoid: terrainProviderBuilder.ellipsoid\n  };\n  if (wkid === 4326) {\n    tilingSchemeOptions.rectangle = Rectangle.fromDegrees(extent.xmin, extent.ymin, extent.xmax, extent.ymax);\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme(tilingSchemeOptions);\n  } else if (wkid === 3857) {\n    // Clamp extent to EPSG 3857 bounds\n    const epsg3857Bounds = Math.PI * terrainProviderBuilder.ellipsoid.maximumRadius;\n    if (metadata.extent.xmax > epsg3857Bounds) {\n      metadata.extent.xmax = epsg3857Bounds;\n    }\n    if (metadata.extent.ymax > epsg3857Bounds) {\n      metadata.extent.ymax = epsg3857Bounds;\n    }\n    if (metadata.extent.xmin < -epsg3857Bounds) {\n      metadata.extent.xmin = -epsg3857Bounds;\n    }\n    if (metadata.extent.ymin < -epsg3857Bounds) {\n      metadata.extent.ymin = -epsg3857Bounds;\n    }\n    tilingSchemeOptions.rectangleSouthwestInMeters = new Cartesian2(extent.xmin, extent.ymin);\n    tilingSchemeOptions.rectangleNortheastInMeters = new Cartesian2(extent.xmax, extent.ymax);\n    terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme(tilingSchemeOptions);\n  } else {\n    throw new RuntimeError(\"Invalid spatial reference\");\n  }\n  const tileInfo = metadata.tileInfo;\n  if (!defined(tileInfo)) {\n    throw new RuntimeError(\"tileInfo is required\");\n  }\n  terrainProviderBuilder.width = tileInfo.rows + 1;\n  terrainProviderBuilder.height = tileInfo.cols + 1;\n  terrainProviderBuilder.encoding = tileInfo.format === \"LERC\" ? HeightmapEncoding.LERC : HeightmapEncoding.NONE;\n  terrainProviderBuilder.lodCount = tileInfo.lods.length - 1;\n  const hasAvailability = terrainProviderBuilder.hasAvailability = metadata.capabilities.indexOf(\"Tilemap\") !== -1;\n  if (hasAvailability) {\n    terrainProviderBuilder.tilesAvailable = new TileAvailability(terrainProviderBuilder.tilingScheme, terrainProviderBuilder.lodCount);\n    terrainProviderBuilder.tilesAvailable.addAvailableTileRange(0, 0, 0, terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0), terrainProviderBuilder.tilingScheme.getNumberOfYTilesAtLevel(0));\n    terrainProviderBuilder.tilesAvailabilityLoaded = new TileAvailability(terrainProviderBuilder.tilingScheme, terrainProviderBuilder.lodCount);\n  }\n  terrainProviderBuilder.levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(terrainProviderBuilder.tilingScheme.ellipsoid, terrainProviderBuilder.width, terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0));\n  if (metadata.bandCount > 1) {\n    console.log(\"ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one.\");\n  }\n  if (defined(metadata.minValues) && defined(metadata.maxValues)) {\n    terrainProviderBuilder.terrainDataStructure = {\n      elementMultiplier: 1.0,\n      lowestEncodedHeight: metadata.minValues[0],\n      highestEncodedHeight: metadata.maxValues[0]\n    };\n  } else {\n    terrainProviderBuilder.terrainDataStructure = {\n      elementMultiplier: 1.0\n    };\n  }\n}\nasync function requestMetadata(terrainProviderBuilder, metadataResource, provider) {\n  try {\n    const metadata = await metadataResource.fetchJson();\n    parseMetadataSuccess(terrainProviderBuilder, metadata);\n  } catch (error) {\n    const message = `An error occurred while accessing ${metadataResource}.`;\n    TileProviderError.reportError(undefined, provider, defined(provider) ? provider._errorEvent : undefined, message);\n    throw error;\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a CesiumTerrainProvider, call {@link ArcGISTiledElevationTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @alias ArcGISTiledElevationTerrainProvider\n * @constructor\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] A url or an object describing initialization options\n *\n * @example\n * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction ArcGISTiledElevationTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._resource = undefined;\n  this._credit = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._maxLevel = undefined;\n  this._terrainDataStructure = undefined;\n  this._width = undefined;\n  this._height = undefined;\n  this._encoding = undefined;\n  this._lodCount = undefined;\n  this._hasAvailability = false;\n  this._tilesAvailable = undefined;\n  this._tilesAvailabilityLoaded = undefined;\n  this._availableCache = {};\n  this._errorEvent = new Event();\n}\nObject.defineProperties(ArcGISTiledElevationTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    }\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return this._tilesAvailable;\n    }\n  }\n});\n\n/**\n * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @param {Resource|String|Promise<Resource>|Promise<String>} url The URL of the ArcGIS ImageServer service.\n * @param {ArcGISTiledElevationTerrainProvider.ConstructorOptions} [options] A url or an object describing initialization options.\n * @returns {Promise<ArcGISTiledElevationTerrainProvider>}\n *\n * @example\n * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @exception {RuntimeError} metadata specifies invalid spatial reference\n * @exception {RuntimeError} metadata does not specify tileInfo\n */\nArcGISTiledElevationTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  url = await Promise.resolve(url);\n  let resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n  if (defined(options.token)) {\n    resource = resource.getDerivedResource({\n      queryParameters: {\n        token: options.token\n      }\n    });\n  }\n  const metadataResource = resource.getDerivedResource({\n    queryParameters: {\n      f: \"pjson\"\n    }\n  });\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  await requestMetadata(terrainProviderBuilder, metadataResource);\n  const provider = new ArcGISTiledElevationTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n  provider._resource = resource;\n  return provider;\n};\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  const tileResource = this._resource.getDerivedResource({\n    url: `tile/${level}/${y}/${x}`,\n    request: request\n  });\n  const hasAvailability = this._hasAvailability;\n  let availabilityPromise = Promise.resolve(true);\n  let availabilityRequest;\n  if (hasAvailability && !defined(isTileAvailable(this, level + 1, x * 2, y * 2))) {\n    // We need to load child availability\n    const availabilityResult = requestAvailability(this, level + 1, x * 2, y * 2);\n    availabilityPromise = availabilityResult.promise;\n    availabilityRequest = availabilityResult.request;\n  }\n  const promise = tileResource.fetchArrayBuffer();\n  if (!defined(promise) || !defined(availabilityPromise)) {\n    return undefined;\n  }\n  const that = this;\n  const tilesAvailable = this._tilesAvailable;\n  return Promise.all([promise, availabilityPromise]).then(function (result) {\n    return new HeightmapTerrainData({\n      buffer: result[0],\n      width: that._width,\n      height: that._height,\n      childTileMask: hasAvailability ? tilesAvailable.computeChildMaskForTile(level, x, y) : ALL_CHILDREN,\n      structure: that._terrainDataStructure,\n      encoding: that._encoding\n    });\n  }).catch(async function (error) {\n    if (defined(availabilityRequest) && availabilityRequest.state === RequestState.CANCELLED) {\n      request.cancel();\n\n      // Don't reject the promise till the request is actually cancelled\n      // Otherwise it will think the request failed, but it didn't.\n      try {\n        await request.deferred?.promise;\n      } catch {\n        // Eat this error\n      }\n      request.state = RequestState.CANCELLED;\n      return Promise.reject(error);\n    }\n    return Promise.reject(error);\n  });\n};\nfunction isTileAvailable(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return undefined;\n  }\n  const tilesAvailabilityLoaded = that._tilesAvailabilityLoaded;\n  const tilesAvailable = that._tilesAvailable;\n  if (level > that._lodCount) {\n    return false;\n  }\n\n  // Check if tiles are known to be available\n  if (tilesAvailable.isTileAvailable(level, x, y)) {\n    return true;\n  }\n\n  // or to not be available\n  if (tilesAvailabilityLoaded.isTileAvailable(level, x, y)) {\n    return false;\n  }\n  return undefined;\n}\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!this._hasAvailability) {\n    return undefined;\n  }\n  const result = isTileAvailable(this, level, x, y);\n  if (defined(result)) {\n    return result;\n  }\n  requestAvailability(this, level, x, y);\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined} This provider does not support loading availability.\n */\nArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  return undefined;\n};\nfunction findRange(origin, width, height, data) {\n  const endCol = width - 1;\n  const endRow = height - 1;\n  const value = data[origin.y * width + origin.x];\n  const endingIndices = [];\n  const range = {\n    startX: origin.x,\n    startY: origin.y,\n    endX: 0,\n    endY: 0\n  };\n  const corner = new Cartesian2(origin.x + 1, origin.y + 1);\n  let doneX = false;\n  let doneY = false;\n  while (!(doneX && doneY)) {\n    // We want to use the original value when checking Y,\n    //  so get it before it possibly gets incremented\n    let endX = corner.x;\n\n    // If we no longer move in the Y direction we need to check the corner tile in X pass\n    const endY = doneY ? corner.y + 1 : corner.y;\n\n    // Check X range\n    if (!doneX) {\n      for (let y = origin.y; y < endY; ++y) {\n        if (data[y * width + corner.x] !== value) {\n          doneX = true;\n          break;\n        }\n      }\n      if (doneX) {\n        endingIndices.push(new Cartesian2(corner.x, origin.y));\n\n        // Use the last good column so we can continue with Y\n        --corner.x;\n        --endX;\n        range.endX = corner.x;\n      } else if (corner.x === endCol) {\n        range.endX = corner.x;\n        doneX = true;\n      } else {\n        ++corner.x;\n      }\n    }\n\n    // Check Y range - The corner tile is checked here\n    if (!doneY) {\n      const col = corner.y * width;\n      for (let x = origin.x; x <= endX; ++x) {\n        if (data[col + x] !== value) {\n          doneY = true;\n          break;\n        }\n      }\n      if (doneY) {\n        endingIndices.push(new Cartesian2(origin.x, corner.y));\n\n        // Use the last good row so we can continue with X\n        --corner.y;\n        range.endY = corner.y;\n      } else if (corner.y === endRow) {\n        range.endY = corner.y;\n        doneY = true;\n      } else {\n        ++corner.y;\n      }\n    }\n  }\n  return {\n    endingIndices: endingIndices,\n    range: range,\n    value: value\n  };\n}\nfunction computeAvailability(x, y, width, height, data) {\n  const ranges = [];\n  const singleValue = data.every(function (val) {\n    return val === data[0];\n  });\n  if (singleValue) {\n    if (data[0] === 1) {\n      ranges.push({\n        startX: x,\n        startY: y,\n        endX: x + width - 1,\n        endY: y + height - 1\n      });\n    }\n    return ranges;\n  }\n  let positions = [new Cartesian2(0, 0)];\n  while (positions.length > 0) {\n    const origin = positions.pop();\n    const result = findRange(origin, width, height, data);\n    if (result.value === 1) {\n      // Convert range into the array into global tile coordinates\n      const range = result.range;\n      range.startX += x;\n      range.endX += x;\n      range.startY += y;\n      range.endY += y;\n      ranges.push(range);\n    }\n    const endingIndices = result.endingIndices;\n    if (endingIndices.length > 0) {\n      positions = positions.concat(endingIndices);\n    }\n  }\n  return ranges;\n}\nfunction requestAvailability(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return {};\n  }\n\n  // Fetch 128x128 availability list, so we make the minimum amount of requests\n  const xOffset = Math.floor(x / 128) * 128;\n  const yOffset = Math.floor(y / 128) * 128;\n  const dim = Math.min(1 << level, 128);\n  const url = `tilemap/${level}/${yOffset}/${xOffset}/${dim}/${dim}`;\n  const availableCache = that._availableCache;\n  if (defined(availableCache[url])) {\n    return availableCache[url];\n  }\n  const request = new Request({\n    throttle: false,\n    throttleByServer: true,\n    type: RequestType.TERRAIN\n  });\n  const tilemapResource = that._resource.getDerivedResource({\n    url: url,\n    request: request\n  });\n  let promise = tilemapResource.fetchJson();\n  if (!defined(promise)) {\n    return {};\n  }\n  promise = promise.then(function (result) {\n    const available = computeAvailability(xOffset, yOffset, dim, dim, result.data);\n\n    // Mark whole area as having availability loaded\n    that._tilesAvailabilityLoaded.addAvailableTileRange(level, xOffset, yOffset, xOffset + dim, yOffset + dim);\n    const tilesAvailable = that._tilesAvailable;\n    for (let i = 0; i < available.length; ++i) {\n      const range = available[i];\n      tilesAvailable.addAvailableTileRange(level, range.startX, range.startY, range.endX, range.endY);\n    }\n\n    // Conveniently return availability of original tile\n    return isTileAvailable(that, level, x, y);\n  });\n  availableCache[url] = {\n    promise: promise,\n    request: request\n  };\n  promise = promise.finally(function (result) {\n    delete availableCache[url];\n    return result;\n  });\n  return {\n    promise: promise,\n    request: request\n  };\n}\nexport default ArcGISTiledElevationTerrainProvider;","map":{"version":3,"names":["Cartesian2","Check","Credit","defaultValue","defined","Ellipsoid","Event","GeographicTilingScheme","HeightmapEncoding","HeightmapTerrainData","Rectangle","Request","RequestState","RequestType","Resource","RuntimeError","TerrainProvider","TileAvailability","TileProviderError","WebMercatorTilingScheme","ALL_CHILDREN","TerrainProviderBuilder","options","ellipsoid","default","credit","undefined","tilingScheme","height","width","encoding","lodCount","hasAvailability","tilesAvailable","tilesAvailabilityLoaded","levelZeroMaximumGeometricError","terrainDataStructure","prototype","build","provider","_credit","_tilingScheme","_height","_width","_encoding","_lodCount","_hasAvailability","_tilesAvailable","_tilesAvailabilityLoaded","_levelZeroMaximumGeometricError","_terrainDataStructure","parseMetadataSuccess","terrainProviderBuilder","metadata","copyrightText","spatialReference","wkid","latestWkid","extent","tilingSchemeOptions","rectangle","fromDegrees","xmin","ymin","xmax","ymax","epsg3857Bounds","Math","PI","maximumRadius","rectangleSouthwestInMeters","rectangleNortheastInMeters","tileInfo","rows","cols","format","LERC","NONE","lods","length","capabilities","indexOf","addAvailableTileRange","getNumberOfXTilesAtLevel","getNumberOfYTilesAtLevel","getEstimatedLevelZeroGeometricErrorForAHeightmap","bandCount","console","log","minValues","maxValues","elementMultiplier","lowestEncodedHeight","highestEncodedHeight","requestMetadata","metadataResource","fetchJson","error","message","reportError","_errorEvent","ArcGISTiledElevationTerrainProvider","EMPTY_OBJECT","_resource","_maxLevel","_availableCache","Object","defineProperties","errorEvent","get","hasWaterMask","hasVertexNormals","availability","fromUrl","url","Promise","resolve","resource","createIfNeeded","appendForwardSlash","token","getDerivedResource","queryParameters","f","requestTileGeometry","x","y","level","request","tileResource","availabilityPromise","availabilityRequest","isTileAvailable","availabilityResult","requestAvailability","promise","fetchArrayBuffer","that","all","then","result","buffer","childTileMask","computeChildMaskForTile","structure","catch","state","CANCELLED","cancel","deferred","reject","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","findRange","origin","data","endCol","endRow","value","endingIndices","range","startX","startY","endX","endY","corner","doneX","doneY","push","col","computeAvailability","ranges","singleValue","every","val","positions","pop","concat","xOffset","floor","yOffset","dim","min","availableCache","throttle","throttleByServer","type","TERRAIN","tilemapResource","available","i","finally"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/ArcGISTiledElevationTerrainProvider.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\n\nconst ALL_CHILDREN = 15;\n\n/**\n * @typedef {Object} ArcGISTiledElevationTerrainProvider.ConstructorOptions\n *\n * Initialization options for the ArcGISTiledElevationTerrainProvider constructor\n *\n * @property {string} [token] The authorization token to use to connect to the service.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.\n *                    If neither parameter is specified, the default ellipsoid is used.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {ArcGISTiledElevationTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n */\nfunction TerrainProviderBuilder(options) {\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n\n  this.credit = undefined;\n  this.tilingScheme = undefined;\n  this.height = undefined;\n  this.width = undefined;\n  this.encoding = undefined;\n  this.lodCount = undefined;\n  this.hasAvailability = false;\n  this.tilesAvailable = undefined;\n  this.tilesAvailabilityLoaded = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.terrainDataStructure = undefined;\n}\n\n/**\n * Complete ArcGISTiledElevationTerrainProvider creation based on builder values.\n *\n * @private\n *\n * @param {ArcGISTiledElevationTerrainProvider} provider\n */\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._credit = this.credit;\n  provider._tilingScheme = this.tilingScheme;\n  provider._height = this.height;\n  provider._width = this.width;\n  provider._encoding = this.encoding;\n  provider._lodCount = this.lodCount;\n  provider._hasAvailability = this.hasAvailability;\n  provider._tilesAvailable = this.tilesAvailable;\n  provider._tilesAvailabilityLoaded = this.tilesAvailabilityLoaded;\n  provider._levelZeroMaximumGeometricError =\n    this.levelZeroMaximumGeometricError;\n  provider._terrainDataStructure = this.terrainDataStructure;\n};\n\nfunction parseMetadataSuccess(terrainProviderBuilder, metadata) {\n  const copyrightText = metadata.copyrightText;\n  if (defined(copyrightText)) {\n    terrainProviderBuilder.credit = new Credit(copyrightText);\n  }\n\n  const spatialReference = metadata.spatialReference;\n  const wkid = defaultValue(spatialReference.latestWkid, spatialReference.wkid);\n  const extent = metadata.extent;\n  const tilingSchemeOptions = {\n    ellipsoid: terrainProviderBuilder.ellipsoid,\n  };\n  if (wkid === 4326) {\n    tilingSchemeOptions.rectangle = Rectangle.fromDegrees(\n      extent.xmin,\n      extent.ymin,\n      extent.xmax,\n      extent.ymax,\n    );\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme(\n      tilingSchemeOptions,\n    );\n  } else if (wkid === 3857) {\n    // Clamp extent to EPSG 3857 bounds\n    const epsg3857Bounds =\n      Math.PI * terrainProviderBuilder.ellipsoid.maximumRadius;\n    if (metadata.extent.xmax > epsg3857Bounds) {\n      metadata.extent.xmax = epsg3857Bounds;\n    }\n    if (metadata.extent.ymax > epsg3857Bounds) {\n      metadata.extent.ymax = epsg3857Bounds;\n    }\n    if (metadata.extent.xmin < -epsg3857Bounds) {\n      metadata.extent.xmin = -epsg3857Bounds;\n    }\n    if (metadata.extent.ymin < -epsg3857Bounds) {\n      metadata.extent.ymin = -epsg3857Bounds;\n    }\n\n    tilingSchemeOptions.rectangleSouthwestInMeters = new Cartesian2(\n      extent.xmin,\n      extent.ymin,\n    );\n    tilingSchemeOptions.rectangleNortheastInMeters = new Cartesian2(\n      extent.xmax,\n      extent.ymax,\n    );\n    terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme(\n      tilingSchemeOptions,\n    );\n  } else {\n    throw new RuntimeError(\"Invalid spatial reference\");\n  }\n\n  const tileInfo = metadata.tileInfo;\n  if (!defined(tileInfo)) {\n    throw new RuntimeError(\"tileInfo is required\");\n  }\n\n  terrainProviderBuilder.width = tileInfo.rows + 1;\n  terrainProviderBuilder.height = tileInfo.cols + 1;\n  terrainProviderBuilder.encoding =\n    tileInfo.format === \"LERC\"\n      ? HeightmapEncoding.LERC\n      : HeightmapEncoding.NONE;\n  terrainProviderBuilder.lodCount = tileInfo.lods.length - 1;\n\n  const hasAvailability = (terrainProviderBuilder.hasAvailability =\n    metadata.capabilities.indexOf(\"Tilemap\") !== -1);\n  if (hasAvailability) {\n    terrainProviderBuilder.tilesAvailable = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      terrainProviderBuilder.lodCount,\n    );\n    terrainProviderBuilder.tilesAvailable.addAvailableTileRange(\n      0,\n      0,\n      0,\n      terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0),\n      terrainProviderBuilder.tilingScheme.getNumberOfYTilesAtLevel(0),\n    );\n    terrainProviderBuilder.tilesAvailabilityLoaded = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      terrainProviderBuilder.lodCount,\n    );\n  }\n\n  terrainProviderBuilder.levelZeroMaximumGeometricError =\n    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      terrainProviderBuilder.tilingScheme.ellipsoid,\n      terrainProviderBuilder.width,\n      terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0),\n    );\n\n  if (metadata.bandCount > 1) {\n    console.log(\n      \"ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one.\",\n    );\n  }\n\n  if (defined(metadata.minValues) && defined(metadata.maxValues)) {\n    terrainProviderBuilder.terrainDataStructure = {\n      elementMultiplier: 1.0,\n      lowestEncodedHeight: metadata.minValues[0],\n      highestEncodedHeight: metadata.maxValues[0],\n    };\n  } else {\n    terrainProviderBuilder.terrainDataStructure = {\n      elementMultiplier: 1.0,\n    };\n  }\n}\n\nasync function requestMetadata(\n  terrainProviderBuilder,\n  metadataResource,\n  provider,\n) {\n  try {\n    const metadata = await metadataResource.fetchJson();\n    parseMetadataSuccess(terrainProviderBuilder, metadata);\n  } catch (error) {\n    const message = `An error occurred while accessing ${metadataResource}.`;\n    TileProviderError.reportError(\n      undefined,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message,\n    );\n\n    throw error;\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a CesiumTerrainProvider, call {@link ArcGISTiledElevationTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @alias ArcGISTiledElevationTerrainProvider\n * @constructor\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] A url or an object describing initialization options\n *\n * @example\n * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction ArcGISTiledElevationTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._resource = undefined;\n  this._credit = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._maxLevel = undefined;\n  this._terrainDataStructure = undefined;\n  this._width = undefined;\n  this._height = undefined;\n  this._encoding = undefined;\n  this._lodCount = undefined;\n\n  this._hasAvailability = false;\n  this._tilesAvailable = undefined;\n  this._tilesAvailabilityLoaded = undefined;\n  this._availableCache = {};\n\n  this._errorEvent = new Event();\n}\n\nObject.defineProperties(ArcGISTiledElevationTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return this._tilesAvailable;\n    },\n  },\n});\n\n/**\n * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @param {Resource|String|Promise<Resource>|Promise<String>} url The URL of the ArcGIS ImageServer service.\n * @param {ArcGISTiledElevationTerrainProvider.ConstructorOptions} [options] A url or an object describing initialization options.\n * @returns {Promise<ArcGISTiledElevationTerrainProvider>}\n *\n * @example\n * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @exception {RuntimeError} metadata specifies invalid spatial reference\n * @exception {RuntimeError} metadata does not specify tileInfo\n */\nArcGISTiledElevationTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  url = await Promise.resolve(url);\n  let resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n  if (defined(options.token)) {\n    resource = resource.getDerivedResource({\n      queryParameters: {\n        token: options.token,\n      },\n    });\n  }\n\n  const metadataResource = resource.getDerivedResource({\n    queryParameters: {\n      f: \"pjson\",\n    },\n  });\n\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  await requestMetadata(terrainProviderBuilder, metadataResource);\n\n  const provider = new ArcGISTiledElevationTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n  provider._resource = resource;\n\n  return provider;\n};\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const tileResource = this._resource.getDerivedResource({\n    url: `tile/${level}/${y}/${x}`,\n    request: request,\n  });\n\n  const hasAvailability = this._hasAvailability;\n  let availabilityPromise = Promise.resolve(true);\n  let availabilityRequest;\n  if (\n    hasAvailability &&\n    !defined(isTileAvailable(this, level + 1, x * 2, y * 2))\n  ) {\n    // We need to load child availability\n    const availabilityResult = requestAvailability(\n      this,\n      level + 1,\n      x * 2,\n      y * 2,\n    );\n\n    availabilityPromise = availabilityResult.promise;\n    availabilityRequest = availabilityResult.request;\n  }\n\n  const promise = tileResource.fetchArrayBuffer();\n  if (!defined(promise) || !defined(availabilityPromise)) {\n    return undefined;\n  }\n\n  const that = this;\n  const tilesAvailable = this._tilesAvailable;\n  return Promise.all([promise, availabilityPromise])\n    .then(function (result) {\n      return new HeightmapTerrainData({\n        buffer: result[0],\n        width: that._width,\n        height: that._height,\n        childTileMask: hasAvailability\n          ? tilesAvailable.computeChildMaskForTile(level, x, y)\n          : ALL_CHILDREN,\n        structure: that._terrainDataStructure,\n        encoding: that._encoding,\n      });\n    })\n    .catch(async function (error) {\n      if (\n        defined(availabilityRequest) &&\n        availabilityRequest.state === RequestState.CANCELLED\n      ) {\n        request.cancel();\n\n        // Don't reject the promise till the request is actually cancelled\n        // Otherwise it will think the request failed, but it didn't.\n        try {\n          await request.deferred?.promise;\n        } catch {\n          // Eat this error\n        }\n\n        request.state = RequestState.CANCELLED;\n        return Promise.reject(error);\n      }\n      return Promise.reject(error);\n    });\n};\n\nfunction isTileAvailable(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return undefined;\n  }\n\n  const tilesAvailabilityLoaded = that._tilesAvailabilityLoaded;\n  const tilesAvailable = that._tilesAvailable;\n\n  if (level > that._lodCount) {\n    return false;\n  }\n\n  // Check if tiles are known to be available\n  if (tilesAvailable.isTileAvailable(level, x, y)) {\n    return true;\n  }\n\n  // or to not be available\n  if (tilesAvailabilityLoaded.isTileAvailable(level, x, y)) {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError =\n  function (level) {\n    return this._levelZeroMaximumGeometricError / (1 << level);\n  };\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level,\n) {\n  if (!this._hasAvailability) {\n    return undefined;\n  }\n\n  const result = isTileAvailable(this, level, x, y);\n  if (defined(result)) {\n    return result;\n  }\n\n  requestAvailability(this, level, x, y);\n\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined} This provider does not support loading availability.\n */\nArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability =\n  function (x, y, level) {\n    return undefined;\n  };\n\nfunction findRange(origin, width, height, data) {\n  const endCol = width - 1;\n  const endRow = height - 1;\n\n  const value = data[origin.y * width + origin.x];\n  const endingIndices = [];\n  const range = {\n    startX: origin.x,\n    startY: origin.y,\n    endX: 0,\n    endY: 0,\n  };\n\n  const corner = new Cartesian2(origin.x + 1, origin.y + 1);\n  let doneX = false;\n  let doneY = false;\n  while (!(doneX && doneY)) {\n    // We want to use the original value when checking Y,\n    //  so get it before it possibly gets incremented\n    let endX = corner.x;\n\n    // If we no longer move in the Y direction we need to check the corner tile in X pass\n    const endY = doneY ? corner.y + 1 : corner.y;\n\n    // Check X range\n    if (!doneX) {\n      for (let y = origin.y; y < endY; ++y) {\n        if (data[y * width + corner.x] !== value) {\n          doneX = true;\n          break;\n        }\n      }\n\n      if (doneX) {\n        endingIndices.push(new Cartesian2(corner.x, origin.y));\n\n        // Use the last good column so we can continue with Y\n        --corner.x;\n        --endX;\n        range.endX = corner.x;\n      } else if (corner.x === endCol) {\n        range.endX = corner.x;\n        doneX = true;\n      } else {\n        ++corner.x;\n      }\n    }\n\n    // Check Y range - The corner tile is checked here\n    if (!doneY) {\n      const col = corner.y * width;\n      for (let x = origin.x; x <= endX; ++x) {\n        if (data[col + x] !== value) {\n          doneY = true;\n          break;\n        }\n      }\n\n      if (doneY) {\n        endingIndices.push(new Cartesian2(origin.x, corner.y));\n\n        // Use the last good row so we can continue with X\n        --corner.y;\n        range.endY = corner.y;\n      } else if (corner.y === endRow) {\n        range.endY = corner.y;\n        doneY = true;\n      } else {\n        ++corner.y;\n      }\n    }\n  }\n\n  return {\n    endingIndices: endingIndices,\n    range: range,\n    value: value,\n  };\n}\n\nfunction computeAvailability(x, y, width, height, data) {\n  const ranges = [];\n\n  const singleValue = data.every(function (val) {\n    return val === data[0];\n  });\n  if (singleValue) {\n    if (data[0] === 1) {\n      ranges.push({\n        startX: x,\n        startY: y,\n        endX: x + width - 1,\n        endY: y + height - 1,\n      });\n    }\n\n    return ranges;\n  }\n\n  let positions = [new Cartesian2(0, 0)];\n  while (positions.length > 0) {\n    const origin = positions.pop();\n    const result = findRange(origin, width, height, data);\n\n    if (result.value === 1) {\n      // Convert range into the array into global tile coordinates\n      const range = result.range;\n      range.startX += x;\n      range.endX += x;\n      range.startY += y;\n      range.endY += y;\n      ranges.push(range);\n    }\n\n    const endingIndices = result.endingIndices;\n    if (endingIndices.length > 0) {\n      positions = positions.concat(endingIndices);\n    }\n  }\n\n  return ranges;\n}\n\nfunction requestAvailability(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return {};\n  }\n\n  // Fetch 128x128 availability list, so we make the minimum amount of requests\n  const xOffset = Math.floor(x / 128) * 128;\n  const yOffset = Math.floor(y / 128) * 128;\n\n  const dim = Math.min(1 << level, 128);\n  const url = `tilemap/${level}/${yOffset}/${xOffset}/${dim}/${dim}`;\n\n  const availableCache = that._availableCache;\n  if (defined(availableCache[url])) {\n    return availableCache[url];\n  }\n\n  const request = new Request({\n    throttle: false,\n    throttleByServer: true,\n    type: RequestType.TERRAIN,\n  });\n\n  const tilemapResource = that._resource.getDerivedResource({\n    url: url,\n    request: request,\n  });\n\n  let promise = tilemapResource.fetchJson();\n  if (!defined(promise)) {\n    return {};\n  }\n\n  promise = promise.then(function (result) {\n    const available = computeAvailability(\n      xOffset,\n      yOffset,\n      dim,\n      dim,\n      result.data,\n    );\n\n    // Mark whole area as having availability loaded\n    that._tilesAvailabilityLoaded.addAvailableTileRange(\n      level,\n      xOffset,\n      yOffset,\n      xOffset + dim,\n      yOffset + dim,\n    );\n\n    const tilesAvailable = that._tilesAvailable;\n    for (let i = 0; i < available.length; ++i) {\n      const range = available[i];\n      tilesAvailable.addAvailableTileRange(\n        level,\n        range.startX,\n        range.startY,\n        range.endX,\n        range.endY,\n      );\n    }\n\n    // Conveniently return availability of original tile\n    return isTileAvailable(that, level, x, y);\n  });\n\n  availableCache[url] = {\n    promise: promise,\n    request: request,\n  };\n\n  promise = promise.finally(function (result) {\n    delete availableCache[url];\n\n    return result;\n  });\n\n  return {\n    promise: promise,\n    request: request,\n  };\n}\nexport default ArcGISTiledElevationTerrainProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}