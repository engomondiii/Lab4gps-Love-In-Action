{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Property from \"./Property.js\";\nfunction resolve(that) {\n  let targetProperty = that._targetProperty;\n  if (!defined(targetProperty)) {\n    let targetEntity = that._targetEntity;\n    if (!defined(targetEntity)) {\n      targetEntity = that._targetCollection.getById(that._targetId);\n      if (!defined(targetEntity)) {\n        // target entity not found\n        that._targetEntity = that._targetProperty = undefined;\n        return;\n      }\n\n      // target entity was found. listen for changes to entity definition\n      targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);\n      that._targetEntity = targetEntity;\n    }\n\n    // walk the list of property names and resolve properties\n    const targetPropertyNames = that._targetPropertyNames;\n    targetProperty = that._targetEntity;\n    for (let i = 0, len = targetPropertyNames.length; i < len && defined(targetProperty); ++i) {\n      targetProperty = targetProperty[targetPropertyNames[i]];\n    }\n\n    // target property may or may not be defined, depending on if it was found\n    that._targetProperty = targetProperty;\n  }\n  return targetProperty;\n}\n\n/**\n * A {@link Property} which transparently links to another property on a provided object.\n *\n * @alias ReferenceProperty\n * @constructor\n *\n * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.\n * @param {string} targetId The id of the entity which is being referenced.\n * @param {string[]} targetPropertyNames The names of the property on the target entity which we will use.\n *\n * @example\n * const collection = new Cesium.EntityCollection();\n *\n * //Create a new entity and assign a billboard scale.\n * const object1 = new Cesium.Entity({id:'object1'});\n * object1.billboard = new Cesium.BillboardGraphics();\n * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object1);\n *\n * //Create a second entity and reference the scale from the first one.\n * const object2 = new Cesium.Entity({id:'object2'});\n * object2.model = new Cesium.ModelGraphics();\n * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n * collection.add(object2);\n *\n * //Create a third object, but use the fromString helper function.\n * const object3 = new Cesium.Entity({id:'object3'});\n * object3.billboard = new Cesium.BillboardGraphics();\n * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n * collection.add(object3);\n *\n * //You can refer to an entity with a # or . in id and property names by escaping them.\n * const object4 = new Cesium.Entity({id:'#object.4'});\n * object4.billboard = new Cesium.BillboardGraphics();\n * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object4);\n *\n * const object5 = new Cesium.Entity({id:'object5'});\n * object5.billboard = new Cesium.BillboardGraphics();\n * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n * collection.add(object5);\n */\nfunction ReferenceProperty(targetCollection, targetId, targetPropertyNames) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(targetCollection)) {\n    throw new DeveloperError(\"targetCollection is required.\");\n  }\n  if (!defined(targetId) || targetId === \"\") {\n    throw new DeveloperError(\"targetId is required.\");\n  }\n  if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {\n    throw new DeveloperError(\"targetPropertyNames is required.\");\n  }\n  for (let i = 0; i < targetPropertyNames.length; i++) {\n    const item = targetPropertyNames[i];\n    if (!defined(item) || item === \"\") {\n      throw new DeveloperError(\"reference contains invalid properties.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  this._targetCollection = targetCollection;\n  this._targetId = targetId;\n  this._targetPropertyNames = targetPropertyNames;\n  this._targetProperty = undefined;\n  this._targetEntity = undefined;\n  this._definitionChanged = new Event();\n  targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);\n}\nObject.defineProperties(ReferenceProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.\n   * @memberof ReferenceProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return Property.isConstant(resolve(this));\n    }\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is changed whenever the referenced property's definition is changed.\n   * @memberof ReferenceProperty.prototype\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n  /**\n   * Gets the reference frame that the position is defined in.\n   * This property is only valid if the referenced property is a {@link PositionProperty}.\n   * @memberof ReferenceProperty.prototype\n   * @type {ReferenceFrame}\n   * @readonly\n   */\n  referenceFrame: {\n    get: function () {\n      const target = resolve(this);\n      return defined(target) ? target.referenceFrame : undefined;\n    }\n  },\n  /**\n   * Gets the id of the entity being referenced.\n   * @memberof ReferenceProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  targetId: {\n    get: function () {\n      return this._targetId;\n    }\n  },\n  /**\n   * Gets the collection containing the entity being referenced.\n   * @memberof ReferenceProperty.prototype\n   * @type {EntityCollection}\n   * @readonly\n   */\n  targetCollection: {\n    get: function () {\n      return this._targetCollection;\n    }\n  },\n  /**\n   * Gets the array of property names used to retrieve the referenced property.\n   * @memberof ReferenceProperty.prototype\n   * @type {}\n   * @readonly\n   */\n  targetPropertyNames: {\n    get: function () {\n      return this._targetPropertyNames;\n    }\n  },\n  /**\n   * Gets the resolved instance of the underlying referenced property.\n   * @memberof ReferenceProperty.prototype\n   * @type {Property|undefined}\n   * @readonly\n   */\n  resolvedProperty: {\n    get: function () {\n      return resolve(this);\n    }\n  }\n});\n\n/**\n * Creates a new instance given the entity collection that will\n * be used to resolve it and a string indicating the target entity id and property.\n * The format of the string is \"objectId#foo.bar\", where # separates the id from\n * property path and . separates sub-properties.  If the reference identifier or\n * or any sub-properties contains a # . or \\ they must be escaped.\n *\n * @param {EntityCollection} targetCollection\n * @param {string} referenceString\n * @returns {ReferenceProperty} A new instance of ReferenceProperty.\n *\n * @exception {DeveloperError} invalid referenceString.\n */\nReferenceProperty.fromString = function (targetCollection, referenceString) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(targetCollection)) {\n    throw new DeveloperError(\"targetCollection is required.\");\n  }\n  if (!defined(referenceString)) {\n    throw new DeveloperError(\"referenceString is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let identifier;\n  const values = [];\n  let inIdentifier = true;\n  let isEscaped = false;\n  let token = \"\";\n  for (let i = 0; i < referenceString.length; ++i) {\n    const c = referenceString.charAt(i);\n    if (isEscaped) {\n      token += c;\n      isEscaped = false;\n    } else if (c === \"\\\\\") {\n      isEscaped = true;\n    } else if (inIdentifier && c === \"#\") {\n      identifier = token;\n      inIdentifier = false;\n      token = \"\";\n    } else if (!inIdentifier && c === \".\") {\n      values.push(token);\n      token = \"\";\n    } else {\n      token += c;\n    }\n  }\n  values.push(token);\n  return new ReferenceProperty(targetCollection, identifier, values);\n};\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nReferenceProperty.prototype.getValue = function (time, result) {\n  const target = resolve(this);\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  return defined(target) ? target.getValue(time, result) : undefined;\n};\n\n/**\n * Gets the value of the property at the provided time and in the provided reference frame.\n * This method is only valid if the property being referenced is a {@link PositionProperty}.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nReferenceProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {\n  const target = resolve(this);\n  return defined(target) ? target.getValueInReferenceFrame(time, referenceFrame, result) : undefined;\n};\n\n/**\n * Gets the {@link Material} type at the provided time.\n * This method is only valid if the property being referenced is a {@link MaterialProperty}.\n *\n * @param {JulianDate} time The time for which to retrieve the type.\n * @returns {string} The type of material.\n */\nReferenceProperty.prototype.getType = function (time) {\n  const target = resolve(this);\n  return defined(target) ? target.getType(time) : undefined;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nReferenceProperty.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  }\n  const names = this._targetPropertyNames;\n  const otherNames = other._targetPropertyNames;\n  if (this._targetCollection !== other._targetCollection ||\n  //\n  this._targetId !== other._targetId ||\n  //\n  names.length !== otherNames.length) {\n    return false;\n  }\n  const length = this._targetPropertyNames.length;\n  for (let i = 0; i < length; i++) {\n    if (names[i] !== otherNames[i]) {\n      return false;\n    }\n  }\n  return true;\n};\nReferenceProperty.prototype._onTargetEntityDefinitionChanged = function (targetEntity, name, value, oldValue) {\n  if (defined(this._targetProperty) && this._targetPropertyNames[0] === name) {\n    this._targetProperty = undefined;\n    this._definitionChanged.raiseEvent(this);\n  }\n};\nReferenceProperty.prototype._onCollectionChanged = function (collection, added, removed) {\n  let targetEntity = this._targetEntity;\n  if (defined(targetEntity) && removed.indexOf(targetEntity) !== -1) {\n    targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);\n    this._targetEntity = this._targetProperty = undefined;\n  } else if (!defined(targetEntity)) {\n    targetEntity = resolve(this);\n    if (defined(targetEntity)) {\n      this._definitionChanged.raiseEvent(this);\n    }\n  }\n};\nexport default ReferenceProperty;","map":{"version":3,"names":["defined","DeveloperError","Event","JulianDate","Property","resolve","that","targetProperty","_targetProperty","targetEntity","_targetEntity","_targetCollection","getById","_targetId","undefined","definitionChanged","addEventListener","ReferenceProperty","prototype","_onTargetEntityDefinitionChanged","targetPropertyNames","_targetPropertyNames","i","len","length","targetCollection","targetId","item","_definitionChanged","collectionChanged","_onCollectionChanged","Object","defineProperties","isConstant","get","referenceFrame","target","resolvedProperty","fromString","referenceString","identifier","values","inIdentifier","isEscaped","token","c","charAt","push","timeScratch","getValue","time","result","now","getValueInReferenceFrame","getType","equals","other","names","otherNames","name","value","oldValue","raiseEvent","collection","added","removed","indexOf","removeEventListener"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/ReferenceProperty.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Property from \"./Property.js\";\n\nfunction resolve(that) {\n  let targetProperty = that._targetProperty;\n\n  if (!defined(targetProperty)) {\n    let targetEntity = that._targetEntity;\n\n    if (!defined(targetEntity)) {\n      targetEntity = that._targetCollection.getById(that._targetId);\n\n      if (!defined(targetEntity)) {\n        // target entity not found\n        that._targetEntity = that._targetProperty = undefined;\n        return;\n      }\n\n      // target entity was found. listen for changes to entity definition\n      targetEntity.definitionChanged.addEventListener(\n        ReferenceProperty.prototype._onTargetEntityDefinitionChanged,\n        that,\n      );\n      that._targetEntity = targetEntity;\n    }\n\n    // walk the list of property names and resolve properties\n    const targetPropertyNames = that._targetPropertyNames;\n    targetProperty = that._targetEntity;\n    for (\n      let i = 0, len = targetPropertyNames.length;\n      i < len && defined(targetProperty);\n      ++i\n    ) {\n      targetProperty = targetProperty[targetPropertyNames[i]];\n    }\n\n    // target property may or may not be defined, depending on if it was found\n    that._targetProperty = targetProperty;\n  }\n\n  return targetProperty;\n}\n\n/**\n * A {@link Property} which transparently links to another property on a provided object.\n *\n * @alias ReferenceProperty\n * @constructor\n *\n * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.\n * @param {string} targetId The id of the entity which is being referenced.\n * @param {string[]} targetPropertyNames The names of the property on the target entity which we will use.\n *\n * @example\n * const collection = new Cesium.EntityCollection();\n *\n * //Create a new entity and assign a billboard scale.\n * const object1 = new Cesium.Entity({id:'object1'});\n * object1.billboard = new Cesium.BillboardGraphics();\n * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object1);\n *\n * //Create a second entity and reference the scale from the first one.\n * const object2 = new Cesium.Entity({id:'object2'});\n * object2.model = new Cesium.ModelGraphics();\n * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n * collection.add(object2);\n *\n * //Create a third object, but use the fromString helper function.\n * const object3 = new Cesium.Entity({id:'object3'});\n * object3.billboard = new Cesium.BillboardGraphics();\n * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n * collection.add(object3);\n *\n * //You can refer to an entity with a # or . in id and property names by escaping them.\n * const object4 = new Cesium.Entity({id:'#object.4'});\n * object4.billboard = new Cesium.BillboardGraphics();\n * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n * collection.add(object4);\n *\n * const object5 = new Cesium.Entity({id:'object5'});\n * object5.billboard = new Cesium.BillboardGraphics();\n * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n * collection.add(object5);\n */\nfunction ReferenceProperty(targetCollection, targetId, targetPropertyNames) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(targetCollection)) {\n    throw new DeveloperError(\"targetCollection is required.\");\n  }\n  if (!defined(targetId) || targetId === \"\") {\n    throw new DeveloperError(\"targetId is required.\");\n  }\n  if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {\n    throw new DeveloperError(\"targetPropertyNames is required.\");\n  }\n  for (let i = 0; i < targetPropertyNames.length; i++) {\n    const item = targetPropertyNames[i];\n    if (!defined(item) || item === \"\") {\n      throw new DeveloperError(\"reference contains invalid properties.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  this._targetCollection = targetCollection;\n  this._targetId = targetId;\n  this._targetPropertyNames = targetPropertyNames;\n  this._targetProperty = undefined;\n  this._targetEntity = undefined;\n  this._definitionChanged = new Event();\n\n  targetCollection.collectionChanged.addEventListener(\n    ReferenceProperty.prototype._onCollectionChanged,\n    this,\n  );\n}\n\nObject.defineProperties(ReferenceProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.\n   * @memberof ReferenceProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return Property.isConstant(resolve(this));\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is changed whenever the referenced property's definition is changed.\n   * @memberof ReferenceProperty.prototype\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n  /**\n   * Gets the reference frame that the position is defined in.\n   * This property is only valid if the referenced property is a {@link PositionProperty}.\n   * @memberof ReferenceProperty.prototype\n   * @type {ReferenceFrame}\n   * @readonly\n   */\n  referenceFrame: {\n    get: function () {\n      const target = resolve(this);\n      return defined(target) ? target.referenceFrame : undefined;\n    },\n  },\n  /**\n   * Gets the id of the entity being referenced.\n   * @memberof ReferenceProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  targetId: {\n    get: function () {\n      return this._targetId;\n    },\n  },\n  /**\n   * Gets the collection containing the entity being referenced.\n   * @memberof ReferenceProperty.prototype\n   * @type {EntityCollection}\n   * @readonly\n   */\n  targetCollection: {\n    get: function () {\n      return this._targetCollection;\n    },\n  },\n  /**\n   * Gets the array of property names used to retrieve the referenced property.\n   * @memberof ReferenceProperty.prototype\n   * @type {}\n   * @readonly\n   */\n  targetPropertyNames: {\n    get: function () {\n      return this._targetPropertyNames;\n    },\n  },\n  /**\n   * Gets the resolved instance of the underlying referenced property.\n   * @memberof ReferenceProperty.prototype\n   * @type {Property|undefined}\n   * @readonly\n   */\n  resolvedProperty: {\n    get: function () {\n      return resolve(this);\n    },\n  },\n});\n\n/**\n * Creates a new instance given the entity collection that will\n * be used to resolve it and a string indicating the target entity id and property.\n * The format of the string is \"objectId#foo.bar\", where # separates the id from\n * property path and . separates sub-properties.  If the reference identifier or\n * or any sub-properties contains a # . or \\ they must be escaped.\n *\n * @param {EntityCollection} targetCollection\n * @param {string} referenceString\n * @returns {ReferenceProperty} A new instance of ReferenceProperty.\n *\n * @exception {DeveloperError} invalid referenceString.\n */\nReferenceProperty.fromString = function (targetCollection, referenceString) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(targetCollection)) {\n    throw new DeveloperError(\"targetCollection is required.\");\n  }\n  if (!defined(referenceString)) {\n    throw new DeveloperError(\"referenceString is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let identifier;\n  const values = [];\n\n  let inIdentifier = true;\n  let isEscaped = false;\n  let token = \"\";\n  for (let i = 0; i < referenceString.length; ++i) {\n    const c = referenceString.charAt(i);\n\n    if (isEscaped) {\n      token += c;\n      isEscaped = false;\n    } else if (c === \"\\\\\") {\n      isEscaped = true;\n    } else if (inIdentifier && c === \"#\") {\n      identifier = token;\n      inIdentifier = false;\n      token = \"\";\n    } else if (!inIdentifier && c === \".\") {\n      values.push(token);\n      token = \"\";\n    } else {\n      token += c;\n    }\n  }\n  values.push(token);\n\n  return new ReferenceProperty(targetCollection, identifier, values);\n};\n\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nReferenceProperty.prototype.getValue = function (time, result) {\n  const target = resolve(this);\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  return defined(target) ? target.getValue(time, result) : undefined;\n};\n\n/**\n * Gets the value of the property at the provided time and in the provided reference frame.\n * This method is only valid if the property being referenced is a {@link PositionProperty}.\n *\n * @param {JulianDate} time The time for which to retrieve the value.\n * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nReferenceProperty.prototype.getValueInReferenceFrame = function (\n  time,\n  referenceFrame,\n  result,\n) {\n  const target = resolve(this);\n  return defined(target)\n    ? target.getValueInReferenceFrame(time, referenceFrame, result)\n    : undefined;\n};\n\n/**\n * Gets the {@link Material} type at the provided time.\n * This method is only valid if the property being referenced is a {@link MaterialProperty}.\n *\n * @param {JulianDate} time The time for which to retrieve the type.\n * @returns {string} The type of material.\n */\nReferenceProperty.prototype.getType = function (time) {\n  const target = resolve(this);\n  return defined(target) ? target.getType(time) : undefined;\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nReferenceProperty.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  }\n\n  const names = this._targetPropertyNames;\n  const otherNames = other._targetPropertyNames;\n\n  if (\n    this._targetCollection !== other._targetCollection || //\n    this._targetId !== other._targetId || //\n    names.length !== otherNames.length\n  ) {\n    return false;\n  }\n\n  const length = this._targetPropertyNames.length;\n  for (let i = 0; i < length; i++) {\n    if (names[i] !== otherNames[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nReferenceProperty.prototype._onTargetEntityDefinitionChanged = function (\n  targetEntity,\n  name,\n  value,\n  oldValue,\n) {\n  if (defined(this._targetProperty) && this._targetPropertyNames[0] === name) {\n    this._targetProperty = undefined;\n    this._definitionChanged.raiseEvent(this);\n  }\n};\n\nReferenceProperty.prototype._onCollectionChanged = function (\n  collection,\n  added,\n  removed,\n) {\n  let targetEntity = this._targetEntity;\n  if (defined(targetEntity) && removed.indexOf(targetEntity) !== -1) {\n    targetEntity.definitionChanged.removeEventListener(\n      ReferenceProperty.prototype._onTargetEntityDefinitionChanged,\n      this,\n    );\n    this._targetEntity = this._targetProperty = undefined;\n  } else if (!defined(targetEntity)) {\n    targetEntity = resolve(this);\n    if (defined(targetEntity)) {\n      this._definitionChanged.raiseEvent(this);\n    }\n  }\n};\nexport default ReferenceProperty;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}