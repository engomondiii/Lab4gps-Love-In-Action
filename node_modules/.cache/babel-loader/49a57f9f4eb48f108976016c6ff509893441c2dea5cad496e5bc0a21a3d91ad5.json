{"ast":null,"code":"import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport CullFace from \"../CullFace.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport StencilConstants from \"../StencilConstants.js\";\nimport StencilFunction from \"../StencilFunction.js\";\nimport StencilOperation from \"../StencilOperation.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\n\n/**\n * A wrapper around the draw commands used to render a {@link ModelRuntimePrimitive}.\n * This manages the derived commands and pushes only the necessary commands depending\n * on the given frame state.\n *\n * @param {object} options An object containing the following options:\n * @param {DrawCommand} options.command The draw command from which to derive other commands from.\n * @param {PrimitiveRenderResources} options.primitiveRenderResources The render resources of the primitive associated with the command.\n *\n * @alias ModelDrawCommand\n * @constructor\n *\n * @private\n */\nfunction ModelDrawCommand(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const command = options.command;\n  const renderResources = options.primitiveRenderResources;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.command\", command);\n  Check.typeOf.object(\"options.primitiveRenderResources\", renderResources);\n  //>>includeEnd('debug');\n\n  const model = renderResources.model;\n  this._model = model;\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  this._runtimePrimitive = runtimePrimitive;\n\n  // If the command is translucent, or if the primitive's material is\n  // double-sided, then back-face culling is automatically disabled for\n  // the command. The user value for back-face culling will be ignored.\n  const isTranslucent = command.pass === Pass.TRANSLUCENT;\n  const isDoubleSided = runtimePrimitive.primitive.material.doubleSided;\n  const usesBackFaceCulling = !isDoubleSided && !isTranslucent;\n  const hasSilhouette = renderResources.hasSilhouette;\n\n  // If the command was already translucent, there's no need to derive a new\n  // translucent command. As of now, a style can't change an originally\n  // translucent feature to opaque since the style's alpha is modulated,\n  // not replaced. When this changes, we need to derive new opaque commands\n  // in initialize().\n  //\n  // Silhouettes for primitives with both opaque and translucent features\n  // are not yet supported.\n  const needsTranslucentCommand = !isTranslucent && !hasSilhouette;\n  const needsSkipLevelOfDetailCommands = renderResources.hasSkipLevelOfDetail && !isTranslucent;\n  const needsSilhouetteCommands = hasSilhouette;\n  this._command = command;\n\n  // None of the derived commands (non-2D) use a different model matrix\n  // or bounding volume than the original, so they all point to the\n  // ModelDrawCommand's copy to save update time and memory.\n  this._modelMatrix = Matrix4.clone(command.modelMatrix);\n  this._boundingVolume = BoundingSphere.clone(command.boundingVolume);\n\n  // The 2D model matrix depends on the frame state's map projection,\n  // so it must be updated when the commands are handled in pushCommands.\n  this._modelMatrix2D = new Matrix4();\n  this._boundingVolume2D = new BoundingSphere();\n  this._modelMatrix2DDirty = false;\n  this._backFaceCulling = command.renderState.cull.enabled;\n  this._cullFace = command.renderState.cull.face;\n  this._shadows = model.shadows;\n  this._debugShowBoundingVolume = command.debugShowBoundingVolume;\n  this._usesBackFaceCulling = usesBackFaceCulling;\n  this._needsTranslucentCommand = needsTranslucentCommand;\n  this._needsSkipLevelOfDetailCommands = needsSkipLevelOfDetailCommands;\n  this._needsSilhouetteCommands = needsSilhouetteCommands;\n\n  // Derived commands\n  this._originalCommand = undefined;\n  this._translucentCommand = undefined;\n  this._skipLodBackfaceCommand = undefined;\n  this._skipLodStencilCommand = undefined;\n  this._silhouetteModelCommand = undefined;\n  this._silhouetteColorCommand = undefined;\n\n  // All derived commands (including 2D commands)\n  this._derivedCommands = [];\n  this._has2DCommands = false;\n  initialize(this);\n}\nfunction ModelDerivedCommand(options) {\n  // The DrawCommand managed by this derived command.\n  this.command = options.command;\n\n  // These control whether the derived command should update the\n  // values of the DrawCommand for the corresponding properties.\n  this.updateShadows = options.updateShadows;\n  this.updateBackFaceCulling = options.updateBackFaceCulling;\n  this.updateCullFace = options.updateCullFace;\n  this.updateDebugShowBoundingVolume = options.updateDebugShowBoundingVolume;\n\n  // Whether this ModelDerivedCommand is in 2D.\n  this.is2D = defaultValue(options.is2D, false);\n\n  // A ModelDerivedCommand that is the 2D version of this one.\n  this.derivedCommand2D = undefined;\n}\nModelDerivedCommand.clone = function (derivedCommand) {\n  return new ModelDerivedCommand({\n    command: derivedCommand.command,\n    updateShadows: derivedCommand.updateShadows,\n    updateBackFaceCulling: derivedCommand.updateBackFaceCulling,\n    updateCullFace: derivedCommand.updateCullFace,\n    updateDebugShowBoundingVolume: derivedCommand.updateDebugShowBoundingVolume,\n    is2D: derivedCommand.is2D,\n    derivedCommand2D: derivedCommand.derivedCommand2D\n  });\n};\nfunction initialize(drawCommand) {\n  const command = drawCommand._command;\n  command.modelMatrix = drawCommand._modelMatrix;\n  command.boundingVolume = drawCommand._boundingVolume;\n  const model = drawCommand._model;\n  const usesBackFaceCulling = drawCommand._usesBackFaceCulling;\n  const derivedCommands = drawCommand._derivedCommands;\n  drawCommand._originalCommand = new ModelDerivedCommand({\n    command: command,\n    updateShadows: true,\n    updateBackFaceCulling: usesBackFaceCulling,\n    updateCullFace: usesBackFaceCulling,\n    updateDebugShowBoundingVolume: true,\n    is2D: false\n  });\n  derivedCommands.push(drawCommand._originalCommand);\n  if (drawCommand._needsTranslucentCommand) {\n    drawCommand._translucentCommand = new ModelDerivedCommand({\n      command: deriveTranslucentCommand(command),\n      updateShadows: true,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: true\n    });\n    derivedCommands.push(drawCommand._translucentCommand);\n  }\n  if (drawCommand._needsSkipLevelOfDetailCommands) {\n    drawCommand._skipLodBackfaceCommand = new ModelDerivedCommand({\n      command: deriveSkipLodBackfaceCommand(command),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: false\n    });\n    drawCommand._skipLodStencilCommand = new ModelDerivedCommand({\n      command: deriveSkipLodStencilCommand(command, model),\n      updateShadows: true,\n      updateBackFaceCulling: usesBackFaceCulling,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: true\n    });\n    derivedCommands.push(drawCommand._skipLodBackfaceCommand);\n    derivedCommands.push(drawCommand._skipLodStencilCommand);\n  }\n  if (drawCommand._needsSilhouetteCommands) {\n    drawCommand._silhouetteModelCommand = new ModelDerivedCommand({\n      command: deriveSilhouetteModelCommand(command, model),\n      updateShadows: true,\n      updateBackFaceCulling: usesBackFaceCulling,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: true\n    });\n    drawCommand._silhouetteColorCommand = new ModelDerivedCommand({\n      command: deriveSilhouetteColorCommand(command, model),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: false\n    });\n    derivedCommands.push(drawCommand._silhouetteModelCommand);\n    derivedCommands.push(drawCommand._silhouetteColorCommand);\n  }\n}\nObject.defineProperties(ModelDrawCommand.prototype, {\n  /**\n   * The main draw command that the other commands are derived from.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {DrawCommand}\n   *\n   * @readonly\n   * @private\n   */\n  command: {\n    get: function () {\n      return this._command;\n    }\n  },\n  /**\n   * The runtime primitive that the draw command belongs to.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {ModelRuntimePrimitive}\n   *\n   * @readonly\n   * @private\n   */\n  runtimePrimitive: {\n    get: function () {\n      return this._runtimePrimitive;\n    }\n  },\n  /**\n   * The model that the draw command belongs to.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {Model}\n   *\n   * @readonly\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    }\n  },\n  /**\n   * The primitive type of the draw command.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {PrimitiveType}\n   *\n   * @readonly\n   * @private\n   */\n  primitiveType: {\n    get: function () {\n      return this._command.primitiveType;\n    }\n  },\n  /**\n   * The current model matrix applied to the draw commands. If there are\n   * 2D draw commands, their model matrix will be derived from the 3D one.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {Matrix4}\n   *\n   * @readonly\n   * @private\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (value) {\n      this._modelMatrix = Matrix4.clone(value, this._modelMatrix);\n      this._modelMatrix2DDirty = true;\n      this._boundingVolume = BoundingSphere.transform(this.runtimePrimitive.boundingSphere, this._modelMatrix, this._boundingVolume);\n    }\n  },\n  /**\n   * The bounding volume of the main draw command. This is equivalent\n   * to the primitive's bounding sphere transformed by the draw\n   * command's model matrix.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {BoundingSphere}\n   *\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingVolume;\n    }\n  },\n  /**\n   * Whether the geometry casts or receives shadows from light sources.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {ShadowMode}\n   *\n   * @private\n   */\n  shadows: {\n    get: function () {\n      return this._shadows;\n    },\n    set: function (value) {\n      this._shadows = value;\n      updateShadows(this);\n    }\n  },\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if the command is\n   * translucent.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {boolean}\n   *\n   * @private\n   */\n  backFaceCulling: {\n    get: function () {\n      return this._backFaceCulling;\n    },\n    set: function (value) {\n      if (this._backFaceCulling === value) {\n        return;\n      }\n      this._backFaceCulling = value;\n      updateBackFaceCulling(this);\n    }\n  },\n  /**\n   * Determines which faces to cull, if culling is enabled.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {CullFace}\n   *\n   * @private\n   */\n  cullFace: {\n    get: function () {\n      return this._cullFace;\n    },\n    set: function (value) {\n      if (this._cullFace === value) {\n        return;\n      }\n      this._cullFace = value;\n      updateCullFace(this);\n    }\n  },\n  /**\n   * Whether to draw the bounding sphere associated with this draw command.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {boolean}\n   *\n   * @private\n   */\n  debugShowBoundingVolume: {\n    get: function () {\n      return this._debugShowBoundingVolume;\n    },\n    set: function (value) {\n      if (this._debugShowBoundingVolume === value) {\n        return;\n      }\n      this._debugShowBoundingVolume = value;\n      updateDebugShowBoundingVolume(this);\n    }\n  }\n});\nfunction updateModelMatrix2D(drawCommand, frameState) {\n  const modelMatrix = drawCommand._modelMatrix;\n  drawCommand._modelMatrix2D = Matrix4.clone(modelMatrix, drawCommand._modelMatrix2D);\n\n  // Change the translation's y-component so it appears on the opposite side\n  // of the map.\n  drawCommand._modelMatrix2D[13] -= CesiumMath.sign(modelMatrix[13]) * 2.0 * CesiumMath.PI * frameState.mapProjection.ellipsoid.maximumRadius;\n  drawCommand._boundingVolume2D = BoundingSphere.transform(drawCommand.runtimePrimitive.boundingSphere, drawCommand._modelMatrix2D, drawCommand._boundingVolume2D);\n}\nfunction updateShadows(drawCommand) {\n  const shadows = drawCommand.shadows;\n  const castShadows = ShadowMode.castShadows(shadows);\n  const receiveShadows = ShadowMode.receiveShadows(shadows);\n  const derivedCommands = drawCommand._derivedCommands;\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateShadows) {\n      const command = derivedCommand.command;\n      command.castShadows = castShadows;\n      command.receiveShadows = receiveShadows;\n    }\n  }\n}\nfunction updateBackFaceCulling(drawCommand) {\n  const backFaceCulling = drawCommand.backFaceCulling;\n  const derivedCommands = drawCommand._derivedCommands;\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateBackFaceCulling) {\n      const command = derivedCommand.command;\n      const renderState = clone(command.renderState, true);\n      renderState.cull.enabled = backFaceCulling;\n      command.renderState = RenderState.fromCache(renderState);\n    }\n  }\n}\nfunction updateCullFace(drawCommand) {\n  const cullFace = drawCommand.cullFace;\n  const derivedCommands = drawCommand._derivedCommands;\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateCullFace) {\n      const command = derivedCommand.command;\n      const renderState = clone(command.renderState, true);\n      renderState.cull.face = cullFace;\n      command.renderState = RenderState.fromCache(renderState);\n    }\n  }\n}\nfunction updateDebugShowBoundingVolume(drawCommand) {\n  const debugShowBoundingVolume = drawCommand.debugShowBoundingVolume;\n  const derivedCommands = drawCommand._derivedCommands;\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateDebugShowBoundingVolume) {\n      const command = derivedCommand.command;\n      command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\n/**\n * Pushes the draw commands necessary to render the primitive.\n * This does not include the draw commands that render its silhouette.\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the draw commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nModelDrawCommand.prototype.pushCommands = function (frameState, result) {\n  const use2D = shouldUse2DCommands(this, frameState);\n  if (use2D && !this._has2DCommands) {\n    derive2DCommands(this);\n    this._has2DCommands = true;\n    this._modelMatrix2DDirty = true;\n  }\n  if (this._modelMatrix2DDirty) {\n    updateModelMatrix2D(this, frameState);\n    this._modelMatrix2DDirty = false;\n  }\n  const styleCommandsNeeded = this.model.styleCommandsNeeded;\n  if (this._needsTranslucentCommand && defined(styleCommandsNeeded)) {\n    // StyleCommandsNeeded has three values: all opaque, all translucent, or both.\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE) {\n      pushCommand(result, this._translucentCommand, use2D);\n    }\n\n    // Continue only if opaque commands are needed.\n    if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n      return;\n    }\n  }\n  if (this._needsSkipLevelOfDetailCommands) {\n    const {\n      tileset,\n      tile\n    } = this._model.content;\n    if (tileset.hasMixedContent) {\n      if (!tile._finalResolution) {\n        pushCommand(tileset._backfaceCommands, this._skipLodBackfaceCommand, use2D);\n      }\n      updateSkipLodStencilCommand(this, tile, use2D);\n      pushCommand(result, this._skipLodStencilCommand, use2D);\n      return;\n    }\n  }\n  if (this._needsSilhouetteCommands) {\n    pushCommand(result, this._silhouetteModelCommand, use2D);\n    return;\n  }\n  pushCommand(result, this._originalCommand, use2D);\n  return result;\n};\n\n/**\n * Pushes the draw commands necessary to render the silhouette. These should\n * be added to the command list after the draw commands of all primitives\n * in the model have been added. This way, the silhouette won't render on\n * top of the model.\n * <p>\n * This should only be called after pushCommands() has been invoked for\n * the ModelDrawCommand this frame. Otherwise, the silhouette commands may\n * not have been derived for 2D. The model matrix will also not have been\n * updated for 2D commands.\n * </p>\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the silhouette commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nModelDrawCommand.prototype.pushSilhouetteCommands = function (frameState, result) {\n  const use2D = shouldUse2DCommands(this, frameState);\n  pushCommand(result, this._silhouetteColorCommand, use2D);\n  return result;\n};\nfunction pushCommand(commandList, derivedCommand, use2D) {\n  commandList.push(derivedCommand.command);\n  if (use2D) {\n    commandList.push(derivedCommand.derivedCommand2D.command);\n  }\n}\nfunction shouldUse2DCommands(drawCommand, frameState) {\n  if (frameState.mode !== SceneMode.SCENE2D || drawCommand.model._projectTo2D) {\n    return false;\n  }\n\n  // The draw command's bounding sphere might cause primitives not to render\n  // over the IDL, even if they are part of the same model. Use the scene graph's\n  // bounding sphere instead.\n  const model = drawCommand.model;\n  const boundingSphere = model.sceneGraph._boundingSphere2D;\n  const left = boundingSphere.center.y - boundingSphere.radius;\n  const right = boundingSphere.center.y + boundingSphere.radius;\n  const idl2D = frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n  return left < idl2D && right > idl2D || left < -idl2D && right > -idl2D;\n}\nfunction derive2DCommand(drawCommand, derivedCommand) {\n  if (!defined(derivedCommand)) {\n    return;\n  }\n\n  // If the model crosses the IDL in 2D, it will be drawn in one viewport but get\n  // clipped by the other viewport. We create a second command that translates\n  // the model matrix to the opposite side of the map so the part that was clipped\n  // in one viewport is drawn in the other.\n  const derivedCommand2D = ModelDerivedCommand.clone(derivedCommand);\n  const command2D = DrawCommand.shallowClone(derivedCommand.command);\n  command2D.modelMatrix = drawCommand._modelMatrix2D;\n  command2D.boundingVolume = drawCommand._boundingVolume2D;\n  derivedCommand2D.command = command2D;\n  derivedCommand2D.updateShadows = false; // Shadows are disabled for 2D\n  derivedCommand2D.is2D = true;\n  derivedCommand.derivedCommand2D = derivedCommand2D;\n  drawCommand._derivedCommands.push(derivedCommand2D);\n  return derivedCommand2D;\n}\nfunction derive2DCommands(drawCommand) {\n  derive2DCommand(drawCommand, drawCommand._originalCommand);\n  derive2DCommand(drawCommand, drawCommand._translucentCommand);\n  derive2DCommand(drawCommand, drawCommand._skipLodBackfaceCommand);\n  derive2DCommand(drawCommand, drawCommand._skipLodStencilCommand);\n  derive2DCommand(drawCommand, drawCommand._silhouetteModelCommand);\n  derive2DCommand(drawCommand, drawCommand._silhouetteColorCommand);\n}\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  const rs = clone(command.renderState, true);\n  rs.cull.enabled = false;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  return derivedCommand;\n}\nfunction deriveSilhouetteModelCommand(command, model) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = model._silhouetteId % 255;\n  const silhouetteModelCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n\n  // Write the reference value into the stencil buffer.\n  renderState.stencilTest = {\n    enabled: true,\n    frontFunction: WebGLConstants.ALWAYS,\n    backFunction: WebGLConstants.ALWAYS,\n    reference: stencilReference,\n    mask: ~0,\n    frontOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.REPLACE\n    },\n    backOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.REPLACE\n    }\n  };\n  if (model.isInvisible()) {\n    renderState.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    };\n  }\n  silhouetteModelCommand.renderState = RenderState.fromCache(renderState);\n  return silhouetteModelCommand;\n}\nfunction deriveSilhouetteColorCommand(command, model) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = model._silhouetteId % 255;\n  const silhouetteColorCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  renderState.cull.enabled = false;\n\n  // Render the silhouette in the translucent pass if either the command\n  // pass or the silhouette color is translucent. This will account for\n  // translucent model color, since ModelColorPipelineStage sets the pass\n  // to translucent.\n  const silhouetteTranslucent = command.pass === Pass.TRANSLUCENT || model.silhouetteColor.alpha < 1.0;\n  if (silhouetteTranslucent) {\n    silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n    renderState.depthMask = false;\n    renderState.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  // Only render the pixels of the silhouette that don't conflict with\n  // the stencil buffer. This way, the silhouette doesn't render over\n  // the original model.\n  renderState.stencilTest = {\n    enabled: true,\n    frontFunction: WebGLConstants.NOTEQUAL,\n    backFunction: WebGLConstants.NOTEQUAL,\n    reference: stencilReference,\n    mask: ~0,\n    frontOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.KEEP\n    },\n    backOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.KEEP\n    }\n  };\n  const uniformMap = clone(command.uniformMap);\n  uniformMap.model_silhouettePass = function () {\n    return true;\n  };\n  silhouetteColorCommand.renderState = RenderState.fromCache(renderState);\n  silhouetteColorCommand.uniformMap = uniformMap;\n  silhouetteColorCommand.castShadows = false;\n  silhouetteColorCommand.receiveShadows = false;\n  return silhouetteColorCommand;\n}\nfunction updateSkipLodStencilCommand(drawCommand, tile, use2D) {\n  const stencilDerivedComand = drawCommand._skipLodStencilCommand;\n  const stencilCommand = stencilDerivedComand.command;\n  const selectionDepth = tile._selectionDepth;\n  const lastSelectionDepth = getLastSelectionDepth(stencilCommand);\n  if (selectionDepth !== lastSelectionDepth) {\n    const skipLodStencilReference = getStencilReference(selectionDepth);\n    const renderState = clone(stencilCommand.renderState, true);\n    renderState.stencilTest.reference = skipLodStencilReference;\n    stencilCommand.renderState = RenderState.fromCache(renderState);\n    if (use2D) {\n      stencilDerivedComand.derivedCommand2D.renderState = renderState;\n    }\n  }\n}\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  const reference = stencilCommand.renderState.stencilTest.reference;\n  return (reference & StencilConstants.SKIP_LOD_MASK) >>> StencilConstants.SKIP_LOD_BIT_SHIFT;\n}\nfunction getStencilReference(selectionDepth) {\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted.\n  // Writes 0 for the terrain bit.\n  return StencilConstants.CESIUM_3D_TILE_MASK | selectionDepth << StencilConstants.SKIP_LOD_BIT_SHIFT;\n}\nfunction deriveSkipLodBackfaceCommand(command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles\n  // do not appear in front.\n  const backfaceCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  renderState.cull.enabled = true;\n  renderState.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  renderState.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0\n  };\n\n  // The stencil test is set in TilesetPipelineStage.\n\n  const uniformMap = clone(backfaceCommand.uniformMap);\n  const polygonOffset = new Cartesian2(5.0, 5.0);\n  uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n  backfaceCommand.renderState = RenderState.fromCache(renderState);\n  backfaceCommand.uniformMap = uniformMap;\n  backfaceCommand.castShadows = false;\n  backfaceCommand.receiveShadows = false;\n  return backfaceCommand;\n}\nfunction deriveSkipLodStencilCommand(command) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  const stencilCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  // The stencil reference is updated dynamically; see updateSkipLodStencilCommand().\n  const {\n    stencilTest\n  } = renderState;\n  stencilTest.enabled = true;\n  stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  stencilTest.reference = StencilConstants.CESIUM_3D_TILE_MASK;\n  stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  renderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n  stencilCommand.renderState = RenderState.fromCache(renderState);\n  return stencilCommand;\n}\nexport default ModelDrawCommand;","map":{"version":3,"names":["BoundingSphere","Cartesian2","CesiumMath","Check","clone","defaultValue","defined","Matrix4","WebGLConstants","DrawCommand","Pass","RenderState","BlendingState","CullFace","SceneMode","ShadowMode","StencilConstants","StencilFunction","StencilOperation","StyleCommandsNeeded","ModelDrawCommand","options","EMPTY_OBJECT","command","renderResources","primitiveRenderResources","typeOf","object","model","_model","runtimePrimitive","_runtimePrimitive","isTranslucent","pass","TRANSLUCENT","isDoubleSided","primitive","material","doubleSided","usesBackFaceCulling","hasSilhouette","needsTranslucentCommand","needsSkipLevelOfDetailCommands","hasSkipLevelOfDetail","needsSilhouetteCommands","_command","_modelMatrix","modelMatrix","_boundingVolume","boundingVolume","_modelMatrix2D","_boundingVolume2D","_modelMatrix2DDirty","_backFaceCulling","renderState","cull","enabled","_cullFace","face","_shadows","shadows","_debugShowBoundingVolume","debugShowBoundingVolume","_usesBackFaceCulling","_needsTranslucentCommand","_needsSkipLevelOfDetailCommands","_needsSilhouetteCommands","_originalCommand","undefined","_translucentCommand","_skipLodBackfaceCommand","_skipLodStencilCommand","_silhouetteModelCommand","_silhouetteColorCommand","_derivedCommands","_has2DCommands","initialize","ModelDerivedCommand","updateShadows","updateBackFaceCulling","updateCullFace","updateDebugShowBoundingVolume","is2D","derivedCommand2D","derivedCommand","drawCommand","derivedCommands","push","deriveTranslucentCommand","deriveSkipLodBackfaceCommand","deriveSkipLodStencilCommand","deriveSilhouetteModelCommand","deriveSilhouetteColorCommand","Object","defineProperties","prototype","get","primitiveType","set","value","transform","boundingSphere","backFaceCulling","cullFace","updateModelMatrix2D","frameState","sign","PI","mapProjection","ellipsoid","maximumRadius","castShadows","receiveShadows","i","length","fromCache","pushCommands","result","use2D","shouldUse2DCommands","derive2DCommands","styleCommandsNeeded","ALL_OPAQUE","pushCommand","ALL_TRANSLUCENT","tileset","tile","content","hasMixedContent","_finalResolution","_backfaceCommands","updateSkipLodStencilCommand","pushSilhouetteCommands","commandList","mode","SCENE2D","_projectTo2D","sceneGraph","_boundingSphere2D","left","center","y","radius","right","idl2D","derive2DCommand","command2D","shallowClone","rs","depthMask","blending","ALPHA_BLEND","stencilReference","_silhouetteId","silhouetteModelCommand","stencilTest","frontFunction","ALWAYS","backFunction","reference","mask","frontOperation","fail","KEEP","zFail","zPass","REPLACE","backOperation","isInvisible","colorMask","red","green","blue","alpha","silhouetteColorCommand","silhouetteTranslucent","silhouetteColor","NOTEQUAL","uniformMap","model_silhouettePass","stencilDerivedComand","stencilCommand","selectionDepth","_selectionDepth","lastSelectionDepth","getLastSelectionDepth","skipLodStencilReference","getStencilReference","SKIP_LOD_MASK","SKIP_LOD_BIT_SHIFT","CESIUM_3D_TILE_MASK","backfaceCommand","FRONT","polygonOffset","factor","units","u_polygonOffset","GREATER_OR_EQUAL","stencilMask"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelDrawCommand.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport CullFace from \"../CullFace.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport StencilConstants from \"../StencilConstants.js\";\nimport StencilFunction from \"../StencilFunction.js\";\nimport StencilOperation from \"../StencilOperation.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\n\n/**\n * A wrapper around the draw commands used to render a {@link ModelRuntimePrimitive}.\n * This manages the derived commands and pushes only the necessary commands depending\n * on the given frame state.\n *\n * @param {object} options An object containing the following options:\n * @param {DrawCommand} options.command The draw command from which to derive other commands from.\n * @param {PrimitiveRenderResources} options.primitiveRenderResources The render resources of the primitive associated with the command.\n *\n * @alias ModelDrawCommand\n * @constructor\n *\n * @private\n */\nfunction ModelDrawCommand(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const command = options.command;\n  const renderResources = options.primitiveRenderResources;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.command\", command);\n  Check.typeOf.object(\"options.primitiveRenderResources\", renderResources);\n  //>>includeEnd('debug');\n\n  const model = renderResources.model;\n  this._model = model;\n\n  const runtimePrimitive = renderResources.runtimePrimitive;\n  this._runtimePrimitive = runtimePrimitive;\n\n  // If the command is translucent, or if the primitive's material is\n  // double-sided, then back-face culling is automatically disabled for\n  // the command. The user value for back-face culling will be ignored.\n  const isTranslucent = command.pass === Pass.TRANSLUCENT;\n  const isDoubleSided = runtimePrimitive.primitive.material.doubleSided;\n  const usesBackFaceCulling = !isDoubleSided && !isTranslucent;\n  const hasSilhouette = renderResources.hasSilhouette;\n\n  // If the command was already translucent, there's no need to derive a new\n  // translucent command. As of now, a style can't change an originally\n  // translucent feature to opaque since the style's alpha is modulated,\n  // not replaced. When this changes, we need to derive new opaque commands\n  // in initialize().\n  //\n  // Silhouettes for primitives with both opaque and translucent features\n  // are not yet supported.\n  const needsTranslucentCommand = !isTranslucent && !hasSilhouette;\n\n  const needsSkipLevelOfDetailCommands =\n    renderResources.hasSkipLevelOfDetail && !isTranslucent;\n\n  const needsSilhouetteCommands = hasSilhouette;\n\n  this._command = command;\n\n  // None of the derived commands (non-2D) use a different model matrix\n  // or bounding volume than the original, so they all point to the\n  // ModelDrawCommand's copy to save update time and memory.\n  this._modelMatrix = Matrix4.clone(command.modelMatrix);\n  this._boundingVolume = BoundingSphere.clone(command.boundingVolume);\n\n  // The 2D model matrix depends on the frame state's map projection,\n  // so it must be updated when the commands are handled in pushCommands.\n  this._modelMatrix2D = new Matrix4();\n  this._boundingVolume2D = new BoundingSphere();\n  this._modelMatrix2DDirty = false;\n\n  this._backFaceCulling = command.renderState.cull.enabled;\n  this._cullFace = command.renderState.cull.face;\n  this._shadows = model.shadows;\n  this._debugShowBoundingVolume = command.debugShowBoundingVolume;\n\n  this._usesBackFaceCulling = usesBackFaceCulling;\n  this._needsTranslucentCommand = needsTranslucentCommand;\n  this._needsSkipLevelOfDetailCommands = needsSkipLevelOfDetailCommands;\n  this._needsSilhouetteCommands = needsSilhouetteCommands;\n\n  // Derived commands\n  this._originalCommand = undefined;\n  this._translucentCommand = undefined;\n  this._skipLodBackfaceCommand = undefined;\n  this._skipLodStencilCommand = undefined;\n  this._silhouetteModelCommand = undefined;\n  this._silhouetteColorCommand = undefined;\n\n  // All derived commands (including 2D commands)\n  this._derivedCommands = [];\n  this._has2DCommands = false;\n\n  initialize(this);\n}\n\nfunction ModelDerivedCommand(options) {\n  // The DrawCommand managed by this derived command.\n  this.command = options.command;\n\n  // These control whether the derived command should update the\n  // values of the DrawCommand for the corresponding properties.\n  this.updateShadows = options.updateShadows;\n  this.updateBackFaceCulling = options.updateBackFaceCulling;\n  this.updateCullFace = options.updateCullFace;\n  this.updateDebugShowBoundingVolume = options.updateDebugShowBoundingVolume;\n\n  // Whether this ModelDerivedCommand is in 2D.\n  this.is2D = defaultValue(options.is2D, false);\n\n  // A ModelDerivedCommand that is the 2D version of this one.\n  this.derivedCommand2D = undefined;\n}\n\nModelDerivedCommand.clone = function (derivedCommand) {\n  return new ModelDerivedCommand({\n    command: derivedCommand.command,\n    updateShadows: derivedCommand.updateShadows,\n    updateBackFaceCulling: derivedCommand.updateBackFaceCulling,\n    updateCullFace: derivedCommand.updateCullFace,\n    updateDebugShowBoundingVolume: derivedCommand.updateDebugShowBoundingVolume,\n    is2D: derivedCommand.is2D,\n    derivedCommand2D: derivedCommand.derivedCommand2D,\n  });\n};\n\nfunction initialize(drawCommand) {\n  const command = drawCommand._command;\n  command.modelMatrix = drawCommand._modelMatrix;\n  command.boundingVolume = drawCommand._boundingVolume;\n\n  const model = drawCommand._model;\n  const usesBackFaceCulling = drawCommand._usesBackFaceCulling;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  drawCommand._originalCommand = new ModelDerivedCommand({\n    command: command,\n    updateShadows: true,\n    updateBackFaceCulling: usesBackFaceCulling,\n    updateCullFace: usesBackFaceCulling,\n    updateDebugShowBoundingVolume: true,\n    is2D: false,\n  });\n\n  derivedCommands.push(drawCommand._originalCommand);\n\n  if (drawCommand._needsTranslucentCommand) {\n    drawCommand._translucentCommand = new ModelDerivedCommand({\n      command: deriveTranslucentCommand(command),\n      updateShadows: true,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: true,\n    });\n\n    derivedCommands.push(drawCommand._translucentCommand);\n  }\n\n  if (drawCommand._needsSkipLevelOfDetailCommands) {\n    drawCommand._skipLodBackfaceCommand = new ModelDerivedCommand({\n      command: deriveSkipLodBackfaceCommand(command),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: false,\n    });\n\n    drawCommand._skipLodStencilCommand = new ModelDerivedCommand({\n      command: deriveSkipLodStencilCommand(command, model),\n      updateShadows: true,\n      updateBackFaceCulling: usesBackFaceCulling,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: true,\n    });\n\n    derivedCommands.push(drawCommand._skipLodBackfaceCommand);\n    derivedCommands.push(drawCommand._skipLodStencilCommand);\n  }\n\n  if (drawCommand._needsSilhouetteCommands) {\n    drawCommand._silhouetteModelCommand = new ModelDerivedCommand({\n      command: deriveSilhouetteModelCommand(command, model),\n      updateShadows: true,\n      updateBackFaceCulling: usesBackFaceCulling,\n      updateCullFace: usesBackFaceCulling,\n      updateDebugShowBoundingVolume: true,\n    });\n\n    drawCommand._silhouetteColorCommand = new ModelDerivedCommand({\n      command: deriveSilhouetteColorCommand(command, model),\n      updateShadows: false,\n      updateBackFaceCulling: false,\n      updateCullFace: false,\n      updateDebugShowBoundingVolume: false,\n    });\n\n    derivedCommands.push(drawCommand._silhouetteModelCommand);\n    derivedCommands.push(drawCommand._silhouetteColorCommand);\n  }\n}\n\nObject.defineProperties(ModelDrawCommand.prototype, {\n  /**\n   * The main draw command that the other commands are derived from.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {DrawCommand}\n   *\n   * @readonly\n   * @private\n   */\n  command: {\n    get: function () {\n      return this._command;\n    },\n  },\n\n  /**\n   * The runtime primitive that the draw command belongs to.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {ModelRuntimePrimitive}\n   *\n   * @readonly\n   * @private\n   */\n  runtimePrimitive: {\n    get: function () {\n      return this._runtimePrimitive;\n    },\n  },\n\n  /**\n   * The model that the draw command belongs to.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {Model}\n   *\n   * @readonly\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The primitive type of the draw command.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {PrimitiveType}\n   *\n   * @readonly\n   * @private\n   */\n  primitiveType: {\n    get: function () {\n      return this._command.primitiveType;\n    },\n  },\n\n  /**\n   * The current model matrix applied to the draw commands. If there are\n   * 2D draw commands, their model matrix will be derived from the 3D one.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {Matrix4}\n   *\n   * @readonly\n   * @private\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (value) {\n      this._modelMatrix = Matrix4.clone(value, this._modelMatrix);\n      this._modelMatrix2DDirty = true;\n\n      this._boundingVolume = BoundingSphere.transform(\n        this.runtimePrimitive.boundingSphere,\n        this._modelMatrix,\n        this._boundingVolume,\n      );\n    },\n  },\n\n  /**\n   * The bounding volume of the main draw command. This is equivalent\n   * to the primitive's bounding sphere transformed by the draw\n   * command's model matrix.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {BoundingSphere}\n   *\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingVolume;\n    },\n  },\n\n  /**\n   * Whether the geometry casts or receives shadows from light sources.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {ShadowMode}\n   *\n   * @private\n   */\n  shadows: {\n    get: function () {\n      return this._shadows;\n    },\n    set: function (value) {\n      this._shadows = value;\n      updateShadows(this);\n    },\n  },\n\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if the command is\n   * translucent.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {boolean}\n   *\n   * @private\n   */\n  backFaceCulling: {\n    get: function () {\n      return this._backFaceCulling;\n    },\n    set: function (value) {\n      if (this._backFaceCulling === value) {\n        return;\n      }\n\n      this._backFaceCulling = value;\n      updateBackFaceCulling(this);\n    },\n  },\n\n  /**\n   * Determines which faces to cull, if culling is enabled.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {CullFace}\n   *\n   * @private\n   */\n  cullFace: {\n    get: function () {\n      return this._cullFace;\n    },\n    set: function (value) {\n      if (this._cullFace === value) {\n        return;\n      }\n\n      this._cullFace = value;\n      updateCullFace(this);\n    },\n  },\n\n  /**\n   * Whether to draw the bounding sphere associated with this draw command.\n   *\n   * @memberof ModelDrawCommand.prototype\n   * @type {boolean}\n   *\n   * @private\n   */\n  debugShowBoundingVolume: {\n    get: function () {\n      return this._debugShowBoundingVolume;\n    },\n    set: function (value) {\n      if (this._debugShowBoundingVolume === value) {\n        return;\n      }\n\n      this._debugShowBoundingVolume = value;\n      updateDebugShowBoundingVolume(this);\n    },\n  },\n});\n\nfunction updateModelMatrix2D(drawCommand, frameState) {\n  const modelMatrix = drawCommand._modelMatrix;\n  drawCommand._modelMatrix2D = Matrix4.clone(\n    modelMatrix,\n    drawCommand._modelMatrix2D,\n  );\n\n  // Change the translation's y-component so it appears on the opposite side\n  // of the map.\n  drawCommand._modelMatrix2D[13] -=\n    CesiumMath.sign(modelMatrix[13]) *\n    2.0 *\n    CesiumMath.PI *\n    frameState.mapProjection.ellipsoid.maximumRadius;\n\n  drawCommand._boundingVolume2D = BoundingSphere.transform(\n    drawCommand.runtimePrimitive.boundingSphere,\n    drawCommand._modelMatrix2D,\n    drawCommand._boundingVolume2D,\n  );\n}\n\nfunction updateShadows(drawCommand) {\n  const shadows = drawCommand.shadows;\n  const castShadows = ShadowMode.castShadows(shadows);\n  const receiveShadows = ShadowMode.receiveShadows(shadows);\n\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateShadows) {\n      const command = derivedCommand.command;\n      command.castShadows = castShadows;\n      command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction updateBackFaceCulling(drawCommand) {\n  const backFaceCulling = drawCommand.backFaceCulling;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateBackFaceCulling) {\n      const command = derivedCommand.command;\n      const renderState = clone(command.renderState, true);\n      renderState.cull.enabled = backFaceCulling;\n      command.renderState = RenderState.fromCache(renderState);\n    }\n  }\n}\n\nfunction updateCullFace(drawCommand) {\n  const cullFace = drawCommand.cullFace;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateCullFace) {\n      const command = derivedCommand.command;\n      const renderState = clone(command.renderState, true);\n      renderState.cull.face = cullFace;\n      command.renderState = RenderState.fromCache(renderState);\n    }\n  }\n}\n\nfunction updateDebugShowBoundingVolume(drawCommand) {\n  const debugShowBoundingVolume = drawCommand.debugShowBoundingVolume;\n  const derivedCommands = drawCommand._derivedCommands;\n\n  for (let i = 0; i < derivedCommands.length; ++i) {\n    const derivedCommand = derivedCommands[i];\n    if (derivedCommand.updateDebugShowBoundingVolume) {\n      const command = derivedCommand.command;\n      command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\n/**\n * Pushes the draw commands necessary to render the primitive.\n * This does not include the draw commands that render its silhouette.\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the draw commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nModelDrawCommand.prototype.pushCommands = function (frameState, result) {\n  const use2D = shouldUse2DCommands(this, frameState);\n\n  if (use2D && !this._has2DCommands) {\n    derive2DCommands(this);\n    this._has2DCommands = true;\n    this._modelMatrix2DDirty = true;\n  }\n\n  if (this._modelMatrix2DDirty) {\n    updateModelMatrix2D(this, frameState);\n    this._modelMatrix2DDirty = false;\n  }\n\n  const styleCommandsNeeded = this.model.styleCommandsNeeded;\n  if (this._needsTranslucentCommand && defined(styleCommandsNeeded)) {\n    // StyleCommandsNeeded has three values: all opaque, all translucent, or both.\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE) {\n      pushCommand(result, this._translucentCommand, use2D);\n    }\n\n    // Continue only if opaque commands are needed.\n    if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n      return;\n    }\n  }\n\n  if (this._needsSkipLevelOfDetailCommands) {\n    const { tileset, tile } = this._model.content;\n\n    if (tileset.hasMixedContent) {\n      if (!tile._finalResolution) {\n        pushCommand(\n          tileset._backfaceCommands,\n          this._skipLodBackfaceCommand,\n          use2D,\n        );\n      }\n\n      updateSkipLodStencilCommand(this, tile, use2D);\n      pushCommand(result, this._skipLodStencilCommand, use2D);\n      return;\n    }\n  }\n\n  if (this._needsSilhouetteCommands) {\n    pushCommand(result, this._silhouetteModelCommand, use2D);\n    return;\n  }\n\n  pushCommand(result, this._originalCommand, use2D);\n\n  return result;\n};\n\n/**\n * Pushes the draw commands necessary to render the silhouette. These should\n * be added to the command list after the draw commands of all primitives\n * in the model have been added. This way, the silhouette won't render on\n * top of the model.\n * <p>\n * This should only be called after pushCommands() has been invoked for\n * the ModelDrawCommand this frame. Otherwise, the silhouette commands may\n * not have been derived for 2D. The model matrix will also not have been\n * updated for 2D commands.\n * </p>\n *\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} result The array to push the silhouette commands to.\n *\n * @returns {DrawCommand[]} The modified result parameter.\n *\n * @private\n */\nModelDrawCommand.prototype.pushSilhouetteCommands = function (\n  frameState,\n  result,\n) {\n  const use2D = shouldUse2DCommands(this, frameState);\n  pushCommand(result, this._silhouetteColorCommand, use2D);\n\n  return result;\n};\n\nfunction pushCommand(commandList, derivedCommand, use2D) {\n  commandList.push(derivedCommand.command);\n  if (use2D) {\n    commandList.push(derivedCommand.derivedCommand2D.command);\n  }\n}\n\nfunction shouldUse2DCommands(drawCommand, frameState) {\n  if (frameState.mode !== SceneMode.SCENE2D || drawCommand.model._projectTo2D) {\n    return false;\n  }\n\n  // The draw command's bounding sphere might cause primitives not to render\n  // over the IDL, even if they are part of the same model. Use the scene graph's\n  // bounding sphere instead.\n  const model = drawCommand.model;\n  const boundingSphere = model.sceneGraph._boundingSphere2D;\n\n  const left = boundingSphere.center.y - boundingSphere.radius;\n  const right = boundingSphere.center.y + boundingSphere.radius;\n  const idl2D =\n    frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  return (left < idl2D && right > idl2D) || (left < -idl2D && right > -idl2D);\n}\n\nfunction derive2DCommand(drawCommand, derivedCommand) {\n  if (!defined(derivedCommand)) {\n    return;\n  }\n\n  // If the model crosses the IDL in 2D, it will be drawn in one viewport but get\n  // clipped by the other viewport. We create a second command that translates\n  // the model matrix to the opposite side of the map so the part that was clipped\n  // in one viewport is drawn in the other.\n  const derivedCommand2D = ModelDerivedCommand.clone(derivedCommand);\n\n  const command2D = DrawCommand.shallowClone(derivedCommand.command);\n  command2D.modelMatrix = drawCommand._modelMatrix2D;\n  command2D.boundingVolume = drawCommand._boundingVolume2D;\n\n  derivedCommand2D.command = command2D;\n  derivedCommand2D.updateShadows = false; // Shadows are disabled for 2D\n  derivedCommand2D.is2D = true;\n\n  derivedCommand.derivedCommand2D = derivedCommand2D;\n  drawCommand._derivedCommands.push(derivedCommand2D);\n\n  return derivedCommand2D;\n}\n\nfunction derive2DCommands(drawCommand) {\n  derive2DCommand(drawCommand, drawCommand._originalCommand);\n  derive2DCommand(drawCommand, drawCommand._translucentCommand);\n  derive2DCommand(drawCommand, drawCommand._skipLodBackfaceCommand);\n  derive2DCommand(drawCommand, drawCommand._skipLodStencilCommand);\n  derive2DCommand(drawCommand, drawCommand._silhouetteModelCommand);\n  derive2DCommand(drawCommand, drawCommand._silhouetteColorCommand);\n}\n\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  const rs = clone(command.renderState, true);\n  rs.cull.enabled = false;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n\n  return derivedCommand;\n}\n\nfunction deriveSilhouetteModelCommand(command, model) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = model._silhouetteId % 255;\n  const silhouetteModelCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n\n  // Write the reference value into the stencil buffer.\n  renderState.stencilTest = {\n    enabled: true,\n    frontFunction: WebGLConstants.ALWAYS,\n    backFunction: WebGLConstants.ALWAYS,\n    reference: stencilReference,\n    mask: ~0,\n    frontOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.REPLACE,\n    },\n    backOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.REPLACE,\n    },\n  };\n\n  if (model.isInvisible()) {\n    renderState.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    };\n  }\n\n  silhouetteModelCommand.renderState = RenderState.fromCache(renderState);\n\n  return silhouetteModelCommand;\n}\n\nfunction deriveSilhouetteColorCommand(command, model) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = model._silhouetteId % 255;\n  const silhouetteColorCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  renderState.cull.enabled = false;\n\n  // Render the silhouette in the translucent pass if either the command\n  // pass or the silhouette color is translucent. This will account for\n  // translucent model color, since ModelColorPipelineStage sets the pass\n  // to translucent.\n  const silhouetteTranslucent =\n    command.pass === Pass.TRANSLUCENT || model.silhouetteColor.alpha < 1.0;\n  if (silhouetteTranslucent) {\n    silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n    renderState.depthMask = false;\n    renderState.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  // Only render the pixels of the silhouette that don't conflict with\n  // the stencil buffer. This way, the silhouette doesn't render over\n  // the original model.\n  renderState.stencilTest = {\n    enabled: true,\n    frontFunction: WebGLConstants.NOTEQUAL,\n    backFunction: WebGLConstants.NOTEQUAL,\n    reference: stencilReference,\n    mask: ~0,\n    frontOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.KEEP,\n    },\n    backOperation: {\n      fail: WebGLConstants.KEEP,\n      zFail: WebGLConstants.KEEP,\n      zPass: WebGLConstants.KEEP,\n    },\n  };\n\n  const uniformMap = clone(command.uniformMap);\n  uniformMap.model_silhouettePass = function () {\n    return true;\n  };\n\n  silhouetteColorCommand.renderState = RenderState.fromCache(renderState);\n  silhouetteColorCommand.uniformMap = uniformMap;\n  silhouetteColorCommand.castShadows = false;\n  silhouetteColorCommand.receiveShadows = false;\n\n  return silhouetteColorCommand;\n}\n\nfunction updateSkipLodStencilCommand(drawCommand, tile, use2D) {\n  const stencilDerivedComand = drawCommand._skipLodStencilCommand;\n  const stencilCommand = stencilDerivedComand.command;\n\n  const selectionDepth = tile._selectionDepth;\n  const lastSelectionDepth = getLastSelectionDepth(stencilCommand);\n\n  if (selectionDepth !== lastSelectionDepth) {\n    const skipLodStencilReference = getStencilReference(selectionDepth);\n    const renderState = clone(stencilCommand.renderState, true);\n    renderState.stencilTest.reference = skipLodStencilReference;\n    stencilCommand.renderState = RenderState.fromCache(renderState);\n\n    if (use2D) {\n      stencilDerivedComand.derivedCommand2D.renderState = renderState;\n    }\n  }\n}\n\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  const reference = stencilCommand.renderState.stencilTest.reference;\n  return (\n    (reference & StencilConstants.SKIP_LOD_MASK) >>>\n    StencilConstants.SKIP_LOD_BIT_SHIFT\n  );\n}\n\nfunction getStencilReference(selectionDepth) {\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted.\n  // Writes 0 for the terrain bit.\n  return (\n    StencilConstants.CESIUM_3D_TILE_MASK |\n    (selectionDepth << StencilConstants.SKIP_LOD_BIT_SHIFT)\n  );\n}\n\nfunction deriveSkipLodBackfaceCommand(command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles\n  // do not appear in front.\n  const backfaceCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  renderState.cull.enabled = true;\n  renderState.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  renderState.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0,\n  };\n\n  // The stencil test is set in TilesetPipelineStage.\n\n  const uniformMap = clone(backfaceCommand.uniformMap);\n  const polygonOffset = new Cartesian2(5.0, 5.0);\n\n  uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n\n  backfaceCommand.renderState = RenderState.fromCache(renderState);\n  backfaceCommand.uniformMap = uniformMap;\n  backfaceCommand.castShadows = false;\n  backfaceCommand.receiveShadows = false;\n\n  return backfaceCommand;\n}\n\nfunction deriveSkipLodStencilCommand(command) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  const stencilCommand = DrawCommand.shallowClone(command);\n  const renderState = clone(command.renderState, true);\n  // The stencil reference is updated dynamically; see updateSkipLodStencilCommand().\n  const { stencilTest } = renderState;\n  stencilTest.enabled = true;\n  stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  stencilTest.reference = StencilConstants.CESIUM_3D_TILE_MASK;\n  stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  renderState.stencilMask =\n    StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n\n  stencilCommand.renderState = RenderState.fromCache(renderState);\n\n  return stencilCommand;\n}\n\nexport default ModelDrawCommand;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}