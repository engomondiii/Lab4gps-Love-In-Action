{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst createGeometryFromPositionsPositions = [];\nconst createGeometryFromPositionsSubdivided = [];\nfunction createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n  let subdividedPositions;\n  let i;\n  let length = positions.length;\n  let index = 0;\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3);\n    for (i = 0; i < length; i++) {\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n    for (i = 0; i < length; i++) {\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n  length = subdividedPositions.length / 3;\n  const indicesSize = length * 2;\n  const indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions\n        })\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES\n    })\n  });\n}\nfunction createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n  let subdividedPositions;\n  let i;\n  let length = positions.length;\n  const corners = new Array(length);\n  let index = 0;\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n  length = subdividedPositions.length / (3 * 2);\n  const cornersLength = corners.length;\n  const indicesSize = (length * 2 + cornersLength) * 2;\n  const indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);\n  index = 0;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = (i + 1) % length + length;\n  }\n  for (i = 0; i < cornersLength; i++) {\n    const corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions\n        })\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES\n    })\n  });\n}\n\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\"Cannot use both options.perPositionHeight and options.height\");\n  }\n  if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\");\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy, Cartesian3) + Ellipsoid.packedLength + 8;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex, Cartesian3);\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex] = value.packedLength;\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst dummyOptions = {\n  polygonHierarchy: {}\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex, Cartesian3);\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const offsetAttribute = array[startingIndex++];\n  const packedLength = array[startingIndex];\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n  return result;\n};\n\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {number} [options.height=0.0] The height of the polygon.\n * @param {number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const arcType = polygonGeometry._arcType;\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);\n  if (polygons.length === 0) {\n    return undefined;\n  }\n  let geometryInstance;\n  const geometries = [];\n  const minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  let offsetValue;\n  let i;\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n      geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const size = geometryInstance.geometry.attributes.position.values.length / 3;\n        let offsetAttribute = new Uint8Array(size);\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n        } else {\n          offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n          offsetAttribute = offsetAttribute.fill(offsetValue);\n        }\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1,\n          values: offsetAttribute\n        });\n      }\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length = geometryInstance.geometry.attributes.position.values.length;\n        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1,\n          values: applyOffset\n        });\n      }\n      geometries.push(geometryInstance);\n    }\n  }\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute\n  });\n};\nexport default PolygonOutlineGeometry;","map":{"version":3,"names":["ArcType","BoundingSphere","Cartesian3","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidTangentPlane","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","PolygonGeometryLibrary","PolygonPipeline","PrimitiveType","WindingOrder","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","createGeometryFromPositions","ellipsoid","positions","minDistance","perPositionHeight","arcType","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","originalWindingOrder","computeWindingOrder2D","CLOCKWISE","reverse","slice","subdividedPositions","i","length","index","numVertices","GEODESIC","subdivideLineCount","RHUMB","subdivideRhumbLineCount","Float64Array","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","j","p0","p1","x","y","z","indicesSize","indices","createTypedArray","geometry","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","LINES","createGeometryFromPositionsExtruded","corners","Array","cornersLength","corner","PolygonOutlineGeometry","options","typeOf","object","polygonHierarchy","height","default","granularity","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","_ellipsoid","clone","_granularity","_height","_extrudedHeight","_arcType","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_offsetAttribute","offsetAttribute","_workerName","packedLength","computeHierarchyPackedLength","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","dummyOptions","unpack","result","unpackPolygonHierarchy","undefined","fromPositions","EMPTY_OBJECT","newOptions","createGeometry","polygonGeometry","polygons","polygonOutlinesFromHierarchy","geometryInstance","geometries","chordLength","maximumRadius","extrude","equalsEpsilon","EPSILON2","offsetValue","scaleToGeodeticHeightExtruded","size","Uint8Array","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","push","scaleToGeodeticHeight","combineInstances","boundingSphere","fromVertices"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/PolygonOutlineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst createGeometryFromPositionsPositions = [];\nconst createGeometryFromPositionsSubdivided = [];\n\nfunction createGeometryFromPositions(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType,\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions,\n  );\n\n  const originalWindingOrder =\n    PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3);\n    for (i = 0; i < length; i++) {\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n    for (i = 0; i < length; i++) {\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / 3;\n  const indicesSize = length * 2;\n  const indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType,\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions,\n  );\n\n  const originalWindingOrder =\n    PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  const corners = new Array(length);\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n        );\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided,\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / (3 * 2);\n  const cornersLength = corners.length;\n\n  const indicesSize = (length * 2 + cornersLength) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    length + cornersLength,\n    indicesSize,\n  );\n\n  index = 0;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  for (i = 0; i < cornersLength; i++) {\n    const corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\",\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) +\n    Ellipsoid.packedLength +\n    8;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const offsetAttribute = array[startingIndex++];\n  const packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {number} [options.height=0.0] The height of the polygon.\n * @param {number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute,\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const arcType = polygonGeometry._arcType;\n\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    !perPositionHeight,\n    ellipsoid,\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  let geometryInstance;\n  const geometries = [];\n  const minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius,\n  );\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  let offsetValue;\n  let i;\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType,\n      );\n      geometryInstance.geometry =\n        PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          geometryInstance.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight,\n        );\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const size =\n          geometryInstance.geometry.attributes.position.values.length / 3;\n        let offsetAttribute = new Uint8Array(size);\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n        } else {\n          offsetValue =\n            polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n              ? 0\n              : 1;\n          offsetAttribute = offsetAttribute.fill(offsetValue);\n        }\n\n        geometryInstance.geometry.attributes.applyOffset =\n          new GeometryAttribute({\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: offsetAttribute,\n          });\n      }\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType,\n      );\n      geometryInstance.geometry.attributes.position.values =\n        PolygonPipeline.scaleToGeodeticHeight(\n          geometryInstance.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight,\n        );\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n        geometryInstance.geometry.attributes.applyOffset =\n          new GeometryAttribute({\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromVertices(\n    geometry.attributes.position.values,\n  );\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\nexport default PolygonOutlineGeometry;\n"],"mappings":"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,GAAGC,MAAM;IAC7BmB,OAAO,CAAClB,KAAK,EAAE,CAAC,GAAI,CAACF,CAAC,GAAG,CAAC,IAAIC,MAAM,GAAIA,MAAM;EAChD;EAEA,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,aAAa,EAAElC,CAAC,EAAE,EAAE;IAClC,MAAMmC,MAAM,GAAGH,OAAO,CAAChC,CAAC,CAAC;IACzBoB,OAAO,CAAClB,KAAK,EAAE,CAAC,GAAGiC,MAAM;IACzBf,OAAO,CAAClB,KAAK,EAAE,CAAC,GAAGiC,MAAM,GAAGlC,MAAM;EACpC;EAEA,OAAO,IAAI5B,gBAAgB,CAAC;IAC1BiD,QAAQ,EAAE,IAAIpD,QAAQ,CAAC;MACrBqD,UAAU,EAAE,IAAInD,kBAAkB,CAAC;QACjCoD,QAAQ,EAAE,IAAIrD,iBAAiB,CAAC;UAC9BsD,iBAAiB,EAAE7D,iBAAiB,CAAC8D,MAAM;UAC3CC,sBAAsB,EAAE,CAAC;UACzBC,MAAM,EAAE7B;QACV,CAAC;MACH,CAAC,CAAC;MACFqB,OAAO,EAAEA,OAAO;MAChBS,aAAa,EAAEjD,aAAa,CAACkD;IAC/B,CAAC;EACH,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,sBAAsBA,CAACC,OAAO,EAAE;EACvC;EACA1E,KAAK,CAAC2E,MAAM,CAACC,MAAM,CAAC,SAAS,EAAEF,OAAO,CAAC;EACvC1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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}