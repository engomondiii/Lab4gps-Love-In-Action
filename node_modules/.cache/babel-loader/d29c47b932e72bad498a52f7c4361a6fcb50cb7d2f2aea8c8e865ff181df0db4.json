{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\nconst scratchDiagonalCartesianNE = new Cartesian3();\nconst scratchDiagonalCartesianSW = new Cartesian3();\nconst scratchDiagonalCartographic = new Cartographic();\nconst scratchCenterCartesian = new Cartesian3();\nconst scratchSurfaceCartesian = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\nconst tilingScheme = new GeographicTilingScheme();\nconst scratchCorners = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\nconst scratchTileXY = new Cartesian2();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nconst ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise<void>}\n */\nApproximateTerrainHeights.initialize = function () {\n  let initPromise = ApproximateTerrainHeights._initPromise;\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n  initPromise = Resource.fetchJson(buildModuleUrl(\"Assets/approximateTerrainHeights.json\")).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid\n * @return {{minimumTerrainHeight: number, maximumTerrainHeight: number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\");\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle, scratchDiagonalCartographic), scratchDiagonalCartesianNE);\n    ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle, scratchDiagonalCartographic), scratchDiagonalCartesianSW);\n    Cartesian3.midpoint(scratchDiagonalCartesianSW, scratchDiagonalCartesianNE, scratchCenterCartesian);\n    const surfacePosition = ellipsoid.scaleToGeodeticSurface(scratchCenterCartesian, scratchSurfaceCartesian);\n    if (defined(surfacePosition)) {\n      const distance = Cartesian3.distance(scratchCenterCartesian, surfacePosition);\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n  minTerrainHeight = Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight, minTerrainHeight);\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\");\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n  const result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(rectangle, ellipsoid, maxTerrainHeight, scratchBoundingSphere);\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(rectangle.east, rectangle.north, 0.0, scratchCorners[0]);\n  Cartographic.fromRadians(rectangle.west, rectangle.north, 0.0, scratchCorners[1]);\n  Cartographic.fromRadians(rectangle.east, rectangle.south, 0.0, scratchCorners[2]);\n  Cartographic.fromRadians(rectangle.west, rectangle.south, 0.0, scratchCorners[3]);\n\n  // Determine which tile the bounding rectangle is in\n  let lastLevelX = 0,\n    lastLevelY = 0;\n  let currentX = 0,\n    currentY = 0;\n  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  let i;\n  for (i = 0; i <= maxLevel; ++i) {\n    let failed = false;\n    for (let j = 0; j < 4; ++j) {\n      const corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n    if (failed) {\n      break;\n    }\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n  if (i === 0) {\n    return undefined;\n  }\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1\n  };\n}\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    }\n  }\n});\nexport default ApproximateTerrainHeights;","map":{"version":3,"names":["BoundingSphere","buildModuleUrl","Cartesian2","Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","Ellipsoid","GeographicTilingScheme","Rectangle","Resource","scratchDiagonalCartesianNE","scratchDiagonalCartesianSW","scratchDiagonalCartographic","scratchCenterCartesian","scratchSurfaceCartesian","scratchBoundingSphere","tilingScheme","scratchCorners","scratchTileXY","ApproximateTerrainHeights","initialize","initPromise","_initPromise","fetchJson","then","json","_terrainHeights","getMinimumMaximumHeights","rectangle","ellipsoid","default","xyLevel","getTileXYLevel","minTerrainHeight","_defaultMinTerrainHeight","maxTerrainHeight","_defaultMaxTerrainHeight","key","level","x","y","heights","cartographicToCartesian","northeast","southwest","midpoint","surfacePosition","scaleToGeodeticSurface","distance","Math","min","max","minimumTerrainHeight","maximumTerrainHeight","getBoundingSphere","result","fromRectangle3D","union","fromRadians","east","north","west","south","lastLevelX","lastLevelY","currentX","currentY","maxLevel","_terrainHeightsMaxLevel","i","failed","j","corner","positionToTileXY","undefined","Object","defineProperties","initialized","get"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/ApproximateTerrainHeights.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\nconst scratchDiagonalCartesianNE = new Cartesian3();\nconst scratchDiagonalCartesianSW = new Cartesian3();\nconst scratchDiagonalCartographic = new Cartographic();\nconst scratchCenterCartesian = new Cartesian3();\nconst scratchSurfaceCartesian = new Cartesian3();\n\nconst scratchBoundingSphere = new BoundingSphere();\nconst tilingScheme = new GeographicTilingScheme();\nconst scratchCorners = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nconst scratchTileXY = new Cartesian2();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nconst ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise<void>}\n */\nApproximateTerrainHeights.initialize = function () {\n  let initPromise = ApproximateTerrainHeights._initPromise;\n  if (defined(initPromise)) {\n    return initPromise;\n  }\n  initPromise = Resource.fetchJson(\n    buildModuleUrl(\"Assets/approximateTerrainHeights.json\"),\n  ).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid\n * @return {{minimumTerrainHeight: number, maximumTerrainHeight: number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\n  rectangle,\n  ellipsoid,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\",\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  let minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(\n      Rectangle.northeast(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianNE,\n    );\n    ellipsoid.cartographicToCartesian(\n      Rectangle.southwest(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianSW,\n    );\n\n    Cartesian3.midpoint(\n      scratchDiagonalCartesianSW,\n      scratchDiagonalCartesianNE,\n      scratchCenterCartesian,\n    );\n    const surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      scratchCenterCartesian,\n      scratchSurfaceCartesian,\n    );\n    if (defined(surfacePosition)) {\n      const distance = Cartesian3.distance(\n        scratchCenterCartesian,\n        surfacePosition,\n      );\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    minTerrainHeight,\n  );\n\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight,\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  if (!defined(ApproximateTerrainHeights._terrainHeights)) {\n    throw new DeveloperError(\n      \"You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function\",\n    );\n  }\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  const xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  let maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if (defined(xyLevel)) {\n    const key = `${xyLevel.level}-${xyLevel.x}-${xyLevel.y}`;\n    const heights = ApproximateTerrainHeights._terrainHeights[key];\n    if (defined(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  const result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  BoundingSphere.fromRectangle3D(\n    rectangle,\n    ellipsoid,\n    maxTerrainHeight,\n    scratchBoundingSphere,\n  );\n\n  return BoundingSphere.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    0.0,\n    scratchCorners[0],\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    0.0,\n    scratchCorners[1],\n  );\n  Cartographic.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    0.0,\n    scratchCorners[2],\n  );\n  Cartographic.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    0.0,\n    scratchCorners[3],\n  );\n\n  // Determine which tile the bounding rectangle is in\n  let lastLevelX = 0,\n    lastLevelY = 0;\n  let currentX = 0,\n    currentY = 0;\n  const maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  let i;\n  for (i = 0; i <= maxLevel; ++i) {\n    let failed = false;\n    for (let j = 0; j < 4; ++j) {\n      const corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1,\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\n\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return defined(ApproximateTerrainHeights._terrainHeights);\n    },\n  },\n});\nexport default ApproximateTerrainHeights;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}