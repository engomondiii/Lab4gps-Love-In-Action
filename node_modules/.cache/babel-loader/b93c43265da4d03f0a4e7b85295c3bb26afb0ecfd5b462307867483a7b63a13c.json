{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport PointCloud from \"./PointCloud.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\nimport PointCloudShading from \"./PointCloudShading.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * Provides playback of time-dynamic point cloud data.\n * <p>\n * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.\n * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently\n * small or the clock is sufficiently slow then no frames will be skipped.\n * </p>\n *\n * @alias TimeDynamicPointCloud\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Clock} options.clock A {@link Clock} instance that is used when determining the value for the time dimension.\n * @param {TimeIntervalCollection} options.intervals A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.\n * @param {boolean} [options.show=true] Determines if the point cloud will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the point cloud.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the point cloud casts or receives shadows from light sources.\n * @param {number} [options.maximumMemoryUsage=256] The maximum amount of memory in MB that can be used by the point cloud.\n * @param {object} [options.shading] Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.\n * @param {Cesium3DTileStyle} [options.style] The style, defined using the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n */\nfunction TimeDynamicPointCloud(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.intervals\", options.intervals);\n  //>>includeEnd('debug');\n\n  /**\n   * Determines if the point cloud will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * A 4x4 transformation matrix that transforms the point cloud.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n\n  /**\n   * Determines whether the point cloud casts or receives shadows from light sources.\n   * <p>\n   * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.\n   * </p>\n   * <p>\n   * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.\n   * </p>\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.\n   * <p>\n   * Frames that are not being loaded or rendered are unloaded to enforce this.\n   * </p>\n   * <p>\n   * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.\n   * </p>\n   *\n   * @type {number}\n   * @default 256\n   *\n   * @see TimeDynamicPointCloud#totalMemoryUsageInBytes\n   */\n  this.maximumMemoryUsage = defaultValue(options.maximumMemoryUsage, 256);\n\n  /**\n   * Options for controlling point size based on geometric error and eye dome lighting.\n   * @type {PointCloudShading}\n   */\n  this.shading = new PointCloudShading(options.shading);\n\n  /**\n   * The style, defined using the\n   * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language},\n   * applied to each point in the point cloud.\n   * <p>\n   * Assign <code>undefined</code> to remove the style, which will restore the visual\n   * appearance of the point cloud to its default when no style was applied.\n   * </p>\n   *\n   * @type {Cesium3DTileStyle}\n   *\n   * @example\n   * pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n   */\n  this.style = options.style;\n\n  /**\n   * The event fired to indicate that a frame failed to load. A frame may fail to load if the\n   * request for its uri fails or processing fails due to invalid content.\n   * <p>\n   * If there are no event listeners, error messages will be logged to the console.\n   * </p>\n   * <p>\n   * The error object passed to the listener contains two properties:\n   * <ul>\n   * <li><code>uri</code>: the uri of the failed frame.</li>\n   * <li><code>message</code>: the error message.</li>\n   * </ul>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log(`An error occurred loading frame: ${error.uri}`);\n   *     console.log(`Error: ${error.message}`);\n   * });\n   */\n  this.frameFailed = new Event();\n\n  /**\n   * The event fired to indicate that a new frame was rendered.\n   * <p>\n   * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.\n   * </p>\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });\n   */\n  this.frameChanged = new Event();\n  this._clock = options.clock;\n  this._intervals = options.intervals;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Call setter\n  this._pointCloudEyeDomeLighting = new PointCloudEyeDomeLighting();\n  this._loadTimestamp = undefined;\n  this._clippingPlanesState = 0;\n  this._styleDirty = false;\n  this._pickId = undefined;\n  this._totalMemoryUsageInBytes = 0;\n  this._frames = [];\n  this._previousInterval = undefined;\n  this._nextInterval = undefined;\n  this._lastRenderedFrame = undefined;\n  this._clockMultiplier = 0.0;\n\n  // For calculating average load time of the last N frames\n  this._runningSum = 0.0;\n  this._runningLength = 0;\n  this._runningIndex = 0;\n  this._runningSamples = new Array(5).fill(0.0);\n  this._runningAverage = 0.0;\n}\nObject.defineProperties(TimeDynamicPointCloud.prototype, {\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  },\n  /**\n   * The total amount of GPU memory in bytes used by the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @see TimeDynamicPointCloud#maximumMemoryUsage\n   */\n  totalMemoryUsageInBytes: {\n    get: function () {\n      return this._totalMemoryUsageInBytes;\n    }\n  },\n  /**\n   * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      if (defined(this._lastRenderedFrame)) {\n        return this._lastRenderedFrame.pointCloud.boundingSphere;\n      }\n      return undefined;\n    }\n  }\n});\nfunction getFragmentShaderLoaded(fs) {\n  return `uniform vec4 czm_pickColor;\\n${fs}`;\n}\nfunction getUniformMapLoaded(stream) {\n  return function (uniformMap) {\n    return combine(uniformMap, {\n      czm_pickColor: function () {\n        return stream._pickId.color;\n      }\n    });\n  };\n}\nfunction getPickIdLoaded() {\n  return \"czm_pickColor\";\n}\n\n/**\n * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all\n * points to re-evaluate the style in the next frame.\n */\nTimeDynamicPointCloud.prototype.makeStyleDirty = function () {\n  this._styleDirty = true;\n};\n\n/**\n * Exposed for testing.\n *\n * @private\n */\nTimeDynamicPointCloud.prototype._getAverageLoadTime = function () {\n  if (this._runningLength === 0) {\n    // Before any frames have loaded make a best guess about the average load time\n    return 0.05;\n  }\n  return this._runningAverage;\n};\nconst scratchDate = new JulianDate();\nfunction getClockMultiplier(that) {\n  const clock = that._clock;\n  const isAnimating = clock.canAnimate && clock.shouldAnimate;\n  const multiplier = clock.multiplier;\n  return isAnimating ? multiplier : 0.0;\n}\nfunction getIntervalIndex(that, interval) {\n  return that._intervals.indexOf(interval.start);\n}\nfunction getNextInterval(that, currentInterval) {\n  const intervals = that._intervals;\n  const clock = that._clock;\n  const multiplier = getClockMultiplier(that);\n  if (multiplier === 0.0) {\n    return undefined;\n  }\n  const averageLoadTime = that._getAverageLoadTime();\n  const time = JulianDate.addSeconds(clock.currentTime, averageLoadTime * multiplier, scratchDate);\n  let index = intervals.indexOf(time);\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  if (index === currentIndex) {\n    if (multiplier >= 0) {\n      ++index;\n    } else {\n      --index;\n    }\n  }\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\nfunction getCurrentInterval(that) {\n  const intervals = that._intervals;\n  const clock = that._clock;\n  const time = clock.currentTime;\n  const index = intervals.indexOf(time);\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\nfunction reachedInterval(that, currentInterval, nextInterval) {\n  const multiplier = getClockMultiplier(that);\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  const nextIndex = getIntervalIndex(that, nextInterval);\n  if (multiplier >= 0) {\n    return currentIndex >= nextIndex;\n  }\n  return currentIndex <= nextIndex;\n}\nfunction handleFrameFailure(that, uri) {\n  return function (error) {\n    const message = defined(error.message) ? error.message : error.toString();\n    if (that.frameFailed.numberOfListeners > 0) {\n      that.frameFailed.raiseEvent({\n        uri: uri,\n        message: message\n      });\n    } else {\n      console.log(`A frame failed to load: ${uri}`);\n      console.log(`Error: ${message}`);\n    }\n  };\n}\nfunction requestFrame(that, interval, frameState) {\n  const index = getIntervalIndex(that, interval);\n  const frames = that._frames;\n  let frame = frames[index];\n  if (!defined(frame)) {\n    const transformArray = interval.data.transform;\n    const transform = defined(transformArray) ? Matrix4.fromArray(transformArray) : undefined;\n    const uri = interval.data.uri;\n    frame = {\n      pointCloud: undefined,\n      transform: transform,\n      timestamp: getTimestamp(),\n      sequential: true,\n      ready: false,\n      touchedFrameNumber: frameState.frameNumber,\n      uri: uri\n    };\n    frames[index] = frame;\n    Resource.fetchArrayBuffer({\n      url: uri\n    }).then(function (arrayBuffer) {\n      // PERFORMANCE_IDEA: share a memory pool, render states, shaders, and other resources among all\n      // frames. Each frame just needs an index/offset into the pool.\n      frame.pointCloud = new PointCloud({\n        arrayBuffer: arrayBuffer,\n        cull: true,\n        fragmentShaderLoaded: getFragmentShaderLoaded,\n        uniformMapLoaded: getUniformMapLoaded(that),\n        pickIdLoaded: getPickIdLoaded\n      });\n    }).catch(handleFrameFailure(that, uri));\n  }\n  return frame;\n}\nfunction updateAverageLoadTime(that, loadTime) {\n  that._runningSum += loadTime;\n  that._runningSum -= that._runningSamples[that._runningIndex];\n  that._runningSamples[that._runningIndex] = loadTime;\n  that._runningLength = Math.min(that._runningLength + 1, that._runningSamples.length);\n  that._runningIndex = (that._runningIndex + 1) % that._runningSamples.length;\n  that._runningAverage = that._runningSum / that._runningLength;\n}\nfunction prepareFrame(that, frame, updateState, frameState) {\n  if (frame.touchedFrameNumber < frameState.frameNumber - 1) {\n    // If this frame was not loaded in sequential updates then it can't be used it for calculating the average load time.\n    // For example: selecting a frame on the timeline, selecting another frame before the request finishes, then selecting this frame later.\n    frame.sequential = false;\n  }\n  const pointCloud = frame.pointCloud;\n  if (defined(pointCloud) && !frame.ready) {\n    // Call update to prepare renderer resources. Don't render anything yet.\n    const commandList = frameState.commandList;\n    const lengthBeforeUpdate = commandList.length;\n    renderFrame(that, frame, updateState, frameState);\n    if (pointCloud.ready) {\n      // Point cloud became ready this update\n      frame.ready = true;\n      that._totalMemoryUsageInBytes += pointCloud.geometryByteLength;\n      commandList.length = lengthBeforeUpdate; // Don't allow preparing frame to insert commands.\n      if (frame.sequential) {\n        // Update the values used to calculate average load time\n        const loadTime = (getTimestamp() - frame.timestamp) / 1000.0;\n        updateAverageLoadTime(that, loadTime);\n      }\n    }\n  }\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\nconst scratchModelMatrix = new Matrix4();\nfunction getGeometricError(that, pointCloud) {\n  const shading = that.shading;\n  if (defined(shading) && defined(shading.baseResolution)) {\n    return shading.baseResolution;\n  } else if (defined(pointCloud.boundingSphere)) {\n    return CesiumMath.cbrt(pointCloud.boundingSphere.volume() / pointCloud.pointsLength);\n  }\n  return 0.0;\n}\nfunction getMaximumAttenuation(that) {\n  const shading = that.shading;\n  if (defined(shading) && defined(shading.maximumAttenuation)) {\n    return shading.maximumAttenuation;\n  }\n\n  // Return a hardcoded maximum attenuation. For a tileset this would instead be the maximum screen space error.\n  return 10.0;\n}\nconst defaultShading = new PointCloudShading();\nfunction renderFrame(that, frame, updateState, frameState) {\n  const shading = defaultValue(that.shading, defaultShading);\n  const pointCloud = frame.pointCloud;\n  const transform = defaultValue(frame.transform, Matrix4.IDENTITY);\n  pointCloud.modelMatrix = Matrix4.multiplyTransformation(that.modelMatrix, transform, scratchModelMatrix);\n  pointCloud.style = that.style;\n  pointCloud.time = updateState.timeSinceLoad;\n  pointCloud.shadows = that.shadows;\n  pointCloud.clippingPlanes = that._clippingPlanes;\n  pointCloud.isClipped = updateState.isClipped;\n  pointCloud.attenuation = shading.attenuation;\n  pointCloud.backFaceCulling = shading.backFaceCulling;\n  pointCloud.normalShading = shading.normalShading;\n  pointCloud.geometricError = getGeometricError(that, pointCloud);\n  pointCloud.geometricErrorScale = shading.geometricErrorScale;\n  pointCloud.maximumAttenuation = getMaximumAttenuation(that);\n  try {\n    pointCloud.update(frameState);\n  } catch (error) {\n    handleFrameFailure(that, frame.uri)(error);\n  }\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\nfunction loadFrame(that, interval, updateState, frameState) {\n  const frame = requestFrame(that, interval, frameState);\n  prepareFrame(that, frame, updateState, frameState);\n}\nfunction getUnloadCondition(frameState) {\n  return function (frame) {\n    // Unload all frames that aren't currently being loaded or rendered\n    return frame.touchedFrameNumber < frameState.frameNumber;\n  };\n}\nfunction unloadFrames(that, unloadCondition) {\n  const frames = that._frames;\n  const length = frames.length;\n  for (let i = 0; i < length; ++i) {\n    const frame = frames[i];\n    if (defined(frame)) {\n      if (!defined(unloadCondition) || unloadCondition(frame)) {\n        const pointCloud = frame.pointCloud;\n        if (frame.ready) {\n          that._totalMemoryUsageInBytes -= pointCloud.geometryByteLength;\n        }\n        if (defined(pointCloud)) {\n          pointCloud.destroy();\n        }\n        if (frame === that._lastRenderedFrame) {\n          that._lastRenderedFrame = undefined;\n        }\n        frames[i] = undefined;\n      }\n    }\n  }\n}\nfunction getFrame(that, interval) {\n  const index = getIntervalIndex(that, interval);\n  const frame = that._frames[index];\n  if (defined(frame) && frame.ready) {\n    return frame;\n  }\n}\nfunction updateInterval(that, interval, frame, updateState, frameState) {\n  if (defined(frame)) {\n    if (frame.ready) {\n      return true;\n    }\n    loadFrame(that, interval, updateState, frameState);\n    return frame.ready;\n  }\n  return false;\n}\nfunction getNearestReadyInterval(that, previousInterval, currentInterval, updateState, frameState) {\n  let i;\n  let interval;\n  let frame;\n  const intervals = that._intervals;\n  const frames = that._frames;\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  const previousIndex = getIntervalIndex(that, previousInterval);\n  if (currentIndex >= previousIndex) {\n    // look backwards\n    for (i = currentIndex; i >= previousIndex; --i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  } else {\n    // look forwards\n    for (i = currentIndex; i <= previousIndex; ++i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  }\n\n  // If no intervals are ready return the previous interval\n  return previousInterval;\n}\nfunction setFramesDirty(that, clippingPlanesDirty, styleDirty) {\n  const frames = that._frames;\n  const framesLength = frames.length;\n  for (let i = 0; i < framesLength; ++i) {\n    const frame = frames[i];\n    if (defined(frame) && defined(frame.pointCloud)) {\n      frame.pointCloud.clippingPlanesDirty = clippingPlanesDirty;\n      frame.pointCloud.styleDirty = styleDirty;\n    }\n  }\n}\nconst updateState = {\n  timeSinceLoad: 0,\n  isClipped: false,\n  clippingPlanesDirty: false\n};\n\n/**\n * @private\n */\nTimeDynamicPointCloud.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n  if (!this.show) {\n    return;\n  }\n  if (!defined(this._pickId)) {\n    this._pickId = frameState.context.createPickId({\n      primitive: this\n    });\n  }\n  if (!defined(this._loadTimestamp)) {\n    this._loadTimestamp = JulianDate.clone(frameState.time);\n  }\n\n  // For styling\n  const timeSinceLoad = Math.max(JulianDate.secondsDifference(frameState.time, this._loadTimestamp) * 1000, 0.0);\n\n  // Update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  let clippingPlanesState = 0;\n  let clippingPlanesDirty = false;\n  const isClipped = defined(clippingPlanes) && clippingPlanes.enabled;\n  if (isClipped) {\n    clippingPlanes.update(frameState);\n    clippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n  if (this._clippingPlanesState !== clippingPlanesState) {\n    this._clippingPlanesState = clippingPlanesState;\n    clippingPlanesDirty = true;\n  }\n  const styleDirty = this._styleDirty;\n  this._styleDirty = false;\n  if (clippingPlanesDirty || styleDirty) {\n    setFramesDirty(this, clippingPlanesDirty, styleDirty);\n  }\n  updateState.timeSinceLoad = timeSinceLoad;\n  updateState.isClipped = isClipped;\n  const shading = this.shading;\n  const eyeDomeLighting = this._pointCloudEyeDomeLighting;\n  const commandList = frameState.commandList;\n  const lengthBeforeUpdate = commandList.length;\n  let previousInterval = this._previousInterval;\n  let nextInterval = this._nextInterval;\n  const currentInterval = getCurrentInterval(this);\n  if (!defined(currentInterval)) {\n    return;\n  }\n  let clockMultiplierChanged = false;\n  const clockMultiplier = getClockMultiplier(this);\n  const clockPaused = clockMultiplier === 0;\n  if (clockMultiplier !== this._clockMultiplier) {\n    clockMultiplierChanged = true;\n    this._clockMultiplier = clockMultiplier;\n  }\n  if (!defined(previousInterval) || clockPaused) {\n    previousInterval = currentInterval;\n  }\n  if (!defined(nextInterval) || clockMultiplierChanged || reachedInterval(this, currentInterval, nextInterval)) {\n    nextInterval = getNextInterval(this, currentInterval);\n  }\n  previousInterval = getNearestReadyInterval(this, previousInterval, currentInterval, updateState, frameState);\n  let frame = getFrame(this, previousInterval);\n  if (!defined(frame)) {\n    // The frame is not ready to render. This can happen when the simulation starts or when scrubbing the timeline\n    // to a frame that hasn't loaded yet. Just render the last rendered frame in its place until it finishes loading.\n    loadFrame(this, previousInterval, updateState, frameState);\n    frame = this._lastRenderedFrame;\n  }\n  if (defined(frame)) {\n    renderFrame(this, frame, updateState, frameState);\n  }\n  if (defined(nextInterval)) {\n    // Start loading the next frame\n    loadFrame(this, nextInterval, updateState, frameState);\n  }\n  const that = this;\n  if (defined(frame) && !defined(this._lastRenderedFrame)) {\n    frameState.afterRender.push(function () {\n      return true;\n    });\n  }\n  if (defined(frame) && frame !== this._lastRenderedFrame) {\n    if (that.frameChanged.numberOfListeners > 0) {\n      frameState.afterRender.push(function () {\n        that.frameChanged.raiseEvent(that);\n        return true;\n      });\n    }\n  }\n  this._previousInterval = previousInterval;\n  this._nextInterval = nextInterval;\n  this._lastRenderedFrame = frame;\n  const totalMemoryUsageInBytes = this._totalMemoryUsageInBytes;\n  const maximumMemoryUsageInBytes = this.maximumMemoryUsage * 1024 * 1024;\n  if (totalMemoryUsageInBytes > maximumMemoryUsageInBytes) {\n    unloadFrames(this, getUnloadCondition(frameState));\n  }\n  const lengthAfterUpdate = commandList.length;\n  const addedCommandsLength = lengthAfterUpdate - lengthBeforeUpdate;\n  if (defined(shading) && shading.attenuation && shading.eyeDomeLighting && addedCommandsLength > 0) {\n    eyeDomeLighting.update(frameState, lengthBeforeUpdate, shading, this.boundingSphere);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see TimeDynamicPointCloud#destroy\n */\nTimeDynamicPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * pointCloud = pointCloud && pointCloud.destroy();\n *\n * @see TimeDynamicPointCloud#isDestroyed\n */\nTimeDynamicPointCloud.prototype.destroy = function () {\n  unloadFrames(this);\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\nexport default TimeDynamicPointCloud;","map":{"version":3,"names":["Check","combine","defaultValue","defined","destroyObject","Event","getTimestamp","JulianDate","CesiumMath","Matrix4","Resource","ClippingPlaneCollection","PointCloud","PointCloudEyeDomeLighting","PointCloudShading","SceneMode","ShadowMode","TimeDynamicPointCloud","options","EMPTY_OBJECT","typeOf","object","clock","intervals","show","modelMatrix","clone","IDENTITY","shadows","ENABLED","maximumMemoryUsage","shading","style","frameFailed","frameChanged","_clock","_intervals","_clippingPlanes","undefined","clippingPlanes","_pointCloudEyeDomeLighting","_loadTimestamp","_clippingPlanesState","_styleDirty","_pickId","_totalMemoryUsageInBytes","_frames","_previousInterval","_nextInterval","_lastRenderedFrame","_clockMultiplier","_runningSum","_runningLength","_runningIndex","_runningSamples","Array","fill","_runningAverage","Object","defineProperties","prototype","get","set","value","setOwner","totalMemoryUsageInBytes","boundingSphere","pointCloud","getFragmentShaderLoaded","fs","getUniformMapLoaded","stream","uniformMap","czm_pickColor","color","getPickIdLoaded","makeStyleDirty","_getAverageLoadTime","scratchDate","getClockMultiplier","that","isAnimating","canAnimate","shouldAnimate","multiplier","getIntervalIndex","interval","indexOf","start","getNextInterval","currentInterval","averageLoadTime","time","addSeconds","currentTime","index","currentIndex","getCurrentInterval","reachedInterval","nextInterval","nextIndex","handleFrameFailure","uri","error","message","toString","numberOfListeners","raiseEvent","console","log","requestFrame","frameState","frames","frame","transformArray","data","transform","fromArray","timestamp","sequential","ready","touchedFrameNumber","frameNumber","fetchArrayBuffer","url","then","arrayBuffer","cull","fragmentShaderLoaded","uniformMapLoaded","pickIdLoaded","catch","updateAverageLoadTime","loadTime","Math","min","length","prepareFrame","updateState","commandList","lengthBeforeUpdate","renderFrame","geometryByteLength","scratchModelMatrix","getGeometricError","baseResolution","cbrt","volume","pointsLength","getMaximumAttenuation","maximumAttenuation","defaultShading","multiplyTransformation","timeSinceLoad","isClipped","attenuation","backFaceCulling","normalShading","geometricError","geometricErrorScale","update","loadFrame","getUnloadCondition","unloadFrames","unloadCondition","i","destroy","getFrame","updateInterval","getNearestReadyInterval","previousInterval","previousIndex","setFramesDirty","clippingPlanesDirty","styleDirty","framesLength","mode","MORPHING","context","createPickId","primitive","max","secondsDifference","clippingPlanesState","enabled","eyeDomeLighting","clockMultiplierChanged","clockMultiplier","clockPaused","afterRender","push","maximumMemoryUsageInBytes","lengthAfterUpdate","addedCommandsLength","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TimeDynamicPointCloud.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport PointCloud from \"./PointCloud.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\nimport PointCloudShading from \"./PointCloudShading.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * Provides playback of time-dynamic point cloud data.\n * <p>\n * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.\n * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently\n * small or the clock is sufficiently slow then no frames will be skipped.\n * </p>\n *\n * @alias TimeDynamicPointCloud\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Clock} options.clock A {@link Clock} instance that is used when determining the value for the time dimension.\n * @param {TimeIntervalCollection} options.intervals A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.\n * @param {boolean} [options.show=true] Determines if the point cloud will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the point cloud.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the point cloud casts or receives shadows from light sources.\n * @param {number} [options.maximumMemoryUsage=256] The maximum amount of memory in MB that can be used by the point cloud.\n * @param {object} [options.shading] Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.\n * @param {Cesium3DTileStyle} [options.style] The style, defined using the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n */\nfunction TimeDynamicPointCloud(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.intervals\", options.intervals);\n  //>>includeEnd('debug');\n\n  /**\n   * Determines if the point cloud will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * A 4x4 transformation matrix that transforms the point cloud.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n\n  /**\n   * Determines whether the point cloud casts or receives shadows from light sources.\n   * <p>\n   * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.\n   * </p>\n   * <p>\n   * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.\n   * </p>\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.\n   * <p>\n   * Frames that are not being loaded or rendered are unloaded to enforce this.\n   * </p>\n   * <p>\n   * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.\n   * </p>\n   *\n   * @type {number}\n   * @default 256\n   *\n   * @see TimeDynamicPointCloud#totalMemoryUsageInBytes\n   */\n  this.maximumMemoryUsage = defaultValue(options.maximumMemoryUsage, 256);\n\n  /**\n   * Options for controlling point size based on geometric error and eye dome lighting.\n   * @type {PointCloudShading}\n   */\n  this.shading = new PointCloudShading(options.shading);\n\n  /**\n   * The style, defined using the\n   * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language},\n   * applied to each point in the point cloud.\n   * <p>\n   * Assign <code>undefined</code> to remove the style, which will restore the visual\n   * appearance of the point cloud to its default when no style was applied.\n   * </p>\n   *\n   * @type {Cesium3DTileStyle}\n   *\n   * @example\n   * pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n   */\n  this.style = options.style;\n\n  /**\n   * The event fired to indicate that a frame failed to load. A frame may fail to load if the\n   * request for its uri fails or processing fails due to invalid content.\n   * <p>\n   * If there are no event listeners, error messages will be logged to the console.\n   * </p>\n   * <p>\n   * The error object passed to the listener contains two properties:\n   * <ul>\n   * <li><code>uri</code>: the uri of the failed frame.</li>\n   * <li><code>message</code>: the error message.</li>\n   * </ul>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log(`An error occurred loading frame: ${error.uri}`);\n   *     console.log(`Error: ${error.message}`);\n   * });\n   */\n  this.frameFailed = new Event();\n\n  /**\n   * The event fired to indicate that a new frame was rendered.\n   * <p>\n   * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.\n   * </p>\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });\n   */\n  this.frameChanged = new Event();\n\n  this._clock = options.clock;\n  this._intervals = options.intervals;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Call setter\n  this._pointCloudEyeDomeLighting = new PointCloudEyeDomeLighting();\n  this._loadTimestamp = undefined;\n  this._clippingPlanesState = 0;\n  this._styleDirty = false;\n  this._pickId = undefined;\n  this._totalMemoryUsageInBytes = 0;\n  this._frames = [];\n  this._previousInterval = undefined;\n  this._nextInterval = undefined;\n  this._lastRenderedFrame = undefined;\n  this._clockMultiplier = 0.0;\n\n  // For calculating average load time of the last N frames\n  this._runningSum = 0.0;\n  this._runningLength = 0;\n  this._runningIndex = 0;\n  this._runningSamples = new Array(5).fill(0.0);\n  this._runningAverage = 0.0;\n}\n\nObject.defineProperties(TimeDynamicPointCloud.prototype, {\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * The total amount of GPU memory in bytes used by the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @see TimeDynamicPointCloud#maximumMemoryUsage\n   */\n  totalMemoryUsageInBytes: {\n    get: function () {\n      return this._totalMemoryUsageInBytes;\n    },\n  },\n\n  /**\n   * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      if (defined(this._lastRenderedFrame)) {\n        return this._lastRenderedFrame.pointCloud.boundingSphere;\n      }\n      return undefined;\n    },\n  },\n});\n\nfunction getFragmentShaderLoaded(fs) {\n  return `uniform vec4 czm_pickColor;\\n${fs}`;\n}\n\nfunction getUniformMapLoaded(stream) {\n  return function (uniformMap) {\n    return combine(uniformMap, {\n      czm_pickColor: function () {\n        return stream._pickId.color;\n      },\n    });\n  };\n}\n\nfunction getPickIdLoaded() {\n  return \"czm_pickColor\";\n}\n\n/**\n * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all\n * points to re-evaluate the style in the next frame.\n */\nTimeDynamicPointCloud.prototype.makeStyleDirty = function () {\n  this._styleDirty = true;\n};\n\n/**\n * Exposed for testing.\n *\n * @private\n */\nTimeDynamicPointCloud.prototype._getAverageLoadTime = function () {\n  if (this._runningLength === 0) {\n    // Before any frames have loaded make a best guess about the average load time\n    return 0.05;\n  }\n  return this._runningAverage;\n};\n\nconst scratchDate = new JulianDate();\n\nfunction getClockMultiplier(that) {\n  const clock = that._clock;\n  const isAnimating = clock.canAnimate && clock.shouldAnimate;\n  const multiplier = clock.multiplier;\n  return isAnimating ? multiplier : 0.0;\n}\n\nfunction getIntervalIndex(that, interval) {\n  return that._intervals.indexOf(interval.start);\n}\n\nfunction getNextInterval(that, currentInterval) {\n  const intervals = that._intervals;\n  const clock = that._clock;\n  const multiplier = getClockMultiplier(that);\n\n  if (multiplier === 0.0) {\n    return undefined;\n  }\n\n  const averageLoadTime = that._getAverageLoadTime();\n  const time = JulianDate.addSeconds(\n    clock.currentTime,\n    averageLoadTime * multiplier,\n    scratchDate,\n  );\n  let index = intervals.indexOf(time);\n\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  if (index === currentIndex) {\n    if (multiplier >= 0) {\n      ++index;\n    } else {\n      --index;\n    }\n  }\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\n\nfunction getCurrentInterval(that) {\n  const intervals = that._intervals;\n  const clock = that._clock;\n  const time = clock.currentTime;\n  const index = intervals.indexOf(time);\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\n\nfunction reachedInterval(that, currentInterval, nextInterval) {\n  const multiplier = getClockMultiplier(that);\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  const nextIndex = getIntervalIndex(that, nextInterval);\n\n  if (multiplier >= 0) {\n    return currentIndex >= nextIndex;\n  }\n  return currentIndex <= nextIndex;\n}\n\nfunction handleFrameFailure(that, uri) {\n  return function (error) {\n    const message = defined(error.message) ? error.message : error.toString();\n    if (that.frameFailed.numberOfListeners > 0) {\n      that.frameFailed.raiseEvent({\n        uri: uri,\n        message: message,\n      });\n    } else {\n      console.log(`A frame failed to load: ${uri}`);\n      console.log(`Error: ${message}`);\n    }\n  };\n}\n\nfunction requestFrame(that, interval, frameState) {\n  const index = getIntervalIndex(that, interval);\n  const frames = that._frames;\n  let frame = frames[index];\n  if (!defined(frame)) {\n    const transformArray = interval.data.transform;\n    const transform = defined(transformArray)\n      ? Matrix4.fromArray(transformArray)\n      : undefined;\n    const uri = interval.data.uri;\n    frame = {\n      pointCloud: undefined,\n      transform: transform,\n      timestamp: getTimestamp(),\n      sequential: true,\n      ready: false,\n      touchedFrameNumber: frameState.frameNumber,\n      uri: uri,\n    };\n    frames[index] = frame;\n    Resource.fetchArrayBuffer({\n      url: uri,\n    })\n      .then(function (arrayBuffer) {\n        // PERFORMANCE_IDEA: share a memory pool, render states, shaders, and other resources among all\n        // frames. Each frame just needs an index/offset into the pool.\n        frame.pointCloud = new PointCloud({\n          arrayBuffer: arrayBuffer,\n          cull: true,\n          fragmentShaderLoaded: getFragmentShaderLoaded,\n          uniformMapLoaded: getUniformMapLoaded(that),\n          pickIdLoaded: getPickIdLoaded,\n        });\n      })\n      .catch(handleFrameFailure(that, uri));\n  }\n  return frame;\n}\n\nfunction updateAverageLoadTime(that, loadTime) {\n  that._runningSum += loadTime;\n  that._runningSum -= that._runningSamples[that._runningIndex];\n  that._runningSamples[that._runningIndex] = loadTime;\n  that._runningLength = Math.min(\n    that._runningLength + 1,\n    that._runningSamples.length,\n  );\n  that._runningIndex = (that._runningIndex + 1) % that._runningSamples.length;\n  that._runningAverage = that._runningSum / that._runningLength;\n}\n\nfunction prepareFrame(that, frame, updateState, frameState) {\n  if (frame.touchedFrameNumber < frameState.frameNumber - 1) {\n    // If this frame was not loaded in sequential updates then it can't be used it for calculating the average load time.\n    // For example: selecting a frame on the timeline, selecting another frame before the request finishes, then selecting this frame later.\n    frame.sequential = false;\n  }\n\n  const pointCloud = frame.pointCloud;\n\n  if (defined(pointCloud) && !frame.ready) {\n    // Call update to prepare renderer resources. Don't render anything yet.\n    const commandList = frameState.commandList;\n    const lengthBeforeUpdate = commandList.length;\n    renderFrame(that, frame, updateState, frameState);\n\n    if (pointCloud.ready) {\n      // Point cloud became ready this update\n      frame.ready = true;\n      that._totalMemoryUsageInBytes += pointCloud.geometryByteLength;\n      commandList.length = lengthBeforeUpdate; // Don't allow preparing frame to insert commands.\n      if (frame.sequential) {\n        // Update the values used to calculate average load time\n        const loadTime = (getTimestamp() - frame.timestamp) / 1000.0;\n        updateAverageLoadTime(that, loadTime);\n      }\n    }\n  }\n\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nconst scratchModelMatrix = new Matrix4();\n\nfunction getGeometricError(that, pointCloud) {\n  const shading = that.shading;\n  if (defined(shading) && defined(shading.baseResolution)) {\n    return shading.baseResolution;\n  } else if (defined(pointCloud.boundingSphere)) {\n    return CesiumMath.cbrt(\n      pointCloud.boundingSphere.volume() / pointCloud.pointsLength,\n    );\n  }\n  return 0.0;\n}\n\nfunction getMaximumAttenuation(that) {\n  const shading = that.shading;\n  if (defined(shading) && defined(shading.maximumAttenuation)) {\n    return shading.maximumAttenuation;\n  }\n\n  // Return a hardcoded maximum attenuation. For a tileset this would instead be the maximum screen space error.\n  return 10.0;\n}\n\nconst defaultShading = new PointCloudShading();\n\nfunction renderFrame(that, frame, updateState, frameState) {\n  const shading = defaultValue(that.shading, defaultShading);\n  const pointCloud = frame.pointCloud;\n  const transform = defaultValue(frame.transform, Matrix4.IDENTITY);\n  pointCloud.modelMatrix = Matrix4.multiplyTransformation(\n    that.modelMatrix,\n    transform,\n    scratchModelMatrix,\n  );\n  pointCloud.style = that.style;\n  pointCloud.time = updateState.timeSinceLoad;\n  pointCloud.shadows = that.shadows;\n  pointCloud.clippingPlanes = that._clippingPlanes;\n  pointCloud.isClipped = updateState.isClipped;\n  pointCloud.attenuation = shading.attenuation;\n  pointCloud.backFaceCulling = shading.backFaceCulling;\n  pointCloud.normalShading = shading.normalShading;\n  pointCloud.geometricError = getGeometricError(that, pointCloud);\n  pointCloud.geometricErrorScale = shading.geometricErrorScale;\n  pointCloud.maximumAttenuation = getMaximumAttenuation(that);\n\n  try {\n    pointCloud.update(frameState);\n  } catch (error) {\n    handleFrameFailure(that, frame.uri)(error);\n  }\n\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nfunction loadFrame(that, interval, updateState, frameState) {\n  const frame = requestFrame(that, interval, frameState);\n  prepareFrame(that, frame, updateState, frameState);\n}\n\nfunction getUnloadCondition(frameState) {\n  return function (frame) {\n    // Unload all frames that aren't currently being loaded or rendered\n    return frame.touchedFrameNumber < frameState.frameNumber;\n  };\n}\n\nfunction unloadFrames(that, unloadCondition) {\n  const frames = that._frames;\n  const length = frames.length;\n  for (let i = 0; i < length; ++i) {\n    const frame = frames[i];\n    if (defined(frame)) {\n      if (!defined(unloadCondition) || unloadCondition(frame)) {\n        const pointCloud = frame.pointCloud;\n        if (frame.ready) {\n          that._totalMemoryUsageInBytes -= pointCloud.geometryByteLength;\n        }\n        if (defined(pointCloud)) {\n          pointCloud.destroy();\n        }\n        if (frame === that._lastRenderedFrame) {\n          that._lastRenderedFrame = undefined;\n        }\n        frames[i] = undefined;\n      }\n    }\n  }\n}\n\nfunction getFrame(that, interval) {\n  const index = getIntervalIndex(that, interval);\n  const frame = that._frames[index];\n  if (defined(frame) && frame.ready) {\n    return frame;\n  }\n}\n\nfunction updateInterval(that, interval, frame, updateState, frameState) {\n  if (defined(frame)) {\n    if (frame.ready) {\n      return true;\n    }\n    loadFrame(that, interval, updateState, frameState);\n    return frame.ready;\n  }\n  return false;\n}\n\nfunction getNearestReadyInterval(\n  that,\n  previousInterval,\n  currentInterval,\n  updateState,\n  frameState,\n) {\n  let i;\n  let interval;\n  let frame;\n  const intervals = that._intervals;\n  const frames = that._frames;\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  const previousIndex = getIntervalIndex(that, previousInterval);\n\n  if (currentIndex >= previousIndex) {\n    // look backwards\n    for (i = currentIndex; i >= previousIndex; --i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  } else {\n    // look forwards\n    for (i = currentIndex; i <= previousIndex; ++i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  }\n\n  // If no intervals are ready return the previous interval\n  return previousInterval;\n}\n\nfunction setFramesDirty(that, clippingPlanesDirty, styleDirty) {\n  const frames = that._frames;\n  const framesLength = frames.length;\n  for (let i = 0; i < framesLength; ++i) {\n    const frame = frames[i];\n    if (defined(frame) && defined(frame.pointCloud)) {\n      frame.pointCloud.clippingPlanesDirty = clippingPlanesDirty;\n      frame.pointCloud.styleDirty = styleDirty;\n    }\n  }\n}\n\nconst updateState = {\n  timeSinceLoad: 0,\n  isClipped: false,\n  clippingPlanesDirty: false,\n};\n\n/**\n * @private\n */\nTimeDynamicPointCloud.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (!defined(this._pickId)) {\n    this._pickId = frameState.context.createPickId({\n      primitive: this,\n    });\n  }\n\n  if (!defined(this._loadTimestamp)) {\n    this._loadTimestamp = JulianDate.clone(frameState.time);\n  }\n\n  // For styling\n  const timeSinceLoad = Math.max(\n    JulianDate.secondsDifference(frameState.time, this._loadTimestamp) * 1000,\n    0.0,\n  );\n\n  // Update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  let clippingPlanesState = 0;\n  let clippingPlanesDirty = false;\n  const isClipped = defined(clippingPlanes) && clippingPlanes.enabled;\n\n  if (isClipped) {\n    clippingPlanes.update(frameState);\n    clippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n\n  if (this._clippingPlanesState !== clippingPlanesState) {\n    this._clippingPlanesState = clippingPlanesState;\n    clippingPlanesDirty = true;\n  }\n\n  const styleDirty = this._styleDirty;\n  this._styleDirty = false;\n\n  if (clippingPlanesDirty || styleDirty) {\n    setFramesDirty(this, clippingPlanesDirty, styleDirty);\n  }\n\n  updateState.timeSinceLoad = timeSinceLoad;\n  updateState.isClipped = isClipped;\n\n  const shading = this.shading;\n  const eyeDomeLighting = this._pointCloudEyeDomeLighting;\n\n  const commandList = frameState.commandList;\n  const lengthBeforeUpdate = commandList.length;\n\n  let previousInterval = this._previousInterval;\n  let nextInterval = this._nextInterval;\n  const currentInterval = getCurrentInterval(this);\n\n  if (!defined(currentInterval)) {\n    return;\n  }\n\n  let clockMultiplierChanged = false;\n  const clockMultiplier = getClockMultiplier(this);\n  const clockPaused = clockMultiplier === 0;\n  if (clockMultiplier !== this._clockMultiplier) {\n    clockMultiplierChanged = true;\n    this._clockMultiplier = clockMultiplier;\n  }\n\n  if (!defined(previousInterval) || clockPaused) {\n    previousInterval = currentInterval;\n  }\n\n  if (\n    !defined(nextInterval) ||\n    clockMultiplierChanged ||\n    reachedInterval(this, currentInterval, nextInterval)\n  ) {\n    nextInterval = getNextInterval(this, currentInterval);\n  }\n\n  previousInterval = getNearestReadyInterval(\n    this,\n    previousInterval,\n    currentInterval,\n    updateState,\n    frameState,\n  );\n  let frame = getFrame(this, previousInterval);\n\n  if (!defined(frame)) {\n    // The frame is not ready to render. This can happen when the simulation starts or when scrubbing the timeline\n    // to a frame that hasn't loaded yet. Just render the last rendered frame in its place until it finishes loading.\n    loadFrame(this, previousInterval, updateState, frameState);\n    frame = this._lastRenderedFrame;\n  }\n\n  if (defined(frame)) {\n    renderFrame(this, frame, updateState, frameState);\n  }\n\n  if (defined(nextInterval)) {\n    // Start loading the next frame\n    loadFrame(this, nextInterval, updateState, frameState);\n  }\n\n  const that = this;\n  if (defined(frame) && !defined(this._lastRenderedFrame)) {\n    frameState.afterRender.push(function () {\n      return true;\n    });\n  }\n\n  if (defined(frame) && frame !== this._lastRenderedFrame) {\n    if (that.frameChanged.numberOfListeners > 0) {\n      frameState.afterRender.push(function () {\n        that.frameChanged.raiseEvent(that);\n        return true;\n      });\n    }\n  }\n\n  this._previousInterval = previousInterval;\n  this._nextInterval = nextInterval;\n  this._lastRenderedFrame = frame;\n\n  const totalMemoryUsageInBytes = this._totalMemoryUsageInBytes;\n  const maximumMemoryUsageInBytes = this.maximumMemoryUsage * 1024 * 1024;\n\n  if (totalMemoryUsageInBytes > maximumMemoryUsageInBytes) {\n    unloadFrames(this, getUnloadCondition(frameState));\n  }\n\n  const lengthAfterUpdate = commandList.length;\n  const addedCommandsLength = lengthAfterUpdate - lengthBeforeUpdate;\n\n  if (\n    defined(shading) &&\n    shading.attenuation &&\n    shading.eyeDomeLighting &&\n    addedCommandsLength > 0\n  ) {\n    eyeDomeLighting.update(\n      frameState,\n      lengthBeforeUpdate,\n      shading,\n      this.boundingSphere,\n    );\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see TimeDynamicPointCloud#destroy\n */\nTimeDynamicPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * pointCloud = pointCloud && pointCloud.destroy();\n *\n * @see TimeDynamicPointCloud#isDestroyed\n */\nTimeDynamicPointCloud.prototype.destroy = function () {\n  unloadFrames(this);\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\nexport default TimeDynamicPointCloud;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,uBAAuB,MAAM,8BAA8B;AAClE,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,yBAAyB,MAAM,gCAAgC;AACtE,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,UAAU,MAAM,iBAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAACC,OAAO,EAAE;EACtCA,OAAO,GAAGhB,YAAY,CAACgB,OAAO,EAAEhB,YAAY,CAACiB,YAAY,CAAC;;EAE1D;EACAnB,KAAK,CAACoB,MAAM,CAACC,MAAM,CAAC,eAAe,EAAEH,OAAO,CAACI,KAAK,CAAC;EACnDtB,KAAK,CAACoB,MAAM,CAACC,MAAM,CAAC,mBAAmB,EAAEH,OAAO,CAACK,SAAS,CAAC;EAC3D;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAGtB,YAAY,CAACgB,OAAO,CAACM,IAAI,EAAE,IAAI,CAAC;;EAE5C;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAGhB,OAAO,CAACiB,KAAK,CAC9BxB,YAAY,CAACgB,OAAO,CAACO,WAAW,EAAEhB,OAAO,CAACkB,QAAQ,CACpD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAG1B,YAAY,CAACgB,OAAO,CAACU,OAAO,EAAEZ,UAAU,CAACa,OAAO,CAAC;;EAEhE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAG5B,YAAY,CAACgB,OAAO,CAACY,kBAAkB,EAAE,GAAG,CAAC;;EAEvE;AACF;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAG,IAAIjB,iBAAiB,CAACI,OAAO,CAACa,OAAO,CAAC;;EAErD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAGd,OAAO,CAACc,KAAK;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI5B,KAAK,CAAC,CAAC;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC6B,YAAY,GAAG,IAAI7B,KAAK,CAAC,CAAC;EAE/B,IAAI,CAAC8B,MAAM,GAAGjB,OAAO,CAACI,KAAK;EAC3B,IAAI,CAACc,UAAU,GAAGlB,OAAO,CAACK,SAAS;EACnC,IAAI,CAACc,eAAe,GAAGC,SAAS;EAChC,IAAI,CAACC,cAAc,GAAGrB,OAAO,CAACqB,cAAc,CAAC,CAAC;EAC9C,IAAI,CAACC,0BAA0B,GAAG,IAAI3B,yBAAyB,CAAC,CAAC;EACjE,IAAI,CAAC4B,cAAc,GAAGH,SAAS;EAC/B,IAAI,CAACI,oBAAoB,GAAG,CAAC;EAC7B,IAAI,CAACC,WAAW,GAAG,KAAK;EACxB,IAAI,CAACC,OAAO,GAAGN,SAAS;EACxB,IAAI,CAACO,wBAAwB,GAAG,CAAC;EACjC,IAAI,CAACC,OAAO,GAAG,EAAE;EACjB,IAAI,CAACC,iBAAi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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}