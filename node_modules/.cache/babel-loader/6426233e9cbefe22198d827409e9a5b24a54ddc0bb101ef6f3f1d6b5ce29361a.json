{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useLocationInfo.js\nimport { useState, useEffect, useRef } from 'react';\nimport { debounce } from 'lodash';\nimport PropTypes from 'prop-types';\n\n/**\n * Custom hook to manage location information based on Cesium camera movements.\n *\n * @param {Cesium.Viewer} viewer - The Cesium Viewer instance.\n * @param {object} Cesium - The Cesium library.\n * @param {Function} reverseGeocode - Function to perform reverse geocoding.\n * @param {string} language - Language code ('en' for English, 'ko' for Korean).\n * @returns {Object} - Contains locationInfo, loading, and error states.\n */\nconst useLocationInfo = (viewer, Cesium, reverseGeocode, language = 'en') => {\n  _s();\n  // State to store location information\n  const [locationInfo, setLocationInfo] = useState(null);\n  // State to manage loading status\n  const [loading, setLoading] = useState(false);\n  // State to manage error messages\n  const [error, setError] = useState(null);\n  // Ref to store the debounced handler\n  const handleCameraMoveEnd = useRef(null);\n  useEffect(() => {\n    // If any of the required dependencies are missing, exit early\n    if (!viewer || !Cesium || !reverseGeocode) return;\n\n    /**\n     * Debounced function to handle camera movements.\n     * This prevents excessive API calls during rapid camera movements.\n     */\n    handleCameraMoveEnd.current = debounce(async () => {\n      setLoading(true); // Start loading\n      setError(null); // Reset any previous errors\n      const camera = viewer.camera;\n      const ellipsoid = viewer.scene.globe.ellipsoid;\n      try {\n        // Get the current camera position in cartesian coordinates\n        const cartesian = camera.positionWC;\n\n        // Convert cartesian coordinates to cartographic (longitude, latitude, height)\n        const cartographic = Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\n\n        // Convert radians to degrees and format to fixed decimal places\n        const longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);\n        const latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);\n        const height = cartographic.height.toFixed(2); // Height in meters\n\n        // Determine zoom level based on height\n        let zoomLevel;\n        if (height < 1000) {\n          zoomLevel = 'Very High';\n        } else if (height < 5000) {\n          zoomLevel = 'High';\n        } else if (height < 20000) {\n          zoomLevel = 'Medium';\n        } else {\n          zoomLevel = 'Low';\n        }\n\n        // Perform reverse geocoding to get the address in the desired language\n        const address = await reverseGeocode(latitude, longitude, language);\n\n        // Update the location information state\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address\n        });\n      } catch (err) {\n        // Handle any errors during the reverse geocoding process\n        console.error('Reverse geocoding failed:', err);\n        setError('Failed to fetch address');\n        setLocationInfo({\n          longitude: (locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.longitude) || 'Unknown',\n          latitude: (locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.latitude) || 'Unknown',\n          height: (locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.height) || 'Unknown',\n          zoomLevel: (locationInfo === null || locationInfo === void 0 ? void 0 : locationInfo.zoomLevel) || 'Unknown',\n          address: 'Unknown'\n        });\n      } finally {\n        setLoading(false); // Stop loading\n      }\n    }, 500); // 500ms debounce delay to optimize performance\n\n    // Attach the debounced handler to the camera's moveEnd event\n    viewer.camera.moveEnd.addEventListener(handleCameraMoveEnd.current);\n\n    // Trigger an initial fetch of location information\n    handleCameraMoveEnd.current();\n\n    // Cleanup function to remove event listeners and cancel debounced functions on unmount\n    return () => {\n      viewer.camera.moveEnd.removeEventListener(handleCameraMoveEnd.current);\n      handleCameraMoveEnd.current.cancel();\n    };\n  }, [viewer, Cesium, reverseGeocode, language]); // Re-run the effect if any dependencies change\n\n  // Return the location information, loading status, and any errors\n  return {\n    locationInfo,\n    loading,\n    error\n  };\n};\n\n// Define PropTypes for type checking and better maintainability\n_s(useLocationInfo, \"pjkE1rAieKkE75zQ/1wW42NMt+A=\");\nuseLocationInfo.propTypes = {\n  viewer: PropTypes.object.isRequired,\n  Cesium: PropTypes.object.isRequired,\n  reverseGeocode: PropTypes.func.isRequired,\n  language: PropTypes.string // Language code ('en' or 'ko')\n};\n\n// Define default props in case the language is not provided\nuseLocationInfo.defaultProps = {\n  language: 'en'\n};\nexport default useLocationInfo;","map":{"version":3,"names":["useState","useEffect","useRef","debounce","PropTypes","useLocationInfo","viewer","Cesium","reverseGeocode","language","_s","locationInfo","setLocationInfo","loading","setLoading","error","setError","handleCameraMoveEnd","current","camera","ellipsoid","scene","globe","cartesian","positionWC","cartographic","Cartographic","fromCartesian","longitude","Math","toDegrees","toFixed","latitude","height","zoomLevel","address","err","console","moveEnd","addEventListener","removeEventListener","cancel","propTypes","object","isRequired","func","string","defaultProps"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/src/components/hooks/useLocationInfo.js"],"sourcesContent":["// src/hooks/useLocationInfo.js\nimport { useState, useEffect, useRef } from 'react';\nimport { debounce } from 'lodash';\nimport PropTypes from 'prop-types';\n\n/**\n * Custom hook to manage location information based on Cesium camera movements.\n *\n * @param {Cesium.Viewer} viewer - The Cesium Viewer instance.\n * @param {object} Cesium - The Cesium library.\n * @param {Function} reverseGeocode - Function to perform reverse geocoding.\n * @param {string} language - Language code ('en' for English, 'ko' for Korean).\n * @returns {Object} - Contains locationInfo, loading, and error states.\n */\nconst useLocationInfo = (viewer, Cesium, reverseGeocode, language = 'en') => {\n  // State to store location information\n  const [locationInfo, setLocationInfo] = useState(null);\n  // State to manage loading status\n  const [loading, setLoading] = useState(false);\n  // State to manage error messages\n  const [error, setError] = useState(null);\n  // Ref to store the debounced handler\n  const handleCameraMoveEnd = useRef(null);\n\n  useEffect(() => {\n    // If any of the required dependencies are missing, exit early\n    if (!viewer || !Cesium || !reverseGeocode) return;\n\n    /**\n     * Debounced function to handle camera movements.\n     * This prevents excessive API calls during rapid camera movements.\n     */\n    handleCameraMoveEnd.current = debounce(async () => {\n      setLoading(true);   // Start loading\n      setError(null);     // Reset any previous errors\n      const camera = viewer.camera;\n      const ellipsoid = viewer.scene.globe.ellipsoid;\n\n      try {\n        // Get the current camera position in cartesian coordinates\n        const cartesian = camera.positionWC;\n\n        // Convert cartesian coordinates to cartographic (longitude, latitude, height)\n        const cartographic = Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\n\n        // Convert radians to degrees and format to fixed decimal places\n        const longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);\n        const latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);\n        const height = cartographic.height.toFixed(2); // Height in meters\n\n        // Determine zoom level based on height\n        let zoomLevel;\n        if (height < 1000) {\n          zoomLevel = 'Very High';\n        } else if (height < 5000) {\n          zoomLevel = 'High';\n        } else if (height < 20000) {\n          zoomLevel = 'Medium';\n        } else {\n          zoomLevel = 'Low';\n        }\n\n        // Perform reverse geocoding to get the address in the desired language\n        const address = await reverseGeocode(latitude, longitude, language);\n\n        // Update the location information state\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address,\n        });\n      } catch (err) {\n        // Handle any errors during the reverse geocoding process\n        console.error('Reverse geocoding failed:', err);\n        setError('Failed to fetch address');\n        setLocationInfo({\n          longitude: locationInfo?.longitude || 'Unknown',\n          latitude: locationInfo?.latitude || 'Unknown',\n          height: locationInfo?.height || 'Unknown',\n          zoomLevel: locationInfo?.zoomLevel || 'Unknown',\n          address: 'Unknown',\n        });\n      } finally {\n        setLoading(false); // Stop loading\n      }\n    }, 500); // 500ms debounce delay to optimize performance\n\n    // Attach the debounced handler to the camera's moveEnd event\n    viewer.camera.moveEnd.addEventListener(handleCameraMoveEnd.current);\n\n    // Trigger an initial fetch of location information\n    handleCameraMoveEnd.current();\n\n    // Cleanup function to remove event listeners and cancel debounced functions on unmount\n    return () => {\n      viewer.camera.moveEnd.removeEventListener(handleCameraMoveEnd.current);\n      handleCameraMoveEnd.current.cancel();\n    };\n  }, [viewer, Cesium, reverseGeocode, language]); // Re-run the effect if any dependencies change\n\n  // Return the location information, loading status, and any errors\n  return { locationInfo, loading, error };\n};\n\n// Define PropTypes for type checking and better maintainability\nuseLocationInfo.propTypes = {\n  viewer: PropTypes.object.isRequired,\n  Cesium: PropTypes.object.isRequired,\n  reverseGeocode: PropTypes.func.isRequired,\n  language: PropTypes.string, // Language code ('en' or 'ko')\n};\n\n// Define default props in case the language is not provided\nuseLocationInfo.defaultProps = {\n  language: 'en',\n};\n\nexport default useLocationInfo;\n"],"mappings":";AAAA;AACA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACnD,SAASC,QAAQ,QAAQ,QAAQ;AACjC,OAAOC,SAAS,MAAM,YAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAGA,CAACC,MAAM,EAAEC,MAAM,EAAEC,cAAc,EAAEC,QAAQ,GAAG,IAAI,KAAK;EAAAC,EAAA;EAC3E;EACA,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGZ,QAAQ,CAAC,IAAI,CAAC;EACtD;EACA,MAAM,CAACa,OAAO,EAAEC,UAAU,CAAC,GAAGd,QAAQ,CAAC,KAAK,CAAC;EAC7C;EACA,MAAM,CAACe,KAAK,EAAEC,QAAQ,CAAC,GAAGhB,QAAQ,CAAC,IAAI,CAAC;EACxC;EACA,MAAMiB,mBAAmB,GAAGf,MAAM,CAAC,IAAI,CAAC;EAExCD,SAAS,CAAC,MAAM;IACd;IACA,IAAI,CAACK,MAAM,IAAI,CAACC,MAAM,IAAI,CAACC,cAAc,EAAE;;IAE3C;AACJ;AACA;AACA;IACIS,mBAAmB,CAACC,OAAO,GAAGf,QAAQ,CAAC,YAAY;MACjDW,UAAU,CAAC,IAAI,CAAC,CAAC,CAAG;MACpBE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAK;MACpB,MAAMG,MAAM,GAAGb,MAAM,CAACa,MAAM;MAC5B,MAAMC,SAAS,GAAGd,MAAM,CAACe,KAAK,CAACC,KAAK,CAACF,SAAS;MAE9C,IAAI;QACF;QACA,MAAMG,SAAS,GAAGJ,MAAM,CAACK,UAAU;;QAEnC;QACA,MAAMC,YAAY,GAAGlB,MAAM,CAACmB,YAAY,CAACC,aAAa,CAACJ,SAAS,EAAEH,SAAS,CAAC;;QAE5E;QACA,MAAMQ,SAAS,GAAGrB,MAAM,CAACsB,IAAI,CAACC,SAAS,CAACL,YAAY,CAACG,SAAS,CAAC,CAACG,OAAO,CAAC,CAAC,CAAC;QAC1E,MAAMC,QAAQ,GAAGzB,MAAM,CAACsB,IAAI,CAACC,SAAS,CAACL,YAAY,CAACO,QAAQ,CAAC,CAACD,OAAO,CAAC,CAAC,CAAC;QACxE,MAAME,MAAM,GAAGR,YAAY,CAACQ,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;;QAE/C;QACA,IAAIG,SAAS;QACb,IAAID,MAAM,GAAG,IAAI,EAAE;UACjBC,SAAS,GAAG,WAAW;QACzB,CAAC,MAAM,IAAID,MAAM,GAAG,IAAI,EAAE;UACxBC,SAAS,GAAG,MAAM;QACpB,CAAC,MAAM,IAAID,MAAM,GAAG,KAAK,EAAE;UACzBC,SAAS,GAAG,QAAQ;QACtB,CAAC,MAAM;UACLA,SAAS,GAAG,KAAK;QACnB;;QAEA;QACA,MAAMC,OAAO,GAAG,MAAM3B,cAAc,CAACwB,QAAQ,EAAEJ,SAAS,EAAEnB,QAAQ,CAAC;;QAEnE;QACAG,eAAe,CAAC;UACdgB,SAAS;UACTI,QAAQ;UACRC,MAAM;UACNC,SAAS;UACTC;QACF,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOC,GAAG,EAAE;QACZ;QACAC,OAAO,CAACtB,KAAK,CAAC,2BAA2B,EAAEqB,GAAG,CAAC;QAC/CpB,QAAQ,CAAC,yBAAyB,CAAC;QACnCJ,eAAe,CAAC;UACdgB,SAAS,EAAE,CAAAjB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEiB,SAAS,KAAI,SAAS;UAC/CI,QAAQ,EAAE,CAAArB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEqB,QAAQ,KAAI,SAAS;UAC7CC,MAAM,EAAE,CAAAtB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEsB,MAAM,KAAI,SAAS;UACzCC,SAAS,EAAE,CAAAvB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEuB,SAAS,KAAI,SAAS;UAC/CC,OAAO,EAAE;QACX,CAAC,CAAC;MACJ,CAAC,SAAS;QACRrB,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;MACrB;IACF,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;;IAET;IACAR,MAAM,CAACa,MAAM,CAACmB,OAAO,CAACC,gBAAgB,CAACtB,mBAAmB,CAACC,OAAO,CAAC;;IAEnE;IACAD,mBAAmB,CAACC,OAAO,CAAC,CAAC;;IAE7B;IACA,OAAO,MAAM;MACXZ,MAAM,CAACa,MAAM,CAACmB,OAAO,CAACE,mBAAmB,CAACvB,mBAAmB,CAACC,OAAO,CAAC;MACtED,mBAAmB,CAACC,OAAO,CAACuB,MAAM,CAAC,CAAC;IACtC,CAAC;EACH,CAAC,EAAE,CAACnC,MAAM,EAAEC,MAAM,EAAEC,cAAc,EAAEC,QAAQ,CAAC,CAAC,CAAC,CAAC;;EAEhD;EACA,OAAO;IAAEE,YAAY;IAAEE,OAAO;IAAEE;EAAM,CAAC;AACzC,CAAC;;AAED;AAAAL,EAAA,CA5FML,eAAe;AA6FrBA,eAAe,CAACqC,SAAS,GAAG;EAC1BpC,MAAM,EAAEF,SAAS,CAACuC,MAAM,CAACC,UAAU;EACnCrC,MAAM,EAAEH,SAAS,CAACuC,MAAM,CAACC,UAAU;EACnCpC,cAAc,EAAEJ,SAAS,CAACyC,IAAI,CAACD,UAAU;EACzCnC,QAAQ,EAAEL,SAAS,CAAC0C,MAAM,CAAE;AAC9B,CAAC;;AAED;AACAzC,eAAe,CAAC0C,YAAY,GAAG;EAC7BtC,QAAQ,EAAE;AACZ,CAAC;AAED,eAAeJ,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}