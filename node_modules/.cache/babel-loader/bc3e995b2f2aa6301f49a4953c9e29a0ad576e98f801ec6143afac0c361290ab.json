{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ShaderProgram from \"./ShaderProgram.js\";\nimport ShaderSource from \"./ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShaderCache(context) {\n  this._context = context;\n  this._shaders = {};\n  this._numberOfShaders = 0;\n  this._shadersToRelease = {};\n}\nObject.defineProperties(ShaderCache.prototype, {\n  numberOfShaders: {\n    get: function () {\n      return this._numberOfShaders;\n    }\n  }\n});\n\n/**\n     * Returns a shader program from the cache, or creates and caches a new shader program,\n     * given the GLSL vertex and fragment shader source and attribute locations.\n     * <p>\n     * The difference between this and {@link ShaderCache#getShaderProgram}, is this is used to\n     * replace an existing reference to a shader program, which is passed as the first argument.\n     * </p>\n     *\n     * @param {object} options Object with the following properties:\n     * @param {ShaderProgram} [options.shaderProgram] The shader program that is being reassigned.\n     * @param {string|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n     * @param {string|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n     * @param {object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n\n     * @returns {ShaderProgram} The cached or newly created shader program.\n     *\n     *\n     * @example\n     * this._shaderProgram = context.shaderCache.replaceShaderProgram({\n     *     shaderProgram : this._shaderProgram,\n     *     vertexShaderSource : vs,\n     *     fragmentShaderSource : fs,\n     *     attributeLocations : attributeLocations\n     * });\n     *\n     * @see ShaderCache#getShaderProgram\n     */\nShaderCache.prototype.replaceShaderProgram = function (options) {\n  if (defined(options.shaderProgram)) {\n    options.shaderProgram.destroy();\n  }\n  return this.getShaderProgram(options);\n};\nfunction toSortedJson(dictionary) {\n  const sortedKeys = Object.keys(dictionary).sort();\n  return JSON.stringify(dictionary, sortedKeys);\n}\n\n/**\n * Returns a shader program from the cache, or creates and caches a new shader program,\n * given the GLSL vertex and fragment shader source and attribute locations.\n *\n * @param {object} options Object with the following properties:\n * @param {string|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n * @param {string|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n * @param {object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n *\n * @returns {ShaderProgram} The cached or newly created shader program.\n */\nShaderCache.prototype.getShaderProgram = function (options) {\n  // convert shaders which are provided as strings into ShaderSource objects\n  // because ShaderSource handles all the automatic including of built-in functions, etc.\n\n  let vertexShaderSource = options.vertexShaderSource;\n  let fragmentShaderSource = options.fragmentShaderSource;\n  const attributeLocations = options.attributeLocations;\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource]\n    });\n  }\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource]\n    });\n  }\n\n  // Since ShaderSource.createCombinedXxxShader() can be expensive, use a\n  // simpler key for caching. This way, the function does not have to be called\n  // for each cache lookup.\n  const vertexShaderKey = vertexShaderSource.getCacheKey();\n  const fragmentShaderKey = fragmentShaderSource.getCacheKey();\n  // Sort the keys in the JSON to ensure a consistent order\n  const attributeLocationKey = defined(attributeLocations) ? toSortedJson(attributeLocations) : \"\";\n  const keyword = `${vertexShaderKey}:${fragmentShaderKey}:${attributeLocationKey}`;\n  let cachedShader;\n  if (defined(this._shaders[keyword])) {\n    cachedShader = this._shaders[keyword];\n\n    // No longer want to release this if it was previously released.\n    delete this._shadersToRelease[keyword];\n  } else {\n    const context = this._context;\n    const vertexShaderText = vertexShaderSource.createCombinedVertexShader(context);\n    const fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(context);\n    const shaderProgram = new ShaderProgram({\n      gl: context._gl,\n      logShaderCompilation: context.logShaderCompilation,\n      debugShaders: context.debugShaders,\n      vertexShaderSource: vertexShaderSource,\n      vertexShaderText: vertexShaderText,\n      fragmentShaderSource: fragmentShaderSource,\n      fragmentShaderText: fragmentShaderText,\n      attributeLocations: attributeLocations\n    });\n    cachedShader = {\n      cache: this,\n      shaderProgram: shaderProgram,\n      keyword: keyword,\n      derivedKeywords: [],\n      count: 0\n    };\n\n    // A shader can't be in more than one cache.\n    shaderProgram._cachedShader = cachedShader;\n    this._shaders[keyword] = cachedShader;\n    ++this._numberOfShaders;\n  }\n  ++cachedShader.count;\n  return cachedShader.shaderProgram;\n};\nShaderCache.prototype.replaceDerivedShaderProgram = function (shaderProgram, keyword, options) {\n  const cachedShader = shaderProgram._cachedShader;\n  const derivedKeyword = keyword + cachedShader.keyword;\n  const cachedDerivedShader = this._shaders[derivedKeyword];\n  if (defined(cachedDerivedShader)) {\n    destroyShader(this, cachedDerivedShader);\n    const index = cachedShader.derivedKeywords.indexOf(keyword);\n    if (index > -1) {\n      cachedShader.derivedKeywords.splice(index, 1);\n    }\n  }\n  return this.createDerivedShaderProgram(shaderProgram, keyword, options);\n};\nShaderCache.prototype.getDerivedShaderProgram = function (shaderProgram, keyword) {\n  const cachedShader = shaderProgram._cachedShader;\n  const derivedKeyword = keyword + cachedShader.keyword;\n  const cachedDerivedShader = this._shaders[derivedKeyword];\n  if (!defined(cachedDerivedShader)) {\n    return undefined;\n  }\n  return cachedDerivedShader.shaderProgram;\n};\nShaderCache.prototype.createDerivedShaderProgram = function (shaderProgram, keyword, options) {\n  const cachedShader = shaderProgram._cachedShader;\n  const derivedKeyword = keyword + cachedShader.keyword;\n  let vertexShaderSource = options.vertexShaderSource;\n  let fragmentShaderSource = options.fragmentShaderSource;\n  const attributeLocations = options.attributeLocations;\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource]\n    });\n  }\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource]\n    });\n  }\n  const context = this._context;\n  const vertexShaderText = vertexShaderSource.createCombinedVertexShader(context);\n  const fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader(context);\n  const derivedShaderProgram = new ShaderProgram({\n    gl: context._gl,\n    logShaderCompilation: context.logShaderCompilation,\n    debugShaders: context.debugShaders,\n    vertexShaderSource: vertexShaderSource,\n    vertexShaderText: vertexShaderText,\n    fragmentShaderSource: fragmentShaderSource,\n    fragmentShaderText: fragmentShaderText,\n    attributeLocations: attributeLocations\n  });\n  const derivedCachedShader = {\n    cache: this,\n    shaderProgram: derivedShaderProgram,\n    keyword: derivedKeyword,\n    derivedKeywords: [],\n    count: 0\n  };\n  cachedShader.derivedKeywords.push(keyword);\n  derivedShaderProgram._cachedShader = derivedCachedShader;\n  this._shaders[derivedKeyword] = derivedCachedShader;\n  return derivedShaderProgram;\n};\nfunction destroyShader(cache, cachedShader) {\n  const derivedKeywords = cachedShader.derivedKeywords;\n  const length = derivedKeywords.length;\n  for (let i = 0; i < length; ++i) {\n    const keyword = derivedKeywords[i] + cachedShader.keyword;\n    const derivedCachedShader = cache._shaders[keyword];\n    destroyShader(cache, derivedCachedShader);\n  }\n  delete cache._shaders[cachedShader.keyword];\n  cachedShader.shaderProgram.finalDestroy();\n}\nShaderCache.prototype.destroyReleasedShaderPrograms = function () {\n  const shadersToRelease = this._shadersToRelease;\n  for (const keyword in shadersToRelease) {\n    if (shadersToRelease.hasOwnProperty(keyword)) {\n      const cachedShader = shadersToRelease[keyword];\n      destroyShader(this, cachedShader);\n      --this._numberOfShaders;\n    }\n  }\n  this._shadersToRelease = {};\n};\nShaderCache.prototype.releaseShaderProgram = function (shaderProgram) {\n  if (defined(shaderProgram)) {\n    const cachedShader = shaderProgram._cachedShader;\n    if (cachedShader && --cachedShader.count === 0) {\n      this._shadersToRelease[cachedShader.keyword] = cachedShader;\n    }\n  }\n};\nShaderCache.prototype.isDestroyed = function () {\n  return false;\n};\nShaderCache.prototype.destroy = function () {\n  const shaders = this._shaders;\n  for (const keyword in shaders) {\n    if (shaders.hasOwnProperty(keyword)) {\n      shaders[keyword].shaderProgram.finalDestroy();\n    }\n  }\n  return destroyObject(this);\n};\nexport default ShaderCache;","map":{"version":3,"names":["defined","destroyObject","ShaderProgram","ShaderSource","ShaderCache","context","_context","_shaders","_numberOfShaders","_shadersToRelease","Object","defineProperties","prototype","numberOfShaders","get","replaceShaderProgram","options","shaderProgram","destroy","getShaderProgram","toSortedJson","dictionary","sortedKeys","keys","sort","JSON","stringify","vertexShaderSource","fragmentShaderSource","attributeLocations","sources","vertexShaderKey","getCacheKey","fragmentShaderKey","attributeLocationKey","keyword","cachedShader","vertexShaderText","createCombinedVertexShader","fragmentShaderText","createCombinedFragmentShader","gl","_gl","logShaderCompilation","debugShaders","cache","derivedKeywords","count","_cachedShader","replaceDerivedShaderProgram","derivedKeyword","cachedDerivedShader","destroyShader","index","indexOf","splice","createDerivedShaderProgram","getDerivedShaderProgram","undefined","derivedShaderProgram","derivedCachedShader","push","length","i","finalDestroy","destroyReleasedShaderPrograms","shadersToRelease","hasOwnProperty","releaseShaderProgram","isDestroyed","shaders"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/ShaderCache.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ShaderProgram from \"./ShaderProgram.js\";\nimport ShaderSource from \"./ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShaderCache(context) {\n  this._context = context;\n  this._shaders = {};\n  this._numberOfShaders = 0;\n  this._shadersToRelease = {};\n}\n\nObject.defineProperties(ShaderCache.prototype, {\n  numberOfShaders: {\n    get: function () {\n      return this._numberOfShaders;\n    },\n  },\n});\n\n/**\n     * Returns a shader program from the cache, or creates and caches a new shader program,\n     * given the GLSL vertex and fragment shader source and attribute locations.\n     * <p>\n     * The difference between this and {@link ShaderCache#getShaderProgram}, is this is used to\n     * replace an existing reference to a shader program, which is passed as the first argument.\n     * </p>\n     *\n     * @param {object} options Object with the following properties:\n     * @param {ShaderProgram} [options.shaderProgram] The shader program that is being reassigned.\n     * @param {string|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n     * @param {string|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n     * @param {object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n\n     * @returns {ShaderProgram} The cached or newly created shader program.\n     *\n     *\n     * @example\n     * this._shaderProgram = context.shaderCache.replaceShaderProgram({\n     *     shaderProgram : this._shaderProgram,\n     *     vertexShaderSource : vs,\n     *     fragmentShaderSource : fs,\n     *     attributeLocations : attributeLocations\n     * });\n     *\n     * @see ShaderCache#getShaderProgram\n     */\nShaderCache.prototype.replaceShaderProgram = function (options) {\n  if (defined(options.shaderProgram)) {\n    options.shaderProgram.destroy();\n  }\n\n  return this.getShaderProgram(options);\n};\n\nfunction toSortedJson(dictionary) {\n  const sortedKeys = Object.keys(dictionary).sort();\n  return JSON.stringify(dictionary, sortedKeys);\n}\n\n/**\n * Returns a shader program from the cache, or creates and caches a new shader program,\n * given the GLSL vertex and fragment shader source and attribute locations.\n *\n * @param {object} options Object with the following properties:\n * @param {string|ShaderSource} options.vertexShaderSource The GLSL source for the vertex shader.\n * @param {string|ShaderSource} options.fragmentShaderSource The GLSL source for the fragment shader.\n * @param {object} options.attributeLocations Indices for the attribute inputs to the vertex shader.\n *\n * @returns {ShaderProgram} The cached or newly created shader program.\n */\nShaderCache.prototype.getShaderProgram = function (options) {\n  // convert shaders which are provided as strings into ShaderSource objects\n  // because ShaderSource handles all the automatic including of built-in functions, etc.\n\n  let vertexShaderSource = options.vertexShaderSource;\n  let fragmentShaderSource = options.fragmentShaderSource;\n  const attributeLocations = options.attributeLocations;\n\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource],\n    });\n  }\n\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource],\n    });\n  }\n\n  // Since ShaderSource.createCombinedXxxShader() can be expensive, use a\n  // simpler key for caching. This way, the function does not have to be called\n  // for each cache lookup.\n  const vertexShaderKey = vertexShaderSource.getCacheKey();\n  const fragmentShaderKey = fragmentShaderSource.getCacheKey();\n  // Sort the keys in the JSON to ensure a consistent order\n  const attributeLocationKey = defined(attributeLocations)\n    ? toSortedJson(attributeLocations)\n    : \"\";\n  const keyword = `${vertexShaderKey}:${fragmentShaderKey}:${attributeLocationKey}`;\n\n  let cachedShader;\n  if (defined(this._shaders[keyword])) {\n    cachedShader = this._shaders[keyword];\n\n    // No longer want to release this if it was previously released.\n    delete this._shadersToRelease[keyword];\n  } else {\n    const context = this._context;\n\n    const vertexShaderText =\n      vertexShaderSource.createCombinedVertexShader(context);\n    const fragmentShaderText =\n      fragmentShaderSource.createCombinedFragmentShader(context);\n\n    const shaderProgram = new ShaderProgram({\n      gl: context._gl,\n      logShaderCompilation: context.logShaderCompilation,\n      debugShaders: context.debugShaders,\n      vertexShaderSource: vertexShaderSource,\n      vertexShaderText: vertexShaderText,\n      fragmentShaderSource: fragmentShaderSource,\n      fragmentShaderText: fragmentShaderText,\n      attributeLocations: attributeLocations,\n    });\n\n    cachedShader = {\n      cache: this,\n      shaderProgram: shaderProgram,\n      keyword: keyword,\n      derivedKeywords: [],\n      count: 0,\n    };\n\n    // A shader can't be in more than one cache.\n    shaderProgram._cachedShader = cachedShader;\n    this._shaders[keyword] = cachedShader;\n    ++this._numberOfShaders;\n  }\n\n  ++cachedShader.count;\n  return cachedShader.shaderProgram;\n};\n\nShaderCache.prototype.replaceDerivedShaderProgram = function (\n  shaderProgram,\n  keyword,\n  options,\n) {\n  const cachedShader = shaderProgram._cachedShader;\n  const derivedKeyword = keyword + cachedShader.keyword;\n  const cachedDerivedShader = this._shaders[derivedKeyword];\n  if (defined(cachedDerivedShader)) {\n    destroyShader(this, cachedDerivedShader);\n    const index = cachedShader.derivedKeywords.indexOf(keyword);\n    if (index > -1) {\n      cachedShader.derivedKeywords.splice(index, 1);\n    }\n  }\n\n  return this.createDerivedShaderProgram(shaderProgram, keyword, options);\n};\n\nShaderCache.prototype.getDerivedShaderProgram = function (\n  shaderProgram,\n  keyword,\n) {\n  const cachedShader = shaderProgram._cachedShader;\n  const derivedKeyword = keyword + cachedShader.keyword;\n  const cachedDerivedShader = this._shaders[derivedKeyword];\n  if (!defined(cachedDerivedShader)) {\n    return undefined;\n  }\n\n  return cachedDerivedShader.shaderProgram;\n};\n\nShaderCache.prototype.createDerivedShaderProgram = function (\n  shaderProgram,\n  keyword,\n  options,\n) {\n  const cachedShader = shaderProgram._cachedShader;\n  const derivedKeyword = keyword + cachedShader.keyword;\n\n  let vertexShaderSource = options.vertexShaderSource;\n  let fragmentShaderSource = options.fragmentShaderSource;\n  const attributeLocations = options.attributeLocations;\n\n  if (typeof vertexShaderSource === \"string\") {\n    vertexShaderSource = new ShaderSource({\n      sources: [vertexShaderSource],\n    });\n  }\n\n  if (typeof fragmentShaderSource === \"string\") {\n    fragmentShaderSource = new ShaderSource({\n      sources: [fragmentShaderSource],\n    });\n  }\n\n  const context = this._context;\n\n  const vertexShaderText =\n    vertexShaderSource.createCombinedVertexShader(context);\n  const fragmentShaderText =\n    fragmentShaderSource.createCombinedFragmentShader(context);\n\n  const derivedShaderProgram = new ShaderProgram({\n    gl: context._gl,\n    logShaderCompilation: context.logShaderCompilation,\n    debugShaders: context.debugShaders,\n    vertexShaderSource: vertexShaderSource,\n    vertexShaderText: vertexShaderText,\n    fragmentShaderSource: fragmentShaderSource,\n    fragmentShaderText: fragmentShaderText,\n    attributeLocations: attributeLocations,\n  });\n\n  const derivedCachedShader = {\n    cache: this,\n    shaderProgram: derivedShaderProgram,\n    keyword: derivedKeyword,\n    derivedKeywords: [],\n    count: 0,\n  };\n\n  cachedShader.derivedKeywords.push(keyword);\n  derivedShaderProgram._cachedShader = derivedCachedShader;\n  this._shaders[derivedKeyword] = derivedCachedShader;\n  return derivedShaderProgram;\n};\n\nfunction destroyShader(cache, cachedShader) {\n  const derivedKeywords = cachedShader.derivedKeywords;\n  const length = derivedKeywords.length;\n  for (let i = 0; i < length; ++i) {\n    const keyword = derivedKeywords[i] + cachedShader.keyword;\n    const derivedCachedShader = cache._shaders[keyword];\n    destroyShader(cache, derivedCachedShader);\n  }\n\n  delete cache._shaders[cachedShader.keyword];\n  cachedShader.shaderProgram.finalDestroy();\n}\n\nShaderCache.prototype.destroyReleasedShaderPrograms = function () {\n  const shadersToRelease = this._shadersToRelease;\n\n  for (const keyword in shadersToRelease) {\n    if (shadersToRelease.hasOwnProperty(keyword)) {\n      const cachedShader = shadersToRelease[keyword];\n      destroyShader(this, cachedShader);\n      --this._numberOfShaders;\n    }\n  }\n\n  this._shadersToRelease = {};\n};\n\nShaderCache.prototype.releaseShaderProgram = function (shaderProgram) {\n  if (defined(shaderProgram)) {\n    const cachedShader = shaderProgram._cachedShader;\n    if (cachedShader && --cachedShader.count === 0) {\n      this._shadersToRelease[cachedShader.keyword] = cachedShader;\n    }\n  }\n};\n\nShaderCache.prototype.isDestroyed = function () {\n  return false;\n};\n\nShaderCache.prototype.destroy = function () {\n  const shaders = this._shaders;\n  for (const keyword in shaders) {\n    if (shaders.hasOwnProperty(keyword)) {\n      shaders[keyword].shaderProgram.finalDestroy();\n    }\n  }\n  return destroyObject(this);\n};\nexport default ShaderCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}