{"ast":null,"code":"import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport GoogleEarthEnterpriseMetadata from \"./GoogleEarthEnterpriseMetadata.js\";\nimport GoogleEarthEnterpriseTerrainData from \"./GoogleEarthEnterpriseTerrainData.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nconst TerrainState = {\n  UNKNOWN: 0,\n  NONE: 1,\n  SELF: 2,\n  PARENT: 3\n};\nconst julianDateScratch = new JulianDate();\nfunction TerrainCache() {\n  this._terrainCache = {};\n  this._lastTidy = JulianDate.now();\n}\nTerrainCache.prototype.add = function (quadKey, buffer) {\n  this._terrainCache[quadKey] = {\n    buffer: buffer,\n    timestamp: JulianDate.now()\n  };\n};\nTerrainCache.prototype.get = function (quadKey) {\n  const terrainCache = this._terrainCache;\n  const result = terrainCache[quadKey];\n  if (defined(result)) {\n    delete this._terrainCache[quadKey];\n    return result.buffer;\n  }\n};\nTerrainCache.prototype.tidy = function () {\n  JulianDate.now(julianDateScratch);\n  if (JulianDate.secondsDifference(julianDateScratch, this._lastTidy) > 10) {\n    const terrainCache = this._terrainCache;\n    const keys = Object.keys(terrainCache);\n    const count = keys.length;\n    for (let i = 0; i < count; ++i) {\n      const k = keys[i];\n      const e = terrainCache[k];\n      if (JulianDate.secondsDifference(julianDateScratch, e.timestamp) > 10) {\n        delete terrainCache[k];\n      }\n    }\n    JulianDate.clone(julianDateScratch, this._lastTidy);\n  }\n};\n\n/**\n * @typedef {Object} GoogleEarthEnterpriseTerrainProvider.ConstructorOptions\n *\n * Initialization options for GoogleEarthEnterpriseTerrainProvider constructor\n *\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * <div class=\"notice\">\n * To construct a GoogleEarthEnterpriseTerrainProvider, call {@link  GoogleEarthEnterpriseTerrainProvider.fromMetadata}. Do not call the constructor directly.\n * </div>\n *\n * Provides tiled terrain using the Google Earth Enterprise REST API.\n *\n * @alias GoogleEarthEnterpriseTerrainProvider\n * @constructor\n *\n * @param {GoogleEarthEnterpriseTerrainProvider.ConstructorOptions} [options] An object describing initialization options\n *\n * @see GoogleEarthEnterpriseTerrainProvider.fromMetadata\n * @see GoogleEarthEnterpriseMetadata.fromUrl\n * @see GoogleEarthEnterpriseImageryProvider\n * @see CesiumTerrainProvider\n *\n * @example\n * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction GoogleEarthEnterpriseTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._tilingScheme = new GeographicTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    rectangle: new Rectangle(-CesiumMath.PI, -CesiumMath.PI, CesiumMath.PI, CesiumMath.PI),\n    ellipsoid: options.ellipsoid\n  });\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Pulled from Google's documentation\n  this._levelZeroMaximumGeometricError = 40075.16;\n  this._terrainCache = new TerrainCache();\n  this._terrainPromises = {};\n  this._terrainRequests = {};\n  this._errorEvent = new Event();\n}\nObject.defineProperties(GoogleEarthEnterpriseTerrainProvider.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server url hosting the imagery.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._metadata.url;\n    }\n  },\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._metadata.proxy;\n    }\n  },\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    }\n  },\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    }\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\n\n/**\n * Creates a GoogleEarthTerrainProvider from GoogleEarthEnterpriseMetadata\n *\n * @param {GoogleEarthEnterpriseMetadata} metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.\n * @param {GoogleEarthEnterpriseTerrainProvider.ConstructorOptions} options An object describing initialization options\n * @returns {GoogleEarthEnterpriseTerrainProvider}\n *\n * @see GoogleEarthEnterpriseMetadata.fromUrl\n *\n * @exception {RuntimeError} metadata does not specify terrain\n *\n * @example\n * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);\n */\nGoogleEarthEnterpriseTerrainProvider.fromMetadata = function (metadata, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"metadata\", metadata);\n  //>>includeEnd('debug');\n\n  if (!metadata.terrainPresent) {\n    throw new RuntimeError(`The server ${metadata.url} doesn't have terrain`);\n  }\n  const provider = new GoogleEarthEnterpriseTerrainProvider(options);\n  provider._metadata = metadata;\n  return provider;\n};\nconst taskProcessor = new TaskProcessor(\"decodeGoogleEarthEnterprisePacket\");\n\n// If the tile has its own terrain, then you can just use its child bitmask. If it was requested using it's parent\n//  then you need to check all of its children to see if they have terrain.\nfunction computeChildMask(quadKey, info, metadata) {\n  let childMask = info.getChildBitmask();\n  if (info.terrainState === TerrainState.PARENT) {\n    childMask = 0;\n    for (let i = 0; i < 4; ++i) {\n      const child = metadata.getTileInformationFromQuadKey(quadKey + i.toString());\n      if (defined(child) && child.hasTerrain()) {\n        childMask |= 1 << i;\n      }\n    }\n  }\n  return childMask;\n}\n\n/**\n * Requests the geometry for a given tile.   The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  const quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  const terrainCache = this._terrainCache;\n  const metadata = this._metadata;\n  const info = metadata.getTileInformationFromQuadKey(quadKey);\n\n  // Check if this tile is even possibly available\n  if (!defined(info)) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n  let terrainState = info.terrainState;\n  if (!defined(terrainState)) {\n    // First time we have tried to load this tile, so set terrain state to UNKNOWN\n    terrainState = info.terrainState = TerrainState.UNKNOWN;\n  }\n\n  // If its in the cache, return it\n  const buffer = terrainCache.get(quadKey);\n  if (defined(buffer)) {\n    const credit = metadata.providers[info.terrainProvider];\n    return Promise.resolve(new GoogleEarthEnterpriseTerrainData({\n      buffer: buffer,\n      childTileMask: computeChildMask(quadKey, info, metadata),\n      credits: defined(credit) ? [credit] : undefined,\n      negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n      negativeElevationThreshold: metadata.negativeAltitudeThreshold\n    }));\n  }\n\n  // Clean up the cache\n  terrainCache.tidy();\n\n  // We have a tile, check to see if no ancestors have terrain or that we know for sure it doesn't\n  if (!info.ancestorHasTerrain) {\n    // We haven't reached a level with terrain, so return the ellipsoid\n    return Promise.resolve(new HeightmapTerrainData({\n      buffer: new Uint8Array(16 * 16),\n      width: 16,\n      height: 16\n    }));\n  } else if (terrainState === TerrainState.NONE) {\n    // Already have info and there isn't any terrain here\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Figure out where we are getting the terrain and what version\n  let parentInfo;\n  let q = quadKey;\n  let terrainVersion = -1;\n  switch (terrainState) {\n    case TerrainState.SELF:\n      // We have terrain and have retrieved it before\n      terrainVersion = info.terrainVersion;\n      break;\n    case TerrainState.PARENT:\n      // We have terrain in our parent\n      q = q.substring(0, q.length - 1);\n      parentInfo = metadata.getTileInformationFromQuadKey(q);\n      terrainVersion = parentInfo.terrainVersion;\n      break;\n    case TerrainState.UNKNOWN:\n      // We haven't tried to retrieve terrain yet\n      if (info.hasTerrain()) {\n        terrainVersion = info.terrainVersion; // We should have terrain\n      } else {\n        q = q.substring(0, q.length - 1);\n        parentInfo = metadata.getTileInformationFromQuadKey(q);\n        if (defined(parentInfo) && parentInfo.hasTerrain()) {\n          terrainVersion = parentInfo.terrainVersion; // Try checking in the parent\n        }\n      }\n      break;\n  }\n\n  // We can't figure out where to get the terrain\n  if (terrainVersion < 0) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Load that terrain\n  const terrainPromises = this._terrainPromises;\n  const terrainRequests = this._terrainRequests;\n  let sharedPromise;\n  let sharedRequest;\n  if (defined(terrainPromises[q])) {\n    // Already being loaded possibly from another child, so return existing promise\n    sharedPromise = terrainPromises[q];\n    sharedRequest = terrainRequests[q];\n  } else {\n    // Create new request for terrain\n    sharedRequest = request;\n    const requestPromise = buildTerrainResource(this, q, terrainVersion, sharedRequest).fetchArrayBuffer();\n    if (!defined(requestPromise)) {\n      return undefined; // Throttled\n    }\n    sharedPromise = requestPromise.then(function (terrain) {\n      if (defined(terrain)) {\n        return taskProcessor.scheduleTask({\n          buffer: terrain,\n          type: \"Terrain\",\n          key: metadata.key\n        }, [terrain]).then(function (terrainTiles) {\n          // Add requested tile and mark it as SELF\n          const requestedInfo = metadata.getTileInformationFromQuadKey(q);\n          requestedInfo.terrainState = TerrainState.SELF;\n          terrainCache.add(q, terrainTiles[0]);\n          const provider = requestedInfo.terrainProvider;\n\n          // Add children to cache\n          const count = terrainTiles.length - 1;\n          for (let j = 0; j < count; ++j) {\n            const childKey = q + j.toString();\n            const child = metadata.getTileInformationFromQuadKey(childKey);\n            if (defined(child)) {\n              terrainCache.add(childKey, terrainTiles[j + 1]);\n              child.terrainState = TerrainState.PARENT;\n              if (child.terrainProvider === 0) {\n                child.terrainProvider = provider;\n              }\n            }\n          }\n        });\n      }\n      return Promise.reject(new RuntimeError(\"Failed to load terrain.\"));\n    });\n    terrainPromises[q] = sharedPromise; // Store promise without delete from terrainPromises\n    terrainRequests[q] = sharedRequest;\n\n    // Set promise so we remove from terrainPromises just one time\n    sharedPromise = sharedPromise.finally(function () {\n      delete terrainPromises[q];\n      delete terrainRequests[q];\n    });\n  }\n  return sharedPromise.then(function () {\n    const buffer = terrainCache.get(quadKey);\n    if (defined(buffer)) {\n      const credit = metadata.providers[info.terrainProvider];\n      return new GoogleEarthEnterpriseTerrainData({\n        buffer: buffer,\n        childTileMask: computeChildMask(quadKey, info, metadata),\n        credits: defined(credit) ? [credit] : undefined,\n        negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n        negativeElevationThreshold: metadata.negativeAltitudeThreshold\n      });\n    }\n    return Promise.reject(new RuntimeError(\"Failed to load terrain.\"));\n  }).catch(function (error) {\n    if (sharedRequest.state === RequestState.CANCELLED) {\n      request.state = sharedRequest.state;\n      return Promise.reject(error);\n    }\n    info.terrainState = TerrainState.NONE;\n    return Promise.reject(error);\n  });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  const metadata = this._metadata;\n  let quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  const info = metadata.getTileInformation(x, y, level);\n  if (info === null) {\n    return false;\n  }\n  if (defined(info)) {\n    if (!info.ancestorHasTerrain) {\n      return true; // We'll just return the ellipsoid\n    }\n    const terrainState = info.terrainState;\n    if (terrainState === TerrainState.NONE) {\n      return false; // Terrain is not available\n    }\n    if (!defined(terrainState) || terrainState === TerrainState.UNKNOWN) {\n      info.terrainState = TerrainState.UNKNOWN;\n      if (!info.hasTerrain()) {\n        quadKey = quadKey.substring(0, quadKey.length - 1);\n        const parentInfo = metadata.getTileInformationFromQuadKey(quadKey);\n        if (!defined(parentInfo) || !parentInfo.hasTerrain()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (metadata.isValid(quadKey)) {\n    // We will need this tile, so request metadata and return false for now\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN\n    });\n    metadata.populateSubtree(x, y, level, request);\n  }\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined}\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  return undefined;\n};\n\n//\n// Functions to handle imagery packets\n//\nfunction buildTerrainResource(terrainProvider, quadKey, version, request) {\n  version = defined(version) && version > 0 ? version : 1;\n  return terrainProvider._metadata.resource.getDerivedResource({\n    url: `flatfile?f1c-0${quadKey}-t.${version.toString()}`,\n    request: request\n  });\n}\nexport default GoogleEarthEnterpriseTerrainProvider;","map":{"version":3,"names":["Check","Credit","defaultValue","defined","Event","GeographicTilingScheme","GoogleEarthEnterpriseMetadata","GoogleEarthEnterpriseTerrainData","HeightmapTerrainData","JulianDate","CesiumMath","Rectangle","Request","RequestState","RequestType","RuntimeError","TaskProcessor","TerrainState","UNKNOWN","NONE","SELF","PARENT","julianDateScratch","TerrainCache","_terrainCache","_lastTidy","now","prototype","add","quadKey","buffer","timestamp","get","terrainCache","result","tidy","secondsDifference","keys","Object","count","length","i","k","e","clone","GoogleEarthEnterpriseTerrainProvider","options","EMPTY_OBJECT","_tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","rectangle","PI","ellipsoid","credit","_credit","_levelZeroMaximumGeometricError","_terrainPromises","_terrainRequests","_errorEvent","defineProperties","url","_metadata","proxy","tilingScheme","errorEvent","hasWaterMask","hasVertexNormals","availability","undefined","fromMetadata","metadata","terrainPresent","provider","taskProcessor","computeChildMask","info","childMask","getChildBitmask","terrainState","child","getTileInformationFromQuadKey","toString","hasTerrain","requestTileGeometry","x","y","level","request","tileXYToQuadKey","Promise","reject","providers","terrainProvider","resolve","childTileMask","credits","negativeAltitudeExponentBias","negativeElevationThreshold","negativeAltitudeThreshold","ancestorHasTerrain","Uint8Array","width","height","parentInfo","q","terrainVersion","substring","terrainPromises","terrainRequests","sharedPromise","sharedRequest","requestPromise","buildTerrainResource","fetchArrayBuffer","then","terrain","scheduleTask","type","key","terrainTiles","requestedInfo","j","childKey","finally","catch","error","state","CANCELLED","getLevelMaximumGeometricError","getTileDataAvailable","getTileInformation","isValid","throttle","throttleByServer","TERRAIN","populateSubtree","loadTileDataAvailability","version","resource","getDerivedResource"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/GoogleEarthEnterpriseTerrainProvider.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport GoogleEarthEnterpriseMetadata from \"./GoogleEarthEnterpriseMetadata.js\";\nimport GoogleEarthEnterpriseTerrainData from \"./GoogleEarthEnterpriseTerrainData.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\n\nconst TerrainState = {\n  UNKNOWN: 0,\n  NONE: 1,\n  SELF: 2,\n  PARENT: 3,\n};\n\nconst julianDateScratch = new JulianDate();\n\nfunction TerrainCache() {\n  this._terrainCache = {};\n  this._lastTidy = JulianDate.now();\n}\n\nTerrainCache.prototype.add = function (quadKey, buffer) {\n  this._terrainCache[quadKey] = {\n    buffer: buffer,\n    timestamp: JulianDate.now(),\n  };\n};\n\nTerrainCache.prototype.get = function (quadKey) {\n  const terrainCache = this._terrainCache;\n  const result = terrainCache[quadKey];\n  if (defined(result)) {\n    delete this._terrainCache[quadKey];\n    return result.buffer;\n  }\n};\n\nTerrainCache.prototype.tidy = function () {\n  JulianDate.now(julianDateScratch);\n  if (JulianDate.secondsDifference(julianDateScratch, this._lastTidy) > 10) {\n    const terrainCache = this._terrainCache;\n    const keys = Object.keys(terrainCache);\n    const count = keys.length;\n    for (let i = 0; i < count; ++i) {\n      const k = keys[i];\n      const e = terrainCache[k];\n      if (JulianDate.secondsDifference(julianDateScratch, e.timestamp) > 10) {\n        delete terrainCache[k];\n      }\n    }\n\n    JulianDate.clone(julianDateScratch, this._lastTidy);\n  }\n};\n\n/**\n * @typedef {Object} GoogleEarthEnterpriseTerrainProvider.ConstructorOptions\n *\n * Initialization options for GoogleEarthEnterpriseTerrainProvider constructor\n *\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * <div class=\"notice\">\n * To construct a GoogleEarthEnterpriseTerrainProvider, call {@link  GoogleEarthEnterpriseTerrainProvider.fromMetadata}. Do not call the constructor directly.\n * </div>\n *\n * Provides tiled terrain using the Google Earth Enterprise REST API.\n *\n * @alias GoogleEarthEnterpriseTerrainProvider\n * @constructor\n *\n * @param {GoogleEarthEnterpriseTerrainProvider.ConstructorOptions} [options] An object describing initialization options\n *\n * @see GoogleEarthEnterpriseTerrainProvider.fromMetadata\n * @see GoogleEarthEnterpriseMetadata.fromUrl\n * @see GoogleEarthEnterpriseImageryProvider\n * @see CesiumTerrainProvider\n *\n * @example\n * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction GoogleEarthEnterpriseTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._tilingScheme = new GeographicTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    rectangle: new Rectangle(\n      -CesiumMath.PI,\n      -CesiumMath.PI,\n      CesiumMath.PI,\n      CesiumMath.PI,\n    ),\n    ellipsoid: options.ellipsoid,\n  });\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Pulled from Google's documentation\n  this._levelZeroMaximumGeometricError = 40075.16;\n\n  this._terrainCache = new TerrainCache();\n  this._terrainPromises = {};\n  this._terrainRequests = {};\n\n  this._errorEvent = new Event();\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainProvider.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server url hosting the imagery.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._metadata.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._metadata.proxy;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * Creates a GoogleEarthTerrainProvider from GoogleEarthEnterpriseMetadata\n *\n * @param {GoogleEarthEnterpriseMetadata} metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.\n * @param {GoogleEarthEnterpriseTerrainProvider.ConstructorOptions} options An object describing initialization options\n * @returns {GoogleEarthEnterpriseTerrainProvider}\n *\n * @see GoogleEarthEnterpriseMetadata.fromUrl\n *\n * @exception {RuntimeError} metadata does not specify terrain\n *\n * @example\n * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl(\"http://www.example.com\");\n * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);\n */\nGoogleEarthEnterpriseTerrainProvider.fromMetadata = function (\n  metadata,\n  options,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"metadata\", metadata);\n  //>>includeEnd('debug');\n\n  if (!metadata.terrainPresent) {\n    throw new RuntimeError(`The server ${metadata.url} doesn't have terrain`);\n  }\n\n  const provider = new GoogleEarthEnterpriseTerrainProvider(options);\n  provider._metadata = metadata;\n\n  return provider;\n};\n\nconst taskProcessor = new TaskProcessor(\"decodeGoogleEarthEnterprisePacket\");\n\n// If the tile has its own terrain, then you can just use its child bitmask. If it was requested using it's parent\n//  then you need to check all of its children to see if they have terrain.\nfunction computeChildMask(quadKey, info, metadata) {\n  let childMask = info.getChildBitmask();\n  if (info.terrainState === TerrainState.PARENT) {\n    childMask = 0;\n    for (let i = 0; i < 4; ++i) {\n      const child = metadata.getTileInformationFromQuadKey(\n        quadKey + i.toString(),\n      );\n      if (defined(child) && child.hasTerrain()) {\n        childMask |= 1 << i;\n      }\n    }\n  }\n\n  return childMask;\n}\n\n/**\n * Requests the geometry for a given tile.   The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  const terrainCache = this._terrainCache;\n  const metadata = this._metadata;\n  const info = metadata.getTileInformationFromQuadKey(quadKey);\n\n  // Check if this tile is even possibly available\n  if (!defined(info)) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  let terrainState = info.terrainState;\n  if (!defined(terrainState)) {\n    // First time we have tried to load this tile, so set terrain state to UNKNOWN\n    terrainState = info.terrainState = TerrainState.UNKNOWN;\n  }\n\n  // If its in the cache, return it\n  const buffer = terrainCache.get(quadKey);\n  if (defined(buffer)) {\n    const credit = metadata.providers[info.terrainProvider];\n    return Promise.resolve(\n      new GoogleEarthEnterpriseTerrainData({\n        buffer: buffer,\n        childTileMask: computeChildMask(quadKey, info, metadata),\n        credits: defined(credit) ? [credit] : undefined,\n        negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n        negativeElevationThreshold: metadata.negativeAltitudeThreshold,\n      }),\n    );\n  }\n\n  // Clean up the cache\n  terrainCache.tidy();\n\n  // We have a tile, check to see if no ancestors have terrain or that we know for sure it doesn't\n  if (!info.ancestorHasTerrain) {\n    // We haven't reached a level with terrain, so return the ellipsoid\n    return Promise.resolve(\n      new HeightmapTerrainData({\n        buffer: new Uint8Array(16 * 16),\n        width: 16,\n        height: 16,\n      }),\n    );\n  } else if (terrainState === TerrainState.NONE) {\n    // Already have info and there isn't any terrain here\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Figure out where we are getting the terrain and what version\n  let parentInfo;\n  let q = quadKey;\n  let terrainVersion = -1;\n  switch (terrainState) {\n    case TerrainState.SELF: // We have terrain and have retrieved it before\n      terrainVersion = info.terrainVersion;\n      break;\n    case TerrainState.PARENT: // We have terrain in our parent\n      q = q.substring(0, q.length - 1);\n      parentInfo = metadata.getTileInformationFromQuadKey(q);\n      terrainVersion = parentInfo.terrainVersion;\n      break;\n    case TerrainState.UNKNOWN: // We haven't tried to retrieve terrain yet\n      if (info.hasTerrain()) {\n        terrainVersion = info.terrainVersion; // We should have terrain\n      } else {\n        q = q.substring(0, q.length - 1);\n        parentInfo = metadata.getTileInformationFromQuadKey(q);\n        if (defined(parentInfo) && parentInfo.hasTerrain()) {\n          terrainVersion = parentInfo.terrainVersion; // Try checking in the parent\n        }\n      }\n      break;\n  }\n\n  // We can't figure out where to get the terrain\n  if (terrainVersion < 0) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Load that terrain\n  const terrainPromises = this._terrainPromises;\n  const terrainRequests = this._terrainRequests;\n  let sharedPromise;\n  let sharedRequest;\n  if (defined(terrainPromises[q])) {\n    // Already being loaded possibly from another child, so return existing promise\n    sharedPromise = terrainPromises[q];\n    sharedRequest = terrainRequests[q];\n  } else {\n    // Create new request for terrain\n    sharedRequest = request;\n    const requestPromise = buildTerrainResource(\n      this,\n      q,\n      terrainVersion,\n      sharedRequest,\n    ).fetchArrayBuffer();\n\n    if (!defined(requestPromise)) {\n      return undefined; // Throttled\n    }\n\n    sharedPromise = requestPromise.then(function (terrain) {\n      if (defined(terrain)) {\n        return taskProcessor\n          .scheduleTask(\n            {\n              buffer: terrain,\n              type: \"Terrain\",\n              key: metadata.key,\n            },\n            [terrain],\n          )\n          .then(function (terrainTiles) {\n            // Add requested tile and mark it as SELF\n            const requestedInfo = metadata.getTileInformationFromQuadKey(q);\n            requestedInfo.terrainState = TerrainState.SELF;\n            terrainCache.add(q, terrainTiles[0]);\n            const provider = requestedInfo.terrainProvider;\n\n            // Add children to cache\n            const count = terrainTiles.length - 1;\n            for (let j = 0; j < count; ++j) {\n              const childKey = q + j.toString();\n              const child = metadata.getTileInformationFromQuadKey(childKey);\n              if (defined(child)) {\n                terrainCache.add(childKey, terrainTiles[j + 1]);\n                child.terrainState = TerrainState.PARENT;\n                if (child.terrainProvider === 0) {\n                  child.terrainProvider = provider;\n                }\n              }\n            }\n          });\n      }\n\n      return Promise.reject(new RuntimeError(\"Failed to load terrain.\"));\n    });\n\n    terrainPromises[q] = sharedPromise; // Store promise without delete from terrainPromises\n    terrainRequests[q] = sharedRequest;\n\n    // Set promise so we remove from terrainPromises just one time\n    sharedPromise = sharedPromise.finally(function () {\n      delete terrainPromises[q];\n      delete terrainRequests[q];\n    });\n  }\n\n  return sharedPromise\n    .then(function () {\n      const buffer = terrainCache.get(quadKey);\n      if (defined(buffer)) {\n        const credit = metadata.providers[info.terrainProvider];\n        return new GoogleEarthEnterpriseTerrainData({\n          buffer: buffer,\n          childTileMask: computeChildMask(quadKey, info, metadata),\n          credits: defined(credit) ? [credit] : undefined,\n          negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n          negativeElevationThreshold: metadata.negativeAltitudeThreshold,\n        });\n      }\n\n      return Promise.reject(new RuntimeError(\"Failed to load terrain.\"));\n    })\n    .catch(function (error) {\n      if (sharedRequest.state === RequestState.CANCELLED) {\n        request.state = sharedRequest.state;\n        return Promise.reject(error);\n      }\n      info.terrainState = TerrainState.NONE;\n      return Promise.reject(error);\n    });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getLevelMaximumGeometricError =\n  function (level) {\n    return this._levelZeroMaximumGeometricError / (1 << level);\n  };\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level,\n) {\n  const metadata = this._metadata;\n  let quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n\n  const info = metadata.getTileInformation(x, y, level);\n  if (info === null) {\n    return false;\n  }\n\n  if (defined(info)) {\n    if (!info.ancestorHasTerrain) {\n      return true; // We'll just return the ellipsoid\n    }\n\n    const terrainState = info.terrainState;\n    if (terrainState === TerrainState.NONE) {\n      return false; // Terrain is not available\n    }\n\n    if (!defined(terrainState) || terrainState === TerrainState.UNKNOWN) {\n      info.terrainState = TerrainState.UNKNOWN;\n      if (!info.hasTerrain()) {\n        quadKey = quadKey.substring(0, quadKey.length - 1);\n        const parentInfo = metadata.getTileInformationFromQuadKey(quadKey);\n        if (!defined(parentInfo) || !parentInfo.hasTerrain()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  if (metadata.isValid(quadKey)) {\n    // We will need this tile, so request metadata and return false for now\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN,\n    });\n    metadata.populateSubtree(x, y, level, request);\n  }\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined}\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.loadTileDataAvailability =\n  function (x, y, level) {\n    return undefined;\n  };\n\n//\n// Functions to handle imagery packets\n//\nfunction buildTerrainResource(terrainProvider, quadKey, version, request) {\n  version = defined(version) && version > 0 ? version : 1;\n  return terrainProvider._metadata.resource.getDerivedResource({\n    url: `flatfile?f1c-0${quadKey}-t.${version.toString()}`,\n    request: request,\n  });\n}\nexport default GoogleEarthEnterpriseTerrainProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}