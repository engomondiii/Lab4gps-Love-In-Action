{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport Entity from \"./Entity.js\";\nconst entityOptionsScratch = {\n  id: undefined\n};\nfunction fireChangedEvent(collection) {\n  if (collection._firing) {\n    collection._refire = true;\n    return;\n  }\n  if (collection._suspendCount === 0) {\n    const added = collection._addedEntities;\n    const removed = collection._removedEntities;\n    const changed = collection._changedEntities;\n    if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {\n      collection._firing = true;\n      do {\n        collection._refire = false;\n        const addedArray = added.values.slice(0);\n        const removedArray = removed.values.slice(0);\n        const changedArray = changed.values.slice(0);\n        added.removeAll();\n        removed.removeAll();\n        changed.removeAll();\n        collection._collectionChanged.raiseEvent(collection, addedArray, removedArray, changedArray);\n      } while (collection._refire);\n      collection._firing = false;\n    }\n  }\n}\n\n/**\n * An observable collection of {@link Entity} instances where each entity has a unique id.\n * @alias EntityCollection\n * @constructor\n *\n * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.\n */\nfunction EntityCollection(owner) {\n  this._owner = owner;\n  this._entities = new AssociativeArray();\n  this._addedEntities = new AssociativeArray();\n  this._removedEntities = new AssociativeArray();\n  this._changedEntities = new AssociativeArray();\n  this._suspendCount = 0;\n  this._collectionChanged = new Event();\n  this._id = createGuid();\n  this._show = true;\n  this._firing = false;\n  this._refire = false;\n}\n\n/**\n * Prevents {@link EntityCollection#collectionChanged} events from being raised\n * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which\n * point a single event will be raised that covers all suspended operations.\n * This allows for many items to be added and removed efficiently.\n * This function can be safely called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n */\nEntityCollection.prototype.suspendEvents = function () {\n  this._suspendCount++;\n};\n\n/**\n * Resumes raising {@link EntityCollection#collectionChanged} events immediately\n * when an item is added or removed.  Any modifications made while while events were suspended\n * will be triggered as a single event when this function is called.\n * This function is reference counted and can safely be called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n *\n * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.\n */\nEntityCollection.prototype.resumeEvents = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._suspendCount === 0) {\n    throw new DeveloperError(\"resumeEvents can not be called before suspendEvents.\");\n  }\n  //>>includeEnd('debug');\n\n  this._suspendCount--;\n  fireChangedEvent(this);\n};\n\n/**\n * The signature of the event generated by {@link EntityCollection#collectionChanged}.\n * @callback EntityCollection.CollectionChangedEventCallback\n *\n * @param {EntityCollection} collection The collection that triggered the event.\n * @param {Entity[]} added The array of {@link Entity} instances that have been added to the collection.\n * @param {Entity[]} removed The array of {@link Entity} instances that have been removed from the collection.\n * @param {Entity[]} changed The array of {@link Entity} instances that have been modified.\n */\n\nObject.defineProperties(EntityCollection.prototype, {\n  /**\n   * Gets the event that is fired when entities are added or removed from the collection.\n   * The generated event is a {@link EntityCollection.CollectionChangedEventCallback}.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {Event<EntityCollection.CollectionChangedEventCallback>}\n   */\n  collectionChanged: {\n    get: function () {\n      return this._collectionChanged;\n    }\n  },\n  /**\n   * Gets a globally unique identifier for this collection.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {string}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * Gets the array of Entity instances in the collection.\n   * This array should not be modified directly.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {Entity[]}\n   */\n  values: {\n    get: function () {\n      return this._entities.values;\n    }\n  },\n  /**\n   * Gets whether or not this entity collection should be\n   * displayed.  When true, each entity is only displayed if\n   * its own show property is also true.\n   * @memberof EntityCollection.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value === this._show) {\n        return;\n      }\n\n      //Since entity.isShowing includes the EntityCollection.show state\n      //in its calculation, we need to loop over the entities array\n      //twice, once to get the old showing value and a second time\n      //to raise the changed event.\n      this.suspendEvents();\n      let i;\n      const oldShows = [];\n      const entities = this._entities.values;\n      const entitiesLength = entities.length;\n      for (i = 0; i < entitiesLength; i++) {\n        oldShows.push(entities[i].isShowing);\n      }\n      this._show = value;\n      for (i = 0; i < entitiesLength; i++) {\n        const oldShow = oldShows[i];\n        const entity = entities[i];\n        if (oldShow !== entity.isShowing) {\n          entity.definitionChanged.raiseEvent(entity, \"isShowing\", entity.isShowing, oldShow);\n        }\n      }\n      this.resumeEvents();\n    }\n  },\n  /**\n   * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {DataSource|CompositeEntityCollection}\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  }\n});\n\n/**\n * Computes the maximum availability of the entities in the collection.\n * If the collection contains a mix of infinitely available data and non-infinite data,\n * it will return the interval pertaining to the non-infinite data only.  If all\n * data is infinite, an infinite interval will be returned.\n *\n * @returns {TimeInterval} The availability of entities in the collection.\n */\nEntityCollection.prototype.computeAvailability = function () {\n  let startTime = Iso8601.MAXIMUM_VALUE;\n  let stopTime = Iso8601.MINIMUM_VALUE;\n  const entities = this._entities.values;\n  for (let i = 0, len = entities.length; i < len; i++) {\n    const entity = entities[i];\n    const availability = entity.availability;\n    if (defined(availability)) {\n      const start = availability.start;\n      const stop = availability.stop;\n      if (JulianDate.lessThan(start, startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {\n        startTime = start;\n      }\n      if (JulianDate.greaterThan(stop, stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {\n        stopTime = stop;\n      }\n    }\n  }\n  if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {\n    startTime = Iso8601.MINIMUM_VALUE;\n  }\n  if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {\n    stopTime = Iso8601.MAXIMUM_VALUE;\n  }\n  return new TimeInterval({\n    start: startTime,\n    stop: stopTime\n  });\n};\n\n/**\n * Add an entity to the collection.\n *\n * @param {Entity | Entity.ConstructorOptions} entity The entity to be added.\n * @returns {Entity} The entity that was added.\n * @exception {DeveloperError} An entity with <entity.id> already exists in this collection.\n */\nEntityCollection.prototype.add = function (entity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!(entity instanceof Entity)) {\n    entity = new Entity(entity);\n  }\n  const id = entity.id;\n  const entities = this._entities;\n  if (entities.contains(id)) {\n    throw new DeveloperError(`An entity with id ${id} already exists in this collection.`);\n  }\n  entity.entityCollection = this;\n  entities.set(id, entity);\n  if (!this._removedEntities.remove(id)) {\n    this._addedEntities.set(id, entity);\n  }\n  entity.definitionChanged.addEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);\n  fireChangedEvent(this);\n  return entity;\n};\n\n/**\n * Removes an entity from the collection.\n *\n * @param {Entity} entity The entity to be removed.\n * @returns {boolean} true if the item was removed, false if it did not exist in the collection.\n */\nEntityCollection.prototype.remove = function (entity) {\n  if (!defined(entity)) {\n    return false;\n  }\n  return this.removeById(entity.id);\n};\n\n/**\n * Returns true if the provided entity is in this collection, false otherwise.\n *\n * @param {Entity} entity The entity.\n * @returns {boolean} true if the provided entity is in this collection, false otherwise.\n */\nEntityCollection.prototype.contains = function (entity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required\");\n  }\n  //>>includeEnd('debug');\n  return this._entities.get(entity.id) === entity;\n};\n\n/**\n * Removes an entity with the provided id from the collection.\n *\n * @param {string} id The id of the entity to remove.\n * @returns {boolean} true if the item was removed, false if no item with the provided id existed in the collection.\n */\nEntityCollection.prototype.removeById = function (id) {\n  if (!defined(id)) {\n    return false;\n  }\n  const entities = this._entities;\n  const entity = entities.get(id);\n  if (!this._entities.remove(id)) {\n    return false;\n  }\n  if (!this._addedEntities.remove(id)) {\n    this._removedEntities.set(id, entity);\n    this._changedEntities.remove(id);\n  }\n  this._entities.remove(id);\n  entity.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);\n  fireChangedEvent(this);\n  return true;\n};\n\n/**\n * Removes all Entities from the collection.\n */\nEntityCollection.prototype.removeAll = function () {\n  //The event should only contain items added before events were suspended\n  //and the contents of the collection.\n  const entities = this._entities;\n  const entitiesLength = entities.length;\n  const array = entities.values;\n  const addedEntities = this._addedEntities;\n  const removed = this._removedEntities;\n  for (let i = 0; i < entitiesLength; i++) {\n    const existingItem = array[i];\n    const existingItemId = existingItem.id;\n    const addedItem = addedEntities.get(existingItemId);\n    if (!defined(addedItem)) {\n      existingItem.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);\n      removed.set(existingItemId, existingItem);\n    }\n  }\n  entities.removeAll();\n  addedEntities.removeAll();\n  this._changedEntities.removeAll();\n  fireChangedEvent(this);\n};\n\n/**\n * Gets an entity with the specified id.\n *\n * @param {string} id The id of the entity to retrieve.\n * @returns {Entity|undefined} The entity with the provided id or undefined if the id did not exist in the collection.\n */\nEntityCollection.prototype.getById = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._entities.get(id);\n};\n\n/**\n * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.\n *\n * @param {string} id The id of the entity to retrieve or create.\n * @returns {Entity} The new or existing object.\n */\nEntityCollection.prototype.getOrCreateEntity = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let entity = this._entities.get(id);\n  if (!defined(entity)) {\n    entityOptionsScratch.id = id;\n    entity = new Entity(entityOptionsScratch);\n    this.add(entity);\n  }\n  return entity;\n};\nEntityCollection.prototype._onEntityDefinitionChanged = function (entity) {\n  const id = entity.id;\n  if (!this._addedEntities.contains(id)) {\n    this._changedEntities.set(id, entity);\n  }\n  fireChangedEvent(this);\n};\nexport default EntityCollection;","map":{"version":3,"names":["AssociativeArray","createGuid","defined","DeveloperError","Event","Iso8601","JulianDate","TimeInterval","Entity","entityOptionsScratch","id","undefined","fireChangedEvent","collection","_firing","_refire","_suspendCount","added","_addedEntities","removed","_removedEntities","changed","_changedEntities","length","addedArray","values","slice","removedArray","changedArray","removeAll","_collectionChanged","raiseEvent","EntityCollection","owner","_owner","_entities","_id","_show","prototype","suspendEvents","resumeEvents","Object","defineProperties","collectionChanged","get","show","set","value","i","oldShows","entities","entitiesLength","push","isShowing","oldShow","entity","definitionChanged","computeAvailability","startTime","MAXIMUM_VALUE","stopTime","MINIMUM_VALUE","len","availability","start","stop","lessThan","equals","greaterThan","add","contains","entityCollection","remove","addEventListener","_onEntityDefinitionChanged","removeById","removeEventListener","array","addedEntities","existingItem","existingItemId","addedItem","getById","getOrCreateEntity"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/EntityCollection.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport Entity from \"./Entity.js\";\n\nconst entityOptionsScratch = {\n  id: undefined,\n};\n\nfunction fireChangedEvent(collection) {\n  if (collection._firing) {\n    collection._refire = true;\n    return;\n  }\n\n  if (collection._suspendCount === 0) {\n    const added = collection._addedEntities;\n    const removed = collection._removedEntities;\n    const changed = collection._changedEntities;\n    if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {\n      collection._firing = true;\n      do {\n        collection._refire = false;\n        const addedArray = added.values.slice(0);\n        const removedArray = removed.values.slice(0);\n        const changedArray = changed.values.slice(0);\n\n        added.removeAll();\n        removed.removeAll();\n        changed.removeAll();\n        collection._collectionChanged.raiseEvent(\n          collection,\n          addedArray,\n          removedArray,\n          changedArray,\n        );\n      } while (collection._refire);\n      collection._firing = false;\n    }\n  }\n}\n\n/**\n * An observable collection of {@link Entity} instances where each entity has a unique id.\n * @alias EntityCollection\n * @constructor\n *\n * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.\n */\nfunction EntityCollection(owner) {\n  this._owner = owner;\n  this._entities = new AssociativeArray();\n  this._addedEntities = new AssociativeArray();\n  this._removedEntities = new AssociativeArray();\n  this._changedEntities = new AssociativeArray();\n  this._suspendCount = 0;\n  this._collectionChanged = new Event();\n  this._id = createGuid();\n  this._show = true;\n  this._firing = false;\n  this._refire = false;\n}\n\n/**\n * Prevents {@link EntityCollection#collectionChanged} events from being raised\n * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which\n * point a single event will be raised that covers all suspended operations.\n * This allows for many items to be added and removed efficiently.\n * This function can be safely called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n */\nEntityCollection.prototype.suspendEvents = function () {\n  this._suspendCount++;\n};\n\n/**\n * Resumes raising {@link EntityCollection#collectionChanged} events immediately\n * when an item is added or removed.  Any modifications made while while events were suspended\n * will be triggered as a single event when this function is called.\n * This function is reference counted and can safely be called multiple times as long as there\n * are corresponding calls to {@link EntityCollection#resumeEvents}.\n *\n * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.\n */\nEntityCollection.prototype.resumeEvents = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._suspendCount === 0) {\n    throw new DeveloperError(\n      \"resumeEvents can not be called before suspendEvents.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._suspendCount--;\n  fireChangedEvent(this);\n};\n\n/**\n * The signature of the event generated by {@link EntityCollection#collectionChanged}.\n * @callback EntityCollection.CollectionChangedEventCallback\n *\n * @param {EntityCollection} collection The collection that triggered the event.\n * @param {Entity[]} added The array of {@link Entity} instances that have been added to the collection.\n * @param {Entity[]} removed The array of {@link Entity} instances that have been removed from the collection.\n * @param {Entity[]} changed The array of {@link Entity} instances that have been modified.\n */\n\nObject.defineProperties(EntityCollection.prototype, {\n  /**\n   * Gets the event that is fired when entities are added or removed from the collection.\n   * The generated event is a {@link EntityCollection.CollectionChangedEventCallback}.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {Event<EntityCollection.CollectionChangedEventCallback>}\n   */\n  collectionChanged: {\n    get: function () {\n      return this._collectionChanged;\n    },\n  },\n  /**\n   * Gets a globally unique identifier for this collection.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {string}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * Gets the array of Entity instances in the collection.\n   * This array should not be modified directly.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {Entity[]}\n   */\n  values: {\n    get: function () {\n      return this._entities.values;\n    },\n  },\n  /**\n   * Gets whether or not this entity collection should be\n   * displayed.  When true, each entity is only displayed if\n   * its own show property is also true.\n   * @memberof EntityCollection.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value === this._show) {\n        return;\n      }\n\n      //Since entity.isShowing includes the EntityCollection.show state\n      //in its calculation, we need to loop over the entities array\n      //twice, once to get the old showing value and a second time\n      //to raise the changed event.\n      this.suspendEvents();\n\n      let i;\n      const oldShows = [];\n      const entities = this._entities.values;\n      const entitiesLength = entities.length;\n\n      for (i = 0; i < entitiesLength; i++) {\n        oldShows.push(entities[i].isShowing);\n      }\n\n      this._show = value;\n\n      for (i = 0; i < entitiesLength; i++) {\n        const oldShow = oldShows[i];\n        const entity = entities[i];\n        if (oldShow !== entity.isShowing) {\n          entity.definitionChanged.raiseEvent(\n            entity,\n            \"isShowing\",\n            entity.isShowing,\n            oldShow,\n          );\n        }\n      }\n\n      this.resumeEvents();\n    },\n  },\n  /**\n   * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.\n   * @memberof EntityCollection.prototype\n   * @readonly\n   * @type {DataSource|CompositeEntityCollection}\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n});\n\n/**\n * Computes the maximum availability of the entities in the collection.\n * If the collection contains a mix of infinitely available data and non-infinite data,\n * it will return the interval pertaining to the non-infinite data only.  If all\n * data is infinite, an infinite interval will be returned.\n *\n * @returns {TimeInterval} The availability of entities in the collection.\n */\nEntityCollection.prototype.computeAvailability = function () {\n  let startTime = Iso8601.MAXIMUM_VALUE;\n  let stopTime = Iso8601.MINIMUM_VALUE;\n  const entities = this._entities.values;\n  for (let i = 0, len = entities.length; i < len; i++) {\n    const entity = entities[i];\n    const availability = entity.availability;\n    if (defined(availability)) {\n      const start = availability.start;\n      const stop = availability.stop;\n      if (\n        JulianDate.lessThan(start, startTime) &&\n        !start.equals(Iso8601.MINIMUM_VALUE)\n      ) {\n        startTime = start;\n      }\n      if (\n        JulianDate.greaterThan(stop, stopTime) &&\n        !stop.equals(Iso8601.MAXIMUM_VALUE)\n      ) {\n        stopTime = stop;\n      }\n    }\n  }\n\n  if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {\n    startTime = Iso8601.MINIMUM_VALUE;\n  }\n  if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {\n    stopTime = Iso8601.MAXIMUM_VALUE;\n  }\n  return new TimeInterval({\n    start: startTime,\n    stop: stopTime,\n  });\n};\n\n/**\n * Add an entity to the collection.\n *\n * @param {Entity | Entity.ConstructorOptions} entity The entity to be added.\n * @returns {Entity} The entity that was added.\n * @exception {DeveloperError} An entity with <entity.id> already exists in this collection.\n */\nEntityCollection.prototype.add = function (entity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!(entity instanceof Entity)) {\n    entity = new Entity(entity);\n  }\n\n  const id = entity.id;\n  const entities = this._entities;\n  if (entities.contains(id)) {\n    throw new DeveloperError(\n      `An entity with id ${id} already exists in this collection.`,\n    );\n  }\n\n  entity.entityCollection = this;\n  entities.set(id, entity);\n\n  if (!this._removedEntities.remove(id)) {\n    this._addedEntities.set(id, entity);\n  }\n  entity.definitionChanged.addEventListener(\n    EntityCollection.prototype._onEntityDefinitionChanged,\n    this,\n  );\n\n  fireChangedEvent(this);\n  return entity;\n};\n\n/**\n * Removes an entity from the collection.\n *\n * @param {Entity} entity The entity to be removed.\n * @returns {boolean} true if the item was removed, false if it did not exist in the collection.\n */\nEntityCollection.prototype.remove = function (entity) {\n  if (!defined(entity)) {\n    return false;\n  }\n  return this.removeById(entity.id);\n};\n\n/**\n * Returns true if the provided entity is in this collection, false otherwise.\n *\n * @param {Entity} entity The entity.\n * @returns {boolean} true if the provided entity is in this collection, false otherwise.\n */\nEntityCollection.prototype.contains = function (entity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required\");\n  }\n  //>>includeEnd('debug');\n  return this._entities.get(entity.id) === entity;\n};\n\n/**\n * Removes an entity with the provided id from the collection.\n *\n * @param {string} id The id of the entity to remove.\n * @returns {boolean} true if the item was removed, false if no item with the provided id existed in the collection.\n */\nEntityCollection.prototype.removeById = function (id) {\n  if (!defined(id)) {\n    return false;\n  }\n\n  const entities = this._entities;\n  const entity = entities.get(id);\n  if (!this._entities.remove(id)) {\n    return false;\n  }\n\n  if (!this._addedEntities.remove(id)) {\n    this._removedEntities.set(id, entity);\n    this._changedEntities.remove(id);\n  }\n  this._entities.remove(id);\n  entity.definitionChanged.removeEventListener(\n    EntityCollection.prototype._onEntityDefinitionChanged,\n    this,\n  );\n  fireChangedEvent(this);\n\n  return true;\n};\n\n/**\n * Removes all Entities from the collection.\n */\nEntityCollection.prototype.removeAll = function () {\n  //The event should only contain items added before events were suspended\n  //and the contents of the collection.\n  const entities = this._entities;\n  const entitiesLength = entities.length;\n  const array = entities.values;\n\n  const addedEntities = this._addedEntities;\n  const removed = this._removedEntities;\n\n  for (let i = 0; i < entitiesLength; i++) {\n    const existingItem = array[i];\n    const existingItemId = existingItem.id;\n    const addedItem = addedEntities.get(existingItemId);\n    if (!defined(addedItem)) {\n      existingItem.definitionChanged.removeEventListener(\n        EntityCollection.prototype._onEntityDefinitionChanged,\n        this,\n      );\n      removed.set(existingItemId, existingItem);\n    }\n  }\n\n  entities.removeAll();\n  addedEntities.removeAll();\n  this._changedEntities.removeAll();\n  fireChangedEvent(this);\n};\n\n/**\n * Gets an entity with the specified id.\n *\n * @param {string} id The id of the entity to retrieve.\n * @returns {Entity|undefined} The entity with the provided id or undefined if the id did not exist in the collection.\n */\nEntityCollection.prototype.getById = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._entities.get(id);\n};\n\n/**\n * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.\n *\n * @param {string} id The id of the entity to retrieve or create.\n * @returns {Entity} The new or existing object.\n */\nEntityCollection.prototype.getOrCreateEntity = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let entity = this._entities.get(id);\n  if (!defined(entity)) {\n    entityOptionsScratch.id = id;\n    entity = new Entity(entityOptionsScratch);\n    this.add(entity);\n  }\n  return entity;\n};\n\nEntityCollection.prototype._onEntityDefinitionChanged = function (entity) {\n  const id = entity.id;\n  if (!this._addedEntities.contains(id)) {\n    this._changedEntities.set(id, entity);\n  }\n  fireChangedEvent(this);\n};\nexport default EntityCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}