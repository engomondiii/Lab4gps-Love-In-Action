{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Vector3DTileGeometry from \"./Vector3DTileGeometry.js\";\n\n/**\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Geometry3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Geometry3DTileContent(tileset, tile, resource, arrayBuffer, byteOffset) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._geometries = undefined;\n  this._metadata = undefined;\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n  this._ready = false;\n  initialize(this, arrayBuffer, byteOffset);\n}\nObject.defineProperties(Geometry3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    }\n  },\n  pointsLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  trianglesLength: {\n    get: function () {\n      if (defined(this._geometries)) {\n        return this._geometries.trianglesLength;\n      }\n      return 0;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._geometries)) {\n        return this._geometries.geometryByteLength;\n      }\n      return 0;\n    }\n  },\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.batchTableByteLength : 0;\n    }\n  },\n  innerContents: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Geometry3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    }\n  },\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    }\n  },\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    }\n  },\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    }\n  }\n});\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._geometries)) {\n      content._geometries.updateCommands(batchId, color);\n    }\n  };\n}\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  let boxBatchIds;\n  let cylinderBatchIds;\n  let ellipsoidBatchIds;\n  let sphereBatchIds;\n  let i;\n  const numberOfBoxes = defaultValue(featureTableJson.BOXES_LENGTH, 0);\n  const numberOfCylinders = defaultValue(featureTableJson.CYLINDERS_LENGTH, 0);\n  const numberOfEllipsoids = defaultValue(featureTableJson.ELLIPSOIDS_LENGTH, 0);\n  const numberOfSpheres = defaultValue(featureTableJson.SPHERES_LENGTH, 0);\n  if (numberOfBoxes > 0 && defined(featureTableJson.BOX_BATCH_IDS)) {\n    const boxBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.BOX_BATCH_IDS.byteOffset;\n    boxBatchIds = new Uint16Array(featureTableBinary.buffer, boxBatchIdsByteOffset, numberOfBoxes);\n  }\n  if (numberOfCylinders > 0 && defined(featureTableJson.CYLINDER_BATCH_IDS)) {\n    const cylinderBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.CYLINDER_BATCH_IDS.byteOffset;\n    cylinderBatchIds = new Uint16Array(featureTableBinary.buffer, cylinderBatchIdsByteOffset, numberOfCylinders);\n  }\n  if (numberOfEllipsoids > 0 && defined(featureTableJson.ELLIPSOID_BATCH_IDS)) {\n    const ellipsoidBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.ELLIPSOID_BATCH_IDS.byteOffset;\n    ellipsoidBatchIds = new Uint16Array(featureTableBinary.buffer, ellipsoidBatchIdsByteOffset, numberOfEllipsoids);\n  }\n  if (numberOfSpheres > 0 && defined(featureTableJson.SPHERE_BATCH_IDS)) {\n    const sphereBatchIdsByteOffset = featureTableBinary.byteOffset + featureTableJson.SPHERE_BATCH_IDS.byteOffset;\n    sphereBatchIds = new Uint16Array(featureTableBinary.buffer, sphereBatchIdsByteOffset, numberOfSpheres);\n  }\n  const atLeastOneDefined = defined(boxBatchIds) || defined(cylinderBatchIds) || defined(ellipsoidBatchIds) || defined(sphereBatchIds);\n  const atLeastOneUndefined = numberOfBoxes > 0 && !defined(boxBatchIds) || numberOfCylinders > 0 && !defined(cylinderBatchIds) || numberOfEllipsoids > 0 && !defined(ellipsoidBatchIds) || numberOfSpheres > 0 && !defined(sphereBatchIds);\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\"If one group of batch ids is defined, then all batch ids must be defined\");\n  }\n  const allUndefinedBatchIds = !defined(boxBatchIds) && !defined(cylinderBatchIds) && !defined(ellipsoidBatchIds) && !defined(sphereBatchIds);\n  if (allUndefinedBatchIds) {\n    let id = 0;\n    if (!defined(boxBatchIds) && numberOfBoxes > 0) {\n      boxBatchIds = new Uint16Array(numberOfBoxes);\n      for (i = 0; i < numberOfBoxes; ++i) {\n        boxBatchIds[i] = id++;\n      }\n    }\n    if (!defined(cylinderBatchIds) && numberOfCylinders > 0) {\n      cylinderBatchIds = new Uint16Array(numberOfCylinders);\n      for (i = 0; i < numberOfCylinders; ++i) {\n        cylinderBatchIds[i] = id++;\n      }\n    }\n    if (!defined(ellipsoidBatchIds) && numberOfEllipsoids > 0) {\n      ellipsoidBatchIds = new Uint16Array(numberOfEllipsoids);\n      for (i = 0; i < numberOfEllipsoids; ++i) {\n        ellipsoidBatchIds[i] = id++;\n      }\n    }\n    if (!defined(sphereBatchIds) && numberOfSpheres > 0) {\n      sphereBatchIds = new Uint16Array(numberOfSpheres);\n      for (i = 0; i < numberOfSpheres; ++i) {\n        sphereBatchIds[i] = id++;\n      }\n    }\n  }\n  return {\n    boxes: boxBatchIds,\n    cylinders: cylinderBatchIds,\n    ellipsoids: ellipsoidBatchIds,\n    spheres: sphereBatchIds\n  };\n}\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(`Only Geometry tile version 1 is supported.  Version ${version} is not.`);\n  }\n  byteOffset += sizeOfUint32;\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  if (byteLength === 0) {\n    content._ready = true;\n    return;\n  }\n  const featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const featureTableJson = getJsonFromTypedArray(uint8Array, byteOffset, featureTableJSONByteLength);\n  byteOffset += featureTableJSONByteLength;\n  const featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(uint8Array, byteOffset, batchTableJSONByteLength);\n    byteOffset += batchTableJSONByteLength;\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n  }\n  const numberOfBoxes = defaultValue(featureTableJson.BOXES_LENGTH, 0);\n  const numberOfCylinders = defaultValue(featureTableJson.CYLINDERS_LENGTH, 0);\n  const numberOfEllipsoids = defaultValue(featureTableJson.ELLIPSOIDS_LENGTH, 0);\n  const numberOfSpheres = defaultValue(featureTableJson.SPHERES_LENGTH, 0);\n  const totalPrimitives = numberOfBoxes + numberOfCylinders + numberOfEllipsoids + numberOfSpheres;\n  const batchTable = new Cesium3DTileBatchTable(content, totalPrimitives, batchTableJson, batchTableBinary, createColorChangedCallback(content));\n  content._batchTable = batchTable;\n  if (totalPrimitives === 0) {\n    return;\n  }\n  const modelMatrix = content.tile.computedTransform;\n  let center;\n  if (defined(featureTableJson.RTC_CENTER)) {\n    center = Cartesian3.unpack(featureTableJson.RTC_CENTER);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  }\n  const batchIds = getBatchIds(featureTableJson, featureTableBinary);\n  if (numberOfBoxes > 0 || numberOfCylinders > 0 || numberOfEllipsoids > 0 || numberOfSpheres > 0) {\n    let boxes;\n    let cylinders;\n    let ellipsoids;\n    let spheres;\n    if (numberOfBoxes > 0) {\n      const boxesByteOffset = featureTableBinary.byteOffset + featureTableJson.BOXES.byteOffset;\n      boxes = new Float32Array(featureTableBinary.buffer, boxesByteOffset, Vector3DTileGeometry.packedBoxLength * numberOfBoxes);\n    }\n    if (numberOfCylinders > 0) {\n      const cylindersByteOffset = featureTableBinary.byteOffset + featureTableJson.CYLINDERS.byteOffset;\n      cylinders = new Float32Array(featureTableBinary.buffer, cylindersByteOffset, Vector3DTileGeometry.packedCylinderLength * numberOfCylinders);\n    }\n    if (numberOfEllipsoids > 0) {\n      const ellipsoidsByteOffset = featureTableBinary.byteOffset + featureTableJson.ELLIPSOIDS.byteOffset;\n      ellipsoids = new Float32Array(featureTableBinary.buffer, ellipsoidsByteOffset, Vector3DTileGeometry.packedEllipsoidLength * numberOfEllipsoids);\n    }\n    if (numberOfSpheres > 0) {\n      const spheresByteOffset = featureTableBinary.byteOffset + featureTableJson.SPHERES.byteOffset;\n      spheres = new Float32Array(featureTableBinary.buffer, spheresByteOffset, Vector3DTileGeometry.packedSphereLength * numberOfSpheres);\n    }\n    content._geometries = new Vector3DTileGeometry({\n      boxes: boxes,\n      boxBatchIds: batchIds.boxes,\n      cylinders: cylinders,\n      cylinderBatchIds: batchIds.cylinders,\n      ellipsoids: ellipsoids,\n      ellipsoidBatchIds: batchIds.ellipsoids,\n      spheres: spheres,\n      sphereBatchIds: batchIds.spheres,\n      center: center,\n      modelMatrix: modelMatrix,\n      batchTable: batchTable,\n      boundingVolume: content.tile.boundingVolume.boundingVolume\n    });\n    return content;\n  }\n  return Promise.resolve(content);\n}\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    if (defined(content._geometries)) {\n      content._geometries.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\nGeometry3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\nGeometry3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(`batchId is required and between zero and featuresLength - 1 (${featuresLength - 1}).`);\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\nGeometry3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._geometries)) {\n    this._geometries.applyDebugSettings(enabled, color);\n  }\n};\nGeometry3DTileContent.prototype.applyStyle = function (style) {\n  createFeatures(this);\n  if (defined(this._geometries)) {\n    this._geometries.applyStyle(style, this._features);\n  }\n};\nGeometry3DTileContent.prototype.update = function (tileset, frameState) {\n  if (defined(this._geometries)) {\n    this._geometries.classificationType = this._tileset.classificationType;\n    this._geometries.debugWireframe = this._tileset.debugWireframe;\n    this._geometries.update(frameState);\n  }\n  if (defined(this._batchTable) && this._geometries.ready) {\n    this._batchTable.update(tileset, frameState);\n    this._ready = true;\n  }\n};\nGeometry3DTileContent.prototype.pick = function (ray, frameState, result) {\n  return undefined;\n};\nGeometry3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\nGeometry3DTileContent.prototype.destroy = function () {\n  this._geometries = this._geometries && this._geometries.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nexport default Geometry3DTileContent;","map":{"version":3,"names":["Cartesian3","defaultValue","defined","destroyObject","DeveloperError","getJsonFromTypedArray","Matrix4","RuntimeError","Cesium3DTileBatchTable","Vector3DTileGeometry","Geometry3DTileContent","tileset","tile","resource","arrayBuffer","byteOffset","_tileset","_tile","_resource","_geometries","undefined","_metadata","_batchTable","_features","featurePropertiesDirty","_group","_ready","initialize","Object","defineProperties","prototype","featuresLength","get","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","innerContents","ready","url","getUrlComponent","metadata","set","value","batchTable","group","createColorChangedCallback","content","batchId","color","updateCommands","getBatchIds","featureTableJson","featureTableBinary","boxBatchIds","cylinderBatchIds","ellipsoidBatchIds","sphereBatchIds","i","numberOfBoxes","BOXES_LENGTH","numberOfCylinders","CYLINDERS_LENGTH","numberOfEllipsoids","ELLIPSOIDS_LENGTH","numberOfSpheres","SPHERES_LENGTH","BOX_BATCH_IDS","boxBatchIdsByteOffset","Uint16Array","buffer","CYLINDER_BATCH_IDS","cylinderBatchIdsByteOffset","ELLIPSOID_BATCH_IDS","ellipsoidBatchIdsByteOffset","SPHERE_BATCH_IDS","sphereBatchIdsByteOffset","atLeastOneDefined","atLeastOneUndefined","allUndefinedBatchIds","id","boxes","cylinders","ellipsoids","spheres","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","uint8Array","Uint8Array","view","DataView","version","getUint32","byteLength","featureTableJSONByteLength","featureTableBinaryByteLength","batchTableJSONByteLength","batchTableBinaryByteLength","batchTableJson","batchTableBinary","totalPrimitives","modelMatrix","computedTransform","center","RTC_CENTER","unpack","multiplyByPoint","batchIds","boxesByteOffset","BOXES","Float32Array","packedBoxLength","cylindersByteOffset","CYLINDERS","packedCylinderLength","ellipsoidsByteOffset","ELLIPSOIDS","packedEllipsoidLength","spheresByteOffset","SPHERES","packedSphereLength","boundingVolume","Promise","resolve","createFeatures","features","Array","hasProperty","name","getFeature","applyDebugSettings","enabled","applyStyle","style","update","frameState","classificationType","debugWireframe","pick","ray","result","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Geometry3DTileContent.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Vector3DTileGeometry from \"./Vector3DTileGeometry.js\";\n\n/**\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Geometry3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Geometry3DTileContent(\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._geometries = undefined;\n\n  this._metadata = undefined;\n\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  this._ready = false;\n\n  initialize(this, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Geometry3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      if (defined(this._geometries)) {\n        return this._geometries.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._geometries)) {\n        return this._geometries.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable)\n        ? this._batchTable.batchTableByteLength\n        : 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Geometry3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._geometries)) {\n      content._geometries.updateCommands(batchId, color);\n    }\n  };\n}\n\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  let boxBatchIds;\n  let cylinderBatchIds;\n  let ellipsoidBatchIds;\n  let sphereBatchIds;\n  let i;\n\n  const numberOfBoxes = defaultValue(featureTableJson.BOXES_LENGTH, 0);\n  const numberOfCylinders = defaultValue(featureTableJson.CYLINDERS_LENGTH, 0);\n  const numberOfEllipsoids = defaultValue(\n    featureTableJson.ELLIPSOIDS_LENGTH,\n    0,\n  );\n  const numberOfSpheres = defaultValue(featureTableJson.SPHERES_LENGTH, 0);\n\n  if (numberOfBoxes > 0 && defined(featureTableJson.BOX_BATCH_IDS)) {\n    const boxBatchIdsByteOffset =\n      featureTableBinary.byteOffset + featureTableJson.BOX_BATCH_IDS.byteOffset;\n    boxBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      boxBatchIdsByteOffset,\n      numberOfBoxes,\n    );\n  }\n\n  if (numberOfCylinders > 0 && defined(featureTableJson.CYLINDER_BATCH_IDS)) {\n    const cylinderBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.CYLINDER_BATCH_IDS.byteOffset;\n    cylinderBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      cylinderBatchIdsByteOffset,\n      numberOfCylinders,\n    );\n  }\n\n  if (numberOfEllipsoids > 0 && defined(featureTableJson.ELLIPSOID_BATCH_IDS)) {\n    const ellipsoidBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.ELLIPSOID_BATCH_IDS.byteOffset;\n    ellipsoidBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      ellipsoidBatchIdsByteOffset,\n      numberOfEllipsoids,\n    );\n  }\n\n  if (numberOfSpheres > 0 && defined(featureTableJson.SPHERE_BATCH_IDS)) {\n    const sphereBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.SPHERE_BATCH_IDS.byteOffset;\n    sphereBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      sphereBatchIdsByteOffset,\n      numberOfSpheres,\n    );\n  }\n\n  const atLeastOneDefined =\n    defined(boxBatchIds) ||\n    defined(cylinderBatchIds) ||\n    defined(ellipsoidBatchIds) ||\n    defined(sphereBatchIds);\n  const atLeastOneUndefined =\n    (numberOfBoxes > 0 && !defined(boxBatchIds)) ||\n    (numberOfCylinders > 0 && !defined(cylinderBatchIds)) ||\n    (numberOfEllipsoids > 0 && !defined(ellipsoidBatchIds)) ||\n    (numberOfSpheres > 0 && !defined(sphereBatchIds));\n\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\n      \"If one group of batch ids is defined, then all batch ids must be defined\",\n    );\n  }\n\n  const allUndefinedBatchIds =\n    !defined(boxBatchIds) &&\n    !defined(cylinderBatchIds) &&\n    !defined(ellipsoidBatchIds) &&\n    !defined(sphereBatchIds);\n  if (allUndefinedBatchIds) {\n    let id = 0;\n    if (!defined(boxBatchIds) && numberOfBoxes > 0) {\n      boxBatchIds = new Uint16Array(numberOfBoxes);\n      for (i = 0; i < numberOfBoxes; ++i) {\n        boxBatchIds[i] = id++;\n      }\n    }\n    if (!defined(cylinderBatchIds) && numberOfCylinders > 0) {\n      cylinderBatchIds = new Uint16Array(numberOfCylinders);\n      for (i = 0; i < numberOfCylinders; ++i) {\n        cylinderBatchIds[i] = id++;\n      }\n    }\n    if (!defined(ellipsoidBatchIds) && numberOfEllipsoids > 0) {\n      ellipsoidBatchIds = new Uint16Array(numberOfEllipsoids);\n      for (i = 0; i < numberOfEllipsoids; ++i) {\n        ellipsoidBatchIds[i] = id++;\n      }\n    }\n    if (!defined(sphereBatchIds) && numberOfSpheres > 0) {\n      sphereBatchIds = new Uint16Array(numberOfSpheres);\n      for (i = 0; i < numberOfSpheres; ++i) {\n        sphereBatchIds[i] = id++;\n      }\n    }\n  }\n\n  return {\n    boxes: boxBatchIds,\n    cylinders: cylinderBatchIds,\n    ellipsoids: ellipsoidBatchIds,\n    spheres: sphereBatchIds,\n  };\n}\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Geometry tile version 1 is supported.  Version ${version} is not.`,\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (byteLength === 0) {\n    content._ready = true;\n    return;\n  }\n\n  const featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\",\n    );\n  }\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJSONByteLength,\n  );\n  byteOffset += featureTableJSONByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength,\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJSONByteLength,\n    );\n    byteOffset += batchTableJSONByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength,\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n  }\n\n  const numberOfBoxes = defaultValue(featureTableJson.BOXES_LENGTH, 0);\n  const numberOfCylinders = defaultValue(featureTableJson.CYLINDERS_LENGTH, 0);\n  const numberOfEllipsoids = defaultValue(\n    featureTableJson.ELLIPSOIDS_LENGTH,\n    0,\n  );\n  const numberOfSpheres = defaultValue(featureTableJson.SPHERES_LENGTH, 0);\n\n  const totalPrimitives =\n    numberOfBoxes + numberOfCylinders + numberOfEllipsoids + numberOfSpheres;\n\n  const batchTable = new Cesium3DTileBatchTable(\n    content,\n    totalPrimitives,\n    batchTableJson,\n    batchTableBinary,\n    createColorChangedCallback(content),\n  );\n  content._batchTable = batchTable;\n\n  if (totalPrimitives === 0) {\n    return;\n  }\n\n  const modelMatrix = content.tile.computedTransform;\n\n  let center;\n  if (defined(featureTableJson.RTC_CENTER)) {\n    center = Cartesian3.unpack(featureTableJson.RTC_CENTER);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  }\n\n  const batchIds = getBatchIds(featureTableJson, featureTableBinary);\n\n  if (\n    numberOfBoxes > 0 ||\n    numberOfCylinders > 0 ||\n    numberOfEllipsoids > 0 ||\n    numberOfSpheres > 0\n  ) {\n    let boxes;\n    let cylinders;\n    let ellipsoids;\n    let spheres;\n\n    if (numberOfBoxes > 0) {\n      const boxesByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.BOXES.byteOffset;\n      boxes = new Float32Array(\n        featureTableBinary.buffer,\n        boxesByteOffset,\n        Vector3DTileGeometry.packedBoxLength * numberOfBoxes,\n      );\n    }\n\n    if (numberOfCylinders > 0) {\n      const cylindersByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.CYLINDERS.byteOffset;\n      cylinders = new Float32Array(\n        featureTableBinary.buffer,\n        cylindersByteOffset,\n        Vector3DTileGeometry.packedCylinderLength * numberOfCylinders,\n      );\n    }\n\n    if (numberOfEllipsoids > 0) {\n      const ellipsoidsByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.ELLIPSOIDS.byteOffset;\n      ellipsoids = new Float32Array(\n        featureTableBinary.buffer,\n        ellipsoidsByteOffset,\n        Vector3DTileGeometry.packedEllipsoidLength * numberOfEllipsoids,\n      );\n    }\n\n    if (numberOfSpheres > 0) {\n      const spheresByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.SPHERES.byteOffset;\n      spheres = new Float32Array(\n        featureTableBinary.buffer,\n        spheresByteOffset,\n        Vector3DTileGeometry.packedSphereLength * numberOfSpheres,\n      );\n    }\n\n    content._geometries = new Vector3DTileGeometry({\n      boxes: boxes,\n      boxBatchIds: batchIds.boxes,\n      cylinders: cylinders,\n      cylinderBatchIds: batchIds.cylinders,\n      ellipsoids: ellipsoids,\n      ellipsoidBatchIds: batchIds.ellipsoids,\n      spheres: spheres,\n      sphereBatchIds: batchIds.spheres,\n      center: center,\n      modelMatrix: modelMatrix,\n      batchTable: batchTable,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n    });\n\n    return content;\n  }\n\n  return Promise.resolve(content);\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    if (defined(content._geometries)) {\n      content._geometries.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\n\nGeometry3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nGeometry3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nGeometry3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._geometries)) {\n    this._geometries.applyDebugSettings(enabled, color);\n  }\n};\n\nGeometry3DTileContent.prototype.applyStyle = function (style) {\n  createFeatures(this);\n  if (defined(this._geometries)) {\n    this._geometries.applyStyle(style, this._features);\n  }\n};\n\nGeometry3DTileContent.prototype.update = function (tileset, frameState) {\n  if (defined(this._geometries)) {\n    this._geometries.classificationType = this._tileset.classificationType;\n    this._geometries.debugWireframe = this._tileset.debugWireframe;\n    this._geometries.update(frameState);\n  }\n\n  if (defined(this._batchTable) && this._geometries.ready) {\n    this._batchTable.update(tileset, frameState);\n    this._ready = true;\n  }\n};\n\nGeometry3DTileContent.prototype.pick = function (ray, frameState, result) {\n  return undefined;\n};\n\nGeometry3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nGeometry3DTileContent.prototype.destroy = function () {\n  this._geometries = this._geometries && this._geometries.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nexport default Geometry3DTileContent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}