{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Visibility from \"./Visibility.js\";\n\n/**\n * Creates an Occluder derived from an object's position and radius, as well as the camera position.\n * The occluder can be used to determine whether or not other objects are visible or hidden behind the\n * visible horizon defined by the occluder and camera position.\n *\n * @alias Occluder\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n *\n * @constructor\n *\n * @example\n * // Construct an occluder one unit away from the origin with a radius of one.\n * const cameraPosition = Cesium.Cartesian3.ZERO;\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n */\nfunction Occluder(occluderBoundingSphere, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  this._occluderRadius = occluderBoundingSphere.radius;\n  this._horizonDistance = 0.0;\n  this._horizonPlaneNormal = undefined;\n  this._horizonPlanePosition = undefined;\n  this._cameraPosition = undefined;\n\n  // cameraPosition fills in the above values\n  this.cameraPosition = cameraPosition;\n}\nconst scratchCartesian3 = new Cartesian3();\nObject.defineProperties(Occluder.prototype, {\n  /**\n   * The position of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._occluderPosition;\n    }\n  },\n  /**\n   * The radius of the occluder.\n   * @memberof Occluder.prototype\n   * @type {number}\n   */\n  radius: {\n    get: function () {\n      return this._occluderRadius;\n    }\n  },\n  /**\n   * The position of the camera.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    set: function (cameraPosition) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(cameraPosition)) {\n        throw new DeveloperError(\"cameraPosition is required.\");\n      }\n      //>>includeEnd('debug');\n\n      cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);\n      const cameraToOccluderVec = Cartesian3.subtract(this._occluderPosition, cameraPosition, scratchCartesian3);\n      let invCameraToOccluderDistance = Cartesian3.magnitudeSquared(cameraToOccluderVec);\n      const occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;\n      let horizonDistance;\n      let horizonPlaneNormal;\n      let horizonPlanePosition;\n      if (invCameraToOccluderDistance > occluderRadiusSqrd) {\n        horizonDistance = Math.sqrt(invCameraToOccluderDistance - occluderRadiusSqrd);\n        invCameraToOccluderDistance = 1.0 / Math.sqrt(invCameraToOccluderDistance);\n        horizonPlaneNormal = Cartesian3.multiplyByScalar(cameraToOccluderVec, invCameraToOccluderDistance, scratchCartesian3);\n        const nearPlaneDistance = horizonDistance * horizonDistance * invCameraToOccluderDistance;\n        horizonPlanePosition = Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(horizonPlaneNormal, nearPlaneDistance, scratchCartesian3), scratchCartesian3);\n      } else {\n        horizonDistance = Number.MAX_VALUE;\n      }\n      this._horizonDistance = horizonDistance;\n      this._horizonPlaneNormal = horizonPlaneNormal;\n      this._horizonPlanePosition = horizonPlanePosition;\n      this._cameraPosition = cameraPosition;\n    }\n  }\n});\n\n/**\n * Creates an occluder from a bounding sphere and the camera position.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n * @param {Occluder} [result] The object onto which to store the result.\n * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.\n */\nOccluder.fromBoundingSphere = function (occluderBoundingSphere, cameraPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Occluder(occluderBoundingSphere, cameraPosition);\n  }\n  Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);\n  result._occluderRadius = occluderBoundingSphere.radius;\n  result.cameraPosition = cameraPosition;\n  return result;\n};\nconst tempVecScratch = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point surrounding the occludee object.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isPointVisible = function (occludee) {\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(occludee, this._occluderPosition, tempVecScratch);\n    let temp = this._occluderRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (temp > 0.0) {\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);\n      return temp * temp > Cartesian3.magnitudeSquared(tempVec);\n    }\n  }\n  return false;\n};\nconst occludeePositionScratch = new Cartesian3();\n\n/**\n * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isBoundingSphereVisible = function (occludee) {\n  const occludeePosition = Cartesian3.clone(occludee.center, occludeePositionScratch);\n  const occludeeRadius = occludee.radius;\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempVecScratch);\n    let temp = this._occluderRadius - occludeeRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (occludeeRadius < this._occluderRadius) {\n      if (temp > 0.0) {\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);\n        return temp * temp + occludeeRadius * occludeeRadius > Cartesian3.magnitudeSquared(tempVec);\n      }\n      return false;\n    }\n\n    // Prevent against the case where the occludee radius is larger than the occluder's; since this is\n    // an uncommon case, the following code should rarely execute.\n    if (temp > 0.0) {\n      tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);\n      const tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);\n      const occluderRadiusSquared = this._occluderRadius * this._occluderRadius;\n      const occludeeRadiusSquared = occludeeRadius * occludeeRadius;\n      if ((this._horizonDistance * this._horizonDistance + occluderRadiusSquared) * occludeeRadiusSquared > tempVecMagnitudeSquared * occluderRadiusSquared) {\n        // The occludee is close enough that the occluder cannot possible occlude the occludee\n        return true;\n      }\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;\n    }\n\n    // The occludee completely encompasses the occluder\n    return true;\n  }\n  return false;\n};\nconst tempScratch = new Cartesian3();\n/**\n * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).\n *\n * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.\n * @returns {Visibility} Visibility.NONE if the occludee is not visible,\n *                       Visibility.PARTIAL if the occludee is partially visible, or\n *                       Visibility.FULL if the occludee is fully visible.\n *\n *\n * @example\n * const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE\n */\nOccluder.prototype.computeVisibility = function (occludeeBS) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occludeeBS)) {\n    throw new DeveloperError(\"occludeeBS is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // If the occludee radius is larger than the occluders, this will return that\n  // the entire ocludee is visible, even though that may not be the case, though this should\n  // not occur too often.\n  const occludeePosition = Cartesian3.clone(occludeeBS.center);\n  const occludeeRadius = occludeeBS.radius;\n  if (occludeeRadius > this._occluderRadius) {\n    return Visibility.FULL;\n  }\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    // The camera is outside the occluder\n    let tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempScratch);\n    let temp = this._occluderRadius - occludeeRadius;\n    const occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n    temp = occluderToOccludeeDistSqrd - temp * temp;\n    if (temp > 0.0) {\n      // The occludee is not completely inside the occluder\n      // Check to see if the occluder completely hides the occludee\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);\n      const cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n      if (temp * temp + occludeeRadius * occludeeRadius < cameraToOccludeeDistSqrd) {\n        return Visibility.NONE;\n      }\n\n      // Check to see whether the occluder is fully or partially visible\n      // when the occludee does not intersect the occluder\n      temp = this._occluderRadius + occludeeRadius;\n      temp = occluderToOccludeeDistSqrd - temp * temp;\n      if (temp > 0.0) {\n        // The occludee does not intersect the occluder.\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        return cameraToOccludeeDistSqrd < temp * temp + occludeeRadius * occludeeRadius ? Visibility.FULL : Visibility.PARTIAL;\n      }\n\n      //Check to see if the occluder is fully or partially visible when the occludee DOES\n      //intersect the occluder\n      tempVec = Cartesian3.subtract(occludeePosition, this._horizonPlanePosition, tempVec);\n      return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius ? Visibility.PARTIAL : Visibility.FULL;\n    }\n  }\n  return Visibility.NONE;\n};\nconst occludeePointScratch = new Cartesian3();\n/**\n * Computes a point that can be used as the occludee position to the visibility functions.\n * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around\n * an object that is used for visibility; however it is also possible to compute a point that if\n * seen/not seen would also indicate if an object is visible/not visible.  This function is better\n * called for objects that do not move relative to the occluder and is large, such as a chunk of\n * terrain.  You are better off not calling this and using the object's bounding sphere for objects\n * such as a satellite or ground vehicle.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.\n * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.\n * @returns {object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n *\n * @exception {DeveloperError} <code>positions</code> must contain at least one element.\n * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * const occludeePosition = tileOccluderSphere.center;\n * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);\n */\nOccluder.computeOccludeePoint = function (occluderBoundingSphere, occludeePosition, positions) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  if (positions.length === 0) {\n    throw new DeveloperError(\"positions must contain at least one element\");\n  }\n  //>>includeEnd('debug');\n\n  const occludeePos = Cartesian3.clone(occludeePosition);\n  const occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  const occluderRadius = occluderBoundingSphere.radius;\n  const numPositions = positions.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Cartesian3.equals(occluderPosition, occludeePosition)) {\n    throw new DeveloperError(\"occludeePosition must be different than occluderBoundingSphere.center\");\n  }\n  //>>includeEnd('debug');\n\n  // Compute a plane with a normal from the occluder to the occludee position.\n  const occluderPlaneNormal = Cartesian3.normalize(Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch), occludeePointScratch);\n  const occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition);\n\n  //For each position, determine the horizon intersection. Choose the position and intersection\n  //that results in the greatest angle with the occcluder plane.\n  const aRotationVector = Occluder._anyRotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD);\n  let dot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[0]);\n  if (!dot) {\n    //The position is inside the mimimum radius, which is invalid\n    return undefined;\n  }\n  let tempDot;\n  for (let i = 1; i < numPositions; ++i) {\n    tempDot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[i]);\n    if (!tempDot) {\n      //The position is inside the minimum radius, which is invalid\n      return undefined;\n    }\n    if (tempDot < dot) {\n      dot = tempDot;\n    }\n  }\n  //Verify that the dot is not near 90 degress\n  // eslint-disable-next-line no-loss-of-precision\n  if (dot < 0.00174532836589830883577820272085) {\n    return undefined;\n  }\n  const distance = occluderRadius / dot;\n  return Cartesian3.add(occluderPosition, Cartesian3.multiplyByScalar(occluderPlaneNormal, distance, occludeePointScratch), occludeePointScratch);\n};\nconst computeOccludeePointFromRectangleScratch = [];\n/**\n * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.\n * @returns {object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n */\nOccluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, computeOccludeePointFromRectangleScratch);\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // Assumes the ellipsoid is centered at the origin\n  const ellipsoidCenter = Cartesian3.ZERO;\n  if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {\n    return Occluder.computeOccludeePoint(new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius), bs.center, positions);\n  }\n  return undefined;\n};\nconst tempVec0Scratch = new Cartesian3();\nOccluder._anyRotationVector = function (occluderPosition, occluderPlaneNormal, occluderPlaneD) {\n  const tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);\n  let majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;\n  if (majorAxis === 0 && tempVec0.z > tempVec0.x || majorAxis === 1 && tempVec0.z > tempVec0.y) {\n    majorAxis = 2;\n  }\n  const tempVec = new Cartesian3();\n  let tempVec1;\n  if (majorAxis === 0) {\n    tempVec0.x = occluderPosition.x;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_X;\n  } else if (majorAxis === 1) {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_Y;\n  } else {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z;\n    tempVec1 = Cartesian3.UNIT_Z;\n  }\n  const u = (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) / -Cartesian3.dot(occluderPlaneNormal, tempVec1);\n  return Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(tempVec0, Cartesian3.multiplyByScalar(tempVec1, u, tempVec), tempVec0), occluderPosition, tempVec0), tempVec0);\n};\nconst posDirectionScratch = new Cartesian3();\nOccluder._rotationVector = function (occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector) {\n  //Determine the angle between the occluder plane normal and the position direction\n  let positionDirection = Cartesian3.subtract(position, occluderPosition, posDirectionScratch);\n  positionDirection = Cartesian3.normalize(positionDirection, positionDirection);\n  if (Cartesian3.dot(occluderPlaneNormal, positionDirection) <\n  // eslint-disable-next-line no-loss-of-precision\n  0.99999998476912904932780850903444) {\n    const crossProduct = Cartesian3.cross(occluderPlaneNormal, positionDirection, positionDirection);\n    const length = Cartesian3.magnitude(crossProduct);\n    if (length > CesiumMath.EPSILON13) {\n      return Cartesian3.normalize(crossProduct, new Cartesian3());\n    }\n  }\n  //The occluder plane normal and the position direction are colinear. Use any\n  //vector in the occluder plane as the rotation vector\n  return anyRotationVector;\n};\nconst posScratch1 = new Cartesian3();\nconst occluerPosScratch = new Cartesian3();\nconst posScratch2 = new Cartesian3();\nconst horizonPlanePosScratch = new Cartesian3();\nOccluder._horizonToPlaneNormalDotProduct = function (occluderBS, occluderPlaneNormal, occluderPlaneD, anyRotationVector, position) {\n  const pos = Cartesian3.clone(position, posScratch1);\n  const occluderPosition = Cartesian3.clone(occluderBS.center, occluerPosScratch);\n  const occluderRadius = occluderBS.radius;\n\n  //Verify that the position is outside the occluder\n  let positionToOccluder = Cartesian3.subtract(occluderPosition, pos, posScratch2);\n  const occluderToPositionDistanceSquared = Cartesian3.magnitudeSquared(positionToOccluder);\n  const occluderRadiusSquared = occluderRadius * occluderRadius;\n  if (occluderToPositionDistanceSquared < occluderRadiusSquared) {\n    return false;\n  }\n\n  //Horizon parameters\n  const horizonDistanceSquared = occluderToPositionDistanceSquared - occluderRadiusSquared;\n  const horizonDistance = Math.sqrt(horizonDistanceSquared);\n  const occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);\n  const invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;\n  const cosTheta = horizonDistance * invOccluderToPositionDistance;\n  const horizonPlaneDistance = cosTheta * horizonDistance;\n  positionToOccluder = Cartesian3.normalize(positionToOccluder, positionToOccluder);\n  const horizonPlanePosition = Cartesian3.add(pos, Cartesian3.multiplyByScalar(positionToOccluder, horizonPlaneDistance, horizonPlanePosScratch), horizonPlanePosScratch);\n  const horizonCrossDistance = Math.sqrt(horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance);\n\n  //Rotate the position to occluder vector 90 degrees\n  let tempVec = this._rotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD, pos, anyRotationVector);\n  let horizonCrossDirection = Cartesian3.fromElements(tempVec.x * tempVec.x * positionToOccluder.x + (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y + (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z, (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x + tempVec.y * tempVec.y * positionToOccluder.y + (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z, (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x + (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y + tempVec.z * tempVec.z * positionToOccluder.z, posScratch1);\n  horizonCrossDirection = Cartesian3.normalize(horizonCrossDirection, horizonCrossDirection);\n\n  //Horizon positions\n  const offset = Cartesian3.multiplyByScalar(horizonCrossDirection, horizonCrossDistance, posScratch1);\n  tempVec = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(horizonPlanePosition, offset, posScratch2), occluderPosition, posScratch2), posScratch2);\n  const dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  tempVec = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.subtract(horizonPlanePosition, offset, tempVec), occluderPosition, tempVec), tempVec);\n  const dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  return dot0 < dot1 ? dot0 : dot1;\n};\nexport default Occluder;","map":{"version":3,"names":["BoundingSphere","Cartesian3","defaultValue","defined","DeveloperError","Ellipsoid","CesiumMath","Rectangle","Visibility","Occluder","occluderBoundingSphere","cameraPosition","_occluderPosition","clone","center","_occluderRadius","radius","_horizonDistance","_horizonPlaneNormal","undefined","_horizonPlanePosition","_cameraPosition","scratchCartesian3","Object","defineProperties","prototype","position","get","set","cameraToOccluderVec","subtract","invCameraToOccluderDistance","magnitudeSquared","occluderRadiusSqrd","horizonDistance","horizonPlaneNormal","horizonPlanePosition","Math","sqrt","multiplyByScalar","nearPlaneDistance","add","Number","MAX_VALUE","fromBoundingSphere","result","tempVecScratch","isPointVisible","occludee","tempVec","temp","occludeePositionScratch","isBoundingSphereVisible","occludeePosition","occludeeRadius","tempVecMagnitudeSquared","occluderRadiusSquared","occludeeRadiusSquared","tempScratch","computeVisibility","occludeeBS","FULL","occluderToOccludeeDistSqrd","cameraToOccludeeDistSqrd","NONE","PARTIAL","dot","occludeePointScratch","computeOccludeePoint","positions","length","occludeePos","occluderPosition","occluderRadius","numPositions","equals","occluderPlaneNormal","normalize","occluderPlaneD","aRotationVector","_anyRotationVector","_horizonToPlaneNormalDotProduct","tempDot","i","distance","computeOccludeePointFromRectangleScratch","computeOccludeePointFromRectangle","rectangle","ellipsoid","default","subsample","bs","fromPoints","ellipsoidCenter","ZERO","minimumRadius","tempVec0Scratch","tempVec0","abs","majorAxis","x","y","z","tempVec1","UNIT_X","UNIT_Y","UNIT_Z","u","posDirectionScratch","_rotationVector","anyRotationVector","positionDirection","crossProduct","cross","magnitude","EPSILON13","posScratch1","occluerPosScratch","posScratch2","horizonPlanePosScratch","occluderBS","pos","positionToOccluder","occluderToPositionDistanceSquared","horizonDistanceSquared","occluderToPositionDistance","invOccluderToPositionDistance","cosTheta","horizonPlaneDistance","horizonCrossDistance","horizonCrossDirection","fromElements","offset","dot0","dot1"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Occluder.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Visibility from \"./Visibility.js\";\n\n/**\n * Creates an Occluder derived from an object's position and radius, as well as the camera position.\n * The occluder can be used to determine whether or not other objects are visible or hidden behind the\n * visible horizon defined by the occluder and camera position.\n *\n * @alias Occluder\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n *\n * @constructor\n *\n * @example\n * // Construct an occluder one unit away from the origin with a radius of one.\n * const cameraPosition = Cesium.Cartesian3.ZERO;\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n */\nfunction Occluder(occluderBoundingSphere, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  this._occluderRadius = occluderBoundingSphere.radius;\n\n  this._horizonDistance = 0.0;\n  this._horizonPlaneNormal = undefined;\n  this._horizonPlanePosition = undefined;\n  this._cameraPosition = undefined;\n\n  // cameraPosition fills in the above values\n  this.cameraPosition = cameraPosition;\n}\n\nconst scratchCartesian3 = new Cartesian3();\n\nObject.defineProperties(Occluder.prototype, {\n  /**\n   * The position of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._occluderPosition;\n    },\n  },\n\n  /**\n   * The radius of the occluder.\n   * @memberof Occluder.prototype\n   * @type {number}\n   */\n  radius: {\n    get: function () {\n      return this._occluderRadius;\n    },\n  },\n\n  /**\n   * The position of the camera.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    set: function (cameraPosition) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(cameraPosition)) {\n        throw new DeveloperError(\"cameraPosition is required.\");\n      }\n      //>>includeEnd('debug');\n\n      cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);\n\n      const cameraToOccluderVec = Cartesian3.subtract(\n        this._occluderPosition,\n        cameraPosition,\n        scratchCartesian3,\n      );\n      let invCameraToOccluderDistance =\n        Cartesian3.magnitudeSquared(cameraToOccluderVec);\n      const occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;\n\n      let horizonDistance;\n      let horizonPlaneNormal;\n      let horizonPlanePosition;\n      if (invCameraToOccluderDistance > occluderRadiusSqrd) {\n        horizonDistance = Math.sqrt(\n          invCameraToOccluderDistance - occluderRadiusSqrd,\n        );\n        invCameraToOccluderDistance =\n          1.0 / Math.sqrt(invCameraToOccluderDistance);\n        horizonPlaneNormal = Cartesian3.multiplyByScalar(\n          cameraToOccluderVec,\n          invCameraToOccluderDistance,\n          scratchCartesian3,\n        );\n        const nearPlaneDistance =\n          horizonDistance * horizonDistance * invCameraToOccluderDistance;\n        horizonPlanePosition = Cartesian3.add(\n          cameraPosition,\n          Cartesian3.multiplyByScalar(\n            horizonPlaneNormal,\n            nearPlaneDistance,\n            scratchCartesian3,\n          ),\n          scratchCartesian3,\n        );\n      } else {\n        horizonDistance = Number.MAX_VALUE;\n      }\n\n      this._horizonDistance = horizonDistance;\n      this._horizonPlaneNormal = horizonPlaneNormal;\n      this._horizonPlanePosition = horizonPlanePosition;\n      this._cameraPosition = cameraPosition;\n    },\n  },\n});\n\n/**\n * Creates an occluder from a bounding sphere and the camera position.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n * @param {Occluder} [result] The object onto which to store the result.\n * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.\n */\nOccluder.fromBoundingSphere = function (\n  occluderBoundingSphere,\n  cameraPosition,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Occluder(occluderBoundingSphere, cameraPosition);\n  }\n\n  Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);\n  result._occluderRadius = occluderBoundingSphere.radius;\n  result.cameraPosition = cameraPosition;\n\n  return result;\n};\n\nconst tempVecScratch = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point surrounding the occludee object.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isPointVisible = function (occludee) {\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(\n      occludee,\n      this._occluderPosition,\n      tempVecScratch,\n    );\n    let temp = this._occluderRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (temp > 0.0) {\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);\n      return temp * temp > Cartesian3.magnitudeSquared(tempVec);\n    }\n  }\n  return false;\n};\n\nconst occludeePositionScratch = new Cartesian3();\n\n/**\n * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isBoundingSphereVisible = function (occludee) {\n  const occludeePosition = Cartesian3.clone(\n    occludee.center,\n    occludeePositionScratch,\n  );\n  const occludeeRadius = occludee.radius;\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempVecScratch,\n    );\n    let temp = this._occluderRadius - occludeeRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (occludeeRadius < this._occluderRadius) {\n      if (temp > 0.0) {\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        tempVec = Cartesian3.subtract(\n          occludeePosition,\n          this._cameraPosition,\n          tempVec,\n        );\n        return (\n          temp * temp + occludeeRadius * occludeeRadius >\n          Cartesian3.magnitudeSquared(tempVec)\n        );\n      }\n      return false;\n    }\n\n    // Prevent against the case where the occludee radius is larger than the occluder's; since this is\n    // an uncommon case, the following code should rarely execute.\n    if (temp > 0.0) {\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec,\n      );\n      const tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);\n      const occluderRadiusSquared = this._occluderRadius * this._occluderRadius;\n      const occludeeRadiusSquared = occludeeRadius * occludeeRadius;\n      if (\n        (this._horizonDistance * this._horizonDistance +\n          occluderRadiusSquared) *\n          occludeeRadiusSquared >\n        tempVecMagnitudeSquared * occluderRadiusSquared\n      ) {\n        // The occludee is close enough that the occluder cannot possible occlude the occludee\n        return true;\n      }\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;\n    }\n\n    // The occludee completely encompasses the occluder\n    return true;\n  }\n\n  return false;\n};\n\nconst tempScratch = new Cartesian3();\n/**\n * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).\n *\n * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.\n * @returns {Visibility} Visibility.NONE if the occludee is not visible,\n *                       Visibility.PARTIAL if the occludee is partially visible, or\n *                       Visibility.FULL if the occludee is fully visible.\n *\n *\n * @example\n * const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE\n */\nOccluder.prototype.computeVisibility = function (occludeeBS) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occludeeBS)) {\n    throw new DeveloperError(\"occludeeBS is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // If the occludee radius is larger than the occluders, this will return that\n  // the entire ocludee is visible, even though that may not be the case, though this should\n  // not occur too often.\n  const occludeePosition = Cartesian3.clone(occludeeBS.center);\n  const occludeeRadius = occludeeBS.radius;\n\n  if (occludeeRadius > this._occluderRadius) {\n    return Visibility.FULL;\n  }\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    // The camera is outside the occluder\n    let tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempScratch,\n    );\n    let temp = this._occluderRadius - occludeeRadius;\n    const occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n    temp = occluderToOccludeeDistSqrd - temp * temp;\n    if (temp > 0.0) {\n      // The occludee is not completely inside the occluder\n      // Check to see if the occluder completely hides the occludee\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec,\n      );\n      const cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n      if (\n        temp * temp + occludeeRadius * occludeeRadius <\n        cameraToOccludeeDistSqrd\n      ) {\n        return Visibility.NONE;\n      }\n\n      // Check to see whether the occluder is fully or partially visible\n      // when the occludee does not intersect the occluder\n      temp = this._occluderRadius + occludeeRadius;\n      temp = occluderToOccludeeDistSqrd - temp * temp;\n      if (temp > 0.0) {\n        // The occludee does not intersect the occluder.\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        return cameraToOccludeeDistSqrd <\n          temp * temp + occludeeRadius * occludeeRadius\n          ? Visibility.FULL\n          : Visibility.PARTIAL;\n      }\n\n      //Check to see if the occluder is fully or partially visible when the occludee DOES\n      //intersect the occluder\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._horizonPlanePosition,\n        tempVec,\n      );\n      return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius\n        ? Visibility.PARTIAL\n        : Visibility.FULL;\n    }\n  }\n  return Visibility.NONE;\n};\n\nconst occludeePointScratch = new Cartesian3();\n/**\n * Computes a point that can be used as the occludee position to the visibility functions.\n * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around\n * an object that is used for visibility; however it is also possible to compute a point that if\n * seen/not seen would also indicate if an object is visible/not visible.  This function is better\n * called for objects that do not move relative to the occluder and is large, such as a chunk of\n * terrain.  You are better off not calling this and using the object's bounding sphere for objects\n * such as a satellite or ground vehicle.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.\n * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.\n * @returns {object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n *\n * @exception {DeveloperError} <code>positions</code> must contain at least one element.\n * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * const occludeePosition = tileOccluderSphere.center;\n * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);\n */\nOccluder.computeOccludeePoint = function (\n  occluderBoundingSphere,\n  occludeePosition,\n  positions,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  if (positions.length === 0) {\n    throw new DeveloperError(\"positions must contain at least one element\");\n  }\n  //>>includeEnd('debug');\n\n  const occludeePos = Cartesian3.clone(occludeePosition);\n  const occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  const occluderRadius = occluderBoundingSphere.radius;\n  const numPositions = positions.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Cartesian3.equals(occluderPosition, occludeePosition)) {\n    throw new DeveloperError(\n      \"occludeePosition must be different than occluderBoundingSphere.center\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Compute a plane with a normal from the occluder to the occludee position.\n  const occluderPlaneNormal = Cartesian3.normalize(\n    Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch),\n    occludeePointScratch,\n  );\n  const occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition);\n\n  //For each position, determine the horizon intersection. Choose the position and intersection\n  //that results in the greatest angle with the occcluder plane.\n  const aRotationVector = Occluder._anyRotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD,\n  );\n  let dot = Occluder._horizonToPlaneNormalDotProduct(\n    occluderBoundingSphere,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    aRotationVector,\n    positions[0],\n  );\n  if (!dot) {\n    //The position is inside the mimimum radius, which is invalid\n    return undefined;\n  }\n  let tempDot;\n  for (let i = 1; i < numPositions; ++i) {\n    tempDot = Occluder._horizonToPlaneNormalDotProduct(\n      occluderBoundingSphere,\n      occluderPlaneNormal,\n      occluderPlaneD,\n      aRotationVector,\n      positions[i],\n    );\n    if (!tempDot) {\n      //The position is inside the minimum radius, which is invalid\n      return undefined;\n    }\n    if (tempDot < dot) {\n      dot = tempDot;\n    }\n  }\n  //Verify that the dot is not near 90 degress\n  // eslint-disable-next-line no-loss-of-precision\n  if (dot < 0.00174532836589830883577820272085) {\n    return undefined;\n  }\n\n  const distance = occluderRadius / dot;\n  return Cartesian3.add(\n    occluderPosition,\n    Cartesian3.multiplyByScalar(\n      occluderPlaneNormal,\n      distance,\n      occludeePointScratch,\n    ),\n    occludeePointScratch,\n  );\n};\n\nconst computeOccludeePointFromRectangleScratch = [];\n/**\n * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.\n * @returns {object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n */\nOccluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    computeOccludeePointFromRectangleScratch,\n  );\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // Assumes the ellipsoid is centered at the origin\n  const ellipsoidCenter = Cartesian3.ZERO;\n  if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {\n    return Occluder.computeOccludeePoint(\n      new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius),\n      bs.center,\n      positions,\n    );\n  }\n\n  return undefined;\n};\n\nconst tempVec0Scratch = new Cartesian3();\nOccluder._anyRotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD,\n) {\n  const tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);\n  let majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;\n  if (\n    (majorAxis === 0 && tempVec0.z > tempVec0.x) ||\n    (majorAxis === 1 && tempVec0.z > tempVec0.y)\n  ) {\n    majorAxis = 2;\n  }\n  const tempVec = new Cartesian3();\n  let tempVec1;\n  if (majorAxis === 0) {\n    tempVec0.x = occluderPosition.x;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_X;\n  } else if (majorAxis === 1) {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_Y;\n  } else {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z;\n    tempVec1 = Cartesian3.UNIT_Z;\n  }\n  const u =\n    (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) /\n    -Cartesian3.dot(occluderPlaneNormal, tempVec1);\n  return Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(\n        tempVec0,\n        Cartesian3.multiplyByScalar(tempVec1, u, tempVec),\n        tempVec0,\n      ),\n      occluderPosition,\n      tempVec0,\n    ),\n    tempVec0,\n  );\n};\n\nconst posDirectionScratch = new Cartesian3();\nOccluder._rotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  position,\n  anyRotationVector,\n) {\n  //Determine the angle between the occluder plane normal and the position direction\n  let positionDirection = Cartesian3.subtract(\n    position,\n    occluderPosition,\n    posDirectionScratch,\n  );\n  positionDirection = Cartesian3.normalize(\n    positionDirection,\n    positionDirection,\n  );\n  if (\n    Cartesian3.dot(occluderPlaneNormal, positionDirection) <\n    // eslint-disable-next-line no-loss-of-precision\n    0.99999998476912904932780850903444\n  ) {\n    const crossProduct = Cartesian3.cross(\n      occluderPlaneNormal,\n      positionDirection,\n      positionDirection,\n    );\n    const length = Cartesian3.magnitude(crossProduct);\n    if (length > CesiumMath.EPSILON13) {\n      return Cartesian3.normalize(crossProduct, new Cartesian3());\n    }\n  }\n  //The occluder plane normal and the position direction are colinear. Use any\n  //vector in the occluder plane as the rotation vector\n  return anyRotationVector;\n};\n\nconst posScratch1 = new Cartesian3();\nconst occluerPosScratch = new Cartesian3();\nconst posScratch2 = new Cartesian3();\nconst horizonPlanePosScratch = new Cartesian3();\nOccluder._horizonToPlaneNormalDotProduct = function (\n  occluderBS,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  anyRotationVector,\n  position,\n) {\n  const pos = Cartesian3.clone(position, posScratch1);\n  const occluderPosition = Cartesian3.clone(\n    occluderBS.center,\n    occluerPosScratch,\n  );\n  const occluderRadius = occluderBS.radius;\n\n  //Verify that the position is outside the occluder\n  let positionToOccluder = Cartesian3.subtract(\n    occluderPosition,\n    pos,\n    posScratch2,\n  );\n  const occluderToPositionDistanceSquared =\n    Cartesian3.magnitudeSquared(positionToOccluder);\n  const occluderRadiusSquared = occluderRadius * occluderRadius;\n  if (occluderToPositionDistanceSquared < occluderRadiusSquared) {\n    return false;\n  }\n\n  //Horizon parameters\n  const horizonDistanceSquared =\n    occluderToPositionDistanceSquared - occluderRadiusSquared;\n  const horizonDistance = Math.sqrt(horizonDistanceSquared);\n  const occluderToPositionDistance = Math.sqrt(\n    occluderToPositionDistanceSquared,\n  );\n  const invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;\n  const cosTheta = horizonDistance * invOccluderToPositionDistance;\n  const horizonPlaneDistance = cosTheta * horizonDistance;\n  positionToOccluder = Cartesian3.normalize(\n    positionToOccluder,\n    positionToOccluder,\n  );\n  const horizonPlanePosition = Cartesian3.add(\n    pos,\n    Cartesian3.multiplyByScalar(\n      positionToOccluder,\n      horizonPlaneDistance,\n      horizonPlanePosScratch,\n    ),\n    horizonPlanePosScratch,\n  );\n  const horizonCrossDistance = Math.sqrt(\n    horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance,\n  );\n\n  //Rotate the position to occluder vector 90 degrees\n  let tempVec = this._rotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    pos,\n    anyRotationVector,\n  );\n  let horizonCrossDirection = Cartesian3.fromElements(\n    tempVec.x * tempVec.x * positionToOccluder.x +\n      (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y +\n      (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z,\n    (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x +\n      tempVec.y * tempVec.y * positionToOccluder.y +\n      (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z,\n    (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x +\n      (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y +\n      tempVec.z * tempVec.z * positionToOccluder.z,\n    posScratch1,\n  );\n  horizonCrossDirection = Cartesian3.normalize(\n    horizonCrossDirection,\n    horizonCrossDirection,\n  );\n\n  //Horizon positions\n  const offset = Cartesian3.multiplyByScalar(\n    horizonCrossDirection,\n    horizonCrossDistance,\n    posScratch1,\n  );\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(horizonPlanePosition, offset, posScratch2),\n      occluderPosition,\n      posScratch2,\n    ),\n    posScratch2,\n  );\n  const dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.subtract(horizonPlanePosition, offset, tempVec),\n      occluderPosition,\n      tempVec,\n    ),\n    tempVec,\n  );\n  const dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  return dot0 < dot1 ? dot0 : dot1;\n};\nexport default Occluder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}