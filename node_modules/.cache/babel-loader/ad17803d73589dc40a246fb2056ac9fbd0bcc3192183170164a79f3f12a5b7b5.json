{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Cylinder defines (set in Scene/VoxelCylinderShape.js)\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_RADIUS\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED\\n\\\n*/\\n\\\n\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)\\n\\\n    uniform vec2 u_cylinderUvToShapeUvRadius; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)\\n\\\n    uniform vec2 u_cylinderUvToShapeUvHeight; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n    uniform vec2 u_cylinderUvToShapeUvAngle; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY)\\n\\\n    uniform vec2 u_cylinderShapeUvAngleMinMax;\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED)\\n\\\n    uniform float u_cylinderShapeUvAngleRangeZeroMid;\\n\\\n#endif\\n\\\n\\n\\\nPointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {\\n\\\n    // Convert from Cartesian UV space [0, 1] to Cartesian local space [-1, 1]\\n\\\n    vec3 position = positionUv * 2.0 - 1.0;\\n\\\n\\n\\\n    float radius = length(position.xy); // [0, 1]\\n\\\n    vec3 radial = normalize(vec3(position.xy, 0.0));\\n\\\n\\n\\\n    // Shape space height is defined within [0, 1]\\n\\\n    float height = positionUv.z; // [0, 1]\\n\\\n    vec3 z = vec3(0.0, 0.0, 1.0);\\n\\\n\\n\\\n    float angle = atan(position.y, position.x);\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n\\n\\\n    vec3 point = vec3(radius, height, angle);\\n\\\n    mat3 jacobianT = mat3(radial, z, east / length(position.xy));\\n\\\n    return PointJacobianT(point, jacobianT);\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeToShapeUvSpace(in vec3 positionShape) {\\n\\\n    float radius = positionShape.x;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)\\n\\\n        radius = radius * u_cylinderUvToShapeUvRadius.x + u_cylinderUvToShapeUvRadius.y;\\n\\\n    #endif\\n\\\n\\n\\\n    float height = positionShape.y;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)\\n\\\n        height = height * u_cylinderUvToShapeUvHeight.x + u_cylinderUvToShapeUvHeight.y;\\n\\\n    #endif\\n\\\n\\n\\\n    float angle = (positionShape.z + czm_pi) / czm_twoPi;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n        #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED)\\n\\\n            // Comparing against u_cylinderShapeUvAngleMinMax has precision problems. u_cylinderShapeUvAngleRangeZeroMid is more conservative.\\n\\\n            angle += float(angle < u_cylinderShapeUvAngleRangeZeroMid);\\n\\\n        #endif\\n\\\n\\n\\\n        // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity.\\n\\\n        #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY)\\n\\\n            angle = angle > u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.x : angle;\\n\\\n        #elif defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY)\\n\\\n            angle = angle < u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.y : angle;\\n\\\n        #endif\\n\\\n\\n\\\n        angle = angle * u_cylinderUvToShapeUvAngle.x + u_cylinderUvToShapeUvAngle.y;\\n\\\n    #endif\\n\\\n\\n\\\n    return vec3(radius, height, angle);\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);\\n\\\n    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);\\n\\\n    return pointJacobian;\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    float radius = shapeUv.x;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)\\n\\\n        radius /= u_cylinderUvToShapeUvRadius.x;\\n\\\n    #endif\\n\\\n\\n\\\n    float height = shapeUv.y;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)\\n\\\n        height /= u_cylinderUvToShapeUvHeight.x;\\n\\\n    #endif\\n\\\n\\n\\\n    float angle = shapeUv.z * czm_twoPi;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n        angle /= u_cylinderUvToShapeUvAngle.x;\\n\\\n    #endif\\n\\\n\\n\\\n    return vec3(radius, height, angle);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/convertUvToCylinder.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Cylinder defines (set in Scene/VoxelCylinderShape.js)\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_RADIUS\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY\\n\\\n#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED\\n\\\n*/\\n\\\n\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)\\n\\\n    uniform vec2 u_cylinderUvToShapeUvRadius; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)\\n\\\n    uniform vec2 u_cylinderUvToShapeUvHeight; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n    uniform vec2 u_cylinderUvToShapeUvAngle; // x = scale, y = offset\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY)\\n\\\n    uniform vec2 u_cylinderShapeUvAngleMinMax;\\n\\\n#endif\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED)\\n\\\n    uniform float u_cylinderShapeUvAngleRangeZeroMid;\\n\\\n#endif\\n\\\n\\n\\\nPointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {\\n\\\n    // Convert from Cartesian UV space [0, 1] to Cartesian local space [-1, 1]\\n\\\n    vec3 position = positionUv * 2.0 - 1.0;\\n\\\n\\n\\\n    float radius = length(position.xy); // [0, 1]\\n\\\n    vec3 radial = normalize(vec3(position.xy, 0.0));\\n\\\n\\n\\\n    // Shape space height is defined within [0, 1]\\n\\\n    float height = positionUv.z; // [0, 1]\\n\\\n    vec3 z = vec3(0.0, 0.0, 1.0);\\n\\\n\\n\\\n    float angle = atan(position.y, position.x);\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n\\n\\\n    vec3 point = vec3(radius, height, angle);\\n\\\n    mat3 jacobianT = mat3(radial, z, east / length(position.xy));\\n\\\n    return PointJacobianT(point, jacobianT);\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeToShapeUvSpace(in vec3 positionShape) {\\n\\\n    float radius = positionShape.x;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)\\n\\\n        radius = radius * u_cylinderUvToShapeUvRadius.x + u_cylinderUvToShapeUvRadius.y;\\n\\\n    #endif\\n\\\n\\n\\\n    float height = positionShape.y;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)\\n\\\n        height = height * u_cylinderUvToShapeUvHeight.x + u_cylinderUvToShapeUvHeight.y;\\n\\\n    #endif\\n\\\n\\n\\\n    float angle = (positionShape.z + czm_pi) / czm_twoPi;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n        #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED)\\n\\\n            // Comparing against u_cylinderShapeUvAngleMinMax has precision problems. u_cylinderShapeUvAngleRangeZeroMid is more conservative.\\n\\\n            angle += float(angle < u_cylinderShapeUvAngleRangeZeroMid);\\n\\\n        #endif\\n\\\n\\n\\\n        // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity.\\n\\\n        #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY)\\n\\\n            angle = angle > u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.x : angle;\\n\\\n        #elif defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY)\\n\\\n            angle = angle < u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.y : angle;\\n\\\n        #endif\\n\\\n\\n\\\n        angle = angle * u_cylinderUvToShapeUvAngle.x + u_cylinderUvToShapeUvAngle.y;\\n\\\n    #endif\\n\\\n\\n\\\n    return vec3(radius, height, angle);\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);\\n\\\n    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);\\n\\\n    return pointJacobian;\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    float radius = shapeUv.x;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)\\n\\\n        radius /= u_cylinderUvToShapeUvRadius.x;\\n\\\n    #endif\\n\\\n\\n\\\n    float height = shapeUv.y;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)\\n\\\n        height /= u_cylinderUvToShapeUvHeight.x;\\n\\\n    #endif\\n\\\n\\n\\\n    float angle = shapeUv.z * czm_twoPi;\\n\\\n    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n        angle /= u_cylinderUvToShapeUvAngle.x;\\n\\\n    #endif\\n\\\n\\n\\\n    return vec3(radius, height, angle);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}