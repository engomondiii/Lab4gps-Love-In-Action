{"ast":null,"code":"import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport defined from \"../../Core/defined.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport WireframeIndexGenerator from \"../../Core/WireframeIndexGenerator.js\";\n\n/**\n * The wireframe pipeline stage generates a new index buffer for rendering the\n * structure of the mesh with gl.LINES.\n *\n * @namespace WireframePipelineStage\n * @private\n */\nconst WireframePipelineStage = {\n  name: \"WireframePipelineStage\" // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the render resources as follows:\n * <ul>\n *   <li>Adds a define to the fragment shader to prevent extra shading of the lines.</li>\n *   <li>Adds a separate index buffer for wireframe indices</li>\n *   <li>Updates the primitive type and count for rendering with gl.LINES</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this node\n * @param {ModelComponents.primitive} primitive The primitive\n * @param {FrameState} frameState The frame state\n */\nWireframePipelineStage.process = function (renderResources, primitive, frameState) {\n  // Applying normal mapping to the lines will result in rendering\n  // errors on Linux. This define is added to disable normal\n  // mapping in the shader.\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_WIREFRAME\", undefined, ShaderDestination.FRAGMENT);\n  const model = renderResources.model;\n  const wireframeIndexBuffer = createWireframeIndexBuffer(primitive, renderResources.indices, frameState);\n  model._pipelineResources.push(wireframeIndexBuffer);\n  renderResources.wireframeIndexBuffer = wireframeIndexBuffer;\n\n  // We only need to count memory for the generated buffer. In WebGL 1, the CPU\n  // copy of the original indices is already counted in the geometry stage,\n  // and in WebGL 2, the CPU copy of the original indices (generated from the\n  // data of the original buffer) is discarded after generating the wireframe\n  // indices.\n  const hasCpuCopy = false;\n  model.statistics.addBuffer(wireframeIndexBuffer, hasCpuCopy);\n\n  // Update render resources so we render LINES with the correct index count\n  const originalPrimitiveType = renderResources.primitiveType;\n  const originalCount = renderResources.count;\n  renderResources.primitiveType = PrimitiveType.LINES;\n  renderResources.count = WireframeIndexGenerator.getWireframeIndicesCount(originalPrimitiveType, originalCount);\n};\nfunction createWireframeIndexBuffer(primitive, indices, frameState) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.POSITION);\n  const vertexCount = positionAttribute.count;\n  const webgl2 = frameState.context.webgl2;\n  let originalIndices;\n  if (defined(indices)) {\n    const indicesBuffer = indices.buffer;\n    const indicesCount = indices.count;\n    if (defined(indicesBuffer) && webgl2) {\n      const useUint8Array = indicesBuffer.sizeInBytes === indicesCount;\n      originalIndices = useUint8Array ? new Uint8Array(indicesCount) : IndexDatatype.createTypedArray(vertexCount, indicesCount);\n      indicesBuffer.getBufferData(originalIndices);\n    } else {\n      originalIndices = indices.typedArray;\n    }\n  }\n  const primitiveType = primitive.primitiveType;\n  const wireframeIndices = WireframeIndexGenerator.createWireframeIndices(primitiveType, vertexCount, originalIndices);\n  const indexDatatype = IndexDatatype.fromSizeInBytes(wireframeIndices.BYTES_PER_ELEMENT);\n  return Buffer.createIndexBuffer({\n    context: frameState.context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype\n  });\n}\nexport default WireframePipelineStage;","map":{"version":3,"names":["Buffer","BufferUsage","defined","IndexDatatype","ModelUtility","PrimitiveType","ShaderDestination","VertexAttributeSemantic","WireframeIndexGenerator","WireframePipelineStage","name","process","renderResources","primitive","frameState","shaderBuilder","addDefine","undefined","FRAGMENT","model","wireframeIndexBuffer","createWireframeIndexBuffer","indices","_pipelineResources","push","hasCpuCopy","statistics","addBuffer","originalPrimitiveType","primitiveType","originalCount","count","LINES","getWireframeIndicesCount","positionAttribute","getAttributeBySemantic","POSITION","vertexCount","webgl2","context","originalIndices","indicesBuffer","buffer","indicesCount","useUint8Array","sizeInBytes","Uint8Array","createTypedArray","getBufferData","typedArray","wireframeIndices","createWireframeIndices","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","createIndexBuffer","usage","STATIC_DRAW"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/WireframePipelineStage.js"],"sourcesContent":["import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport defined from \"../../Core/defined.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport WireframeIndexGenerator from \"../../Core/WireframeIndexGenerator.js\";\n\n/**\n * The wireframe pipeline stage generates a new index buffer for rendering the\n * structure of the mesh with gl.LINES.\n *\n * @namespace WireframePipelineStage\n * @private\n */\nconst WireframePipelineStage = {\n  name: \"WireframePipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the render resources as follows:\n * <ul>\n *   <li>Adds a define to the fragment shader to prevent extra shading of the lines.</li>\n *   <li>Adds a separate index buffer for wireframe indices</li>\n *   <li>Updates the primitive type and count for rendering with gl.LINES</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this node\n * @param {ModelComponents.primitive} primitive The primitive\n * @param {FrameState} frameState The frame state\n */\nWireframePipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  // Applying normal mapping to the lines will result in rendering\n  // errors on Linux. This define is added to disable normal\n  // mapping in the shader.\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\n    \"HAS_WIREFRAME\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const model = renderResources.model;\n  const wireframeIndexBuffer = createWireframeIndexBuffer(\n    primitive,\n    renderResources.indices,\n    frameState,\n  );\n  model._pipelineResources.push(wireframeIndexBuffer);\n  renderResources.wireframeIndexBuffer = wireframeIndexBuffer;\n\n  // We only need to count memory for the generated buffer. In WebGL 1, the CPU\n  // copy of the original indices is already counted in the geometry stage,\n  // and in WebGL 2, the CPU copy of the original indices (generated from the\n  // data of the original buffer) is discarded after generating the wireframe\n  // indices.\n  const hasCpuCopy = false;\n  model.statistics.addBuffer(wireframeIndexBuffer, hasCpuCopy);\n\n  // Update render resources so we render LINES with the correct index count\n  const originalPrimitiveType = renderResources.primitiveType;\n  const originalCount = renderResources.count;\n  renderResources.primitiveType = PrimitiveType.LINES;\n  renderResources.count = WireframeIndexGenerator.getWireframeIndicesCount(\n    originalPrimitiveType,\n    originalCount,\n  );\n};\n\nfunction createWireframeIndexBuffer(primitive, indices, frameState) {\n  const positionAttribute = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION,\n  );\n  const vertexCount = positionAttribute.count;\n  const webgl2 = frameState.context.webgl2;\n\n  let originalIndices;\n  if (defined(indices)) {\n    const indicesBuffer = indices.buffer;\n    const indicesCount = indices.count;\n    if (defined(indicesBuffer) && webgl2) {\n      const useUint8Array = indicesBuffer.sizeInBytes === indicesCount;\n      originalIndices = useUint8Array\n        ? new Uint8Array(indicesCount)\n        : IndexDatatype.createTypedArray(vertexCount, indicesCount);\n\n      indicesBuffer.getBufferData(originalIndices);\n    } else {\n      originalIndices = indices.typedArray;\n    }\n  }\n\n  const primitiveType = primitive.primitiveType;\n  const wireframeIndices = WireframeIndexGenerator.createWireframeIndices(\n    primitiveType,\n    vertexCount,\n    originalIndices,\n  );\n  const indexDatatype = IndexDatatype.fromSizeInBytes(\n    wireframeIndices.BYTES_PER_ELEMENT,\n  );\n\n  return Buffer.createIndexBuffer({\n    context: frameState.context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n}\n\nexport default WireframePipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}