{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\n\n/**\n * A metadata property, as part of a {@link MetadataClass}.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.id The ID of the property.\n * @param {MetadataType} options.type The type of the property such as SCALAR, VEC2, VEC3.\n * @param {MetadataComponentType} [options.componentType] The component type of the property. This includes integer (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values.\n * @param {MetadataEnum} [options.enumType] The enum type of the property. Only defined when type is ENUM.\n * @param {boolean} [options.isArray=false] True if a property is an array (either fixed length or variable length), false otherwise.\n * @param {boolean} [options.isVariableLengthArray=false] True if a property is a variable length array, false otherwise.\n * @param {number} [options.arrayLength] The number of array elements. Only defined for fixed length arrays.\n * @param {boolean} [options.normalized=false] Whether the property is normalized.\n * @param {number|number[]|number[][]} [options.min] A number or an array of numbers storing the minimum allowable value of this property. Only defined when type is a numeric type.\n * @param {number|number[]|number[][]} [options.max] A number or an array of numbers storing the maximum allowable value of this property. Only defined when type is a numeric type.\n * @param {number|number[]|number[][]} [options.offset] The offset to be added to property values as part of the value transform.\n * @param {number|number[]|number[][]} [options.scale] The scale to be multiplied to property values as part of the value transform.\n * @param {boolean|number|string|Array} [options.noData] The no-data sentinel value that represents null values.\n * @param {boolean|number|string|Array} [options.default] A default value to use when an entity's property value is not defined.\n * @param {boolean} [options.required=false] Whether the property is required.\n * @param {string} [options.name] The name of the property.\n * @param {string} [options.description] The description of the property.\n * @param {string} [options.semantic] An identifier that describes how this property should be interpreted.\n * @param {*} [options.extras] Extra user-defined properties.\n * @param {object} [options.extensions] An object containing extensions.\n *\n * @alias MetadataClassProperty\n * @constructor\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataClassProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const type = options.type;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.string(\"options.type\", type);\n  //>>includeEnd('debug');\n\n  const componentType = options.componentType;\n  const enumType = options.enumType;\n  const normalized = defined(componentType) && MetadataComponentType.isIntegerType(componentType) && defaultValue(options.normalized, false);\n\n  // Basic information about this property\n  this._id = id;\n  this._name = options.name;\n  this._description = options.description;\n  this._semantic = options.semantic;\n\n  // Only for unit testing purposes, not documented in the API\n  this._isLegacyExtension = options.isLegacyExtension;\n\n  // Details about basic types\n  this._type = type;\n  this._componentType = componentType;\n  this._enumType = enumType;\n  this._valueType = defined(enumType) ? enumType.valueType : componentType;\n\n  // Details about arrays\n  this._isArray = defaultValue(options.isArray, false);\n  this._isVariableLengthArray = defaultValue(options.isVariableLengthArray, false);\n  this._arrayLength = options.arrayLength;\n\n  // min and max allowed values\n  this._min = clone(options.min, true);\n  this._max = clone(options.max, true);\n\n  // properties that adjust the range of metadata values\n  this._normalized = normalized;\n  let offset = clone(options.offset, true);\n  let scale = clone(options.scale, true);\n  const hasValueTransform = defined(offset) || defined(scale);\n  const enableNestedArrays = true;\n  if (!defined(offset)) {\n    offset = this.expandConstant(0, enableNestedArrays);\n  }\n  if (!defined(scale)) {\n    scale = this.expandConstant(1, enableNestedArrays);\n  }\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n\n  // sentinel value for missing data, and a default value to use\n  // in its place if needed.\n  this._noData = clone(options.noData, true);\n  // For vector and array types, this is stored as an array of values.\n  this._default = clone(options.default, true);\n  this._required = defaultValue(options.required, true);\n\n  // extras and extensions\n  this._extras = clone(options.extras, true);\n  this._extensions = clone(options.extensions, true);\n}\n\n/**\n * Creates a {@link MetadataClassProperty} from either 3D Tiles 1.1, 3DTILES_metadata, EXT_structural_metadata, or EXT_feature_metadata.\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.id The ID of the property.\n * @param {object} options.property The property JSON object.\n * @param {Object<string, MetadataEnum>} [options.enums] A dictionary of enums.\n *\n * @returns {MetadataClassProperty} The newly created metadata class property.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nMetadataClassProperty.fromJson = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const property = options.property;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.string(\"options.property.type\", property.type);\n  //>>includeEnd('debug');\n\n  // Try to determine if this is the legacy extension. This is not\n  // always possible, as there are some types that are valid in both\n  // extensions.\n  const isLegacyExtension = isLegacy(property);\n  const parsedType = parseType(property, options.enums);\n\n  // EXT_feature_metadata had an optional flag, while EXT_structural_metadata\n  // has a required flag. The defaults are not the same, and there's some cases\n  // like {type: BOOLEAN} that are ambiguous. Coalesce this into a single\n  // required flag\n  let required;\n  if (!defined(isLegacyExtension)) {\n    // Impossible to tell which extension was used, so don't require\n    // the property\n    required = false;\n  } else if (isLegacyExtension) {\n    required = defined(property.optional) ? !property.optional : true;\n  } else {\n    required = defaultValue(property.required, false);\n  }\n  return new MetadataClassProperty({\n    id: id,\n    type: parsedType.type,\n    componentType: parsedType.componentType,\n    enumType: parsedType.enumType,\n    isArray: parsedType.isArray,\n    isVariableLengthArray: parsedType.isVariableLengthArray,\n    arrayLength: parsedType.arrayLength,\n    normalized: property.normalized,\n    min: property.min,\n    max: property.max,\n    offset: property.offset,\n    scale: property.scale,\n    noData: property.noData,\n    default: property.default,\n    required: required,\n    name: property.name,\n    description: property.description,\n    semantic: property.semantic,\n    extras: property.extras,\n    extensions: property.extensions,\n    isLegacyExtension: isLegacyExtension\n  });\n};\nObject.defineProperties(MetadataClassProperty.prototype, {\n  /**\n   * The ID of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * The name of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * The description of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  description: {\n    get: function () {\n      return this._description;\n    }\n  },\n  /**\n   * The type of the property such as SCALAR, VEC2, VEC3\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataType}\n   * @readonly\n   */\n  type: {\n    get: function () {\n      return this._type;\n    }\n  },\n  /**\n   * The enum type of the property. Only defined when type is ENUM.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataEnum}\n   * @readonly\n   */\n  enumType: {\n    get: function () {\n      return this._enumType;\n    }\n  },\n  /**\n   * The component type of the property. This includes integer\n   * (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   */\n  componentType: {\n    get: function () {\n      return this._componentType;\n    }\n  },\n  /**\n   * The datatype used for storing each component of the property. This\n   * is usually the same as componentType except for ENUM, where this\n   * returns an integer type\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   * @private\n   */\n  valueType: {\n    get: function () {\n      return this._valueType;\n    }\n  },\n  /**\n   * True if a property is an array (either fixed length or variable length),\n   * false otherwise.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isArray: {\n    get: function () {\n      return this._isArray;\n    }\n  },\n  /**\n   * True if a property is a variable length array, false otherwise.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isVariableLengthArray: {\n    get: function () {\n      return this._isVariableLengthArray;\n    }\n  },\n  /**\n   * The number of array elements. Only defined for fixed-size\n   * arrays.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number}\n   * @readonly\n   */\n  arrayLength: {\n    get: function () {\n      return this._arrayLength;\n    }\n  },\n  /**\n   * Whether the property is normalized.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  normalized: {\n    get: function () {\n      return this._normalized;\n    }\n  },\n  /**\n   * A number or an array of numbers storing the maximum allowable value of this property. Only defined when type is a numeric type.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  max: {\n    get: function () {\n      return this._max;\n    }\n  },\n  /**\n   * A number or an array of numbers storing the minimum allowable value of this property. Only defined when type is a numeric type.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  min: {\n    get: function () {\n      return this._min;\n    }\n  },\n  /**\n   * The no-data sentinel value that represents null values\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean|number|string|Array}\n   * @readonly\n   */\n  noData: {\n    get: function () {\n      return this._noData;\n    }\n  },\n  /**\n   * A default value to use when an entity's property value is not defined.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean|number|string|Array}\n   * @readonly\n   */\n  default: {\n    get: function () {\n      return this._default;\n    }\n  },\n  /**\n   * Whether the property is required.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  required: {\n    get: function () {\n      return this._required;\n    }\n  },\n  /**\n   * An identifier that describes how this property should be interpreted.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  semantic: {\n    get: function () {\n      return this._semantic;\n    }\n  },\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    }\n  },\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the class property JSON itself did not define it, then it will be\n   * initialized to the default value.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    }\n  },\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the class property JSON itself did not define it, then it will be\n   * initialized to the default value.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    }\n  },\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {*}\n   * @readonly\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    }\n  },\n  /**\n   * An object containing extensions.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {object}\n   * @readonly\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    }\n  }\n});\nfunction isLegacy(property) {\n  if (property.type === \"ARRAY\") {\n    return true;\n  }\n\n  // New property types in EXT_structural_metadata\n  const type = property.type;\n  if (type === MetadataType.SCALAR || MetadataType.isMatrixType(type) || MetadataType.isVectorType(type)) {\n    return false;\n  }\n\n  // EXT_feature_metadata allowed numeric types as a type. Now they are\n  // represented as {type: SINGLE, componentType: type}\n  if (defined(MetadataComponentType[type])) {\n    return true;\n  }\n\n  // New properties in EXT_structural_metadata\n  if (defined(property.noData) || defined(property.scale) || defined(property.offset) || defined(property.required) || defined(property.count) || defined(property.array)) {\n    return false;\n  }\n\n  // Properties that only exist in EXT_feature_metadata\n  if (defined(property.optional)) {\n    return false;\n  }\n\n  // impossible to tell, give up.\n  return undefined;\n}\nfunction parseType(property, enums) {\n  const type = property.type;\n  const componentType = property.componentType;\n\n  // EXT_feature_metadata had an ARRAY type. This is now handled\n  // with array + count, so some details need to be transcoded\n  const isLegacyArray = type === \"ARRAY\";\n  let isArray;\n  let arrayLength;\n  let isVariableLengthArray;\n  if (isLegacyArray) {\n    // definitely EXT_feature_metadata\n    isArray = true;\n    arrayLength = property.componentCount;\n    isVariableLengthArray = !defined(arrayLength);\n  } else if (property.array) {\n    isArray = true;\n    arrayLength = property.count;\n    isVariableLengthArray = !defined(property.count);\n  } else {\n    // Could be either extension. Some cases are impossible to distinguish\n    // Default to a single value\n    isArray = false;\n    arrayLength = undefined;\n    isVariableLengthArray = false;\n  }\n  let enumType;\n  if (defined(property.enumType)) {\n    enumType = enums[property.enumType];\n  }\n\n  // In both EXT_feature_metadata and EXT_structural_metadata, ENUM appears\n  // as a type.\n  if (type === MetadataType.ENUM) {\n    return {\n      type: type,\n      componentType: undefined,\n      enumType: enumType,\n      valueType: enumType.valueType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  // In EXT_feature_metadata, ENUM also appears as an ARRAY componentType\n  if (isLegacyArray && componentType === MetadataType.ENUM) {\n    return {\n      type: componentType,\n      componentType: undefined,\n      enumType: enumType,\n      valueType: enumType.valueType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  // EXT_structural_metadata only: SCALAR, VECN and MATN\n  if (type === MetadataType.SCALAR || MetadataType.isMatrixType(type) || MetadataType.isVectorType(type)) {\n    return {\n      type: type,\n      componentType: componentType,\n      enumType: undefined,\n      valueType: componentType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  // In both EXT_structural_metadata and EXT_feature_metadata,\n  // BOOLEAN and STRING appear as types\n  if (type === MetadataType.BOOLEAN || type === MetadataType.STRING) {\n    return {\n      type: type,\n      componentType: undefined,\n      enumType: undefined,\n      valueType: undefined,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  // EXT_feature_metadata also allows BOOLEAN and STRING as an ARRAY\n  // componentType\n  if (isLegacyArray && (componentType === MetadataType.BOOLEAN || componentType === MetadataType.STRING)) {\n    return {\n      type: componentType,\n      componentType: undefined,\n      enumType: undefined,\n      valueType: undefined,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  // Both EXT_feature_metadata and EXT_structural_metadata allow numeric types like\n  // INT32 or FLOAT64 as a componentType.\n  if (defined(componentType) && defined(MetadataComponentType[componentType])) {\n    return {\n      type: MetadataType.SCALAR,\n      componentType: componentType,\n      enumType: undefined,\n      valueType: componentType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  // EXT_feature_metadata: integer and float types were allowed as types,\n  // but now these are expressed as {type: SCALAR, componentType: type}\n  if (defined(MetadataComponentType[type])) {\n    return {\n      type: MetadataType.SCALAR,\n      componentType: type,\n      enumType: undefined,\n      valueType: type,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength\n    };\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(`unknown metadata type {type: ${type}, componentType: ${componentType})`);\n  //>>includeEnd('debug');\n}\n\n/**\n * Normalizes integer property values. If the property is not normalized\n * the value is returned unmodified.\n * <p>\n * Given the way normalization is defined in {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#normalized-values|the 3D Metadata Specification},\n * normalize and unnormalize are almost, but not quite inverses. In particular,\n * the smallest signed integer value will be off by one after normalizing and\n * unnormalizing. See\n * {@link https://www.desmos.com/calculator/nledg1evut|this Desmos graph} for\n * an example using INT8.\n * </p>\n * <p>\n * Furthermore, for 64-bit integer types, there may be a loss of precision\n * due to conversion to Number\n * </p>\n *\n * @param {*} value The integer value or array of integer values.\n * @returns {*} The normalized value or array of normalized values.\n *\n * @private\n */\nMetadataClassProperty.prototype.normalize = function (value) {\n  if (!this._normalized) {\n    return value;\n  }\n  return normalizeInPlace(value, this._valueType, MetadataComponentType.normalize);\n};\n\n/**\n * Unnormalizes integer property values. If the property is not normalized\n * the value is returned unmodified.\n * <p>\n * Given the way normalization is defined in {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#normalized-values|the 3D Metadata Specification},\n * normalize and unnormalize are almost, but not quite inverses. In particular,\n * the smallest signed integer value will be off by one after normalizing and\n * unnormalizing. See\n * {@link https://www.desmos.com/calculator/nledg1evut|this Desmos graph} for\n * an example using INT8.\n * </p>\n * <p>\n * Furthermore, for 64-bit integer types, there may be a loss of precision\n * due to conversion to Number\n * </p>\n *\n * @param {*} value The normalized value or array of normalized values.\n * @returns {*} The integer value or array of integer values.\n *\n * @private\n */\nMetadataClassProperty.prototype.unnormalize = function (value) {\n  if (!this._normalized) {\n    return value;\n  }\n  return normalizeInPlace(value, this._valueType, MetadataComponentType.unnormalize);\n};\n\n/**\n * @private\n */\nMetadataClassProperty.prototype.applyValueTransform = function (value) {\n  // variable length arrays do not have a well-defined offset/scale so this\n  // is forbidden by the spec\n  if (!this._hasValueTransform || this._isVariableLengthArray) {\n    return value;\n  }\n  return MetadataClassProperty.valueTransformInPlace(value, this._offset, this._scale, MetadataComponentType.applyValueTransform);\n};\n\n/**\n * @private\n */\nMetadataClassProperty.prototype.unapplyValueTransform = function (value) {\n  // variable length arrays do not have a well-defined offset/scale so this\n  // is forbidden by the spec\n  if (!this._hasValueTransform || this._isVariableLengthArray) {\n    return value;\n  }\n  return MetadataClassProperty.valueTransformInPlace(value, this._offset, this._scale, MetadataComponentType.unapplyValueTransform);\n};\n\n/**\n * @private\n */\nMetadataClassProperty.prototype.expandConstant = function (constant, enableNestedArrays) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const isArray = this._isArray;\n  const arrayLength = this._arrayLength;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  // scalar values can be returned directly\n  if (!isArray && componentCount === 1) {\n    return constant;\n  }\n\n  // vector and matrix values\n  if (!isArray) {\n    return new Array(componentCount).fill(constant);\n  }\n\n  // arrays of scalars\n  if (!isNested) {\n    return new Array(arrayLength).fill(constant);\n  }\n\n  // arrays of vectors/matrices: flattened\n  if (!enableNestedArrays) {\n    return new Array(this._arrayLength * componentCount).fill(constant);\n  }\n\n  // array of vectors/matrices: nested\n  const innerConstant = new Array(componentCount).fill(constant);\n  // This array fill duplicates the pointer to the inner arrays. Since this is\n  // intended for use with constants, no need to clone the array.\n  return new Array(this._arrayLength).fill(innerConstant);\n};\n\n/**\n * If the value is the noData sentinel, return undefined. Otherwise, return\n * the value.\n * @param {*} value The raw value\n * @returns {*} Either the value or undefined if the value was a no data value.\n *\n * @private\n */\nMetadataClassProperty.prototype.handleNoData = function (value) {\n  const sentinel = this._noData;\n  if (!defined(sentinel)) {\n    return value;\n  }\n  if (arrayEquals(value, sentinel)) {\n    return undefined;\n  }\n  return value;\n};\nfunction arrayEquals(left, right) {\n  if (!Array.isArray(left)) {\n    return left === right;\n  }\n  if (!Array.isArray(right)) {\n    return false;\n  }\n  if (left.length !== right.length) {\n    return false;\n  }\n  for (let i = 0; i < left.length; i++) {\n    if (!arrayEquals(left[i], right[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Unpack VECN values into {@link Cartesian2}, {@link Cartesian3}, or\n * {@link Cartesian4} and MATN values into {@link Matrix2}, {@link Matrix3}, or\n * {@link Matrix4} depending on N. All other values (including arrays of\n * other sizes) are passed through unaltered.\n *\n * @param {*} value the original, normalized values.\n * @param {boolean} [enableNestedArrays=false] If true, arrays of vectors are represented as nested arrays. This is used for JSON encoding but not binary encoding\n * @returns {*} The appropriate vector or matrix type if the value is a vector or matrix type, respectively. If the property is an array of vectors or matrices, an array of the appropriate vector or matrix type is returned. Otherwise, the value is returned unaltered.\n * @private\n */\nMetadataClassProperty.prototype.unpackVectorAndMatrixTypes = function (value, enableNestedArrays) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const MathType = MetadataType.getMathType(this._type);\n  const isArray = this._isArray;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n  if (!defined(MathType)) {\n    return value;\n  }\n  if (enableNestedArrays && isNested) {\n    return value.map(function (x) {\n      return MathType.unpack(x);\n    });\n  }\n  if (isArray) {\n    return MathType.unpackArray(value);\n  }\n  return MathType.unpack(value);\n};\n\n/**\n * Pack a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} into an\n * array if this property is an <code>VECN</code>.\n * Pack a {@link Matrix2}, {@link Matrix3}, or {@link Matrix4} into an\n * array if this property is an <code>MATN</code>.\n * All other values (including arrays of other sizes) are passed through unaltered.\n *\n * @param {*} value The value of this property\n * @param {boolean} [enableNestedArrays=false] If true, arrays of vectors are represented as nested arrays. This is used for JSON encoding but not binary encoding\n * @returns {*} An array of the appropriate length if the property is a vector or matrix type. Otherwise, the value is returned unaltered.\n * @private\n */\nMetadataClassProperty.prototype.packVectorAndMatrixTypes = function (value, enableNestedArrays) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const MathType = MetadataType.getMathType(this._type);\n  const isArray = this._isArray;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n  if (!defined(MathType)) {\n    return value;\n  }\n  if (enableNestedArrays && isNested) {\n    return value.map(function (x) {\n      return MathType.pack(x, []);\n    });\n  }\n  if (isArray) {\n    return MathType.packArray(value, []);\n  }\n  return MathType.pack(value, []);\n};\n\n/**\n * Validates whether the given value conforms to the property.\n *\n * @param {*} value The value.\n * @returns {string|undefined} An error message if the value does not conform to the property, otherwise undefined.\n * @private\n */\nMetadataClassProperty.prototype.validate = function (value) {\n  if (!defined(value) && defined(this._default)) {\n    // no value, but we have a default to use.\n    return undefined;\n  }\n  if (this._required && !defined(value)) {\n    return `required property must have a value`;\n  }\n  if (this._isArray) {\n    return validateArray(this, value);\n  }\n  return validateSingleValue(this, value);\n};\nfunction validateArray(classProperty, value) {\n  if (!Array.isArray(value)) {\n    return `value ${value} must be an array`;\n  }\n  const length = value.length;\n  if (!classProperty._isVariableLengthArray && length !== classProperty._arrayLength) {\n    return \"Array length does not match property.arrayLength\";\n  }\n  for (let i = 0; i < length; i++) {\n    const message = validateSingleValue(classProperty, value[i]);\n    if (defined(message)) {\n      return message;\n    }\n  }\n}\nfunction validateSingleValue(classProperty, value) {\n  const type = classProperty._type;\n  const componentType = classProperty._componentType;\n  const enumType = classProperty._enumType;\n  const normalized = classProperty._normalized;\n  if (MetadataType.isVectorType(type)) {\n    return validateVector(value, type, componentType);\n  } else if (MetadataType.isMatrixType(type)) {\n    return validateMatrix(value, type, componentType);\n  } else if (type === MetadataType.STRING) {\n    return validateString(value);\n  } else if (type === MetadataType.BOOLEAN) {\n    return validateBoolean(value);\n  } else if (type === MetadataType.ENUM) {\n    return validateEnum(value, enumType);\n  }\n  return validateScalar(value, componentType, normalized);\n}\nfunction validateVector(value, type, componentType) {\n  if (!MetadataComponentType.isVectorCompatible(componentType)) {\n    return `componentType ${componentType} is incompatible with vector type ${type}`;\n  }\n  if (type === MetadataType.VEC2 && !(value instanceof Cartesian2)) {\n    return `vector value ${value} must be a Cartesian2`;\n  }\n  if (type === MetadataType.VEC3 && !(value instanceof Cartesian3)) {\n    return `vector value ${value} must be a Cartesian3`;\n  }\n  if (type === MetadataType.VEC4 && !(value instanceof Cartesian4)) {\n    return `vector value ${value} must be a Cartesian4`;\n  }\n}\nfunction validateMatrix(value, type, componentType) {\n  if (!MetadataComponentType.isVectorCompatible(componentType)) {\n    return `componentType ${componentType} is incompatible with matrix type ${type}`;\n  }\n  if (type === MetadataType.MAT2 && !(value instanceof Matrix2)) {\n    return `matrix value ${value} must be a Matrix2`;\n  }\n  if (type === MetadataType.MAT3 && !(value instanceof Matrix3)) {\n    return `matrix value ${value} must be a Matrix3`;\n  }\n  if (type === MetadataType.MAT4 && !(value instanceof Matrix4)) {\n    return `matrix value ${value} must be a Matrix4`;\n  }\n}\nfunction validateString(value) {\n  if (typeof value !== \"string\") {\n    return getTypeErrorMessage(value, MetadataType.STRING);\n  }\n}\nfunction validateBoolean(value) {\n  if (typeof value !== \"boolean\") {\n    return getTypeErrorMessage(value, MetadataType.BOOLEAN);\n  }\n}\nfunction validateEnum(value, enumType) {\n  const javascriptType = typeof value;\n  if (defined(enumType)) {\n    if (javascriptType !== \"string\" || !defined(enumType.valuesByName[value])) {\n      return `value ${value} is not a valid enum name for ${enumType.id}`;\n    }\n    return;\n  }\n}\nfunction validateScalar(value, componentType, normalized) {\n  const javascriptType = typeof value;\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      if (javascriptType !== \"number\") {\n        return getTypeErrorMessage(value, componentType);\n      }\n      if (!isFinite(value)) {\n        return getNonFiniteErrorMessage(value, componentType);\n      }\n      return checkInRange(value, componentType, normalized);\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      if (javascriptType !== \"number\" && javascriptType !== \"bigint\") {\n        return getTypeErrorMessage(value, componentType);\n      }\n      if (javascriptType === \"number\" && !isFinite(value)) {\n        return getNonFiniteErrorMessage(value, componentType);\n      }\n      return checkInRange(value, componentType, normalized);\n  }\n}\nfunction getTypeErrorMessage(value, type) {\n  return `value ${value} does not match type ${type}`;\n}\nfunction getOutOfRangeErrorMessage(value, type, normalized) {\n  let errorMessage = `value ${value} is out of range for type ${type}`;\n  if (normalized) {\n    errorMessage += \" (normalized)\";\n  }\n  return errorMessage;\n}\nfunction checkInRange(value, componentType, normalized) {\n  if (normalized) {\n    const min = MetadataComponentType.isUnsignedIntegerType(componentType) ? 0.0 : -1.0;\n    const max = 1.0;\n    if (value < min || value > max) {\n      return getOutOfRangeErrorMessage(value, componentType, normalized);\n    }\n    return;\n  }\n  if (value < MetadataComponentType.getMinimum(componentType) || value > MetadataComponentType.getMaximum(componentType)) {\n    return getOutOfRangeErrorMessage(value, componentType, normalized);\n  }\n}\nfunction getNonFiniteErrorMessage(value, type) {\n  return `value ${value} of type ${type} must be finite`;\n}\nfunction normalizeInPlace(values, valueType, normalizeFunction) {\n  if (!Array.isArray(values)) {\n    return normalizeFunction(values, valueType);\n  }\n  for (let i = 0; i < values.length; i++) {\n    values[i] = normalizeInPlace(values[i], valueType, normalizeFunction);\n  }\n  return values;\n}\n\n/**\n * Applies the value transform that is defined with the given offsets\n * and scales to the given values.\n *\n * If the given values are not an array, then the given transformation\n * function will be applied directly.\n *\n * If the values are an array, then this function will be called recursively\n * with the array elements, boiling down to a component-wise application\n * of the transformation function to the innermost array elements.\n *\n * @param {number|number[]|number[][]} values The input values\n * @param {number|number[]|number[][]} offsets The offsets\n * @param {number|number[]|number[][]} scales The scales\n * @param {Function} transformationFunction The function with the signature\n * `(value:number, offset:number, scale:number) : number` that will be\n * applied to the innermost elements\n * @returns The input values (or the result of applying the transformation\n * function to a single value if the values have not been an array).\n * @private\n */\nMetadataClassProperty.valueTransformInPlace = function (values, offsets, scales, transformationFunction) {\n  if (!Array.isArray(values)) {\n    // transform a single value\n    return transformationFunction(values, offsets, scales);\n  }\n  for (let i = 0; i < values.length; i++) {\n    // offsets and scales must be the same array shape as values.\n    values[i] = MetadataClassProperty.valueTransformInPlace(values[i], offsets[i], scales[i], transformationFunction);\n  }\n  return values;\n};\nexport default MetadataClassProperty;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Check","clone","defaultValue","defined","DeveloperError","Matrix2","Matrix3","Matrix4","MetadataType","MetadataComponentType","MetadataClassProperty","options","EMPTY_OBJECT","id","type","typeOf","string","componentType","enumType","normalized","isIntegerType","_id","_name","name","_description","description","_semantic","semantic","_isLegacyExtension","isLegacyExtension","_type","_componentType","_enumType","_valueType","valueType","_isArray","isArray","_isVariableLengthArray","isVariableLengthArray","_arrayLength","arrayLength","_min","min","_max","max","_normalized","offset","scale","hasValueTransform","enableNestedArrays","expandConstant","_offset","_scale","_hasValueTransform","_noData","noData","_default","default","_required","required","_extras","extras","_extensions","extensions","fromJson","property","object","isLegacy","parsedType","parseType","enums","optional","Object","defineProperties","prototype","get","SCALAR","isMatrixType","isVectorType","count","array","undefined","isLegacyArray","componentCount","ENUM","BOOLEAN","STRING","normalize","value","normalizeInPlace","unnormalize","applyValueTransform","valueTransformInPlace","unapplyValueTransform","constant","getComponentCount","isNested","Array","fill","innerConstant","handleNoData","sentinel","arrayEquals","left","right","length","i","unpackVectorAndMatrixTypes","MathType","getMathType","map","x","unpack","unpackArray","packVectorAndMatrixTypes","pack","packArray","validate","validateArray","validateSingleValue","classProperty","message","validateVector","validateMatrix","validateString","validateBoolean","validateEnum","validateScalar","isVectorCompatible","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","getTypeErrorMessage","javascriptType","valuesByName","INT8","UINT8","INT16","UINT16","INT32","UINT32","FLOAT32","FLOAT64","isFinite","getNonFiniteErrorMessage","checkInRange","INT64","UINT64","getOutOfRangeErrorMessage","errorMessage","isUnsignedIntegerType","getMinimum","getMaximum","values","normalizeFunction","offsets","scales","transformationFunction"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/MetadataClassProperty.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\n\n/**\n * A metadata property, as part of a {@link MetadataClass}.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.id The ID of the property.\n * @param {MetadataType} options.type The type of the property such as SCALAR, VEC2, VEC3.\n * @param {MetadataComponentType} [options.componentType] The component type of the property. This includes integer (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values.\n * @param {MetadataEnum} [options.enumType] The enum type of the property. Only defined when type is ENUM.\n * @param {boolean} [options.isArray=false] True if a property is an array (either fixed length or variable length), false otherwise.\n * @param {boolean} [options.isVariableLengthArray=false] True if a property is a variable length array, false otherwise.\n * @param {number} [options.arrayLength] The number of array elements. Only defined for fixed length arrays.\n * @param {boolean} [options.normalized=false] Whether the property is normalized.\n * @param {number|number[]|number[][]} [options.min] A number or an array of numbers storing the minimum allowable value of this property. Only defined when type is a numeric type.\n * @param {number|number[]|number[][]} [options.max] A number or an array of numbers storing the maximum allowable value of this property. Only defined when type is a numeric type.\n * @param {number|number[]|number[][]} [options.offset] The offset to be added to property values as part of the value transform.\n * @param {number|number[]|number[][]} [options.scale] The scale to be multiplied to property values as part of the value transform.\n * @param {boolean|number|string|Array} [options.noData] The no-data sentinel value that represents null values.\n * @param {boolean|number|string|Array} [options.default] A default value to use when an entity's property value is not defined.\n * @param {boolean} [options.required=false] Whether the property is required.\n * @param {string} [options.name] The name of the property.\n * @param {string} [options.description] The description of the property.\n * @param {string} [options.semantic] An identifier that describes how this property should be interpreted.\n * @param {*} [options.extras] Extra user-defined properties.\n * @param {object} [options.extensions] An object containing extensions.\n *\n * @alias MetadataClassProperty\n * @constructor\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataClassProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const type = options.type;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.string(\"options.type\", type);\n  //>>includeEnd('debug');\n\n  const componentType = options.componentType;\n  const enumType = options.enumType;\n\n  const normalized =\n    defined(componentType) &&\n    MetadataComponentType.isIntegerType(componentType) &&\n    defaultValue(options.normalized, false);\n\n  // Basic information about this property\n  this._id = id;\n  this._name = options.name;\n  this._description = options.description;\n  this._semantic = options.semantic;\n\n  // Only for unit testing purposes, not documented in the API\n  this._isLegacyExtension = options.isLegacyExtension;\n\n  // Details about basic types\n  this._type = type;\n  this._componentType = componentType;\n  this._enumType = enumType;\n  this._valueType = defined(enumType) ? enumType.valueType : componentType;\n\n  // Details about arrays\n  this._isArray = defaultValue(options.isArray, false);\n  this._isVariableLengthArray = defaultValue(\n    options.isVariableLengthArray,\n    false,\n  );\n  this._arrayLength = options.arrayLength;\n\n  // min and max allowed values\n  this._min = clone(options.min, true);\n  this._max = clone(options.max, true);\n\n  // properties that adjust the range of metadata values\n  this._normalized = normalized;\n\n  let offset = clone(options.offset, true);\n  let scale = clone(options.scale, true);\n  const hasValueTransform = defined(offset) || defined(scale);\n\n  const enableNestedArrays = true;\n  if (!defined(offset)) {\n    offset = this.expandConstant(0, enableNestedArrays);\n  }\n\n  if (!defined(scale)) {\n    scale = this.expandConstant(1, enableNestedArrays);\n  }\n\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n\n  // sentinel value for missing data, and a default value to use\n  // in its place if needed.\n  this._noData = clone(options.noData, true);\n  // For vector and array types, this is stored as an array of values.\n  this._default = clone(options.default, true);\n\n  this._required = defaultValue(options.required, true);\n\n  // extras and extensions\n  this._extras = clone(options.extras, true);\n  this._extensions = clone(options.extensions, true);\n}\n\n/**\n * Creates a {@link MetadataClassProperty} from either 3D Tiles 1.1, 3DTILES_metadata, EXT_structural_metadata, or EXT_feature_metadata.\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.id The ID of the property.\n * @param {object} options.property The property JSON object.\n * @param {Object<string, MetadataEnum>} [options.enums] A dictionary of enums.\n *\n * @returns {MetadataClassProperty} The newly created metadata class property.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nMetadataClassProperty.fromJson = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const property = options.property;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.string(\"options.property.type\", property.type);\n  //>>includeEnd('debug');\n\n  // Try to determine if this is the legacy extension. This is not\n  // always possible, as there are some types that are valid in both\n  // extensions.\n  const isLegacyExtension = isLegacy(property);\n  const parsedType = parseType(property, options.enums);\n\n  // EXT_feature_metadata had an optional flag, while EXT_structural_metadata\n  // has a required flag. The defaults are not the same, and there's some cases\n  // like {type: BOOLEAN} that are ambiguous. Coalesce this into a single\n  // required flag\n  let required;\n  if (!defined(isLegacyExtension)) {\n    // Impossible to tell which extension was used, so don't require\n    // the property\n    required = false;\n  } else if (isLegacyExtension) {\n    required = defined(property.optional) ? !property.optional : true;\n  } else {\n    required = defaultValue(property.required, false);\n  }\n\n  return new MetadataClassProperty({\n    id: id,\n    type: parsedType.type,\n    componentType: parsedType.componentType,\n    enumType: parsedType.enumType,\n    isArray: parsedType.isArray,\n    isVariableLengthArray: parsedType.isVariableLengthArray,\n    arrayLength: parsedType.arrayLength,\n    normalized: property.normalized,\n    min: property.min,\n    max: property.max,\n    offset: property.offset,\n    scale: property.scale,\n    noData: property.noData,\n    default: property.default,\n    required: required,\n    name: property.name,\n    description: property.description,\n    semantic: property.semantic,\n    extras: property.extras,\n    extensions: property.extensions,\n    isLegacyExtension: isLegacyExtension,\n  });\n};\n\nObject.defineProperties(MetadataClassProperty.prototype, {\n  /**\n   * The ID of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * The name of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The description of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  description: {\n    get: function () {\n      return this._description;\n    },\n  },\n\n  /**\n   * The type of the property such as SCALAR, VEC2, VEC3\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataType}\n   * @readonly\n   */\n  type: {\n    get: function () {\n      return this._type;\n    },\n  },\n\n  /**\n   * The enum type of the property. Only defined when type is ENUM.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataEnum}\n   * @readonly\n   */\n  enumType: {\n    get: function () {\n      return this._enumType;\n    },\n  },\n\n  /**\n   * The component type of the property. This includes integer\n   * (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   */\n  componentType: {\n    get: function () {\n      return this._componentType;\n    },\n  },\n\n  /**\n   * The datatype used for storing each component of the property. This\n   * is usually the same as componentType except for ENUM, where this\n   * returns an integer type\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   * @private\n   */\n  valueType: {\n    get: function () {\n      return this._valueType;\n    },\n  },\n\n  /**\n   * True if a property is an array (either fixed length or variable length),\n   * false otherwise.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isArray: {\n    get: function () {\n      return this._isArray;\n    },\n  },\n\n  /**\n   * True if a property is a variable length array, false otherwise.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isVariableLengthArray: {\n    get: function () {\n      return this._isVariableLengthArray;\n    },\n  },\n\n  /**\n   * The number of array elements. Only defined for fixed-size\n   * arrays.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number}\n   * @readonly\n   */\n  arrayLength: {\n    get: function () {\n      return this._arrayLength;\n    },\n  },\n\n  /**\n   * Whether the property is normalized.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  normalized: {\n    get: function () {\n      return this._normalized;\n    },\n  },\n\n  /**\n   * A number or an array of numbers storing the maximum allowable value of this property. Only defined when type is a numeric type.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  max: {\n    get: function () {\n      return this._max;\n    },\n  },\n\n  /**\n   * A number or an array of numbers storing the minimum allowable value of this property. Only defined when type is a numeric type.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  min: {\n    get: function () {\n      return this._min;\n    },\n  },\n\n  /**\n   * The no-data sentinel value that represents null values\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean|number|string|Array}\n   * @readonly\n   */\n  noData: {\n    get: function () {\n      return this._noData;\n    },\n  },\n\n  /**\n   * A default value to use when an entity's property value is not defined.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean|number|string|Array}\n   * @readonly\n   */\n  default: {\n    get: function () {\n      return this._default;\n    },\n  },\n\n  /**\n   * Whether the property is required.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  required: {\n    get: function () {\n      return this._required;\n    },\n  },\n\n  /**\n   * An identifier that describes how this property should be interpreted.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {string}\n   * @readonly\n   */\n  semantic: {\n    get: function () {\n      return this._semantic;\n    },\n  },\n\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the class property JSON itself did not define it, then it will be\n   * initialized to the default value.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the class property JSON itself did not define it, then it will be\n   * initialized to the default value.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {number|number[]|number[][]}\n   * @readonly\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {*}\n   * @readonly\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * An object containing extensions.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {object}\n   * @readonly\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nfunction isLegacy(property) {\n  if (property.type === \"ARRAY\") {\n    return true;\n  }\n\n  // New property types in EXT_structural_metadata\n  const type = property.type;\n  if (\n    type === MetadataType.SCALAR ||\n    MetadataType.isMatrixType(type) ||\n    MetadataType.isVectorType(type)\n  ) {\n    return false;\n  }\n\n  // EXT_feature_metadata allowed numeric types as a type. Now they are\n  // represented as {type: SINGLE, componentType: type}\n  if (defined(MetadataComponentType[type])) {\n    return true;\n  }\n\n  // New properties in EXT_structural_metadata\n  if (\n    defined(property.noData) ||\n    defined(property.scale) ||\n    defined(property.offset) ||\n    defined(property.required) ||\n    defined(property.count) ||\n    defined(property.array)\n  ) {\n    return false;\n  }\n\n  // Properties that only exist in EXT_feature_metadata\n  if (defined(property.optional)) {\n    return false;\n  }\n\n  // impossible to tell, give up.\n  return undefined;\n}\n\nfunction parseType(property, enums) {\n  const type = property.type;\n  const componentType = property.componentType;\n\n  // EXT_feature_metadata had an ARRAY type. This is now handled\n  // with array + count, so some details need to be transcoded\n  const isLegacyArray = type === \"ARRAY\";\n  let isArray;\n  let arrayLength;\n  let isVariableLengthArray;\n  if (isLegacyArray) {\n    // definitely EXT_feature_metadata\n    isArray = true;\n    arrayLength = property.componentCount;\n    isVariableLengthArray = !defined(arrayLength);\n  } else if (property.array) {\n    isArray = true;\n    arrayLength = property.count;\n    isVariableLengthArray = !defined(property.count);\n  } else {\n    // Could be either extension. Some cases are impossible to distinguish\n    // Default to a single value\n    isArray = false;\n    arrayLength = undefined;\n    isVariableLengthArray = false;\n  }\n\n  let enumType;\n  if (defined(property.enumType)) {\n    enumType = enums[property.enumType];\n  }\n\n  // In both EXT_feature_metadata and EXT_structural_metadata, ENUM appears\n  // as a type.\n  if (type === MetadataType.ENUM) {\n    return {\n      type: type,\n      componentType: undefined,\n      enumType: enumType,\n      valueType: enumType.valueType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // In EXT_feature_metadata, ENUM also appears as an ARRAY componentType\n  if (isLegacyArray && componentType === MetadataType.ENUM) {\n    return {\n      type: componentType,\n      componentType: undefined,\n      enumType: enumType,\n      valueType: enumType.valueType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // EXT_structural_metadata only: SCALAR, VECN and MATN\n  if (\n    type === MetadataType.SCALAR ||\n    MetadataType.isMatrixType(type) ||\n    MetadataType.isVectorType(type)\n  ) {\n    return {\n      type: type,\n      componentType: componentType,\n      enumType: undefined,\n      valueType: componentType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // In both EXT_structural_metadata and EXT_feature_metadata,\n  // BOOLEAN and STRING appear as types\n  if (type === MetadataType.BOOLEAN || type === MetadataType.STRING) {\n    return {\n      type: type,\n      componentType: undefined,\n      enumType: undefined,\n      valueType: undefined,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // EXT_feature_metadata also allows BOOLEAN and STRING as an ARRAY\n  // componentType\n  if (\n    isLegacyArray &&\n    (componentType === MetadataType.BOOLEAN ||\n      componentType === MetadataType.STRING)\n  ) {\n    return {\n      type: componentType,\n      componentType: undefined,\n      enumType: undefined,\n      valueType: undefined,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // Both EXT_feature_metadata and EXT_structural_metadata allow numeric types like\n  // INT32 or FLOAT64 as a componentType.\n  if (defined(componentType) && defined(MetadataComponentType[componentType])) {\n    return {\n      type: MetadataType.SCALAR,\n      componentType: componentType,\n      enumType: undefined,\n      valueType: componentType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // EXT_feature_metadata: integer and float types were allowed as types,\n  // but now these are expressed as {type: SCALAR, componentType: type}\n  if (defined(MetadataComponentType[type])) {\n    return {\n      type: MetadataType.SCALAR,\n      componentType: type,\n      enumType: undefined,\n      valueType: type,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    `unknown metadata type {type: ${type}, componentType: ${componentType})`,\n  );\n  //>>includeEnd('debug');\n}\n\n/**\n * Normalizes integer property values. If the property is not normalized\n * the value is returned unmodified.\n * <p>\n * Given the way normalization is defined in {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#normalized-values|the 3D Metadata Specification},\n * normalize and unnormalize are almost, but not quite inverses. In particular,\n * the smallest signed integer value will be off by one after normalizing and\n * unnormalizing. See\n * {@link https://www.desmos.com/calculator/nledg1evut|this Desmos graph} for\n * an example using INT8.\n * </p>\n * <p>\n * Furthermore, for 64-bit integer types, there may be a loss of precision\n * due to conversion to Number\n * </p>\n *\n * @param {*} value The integer value or array of integer values.\n * @returns {*} The normalized value or array of normalized values.\n *\n * @private\n */\nMetadataClassProperty.prototype.normalize = function (value) {\n  if (!this._normalized) {\n    return value;\n  }\n\n  return normalizeInPlace(\n    value,\n    this._valueType,\n    MetadataComponentType.normalize,\n  );\n};\n\n/**\n * Unnormalizes integer property values. If the property is not normalized\n * the value is returned unmodified.\n * <p>\n * Given the way normalization is defined in {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#normalized-values|the 3D Metadata Specification},\n * normalize and unnormalize are almost, but not quite inverses. In particular,\n * the smallest signed integer value will be off by one after normalizing and\n * unnormalizing. See\n * {@link https://www.desmos.com/calculator/nledg1evut|this Desmos graph} for\n * an example using INT8.\n * </p>\n * <p>\n * Furthermore, for 64-bit integer types, there may be a loss of precision\n * due to conversion to Number\n * </p>\n *\n * @param {*} value The normalized value or array of normalized values.\n * @returns {*} The integer value or array of integer values.\n *\n * @private\n */\nMetadataClassProperty.prototype.unnormalize = function (value) {\n  if (!this._normalized) {\n    return value;\n  }\n\n  return normalizeInPlace(\n    value,\n    this._valueType,\n    MetadataComponentType.unnormalize,\n  );\n};\n\n/**\n * @private\n */\nMetadataClassProperty.prototype.applyValueTransform = function (value) {\n  // variable length arrays do not have a well-defined offset/scale so this\n  // is forbidden by the spec\n  if (!this._hasValueTransform || this._isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    this._offset,\n    this._scale,\n    MetadataComponentType.applyValueTransform,\n  );\n};\n\n/**\n * @private\n */\nMetadataClassProperty.prototype.unapplyValueTransform = function (value) {\n  // variable length arrays do not have a well-defined offset/scale so this\n  // is forbidden by the spec\n  if (!this._hasValueTransform || this._isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    this._offset,\n    this._scale,\n    MetadataComponentType.unapplyValueTransform,\n  );\n};\n\n/**\n * @private\n */\nMetadataClassProperty.prototype.expandConstant = function (\n  constant,\n  enableNestedArrays,\n) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const isArray = this._isArray;\n  const arrayLength = this._arrayLength;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  // scalar values can be returned directly\n  if (!isArray && componentCount === 1) {\n    return constant;\n  }\n\n  // vector and matrix values\n  if (!isArray) {\n    return new Array(componentCount).fill(constant);\n  }\n\n  // arrays of scalars\n  if (!isNested) {\n    return new Array(arrayLength).fill(constant);\n  }\n\n  // arrays of vectors/matrices: flattened\n  if (!enableNestedArrays) {\n    return new Array(this._arrayLength * componentCount).fill(constant);\n  }\n\n  // array of vectors/matrices: nested\n  const innerConstant = new Array(componentCount).fill(constant);\n  // This array fill duplicates the pointer to the inner arrays. Since this is\n  // intended for use with constants, no need to clone the array.\n  return new Array(this._arrayLength).fill(innerConstant);\n};\n\n/**\n * If the value is the noData sentinel, return undefined. Otherwise, return\n * the value.\n * @param {*} value The raw value\n * @returns {*} Either the value or undefined if the value was a no data value.\n *\n * @private\n */\nMetadataClassProperty.prototype.handleNoData = function (value) {\n  const sentinel = this._noData;\n  if (!defined(sentinel)) {\n    return value;\n  }\n\n  if (arrayEquals(value, sentinel)) {\n    return undefined;\n  }\n\n  return value;\n};\n\nfunction arrayEquals(left, right) {\n  if (!Array.isArray(left)) {\n    return left === right;\n  }\n\n  if (!Array.isArray(right)) {\n    return false;\n  }\n\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    if (!arrayEquals(left[i], right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Unpack VECN values into {@link Cartesian2}, {@link Cartesian3}, or\n * {@link Cartesian4} and MATN values into {@link Matrix2}, {@link Matrix3}, or\n * {@link Matrix4} depending on N. All other values (including arrays of\n * other sizes) are passed through unaltered.\n *\n * @param {*} value the original, normalized values.\n * @param {boolean} [enableNestedArrays=false] If true, arrays of vectors are represented as nested arrays. This is used for JSON encoding but not binary encoding\n * @returns {*} The appropriate vector or matrix type if the value is a vector or matrix type, respectively. If the property is an array of vectors or matrices, an array of the appropriate vector or matrix type is returned. Otherwise, the value is returned unaltered.\n * @private\n */\nMetadataClassProperty.prototype.unpackVectorAndMatrixTypes = function (\n  value,\n  enableNestedArrays,\n) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const MathType = MetadataType.getMathType(this._type);\n  const isArray = this._isArray;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  if (!defined(MathType)) {\n    return value;\n  }\n\n  if (enableNestedArrays && isNested) {\n    return value.map(function (x) {\n      return MathType.unpack(x);\n    });\n  }\n\n  if (isArray) {\n    return MathType.unpackArray(value);\n  }\n\n  return MathType.unpack(value);\n};\n\n/**\n * Pack a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} into an\n * array if this property is an <code>VECN</code>.\n * Pack a {@link Matrix2}, {@link Matrix3}, or {@link Matrix4} into an\n * array if this property is an <code>MATN</code>.\n * All other values (including arrays of other sizes) are passed through unaltered.\n *\n * @param {*} value The value of this property\n * @param {boolean} [enableNestedArrays=false] If true, arrays of vectors are represented as nested arrays. This is used for JSON encoding but not binary encoding\n * @returns {*} An array of the appropriate length if the property is a vector or matrix type. Otherwise, the value is returned unaltered.\n * @private\n */\nMetadataClassProperty.prototype.packVectorAndMatrixTypes = function (\n  value,\n  enableNestedArrays,\n) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const MathType = MetadataType.getMathType(this._type);\n  const isArray = this._isArray;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  if (!defined(MathType)) {\n    return value;\n  }\n\n  if (enableNestedArrays && isNested) {\n    return value.map(function (x) {\n      return MathType.pack(x, []);\n    });\n  }\n\n  if (isArray) {\n    return MathType.packArray(value, []);\n  }\n\n  return MathType.pack(value, []);\n};\n\n/**\n * Validates whether the given value conforms to the property.\n *\n * @param {*} value The value.\n * @returns {string|undefined} An error message if the value does not conform to the property, otherwise undefined.\n * @private\n */\nMetadataClassProperty.prototype.validate = function (value) {\n  if (!defined(value) && defined(this._default)) {\n    // no value, but we have a default to use.\n    return undefined;\n  }\n\n  if (this._required && !defined(value)) {\n    return `required property must have a value`;\n  }\n\n  if (this._isArray) {\n    return validateArray(this, value);\n  }\n\n  return validateSingleValue(this, value);\n};\n\nfunction validateArray(classProperty, value) {\n  if (!Array.isArray(value)) {\n    return `value ${value} must be an array`;\n  }\n\n  const length = value.length;\n  if (\n    !classProperty._isVariableLengthArray &&\n    length !== classProperty._arrayLength\n  ) {\n    return \"Array length does not match property.arrayLength\";\n  }\n\n  for (let i = 0; i < length; i++) {\n    const message = validateSingleValue(classProperty, value[i]);\n    if (defined(message)) {\n      return message;\n    }\n  }\n}\n\nfunction validateSingleValue(classProperty, value) {\n  const type = classProperty._type;\n  const componentType = classProperty._componentType;\n  const enumType = classProperty._enumType;\n  const normalized = classProperty._normalized;\n\n  if (MetadataType.isVectorType(type)) {\n    return validateVector(value, type, componentType);\n  } else if (MetadataType.isMatrixType(type)) {\n    return validateMatrix(value, type, componentType);\n  } else if (type === MetadataType.STRING) {\n    return validateString(value);\n  } else if (type === MetadataType.BOOLEAN) {\n    return validateBoolean(value);\n  } else if (type === MetadataType.ENUM) {\n    return validateEnum(value, enumType);\n  }\n\n  return validateScalar(value, componentType, normalized);\n}\n\nfunction validateVector(value, type, componentType) {\n  if (!MetadataComponentType.isVectorCompatible(componentType)) {\n    return `componentType ${componentType} is incompatible with vector type ${type}`;\n  }\n\n  if (type === MetadataType.VEC2 && !(value instanceof Cartesian2)) {\n    return `vector value ${value} must be a Cartesian2`;\n  }\n\n  if (type === MetadataType.VEC3 && !(value instanceof Cartesian3)) {\n    return `vector value ${value} must be a Cartesian3`;\n  }\n\n  if (type === MetadataType.VEC4 && !(value instanceof Cartesian4)) {\n    return `vector value ${value} must be a Cartesian4`;\n  }\n}\n\nfunction validateMatrix(value, type, componentType) {\n  if (!MetadataComponentType.isVectorCompatible(componentType)) {\n    return `componentType ${componentType} is incompatible with matrix type ${type}`;\n  }\n\n  if (type === MetadataType.MAT2 && !(value instanceof Matrix2)) {\n    return `matrix value ${value} must be a Matrix2`;\n  }\n\n  if (type === MetadataType.MAT3 && !(value instanceof Matrix3)) {\n    return `matrix value ${value} must be a Matrix3`;\n  }\n\n  if (type === MetadataType.MAT4 && !(value instanceof Matrix4)) {\n    return `matrix value ${value} must be a Matrix4`;\n  }\n}\n\nfunction validateString(value) {\n  if (typeof value !== \"string\") {\n    return getTypeErrorMessage(value, MetadataType.STRING);\n  }\n}\n\nfunction validateBoolean(value) {\n  if (typeof value !== \"boolean\") {\n    return getTypeErrorMessage(value, MetadataType.BOOLEAN);\n  }\n}\n\nfunction validateEnum(value, enumType) {\n  const javascriptType = typeof value;\n  if (defined(enumType)) {\n    if (javascriptType !== \"string\" || !defined(enumType.valuesByName[value])) {\n      return `value ${value} is not a valid enum name for ${enumType.id}`;\n    }\n    return;\n  }\n}\n\nfunction validateScalar(value, componentType, normalized) {\n  const javascriptType = typeof value;\n\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      if (javascriptType !== \"number\") {\n        return getTypeErrorMessage(value, componentType);\n      }\n      if (!isFinite(value)) {\n        return getNonFiniteErrorMessage(value, componentType);\n      }\n      return checkInRange(value, componentType, normalized);\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      if (javascriptType !== \"number\" && javascriptType !== \"bigint\") {\n        return getTypeErrorMessage(value, componentType);\n      }\n      if (javascriptType === \"number\" && !isFinite(value)) {\n        return getNonFiniteErrorMessage(value, componentType);\n      }\n      return checkInRange(value, componentType, normalized);\n  }\n}\n\nfunction getTypeErrorMessage(value, type) {\n  return `value ${value} does not match type ${type}`;\n}\n\nfunction getOutOfRangeErrorMessage(value, type, normalized) {\n  let errorMessage = `value ${value} is out of range for type ${type}`;\n  if (normalized) {\n    errorMessage += \" (normalized)\";\n  }\n  return errorMessage;\n}\n\nfunction checkInRange(value, componentType, normalized) {\n  if (normalized) {\n    const min = MetadataComponentType.isUnsignedIntegerType(componentType)\n      ? 0.0\n      : -1.0;\n    const max = 1.0;\n    if (value < min || value > max) {\n      return getOutOfRangeErrorMessage(value, componentType, normalized);\n    }\n    return;\n  }\n\n  if (\n    value < MetadataComponentType.getMinimum(componentType) ||\n    value > MetadataComponentType.getMaximum(componentType)\n  ) {\n    return getOutOfRangeErrorMessage(value, componentType, normalized);\n  }\n}\n\nfunction getNonFiniteErrorMessage(value, type) {\n  return `value ${value} of type ${type} must be finite`;\n}\n\nfunction normalizeInPlace(values, valueType, normalizeFunction) {\n  if (!Array.isArray(values)) {\n    return normalizeFunction(values, valueType);\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    values[i] = normalizeInPlace(values[i], valueType, normalizeFunction);\n  }\n\n  return values;\n}\n\n/**\n * Applies the value transform that is defined with the given offsets\n * and scales to the given values.\n *\n * If the given values are not an array, then the given transformation\n * function will be applied directly.\n *\n * If the values are an array, then this function will be called recursively\n * with the array elements, boiling down to a component-wise application\n * of the transformation function to the innermost array elements.\n *\n * @param {number|number[]|number[][]} values The input values\n * @param {number|number[]|number[][]} offsets The offsets\n * @param {number|number[]|number[][]} scales The scales\n * @param {Function} transformationFunction The function with the signature\n * `(value:number, offset:number, scale:number) : number` that will be\n * applied to the innermost elements\n * @returns The input values (or the result of applying the transformation\n * function to a single value if the values have not been an array).\n * @private\n */\nMetadataClassProperty.valueTransformInPlace = function (\n  values,\n  offsets,\n  scales,\n  transformationFunction,\n) {\n  if (!Array.isArray(values)) {\n    // transform a single value\n    return transformationFunction(values, offsets, scales);\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    // offsets and scales must be the same array shape as values.\n    values[i] = MetadataClassProperty.valueTransformInPlace(\n      values[i],\n      offsets[i],\n      scales[i],\n      transformationFunction,\n    );\n  }\n\n  return values;\n};\n\nexport default MetadataClassProperty;\n"],"mappings":"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,CAACrD,KAAK;IACnB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,WAAW,EAAE;IACXkD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACnD,YAAY;IAC1B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEV,IAAI,EAAE;IACJ6D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC7C,KAAK;IACnB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEZ,QAAQ,EAAE;IACRyD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC3C,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEf,aAAa,EAAE;IACb0D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC5C,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,SAAS,EAAE;IACTyC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC1C,UAAU;IACxB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,OAAO,EAAE;IACPuC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxC,QAAQ;IACtB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,qBAAqB,EAAE;IACrBqC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACtC,sBAAsB;IACpC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,WAAW,EAAE;IACXmC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACpC,YAAY;IAC1B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEpB,UAAU,EAAE;IACVwD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC9B,WAAW;IACzB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACED,GAAG,EAAE;IACH+B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAChC,IAAI;IAClB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACED,GAAG,EAAE;IACHiC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAClC,IAAI;IAClB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEc,MAAM,EAAE;IACNoB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACrB,OAAO;IACrB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,OAAO,EAAE;IACPkB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACnB,QAAQ;IACtB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,QAAQ,EAAE;IACRgB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjB,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE/B,QAAQ,EAAE;IACRgD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjD,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEsB,iBAAiB,EAAE;IACjB2B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACtB,kBAAkB;IAChC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,MAAM,EAAE;IACN6B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxB,OAAO;IACrB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEJ,KAAK,EAAE;IACL4B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACvB,MAAM;IACpB;EA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}