{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\n\n/**\n * A cylinder {@link VoxelShape}.\n *\n * @alias VoxelCylinderShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelEllipsoidShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelCylinderShape() {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  this.orientedBoundingBox = new OrientedBoundingBox();\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  this.boundingSphere = new BoundingSphere();\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.boundTransform = new Matrix4();\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.shapeTransform = new Matrix4();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumRadius = VoxelCylinderShape.DefaultMinBounds.x;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumRadius = VoxelCylinderShape.DefaultMaxBounds.x;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumHeight = VoxelCylinderShape.DefaultMinBounds.y;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumHeight = VoxelCylinderShape.DefaultMaxBounds.y;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumAngle = VoxelCylinderShape.DefaultMinBounds.z;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumAngle = VoxelCylinderShape.DefaultMaxBounds.z;\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderUniforms = {\n    cylinderRenderHeightMinMax: new Cartesian2(),\n    cylinderRenderRadiusMinMax: new Cartesian2(),\n    cylinderRenderAngleMinMax: new Cartesian2(),\n    cylinderUvToShapeUvRadius: new Cartesian2(),\n    cylinderUvToShapeUvHeight: new Cartesian2(),\n    cylinderUvToShapeUvAngle: new Cartesian2(),\n    cylinderShapeUvAngleMinMax: new Cartesian2(),\n    cylinderShapeUvAngleRangeZeroMid: 0.0\n  };\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderDefines = {\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_RADIUS: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MAX: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MIN: undefined,\n    CYLINDER_INTERSECTION_INDEX_ANGLE: undefined\n  };\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @type {number}\n   * @readonly\n   */\n  this.shaderMaximumIntersectionsLength = 0; // not known until update\n}\nconst scratchScale = new Cartesian3();\n\n/**\n * Update the shape's state.\n *\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelCylinderShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelCylinderShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelCylinderShape.prototype.update = function (modelMatrix, minBounds, maxBounds, clipMinBounds, clipMaxBounds) {\n  clipMinBounds = defaultValue(clipMinBounds, VoxelCylinderShape.DefaultMinBounds);\n  clipMaxBounds = defaultValue(clipMaxBounds, VoxelCylinderShape.DefaultMaxBounds);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const defaultMinRadius = VoxelCylinderShape.DefaultMinBounds.x;\n  const defaultMaxRadius = VoxelCylinderShape.DefaultMaxBounds.x;\n  const defaultMinHeight = VoxelCylinderShape.DefaultMinBounds.y;\n  const defaultMaxHeight = VoxelCylinderShape.DefaultMaxBounds.y;\n  const defaultMinAngle = VoxelCylinderShape.DefaultMinBounds.z;\n  const defaultMaxAngle = VoxelCylinderShape.DefaultMaxBounds.z;\n  const defaultAngleRange = defaultMaxAngle - defaultMinAngle;\n  const defaultAngleRangeHalf = 0.5 * defaultAngleRange;\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonAngleDiscontinuity = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n  const epsilonAngle = CesiumMath.EPSILON10;\n\n  // Clamp the radii to the valid range\n  const shapeMinRadius = CesiumMath.clamp(minBounds.x, defaultMinRadius, defaultMaxRadius);\n  const shapeMaxRadius = CesiumMath.clamp(maxBounds.x, defaultMinRadius, defaultMaxRadius);\n  const clipMinRadius = CesiumMath.clamp(clipMinBounds.x, defaultMinRadius, defaultMaxRadius);\n  const clipMaxRadius = CesiumMath.clamp(clipMaxBounds.x, defaultMinRadius, defaultMaxRadius);\n  const renderMinRadius = Math.max(shapeMinRadius, clipMinRadius);\n  const renderMaxRadius = Math.min(shapeMaxRadius, clipMaxRadius);\n\n  // Clamp the heights to the valid range\n  const shapeMinHeight = CesiumMath.clamp(minBounds.y, defaultMinHeight, defaultMaxHeight);\n  const shapeMaxHeight = CesiumMath.clamp(maxBounds.y, defaultMinHeight, defaultMaxHeight);\n  const clipMinHeight = CesiumMath.clamp(clipMinBounds.y, defaultMinHeight, defaultMaxHeight);\n  const clipMaxHeight = CesiumMath.clamp(clipMaxBounds.y, defaultMinHeight, defaultMaxHeight);\n  const renderMinHeight = Math.max(shapeMinHeight, clipMinHeight);\n  const renderMaxHeight = Math.min(shapeMaxHeight, clipMaxHeight);\n\n  // Clamp the angles to the valid range\n  const shapeMinAngle = CesiumMath.negativePiToPi(minBounds.z);\n  const shapeMaxAngle = CesiumMath.negativePiToPi(maxBounds.z);\n  const clipMinAngle = CesiumMath.negativePiToPi(clipMinBounds.z);\n  const clipMaxAngle = CesiumMath.negativePiToPi(clipMaxBounds.z);\n  const renderMinAngle = Math.max(shapeMinAngle, clipMinAngle);\n  const renderMaxAngle = Math.min(shapeMaxAngle, clipMaxAngle);\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n\n  // Exit early if the shape is not visible.\n  // Note that minAngle may be greater than maxAngle when crossing the 180th meridian.\n\n  // Cylinder is not visible if:\n  // - maxRadius is zero (line)\n  // - minRadius is greater than maxRadius\n  // - minHeight is greater than maxHeight\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  if (renderMaxRadius === 0.0 || renderMinRadius > renderMaxRadius || renderMinHeight > renderMaxHeight || CesiumMath.equalsEpsilon(scale.x, 0.0, undefined, epsilonZeroScale) || CesiumMath.equalsEpsilon(scale.y, 0.0, undefined, epsilonZeroScale) || CesiumMath.equalsEpsilon(scale.z, 0.0, undefined, epsilonZeroScale)) {\n    return false;\n  }\n  this._minimumRadius = shapeMinRadius; // [0,1]\n  this._maximumRadius = shapeMaxRadius; // [0,1]\n  this._minimumHeight = shapeMinHeight; // [-1,+1]\n  this._maximumHeight = shapeMaxHeight; // [-1,+1]\n  this._minimumAngle = shapeMinAngle; // [-pi,+pi]\n  this._maximumAngle = shapeMaxAngle; // [-pi,+pi]\n\n  this.shapeTransform = Matrix4.clone(modelMatrix, this.shapeTransform);\n  this.orientedBoundingBox = getCylinderChunkObb(renderMinRadius, renderMaxRadius, renderMinHeight, renderMaxHeight, renderMinAngle, renderMaxAngle, this.shapeTransform, this.orientedBoundingBox);\n  this.boundTransform = Matrix4.fromRotationTranslation(this.orientedBoundingBox.halfAxes, this.orientedBoundingBox.center, this.boundTransform);\n  this.boundingSphere = BoundingSphere.fromOrientedBoundingBox(this.orientedBoundingBox, this.boundingSphere);\n  const shapeIsDefaultMaxRadius = shapeMaxRadius === defaultMaxRadius;\n  const shapeIsDefaultMinRadius = shapeMinRadius === defaultMinRadius;\n  const shapeIsDefaultRadius = shapeIsDefaultMinRadius && shapeIsDefaultMaxRadius;\n  const shapeIsDefaultHeight = shapeMinHeight === defaultMinHeight && shapeMaxHeight === defaultMaxHeight;\n  const shapeIsAngleReversed = shapeMaxAngle < shapeMinAngle;\n  const shapeAngleRange = shapeMaxAngle - shapeMinAngle + shapeIsAngleReversed * defaultAngleRange;\n  const shapeIsAngleRegular = shapeAngleRange > defaultAngleRangeHalf + epsilonAngle && shapeAngleRange < defaultAngleRange - epsilonAngle;\n  const shapeIsAngleFlipped = shapeAngleRange < defaultAngleRangeHalf - epsilonAngle;\n  const shapeIsAngleRangeHalf = shapeAngleRange >= defaultAngleRangeHalf - epsilonAngle && shapeAngleRange <= defaultAngleRangeHalf + epsilonAngle;\n  const shapeHasAngle = shapeIsAngleRegular || shapeIsAngleFlipped || shapeIsAngleRangeHalf;\n  const shapeIsMinAngleDiscontinuity = CesiumMath.equalsEpsilon(shapeMinAngle, defaultMinAngle, undefined, epsilonAngleDiscontinuity);\n  const shapeIsMaxAngleDiscontinuity = CesiumMath.equalsEpsilon(shapeMaxAngle, defaultMaxAngle, undefined, epsilonAngleDiscontinuity);\n  const renderIsDefaultMinRadius = renderMinRadius === defaultMinRadius;\n  const renderIsAngleReversed = renderMaxAngle < renderMinAngle;\n  const renderAngleRange = renderMaxAngle - renderMinAngle + renderIsAngleReversed * defaultAngleRange;\n  const renderIsAngleRegular = renderAngleRange >= defaultAngleRangeHalf - epsilonAngle && renderAngleRange < defaultAngleRange - epsilonAngle;\n  const renderIsAngleFlipped = renderAngleRange > epsilonAngle && renderAngleRange < defaultAngleRangeHalf - epsilonAngle;\n  const renderIsAngleRangeZero = renderAngleRange <= epsilonAngle;\n  const renderHasAngle = renderIsAngleRegular || renderIsAngleFlipped || renderIsAngleRangeZero;\n  const {\n    shaderUniforms,\n    shaderDefines\n  } = this;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n  shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n  if (!renderIsDefaultMinRadius) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\"] = intersectionCount;\n    intersectionCount += 1;\n  }\n  shaderUniforms.cylinderRenderRadiusMinMax = Cartesian2.fromElements(renderMinRadius, renderMaxRadius, shaderUniforms.cylinderRenderRadiusMinMax);\n  if (renderMinRadius === renderMaxRadius) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\"] = true;\n  }\n  if (!shapeIsDefaultRadius) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_RADIUS\"] = true;\n\n    // delerp(radius, minRadius, maxRadius)\n    // (radius - minRadius) / (maxRadius - minRadius)\n    // radius / (maxRadius - minRadius) - minRadius / (maxRadius - minRadius)\n    // scale = 1.0 / (maxRadius - minRadius)\n    // offset = -minRadius / (maxRadius - minRadius)\n    // offset = minRadius / (minRadius - maxRadius)\n    const radiusRange = shapeMaxRadius - shapeMinRadius;\n    let scale = 0.0;\n    let offset = 1.0;\n    if (radiusRange !== 0.0) {\n      scale = 1.0 / radiusRange;\n      offset = -shapeMinRadius / radiusRange;\n    }\n    shaderUniforms.cylinderUvToShapeUvRadius = Cartesian2.fromElements(scale, offset, shaderUniforms.cylinderUvToShapeUvRadius);\n  }\n  if (!shapeIsDefaultHeight) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT\"] = true;\n\n    // delerp(heightUv, minHeightUv, maxHeightUv)\n    // (heightUv - minHeightUv) / (maxHeightUv - minHeightUv)\n    // heightUv / (maxHeightUv - minHeightUv) - minHeightUv / (maxHeightUv - minHeightUv)\n    // scale = 1.0 / (maxHeightUv - minHeightUv)\n    // scale = 1.0 / ((maxHeight * 0.5 + 0.5) - (minHeight * 0.5 + 0.5))\n    // scale = 2.0 / (maxHeight - minHeight)\n    // offset = -minHeightUv / (maxHeightUv - minHeightUv)\n    // offset = -minHeightUv / ((maxHeight * 0.5 + 0.5) - (minHeight * 0.5 + 0.5))\n    // offset = -2.0 * (minHeight * 0.5 + 0.5) / (maxHeight - minHeight)\n    // offset = -(minHeight + 1.0) / (maxHeight - minHeight)\n    // offset = (minHeight + 1.0) / (minHeight - maxHeight)\n    const heightRange = shapeMaxHeight - shapeMinHeight;\n    let scale = 0.0;\n    let offset = 1.0;\n    if (heightRange !== 0.0) {\n      scale = 2.0 / heightRange;\n      offset = -(shapeMinHeight + 1.0) / heightRange;\n    }\n    shaderUniforms.cylinderUvToShapeUvHeight = Cartesian2.fromElements(scale, offset, shaderUniforms.cylinderUvToShapeUvHeight);\n  }\n  shaderUniforms.cylinderRenderHeightMinMax = Cartesian2.fromElements(renderMinHeight, renderMaxHeight, shaderUniforms.cylinderRenderHeightMinMax);\n  if (shapeIsAngleReversed) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED\"] = true;\n  }\n  if (renderHasAngle) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_ANGLE\"] = intersectionCount;\n    if (renderIsAngleRegular) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\"] = true;\n      intersectionCount += 1;\n    } else if (renderIsAngleFlipped) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\"] = true;\n      intersectionCount += 2;\n    } else if (renderIsAngleRangeZero) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\"] = true;\n      intersectionCount += 2;\n    }\n    shaderUniforms.cylinderRenderAngleMinMax = Cartesian2.fromElements(renderMinAngle, renderMaxAngle, shaderUniforms.cylinderRenderAngleMinMax);\n  }\n  if (shapeHasAngle) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE\"] = true;\n    if (shapeIsMinAngleDiscontinuity) {\n      shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY\"] = true;\n    }\n    if (shapeIsMaxAngleDiscontinuity) {\n      shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY\"] = true;\n    }\n    const uvMinAngle = (shapeMinAngle - defaultMinAngle) / defaultAngleRange;\n    const uvMaxAngle = (shapeMaxAngle - defaultMinAngle) / defaultAngleRange;\n    const uvAngleRangeZero = 1.0 - shapeAngleRange / defaultAngleRange;\n    shaderUniforms.cylinderShapeUvAngleMinMax = Cartesian2.fromElements(uvMinAngle, uvMaxAngle, shaderUniforms.cylinderShapeUvAngleMinMax);\n    shaderUniforms.cylinderShapeUvAngleRangeZeroMid = (uvMaxAngle + 0.5 * uvAngleRangeZero) % 1.0;\n\n    // delerp(angleUv, uvMinAngle, uvMaxAngle)\n    // (angelUv - uvMinAngle) / (uvMaxAngle - uvMinAngle)\n    // angleUv / (uvMaxAngle - uvMinAngle) - uvMinAngle / (uvMaxAngle - uvMinAngle)\n    // scale = 1.0 / (uvMaxAngle - uvMinAngle)\n    // scale = 1.0 / (((maxAngle - pi) / (2.0 * pi)) - ((minAngle - pi) / (2.0 * pi)))\n    // scale = 2.0 * pi / (maxAngle - minAngle)\n    // offset = -uvMinAngle / (uvMaxAngle - uvMinAngle)\n    // offset = -((minAngle - pi) / (2.0 * pi)) / (((maxAngle - pi) / (2.0 * pi)) - ((minAngle - pi) / (2.0 * pi)))\n    // offset = -(minAngle - pi) / (maxAngle - minAngle)\n    if (shapeAngleRange <= epsilonAngle) {\n      shaderUniforms.cylinderUvToShapeUvAngle = Cartesian2.fromElements(0.0, 1.0, shaderUniforms.cylinderUvToShapeUvAngle);\n    } else {\n      const scale = defaultAngleRange / shapeAngleRange;\n      const offset = -(shapeMinAngle - defaultMinAngle) / shapeAngleRange;\n      shaderUniforms.cylinderUvToShapeUvAngle = Cartesian2.fromElements(scale, offset, shaderUniforms.cylinderUvToShapeUvAngle);\n    }\n  }\n  this.shaderMaximumIntersectionsLength = intersectionCount;\n  return true;\n};\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForTile = function (tileLevel, tileX, tileY, tileZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minimumRadius = this._minimumRadius;\n  const maximumRadius = this._maximumRadius;\n  const minimumHeight = this._minimumHeight;\n  const maximumHeight = this._maximumHeight;\n  const minimumAngle = this._minimumAngle;\n  const maximumAngle = this._maximumAngle;\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n  const radiusStart = CesiumMath.lerp(minimumRadius, maximumRadius, tileX * sizeAtLevel);\n  const radiusEnd = CesiumMath.lerp(minimumRadius, maximumRadius, (tileX + 1) * sizeAtLevel);\n  const heightStart = CesiumMath.lerp(minimumHeight, maximumHeight, tileY * sizeAtLevel);\n  const heightEnd = CesiumMath.lerp(minimumHeight, maximumHeight, (tileY + 1) * sizeAtLevel);\n  const angleStart = CesiumMath.lerp(minimumAngle, maximumAngle, tileZ * sizeAtLevel);\n  const angleEnd = CesiumMath.lerp(minimumAngle, maximumAngle, (tileZ + 1) * sizeAtLevel);\n  return getCylinderChunkObb(radiusStart, radiusEnd, heightStart, heightEnd, angleStart, angleEnd, this.shapeTransform, result);\n};\nconst sampleSizeScratch = new Cartesian3();\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForSample = function (spatialNode, tileDimensions, tileUv, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(Cartesian3.ONE, tileDimensions, sampleSizeScratch);\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(sampleSize, tileSizeAtLevel, sampleSizeScratch);\n  const minLerp = Cartesian3.multiplyByScalar(Cartesian3.fromElements(spatialNode.x + tileUv.x, spatialNode.y + tileUv.y, spatialNode.z + tileUv.z, scratchTileMinBounds), tileSizeAtLevel, scratchTileMinBounds);\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchTileMaxBounds);\n  const minimumRadius = this._minimumRadius;\n  const maximumRadius = this._maximumRadius;\n  const minimumHeight = this._minimumHeight;\n  const maximumHeight = this._maximumHeight;\n  const minimumAngle = this._minimumAngle;\n  const maximumAngle = this._maximumAngle;\n  const radiusStart = CesiumMath.lerp(minimumRadius, maximumRadius, minLerp.x);\n  const radiusEnd = CesiumMath.lerp(minimumRadius, maximumRadius, maxLerp.x);\n  const heightStart = CesiumMath.lerp(minimumHeight, maximumHeight, minLerp.y);\n  const heightEnd = CesiumMath.lerp(minimumHeight, maximumHeight, maxLerp.y);\n  const angleStart = CesiumMath.lerp(minimumAngle, maximumAngle, minLerp.z);\n  const angleEnd = CesiumMath.lerp(minimumAngle, maximumAngle, maxLerp.z);\n  return getCylinderChunkObb(radiusStart, radiusEnd, heightStart, heightEnd, angleStart, angleEnd, this.shapeTransform, result);\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum radius, height, angle.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMinBounds = Object.freeze(new Cartesian3(0.0, -1.0, -CesiumMath.PI));\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum radius, height, angle.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMaxBounds = Object.freeze(new Cartesian3(1.0, +1.0, +CesiumMath.PI));\nconst maxTestAngles = 5;\nconst scratchTestAngles = new Array(maxTestAngles);\nconst scratchTranslation = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchTranslationMatrix = new Matrix4();\nconst scratchRotationMatrix = new Matrix4();\nconst scratchScaleMatrix = new Matrix4();\nconst scratchMatrix = new Matrix4();\nconst scratchColumn0 = new Cartesian3();\nconst scratchColumn1 = new Cartesian3();\nconst scratchColumn2 = new Cartesian3();\nconst scratchCorners = new Array(8);\nfor (let i = 0; i < 8; i++) {\n  scratchCorners[i] = new Cartesian3();\n}\nfunction orthogonal(a, b, epsilon) {\n  return Math.abs(Cartesian4.dot(a, b)) < epsilon;\n}\nfunction isValidOrientedBoundingBoxTransformation(matrix) {\n  const column0 = Matrix4.getColumn(matrix, 0, scratchColumn0);\n  const column1 = Matrix4.getColumn(matrix, 1, scratchColumn1);\n  const column2 = Matrix4.getColumn(matrix, 2, scratchColumn2);\n  const epsilon = CesiumMath.EPSILON4;\n  return orthogonal(column0, column1, epsilon) && orthogonal(column1, column2, epsilon);\n}\nfunction computeLooseOrientedBoundingBox(matrix, result) {\n  const corners = scratchCorners;\n  Cartesian3.fromElements(-0.5, -0.5, -0.5, corners[0]);\n  Cartesian3.fromElements(-0.5, -0.5, 0.5, corners[1]);\n  Cartesian3.fromElements(-0.5, 0.5, -0.5, corners[2]);\n  Cartesian3.fromElements(-0.5, 0.5, 0.5, corners[3]);\n  Cartesian3.fromElements(0.5, -0.5, -0.5, corners[4]);\n  Cartesian3.fromElements(0.5, -0.5, 0.5, corners[5]);\n  Cartesian3.fromElements(0.5, 0.5, -0.5, corners[6]);\n  Cartesian3.fromElements(0.5, 0.5, 0.5, corners[7]);\n  for (let i = 0; i < 8; ++i) {\n    Matrix4.multiplyByPoint(matrix, corners[i], corners[i]);\n  }\n  return OrientedBoundingBox.fromPoints(corners, result);\n}\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {number} radiusStart The radiusStart.\n * @param {number} radiusEnd The radiusEnd.\n * @param {number} heightStart The heightStart.\n * @param {number} heightEnd The heightEnd.\n * @param {number} angleStart The angleStart.\n * @param {number} angleEnd The angleEnd.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getCylinderChunkObb(radiusStart, radiusEnd, heightStart, heightEnd, angleStart, angleEnd, matrix, result) {\n  const defaultMinBounds = VoxelCylinderShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelCylinderShape.DefaultMaxBounds;\n  const defaultMinRadius = defaultMinBounds.x; // 0\n  const defaultMaxRadius = defaultMaxBounds.x; // 1\n  const defaultMinHeight = defaultMinBounds.y; // -1\n  const defaultMaxHeight = defaultMaxBounds.y; // +1\n  const defaultMinAngle = defaultMinBounds.z; // -pi\n  const defaultMaxAngle = defaultMaxBounds.z; // +pi\n\n  // Return early if using the default bounds\n  if (radiusStart === defaultMinRadius && radiusEnd === defaultMaxRadius && heightStart === defaultMinHeight && heightEnd === defaultMaxHeight && angleStart === defaultMinAngle && angleEnd === defaultMaxAngle) {\n    result.center = Matrix4.getTranslation(matrix, result.center);\n    result.halfAxes = Matrix4.getMatrix3(matrix, result.halfAxes);\n    return result;\n  }\n  const isAngleReversed = angleEnd < angleStart;\n  if (isAngleReversed) {\n    angleEnd += CesiumMath.TWO_PI;\n  }\n  const angleRange = angleEnd - angleStart;\n  const angleMid = angleStart + angleRange * 0.5;\n  const testAngles = scratchTestAngles;\n  let testAngleCount = 0;\n  testAngles[testAngleCount++] = angleStart;\n  testAngles[testAngleCount++] = angleEnd;\n  testAngles[testAngleCount++] = angleMid;\n  if (angleRange > CesiumMath.PI) {\n    testAngles[testAngleCount++] = angleMid - CesiumMath.PI_OVER_TWO;\n    testAngles[testAngleCount++] = angleMid + CesiumMath.PI_OVER_TWO;\n  }\n\n  // Find bounding box in shape space relative to angleMid\n  let minX = 1.0;\n  let minY = 1.0;\n  let maxX = -1.0;\n  let maxY = -1.0;\n  for (let i = 0; i < testAngleCount; ++i) {\n    const angle = testAngles[i] - angleMid;\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const x1 = cosAngle * radiusStart;\n    const y1 = sinAngle * radiusStart;\n    const x2 = cosAngle * radiusEnd;\n    const y2 = sinAngle * radiusEnd;\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    minX = Math.min(minX, x2);\n    minY = Math.min(minY, y2);\n    maxX = Math.max(maxX, x1);\n    maxY = Math.max(maxY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  }\n  const extentX = maxX - minX;\n  const extentY = maxY - minY;\n  const extentZ = heightEnd - heightStart;\n  const centerX = (minX + maxX) * 0.5;\n  const centerY = (minY + maxY) * 0.5;\n  const centerZ = (heightStart + heightEnd) * 0.5;\n  const translation = Cartesian3.fromElements(centerX, centerY, centerZ, scratchTranslation);\n  const rotation = Matrix3.fromRotationZ(angleMid, scratchRotation);\n  const scale = Cartesian3.fromElements(extentX, extentY, extentZ, scratchScale);\n  const scaleMatrix = Matrix4.fromScale(scale, scratchScaleMatrix);\n  const rotationMatrix = Matrix4.fromRotation(rotation, scratchRotationMatrix);\n  const translationMatrix = Matrix4.fromTranslation(translation, scratchTranslationMatrix);\n\n  // Shape space matrix = R * T * S\n  const localMatrix = Matrix4.multiplyTransformation(rotationMatrix, Matrix4.multiplyTransformation(translationMatrix, scaleMatrix, scratchMatrix), scratchMatrix);\n  const globalMatrix = Matrix4.multiplyTransformation(matrix, localMatrix, scratchMatrix);\n  if (!isValidOrientedBoundingBoxTransformation(globalMatrix)) {\n    return computeLooseOrientedBoundingBox(globalMatrix, result);\n  }\n  return OrientedBoundingBox.fromTransformation(globalMatrix, result);\n}\nexport default VoxelCylinderShape;","map":{"version":3,"names":["defaultValue","BoundingSphere","Cartesian2","Cartesian3","Check","CesiumMath","Matrix3","Matrix4","OrientedBoundingBox","Cartesian4","VoxelCylinderShape","orientedBoundingBox","boundingSphere","boundTransform","shapeTransform","_minimumRadius","DefaultMinBounds","x","_maximumRadius","DefaultMaxBounds","_minimumHeight","y","_maximumHeight","_minimumAngle","z","_maximumAngle","shaderUniforms","cylinderRenderHeightMinMax","cylinderRenderRadiusMinMax","cylinderRenderAngleMinMax","cylinderUvToShapeUvRadius","cylinderUvToShapeUvHeight","cylinderUvToShapeUvAngle","cylinderShapeUvAngleMinMax","cylinderShapeUvAngleRangeZeroMid","shaderDefines","CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN","undefined","CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT","CYLINDER_HAS_RENDER_BOUNDS_ANGLE","CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO","CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF","CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF","CYLINDER_HAS_SHAPE_BOUNDS_RADIUS","CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT","CYLINDER_HAS_SHAPE_BOUNDS_ANGLE","CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY","CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY","CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED","CYLINDER_INTERSECTION_INDEX_RADIUS_MAX","CYLINDER_INTERSECTION_INDEX_RADIUS_MIN","CYLINDER_INTERSECTION_INDEX_ANGLE","shaderMaximumIntersectionsLength","scratchScale","prototype","update","modelMatrix","minBounds","maxBounds","clipMinBounds","clipMaxBounds","typeOf","object","defaultMinRadius","defaultMaxRadius","defaultMinHeight","defaultMaxHeight","defaultMinAngle","defaultMaxAngle","defaultAngleRange","defaultAngleRangeHalf","epsilonZeroScale","EPSILON10","epsilonAngleDiscontinuity","EPSILON3","epsilonAngle","shapeMinRadius","clamp","shapeMaxRadius","clipMinRadius","clipMaxRadius","renderMinRadius","Math","max","renderMaxRadius","min","shapeMinHeight","shapeMaxHeight","clipMinHeight","clipMaxHeight","renderMinHeight","renderMaxHeight","shapeMinAngle","negativePiToPi","shapeMaxAngle","clipMinAngle","clipMaxAngle","renderMinAngle","renderMaxAngle","scale","getScale","equalsEpsilon","clone","getCylinderChunkObb","fromRotationTranslation","halfAxes","center","fromOrientedBoundingBox","shapeIsDefaultMaxRadius","shapeIsDefaultMinRadius","shapeIsDefaultRadius","shapeIsDefaultHeight","shapeIsAngleReversed","shapeAngleRange","shapeIsAngleRegular","shapeIsAngleFlipped","shapeIsAngleRangeHalf","shapeHasAngle","shapeIsMinAngleDiscontinuity","shapeIsMaxAngleDiscontinuity","renderIsDefaultMinRadius","renderIsAngleReversed","renderAngleRange","renderIsAngleRegular","renderIsAngleFlipped","renderIsAngleRangeZero","renderHasAngle","key","hasOwnProperty","intersectionCount","fromElements","radiusRange","offset","heightRange","uvMinAngle","uvMaxAngle","uvAngleRangeZero","computeOrientedBoundingBoxForTile","tileLevel","tileX","tileY","tileZ","result","number","minimumRadius","maximumRadius","minimumHeight","maximumHeight","minimumAngle","maximumAngle","sizeAtLevel","pow","radiusStart","lerp","radiusEnd","heightStart","heightEnd","angleStart","angleEnd","sampleSizeScratch","scratchTileMinBounds","scratchTileMaxBounds","computeOrientedBoundingBoxForSample","spatialNode","tileDimensions","tileUv","tileSizeAtLevel","level","sampleSize","divideComponents","ONE","sampleSizeAtLevel","multiplyByScalar","minLerp","maxLerp","add","Object","freeze","PI","maxTestAngles","scratchTestAngles","Array","scratchTranslation","scratchRotation","scratchTranslationMatrix","scratchRotationMatrix","scratchScaleMatrix","scratchMatrix","scratchColumn0","scratchColumn1","scratchColumn2","scratchCorners","i","orthogonal","a","b","epsilon","abs","dot","isValidOrientedBoundingBoxTransformation","matrix","column0","getColumn","column1","column2","EPSILON4","computeLooseOrientedBoundingBox","corners","multiplyByPoint","fromPoints","defaultMinBounds","defaultMaxBounds","getTranslation","getMatrix3","isAngleReversed","TWO_PI","angleRange","angleMid","testAngles","testAngleCount","PI_OVER_TWO","minX","minY","maxX","maxY","angle","cosAngle","cos","sinAngle","sin","x1","y1","x2","y2","extentX","extentY","extentZ","centerX","centerY","centerZ","translation","rotation","fromRotationZ","scaleMatrix","fromScale","rotationMatrix","fromRotation","translationMatrix","fromTranslation","localMatrix","multiplyTransformation","globalMatrix","fromTransformation"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelCylinderShape.js"],"sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\n\n/**\n * A cylinder {@link VoxelShape}.\n *\n * @alias VoxelCylinderShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelEllipsoidShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelCylinderShape() {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  this.orientedBoundingBox = new OrientedBoundingBox();\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  this.boundingSphere = new BoundingSphere();\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.boundTransform = new Matrix4();\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.shapeTransform = new Matrix4();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumRadius = VoxelCylinderShape.DefaultMinBounds.x;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumRadius = VoxelCylinderShape.DefaultMaxBounds.x;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumHeight = VoxelCylinderShape.DefaultMinBounds.y;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumHeight = VoxelCylinderShape.DefaultMaxBounds.y;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumAngle = VoxelCylinderShape.DefaultMinBounds.z;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumAngle = VoxelCylinderShape.DefaultMaxBounds.z;\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderUniforms = {\n    cylinderRenderHeightMinMax: new Cartesian2(),\n    cylinderRenderRadiusMinMax: new Cartesian2(),\n    cylinderRenderAngleMinMax: new Cartesian2(),\n    cylinderUvToShapeUvRadius: new Cartesian2(),\n    cylinderUvToShapeUvHeight: new Cartesian2(),\n    cylinderUvToShapeUvAngle: new Cartesian2(),\n    cylinderShapeUvAngleMinMax: new Cartesian2(),\n    cylinderShapeUvAngleRangeZeroMid: 0.0,\n  };\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderDefines = {\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF: undefined,\n\n    CYLINDER_HAS_SHAPE_BOUNDS_RADIUS: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY: undefined,\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED: undefined,\n\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MAX: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MIN: undefined,\n    CYLINDER_INTERSECTION_INDEX_ANGLE: undefined,\n  };\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @type {number}\n   * @readonly\n   */\n  this.shaderMaximumIntersectionsLength = 0; // not known until update\n}\n\nconst scratchScale = new Cartesian3();\n\n/**\n * Update the shape's state.\n *\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelCylinderShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelCylinderShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelCylinderShape.prototype.update = function (\n  modelMatrix,\n  minBounds,\n  maxBounds,\n  clipMinBounds,\n  clipMaxBounds,\n) {\n  clipMinBounds = defaultValue(\n    clipMinBounds,\n    VoxelCylinderShape.DefaultMinBounds,\n  );\n  clipMaxBounds = defaultValue(\n    clipMaxBounds,\n    VoxelCylinderShape.DefaultMaxBounds,\n  );\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const defaultMinRadius = VoxelCylinderShape.DefaultMinBounds.x;\n  const defaultMaxRadius = VoxelCylinderShape.DefaultMaxBounds.x;\n  const defaultMinHeight = VoxelCylinderShape.DefaultMinBounds.y;\n  const defaultMaxHeight = VoxelCylinderShape.DefaultMaxBounds.y;\n  const defaultMinAngle = VoxelCylinderShape.DefaultMinBounds.z;\n  const defaultMaxAngle = VoxelCylinderShape.DefaultMaxBounds.z;\n  const defaultAngleRange = defaultMaxAngle - defaultMinAngle;\n  const defaultAngleRangeHalf = 0.5 * defaultAngleRange;\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonAngleDiscontinuity = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n  const epsilonAngle = CesiumMath.EPSILON10;\n\n  // Clamp the radii to the valid range\n  const shapeMinRadius = CesiumMath.clamp(\n    minBounds.x,\n    defaultMinRadius,\n    defaultMaxRadius,\n  );\n  const shapeMaxRadius = CesiumMath.clamp(\n    maxBounds.x,\n    defaultMinRadius,\n    defaultMaxRadius,\n  );\n  const clipMinRadius = CesiumMath.clamp(\n    clipMinBounds.x,\n    defaultMinRadius,\n    defaultMaxRadius,\n  );\n  const clipMaxRadius = CesiumMath.clamp(\n    clipMaxBounds.x,\n    defaultMinRadius,\n    defaultMaxRadius,\n  );\n  const renderMinRadius = Math.max(shapeMinRadius, clipMinRadius);\n  const renderMaxRadius = Math.min(shapeMaxRadius, clipMaxRadius);\n\n  // Clamp the heights to the valid range\n  const shapeMinHeight = CesiumMath.clamp(\n    minBounds.y,\n    defaultMinHeight,\n    defaultMaxHeight,\n  );\n  const shapeMaxHeight = CesiumMath.clamp(\n    maxBounds.y,\n    defaultMinHeight,\n    defaultMaxHeight,\n  );\n  const clipMinHeight = CesiumMath.clamp(\n    clipMinBounds.y,\n    defaultMinHeight,\n    defaultMaxHeight,\n  );\n  const clipMaxHeight = CesiumMath.clamp(\n    clipMaxBounds.y,\n    defaultMinHeight,\n    defaultMaxHeight,\n  );\n  const renderMinHeight = Math.max(shapeMinHeight, clipMinHeight);\n  const renderMaxHeight = Math.min(shapeMaxHeight, clipMaxHeight);\n\n  // Clamp the angles to the valid range\n  const shapeMinAngle = CesiumMath.negativePiToPi(minBounds.z);\n  const shapeMaxAngle = CesiumMath.negativePiToPi(maxBounds.z);\n  const clipMinAngle = CesiumMath.negativePiToPi(clipMinBounds.z);\n  const clipMaxAngle = CesiumMath.negativePiToPi(clipMaxBounds.z);\n  const renderMinAngle = Math.max(shapeMinAngle, clipMinAngle);\n  const renderMaxAngle = Math.min(shapeMaxAngle, clipMaxAngle);\n\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n\n  // Exit early if the shape is not visible.\n  // Note that minAngle may be greater than maxAngle when crossing the 180th meridian.\n\n  // Cylinder is not visible if:\n  // - maxRadius is zero (line)\n  // - minRadius is greater than maxRadius\n  // - minHeight is greater than maxHeight\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  if (\n    renderMaxRadius === 0.0 ||\n    renderMinRadius > renderMaxRadius ||\n    renderMinHeight > renderMaxHeight ||\n    CesiumMath.equalsEpsilon(scale.x, 0.0, undefined, epsilonZeroScale) ||\n    CesiumMath.equalsEpsilon(scale.y, 0.0, undefined, epsilonZeroScale) ||\n    CesiumMath.equalsEpsilon(scale.z, 0.0, undefined, epsilonZeroScale)\n  ) {\n    return false;\n  }\n\n  this._minimumRadius = shapeMinRadius; // [0,1]\n  this._maximumRadius = shapeMaxRadius; // [0,1]\n  this._minimumHeight = shapeMinHeight; // [-1,+1]\n  this._maximumHeight = shapeMaxHeight; // [-1,+1]\n  this._minimumAngle = shapeMinAngle; // [-pi,+pi]\n  this._maximumAngle = shapeMaxAngle; // [-pi,+pi]\n\n  this.shapeTransform = Matrix4.clone(modelMatrix, this.shapeTransform);\n\n  this.orientedBoundingBox = getCylinderChunkObb(\n    renderMinRadius,\n    renderMaxRadius,\n    renderMinHeight,\n    renderMaxHeight,\n    renderMinAngle,\n    renderMaxAngle,\n    this.shapeTransform,\n    this.orientedBoundingBox,\n  );\n\n  this.boundTransform = Matrix4.fromRotationTranslation(\n    this.orientedBoundingBox.halfAxes,\n    this.orientedBoundingBox.center,\n    this.boundTransform,\n  );\n\n  this.boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this.orientedBoundingBox,\n    this.boundingSphere,\n  );\n\n  const shapeIsDefaultMaxRadius = shapeMaxRadius === defaultMaxRadius;\n  const shapeIsDefaultMinRadius = shapeMinRadius === defaultMinRadius;\n  const shapeIsDefaultRadius =\n    shapeIsDefaultMinRadius && shapeIsDefaultMaxRadius;\n  const shapeIsDefaultHeight =\n    shapeMinHeight === defaultMinHeight && shapeMaxHeight === defaultMaxHeight;\n  const shapeIsAngleReversed = shapeMaxAngle < shapeMinAngle;\n  const shapeAngleRange =\n    shapeMaxAngle - shapeMinAngle + shapeIsAngleReversed * defaultAngleRange;\n  const shapeIsAngleRegular =\n    shapeAngleRange > defaultAngleRangeHalf + epsilonAngle &&\n    shapeAngleRange < defaultAngleRange - epsilonAngle;\n  const shapeIsAngleFlipped =\n    shapeAngleRange < defaultAngleRangeHalf - epsilonAngle;\n  const shapeIsAngleRangeHalf =\n    shapeAngleRange >= defaultAngleRangeHalf - epsilonAngle &&\n    shapeAngleRange <= defaultAngleRangeHalf + epsilonAngle;\n  const shapeHasAngle =\n    shapeIsAngleRegular || shapeIsAngleFlipped || shapeIsAngleRangeHalf;\n  const shapeIsMinAngleDiscontinuity = CesiumMath.equalsEpsilon(\n    shapeMinAngle,\n    defaultMinAngle,\n    undefined,\n    epsilonAngleDiscontinuity,\n  );\n  const shapeIsMaxAngleDiscontinuity = CesiumMath.equalsEpsilon(\n    shapeMaxAngle,\n    defaultMaxAngle,\n    undefined,\n    epsilonAngleDiscontinuity,\n  );\n\n  const renderIsDefaultMinRadius = renderMinRadius === defaultMinRadius;\n  const renderIsAngleReversed = renderMaxAngle < renderMinAngle;\n  const renderAngleRange =\n    renderMaxAngle - renderMinAngle + renderIsAngleReversed * defaultAngleRange;\n  const renderIsAngleRegular =\n    renderAngleRange >= defaultAngleRangeHalf - epsilonAngle &&\n    renderAngleRange < defaultAngleRange - epsilonAngle;\n  const renderIsAngleFlipped =\n    renderAngleRange > epsilonAngle &&\n    renderAngleRange < defaultAngleRangeHalf - epsilonAngle;\n  const renderIsAngleRangeZero = renderAngleRange <= epsilonAngle;\n  const renderHasAngle =\n    renderIsAngleRegular || renderIsAngleFlipped || renderIsAngleRangeZero;\n\n  const { shaderUniforms, shaderDefines } = this;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n\n  if (!renderIsDefaultMinRadius) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\"] = intersectionCount;\n    intersectionCount += 1;\n  }\n  shaderUniforms.cylinderRenderRadiusMinMax = Cartesian2.fromElements(\n    renderMinRadius,\n    renderMaxRadius,\n    shaderUniforms.cylinderRenderRadiusMinMax,\n  );\n\n  if (renderMinRadius === renderMaxRadius) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\"] = true;\n  }\n  if (!shapeIsDefaultRadius) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_RADIUS\"] = true;\n\n    // delerp(radius, minRadius, maxRadius)\n    // (radius - minRadius) / (maxRadius - minRadius)\n    // radius / (maxRadius - minRadius) - minRadius / (maxRadius - minRadius)\n    // scale = 1.0 / (maxRadius - minRadius)\n    // offset = -minRadius / (maxRadius - minRadius)\n    // offset = minRadius / (minRadius - maxRadius)\n    const radiusRange = shapeMaxRadius - shapeMinRadius;\n    let scale = 0.0;\n    let offset = 1.0;\n    if (radiusRange !== 0.0) {\n      scale = 1.0 / radiusRange;\n      offset = -shapeMinRadius / radiusRange;\n    }\n    shaderUniforms.cylinderUvToShapeUvRadius = Cartesian2.fromElements(\n      scale,\n      offset,\n      shaderUniforms.cylinderUvToShapeUvRadius,\n    );\n  }\n\n  if (!shapeIsDefaultHeight) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT\"] = true;\n\n    // delerp(heightUv, minHeightUv, maxHeightUv)\n    // (heightUv - minHeightUv) / (maxHeightUv - minHeightUv)\n    // heightUv / (maxHeightUv - minHeightUv) - minHeightUv / (maxHeightUv - minHeightUv)\n    // scale = 1.0 / (maxHeightUv - minHeightUv)\n    // scale = 1.0 / ((maxHeight * 0.5 + 0.5) - (minHeight * 0.5 + 0.5))\n    // scale = 2.0 / (maxHeight - minHeight)\n    // offset = -minHeightUv / (maxHeightUv - minHeightUv)\n    // offset = -minHeightUv / ((maxHeight * 0.5 + 0.5) - (minHeight * 0.5 + 0.5))\n    // offset = -2.0 * (minHeight * 0.5 + 0.5) / (maxHeight - minHeight)\n    // offset = -(minHeight + 1.0) / (maxHeight - minHeight)\n    // offset = (minHeight + 1.0) / (minHeight - maxHeight)\n    const heightRange = shapeMaxHeight - shapeMinHeight;\n    let scale = 0.0;\n    let offset = 1.0;\n    if (heightRange !== 0.0) {\n      scale = 2.0 / heightRange;\n      offset = -(shapeMinHeight + 1.0) / heightRange;\n    }\n    shaderUniforms.cylinderUvToShapeUvHeight = Cartesian2.fromElements(\n      scale,\n      offset,\n      shaderUniforms.cylinderUvToShapeUvHeight,\n    );\n  }\n  shaderUniforms.cylinderRenderHeightMinMax = Cartesian2.fromElements(\n    renderMinHeight,\n    renderMaxHeight,\n    shaderUniforms.cylinderRenderHeightMinMax,\n  );\n\n  if (shapeIsAngleReversed) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED\"] = true;\n  }\n\n  if (renderHasAngle) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_ANGLE\"] = intersectionCount;\n\n    if (renderIsAngleRegular) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\"] = true;\n      intersectionCount += 1;\n    } else if (renderIsAngleFlipped) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\"] = true;\n      intersectionCount += 2;\n    } else if (renderIsAngleRangeZero) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\"] = true;\n      intersectionCount += 2;\n    }\n\n    shaderUniforms.cylinderRenderAngleMinMax = Cartesian2.fromElements(\n      renderMinAngle,\n      renderMaxAngle,\n      shaderUniforms.cylinderRenderAngleMinMax,\n    );\n  }\n\n  if (shapeHasAngle) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE\"] = true;\n    if (shapeIsMinAngleDiscontinuity) {\n      shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY\"] = true;\n    }\n    if (shapeIsMaxAngleDiscontinuity) {\n      shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY\"] = true;\n    }\n\n    const uvMinAngle = (shapeMinAngle - defaultMinAngle) / defaultAngleRange;\n    const uvMaxAngle = (shapeMaxAngle - defaultMinAngle) / defaultAngleRange;\n    const uvAngleRangeZero = 1.0 - shapeAngleRange / defaultAngleRange;\n\n    shaderUniforms.cylinderShapeUvAngleMinMax = Cartesian2.fromElements(\n      uvMinAngle,\n      uvMaxAngle,\n      shaderUniforms.cylinderShapeUvAngleMinMax,\n    );\n    shaderUniforms.cylinderShapeUvAngleRangeZeroMid =\n      (uvMaxAngle + 0.5 * uvAngleRangeZero) % 1.0;\n\n    // delerp(angleUv, uvMinAngle, uvMaxAngle)\n    // (angelUv - uvMinAngle) / (uvMaxAngle - uvMinAngle)\n    // angleUv / (uvMaxAngle - uvMinAngle) - uvMinAngle / (uvMaxAngle - uvMinAngle)\n    // scale = 1.0 / (uvMaxAngle - uvMinAngle)\n    // scale = 1.0 / (((maxAngle - pi) / (2.0 * pi)) - ((minAngle - pi) / (2.0 * pi)))\n    // scale = 2.0 * pi / (maxAngle - minAngle)\n    // offset = -uvMinAngle / (uvMaxAngle - uvMinAngle)\n    // offset = -((minAngle - pi) / (2.0 * pi)) / (((maxAngle - pi) / (2.0 * pi)) - ((minAngle - pi) / (2.0 * pi)))\n    // offset = -(minAngle - pi) / (maxAngle - minAngle)\n    if (shapeAngleRange <= epsilonAngle) {\n      shaderUniforms.cylinderUvToShapeUvAngle = Cartesian2.fromElements(\n        0.0,\n        1.0,\n        shaderUniforms.cylinderUvToShapeUvAngle,\n      );\n    } else {\n      const scale = defaultAngleRange / shapeAngleRange;\n      const offset = -(shapeMinAngle - defaultMinAngle) / shapeAngleRange;\n      shaderUniforms.cylinderUvToShapeUvAngle = Cartesian2.fromElements(\n        scale,\n        offset,\n        shaderUniforms.cylinderUvToShapeUvAngle,\n      );\n    }\n  }\n\n  this.shaderMaximumIntersectionsLength = intersectionCount;\n\n  return true;\n};\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForTile = function (\n  tileLevel,\n  tileX,\n  tileY,\n  tileZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minimumRadius = this._minimumRadius;\n  const maximumRadius = this._maximumRadius;\n  const minimumHeight = this._minimumHeight;\n  const maximumHeight = this._maximumHeight;\n  const minimumAngle = this._minimumAngle;\n  const maximumAngle = this._maximumAngle;\n\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n\n  const radiusStart = CesiumMath.lerp(\n    minimumRadius,\n    maximumRadius,\n    tileX * sizeAtLevel,\n  );\n  const radiusEnd = CesiumMath.lerp(\n    minimumRadius,\n    maximumRadius,\n    (tileX + 1) * sizeAtLevel,\n  );\n  const heightStart = CesiumMath.lerp(\n    minimumHeight,\n    maximumHeight,\n    tileY * sizeAtLevel,\n  );\n  const heightEnd = CesiumMath.lerp(\n    minimumHeight,\n    maximumHeight,\n    (tileY + 1) * sizeAtLevel,\n  );\n  const angleStart = CesiumMath.lerp(\n    minimumAngle,\n    maximumAngle,\n    tileZ * sizeAtLevel,\n  );\n  const angleEnd = CesiumMath.lerp(\n    minimumAngle,\n    maximumAngle,\n    (tileZ + 1) * sizeAtLevel,\n  );\n\n  return getCylinderChunkObb(\n    radiusStart,\n    radiusEnd,\n    heightStart,\n    heightEnd,\n    angleStart,\n    angleEnd,\n    this.shapeTransform,\n    result,\n  );\n};\n\nconst sampleSizeScratch = new Cartesian3();\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForSample = function (\n  spatialNode,\n  tileDimensions,\n  tileUv,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    tileDimensions,\n    sampleSizeScratch,\n  );\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(\n    sampleSize,\n    tileSizeAtLevel,\n    sampleSizeScratch,\n  );\n\n  const minLerp = Cartesian3.multiplyByScalar(\n    Cartesian3.fromElements(\n      spatialNode.x + tileUv.x,\n      spatialNode.y + tileUv.y,\n      spatialNode.z + tileUv.z,\n      scratchTileMinBounds,\n    ),\n    tileSizeAtLevel,\n    scratchTileMinBounds,\n  );\n  const maxLerp = Cartesian3.add(\n    minLerp,\n    sampleSizeAtLevel,\n    scratchTileMaxBounds,\n  );\n\n  const minimumRadius = this._minimumRadius;\n  const maximumRadius = this._maximumRadius;\n  const minimumHeight = this._minimumHeight;\n  const maximumHeight = this._maximumHeight;\n  const minimumAngle = this._minimumAngle;\n  const maximumAngle = this._maximumAngle;\n\n  const radiusStart = CesiumMath.lerp(minimumRadius, maximumRadius, minLerp.x);\n  const radiusEnd = CesiumMath.lerp(minimumRadius, maximumRadius, maxLerp.x);\n  const heightStart = CesiumMath.lerp(minimumHeight, maximumHeight, minLerp.y);\n  const heightEnd = CesiumMath.lerp(minimumHeight, maximumHeight, maxLerp.y);\n  const angleStart = CesiumMath.lerp(minimumAngle, maximumAngle, minLerp.z);\n  const angleEnd = CesiumMath.lerp(minimumAngle, maximumAngle, maxLerp.z);\n\n  return getCylinderChunkObb(\n    radiusStart,\n    radiusEnd,\n    heightStart,\n    heightEnd,\n    angleStart,\n    angleEnd,\n    this.shapeTransform,\n    result,\n  );\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum radius, height, angle.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMinBounds = Object.freeze(\n  new Cartesian3(0.0, -1.0, -CesiumMath.PI),\n);\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum radius, height, angle.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMaxBounds = Object.freeze(\n  new Cartesian3(1.0, +1.0, +CesiumMath.PI),\n);\n\nconst maxTestAngles = 5;\nconst scratchTestAngles = new Array(maxTestAngles);\nconst scratchTranslation = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchTranslationMatrix = new Matrix4();\nconst scratchRotationMatrix = new Matrix4();\nconst scratchScaleMatrix = new Matrix4();\nconst scratchMatrix = new Matrix4();\nconst scratchColumn0 = new Cartesian3();\nconst scratchColumn1 = new Cartesian3();\nconst scratchColumn2 = new Cartesian3();\nconst scratchCorners = new Array(8);\nfor (let i = 0; i < 8; i++) {\n  scratchCorners[i] = new Cartesian3();\n}\n\nfunction orthogonal(a, b, epsilon) {\n  return Math.abs(Cartesian4.dot(a, b)) < epsilon;\n}\n\nfunction isValidOrientedBoundingBoxTransformation(matrix) {\n  const column0 = Matrix4.getColumn(matrix, 0, scratchColumn0);\n  const column1 = Matrix4.getColumn(matrix, 1, scratchColumn1);\n  const column2 = Matrix4.getColumn(matrix, 2, scratchColumn2);\n\n  const epsilon = CesiumMath.EPSILON4;\n\n  return (\n    orthogonal(column0, column1, epsilon) &&\n    orthogonal(column1, column2, epsilon)\n  );\n}\n\nfunction computeLooseOrientedBoundingBox(matrix, result) {\n  const corners = scratchCorners;\n  Cartesian3.fromElements(-0.5, -0.5, -0.5, corners[0]);\n  Cartesian3.fromElements(-0.5, -0.5, 0.5, corners[1]);\n  Cartesian3.fromElements(-0.5, 0.5, -0.5, corners[2]);\n  Cartesian3.fromElements(-0.5, 0.5, 0.5, corners[3]);\n  Cartesian3.fromElements(0.5, -0.5, -0.5, corners[4]);\n  Cartesian3.fromElements(0.5, -0.5, 0.5, corners[5]);\n  Cartesian3.fromElements(0.5, 0.5, -0.5, corners[6]);\n  Cartesian3.fromElements(0.5, 0.5, 0.5, corners[7]);\n\n  for (let i = 0; i < 8; ++i) {\n    Matrix4.multiplyByPoint(matrix, corners[i], corners[i]);\n  }\n\n  return OrientedBoundingBox.fromPoints(corners, result);\n}\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {number} radiusStart The radiusStart.\n * @param {number} radiusEnd The radiusEnd.\n * @param {number} heightStart The heightStart.\n * @param {number} heightEnd The heightEnd.\n * @param {number} angleStart The angleStart.\n * @param {number} angleEnd The angleEnd.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getCylinderChunkObb(\n  radiusStart,\n  radiusEnd,\n  heightStart,\n  heightEnd,\n  angleStart,\n  angleEnd,\n  matrix,\n  result,\n) {\n  const defaultMinBounds = VoxelCylinderShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelCylinderShape.DefaultMaxBounds;\n  const defaultMinRadius = defaultMinBounds.x; // 0\n  const defaultMaxRadius = defaultMaxBounds.x; // 1\n  const defaultMinHeight = defaultMinBounds.y; // -1\n  const defaultMaxHeight = defaultMaxBounds.y; // +1\n  const defaultMinAngle = defaultMinBounds.z; // -pi\n  const defaultMaxAngle = defaultMaxBounds.z; // +pi\n\n  // Return early if using the default bounds\n  if (\n    radiusStart === defaultMinRadius &&\n    radiusEnd === defaultMaxRadius &&\n    heightStart === defaultMinHeight &&\n    heightEnd === defaultMaxHeight &&\n    angleStart === defaultMinAngle &&\n    angleEnd === defaultMaxAngle\n  ) {\n    result.center = Matrix4.getTranslation(matrix, result.center);\n    result.halfAxes = Matrix4.getMatrix3(matrix, result.halfAxes);\n    return result;\n  }\n\n  const isAngleReversed = angleEnd < angleStart;\n\n  if (isAngleReversed) {\n    angleEnd += CesiumMath.TWO_PI;\n  }\n\n  const angleRange = angleEnd - angleStart;\n  const angleMid = angleStart + angleRange * 0.5;\n\n  const testAngles = scratchTestAngles;\n  let testAngleCount = 0;\n\n  testAngles[testAngleCount++] = angleStart;\n  testAngles[testAngleCount++] = angleEnd;\n  testAngles[testAngleCount++] = angleMid;\n\n  if (angleRange > CesiumMath.PI) {\n    testAngles[testAngleCount++] = angleMid - CesiumMath.PI_OVER_TWO;\n    testAngles[testAngleCount++] = angleMid + CesiumMath.PI_OVER_TWO;\n  }\n\n  // Find bounding box in shape space relative to angleMid\n  let minX = 1.0;\n  let minY = 1.0;\n  let maxX = -1.0;\n  let maxY = -1.0;\n\n  for (let i = 0; i < testAngleCount; ++i) {\n    const angle = testAngles[i] - angleMid;\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const x1 = cosAngle * radiusStart;\n    const y1 = sinAngle * radiusStart;\n    const x2 = cosAngle * radiusEnd;\n    const y2 = sinAngle * radiusEnd;\n\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    minX = Math.min(minX, x2);\n    minY = Math.min(minY, y2);\n    maxX = Math.max(maxX, x1);\n    maxY = Math.max(maxY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  }\n\n  const extentX = maxX - minX;\n  const extentY = maxY - minY;\n  const extentZ = heightEnd - heightStart;\n\n  const centerX = (minX + maxX) * 0.5;\n  const centerY = (minY + maxY) * 0.5;\n  const centerZ = (heightStart + heightEnd) * 0.5;\n\n  const translation = Cartesian3.fromElements(\n    centerX,\n    centerY,\n    centerZ,\n    scratchTranslation,\n  );\n\n  const rotation = Matrix3.fromRotationZ(angleMid, scratchRotation);\n\n  const scale = Cartesian3.fromElements(\n    extentX,\n    extentY,\n    extentZ,\n    scratchScale,\n  );\n\n  const scaleMatrix = Matrix4.fromScale(scale, scratchScaleMatrix);\n  const rotationMatrix = Matrix4.fromRotation(rotation, scratchRotationMatrix);\n  const translationMatrix = Matrix4.fromTranslation(\n    translation,\n    scratchTranslationMatrix,\n  );\n\n  // Shape space matrix = R * T * S\n  const localMatrix = Matrix4.multiplyTransformation(\n    rotationMatrix,\n    Matrix4.multiplyTransformation(\n      translationMatrix,\n      scaleMatrix,\n      scratchMatrix,\n    ),\n    scratchMatrix,\n  );\n\n  const globalMatrix = Matrix4.multiplyTransformation(\n    matrix,\n    localMatrix,\n    scratchMatrix,\n  );\n\n  if (!isValidOrientedBoundingBoxTransformation(globalMatrix)) {\n    return computeLooseOrientedBoundingBox(globalMatrix, result);\n  }\n\n  return OrientedBoundingBox.fromTransformation(globalMatrix, result);\n}\n\nexport default VoxelCylinderShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}