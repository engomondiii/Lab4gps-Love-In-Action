{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\n\n/**\n * @alias Megatexture\n * @constructor\n *\n * @param {Context} context\n * @param {Cartesian3} dimensions\n * @param {number} channelCount\n * @param {MetadataComponentType} componentType\n * @param {number} [textureMemoryByteLength]\n *\n * @private\n */\nfunction Megatexture(context, dimensions, channelCount, componentType, textureMemoryByteLength) {\n  // TODO there are a lot of texture packing rules, see https://github.com/CesiumGS/cesium/issues/9572\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n  const supportsFloatingPointTexture = context.floatingPointTexture;\n  if (componentType === MetadataComponentType.FLOAT32 && !supportsFloatingPointTexture) {\n    throw new RuntimeError(\"Floating point texture not supported\");\n  }\n\n  // TODO support more\n  let pixelType;\n  if (componentType === MetadataComponentType.FLOAT32 || componentType === MetadataComponentType.FLOAT64) {\n    pixelType = PixelDatatype.FLOAT;\n  } else if (componentType === MetadataComponentType.UINT8) {\n    pixelType = PixelDatatype.UNSIGNED_BYTE;\n  }\n  let pixelFormat;\n  if (channelCount === 1) {\n    pixelFormat = context.webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE;\n  } else if (channelCount === 2) {\n    pixelFormat = context.webgl2 ? PixelFormat.RG : PixelFormat.LUMINANCE_ALPHA;\n  } else if (channelCount === 3) {\n    pixelFormat = PixelFormat.RGB;\n  } else if (channelCount === 4) {\n    pixelFormat = PixelFormat.RGBA;\n  }\n  const maximumTextureMemoryByteLength = 512 * 1024 * 1024;\n  const defaultTextureMemoryByteLength = 128 * 1024 * 1024;\n  textureMemoryByteLength = Math.min(defaultValue(textureMemoryByteLength, defaultTextureMemoryByteLength), maximumTextureMemoryByteLength);\n  const maximumTextureDimensionContext = ContextLimits.maximumTextureSize;\n  const componentTypeByteLength = MetadataComponentType.getSizeInBytes(componentType);\n  const texelCount = Math.floor(textureMemoryByteLength / (channelCount * componentTypeByteLength));\n  const textureDimension = Math.min(maximumTextureDimensionContext, CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(texelCount))));\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n  const regionCountPerMegatextureX = Math.floor(textureDimension / voxelCountPerRegionX);\n  const regionCountPerMegatextureY = Math.floor(textureDimension / voxelCountPerRegionY);\n  if (regionCountPerMegatextureX === 0 || regionCountPerMegatextureY === 0) {\n    throw new RuntimeError(\"Tileset is too large to fit into megatexture\");\n  }\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.channelCount = channelCount;\n\n  /**\n   * @type {MetadataComponentType}\n   * @readonly\n   */\n  this.componentType = componentType;\n\n  /**\n   * @type {Cartesian3}\n   * @readonly\n   */\n  this.voxelCountPerTile = Cartesian3.clone(dimensions, new Cartesian3());\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.maximumTileCount = regionCountPerMegatextureX * regionCountPerMegatextureY;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionCountPerMegatexture = new Cartesian2(regionCountPerMegatextureX, regionCountPerMegatextureY);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelCountPerRegion = new Cartesian2(voxelCountPerRegionX, voxelCountPerRegionY);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceCountPerRegion = new Cartesian2(sliceCountPerRegionX, sliceCountPerRegionY);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelSizeUv = new Cartesian2(1.0 / textureDimension, 1.0 / textureDimension);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceSizeUv = new Cartesian2(dimensions.x / textureDimension, dimensions.y / textureDimension);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionSizeUv = new Cartesian2(voxelCountPerRegionX / textureDimension, voxelCountPerRegionY / textureDimension);\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.texture = new Texture({\n    context: context,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelType,\n    flipY: false,\n    width: textureDimension,\n    height: textureDimension,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    })\n  });\n  const componentDatatype = MetadataComponentType.toComponentDatatype(componentType);\n\n  /**\n   * @type {Array}\n   */\n  this.tileVoxelDataTemp = ComponentDatatype.createTypedArray(componentDatatype, voxelCountPerRegionX * voxelCountPerRegionY * channelCount);\n\n  /**\n   * @type {MegatextureNode[]}\n   * @readonly\n   */\n  this.nodes = new Array(this.maximumTileCount);\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    this.nodes[tileIndex] = new MegatextureNode(tileIndex);\n  }\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    const node = this.nodes[tileIndex];\n    node.previousNode = tileIndex > 0 ? this.nodes[tileIndex - 1] : undefined;\n    node.nextNode = tileIndex < this.maximumTileCount - 1 ? this.nodes[tileIndex + 1] : undefined;\n  }\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.occupiedList = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.emptyList = this.nodes[0];\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.occupiedCount = 0;\n}\n\n/**\n * @alias MegatextureNode\n * @constructor\n *\n * @param {number} index\n *\n * @private\n */\nfunction MegatextureNode(index) {\n  /**\n   * @type {number}\n   */\n  this.index = index;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.nextNode = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.previousNode = undefined;\n}\n\n/**\n * @param {Array} data\n * @returns {number}\n */\nMegatexture.prototype.add = function (data) {\n  if (this.isFull()) {\n    throw new DeveloperError(\"Trying to add when there are no empty spots\");\n  }\n\n  // remove head of empty list\n  const node = this.emptyList;\n  this.emptyList = this.emptyList.nextNode;\n  if (defined(this.emptyList)) {\n    this.emptyList.previousNode = undefined;\n  }\n\n  // make head of occupied list\n  node.nextNode = this.occupiedList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  this.occupiedList = node;\n  const index = node.index;\n  this.writeDataToTexture(index, data);\n  this.occupiedCount++;\n  return index;\n};\n\n/**\n * @param {number} index\n */\nMegatexture.prototype.remove = function (index) {\n  if (index < 0 || index >= this.maximumTileCount) {\n    throw new DeveloperError(\"Megatexture index out of bounds\");\n  }\n\n  // remove from list\n  const node = this.nodes[index];\n  if (defined(node.previousNode)) {\n    node.previousNode.nextNode = node.nextNode;\n  }\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node.previousNode;\n  }\n\n  // make head of empty list\n  node.nextNode = this.emptyList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  node.previousNode = undefined;\n  this.emptyList = node;\n  this.occupiedCount--;\n};\n\n/**\n * @returns {boolean}\n */\nMegatexture.prototype.isFull = function () {\n  return this.emptyList === undefined;\n};\n\n/**\n * @param {number} tileCount\n * @param {Cartesian3} dimensions\n * @param {number} channelCount number of channels in the metadata. Must be 1 to 4.\n * @param {MetadataComponentType} componentType\n * @returns {number}\n */\nMegatexture.getApproximateTextureMemoryByteLength = function (tileCount, dimensions, channelCount, componentType) {\n  // TODO there's a lot of code duplicate with Megatexture constructor\n\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n  const datatypeSizeInBytes = MetadataComponentType.getSizeInBytes(componentType);\n  const voxelCountTotal = tileCount * dimensions.x * dimensions.y * dimensions.z;\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n\n  // Find the power of two that can fit all tile data, accounting for slices.\n  // There's probably a non-iterative solution for this, but this is good enough for now.\n  let textureDimension = CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(voxelCountTotal)));\n  for (;;) {\n    const regionCountX = Math.floor(textureDimension / voxelCountPerRegionX);\n    const regionCountY = Math.floor(textureDimension / voxelCountPerRegionY);\n    const regionCount = regionCountX * regionCountY;\n    if (regionCount >= tileCount) {\n      break;\n    } else {\n      textureDimension *= 2;\n    }\n  }\n  const textureMemoryByteLength = textureDimension * textureDimension * channelCount * datatypeSizeInBytes;\n  return textureMemoryByteLength;\n};\n\n/**\n * @param {number} index\n * @param {Float32Array|Uint16Array|Uint8Array} data\n */\nMegatexture.prototype.writeDataToTexture = function (index, data) {\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  const tileData = data.constructor === Uint16Array ? new Float32Array(data) : data;\n  const voxelDimensionsPerTile = this.voxelCountPerTile;\n  const sliceDimensionsPerRegion = this.sliceCountPerRegion;\n  const voxelDimensionsPerRegion = this.voxelCountPerRegion;\n  const channelCount = this.channelCount;\n  const tileVoxelData = this.tileVoxelDataTemp;\n  for (let z = 0; z < voxelDimensionsPerTile.z; z++) {\n    const sliceVoxelOffsetX = z % sliceDimensionsPerRegion.x * voxelDimensionsPerTile.x;\n    const sliceVoxelOffsetY = Math.floor(z / sliceDimensionsPerRegion.x) * voxelDimensionsPerTile.y;\n    for (let y = 0; y < voxelDimensionsPerTile.y; y++) {\n      for (let x = 0; x < voxelDimensionsPerTile.x; x++) {\n        const readIndex = z * voxelDimensionsPerTile.y * voxelDimensionsPerTile.x + y * voxelDimensionsPerTile.x + x;\n        const writeIndex = (sliceVoxelOffsetY + y) * voxelDimensionsPerRegion.x + (sliceVoxelOffsetX + x);\n        for (let c = 0; c < channelCount; c++) {\n          tileVoxelData[writeIndex * channelCount + c] = tileData[readIndex * channelCount + c];\n        }\n      }\n    }\n  }\n  const regionDimensionsPerMegatexture = this.regionCountPerMegatexture;\n  const voxelWidth = voxelDimensionsPerRegion.x;\n  const voxelHeight = voxelDimensionsPerRegion.y;\n  const voxelOffsetX = index % regionDimensionsPerMegatexture.x * voxelDimensionsPerRegion.x;\n  const voxelOffsetY = Math.floor(index / regionDimensionsPerMegatexture.x) * voxelDimensionsPerRegion.y;\n  const source = {\n    arrayBufferView: tileVoxelData,\n    width: voxelWidth,\n    height: voxelHeight\n  };\n  const copyOptions = {\n    source: source,\n    xOffset: voxelOffsetX,\n    yOffset: voxelOffsetY\n  };\n  this.texture.copyFrom(copyOptions);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Megatexture#destroy\n */\nMegatexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see Megatexture#isDestroyed\n *\n * @example\n * megatexture = megatexture && megatexture.destroy();\n */\nMegatexture.prototype.destroy = function () {\n  this.texture = this.texture && this.texture.destroy();\n  return destroyObject(this);\n};\nexport default Megatexture;","map":{"version":3,"names":["Cartesian2","Cartesian3","ComponentDatatype","ContextLimits","defaultValue","defined","destroyObject","DeveloperError","CesiumMath","MetadataComponentType","PixelDatatype","PixelFormat","RuntimeError","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","Megatexture","context","dimensions","channelCount","componentType","textureMemoryByteLength","UNSIGNED_SHORT","FLOAT32","supportsFloatingPointTexture","floatingPointTexture","pixelType","FLOAT64","FLOAT","UINT8","UNSIGNED_BYTE","pixelFormat","webgl2","RED","LUMINANCE","RG","LUMINANCE_ALPHA","RGB","RGBA","maximumTextureMemoryByteLength","defaultTextureMemoryByteLength","Math","min","maximumTextureDimensionContext","maximumTextureSize","componentTypeByteLength","getSizeInBytes","texelCount","floor","textureDimension","previousPowerOfTwo","sqrt","sliceCountPerRegionX","ceil","x","sliceCountPerRegionY","z","voxelCountPerRegionX","voxelCountPerRegionY","y","regionCountPerMegatextureX","regionCountPerMegatextureY","voxelCountPerTile","clone","maximumTileCount","regionCountPerMegatexture","voxelCountPerRegion","sliceCountPerRegion","voxelSizeUv","sliceSizeUv","regionSizeUv","texture","pixelDatatype","flipY","width","height","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR","magnificationFilter","componentDatatype","toComponentDatatype","tileVoxelDataTemp","createTypedArray","nodes","Array","tileIndex","MegatextureNode","node","previousNode","undefined","nextNode","occupiedList","emptyList","occupiedCount","index","prototype","add","data","isFull","writeDataToTexture","remove","getApproximateTextureMemoryByteLength","tileCount","datatypeSizeInBytes","voxelCountTotal","regionCountX","regionCountY","regionCount","tileData","constructor","Uint16Array","Float32Array","voxelDimensionsPerTile","sliceDimensionsPerRegion","voxelDimensionsPerRegion","tileVoxelData","sliceVoxelOffsetX","sliceVoxelOffsetY","readIndex","writeIndex","c","regionDimensionsPerMegatexture","voxelWidth","voxelHeight","voxelOffsetX","voxelOffsetY","source","arrayBufferView","copyOptions","xOffset","yOffset","copyFrom","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Megatexture.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\n\n/**\n * @alias Megatexture\n * @constructor\n *\n * @param {Context} context\n * @param {Cartesian3} dimensions\n * @param {number} channelCount\n * @param {MetadataComponentType} componentType\n * @param {number} [textureMemoryByteLength]\n *\n * @private\n */\nfunction Megatexture(\n  context,\n  dimensions,\n  channelCount,\n  componentType,\n  textureMemoryByteLength,\n) {\n  // TODO there are a lot of texture packing rules, see https://github.com/CesiumGS/cesium/issues/9572\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n\n  const supportsFloatingPointTexture = context.floatingPointTexture;\n  if (\n    componentType === MetadataComponentType.FLOAT32 &&\n    !supportsFloatingPointTexture\n  ) {\n    throw new RuntimeError(\"Floating point texture not supported\");\n  }\n\n  // TODO support more\n  let pixelType;\n  if (\n    componentType === MetadataComponentType.FLOAT32 ||\n    componentType === MetadataComponentType.FLOAT64\n  ) {\n    pixelType = PixelDatatype.FLOAT;\n  } else if (componentType === MetadataComponentType.UINT8) {\n    pixelType = PixelDatatype.UNSIGNED_BYTE;\n  }\n\n  let pixelFormat;\n  if (channelCount === 1) {\n    pixelFormat = context.webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE;\n  } else if (channelCount === 2) {\n    pixelFormat = context.webgl2 ? PixelFormat.RG : PixelFormat.LUMINANCE_ALPHA;\n  } else if (channelCount === 3) {\n    pixelFormat = PixelFormat.RGB;\n  } else if (channelCount === 4) {\n    pixelFormat = PixelFormat.RGBA;\n  }\n\n  const maximumTextureMemoryByteLength = 512 * 1024 * 1024;\n  const defaultTextureMemoryByteLength = 128 * 1024 * 1024;\n  textureMemoryByteLength = Math.min(\n    defaultValue(textureMemoryByteLength, defaultTextureMemoryByteLength),\n    maximumTextureMemoryByteLength,\n  );\n  const maximumTextureDimensionContext = ContextLimits.maximumTextureSize;\n  const componentTypeByteLength =\n    MetadataComponentType.getSizeInBytes(componentType);\n  const texelCount = Math.floor(\n    textureMemoryByteLength / (channelCount * componentTypeByteLength),\n  );\n  const textureDimension = Math.min(\n    maximumTextureDimensionContext,\n    CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(texelCount))),\n  );\n\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n  const regionCountPerMegatextureX = Math.floor(\n    textureDimension / voxelCountPerRegionX,\n  );\n  const regionCountPerMegatextureY = Math.floor(\n    textureDimension / voxelCountPerRegionY,\n  );\n\n  if (regionCountPerMegatextureX === 0 || regionCountPerMegatextureY === 0) {\n    throw new RuntimeError(\"Tileset is too large to fit into megatexture\");\n  }\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.channelCount = channelCount;\n\n  /**\n   * @type {MetadataComponentType}\n   * @readonly\n   */\n  this.componentType = componentType;\n\n  /**\n   * @type {Cartesian3}\n   * @readonly\n   */\n  this.voxelCountPerTile = Cartesian3.clone(dimensions, new Cartesian3());\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.maximumTileCount =\n    regionCountPerMegatextureX * regionCountPerMegatextureY;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionCountPerMegatexture = new Cartesian2(\n    regionCountPerMegatextureX,\n    regionCountPerMegatextureY,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelCountPerRegion = new Cartesian2(\n    voxelCountPerRegionX,\n    voxelCountPerRegionY,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceCountPerRegion = new Cartesian2(\n    sliceCountPerRegionX,\n    sliceCountPerRegionY,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelSizeUv = new Cartesian2(\n    1.0 / textureDimension,\n    1.0 / textureDimension,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceSizeUv = new Cartesian2(\n    dimensions.x / textureDimension,\n    dimensions.y / textureDimension,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionSizeUv = new Cartesian2(\n    voxelCountPerRegionX / textureDimension,\n    voxelCountPerRegionY / textureDimension,\n  );\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.texture = new Texture({\n    context: context,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelType,\n    flipY: false,\n    width: textureDimension,\n    height: textureDimension,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  const componentDatatype =\n    MetadataComponentType.toComponentDatatype(componentType);\n\n  /**\n   * @type {Array}\n   */\n  this.tileVoxelDataTemp = ComponentDatatype.createTypedArray(\n    componentDatatype,\n    voxelCountPerRegionX * voxelCountPerRegionY * channelCount,\n  );\n\n  /**\n   * @type {MegatextureNode[]}\n   * @readonly\n   */\n  this.nodes = new Array(this.maximumTileCount);\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    this.nodes[tileIndex] = new MegatextureNode(tileIndex);\n  }\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    const node = this.nodes[tileIndex];\n    node.previousNode = tileIndex > 0 ? this.nodes[tileIndex - 1] : undefined;\n    node.nextNode =\n      tileIndex < this.maximumTileCount - 1\n        ? this.nodes[tileIndex + 1]\n        : undefined;\n  }\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.occupiedList = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.emptyList = this.nodes[0];\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.occupiedCount = 0;\n}\n\n/**\n * @alias MegatextureNode\n * @constructor\n *\n * @param {number} index\n *\n * @private\n */\nfunction MegatextureNode(index) {\n  /**\n   * @type {number}\n   */\n  this.index = index;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.nextNode = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.previousNode = undefined;\n}\n\n/**\n * @param {Array} data\n * @returns {number}\n */\nMegatexture.prototype.add = function (data) {\n  if (this.isFull()) {\n    throw new DeveloperError(\"Trying to add when there are no empty spots\");\n  }\n\n  // remove head of empty list\n  const node = this.emptyList;\n  this.emptyList = this.emptyList.nextNode;\n  if (defined(this.emptyList)) {\n    this.emptyList.previousNode = undefined;\n  }\n\n  // make head of occupied list\n  node.nextNode = this.occupiedList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  this.occupiedList = node;\n\n  const index = node.index;\n  this.writeDataToTexture(index, data);\n\n  this.occupiedCount++;\n  return index;\n};\n\n/**\n * @param {number} index\n */\nMegatexture.prototype.remove = function (index) {\n  if (index < 0 || index >= this.maximumTileCount) {\n    throw new DeveloperError(\"Megatexture index out of bounds\");\n  }\n\n  // remove from list\n  const node = this.nodes[index];\n  if (defined(node.previousNode)) {\n    node.previousNode.nextNode = node.nextNode;\n  }\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node.previousNode;\n  }\n\n  // make head of empty list\n  node.nextNode = this.emptyList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  node.previousNode = undefined;\n  this.emptyList = node;\n  this.occupiedCount--;\n};\n\n/**\n * @returns {boolean}\n */\nMegatexture.prototype.isFull = function () {\n  return this.emptyList === undefined;\n};\n\n/**\n * @param {number} tileCount\n * @param {Cartesian3} dimensions\n * @param {number} channelCount number of channels in the metadata. Must be 1 to 4.\n * @param {MetadataComponentType} componentType\n * @returns {number}\n */\nMegatexture.getApproximateTextureMemoryByteLength = function (\n  tileCount,\n  dimensions,\n  channelCount,\n  componentType,\n) {\n  // TODO there's a lot of code duplicate with Megatexture constructor\n\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n\n  const datatypeSizeInBytes =\n    MetadataComponentType.getSizeInBytes(componentType);\n  const voxelCountTotal =\n    tileCount * dimensions.x * dimensions.y * dimensions.z;\n\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n\n  // Find the power of two that can fit all tile data, accounting for slices.\n  // There's probably a non-iterative solution for this, but this is good enough for now.\n  let textureDimension = CesiumMath.previousPowerOfTwo(\n    Math.floor(Math.sqrt(voxelCountTotal)),\n  );\n  for (;;) {\n    const regionCountX = Math.floor(textureDimension / voxelCountPerRegionX);\n    const regionCountY = Math.floor(textureDimension / voxelCountPerRegionY);\n    const regionCount = regionCountX * regionCountY;\n    if (regionCount >= tileCount) {\n      break;\n    } else {\n      textureDimension *= 2;\n    }\n  }\n\n  const textureMemoryByteLength =\n    textureDimension * textureDimension * channelCount * datatypeSizeInBytes;\n  return textureMemoryByteLength;\n};\n\n/**\n * @param {number} index\n * @param {Float32Array|Uint16Array|Uint8Array} data\n */\nMegatexture.prototype.writeDataToTexture = function (index, data) {\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  const tileData =\n    data.constructor === Uint16Array ? new Float32Array(data) : data;\n\n  const voxelDimensionsPerTile = this.voxelCountPerTile;\n  const sliceDimensionsPerRegion = this.sliceCountPerRegion;\n  const voxelDimensionsPerRegion = this.voxelCountPerRegion;\n  const channelCount = this.channelCount;\n\n  const tileVoxelData = this.tileVoxelDataTemp;\n  for (let z = 0; z < voxelDimensionsPerTile.z; z++) {\n    const sliceVoxelOffsetX =\n      (z % sliceDimensionsPerRegion.x) * voxelDimensionsPerTile.x;\n    const sliceVoxelOffsetY =\n      Math.floor(z / sliceDimensionsPerRegion.x) * voxelDimensionsPerTile.y;\n    for (let y = 0; y < voxelDimensionsPerTile.y; y++) {\n      for (let x = 0; x < voxelDimensionsPerTile.x; x++) {\n        const readIndex =\n          z * voxelDimensionsPerTile.y * voxelDimensionsPerTile.x +\n          y * voxelDimensionsPerTile.x +\n          x;\n        const writeIndex =\n          (sliceVoxelOffsetY + y) * voxelDimensionsPerRegion.x +\n          (sliceVoxelOffsetX + x);\n        for (let c = 0; c < channelCount; c++) {\n          tileVoxelData[writeIndex * channelCount + c] =\n            tileData[readIndex * channelCount + c];\n        }\n      }\n    }\n  }\n\n  const regionDimensionsPerMegatexture = this.regionCountPerMegatexture;\n  const voxelWidth = voxelDimensionsPerRegion.x;\n  const voxelHeight = voxelDimensionsPerRegion.y;\n  const voxelOffsetX =\n    (index % regionDimensionsPerMegatexture.x) * voxelDimensionsPerRegion.x;\n  const voxelOffsetY =\n    Math.floor(index / regionDimensionsPerMegatexture.x) *\n    voxelDimensionsPerRegion.y;\n\n  const source = {\n    arrayBufferView: tileVoxelData,\n    width: voxelWidth,\n    height: voxelHeight,\n  };\n\n  const copyOptions = {\n    source: source,\n    xOffset: voxelOffsetX,\n    yOffset: voxelOffsetY,\n  };\n\n  this.texture.copyFrom(copyOptions);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Megatexture#destroy\n */\nMegatexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see Megatexture#isDestroyed\n *\n * @example\n * megatexture = megatexture && megatexture.destroy();\n */\nMegatexture.prototype.destroy = function () {\n  this.texture = this.texture && this.texture.destroy();\n  return destroyObject(this);\n};\n\nexport default Megatexture;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}