{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport PassThrough from \"../Shaders/PostProcessStages/PassThrough.js\";\nimport PostProcessStageLibrary from \"./PostProcessStageLibrary.js\";\nimport PostProcessStageTextureCache from \"./PostProcessStageTextureCache.js\";\nimport Tonemapper, { validateTonemapper } from \"./Tonemapper.js\";\nconst stackScratch = [];\n\n/**\n * A collection of {@link PostProcessStage}s and/or {@link PostProcessStageComposite}s.\n * <p>\n * The input texture for each post-process stage is the texture rendered to by the scene or the texture rendered\n * to by the previous stage in the collection.\n * </p>\n * <p>\n * If the ambient occlusion or bloom stages are enabled, they will execute before all other stages.\n * </p>\n * <p>\n * If the FXAA stage is enabled, it will execute after all other stages.\n * </p>\n *\n * @alias PostProcessStageCollection\n * @constructor\n */\nfunction PostProcessStageCollection() {\n  const fxaa = PostProcessStageLibrary.createFXAAStage();\n  const ao = PostProcessStageLibrary.createAmbientOcclusionStage();\n  const bloom = PostProcessStageLibrary.createBloomStage();\n\n  // Auto-exposure is currently disabled because most shaders output a value in [0.0, 1.0].\n  // Some shaders, such as the atmosphere and ground atmosphere, output values slightly over 1.0.\n  this._autoExposureEnabled = false;\n  this._autoExposure = PostProcessStageLibrary.createAutoExposureStage();\n  this._exposure = 1.0;\n  this._tonemapping = undefined;\n  this._tonemapper = undefined;\n\n  // set tonemapper and tonemapping using the setter\n  this.tonemapper = Tonemapper.PBR_NEUTRAL;\n  const tonemapping = this._tonemapping;\n  fxaa.enabled = false;\n  ao.enabled = false;\n  bloom.enabled = false;\n  tonemapping.enabled = false; // will be enabled if necessary in update\n\n  const textureCache = new PostProcessStageTextureCache(this);\n  const stageNames = {};\n  const stack = stackScratch;\n  stack.push(fxaa, ao, bloom, tonemapping);\n  while (stack.length > 0) {\n    const stage = stack.pop();\n    stageNames[stage.name] = stage;\n    stage._textureCache = textureCache;\n    const length = stage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(stage.get(i));\n      }\n    }\n  }\n  this._stages = [];\n  this._activeStages = [];\n  this._previousActiveStages = [];\n  this._randomTexture = undefined; // For AO\n\n  const that = this;\n  ao.uniforms.randomTexture = function () {\n    return that._randomTexture;\n  };\n  this._ao = ao;\n  this._bloom = bloom;\n  this._fxaa = fxaa;\n  this._aoEnabled = undefined;\n  this._bloomEnabled = undefined;\n  this._tonemappingEnabled = undefined;\n  this._fxaaEnabled = undefined;\n  this._activeStagesChanged = false;\n  this._stagesRemoved = false;\n  this._textureCacheDirty = false;\n  this._stageNames = stageNames;\n  this._textureCache = textureCache;\n}\nObject.defineProperties(PostProcessStageCollection.prototype, {\n  /**\n   * Determines if all of the post-process stages in the collection are ready to be executed.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      let readyAndEnabled = false;\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = length - 1; i >= 0; --i) {\n        const stage = stages[i];\n        readyAndEnabled = readyAndEnabled || stage.ready && stage.enabled;\n      }\n      const fxaa = this._fxaa;\n      const ao = this._ao;\n      const bloom = this._bloom;\n      const tonemapping = this._tonemapping;\n      readyAndEnabled = readyAndEnabled || fxaa.ready && fxaa.enabled;\n      readyAndEnabled = readyAndEnabled || ao.ready && ao.enabled;\n      readyAndEnabled = readyAndEnabled || bloom.ready && bloom.enabled;\n      readyAndEnabled = readyAndEnabled || tonemapping.ready && tonemapping.enabled;\n      return readyAndEnabled;\n    }\n  },\n  /**\n   * A post-process stage for Fast Approximate Anti-aliasing.\n   * <p>\n   * When enabled, this stage will execute after all others.\n   * </p>\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {PostProcessStage}\n   * @readonly\n   */\n  fxaa: {\n    get: function () {\n      return this._fxaa;\n    }\n  },\n  /**\n   * A post-process stage that applies Horizon-based Ambient Occlusion (HBAO) to the input texture.\n   * <p>\n   * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the\n   * surface receives light and regardless of the light's position.\n   * </p>\n   * <p>\n   * The uniforms have the following properties:\n   * <ul>\n   * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>\n   * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,\n   * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>\n   * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,\n   * sampling stops in the current direction. The default value is <code>0.26</code>.</li>\n   * <li><code>directionCount</code> is the number of directions along which the ray marching will search for occluders. The default value is <code>8</code>.</li>\n   * <li><code>stepCount</code> is the number of steps the ray marching will take along each direction. The default value is <code>32</code>.</li>\n   * <li><code>randomTexture</code> is a texture where the red channel is a random value in [0.0, 1.0]. The default value is <code>undefined</code>. This texture needs to be set.</li>\n   * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated\n   * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>\n   * </ul>\n   * <p>\n   * When enabled, this stage will execute before all others.\n   * </p>\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {PostProcessStageComposite}\n   * @readonly\n   */\n  ambientOcclusion: {\n    get: function () {\n      return this._ao;\n    }\n  },\n  /**\n   * A post-process stage for a bloom effect.\n   * <p>\n   * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.\n   * </p>\n   * <p>\n   * This stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,\n   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n   * </p>\n   * <ul>\n   * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>\n   *\n   * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is\n   * added to the brightness. The default value is <code>-0.3</code>.</li>\n   *\n   * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.\n   * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>\n   * </ul>\n   * <p>\n   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n   * The blur is applied to the shadows generated from the image to make them smoother.\n   * </p>\n   * <p>\n   * When enabled, this stage will execute before all others.\n   * </p>\n   *\n   * @memberOf PostProcessStageCollection.prototype\n   * @type {PostProcessStageComposite}\n   * @readonly\n   */\n  bloom: {\n    get: function () {\n      return this._bloom;\n    }\n  },\n  /**\n   * The number of post-process stages in this collection.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      removeStages(this);\n      return this._stages.length;\n    }\n  },\n  /**\n   * A reference to the last texture written to when executing the post-process stages in this collection.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      const fxaa = this._fxaa;\n      if (fxaa.enabled && fxaa.ready) {\n        return this.getOutputTexture(fxaa.name);\n      }\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = length - 1; i >= 0; --i) {\n        const stage = stages[i];\n        if (defined(stage) && stage.ready && stage.enabled) {\n          return this.getOutputTexture(stage.name);\n        }\n      }\n      const tonemapping = this._tonemapping;\n      if (tonemapping.enabled && tonemapping.ready) {\n        return this.getOutputTexture(tonemapping.name);\n      }\n      const bloom = this._bloom;\n      if (bloom.enabled && bloom.ready) {\n        return this.getOutputTexture(bloom.name);\n      }\n      const ao = this._ao;\n      if (ao.enabled && ao.ready) {\n        return this.getOutputTexture(ao.name);\n      }\n      return undefined;\n    }\n  },\n  /**\n   * Whether the collection has a stage that has selected features.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasSelected: {\n    get: function () {\n      const stages = this._stages.slice();\n      while (stages.length > 0) {\n        const stage = stages.pop();\n        if (!defined(stage)) {\n          continue;\n        }\n        if (defined(stage.selected)) {\n          return true;\n        }\n        const length = stage.length;\n        if (defined(length)) {\n          for (let i = 0; i < length; ++i) {\n            stages.push(stage.get(i));\n          }\n        }\n      }\n      return false;\n    }\n  },\n  /**\n   * Specifies the tonemapping algorithm used when rendering with high dynamic range.\n   * {@link https://sandcastle.cesium.com/?src=High%20Dynamic%20Range.html|Sandcastle Demo}\n   *\n   * @example viewer.scene.postProcessStages.tonemapper = Cesium.Tonemapper.ACES;\n   *\n   * @default Tonemapper.PBR_NEUTRAL\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Tonemapper}\n   */\n  tonemapper: {\n    get: function () {\n      return this._tonemapper;\n    },\n    set: function (value) {\n      if (this._tonemapper === value) {\n        return;\n      }\n      //>>includeStart('debug', pragmas.debug);\n      if (!validateTonemapper(value)) {\n        throw new DeveloperError(\"tonemapper was set to an invalid value.\");\n      }\n      //>>includeEnd('debug');\n\n      if (defined(this._tonemapping)) {\n        delete this._stageNames[this._tonemapping.name];\n        this._tonemapping.destroy();\n      }\n      const useAutoExposure = this._autoExposureEnabled;\n      let tonemapping;\n      switch (value) {\n        case Tonemapper.REINHARD:\n          tonemapping = PostProcessStageLibrary.createReinhardTonemappingStage(useAutoExposure);\n          break;\n        case Tonemapper.MODIFIED_REINHARD:\n          tonemapping = PostProcessStageLibrary.createModifiedReinhardTonemappingStage(useAutoExposure);\n          break;\n        case Tonemapper.FILMIC:\n          tonemapping = PostProcessStageLibrary.createFilmicTonemappingStage(useAutoExposure);\n          break;\n        case Tonemapper.PBR_NEUTRAL:\n          tonemapping = PostProcessStageLibrary.createPbrNeutralTonemappingStage(useAutoExposure);\n          break;\n        default:\n          tonemapping = PostProcessStageLibrary.createAcesTonemappingStage(useAutoExposure);\n          break;\n      }\n      if (useAutoExposure) {\n        const autoexposure = this._autoExposure;\n        tonemapping.uniforms.autoExposure = function () {\n          return autoexposure.outputTexture;\n        };\n      } else {\n        tonemapping.uniforms.exposure = this._exposure;\n      }\n      this._tonemapper = value;\n      this._tonemapping = tonemapping;\n      if (defined(this._stageNames)) {\n        this._stageNames[tonemapping.name] = tonemapping;\n        tonemapping._textureCache = this._textureCache;\n      }\n      this._textureCacheDirty = true;\n    }\n  },\n  /**\n   * Control the exposure when HDR is on. Less than 1.0 makes the tonemapping darker while greater than 1.0 makes it brighter.\n   *\n   * @example viewer.scene.postProcessStages.exposure = 1.0;\n   *\n   * @default 1.0\n   * @memberof PostProcessStageCollection.prototype\n   * @type {number}\n   */\n  exposure: {\n    get: function () {\n      return this._exposure;\n    },\n    set: function (value) {\n      this._tonemapping.uniforms.exposure = value;\n      this._exposure = value;\n    }\n  }\n});\nfunction removeStages(collection) {\n  if (!collection._stagesRemoved) {\n    return;\n  }\n  collection._stagesRemoved = false;\n  const newStages = [];\n  const stages = collection._stages;\n  for (let i = 0, j = 0; i < stages.length; ++i) {\n    const stage = stages[i];\n    if (stage) {\n      stage._index = j++;\n      newStages.push(stage);\n    }\n  }\n  collection._stages = newStages;\n}\n\n/**\n * Adds the post-process stage to the collection.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to add to the collection.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage that was added to the collection.\n *\n * @exception {DeveloperError} The post-process stage has already been added to the collection or does not have a unique name.\n */\nPostProcessStageCollection.prototype.add = function (stage) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  //>>includeEnd('debug');\n\n  const stageNames = this._stageNames;\n  const stack = stackScratch;\n  stack.push(stage);\n  while (stack.length > 0) {\n    const currentStage = stack.pop();\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(stageNames[currentStage.name])) {\n      throw new DeveloperError(`${currentStage.name} has already been added to the collection or does not have a unique name.`);\n    }\n    //>>includeEnd('debug');\n    stageNames[currentStage.name] = currentStage;\n    currentStage._textureCache = this._textureCache;\n    const length = currentStage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(currentStage.get(i));\n      }\n    }\n  }\n  const stages = this._stages;\n  stage._index = stages.length;\n  stages.push(stage);\n  this._textureCacheDirty = true;\n  return stage;\n};\n\n/**\n * Removes a post-process stage from the collection and destroys it.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to remove from the collection.\n * @return {boolean} Whether the post-process stage was removed.\n */\nPostProcessStageCollection.prototype.remove = function (stage) {\n  if (!this.contains(stage)) {\n    return false;\n  }\n  const stageNames = this._stageNames;\n  const stack = stackScratch;\n  stack.push(stage);\n  while (stack.length > 0) {\n    const currentStage = stack.pop();\n    delete stageNames[currentStage.name];\n    const length = currentStage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(currentStage.get(i));\n      }\n    }\n  }\n  this._stages[stage._index] = undefined;\n  this._stagesRemoved = true;\n  this._textureCacheDirty = true;\n  stage._index = undefined;\n  stage._textureCache = undefined;\n  stage.destroy();\n  return true;\n};\n\n/**\n * Returns whether the collection contains a post-process stage.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage.\n * @return {boolean} Whether the collection contains the post-process stage.\n */\nPostProcessStageCollection.prototype.contains = function (stage) {\n  return defined(stage) && defined(stage._index) && stage._textureCache === this._textureCache;\n};\n\n/**\n * Gets the post-process stage at <code>index</code>.\n *\n * @param {number} index The index of the post-process stage.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage at index.\n */\nPostProcessStageCollection.prototype.get = function (index) {\n  removeStages(this);\n  const stages = this._stages;\n  //>>includeStart('debug', pragmas.debug);\n  const length = stages.length;\n  Check.typeOf.number.greaterThanOrEquals(\"stages length\", length, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThan(\"index\", index, length);\n  //>>includeEnd('debug');\n  return stages[index];\n};\n\n/**\n * Removes all post-process stages from the collection and destroys them.\n */\nPostProcessStageCollection.prototype.removeAll = function () {\n  const stages = this._stages;\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    this.remove(stages[i]);\n  }\n  stages.length = 0;\n};\n\n/**\n * Gets a post-process stage in the collection by its name.\n *\n * @param {string} name The name of the post-process stage.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage.\n *\n * @private\n */\nPostProcessStageCollection.prototype.getStageByName = function (name) {\n  return this._stageNames[name];\n};\n\n/**\n * Called before the post-process stages in the collection are executed. Calls update for each stage and creates WebGL resources.\n *\n * @param {Context} context The context.\n * @param {boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n *\n * @private\n */\nPostProcessStageCollection.prototype.update = function (context, useLogDepth, useHdr) {\n  removeStages(this);\n  const previousActiveStages = this._activeStages;\n  const activeStages = this._activeStages = this._previousActiveStages;\n  this._previousActiveStages = previousActiveStages;\n  const stages = this._stages;\n  activeStages.length = stages.length;\n  let count = 0;\n  for (let i = 0; i < stages.length; ++i) {\n    const stage = stages[i];\n    if (stage.ready && stage.enabled && stage._isSupported(context)) {\n      activeStages[count++] = stage;\n    }\n  }\n  activeStages.length = count;\n  let activeStagesChanged = count !== previousActiveStages.length;\n  if (!activeStagesChanged) {\n    for (let i = 0; i < count; ++i) {\n      if (activeStages[i] !== previousActiveStages[i]) {\n        activeStagesChanged = true;\n        break;\n      }\n    }\n  }\n  const ao = this._ao;\n  const bloom = this._bloom;\n  const autoexposure = this._autoExposure;\n  const tonemapping = this._tonemapping;\n  const fxaa = this._fxaa;\n  tonemapping.enabled = useHdr;\n  const aoEnabled = ao.enabled && ao._isSupported(context);\n  const bloomEnabled = bloom.enabled && bloom._isSupported(context);\n  const tonemappingEnabled = tonemapping.enabled && tonemapping._isSupported(context);\n  const fxaaEnabled = fxaa.enabled && fxaa._isSupported(context);\n  if (activeStagesChanged || this._textureCacheDirty || aoEnabled !== this._aoEnabled || bloomEnabled !== this._bloomEnabled || tonemappingEnabled !== this._tonemappingEnabled || fxaaEnabled !== this._fxaaEnabled) {\n    // The number of stages to execute has changed.\n    // Update dependencies and recreate framebuffers.\n    this._textureCache.updateDependencies();\n    this._aoEnabled = aoEnabled;\n    this._bloomEnabled = bloomEnabled;\n    this._tonemappingEnabled = tonemappingEnabled;\n    this._fxaaEnabled = fxaaEnabled;\n    this._textureCacheDirty = false;\n  }\n  if (defined(this._randomTexture) && !aoEnabled) {\n    this._randomTexture.destroy();\n    this._randomTexture = undefined;\n  }\n  if (!defined(this._randomTexture) && aoEnabled) {\n    const length = 256 * 256 * 3;\n    const random = new Uint8Array(length);\n    for (let i = 0; i < length; i += 3) {\n      random[i] = Math.floor(Math.random() * 255.0);\n    }\n    this._randomTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGB,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: random,\n        width: 256,\n        height: 256\n      },\n      sampler: new Sampler({\n        wrapS: TextureWrap.REPEAT,\n        wrapT: TextureWrap.REPEAT,\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST\n      })\n    });\n  }\n  this._textureCache.update(context);\n  fxaa.update(context, useLogDepth);\n  ao.update(context, useLogDepth);\n  bloom.update(context, useLogDepth);\n  tonemapping.update(context, useLogDepth);\n  if (this._autoExposureEnabled) {\n    autoexposure.update(context, useLogDepth);\n  }\n  for (let i = 0; i < stages.length; ++i) {\n    stages[i].update(context, useLogDepth);\n  }\n  count = 0;\n  for (let i = 0; i < stages.length; ++i) {\n    const stage = stages[i];\n    if (stage.ready && stage.enabled && stage._isSupported(context)) {\n      count++;\n    }\n  }\n  activeStagesChanged = count !== activeStages.length;\n  if (activeStagesChanged) {\n    this.update(context, useLogDepth, useHdr);\n  }\n};\n\n/**\n * Clears all of the framebuffers used by the stages.\n *\n * @param {Context} context The context.\n *\n * @private\n */\nPostProcessStageCollection.prototype.clear = function (context) {\n  this._textureCache.clear(context);\n  if (this._autoExposureEnabled) {\n    this._autoExposure.clear(context);\n  }\n};\nfunction getOutputTexture(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.outputTexture;\n}\n\n/**\n * Gets the output texture of a stage with the given name.\n *\n * @param {string} stageName The name of the stage.\n * @return {Texture|undefined} The texture rendered to by the stage with the given name.\n *\n * @private\n */\nPostProcessStageCollection.prototype.getOutputTexture = function (stageName) {\n  const stage = this.getStageByName(stageName);\n  if (!defined(stage)) {\n    return undefined;\n  }\n  return getOutputTexture(stage);\n};\nfunction execute(stage, context, colorTexture, depthTexture, idTexture) {\n  if (defined(stage.execute)) {\n    stage.execute(context, colorTexture, depthTexture, idTexture);\n    return;\n  }\n  if (stage.inputPreviousStageTexture) {\n    execute(stage.get(0), context, colorTexture, depthTexture, idTexture);\n    for (let i = 1; i < stage.length; ++i) {\n      execute(stage.get(i), context, getOutputTexture(stage.get(i - 1)), depthTexture, idTexture);\n    }\n  } else {\n    for (let i = 0; i < stage.length; ++i) {\n      execute(stage.get(i), context, colorTexture, depthTexture, idTexture);\n    }\n  }\n}\n\n/**\n * Executes all ready and enabled stages in the collection.\n *\n * @param {Context} context The context.\n * @param {Texture} colorTexture The color texture rendered to by the scene.\n * @param {Texture} depthTexture The depth texture written to by the scene.\n * @param {Texture} idTexture The id texture written to by the scene.\n *\n * @private\n */\nPostProcessStageCollection.prototype.execute = function (context, colorTexture, depthTexture, idTexture) {\n  const activeStages = this._activeStages;\n  const length = activeStages.length;\n  const fxaa = this._fxaa;\n  const ao = this._ao;\n  const bloom = this._bloom;\n  const autoexposure = this._autoExposure;\n  const tonemapping = this._tonemapping;\n  const aoEnabled = ao.enabled && ao._isSupported(context);\n  const bloomEnabled = bloom.enabled && bloom._isSupported(context);\n  const autoExposureEnabled = this._autoExposureEnabled;\n  const tonemappingEnabled = tonemapping.enabled && tonemapping._isSupported(context);\n  const fxaaEnabled = fxaa.enabled && fxaa._isSupported(context);\n  if (!fxaaEnabled && !aoEnabled && !bloomEnabled && !tonemappingEnabled && length === 0) {\n    return;\n  }\n  let initialTexture = colorTexture;\n  if (aoEnabled && ao.ready) {\n    execute(ao, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(ao);\n  }\n  if (bloomEnabled && bloom.ready) {\n    execute(bloom, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(bloom);\n  }\n  if (autoExposureEnabled && autoexposure.ready) {\n    execute(autoexposure, context, initialTexture, depthTexture, idTexture);\n  }\n  if (tonemappingEnabled && tonemapping.ready) {\n    execute(tonemapping, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(tonemapping);\n  }\n  let lastTexture = initialTexture;\n  if (length > 0) {\n    execute(activeStages[0], context, initialTexture, depthTexture, idTexture);\n    for (let i = 1; i < length; ++i) {\n      execute(activeStages[i], context, getOutputTexture(activeStages[i - 1]), depthTexture, idTexture);\n    }\n    lastTexture = getOutputTexture(activeStages[length - 1]);\n  }\n  if (fxaaEnabled && fxaa.ready) {\n    execute(fxaa, context, lastTexture, depthTexture, idTexture);\n  }\n};\n\n/**\n * Copies the output of all executed stages to the color texture of a framebuffer.\n *\n * @param {Context} context The context.\n * @param {Framebuffer} framebuffer The framebuffer to copy to.\n *\n * @private\n */\nPostProcessStageCollection.prototype.copy = function (context, framebuffer) {\n  if (!defined(this._copyColorCommand)) {\n    const that = this;\n    this._copyColorCommand = context.createViewportQuadCommand(PassThrough, {\n      uniformMap: {\n        colorTexture: function () {\n          return that.outputTexture;\n        }\n      },\n      owner: this\n    });\n  }\n  this._copyColorCommand.framebuffer = framebuffer;\n  this._copyColorCommand.execute(context);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageCollection#destroy\n */\nPostProcessStageCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageCollection#isDestroyed\n */\nPostProcessStageCollection.prototype.destroy = function () {\n  this._fxaa.destroy();\n  this._ao.destroy();\n  this._bloom.destroy();\n  this._autoExposure.destroy();\n  this._tonemapping.destroy();\n  this.removeAll();\n  this._textureCache = this._textureCache && this._textureCache.destroy();\n  return destroyObject(this);\n};\nexport default PostProcessStageCollection;","map":{"version":3,"names":["Check","defined","destroyObject","DeveloperError","PixelFormat","PixelDatatype","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","PassThrough","PostProcessStageLibrary","PostProcessStageTextureCache","Tonemapper","validateTonemapper","stackScratch","PostProcessStageCollection","fxaa","createFXAAStage","ao","createAmbientOcclusionStage","bloom","createBloomStage","_autoExposureEnabled","_autoExposure","createAutoExposureStage","_exposure","_tonemapping","undefined","_tonemapper","tonemapper","PBR_NEUTRAL","tonemapping","enabled","textureCache","stageNames","stack","push","length","stage","pop","name","_textureCache","i","get","_stages","_activeStages","_previousActiveStages","_randomTexture","that","uniforms","randomTexture","_ao","_bloom","_fxaa","_aoEnabled","_bloomEnabled","_tonemappingEnabled","_fxaaEnabled","_activeStagesChanged","_stagesRemoved","_textureCacheDirty","_stageNames","Object","defineProperties","prototype","ready","readyAndEnabled","stages","ambientOcclusion","removeStages","outputTexture","getOutputTexture","hasSelected","slice","selected","set","value","destroy","useAutoExposure","REINHARD","createReinhardTonemappingStage","MODIFIED_REINHARD","createModifiedReinhardTonemappingStage","FILMIC","createFilmicTonemappingStage","createPbrNeutralTonemappingStage","createAcesTonemappingStage","autoexposure","autoExposure","exposure","collection","newStages","j","_index","add","typeOf","object","currentStage","remove","contains","index","number","greaterThanOrEquals","lessThan","removeAll","getStageByName","update","context","useLogDepth","useHdr","previousActiveStages","activeStages","count","_isSupported","activeStagesChanged","aoEnabled","bloomEnabled","tonemappingEnabled","fxaaEnabled","updateDependencies","random","Uint8Array","Math","floor","pixelFormat","RGB","pixelDatatype","UNSIGNED_BYTE","source","arrayBufferView","width","height","sampler","wrapS","REPEAT","wrapT","minificationFilter","NEAREST","magnificationFilter","clear","stageName","execute","colorTexture","depthTexture","idTexture","inputPreviousStageTexture","autoExposureEnabled","initialTexture","lastTexture","copy","framebuffer","_copyColorCommand","createViewportQuadCommand","uniformMap","owner","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PostProcessStageCollection.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport PassThrough from \"../Shaders/PostProcessStages/PassThrough.js\";\nimport PostProcessStageLibrary from \"./PostProcessStageLibrary.js\";\nimport PostProcessStageTextureCache from \"./PostProcessStageTextureCache.js\";\nimport Tonemapper, { validateTonemapper } from \"./Tonemapper.js\";\n\nconst stackScratch = [];\n\n/**\n * A collection of {@link PostProcessStage}s and/or {@link PostProcessStageComposite}s.\n * <p>\n * The input texture for each post-process stage is the texture rendered to by the scene or the texture rendered\n * to by the previous stage in the collection.\n * </p>\n * <p>\n * If the ambient occlusion or bloom stages are enabled, they will execute before all other stages.\n * </p>\n * <p>\n * If the FXAA stage is enabled, it will execute after all other stages.\n * </p>\n *\n * @alias PostProcessStageCollection\n * @constructor\n */\nfunction PostProcessStageCollection() {\n  const fxaa = PostProcessStageLibrary.createFXAAStage();\n  const ao = PostProcessStageLibrary.createAmbientOcclusionStage();\n  const bloom = PostProcessStageLibrary.createBloomStage();\n\n  // Auto-exposure is currently disabled because most shaders output a value in [0.0, 1.0].\n  // Some shaders, such as the atmosphere and ground atmosphere, output values slightly over 1.0.\n  this._autoExposureEnabled = false;\n  this._autoExposure = PostProcessStageLibrary.createAutoExposureStage();\n  this._exposure = 1.0;\n  this._tonemapping = undefined;\n  this._tonemapper = undefined;\n\n  // set tonemapper and tonemapping using the setter\n  this.tonemapper = Tonemapper.PBR_NEUTRAL;\n\n  const tonemapping = this._tonemapping;\n\n  fxaa.enabled = false;\n  ao.enabled = false;\n  bloom.enabled = false;\n  tonemapping.enabled = false; // will be enabled if necessary in update\n\n  const textureCache = new PostProcessStageTextureCache(this);\n\n  const stageNames = {};\n  const stack = stackScratch;\n  stack.push(fxaa, ao, bloom, tonemapping);\n  while (stack.length > 0) {\n    const stage = stack.pop();\n    stageNames[stage.name] = stage;\n    stage._textureCache = textureCache;\n\n    const length = stage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(stage.get(i));\n      }\n    }\n  }\n\n  this._stages = [];\n  this._activeStages = [];\n  this._previousActiveStages = [];\n\n  this._randomTexture = undefined; // For AO\n\n  const that = this;\n  ao.uniforms.randomTexture = function () {\n    return that._randomTexture;\n  };\n\n  this._ao = ao;\n  this._bloom = bloom;\n  this._fxaa = fxaa;\n\n  this._aoEnabled = undefined;\n  this._bloomEnabled = undefined;\n  this._tonemappingEnabled = undefined;\n  this._fxaaEnabled = undefined;\n\n  this._activeStagesChanged = false;\n  this._stagesRemoved = false;\n  this._textureCacheDirty = false;\n\n  this._stageNames = stageNames;\n  this._textureCache = textureCache;\n}\n\nObject.defineProperties(PostProcessStageCollection.prototype, {\n  /**\n   * Determines if all of the post-process stages in the collection are ready to be executed.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      let readyAndEnabled = false;\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = length - 1; i >= 0; --i) {\n        const stage = stages[i];\n        readyAndEnabled = readyAndEnabled || (stage.ready && stage.enabled);\n      }\n\n      const fxaa = this._fxaa;\n      const ao = this._ao;\n      const bloom = this._bloom;\n      const tonemapping = this._tonemapping;\n\n      readyAndEnabled = readyAndEnabled || (fxaa.ready && fxaa.enabled);\n      readyAndEnabled = readyAndEnabled || (ao.ready && ao.enabled);\n      readyAndEnabled = readyAndEnabled || (bloom.ready && bloom.enabled);\n      readyAndEnabled =\n        readyAndEnabled || (tonemapping.ready && tonemapping.enabled);\n\n      return readyAndEnabled;\n    },\n  },\n  /**\n   * A post-process stage for Fast Approximate Anti-aliasing.\n   * <p>\n   * When enabled, this stage will execute after all others.\n   * </p>\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {PostProcessStage}\n   * @readonly\n   */\n  fxaa: {\n    get: function () {\n      return this._fxaa;\n    },\n  },\n  /**\n   * A post-process stage that applies Horizon-based Ambient Occlusion (HBAO) to the input texture.\n   * <p>\n   * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the\n   * surface receives light and regardless of the light's position.\n   * </p>\n   * <p>\n   * The uniforms have the following properties:\n   * <ul>\n   * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>\n   * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,\n   * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>\n   * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,\n   * sampling stops in the current direction. The default value is <code>0.26</code>.</li>\n   * <li><code>directionCount</code> is the number of directions along which the ray marching will search for occluders. The default value is <code>8</code>.</li>\n   * <li><code>stepCount</code> is the number of steps the ray marching will take along each direction. The default value is <code>32</code>.</li>\n   * <li><code>randomTexture</code> is a texture where the red channel is a random value in [0.0, 1.0]. The default value is <code>undefined</code>. This texture needs to be set.</li>\n   * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated\n   * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>\n   * </ul>\n   * <p>\n   * When enabled, this stage will execute before all others.\n   * </p>\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {PostProcessStageComposite}\n   * @readonly\n   */\n  ambientOcclusion: {\n    get: function () {\n      return this._ao;\n    },\n  },\n  /**\n   * A post-process stage for a bloom effect.\n   * <p>\n   * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.\n   * </p>\n   * <p>\n   * This stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,\n   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n   * </p>\n   * <ul>\n   * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>\n   *\n   * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is\n   * added to the brightness. The default value is <code>-0.3</code>.</li>\n   *\n   * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.\n   * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>\n   * </ul>\n   * <p>\n   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n   * The blur is applied to the shadows generated from the image to make them smoother.\n   * </p>\n   * <p>\n   * When enabled, this stage will execute before all others.\n   * </p>\n   *\n   * @memberOf PostProcessStageCollection.prototype\n   * @type {PostProcessStageComposite}\n   * @readonly\n   */\n  bloom: {\n    get: function () {\n      return this._bloom;\n    },\n  },\n  /**\n   * The number of post-process stages in this collection.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      removeStages(this);\n      return this._stages.length;\n    },\n  },\n  /**\n   * A reference to the last texture written to when executing the post-process stages in this collection.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      const fxaa = this._fxaa;\n      if (fxaa.enabled && fxaa.ready) {\n        return this.getOutputTexture(fxaa.name);\n      }\n\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = length - 1; i >= 0; --i) {\n        const stage = stages[i];\n        if (defined(stage) && stage.ready && stage.enabled) {\n          return this.getOutputTexture(stage.name);\n        }\n      }\n\n      const tonemapping = this._tonemapping;\n      if (tonemapping.enabled && tonemapping.ready) {\n        return this.getOutputTexture(tonemapping.name);\n      }\n\n      const bloom = this._bloom;\n      if (bloom.enabled && bloom.ready) {\n        return this.getOutputTexture(bloom.name);\n      }\n\n      const ao = this._ao;\n      if (ao.enabled && ao.ready) {\n        return this.getOutputTexture(ao.name);\n      }\n\n      return undefined;\n    },\n  },\n  /**\n   * Whether the collection has a stage that has selected features.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasSelected: {\n    get: function () {\n      const stages = this._stages.slice();\n      while (stages.length > 0) {\n        const stage = stages.pop();\n        if (!defined(stage)) {\n          continue;\n        }\n        if (defined(stage.selected)) {\n          return true;\n        }\n        const length = stage.length;\n        if (defined(length)) {\n          for (let i = 0; i < length; ++i) {\n            stages.push(stage.get(i));\n          }\n        }\n      }\n      return false;\n    },\n  },\n\n  /**\n   * Specifies the tonemapping algorithm used when rendering with high dynamic range.\n   * {@link https://sandcastle.cesium.com/?src=High%20Dynamic%20Range.html|Sandcastle Demo}\n   *\n   * @example viewer.scene.postProcessStages.tonemapper = Cesium.Tonemapper.ACES;\n   *\n   * @default Tonemapper.PBR_NEUTRAL\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Tonemapper}\n   */\n  tonemapper: {\n    get: function () {\n      return this._tonemapper;\n    },\n    set: function (value) {\n      if (this._tonemapper === value) {\n        return;\n      }\n      //>>includeStart('debug', pragmas.debug);\n      if (!validateTonemapper(value)) {\n        throw new DeveloperError(\"tonemapper was set to an invalid value.\");\n      }\n      //>>includeEnd('debug');\n\n      if (defined(this._tonemapping)) {\n        delete this._stageNames[this._tonemapping.name];\n        this._tonemapping.destroy();\n      }\n\n      const useAutoExposure = this._autoExposureEnabled;\n      let tonemapping;\n\n      switch (value) {\n        case Tonemapper.REINHARD:\n          tonemapping =\n            PostProcessStageLibrary.createReinhardTonemappingStage(\n              useAutoExposure,\n            );\n          break;\n        case Tonemapper.MODIFIED_REINHARD:\n          tonemapping =\n            PostProcessStageLibrary.createModifiedReinhardTonemappingStage(\n              useAutoExposure,\n            );\n          break;\n        case Tonemapper.FILMIC:\n          tonemapping =\n            PostProcessStageLibrary.createFilmicTonemappingStage(\n              useAutoExposure,\n            );\n          break;\n        case Tonemapper.PBR_NEUTRAL:\n          tonemapping =\n            PostProcessStageLibrary.createPbrNeutralTonemappingStage(\n              useAutoExposure,\n            );\n          break;\n        default:\n          tonemapping =\n            PostProcessStageLibrary.createAcesTonemappingStage(useAutoExposure);\n          break;\n      }\n\n      if (useAutoExposure) {\n        const autoexposure = this._autoExposure;\n        tonemapping.uniforms.autoExposure = function () {\n          return autoexposure.outputTexture;\n        };\n      } else {\n        tonemapping.uniforms.exposure = this._exposure;\n      }\n\n      this._tonemapper = value;\n      this._tonemapping = tonemapping;\n\n      if (defined(this._stageNames)) {\n        this._stageNames[tonemapping.name] = tonemapping;\n        tonemapping._textureCache = this._textureCache;\n      }\n\n      this._textureCacheDirty = true;\n    },\n  },\n\n  /**\n   * Control the exposure when HDR is on. Less than 1.0 makes the tonemapping darker while greater than 1.0 makes it brighter.\n   *\n   * @example viewer.scene.postProcessStages.exposure = 1.0;\n   *\n   * @default 1.0\n   * @memberof PostProcessStageCollection.prototype\n   * @type {number}\n   */\n  exposure: {\n    get: function () {\n      return this._exposure;\n    },\n    set: function (value) {\n      this._tonemapping.uniforms.exposure = value;\n      this._exposure = value;\n    },\n  },\n});\n\nfunction removeStages(collection) {\n  if (!collection._stagesRemoved) {\n    return;\n  }\n\n  collection._stagesRemoved = false;\n\n  const newStages = [];\n  const stages = collection._stages;\n  for (let i = 0, j = 0; i < stages.length; ++i) {\n    const stage = stages[i];\n    if (stage) {\n      stage._index = j++;\n      newStages.push(stage);\n    }\n  }\n\n  collection._stages = newStages;\n}\n\n/**\n * Adds the post-process stage to the collection.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to add to the collection.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage that was added to the collection.\n *\n * @exception {DeveloperError} The post-process stage has already been added to the collection or does not have a unique name.\n */\nPostProcessStageCollection.prototype.add = function (stage) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  //>>includeEnd('debug');\n\n  const stageNames = this._stageNames;\n\n  const stack = stackScratch;\n  stack.push(stage);\n  while (stack.length > 0) {\n    const currentStage = stack.pop();\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(stageNames[currentStage.name])) {\n      throw new DeveloperError(\n        `${currentStage.name} has already been added to the collection or does not have a unique name.`,\n      );\n    }\n    //>>includeEnd('debug');\n    stageNames[currentStage.name] = currentStage;\n    currentStage._textureCache = this._textureCache;\n\n    const length = currentStage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(currentStage.get(i));\n      }\n    }\n  }\n\n  const stages = this._stages;\n  stage._index = stages.length;\n  stages.push(stage);\n  this._textureCacheDirty = true;\n  return stage;\n};\n\n/**\n * Removes a post-process stage from the collection and destroys it.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to remove from the collection.\n * @return {boolean} Whether the post-process stage was removed.\n */\nPostProcessStageCollection.prototype.remove = function (stage) {\n  if (!this.contains(stage)) {\n    return false;\n  }\n\n  const stageNames = this._stageNames;\n\n  const stack = stackScratch;\n  stack.push(stage);\n  while (stack.length > 0) {\n    const currentStage = stack.pop();\n    delete stageNames[currentStage.name];\n\n    const length = currentStage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(currentStage.get(i));\n      }\n    }\n  }\n\n  this._stages[stage._index] = undefined;\n  this._stagesRemoved = true;\n  this._textureCacheDirty = true;\n  stage._index = undefined;\n  stage._textureCache = undefined;\n  stage.destroy();\n  return true;\n};\n\n/**\n * Returns whether the collection contains a post-process stage.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage.\n * @return {boolean} Whether the collection contains the post-process stage.\n */\nPostProcessStageCollection.prototype.contains = function (stage) {\n  return (\n    defined(stage) &&\n    defined(stage._index) &&\n    stage._textureCache === this._textureCache\n  );\n};\n\n/**\n * Gets the post-process stage at <code>index</code>.\n *\n * @param {number} index The index of the post-process stage.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage at index.\n */\nPostProcessStageCollection.prototype.get = function (index) {\n  removeStages(this);\n  const stages = this._stages;\n  //>>includeStart('debug', pragmas.debug);\n  const length = stages.length;\n  Check.typeOf.number.greaterThanOrEquals(\"stages length\", length, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThan(\"index\", index, length);\n  //>>includeEnd('debug');\n  return stages[index];\n};\n\n/**\n * Removes all post-process stages from the collection and destroys them.\n */\nPostProcessStageCollection.prototype.removeAll = function () {\n  const stages = this._stages;\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    this.remove(stages[i]);\n  }\n  stages.length = 0;\n};\n\n/**\n * Gets a post-process stage in the collection by its name.\n *\n * @param {string} name The name of the post-process stage.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage.\n *\n * @private\n */\nPostProcessStageCollection.prototype.getStageByName = function (name) {\n  return this._stageNames[name];\n};\n\n/**\n * Called before the post-process stages in the collection are executed. Calls update for each stage and creates WebGL resources.\n *\n * @param {Context} context The context.\n * @param {boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n *\n * @private\n */\nPostProcessStageCollection.prototype.update = function (\n  context,\n  useLogDepth,\n  useHdr,\n) {\n  removeStages(this);\n\n  const previousActiveStages = this._activeStages;\n  const activeStages = (this._activeStages = this._previousActiveStages);\n  this._previousActiveStages = previousActiveStages;\n\n  const stages = this._stages;\n  activeStages.length = stages.length;\n\n  let count = 0;\n  for (let i = 0; i < stages.length; ++i) {\n    const stage = stages[i];\n    if (stage.ready && stage.enabled && stage._isSupported(context)) {\n      activeStages[count++] = stage;\n    }\n  }\n  activeStages.length = count;\n\n  let activeStagesChanged = count !== previousActiveStages.length;\n  if (!activeStagesChanged) {\n    for (let i = 0; i < count; ++i) {\n      if (activeStages[i] !== previousActiveStages[i]) {\n        activeStagesChanged = true;\n        break;\n      }\n    }\n  }\n\n  const ao = this._ao;\n  const bloom = this._bloom;\n  const autoexposure = this._autoExposure;\n  const tonemapping = this._tonemapping;\n  const fxaa = this._fxaa;\n\n  tonemapping.enabled = useHdr;\n\n  const aoEnabled = ao.enabled && ao._isSupported(context);\n  const bloomEnabled = bloom.enabled && bloom._isSupported(context);\n  const tonemappingEnabled =\n    tonemapping.enabled && tonemapping._isSupported(context);\n  const fxaaEnabled = fxaa.enabled && fxaa._isSupported(context);\n\n  if (\n    activeStagesChanged ||\n    this._textureCacheDirty ||\n    aoEnabled !== this._aoEnabled ||\n    bloomEnabled !== this._bloomEnabled ||\n    tonemappingEnabled !== this._tonemappingEnabled ||\n    fxaaEnabled !== this._fxaaEnabled\n  ) {\n    // The number of stages to execute has changed.\n    // Update dependencies and recreate framebuffers.\n    this._textureCache.updateDependencies();\n\n    this._aoEnabled = aoEnabled;\n    this._bloomEnabled = bloomEnabled;\n    this._tonemappingEnabled = tonemappingEnabled;\n    this._fxaaEnabled = fxaaEnabled;\n    this._textureCacheDirty = false;\n  }\n\n  if (defined(this._randomTexture) && !aoEnabled) {\n    this._randomTexture.destroy();\n    this._randomTexture = undefined;\n  }\n\n  if (!defined(this._randomTexture) && aoEnabled) {\n    const length = 256 * 256 * 3;\n    const random = new Uint8Array(length);\n    for (let i = 0; i < length; i += 3) {\n      random[i] = Math.floor(Math.random() * 255.0);\n    }\n\n    this._randomTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGB,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: random,\n        width: 256,\n        height: 256,\n      },\n      sampler: new Sampler({\n        wrapS: TextureWrap.REPEAT,\n        wrapT: TextureWrap.REPEAT,\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST,\n      }),\n    });\n  }\n\n  this._textureCache.update(context);\n\n  fxaa.update(context, useLogDepth);\n  ao.update(context, useLogDepth);\n  bloom.update(context, useLogDepth);\n  tonemapping.update(context, useLogDepth);\n\n  if (this._autoExposureEnabled) {\n    autoexposure.update(context, useLogDepth);\n  }\n\n  for (let i = 0; i < stages.length; ++i) {\n    stages[i].update(context, useLogDepth);\n  }\n\n  count = 0;\n  for (let i = 0; i < stages.length; ++i) {\n    const stage = stages[i];\n    if (stage.ready && stage.enabled && stage._isSupported(context)) {\n      count++;\n    }\n  }\n  activeStagesChanged = count !== activeStages.length;\n  if (activeStagesChanged) {\n    this.update(context, useLogDepth, useHdr);\n  }\n};\n\n/**\n * Clears all of the framebuffers used by the stages.\n *\n * @param {Context} context The context.\n *\n * @private\n */\nPostProcessStageCollection.prototype.clear = function (context) {\n  this._textureCache.clear(context);\n\n  if (this._autoExposureEnabled) {\n    this._autoExposure.clear(context);\n  }\n};\n\nfunction getOutputTexture(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.outputTexture;\n}\n\n/**\n * Gets the output texture of a stage with the given name.\n *\n * @param {string} stageName The name of the stage.\n * @return {Texture|undefined} The texture rendered to by the stage with the given name.\n *\n * @private\n */\nPostProcessStageCollection.prototype.getOutputTexture = function (stageName) {\n  const stage = this.getStageByName(stageName);\n  if (!defined(stage)) {\n    return undefined;\n  }\n  return getOutputTexture(stage);\n};\n\nfunction execute(stage, context, colorTexture, depthTexture, idTexture) {\n  if (defined(stage.execute)) {\n    stage.execute(context, colorTexture, depthTexture, idTexture);\n    return;\n  }\n\n  if (stage.inputPreviousStageTexture) {\n    execute(stage.get(0), context, colorTexture, depthTexture, idTexture);\n    for (let i = 1; i < stage.length; ++i) {\n      execute(\n        stage.get(i),\n        context,\n        getOutputTexture(stage.get(i - 1)),\n        depthTexture,\n        idTexture,\n      );\n    }\n  } else {\n    for (let i = 0; i < stage.length; ++i) {\n      execute(stage.get(i), context, colorTexture, depthTexture, idTexture);\n    }\n  }\n}\n\n/**\n * Executes all ready and enabled stages in the collection.\n *\n * @param {Context} context The context.\n * @param {Texture} colorTexture The color texture rendered to by the scene.\n * @param {Texture} depthTexture The depth texture written to by the scene.\n * @param {Texture} idTexture The id texture written to by the scene.\n *\n * @private\n */\nPostProcessStageCollection.prototype.execute = function (\n  context,\n  colorTexture,\n  depthTexture,\n  idTexture,\n) {\n  const activeStages = this._activeStages;\n  const length = activeStages.length;\n  const fxaa = this._fxaa;\n  const ao = this._ao;\n  const bloom = this._bloom;\n  const autoexposure = this._autoExposure;\n  const tonemapping = this._tonemapping;\n\n  const aoEnabled = ao.enabled && ao._isSupported(context);\n  const bloomEnabled = bloom.enabled && bloom._isSupported(context);\n  const autoExposureEnabled = this._autoExposureEnabled;\n  const tonemappingEnabled =\n    tonemapping.enabled && tonemapping._isSupported(context);\n  const fxaaEnabled = fxaa.enabled && fxaa._isSupported(context);\n\n  if (\n    !fxaaEnabled &&\n    !aoEnabled &&\n    !bloomEnabled &&\n    !tonemappingEnabled &&\n    length === 0\n  ) {\n    return;\n  }\n\n  let initialTexture = colorTexture;\n  if (aoEnabled && ao.ready) {\n    execute(ao, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(ao);\n  }\n  if (bloomEnabled && bloom.ready) {\n    execute(bloom, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(bloom);\n  }\n  if (autoExposureEnabled && autoexposure.ready) {\n    execute(autoexposure, context, initialTexture, depthTexture, idTexture);\n  }\n  if (tonemappingEnabled && tonemapping.ready) {\n    execute(tonemapping, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(tonemapping);\n  }\n\n  let lastTexture = initialTexture;\n\n  if (length > 0) {\n    execute(activeStages[0], context, initialTexture, depthTexture, idTexture);\n    for (let i = 1; i < length; ++i) {\n      execute(\n        activeStages[i],\n        context,\n        getOutputTexture(activeStages[i - 1]),\n        depthTexture,\n        idTexture,\n      );\n    }\n    lastTexture = getOutputTexture(activeStages[length - 1]);\n  }\n\n  if (fxaaEnabled && fxaa.ready) {\n    execute(fxaa, context, lastTexture, depthTexture, idTexture);\n  }\n};\n\n/**\n * Copies the output of all executed stages to the color texture of a framebuffer.\n *\n * @param {Context} context The context.\n * @param {Framebuffer} framebuffer The framebuffer to copy to.\n *\n * @private\n */\nPostProcessStageCollection.prototype.copy = function (context, framebuffer) {\n  if (!defined(this._copyColorCommand)) {\n    const that = this;\n    this._copyColorCommand = context.createViewportQuadCommand(PassThrough, {\n      uniformMap: {\n        colorTexture: function () {\n          return that.outputTexture;\n        },\n      },\n      owner: this,\n    });\n  }\n\n  this._copyColorCommand.framebuffer = framebuffer;\n  this._copyColorCommand.execute(context);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageCollection#destroy\n */\nPostProcessStageCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageCollection#isDestroyed\n */\nPostProcessStageCollection.prototype.destroy = function () {\n  this._fxaa.destroy();\n  this._ao.destroy();\n  this._bloom.destroy();\n  this._autoExposure.destroy();\n  this._tonemapping.destroy();\n  this.removeAll();\n  this._textureCache = this._textureCache && this._textureCache.destroy();\n  return destroyObject(this);\n};\nexport default PostProcessStageCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}