{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport GlobeTranslucency from \"./GlobeTranslucency.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] Determines the size and shape of the\n * globe.\n */\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid\n  });\n  const imageryLayerCollection = new ImageryLayerCollection();\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet\n    })\n  });\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n  this._undergroundColor = Color.clone(Color.BLACK);\n  this._undergroundColorAlphaByDistance = new NearFarScalar(ellipsoid.maximumRadius / 1000.0, 0.0, ellipsoid.maximumRadius / 5.0, 1.0);\n  this._translucency = new GlobeTranslucency();\n  makeShadersDirty(this);\n\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = true;\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\")\n  });\n\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = 2;\n\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {number}\n   * @default 100\n   */\n  this.tileCacheSize = 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.enableLighting = false;\n\n  /**\n   * A multiplier to adjust terrain lambert lighting.\n   * This number is multiplied by the result of <code>czm_getLambertDiffuse</code> in GlobeFS.glsl.\n   * This only takes effect when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default 0.9\n   */\n  this.lambertDiffuseMultiplier = 0.9;\n\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.dynamicAtmosphereLighting = true;\n\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.dynamicAtmosphereLightingFromSun = false;\n\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @type {boolean}\n   * @default true when using the WGS84 ellipsoid, false otherwise\n   */\n  this.showGroundAtmosphere = Ellipsoid.WGS84.equals(ellipsoid);\n\n  /**\n   * The intensity of the light that is used for computing the ground atmosphere color.\n   *\n   * @type {number}\n   * @default 10.0\n   */\n  this.atmosphereLightIntensity = 10.0;\n\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(5.5e-6, 13.0e-6, 28.4e-6)\n   */\n  this.atmosphereRayleighCoefficient = new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6);\n\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(21e-6, 21e-6, 21e-6)\n   */\n  this.atmosphereMieCoefficient = new Cartesian3(21e-6, 21e-6, 21e-6);\n\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 10000.0\n   */\n  this.atmosphereRayleighScaleHeight = 10000.0;\n\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 3200.0\n   */\n  this.atmosphereMieScaleHeight = 3200.0;\n\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * <p>\n   * Valid values are between -1.0 and 1.0.\n   * </p>\n   * @type {number}\n   * @default 0.9\n   */\n  this.atmosphereMieAnisotropy = 0.9;\n\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default 1/2 * pi * ellipsoid.minimumRadius\n   */\n  this.lightingFadeOutDistance = CesiumMath.PI_OVER_TWO * ellipsoid.minimumRadius;\n\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default pi * ellipsoid.minimumRadius\n   */\n  this.lightingFadeInDistance = CesiumMath.PI * ellipsoid.minimumRadius;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {number}\n   * @default 1/2 * pi * ellipsoid.minimumRadius\n   */\n  this.nightFadeOutDistance = CesiumMath.PI_OVER_TWO * ellipsoid.minimumRadius;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {number}\n   * @default 5/2 * pi * ellipsoid.minimumRadius\n   */\n  this.nightFadeInDistance = 5.0 * CesiumMath.PI_OVER_TWO * ellipsoid.minimumRadius;\n\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.showWaterEffect = true;\n\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {boolean}\n   * @default false\n   *\n   */\n  this.depthTestAgainstTerrain = false;\n\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {number}\n   * @default 0.0\n   */\n  this.atmosphereHueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {number}\n   * @default 0.0\n   */\n  this.atmosphereSaturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {number}\n   * @default 0.0\n   */\n  this.atmosphereBrightnessShift = 0.0;\n\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * Skirts are always hidden when the camera is underground or translucency is enabled.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.showSkirts = true;\n\n  /**\n   * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.backFaceCulling = true;\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n\n  /**\n   * Determines the darkness of the vertex shadow.\n   * This only takes effect when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default 0.3\n   */\n  this.vertexShadowDarkness = 0.3;\n}\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function () {\n      return this._imageryLayerCollection;\n    }\n  },\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    }\n  },\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function () {\n      if (!defined(this._surface)) {\n        return true;\n      }\n      return this._surface._tileLoadQueueHigh.length === 0 && this._surface._tileLoadQueueMedium.length === 0 && this._surface._tileLoadQueueLow.length === 0;\n    }\n  },\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function (value) {\n      this._surface.tileProvider.baseColor = value;\n    }\n  },\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    }\n  },\n  /**\n   * A property specifying a {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPolygonCollection}\n   */\n  clippingPolygons: {\n    get: function () {\n      return this._surface.tileProvider.clippingPolygons;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPolygons = value;\n    }\n  },\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @memberof Globe.prototype\n   * @type {Rectangle}\n   * @default {@link Rectangle.MAX_VALUE}\n   */\n  cartographicLimitRectangle: {\n    get: function () {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    }\n  },\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {string}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function () {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function (value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    }\n  },\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n        this._terrainProviderChanged.raiseEvent(value);\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    }\n  },\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      return this._terrainProviderChanged;\n    }\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._surface.tileLoadProgressEvent;\n    }\n  },\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material | undefined}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    }\n  },\n  /**\n   * The color to render the back side of the globe when the camera is underground or the globe is translucent,\n   * blended with the globe color based on the camera's distance.\n   * <br /><br />\n   * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.\n   *\n   * @memberof Globe.prototype\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Globe#undergroundColorAlphaByDistance\n   */\n  undergroundColor: {\n    get: function () {\n      return this._undergroundColor;\n    },\n    set: function (value) {\n      this._undergroundColor = Color.clone(value, this._undergroundColor);\n    }\n  },\n  /**\n   * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.\n   * The alpha will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,\n   * the underground color will not be blended with the globe color.\n   * <br /> <br />\n   * When the camera is above the ellipsoid the distance is computed from the nearest\n   * point on the ellipsoid instead of the camera's position.\n   *\n   * @memberof Globe.prototype\n   * @type {NearFarScalar}\n   *\n   * @see Globe#undergroundColor\n   *\n   */\n  undergroundColorAlphaByDistance: {\n    get: function () {\n      return this._undergroundColorAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      }\n      //>>includeEnd('debug');\n      this._undergroundColorAlphaByDistance = NearFarScalar.clone(value, this._undergroundColorAlphaByDistance);\n    }\n  },\n  /**\n   * Properties for controlling globe translucency.\n   *\n   * @memberof Globe.prototype\n   * @type {GlobeTranslucency}\n   */\n  translucency: {\n    get: function () {\n      return this._translucency;\n    }\n  }\n});\nfunction makeShadersDirty(globe) {\n  const defines = [];\n  const requireNormals = defined(globe._material) && (defined(globe._material.shaderSource.match(/slope/)) || defined(globe._material.shaderSource.match(\"normalEC\")));\n  const fragmentSources = [AtmosphereCommon, GroundAtmosphere];\n  if (defined(globe._material) && (!requireNormals || globe._terrainProvider.requestVertexNormals)) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.materialUniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.materialUniformMap = undefined;\n  }\n  fragmentSources.push(GlobeFS);\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [AtmosphereCommon, GroundAtmosphere, GlobeVS],\n    defines: defines\n  });\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    const aDist = BoundingSphere.distanceSquaredTo(a.pickBoundingSphere, rayOrigin);\n    const bDist = BoundingSphere.distanceSquaredTo(b.pickBoundingSphere, rayOrigin);\n    return aDist - bDist;\n  };\n}\nconst scratchArray = [];\nconst scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0\n};\n\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {boolean} [cullBackFaces=true] Set to true to not pick back faces.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\nGlobe.prototype.pickWorldCoordinates = function (ray, scene, cullBackFaces, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, true);\n  const mode = scene.mode;\n  const projection = scene.mapProjection;\n  const sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n  const tilesToRender = this._surface._tilesToRender;\n  let length = tilesToRender.length;\n  let tile;\n  let i;\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    const surfaceTile = tile.data;\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n    let boundingVolume = surfaceTile.pickBoundingSphere;\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume = BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, projection, surfaceTile.tileBoundingRegion.minimumHeight, surfaceTile.tileBoundingRegion.maximumHeight, boundingVolume);\n      Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(surfaceTile.tileBoundingRegion.boundingSphere, boundingVolume);\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n    const boundingSphereIntersection = IntersectionTests.raySphere(ray, boundingVolume, scratchSphereIntersectionResult);\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n  let intersection;\n  length = sphereIntersections.length;\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(ray, scene.mode, scene.mapProjection, cullBackFaces, result);\n    if (defined(intersection)) {\n      break;\n    }\n  }\n  return intersection;\n};\nconst cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * const ray = viewer.camera.getPickRay(windowCoordinates);\n * const intersection = globe.pick(ray, scene);\n */\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, true, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    const carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = this._ellipsoid.cartographicToCartesian(carto, result);\n  }\n  return result;\n};\nconst scratchGetHeightCartesian = new Cartesian3();\nconst scratchGetHeightIntersection = new Cartesian3();\nconst scratchGetHeightCartographic = new Cartographic();\nconst scratchGetHeightRay = new Ray();\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic) ? tile : undefined;\n}\n\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {number|undefined} The height of the cartographic or undefined if it could not be found.\n */\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  }\n  //>>includeEnd('debug');\n\n  const levelZeroTiles = this._surface._levelZeroTiles;\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n  let tile;\n  let i;\n  const length = levelZeroTiles.length;\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n  if (i >= length) {\n    return undefined;\n  }\n  let tileWithMesh = tile;\n  while (defined(tile)) {\n    tile = tileIfContainsCartographic(tile._southwestChild, cartographic) || tileIfContainsCartographic(tile._southeastChild, cartographic) || tileIfContainsCartographic(tile._northwestChild, cartographic) || tile._northeastChild;\n    if (defined(tile) && defined(tile.data) && defined(tile.data.renderedMesh)) {\n      tileWithMesh = tile;\n    }\n  }\n  tile = tileWithMesh;\n\n  // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n  if (!defined(tile) || !defined(tile.data) || !defined(tile.data.renderedMesh)) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n  const projection = this._surface._tileProvider.tilingScheme.projection;\n  const ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid;\n\n  //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n  const cartesian = Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0, ellipsoid, scratchGetHeightCartesian);\n  const ray = scratchGetHeightRay;\n  const surfaceNormal = ellipsoid.geodeticSurfaceNormal(cartesian, ray.direction);\n\n  // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n  const rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(cartesian, 11500.0, ray.origin);\n\n  // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    let minimumHeight;\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n    const magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0);\n\n    // multiply by the *positive* value of the magnitude\n    const vectorToMinimumPoint = Cartesian3.multiplyByScalar(surfaceNormal, Math.abs(magnitude) + 1, scratchGetHeightIntersection);\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n  const intersection = tile.data.pick(ray, undefined, projection, false, scratchGetHeightIntersection);\n  if (!defined(intersection)) {\n    return undefined;\n  }\n  return ellipsoid.cartesianToCartographic(intersection, scratchGetHeightCartographic).height;\n};\n\n/**\n * @private\n */\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.beginFrame = function (frameState) {\n  const surface = this._surface;\n  const tileProvider = surface.tileProvider;\n  const terrainProvider = this.terrainProvider;\n  const hasWaterMask = defined(terrainProvider) && terrainProvider.hasWaterMask && terrainProvider.hasWaterMask;\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    const oceanNormalMapResource = this._oceanNormalMapResource;\n    const oceanNormalMapUrl = oceanNormalMapResource.url;\n    if (defined(oceanNormalMapUrl)) {\n      const that = this;\n      oceanNormalMapResource.fetchImage().then(function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n        that._oceanNormalMap = that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image\n        });\n      });\n    } else {\n      this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n  const pass = frameState.passes;\n  const mode = frameState.mode;\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity = mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.showWaterEffect = this.showWaterEffect;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.atmosphereLightIntensity = this.atmosphereLightIntensity;\n    tileProvider.atmosphereRayleighCoefficient = this.atmosphereRayleighCoefficient;\n    tileProvider.atmosphereMieCoefficient = this.atmosphereMieCoefficient;\n    tileProvider.atmosphereRayleighScaleHeight = this.atmosphereRayleighScaleHeight;\n    tileProvider.atmosphereMieScaleHeight = this.atmosphereMieScaleHeight;\n    tileProvider.atmosphereMieAnisotropy = this.atmosphereMieAnisotropy;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    tileProvider.vertexShadowDarkness = this.vertexShadowDarkness;\n    tileProvider.undergroundColor = this._undergroundColor;\n    tileProvider.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance;\n    tileProvider.lambertDiffuseMultiplier = this.lambertDiffuseMultiplier;\n    surface.beginFrame(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n  this._surface.render(frameState);\n};\n\n/**\n * @private\n */\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\nexport default Globe;","map":{"version":3,"names":["BoundingSphere","buildModuleUrl","Cartesian3","Cartographic","Color","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","EllipsoidTerrainProvider","Event","IntersectionTests","NearFarScalar","Ray","Rectangle","Resource","ShaderSource","Texture","GlobeFS","GlobeVS","AtmosphereCommon","GroundAtmosphere","GlobeSurfaceShaderSet","GlobeSurfaceTileProvider","GlobeTranslucency","ImageryLayerCollection","QuadtreePrimitive","SceneMode","ShadowMode","CesiumMath","Globe","ellipsoid","default","terrainProvider","imageryLayerCollection","_ellipsoid","_imageryLayerCollection","_surfaceShaderSet","_material","undefined","_surface","tileProvider","imageryLayers","surfaceShaderSet","_terrainProvider","_terrainProviderChanged","_undergroundColor","clone","BLACK","_undergroundColorAlphaByDistance","maximumRadius","_translucency","makeShadersDirty","show","_oceanNormalMapResourceDirty","_oceanNormalMapResource","url","maximumScreenSpaceError","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","fillHighlightColor","enableLighting","lambertDiffuseMultiplier","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","WGS84","equals","atmosphereLightIntensity","atmosphereRayleighCoefficient","atmosphereMieCoefficient","atmosphereRayleighScaleHeight","atmosphereMieScaleHeight","atmosphereMieAnisotropy","lightingFadeOutDistance","PI_OVER_TWO","minimumRadius","lightingFadeInDistance","PI","nightFadeOutDistance","nightFadeInDistance","showWaterEffect","depthTestAgainstTerrain","shadows","RECEIVE_ONLY","atmosphereHueShift","atmosphereSaturationShift","atmosphereBrightnessShift","showSkirts","backFaceCulling","_oceanNormalMap","_zoomedOutOceanSpecularIntensity","vertexShadowDarkness","Object","defineProperties","prototype","get","imageryLayersUpdatedEvent","tilesLoaded","_tileLoadQueueHigh","length","_tileLoadQueueMedium","_tileLoadQueueLow","baseColor","set","value","clippingPlanes","clippingPolygons","cartographicLimitRectangle","MAX_VALUE","oceanNormalMapUrl","raiseEvent","terrainProviderChanged","tileLoadProgressEvent","material","undergroundColor","undergroundColorAlphaByDistance","far","near","translucency","globe","defines","requireNormals","shaderSource","match","fragmentSources","requestVertexNormals","push","_tileProvider","materialUniformMap","_uniforms","baseVertexShaderSource","sources","baseFragmentShaderSource","createComparePickTileFunction","rayOrigin","a","b","aDist","distanceSquaredTo","pickBoundingSphere","bDist","scratchArray","scratchSphereIntersectionResult","start","stop","pickWorldCoordinates","ray","scene","cullBackFaces","result","mode","projection","mapProjection","sphereIntersections","tilesToRender","_tilesToRender","tile","i","surfaceTile","data","boundingVolume","SCENE3D","fromRectangleWithHeights2D","rectangle","tileBoundingRegion","minimumHeight","maximumHeight","fromElements","center","z","x","y","renderedMesh","boundingSphere","boundingSphereIntersection","raySphere","sort","origin","intersection","pick","cartoScratch","carto","unproject","cartographicToCartesian","scratchGetHeightCartesian","scratchGetHeightIntersection","scratchGetHeightCartographic","scratchGetHeightRay","tileIfContainsCartographic","cartographic","contains","getHeight","levelZeroTiles","_levelZeroTiles","tileWithMesh","_southwestChild","_southeastChild","_northwestChild","_northeastChild","tilingScheme","cartesian","fromRadians","longitude","latitude","surfaceNormal","geodeticSurfaceNormal","direction","getSurfaceNormalIntersectionWithZAxis","magnitude","Math","min","vectorToMinimumPoint","multiplyByScalar","abs","subtract","cartesianToCartographic","height","update","frameState","passes","render","beginFrame","surface","hasWaterMask","oceanNormalMapResource","that","fetchImage","then","image","destroy","context","source","pass","zoomedOutOceanSpecularIntensity","oceanNormalMap","hueShift","saturationShift","brightnessShift","endFrame","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Globe.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport GlobeTranslucency from \"./GlobeTranslucency.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] Determines the size and shape of the\n * globe.\n */\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid,\n  });\n  const imageryLayerCollection = new ImageryLayerCollection();\n\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet,\n    }),\n  });\n\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n\n  this._undergroundColor = Color.clone(Color.BLACK);\n  this._undergroundColorAlphaByDistance = new NearFarScalar(\n    ellipsoid.maximumRadius / 1000.0,\n    0.0,\n    ellipsoid.maximumRadius / 5.0,\n    1.0,\n  );\n\n  this._translucency = new GlobeTranslucency();\n\n  makeShadersDirty(this);\n\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = true;\n\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\"),\n  });\n\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = 2;\n\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {number}\n   * @default 100\n   */\n  this.tileCacheSize = 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.enableLighting = false;\n\n  /**\n   * A multiplier to adjust terrain lambert lighting.\n   * This number is multiplied by the result of <code>czm_getLambertDiffuse</code> in GlobeFS.glsl.\n   * This only takes effect when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default 0.9\n   */\n  this.lambertDiffuseMultiplier = 0.9;\n\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.dynamicAtmosphereLighting = true;\n\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.dynamicAtmosphereLightingFromSun = false;\n\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @type {boolean}\n   * @default true when using the WGS84 ellipsoid, false otherwise\n   */\n  this.showGroundAtmosphere = Ellipsoid.WGS84.equals(ellipsoid);\n\n  /**\n   * The intensity of the light that is used for computing the ground atmosphere color.\n   *\n   * @type {number}\n   * @default 10.0\n   */\n  this.atmosphereLightIntensity = 10.0;\n\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(5.5e-6, 13.0e-6, 28.4e-6)\n   */\n  this.atmosphereRayleighCoefficient = new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6);\n\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(21e-6, 21e-6, 21e-6)\n   */\n  this.atmosphereMieCoefficient = new Cartesian3(21e-6, 21e-6, 21e-6);\n\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 10000.0\n   */\n  this.atmosphereRayleighScaleHeight = 10000.0;\n\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 3200.0\n   */\n  this.atmosphereMieScaleHeight = 3200.0;\n\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * <p>\n   * Valid values are between -1.0 and 1.0.\n   * </p>\n   * @type {number}\n   * @default 0.9\n   */\n  this.atmosphereMieAnisotropy = 0.9;\n\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default 1/2 * pi * ellipsoid.minimumRadius\n   */\n  this.lightingFadeOutDistance =\n    CesiumMath.PI_OVER_TWO * ellipsoid.minimumRadius;\n\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default pi * ellipsoid.minimumRadius\n   */\n  this.lightingFadeInDistance = CesiumMath.PI * ellipsoid.minimumRadius;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {number}\n   * @default 1/2 * pi * ellipsoid.minimumRadius\n   */\n  this.nightFadeOutDistance = CesiumMath.PI_OVER_TWO * ellipsoid.minimumRadius;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {number}\n   * @default 5/2 * pi * ellipsoid.minimumRadius\n   */\n  this.nightFadeInDistance =\n    5.0 * CesiumMath.PI_OVER_TWO * ellipsoid.minimumRadius;\n\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.showWaterEffect = true;\n\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {boolean}\n   * @default false\n   *\n   */\n  this.depthTestAgainstTerrain = false;\n\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {number}\n   * @default 0.0\n   */\n  this.atmosphereHueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {number}\n   * @default 0.0\n   */\n  this.atmosphereSaturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {number}\n   * @default 0.0\n   */\n  this.atmosphereBrightnessShift = 0.0;\n\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * Skirts are always hidden when the camera is underground or translucency is enabled.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.showSkirts = true;\n\n  /**\n   * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.backFaceCulling = true;\n\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n\n  /**\n   * Determines the darkness of the vertex shadow.\n   * This only takes effect when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {number}\n   * @default 0.3\n   */\n  this.vertexShadowDarkness = 0.3;\n}\n\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function () {\n      return this._imageryLayerCollection;\n    },\n  },\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    },\n  },\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function () {\n      if (!defined(this._surface)) {\n        return true;\n      }\n      return (\n        this._surface._tileLoadQueueHigh.length === 0 &&\n        this._surface._tileLoadQueueMedium.length === 0 &&\n        this._surface._tileLoadQueueLow.length === 0\n      );\n    },\n  },\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function (value) {\n      this._surface.tileProvider.baseColor = value;\n    },\n  },\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    },\n  },\n  /**\n   * A property specifying a {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPolygonCollection}\n   */\n  clippingPolygons: {\n    get: function () {\n      return this._surface.tileProvider.clippingPolygons;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPolygons = value;\n    },\n  },\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @memberof Globe.prototype\n   * @type {Rectangle}\n   * @default {@link Rectangle.MAX_VALUE}\n   */\n  cartographicLimitRectangle: {\n    get: function () {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    },\n  },\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {string}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function () {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function (value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    },\n  },\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n        this._terrainProviderChanged.raiseEvent(value);\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    },\n  },\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      return this._terrainProviderChanged;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._surface.tileLoadProgressEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material | undefined}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    },\n  },\n\n  /**\n   * The color to render the back side of the globe when the camera is underground or the globe is translucent,\n   * blended with the globe color based on the camera's distance.\n   * <br /><br />\n   * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.\n   *\n   * @memberof Globe.prototype\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Globe#undergroundColorAlphaByDistance\n   */\n  undergroundColor: {\n    get: function () {\n      return this._undergroundColor;\n    },\n    set: function (value) {\n      this._undergroundColor = Color.clone(value, this._undergroundColor);\n    },\n  },\n\n  /**\n   * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.\n   * The alpha will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,\n   * the underground color will not be blended with the globe color.\n   * <br /> <br />\n   * When the camera is above the ellipsoid the distance is computed from the nearest\n   * point on the ellipsoid instead of the camera's position.\n   *\n   * @memberof Globe.prototype\n   * @type {NearFarScalar}\n   *\n   * @see Globe#undergroundColor\n   *\n   */\n  undergroundColorAlphaByDistance: {\n    get: function () {\n      return this._undergroundColorAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\",\n        );\n      }\n      //>>includeEnd('debug');\n      this._undergroundColorAlphaByDistance = NearFarScalar.clone(\n        value,\n        this._undergroundColorAlphaByDistance,\n      );\n    },\n  },\n\n  /**\n   * Properties for controlling globe translucency.\n   *\n   * @memberof Globe.prototype\n   * @type {GlobeTranslucency}\n   */\n  translucency: {\n    get: function () {\n      return this._translucency;\n    },\n  },\n});\n\nfunction makeShadersDirty(globe) {\n  const defines = [];\n\n  const requireNormals =\n    defined(globe._material) &&\n    (defined(globe._material.shaderSource.match(/slope/)) ||\n      defined(globe._material.shaderSource.match(\"normalEC\")));\n\n  const fragmentSources = [AtmosphereCommon, GroundAtmosphere];\n  if (\n    defined(globe._material) &&\n    (!requireNormals || globe._terrainProvider.requestVertexNormals)\n  ) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.materialUniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.materialUniformMap = undefined;\n  }\n  fragmentSources.push(GlobeFS);\n\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [AtmosphereCommon, GroundAtmosphere, GlobeVS],\n    defines: defines,\n  });\n\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines,\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\n\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    const aDist = BoundingSphere.distanceSquaredTo(\n      a.pickBoundingSphere,\n      rayOrigin,\n    );\n    const bDist = BoundingSphere.distanceSquaredTo(\n      b.pickBoundingSphere,\n      rayOrigin,\n    );\n\n    return aDist - bDist;\n  };\n}\n\nconst scratchArray = [];\nconst scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0,\n};\n\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {boolean} [cullBackFaces=true] Set to true to not pick back faces.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\nGlobe.prototype.pickWorldCoordinates = function (\n  ray,\n  scene,\n  cullBackFaces,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, true);\n\n  const mode = scene.mode;\n  const projection = scene.mapProjection;\n\n  const sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n\n  const tilesToRender = this._surface._tilesToRender;\n  let length = tilesToRender.length;\n\n  let tile;\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    const surfaceTile = tile.data;\n\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n\n    let boundingVolume = surfaceTile.pickBoundingSphere;\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume =\n        BoundingSphere.fromRectangleWithHeights2D(\n          tile.rectangle,\n          projection,\n          surfaceTile.tileBoundingRegion.minimumHeight,\n          surfaceTile.tileBoundingRegion.maximumHeight,\n          boundingVolume,\n        );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center,\n      );\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(\n        surfaceTile.tileBoundingRegion.boundingSphere,\n        boundingVolume,\n      );\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n\n    const boundingSphereIntersection = IntersectionTests.raySphere(\n      ray,\n      boundingVolume,\n      scratchSphereIntersectionResult,\n    );\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n\n  let intersection;\n  length = sphereIntersections.length;\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(\n      ray,\n      scene.mode,\n      scene.mapProjection,\n      cullBackFaces,\n      result,\n    );\n    if (defined(intersection)) {\n      break;\n    }\n  }\n\n  return intersection;\n};\n\nconst cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * const ray = viewer.camera.getPickRay(windowCoordinates);\n * const intersection = globe.pick(ray, scene);\n */\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, true, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    const carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = this._ellipsoid.cartographicToCartesian(carto, result);\n  }\n\n  return result;\n};\n\nconst scratchGetHeightCartesian = new Cartesian3();\nconst scratchGetHeightIntersection = new Cartesian3();\nconst scratchGetHeightCartographic = new Cartographic();\nconst scratchGetHeightRay = new Ray();\n\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic)\n    ? tile\n    : undefined;\n}\n\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {number|undefined} The height of the cartographic or undefined if it could not be found.\n */\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  }\n  //>>includeEnd('debug');\n\n  const levelZeroTiles = this._surface._levelZeroTiles;\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n\n  let tile;\n  let i;\n\n  const length = levelZeroTiles.length;\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n\n  if (i >= length) {\n    return undefined;\n  }\n\n  let tileWithMesh = tile;\n\n  while (defined(tile)) {\n    tile =\n      tileIfContainsCartographic(tile._southwestChild, cartographic) ||\n      tileIfContainsCartographic(tile._southeastChild, cartographic) ||\n      tileIfContainsCartographic(tile._northwestChild, cartographic) ||\n      tile._northeastChild;\n\n    if (\n      defined(tile) &&\n      defined(tile.data) &&\n      defined(tile.data.renderedMesh)\n    ) {\n      tileWithMesh = tile;\n    }\n  }\n\n  tile = tileWithMesh;\n\n  // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n  if (\n    !defined(tile) ||\n    !defined(tile.data) ||\n    !defined(tile.data.renderedMesh)\n  ) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n\n  const projection = this._surface._tileProvider.tilingScheme.projection;\n  const ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid;\n\n  //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n  const cartesian = Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    0.0,\n    ellipsoid,\n    scratchGetHeightCartesian,\n  );\n\n  const ray = scratchGetHeightRay;\n  const surfaceNormal = ellipsoid.geodeticSurfaceNormal(\n    cartesian,\n    ray.direction,\n  );\n\n  // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n  const rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n    cartesian,\n    11500.0,\n    ray.origin,\n  );\n\n  // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    let minimumHeight;\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n    const magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0);\n\n    // multiply by the *positive* value of the magnitude\n    const vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Math.abs(magnitude) + 1,\n      scratchGetHeightIntersection,\n    );\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n\n  const intersection = tile.data.pick(\n    ray,\n    undefined,\n    projection,\n    false,\n    scratchGetHeightIntersection,\n  );\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return ellipsoid.cartesianToCartographic(\n    intersection,\n    scratchGetHeightCartographic,\n  ).height;\n};\n\n/**\n * @private\n */\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.beginFrame = function (frameState) {\n  const surface = this._surface;\n  const tileProvider = surface.tileProvider;\n  const terrainProvider = this.terrainProvider;\n  const hasWaterMask =\n    defined(terrainProvider) &&\n    terrainProvider.hasWaterMask &&\n    terrainProvider.hasWaterMask;\n\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    const oceanNormalMapResource = this._oceanNormalMapResource;\n    const oceanNormalMapUrl = oceanNormalMapResource.url;\n    if (defined(oceanNormalMapUrl)) {\n      const that = this;\n      oceanNormalMapResource.fetchImage().then(function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n\n        that._oceanNormalMap =\n          that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image,\n        });\n      });\n    } else {\n      this._oceanNormalMap =\n        this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n\n  const pass = frameState.passes;\n  const mode = frameState.mode;\n\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity =\n      mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.showWaterEffect = this.showWaterEffect;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun =\n      this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.atmosphereLightIntensity = this.atmosphereLightIntensity;\n    tileProvider.atmosphereRayleighCoefficient =\n      this.atmosphereRayleighCoefficient;\n    tileProvider.atmosphereMieCoefficient = this.atmosphereMieCoefficient;\n    tileProvider.atmosphereRayleighScaleHeight =\n      this.atmosphereRayleighScaleHeight;\n    tileProvider.atmosphereMieScaleHeight = this.atmosphereMieScaleHeight;\n    tileProvider.atmosphereMieAnisotropy = this.atmosphereMieAnisotropy;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    tileProvider.vertexShadowDarkness = this.vertexShadowDarkness;\n    tileProvider.undergroundColor = this._undergroundColor;\n    tileProvider.undergroundColorAlphaByDistance =\n      this._undergroundColorAlphaByDistance;\n    tileProvider.lambertDiffuseMultiplier = this.lambertDiffuseMultiplier;\n\n    surface.beginFrame(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n\n  this._surface.render(frameState);\n};\n\n/**\n * @private\n */\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet =\n    this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\nexport default Globe;\n"],"mappings":"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B,GAAG,IAAI;;EAE5B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAG,KAAK;;EAE5B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAGvB,SAAS;;EAEnC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACwB,cAAc,GAAG,KAAK;;EAE3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,wBAAwB,GAAG,GAAG;;EAEnC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,yBAAyB,GAAG,IAAI;;EAErC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gCAAgC,GAAG,KAAK;;EAE7C;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,oBAAoB,GAAG3D,SAAS,CAAC4D,KAAK,CAACC,MAAM,CAACtC,SAAS,CAAC;;EAE7D;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACuC,wBAAwB,GAAG,IAAI;;EAEpC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,6BAA6B,GAAG,IAAItE,UAAU,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC;;EAE7E;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACuE,wBAAwB,GAAG,IAAIvE,UAAU,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;;EAEnE;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACwE,6BAA6B,GAAG,OAAO;;EAE5C;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,wBAAwB,GAAG,MAAM;;EAEtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,uBAAuB,GAAG,GAAG;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,uBAAuB,GAC1B/C,UAAU,CAACgD,WAAW,GAAG9C,SAAS,CAAC+C,aAAa;;EAElD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,sBAAsB,GAAGlD,UAAU,CAACmD,EAAE,GAAGjD,SAAS,CAAC+C,aAAa;;EAErE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACG,oBAAoB,GAAGpD,UAAU,CAACgD,WAAW,GAAG9C,SAAS,CAAC+C,aAAa;;EAE5E;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACI,mBAAmB,GACtB,GAAG,GAAGrD,UAAU,CAACgD,WAAW,GAAG9C,SAAS,CAAC+C,aAAa;;EAExD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACK,eAAe,GAAG,IAAI;;EAE3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,uBAAuB,GAAG,KAAK;;EAEpC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAGzD,UAAU,CAAC0D,YAAY;;EAEtC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAG,GAAG;;EAE7B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,yBAAyB,GAAG,GAAG;;EAEpC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,yBAAyB,GAAG,GAAG;;EAEpC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;;EAEtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAG,IAAI;EAE3B,IAAI,CAACC,eAAe,GAAGrD,SAAS;EAChC,IAAI,CAACsD,gCAAgC,GAAGtD,SAAS;;EAEjD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACuD,oBAAoB,GAAG,GAAG;AACjC;AAEAC,MAAM,CAACC,gBAAgB,CAAClE,KAAK,CAACmE,SAAS,EAAE;EACvC;AACF;AACA;AACA;AACA;EACElE,SAAS,EAAE;IACTmE,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC/D,UAAU;IACxB;EACF,CAAC;EACD;AACF;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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}