{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport MaterialStageFS from \"../../Shaders/Model/MaterialStageFS.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport LightingModel from \"./LightingModel.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nconst {\n  Material,\n  MetallicRoughness,\n  SpecularGlossiness,\n  Specular,\n  Clearcoat\n} = ModelComponents;\n\n/**\n * The material pipeline stage processes textures and other uniforms needed\n * to render a primitive. This handles the following material types:\n * <ul>\n *   <li>Basic glTF materials (PBR metallic roughness model)</li>\n *   <li>The `KHR_materials_specular` glTF extension</li>\n *   <li>The `KHR_materials_pbrSpecularGlossiness` glTF extension</li>\n *   <li>The `KHR_materials_unlit` glTF extension</li>\n * </ul>\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst MaterialPipelineStage = {\n  name: \"MaterialPipelineStage\",\n  // Helps with debugging\n\n  // Expose some methods for testing\n  _processTexture: processTexture,\n  _processTextureTransform: processTextureTransform\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the material processing stage</li>\n *   <li>Modifies the shader to include additional uniforms for textures and other rendering details</li>\n *   <li>Modifies the lighting options to set either PBR or unlit lighting</li>\n *   <li>Sets the render state for back-face culling</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nMaterialPipelineStage.process = function (renderResources, primitive, frameState) {\n  // gltf-pipeline automatically creates a default material so this will always\n  // be defined.\n  const material = primitive.material;\n  const {\n    model,\n    uniformMap,\n    shaderBuilder\n  } = renderResources;\n\n  // Classification models only use position and feature ID attributes,\n  // so textures should be disabled to avoid compile errors.\n  const hasClassification = defined(model.classificationType);\n  const disableTextures = hasClassification;\n\n  // When textures are loaded incrementally, fall back to a default 1x1 texture\n  const {\n    defaultTexture,\n    defaultNormalTexture,\n    defaultEmissiveTexture\n  } = frameState.context;\n  processMaterialUniforms(material, uniformMap, shaderBuilder, defaultTexture, defaultNormalTexture, defaultEmissiveTexture, disableTextures);\n  if (defined(material.specularGlossiness)) {\n    processSpecularGlossinessUniforms(material.specularGlossiness, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n  } else {\n    if (defined(material.specular) && ModelUtility.supportedExtensions.KHR_materials_specular) {\n      processSpecularUniforms(material.specular, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n    }\n    if (defined(material.anisotropy) && ModelUtility.supportedExtensions.KHR_materials_anisotropy) {\n      processAnisotropyUniforms(material.anisotropy, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n    }\n    if (defined(material.clearcoat) && ModelUtility.supportedExtensions.KHR_materials_clearcoat) {\n      processClearcoatUniforms(material.clearcoat, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n    }\n    processMetallicRoughnessUniforms(material.metallicRoughness, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n  }\n\n  // If the primitive does not have normals, fall back to unlit lighting.\n  const hasNormals = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.NORMAL);\n\n  // Classification models will be rendered as unlit.\n  const lightingOptions = renderResources.lightingOptions;\n  if (material.unlit || !hasNormals || hasClassification) {\n    lightingOptions.lightingModel = LightingModel.UNLIT;\n  } else {\n    lightingOptions.lightingModel = LightingModel.PBR;\n  }\n\n  // Configure back-face culling\n  const cull = model.backFaceCulling && !material.doubleSided;\n  renderResources.renderStateOptions.cull.enabled = cull;\n  const alphaOptions = renderResources.alphaOptions;\n  if (material.alphaMode === AlphaMode.BLEND) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (material.alphaMode === AlphaMode.MASK) {\n    alphaOptions.alphaCutoff = material.alphaCutoff;\n  }\n  shaderBuilder.addFragmentLines(MaterialStageFS);\n  if (material.doubleSided) {\n    shaderBuilder.addDefine(\"HAS_DOUBLE_SIDED_MATERIAL\", undefined, ShaderDestination.BOTH);\n  }\n};\n\n/**\n * Process a single texture transformation and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureTransform(shaderBuilder, uniformMap, textureReader, uniformName, defineName) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_TRANSFORM`;\n  shaderBuilder.addDefine(transformDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a uniform for the transformation matrix\n  const transformUniformName = `${uniformName}Transform`;\n  shaderBuilder.addUniform(\"mat3\", transformUniformName, ShaderDestination.FRAGMENT);\n  uniformMap[transformUniformName] = function () {\n    return textureReader.transform;\n  };\n}\n\n/**\n * Process a single texture scale and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureScale(shaderBuilder, uniformMap, textureReader, uniformName, defineName) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_SCALE`;\n  shaderBuilder.addDefine(transformDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a uniform for the transformation matrix\n  const scaleUniformName = `${uniformName}Scale`;\n  shaderBuilder.addUniform(\"float\", scaleUniformName, ShaderDestination.FRAGMENT);\n  uniformMap[scaleUniformName] = function () {\n    return textureReader.scale;\n  };\n}\n\n/**\n * Process a single texture and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTexture(shaderBuilder, uniformMap, textureReader, uniformName, defineName, defaultTexture) {\n  // Add a uniform for the texture itself\n  shaderBuilder.addUniform(\"sampler2D\", uniformName, ShaderDestination.FRAGMENT);\n  uniformMap[uniformName] = function () {\n    return defaultValue(textureReader.texture, defaultTexture);\n  };\n\n  // Add a #define directive to enable using the texture in the shader\n  const textureDefine = `HAS_${defineName}_TEXTURE`;\n  shaderBuilder.addDefine(textureDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a #define to tell the shader which texture coordinates varying to use.\n  const texCoordIndex = textureReader.texCoord;\n  const texCoordVarying = `v_texCoord_${texCoordIndex}`;\n  const texCoordDefine = `TEXCOORD_${defineName}`;\n  shaderBuilder.addDefine(texCoordDefine, texCoordVarying, ShaderDestination.FRAGMENT);\n\n  // Some textures have matrix transforms (e.g. for texture atlases). Add those\n  // to the shader if present.\n  const textureTransform = textureReader.transform;\n  if (defined(textureTransform) && !Matrix3.equals(textureTransform, Matrix3.IDENTITY)) {\n    processTextureTransform(shaderBuilder, uniformMap, textureReader, uniformName, defineName);\n  }\n  const {\n    scale\n  } = textureReader;\n  if (defined(scale) && scale !== 1.0) {\n    processTextureScale(shaderBuilder, uniformMap, textureReader, uniformName, defineName);\n  }\n}\nfunction processMaterialUniforms(material, uniformMap, shaderBuilder, defaultTexture, defaultNormalTexture, defaultEmissiveTexture, disableTextures) {\n  const {\n    emissiveFactor,\n    emissiveTexture,\n    normalTexture,\n    occlusionTexture\n  } = material;\n  if (defined(emissiveFactor) && !Cartesian3.equals(emissiveFactor, Material.DEFAULT_EMISSIVE_FACTOR)) {\n    shaderBuilder.addUniform(\"vec3\", \"u_emissiveFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_emissiveFactor = function () {\n      return material.emissiveFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_EMISSIVE_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n    if (defined(emissiveTexture) && !disableTextures) {\n      processTexture(shaderBuilder, uniformMap, emissiveTexture, \"u_emissiveTexture\", \"EMISSIVE\", defaultEmissiveTexture);\n    }\n  }\n  if (defined(normalTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, normalTexture, \"u_normalTexture\", \"NORMAL\", defaultNormalTexture);\n  }\n  if (defined(occlusionTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, occlusionTexture, \"u_occlusionTexture\", \"OCCLUSION\", defaultTexture);\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_pbrSpecularGlossiness extension\n *\n * @param {ModelComponents.SpecularGlossiness} specularGlossiness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularGlossinessUniforms(specularGlossiness, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    diffuseTexture,\n    diffuseFactor,\n    specularGlossinessTexture,\n    specularFactor,\n    glossinessFactor\n  } = specularGlossiness;\n  shaderBuilder.addDefine(\"USE_SPECULAR_GLOSSINESS\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(diffuseTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, diffuseTexture, \"u_diffuseTexture\", \"DIFFUSE\", defaultTexture);\n  }\n  if (defined(diffuseFactor) && !Cartesian4.equals(diffuseFactor, SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR)) {\n    shaderBuilder.addUniform(\"vec4\", \"u_diffuseFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_diffuseFactor = function () {\n      return specularGlossiness.diffuseFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_DIFFUSE_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(specularGlossinessTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, specularGlossinessTexture, \"u_specularGlossinessTexture\", \"SPECULAR_GLOSSINESS\", defaultTexture);\n  }\n  if (defined(specularFactor) && !Cartesian3.equals(specularFactor, SpecularGlossiness.DEFAULT_SPECULAR_FACTOR)) {\n    shaderBuilder.addUniform(\"vec3\", \"u_legacySpecularFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_legacySpecularFactor = function () {\n      return specularGlossiness.specularFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_LEGACY_SPECULAR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(glossinessFactor) && glossinessFactor !== SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_glossinessFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_glossinessFactor = function () {\n      return specularGlossiness.glossinessFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_GLOSSINESS_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_specular extension\n *\n * @param {ModelComponents.Specular} specular\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularUniforms(specular, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    specularTexture,\n    specularFactor,\n    specularColorTexture,\n    specularColorFactor\n  } = specular;\n  shaderBuilder.addDefine(\"USE_SPECULAR\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(specularTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, specularTexture, \"u_specularTexture\", \"SPECULAR\", defaultTexture);\n  }\n  if (defined(specularFactor) && specularFactor !== Specular.DEFAULT_SPECULAR_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_specularFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_specularFactor = function () {\n      return specular.specularFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_SPECULAR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(specularColorTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, specularColorTexture, \"u_specularColorTexture\", \"SPECULAR_COLOR\", defaultTexture);\n  }\n  if (defined(specularColorFactor) && !Cartesian3.equals(specularColorFactor, Specular.DEFAULT_SPECULAR_COLOR_FACTOR)) {\n    shaderBuilder.addUniform(\"vec3\", \"u_specularColorFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_specularColorFactor = function () {\n      return specular.specularColorFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_SPECULAR_COLOR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n}\nconst scratchAnisotropy = new Cartesian3();\n\n/**\n * Add uniforms and defines for the KHR_materials_anisotropy extension\n *\n * @param {ModelComponents.Anisotropy} anisotropy\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processAnisotropyUniforms(anisotropy, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    anisotropyStrength,\n    anisotropyRotation,\n    anisotropyTexture\n  } = anisotropy;\n  shaderBuilder.addDefine(\"USE_ANISOTROPY\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(anisotropyTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, anisotropyTexture, \"u_anisotropyTexture\", \"ANISOTROPY\", defaultTexture);\n  }\n\n  // Pre-compute cos and sin of rotation, since they are the same for all fragments.\n  // Combine with strength as one vec3 uniform.\n  const cosRotation = Math.cos(anisotropyRotation);\n  const sinRotation = Math.sin(anisotropyRotation);\n  shaderBuilder.addUniform(\"vec3\", \"u_anisotropy\", ShaderDestination.FRAGMENT);\n  uniformMap.u_anisotropy = function () {\n    return Cartesian3.fromElements(cosRotation, sinRotation, anisotropyStrength, scratchAnisotropy);\n  };\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_clearcoat extension\n *\n * @param {ModelComponents.Clearcoat} clearcoat\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processClearcoatUniforms(clearcoat, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    clearcoatFactor,\n    clearcoatTexture,\n    clearcoatRoughnessFactor,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture\n  } = clearcoat;\n  shaderBuilder.addDefine(\"USE_CLEARCOAT\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(clearcoatFactor) && clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_clearcoatFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_clearcoatFactor = function () {\n      return clearcoat.clearcoatFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_CLEARCOAT_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(clearcoatTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, clearcoatTexture, \"u_clearcoatTexture\", \"CLEARCOAT\", defaultTexture);\n  }\n  if (defined(clearcoatRoughnessFactor) && clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_clearcoatRoughnessFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_clearcoatRoughnessFactor = function () {\n      return clearcoat.clearcoatRoughnessFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_CLEARCOAT_ROUGHNESS_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(clearcoatRoughnessTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, clearcoatRoughnessTexture, \"u_clearcoatRoughnessTexture\", \"CLEARCOAT_ROUGHNESS\", defaultTexture);\n  }\n  if (defined(clearcoatNormalTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, clearcoatNormalTexture, \"u_clearcoatNormalTexture\", \"CLEARCOAT_NORMAL\", defaultTexture);\n  }\n}\n\n/**\n * Add uniforms and defines for the PBR metallic roughness model\n *\n * @param {ModelComponents.MetallicRoughness} metallicRoughness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processMetallicRoughnessUniforms(metallicRoughness, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  shaderBuilder.addDefine(\"USE_METALLIC_ROUGHNESS\", undefined, ShaderDestination.FRAGMENT);\n  const baseColorTexture = metallicRoughness.baseColorTexture;\n  if (defined(baseColorTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, baseColorTexture, \"u_baseColorTexture\", \"BASE_COLOR\", defaultTexture);\n  }\n  const baseColorFactor = metallicRoughness.baseColorFactor;\n  if (defined(baseColorFactor) && !Cartesian4.equals(baseColorFactor, MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR)) {\n    shaderBuilder.addUniform(\"vec4\", \"u_baseColorFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_baseColorFactor = function () {\n      return metallicRoughness.baseColorFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_BASE_COLOR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const metallicRoughnessTexture = metallicRoughness.metallicRoughnessTexture;\n  if (defined(metallicRoughnessTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, metallicRoughnessTexture, \"u_metallicRoughnessTexture\", \"METALLIC_ROUGHNESS\", defaultTexture);\n  }\n  const metallicFactor = metallicRoughness.metallicFactor;\n  if (defined(metallicFactor) && metallicFactor !== MetallicRoughness.DEFAULT_METALLIC_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_metallicFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_metallicFactor = function () {\n      return metallicRoughness.metallicFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_METALLIC_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const roughnessFactor = metallicRoughness.roughnessFactor;\n  if (defined(roughnessFactor) && roughnessFactor !== MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_roughnessFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_roughnessFactor = function () {\n      return metallicRoughness.roughnessFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_ROUGHNESS_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n}\nexport default MaterialPipelineStage;","map":{"version":3,"names":["defined","defaultValue","Cartesian3","Cartesian4","Matrix3","ShaderDestination","Pass","MaterialStageFS","AlphaMode","ModelComponents","VertexAttributeSemantic","LightingModel","ModelUtility","Material","MetallicRoughness","SpecularGlossiness","Specular","Clearcoat","MaterialPipelineStage","name","_processTexture","processTexture","_processTextureTransform","processTextureTransform","process","renderResources","primitive","frameState","material","model","uniformMap","shaderBuilder","hasClassification","classificationType","disableTextures","defaultTexture","defaultNormalTexture","defaultEmissiveTexture","context","processMaterialUniforms","specularGlossiness","processSpecularGlossinessUniforms","specular","supportedExtensions","KHR_materials_specular","processSpecularUniforms","anisotropy","KHR_materials_anisotropy","processAnisotropyUniforms","clearcoat","KHR_materials_clearcoat","processClearcoatUniforms","processMetallicRoughnessUniforms","metallicRoughness","hasNormals","getAttributeBySemantic","NORMAL","lightingOptions","unlit","lightingModel","UNLIT","PBR","cull","backFaceCulling","doubleSided","renderStateOptions","enabled","alphaOptions","alphaMode","BLEND","pass","TRANSLUCENT","MASK","alphaCutoff","addFragmentLines","addDefine","undefined","BOTH","textureReader","uniformName","defineName","transformDefine","FRAGMENT","transformUniformName","addUniform","transform","processTextureScale","scaleUniformName","scale","texture","textureDefine","texCoordIndex","texCoord","texCoordVarying","texCoordDefine","textureTransform","equals","IDENTITY","emissiveFactor","emissiveTexture","normalTexture","occlusionTexture","DEFAULT_EMISSIVE_FACTOR","u_emissiveFactor","diffuseTexture","diffuseFactor","specularGlossinessTexture","specularFactor","glossinessFactor","DEFAULT_DIFFUSE_FACTOR","u_diffuseFactor","DEFAULT_SPECULAR_FACTOR","u_legacySpecularFactor","DEFAULT_GLOSSINESS_FACTOR","u_glossinessFactor","specularTexture","specularColorTexture","specularColorFactor","u_specularFactor","DEFAULT_SPECULAR_COLOR_FACTOR","u_specularColorFactor","scratchAnisotropy","anisotropyStrength","anisotropyRotation","anisotropyTexture","cosRotation","Math","cos","sinRotation","sin","u_anisotropy","fromElements","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","DEFAULT_CLEARCOAT_FACTOR","u_clearcoatFactor","DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR","u_clearcoatRoughnessFactor","baseColorTexture","baseColorFactor","DEFAULT_BASE_COLOR_FACTOR","u_baseColorFactor","metallicRoughnessTexture","metallicFactor","DEFAULT_METALLIC_FACTOR","u_metallicFactor","roughnessFactor","DEFAULT_ROUGHNESS_FACTOR","u_roughnessFactor"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/MaterialPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport MaterialStageFS from \"../../Shaders/Model/MaterialStageFS.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport LightingModel from \"./LightingModel.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst { Material, MetallicRoughness, SpecularGlossiness, Specular, Clearcoat } =\n  ModelComponents;\n\n/**\n * The material pipeline stage processes textures and other uniforms needed\n * to render a primitive. This handles the following material types:\n * <ul>\n *   <li>Basic glTF materials (PBR metallic roughness model)</li>\n *   <li>The `KHR_materials_specular` glTF extension</li>\n *   <li>The `KHR_materials_pbrSpecularGlossiness` glTF extension</li>\n *   <li>The `KHR_materials_unlit` glTF extension</li>\n * </ul>\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst MaterialPipelineStage = {\n  name: \"MaterialPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _processTexture: processTexture,\n  _processTextureTransform: processTextureTransform,\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the material processing stage</li>\n *   <li>Modifies the shader to include additional uniforms for textures and other rendering details</li>\n *   <li>Modifies the lighting options to set either PBR or unlit lighting</li>\n *   <li>Sets the render state for back-face culling</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nMaterialPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  // gltf-pipeline automatically creates a default material so this will always\n  // be defined.\n  const material = primitive.material;\n  const { model, uniformMap, shaderBuilder } = renderResources;\n\n  // Classification models only use position and feature ID attributes,\n  // so textures should be disabled to avoid compile errors.\n  const hasClassification = defined(model.classificationType);\n  const disableTextures = hasClassification;\n\n  // When textures are loaded incrementally, fall back to a default 1x1 texture\n  const { defaultTexture, defaultNormalTexture, defaultEmissiveTexture } =\n    frameState.context;\n\n  processMaterialUniforms(\n    material,\n    uniformMap,\n    shaderBuilder,\n    defaultTexture,\n    defaultNormalTexture,\n    defaultEmissiveTexture,\n    disableTextures,\n  );\n\n  if (defined(material.specularGlossiness)) {\n    processSpecularGlossinessUniforms(\n      material.specularGlossiness,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture,\n      disableTextures,\n    );\n  } else {\n    if (\n      defined(material.specular) &&\n      ModelUtility.supportedExtensions.KHR_materials_specular\n    ) {\n      processSpecularUniforms(\n        material.specular,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    if (\n      defined(material.anisotropy) &&\n      ModelUtility.supportedExtensions.KHR_materials_anisotropy\n    ) {\n      processAnisotropyUniforms(\n        material.anisotropy,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    if (\n      defined(material.clearcoat) &&\n      ModelUtility.supportedExtensions.KHR_materials_clearcoat\n    ) {\n      processClearcoatUniforms(\n        material.clearcoat,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    processMetallicRoughnessUniforms(\n      material.metallicRoughness,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture,\n      disableTextures,\n    );\n  }\n\n  // If the primitive does not have normals, fall back to unlit lighting.\n  const hasNormals = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.NORMAL,\n  );\n\n  // Classification models will be rendered as unlit.\n  const lightingOptions = renderResources.lightingOptions;\n  if (material.unlit || !hasNormals || hasClassification) {\n    lightingOptions.lightingModel = LightingModel.UNLIT;\n  } else {\n    lightingOptions.lightingModel = LightingModel.PBR;\n  }\n\n  // Configure back-face culling\n  const cull = model.backFaceCulling && !material.doubleSided;\n  renderResources.renderStateOptions.cull.enabled = cull;\n\n  const alphaOptions = renderResources.alphaOptions;\n  if (material.alphaMode === AlphaMode.BLEND) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (material.alphaMode === AlphaMode.MASK) {\n    alphaOptions.alphaCutoff = material.alphaCutoff;\n  }\n\n  shaderBuilder.addFragmentLines(MaterialStageFS);\n\n  if (material.doubleSided) {\n    shaderBuilder.addDefine(\n      \"HAS_DOUBLE_SIDED_MATERIAL\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n  }\n};\n\n/**\n * Process a single texture transformation and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureTransform(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_TRANSFORM`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Add a uniform for the transformation matrix\n  const transformUniformName = `${uniformName}Transform`;\n  shaderBuilder.addUniform(\n    \"mat3\",\n    transformUniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[transformUniformName] = function () {\n    return textureReader.transform;\n  };\n}\n\n/**\n * Process a single texture scale and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureScale(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_SCALE`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Add a uniform for the transformation matrix\n  const scaleUniformName = `${uniformName}Scale`;\n  shaderBuilder.addUniform(\n    \"float\",\n    scaleUniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[scaleUniformName] = function () {\n    return textureReader.scale;\n  };\n}\n\n/**\n * Process a single texture and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTexture(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n  defaultTexture,\n) {\n  // Add a uniform for the texture itself\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[uniformName] = function () {\n    return defaultValue(textureReader.texture, defaultTexture);\n  };\n\n  // Add a #define directive to enable using the texture in the shader\n  const textureDefine = `HAS_${defineName}_TEXTURE`;\n  shaderBuilder.addDefine(textureDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a #define to tell the shader which texture coordinates varying to use.\n  const texCoordIndex = textureReader.texCoord;\n  const texCoordVarying = `v_texCoord_${texCoordIndex}`;\n  const texCoordDefine = `TEXCOORD_${defineName}`;\n  shaderBuilder.addDefine(\n    texCoordDefine,\n    texCoordVarying,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Some textures have matrix transforms (e.g. for texture atlases). Add those\n  // to the shader if present.\n  const textureTransform = textureReader.transform;\n  if (\n    defined(textureTransform) &&\n    !Matrix3.equals(textureTransform, Matrix3.IDENTITY)\n  ) {\n    processTextureTransform(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName,\n    );\n  }\n\n  const { scale } = textureReader;\n  if (defined(scale) && scale !== 1.0) {\n    processTextureScale(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName,\n    );\n  }\n}\n\nfunction processMaterialUniforms(\n  material,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  defaultNormalTexture,\n  defaultEmissiveTexture,\n  disableTextures,\n) {\n  const { emissiveFactor, emissiveTexture, normalTexture, occlusionTexture } =\n    material;\n\n  if (\n    defined(emissiveFactor) &&\n    !Cartesian3.equals(emissiveFactor, Material.DEFAULT_EMISSIVE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_emissiveFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_emissiveFactor = function () {\n      return material.emissiveFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_EMISSIVE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    if (defined(emissiveTexture) && !disableTextures) {\n      processTexture(\n        shaderBuilder,\n        uniformMap,\n        emissiveTexture,\n        \"u_emissiveTexture\",\n        \"EMISSIVE\",\n        defaultEmissiveTexture,\n      );\n    }\n  }\n\n  if (defined(normalTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      normalTexture,\n      \"u_normalTexture\",\n      \"NORMAL\",\n      defaultNormalTexture,\n    );\n  }\n\n  if (defined(occlusionTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      occlusionTexture,\n      \"u_occlusionTexture\",\n      \"OCCLUSION\",\n      defaultTexture,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_pbrSpecularGlossiness extension\n *\n * @param {ModelComponents.SpecularGlossiness} specularGlossiness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularGlossinessUniforms(\n  specularGlossiness,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    diffuseTexture,\n    diffuseFactor,\n    specularGlossinessTexture,\n    specularFactor,\n    glossinessFactor,\n  } = specularGlossiness;\n\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR_GLOSSINESS\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(diffuseTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      diffuseTexture,\n      \"u_diffuseTexture\",\n      \"DIFFUSE\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(diffuseFactor) &&\n    !Cartesian4.equals(diffuseFactor, SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_diffuseFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_diffuseFactor = function () {\n      return specularGlossiness.diffuseFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_DIFFUSE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(specularGlossinessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularGlossinessTexture,\n      \"u_specularGlossinessTexture\",\n      \"SPECULAR_GLOSSINESS\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularFactor) &&\n    !Cartesian3.equals(\n      specularFactor,\n      SpecularGlossiness.DEFAULT_SPECULAR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_legacySpecularFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_legacySpecularFactor = function () {\n      return specularGlossiness.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_LEGACY_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (\n    defined(glossinessFactor) &&\n    glossinessFactor !== SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_glossinessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_glossinessFactor = function () {\n      return specularGlossiness.glossinessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_GLOSSINESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_specular extension\n *\n * @param {ModelComponents.Specular} specular\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularUniforms(\n  specular,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    specularTexture,\n    specularFactor,\n    specularColorTexture,\n    specularColorFactor,\n  } = specular;\n\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(specularTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularTexture,\n      \"u_specularTexture\",\n      \"SPECULAR\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularFactor) &&\n    specularFactor !== Specular.DEFAULT_SPECULAR_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_specularFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_specularFactor = function () {\n      return specular.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(specularColorTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularColorTexture,\n      \"u_specularColorTexture\",\n      \"SPECULAR_COLOR\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularColorFactor) &&\n    !Cartesian3.equals(\n      specularColorFactor,\n      Specular.DEFAULT_SPECULAR_COLOR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_specularColorFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_specularColorFactor = function () {\n      return specular.specularColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\nconst scratchAnisotropy = new Cartesian3();\n\n/**\n * Add uniforms and defines for the KHR_materials_anisotropy extension\n *\n * @param {ModelComponents.Anisotropy} anisotropy\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processAnisotropyUniforms(\n  anisotropy,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const { anisotropyStrength, anisotropyRotation, anisotropyTexture } =\n    anisotropy;\n\n  shaderBuilder.addDefine(\n    \"USE_ANISOTROPY\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(anisotropyTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      anisotropyTexture,\n      \"u_anisotropyTexture\",\n      \"ANISOTROPY\",\n      defaultTexture,\n    );\n  }\n\n  // Pre-compute cos and sin of rotation, since they are the same for all fragments.\n  // Combine with strength as one vec3 uniform.\n  const cosRotation = Math.cos(anisotropyRotation);\n  const sinRotation = Math.sin(anisotropyRotation);\n  shaderBuilder.addUniform(\"vec3\", \"u_anisotropy\", ShaderDestination.FRAGMENT);\n  uniformMap.u_anisotropy = function () {\n    return Cartesian3.fromElements(\n      cosRotation,\n      sinRotation,\n      anisotropyStrength,\n      scratchAnisotropy,\n    );\n  };\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_clearcoat extension\n *\n * @param {ModelComponents.Clearcoat} clearcoat\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processClearcoatUniforms(\n  clearcoat,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    clearcoatFactor,\n    clearcoatTexture,\n    clearcoatRoughnessFactor,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture,\n  } = clearcoat;\n\n  shaderBuilder.addDefine(\n    \"USE_CLEARCOAT\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (\n    defined(clearcoatFactor) &&\n    clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_clearcoatFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_clearcoatFactor = function () {\n      return clearcoat.clearcoatFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_CLEARCOAT_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(clearcoatTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatTexture,\n      \"u_clearcoatTexture\",\n      \"CLEARCOAT\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(clearcoatRoughnessFactor) &&\n    clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_clearcoatRoughnessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_clearcoatRoughnessFactor = function () {\n      return clearcoat.clearcoatRoughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_CLEARCOAT_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(clearcoatRoughnessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatRoughnessTexture,\n      \"u_clearcoatRoughnessTexture\",\n      \"CLEARCOAT_ROUGHNESS\",\n      defaultTexture,\n    );\n  }\n\n  if (defined(clearcoatNormalTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatNormalTexture,\n      \"u_clearcoatNormalTexture\",\n      \"CLEARCOAT_NORMAL\",\n      defaultTexture,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the PBR metallic roughness model\n *\n * @param {ModelComponents.MetallicRoughness} metallicRoughness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processMetallicRoughnessUniforms(\n  metallicRoughness,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  shaderBuilder.addDefine(\n    \"USE_METALLIC_ROUGHNESS\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const baseColorTexture = metallicRoughness.baseColorTexture;\n  if (defined(baseColorTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      baseColorTexture,\n      \"u_baseColorTexture\",\n      \"BASE_COLOR\",\n      defaultTexture,\n    );\n  }\n\n  const baseColorFactor = metallicRoughness.baseColorFactor;\n  if (\n    defined(baseColorFactor) &&\n    !Cartesian4.equals(\n      baseColorFactor,\n      MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_baseColorFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_baseColorFactor = function () {\n      return metallicRoughness.baseColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_BASE_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const metallicRoughnessTexture = metallicRoughness.metallicRoughnessTexture;\n  if (defined(metallicRoughnessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      metallicRoughnessTexture,\n      \"u_metallicRoughnessTexture\",\n      \"METALLIC_ROUGHNESS\",\n      defaultTexture,\n    );\n  }\n\n  const metallicFactor = metallicRoughness.metallicFactor;\n  if (\n    defined(metallicFactor) &&\n    metallicFactor !== MetallicRoughness.DEFAULT_METALLIC_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_metallicFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_metallicFactor = function () {\n      return metallicRoughness.metallicFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_METALLIC_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const roughnessFactor = metallicRoughness.roughnessFactor;\n  if (\n    defined(roughnessFactor) &&\n    roughnessFactor !== MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_roughnessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_roughnessFactor = function () {\n      return metallicRoughness.roughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\nexport default MaterialPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}