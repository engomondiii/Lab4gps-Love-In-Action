{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst texCoordScratch = new Cartesian2();\nconst textureMatrixScratch = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst projectedCenterScratch = new Cartesian3();\nconst scratchMinTexCoord = new Cartesian2();\nconst scratchMaxTexCoord = new Cartesian2();\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const stRotation = options.stRotation;\n  const size = extrude ? positions.length / 3 * 2 : positions.length / 3;\n  const shadowVolume = options.shadowVolume;\n  const textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(size * 3) : undefined;\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  let textureMatrix = textureMatrixScratch;\n  let tangentMatrix = tangentMatrixScratch;\n  if (stRotation !== 0) {\n    let rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n    rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);\n    tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n    tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n  }\n  const minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n  const maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n  let length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  const stOffset = bottomOffset / 3 * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n      const projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n      texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n      }\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n      if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n          Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    const finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions\n    });\n  }\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n  }\n  if (extrude && defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      const offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n  return attributes;\n}\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTriangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n\n  const indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  let indicesIndex = 0;\n  let prevIndex;\n  let numInterior;\n  let positionIndex;\n  let i;\n  let j;\n  // Indices triangles to the 'right' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  // Indices for center column of triangles\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  // Reverse the process creating indices to the 'left' of the north vector\n  ++prevIndex;\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  return indices;\n}\nlet boundingSphereCenter = new Cartesian3();\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n  boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n  const boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const attributes = computeTopBottomAttributes(positions, options, false);\n  let indices = topIndices(numPts);\n  indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices\n  };\n}\nfunction computeWallAttributes(positions, options) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const stRotation = options.stRotation;\n  const size = positions.length / 3 * 2;\n  const finalPositions = new Float64Array(size * 3);\n  const textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(size * 3) : undefined;\n  const shadowVolume = options.shadowVolume;\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  const rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n  const textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n  const minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n  const maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n  let length = positions.length;\n  const stOffset = length / 3 * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    let position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    let extrudedPosition;\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n      const projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n      texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n    let scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);\n    position = Cartesian3.add(position, scaledNormal, position);\n    scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n    extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = Cartesian3.clone(normal, bitangent);\n      const next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);\n      Cartesian3.subtract(next, position, next);\n      const bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);\n      normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions\n    });\n  }\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals\n    });\n  }\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents\n    });\n  }\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents\n    });\n  }\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n  }\n  if (defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      const offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n  return attributes;\n}\nfunction computeWallIndices(positions) {\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 6);\n  let index = 0;\n  for (let i = 0; i < length; i++) {\n    const UL = i;\n    const LL = i + length;\n    const UR = (UL + 1) % length;\n    const LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n  return indices;\n}\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n  topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n  topBoundingSphere.radius = semiMajorAxis;\n  scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n  bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n  bottomBoundingSphere.radius = semiMajorAxis;\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const outerPositions = cep.outerPositions;\n  const boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n  const topBottomAttributes = computeTopBottomAttributes(positions, options, true);\n  let indices = topIndices(numPts);\n  const length = indices.length;\n  indices.length = length * 2;\n  const posLength = positions.length / 3;\n  for (let i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n  const topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);\n  const topBottomGeo = new Geometry({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  const wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  const wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);\n  const wallGeo = new Geometry({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  const geo = GeometryPipeline.combineInstances([new GeometryInstance({\n    geometry: topBottomGeo\n  }), new GeometryInstance({\n    geometry: wallGeo\n  })]);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices\n  };\n}\nfunction computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {\n  const cep = EllipseGeometryLibrary.computeEllipsePositions({\n    center: center,\n    semiMajorAxis: semiMajorAxis,\n    semiMinorAxis: semiMinorAxis,\n    rotation: rotation,\n    granularity: granularity\n  }, false, true);\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n  const rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a \"circle\" around the pole\n  if (rectangle.width > CesiumMath.PI) {\n    rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;\n    rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;\n    rectangle.east = CesiumMath.PI;\n    rectangle.west = -CesiumMath.PI;\n  }\n  return rectangle;\n}\n\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * const ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\nfunction EllipseGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\"semiMajorAxis must be greater than or equal to the semiMinorAxis.\");\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createEllipseGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipseGeometry(scratchOptions);\n  }\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\"semiMajorAxis must be greater than or equal to the semiMinorAxis.\");\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);\n};\n\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (ellipseGeometry._semiMajorAxis <= 0.0 || ellipseGeometry._semiMinorAxis <= 0.0) {\n    return;\n  }\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute\n  });\n};\n\n/**\n * @private\n */\nEllipseGeometry.createShadowVolume = function (ellipseGeometry, minHeightFunc, maxHeightFunc) {\n  const granularity = ellipseGeometry._granularity;\n  const ellipsoid = ellipseGeometry._ellipsoid;\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true\n  });\n};\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  const stRotation = -ellipseGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  const cep = EllipseGeometryLibrary.computeEllipsePositions({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    rotation: ellipseGeometry._rotation,\n    granularity: ellipseGeometry._granularity\n  }, false, true);\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n  const ellipsoid = ellipseGeometry._ellipsoid;\n  const boundingRectangle = ellipseGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n}\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);\n      }\n      return this._rectangle;\n    }\n  },\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    }\n  }\n});\nexport default EllipseGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","EllipseGeometryLibrary","Ellipsoid","GeographicProjection","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","Matrix3","PrimitiveType","Quaternion","Rectangle","VertexFormat","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchNormal","scratchTangent","scratchBitangent","scratchCartographic","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","positions","options","extrude","vertexFormat","center","semiMajorAxis","semiMinorAxis","ellipsoid","stRotation","size","length","shadowVolume","textureCoordinates","st","Float32Array","undefined","normals","normal","tangents","tangent","bitangents","bitangent","extrudeNormals","textureCoordIndex","projection","projectedCenter","project","cartesianToCartographic","geodeticNormal","scaleToGeodeticSurface","geodeticSurfaceNormal","textureMatrix","tangentMatrix","rotation","fromAxisAngle","fromQuaternion","clone","IDENTITY","minTexCoord","fromElements","Number","POSITIVE_INFINITY","maxTexCoord","NEGATIVE_INFINITY","bottomOffset","stOffset","i","i1","i2","position","fromArray","rotatedPoint","multiplyByVector","projectedPoint","subtract","x","y","Math","min","max","z","normalize","cross","UNIT_Z","k","attributes","finalPositions","raisePositionsToHeight","componentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","extrudeDirection","offsetAttribute","Uint8Array","TOP","fill","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","topIndices","numPts","indices","Array","indicesIndex","prevIndex","numInterior","positionIndex","j","boundingSphereCenter","computeEllipse","multiplyByScalar","height","add","boundingSphere","cep","computeEllipsePositions","createTypedArray","computeWallAttributes","extrudedHeight","Float64Array","extrudedPosition","scaledNormal","next","bottom","computeWallIndices","index","UL","LL","UR","LR","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","radius","outerPositions","union","topBottomAttributes","posLength","topBottomIndices","topBottomGeo","primitiveType","TRIANGLES","wallAttributes","wallIndices","wallGeo","geo","combineInstances","geometry","computeRectangle","granularity","result","positionsFlat","positionsCount","rectangle","fromCartesianArray","width","PI","north","PI_OVER_TWO","EPSILON7","south","east","west","EllipseGeometry","EMPTY_OBJECT","default","RADIANS_PER_DEGREE","DEFAULT","typeOf","number","_center","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","_stRotation","_height","_granularity","_vertexFormat","_extrudedHeight","_shadowVolume","_workerName","_offsetAttribute","_rectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchVertexFormat","scratchOptions","unpack","createGeometry","ellipseGeometry","equalsEpsilon","EPSILON2","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","boundingRectangle","Object","defineProperties","prototype","get"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EllipseGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst texCoordScratch = new Cartesian2();\nconst textureMatrixScratch = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\n\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\n\nconst scratchCartographic = new Cartographic();\nconst projectedCenterScratch = new Cartesian3();\n\nconst scratchMinTexCoord = new Cartesian2();\nconst scratchMaxTexCoord = new Cartesian2();\n\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const stRotation = options.stRotation;\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n  const shadowVolume = options.shadowVolume;\n\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(size * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch,\n  );\n\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1,\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n  let textureMatrix = textureMatrixScratch;\n  let tangentMatrix = tangentMatrixScratch;\n  if (stRotation !== 0) {\n    let rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      stRotation,\n      quaternionScratch,\n    );\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      -stRotation,\n      quaternionScratch,\n    );\n    tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n    tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n  }\n\n  const minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord,\n  );\n  const maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord,\n  );\n\n  let length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  const stOffset = (bottomOffset / 3) * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2,\n      );\n      const projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3,\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] =\n          texCoordScratch.y;\n      }\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    if (\n      vertexFormat.normal ||\n      vertexFormat.tangent ||\n      vertexFormat.bitangent ||\n      shadowVolume\n    ) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent\n      ) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent,\n          );\n          Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    const finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(\n      positions,\n      options,\n      extrude,\n    );\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (extrude && defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTriangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n\n  const indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  let indicesIndex = 0;\n  let prevIndex;\n  let numInterior;\n  let positionIndex;\n  let i;\n  let j;\n  // Indices triangles to the 'right' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  // Indices for center column of triangles\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  // Reverse the process creating indices to the 'left' of the north vector\n  ++prevIndex;\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  return indices;\n}\n\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter,\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter,\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis,\n  );\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    false,\n  );\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const attributes = computeTopBottomAttributes(positions, options, false);\n  let indices = topIndices(numPts);\n  indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction computeWallAttributes(positions, options) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const stRotation = options.stRotation;\n  const size = (positions.length / 3) * 2;\n\n  const finalPositions = new Float64Array(size * 3);\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(size * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  const shadowVolume = options.shadowVolume;\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch,\n  );\n\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1,\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  const rotation = Quaternion.fromAxisAngle(\n    geodeticNormal,\n    stRotation,\n    quaternionScratch,\n  );\n  const textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n  const minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord,\n  );\n  const maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord,\n  );\n\n  let length = positions.length;\n  const stOffset = (length / 3) * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    let position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    let extrudedPosition;\n\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2,\n      );\n      const projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3,\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n\n    let scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian4,\n    );\n    position = Cartesian3.add(position, scaledNormal, position);\n    scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      extrudedHeight,\n      scaledNormal,\n    );\n    extrudedPosition = Cartesian3.add(\n      extrudedPosition,\n      scaledNormal,\n      extrudedPosition,\n    );\n\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = Cartesian3.clone(normal, bitangent);\n      const next = Cartesian3.fromArray(\n        positions,\n        (i + 3) % length,\n        scratchCartesian4,\n      );\n      Cartesian3.subtract(next, position, next);\n      const bottom = Cartesian3.subtract(\n        extrudedPosition,\n        position,\n        scratchCartesian3,\n      );\n\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottom, next, normal),\n        normal,\n      );\n\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangent = Cartesian3.normalize(\n          Cartesian3.cross(bitangent, normal, tangent),\n          tangent,\n        );\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction computeWallIndices(positions) {\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 6);\n  let index = 0;\n  for (let i = 0; i < length; i++) {\n    const UL = i;\n    const LL = i + length;\n    const UR = (UL + 1) % length;\n    const LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n\n  return indices;\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\n\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1,\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center,\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal,\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center,\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    true,\n  );\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const outerPositions = cep.outerPositions;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere,\n  );\n  const topBottomAttributes = computeTopBottomAttributes(\n    positions,\n    options,\n    true,\n  );\n  let indices = topIndices(numPts);\n  const length = indices.length;\n  indices.length = length * 2;\n  const posLength = positions.length / 3;\n  for (let i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n\n  const topBottomIndices = IndexDatatype.createTypedArray(\n    (posLength * 2) / 3,\n    indices,\n  );\n\n  const topBottomGeo = new Geometry({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  const wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  const wallIndices = IndexDatatype.createTypedArray(\n    (outerPositions.length * 2) / 3,\n    indices,\n  );\n\n  const wallGeo = new Geometry({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  const geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: wallGeo,\n    }),\n  ]);\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices,\n  };\n}\n\nfunction computeRectangle(\n  center,\n  semiMajorAxis,\n  semiMinorAxis,\n  rotation,\n  granularity,\n  ellipsoid,\n  result,\n) {\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: center,\n      semiMajorAxis: semiMajorAxis,\n      semiMinorAxis: semiMinorAxis,\n      rotation: rotation,\n      granularity: granularity,\n    },\n    false,\n    true,\n  );\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n  const rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a \"circle\" around the pole\n  if (rectangle.width > CesiumMath.PI) {\n    rectangle.north =\n      rectangle.north > 0.0\n        ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7\n        : rectangle.north;\n    rectangle.south =\n      rectangle.south < 0.0\n        ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO\n        : rectangle.south;\n    rectangle.east = CesiumMath.PI;\n    rectangle.west = -CesiumMath.PI;\n  }\n  return rectangle;\n}\n\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * const ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\nfunction EllipseGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\",\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createEllipseGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nEllipseGeometry.packedLength =\n  Cartesian3.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid the ellipse will be on.\n * @param {number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\",\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  return computeRectangle(\n    center,\n    semiMajorAxis,\n    semiMinorAxis,\n    rotation,\n    granularity,\n    ellipsoid,\n    result,\n  );\n};\n\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center,\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nEllipseGeometry.createShadowVolume = function (\n  ellipseGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = ellipseGeometry._granularity;\n  const ellipsoid = ellipseGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  const stRotation = -ellipseGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: ellipseGeometry._center,\n      semiMajorAxis: ellipseGeometry._semiMajorAxis,\n      semiMinorAxis: ellipseGeometry._semiMinorAxis,\n      rotation: ellipseGeometry._rotation,\n      granularity: ellipseGeometry._granularity,\n    },\n    false,\n    true,\n  );\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n\n  const ellipsoid = ellipseGeometry._ellipsoid;\n  const boundingRectangle = ellipseGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle,\n  );\n}\n\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._center,\n          this._semiMajorAxis,\n          this._semiMinorAxis,\n          this._rotation,\n          this._granularity,\n          this._ellipsoid,\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints =\n          textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default EllipseGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}