{"ast":null,"code":"import Color from \"../../Core/Color.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ModelAnimationLoop from \"../ModelAnimationLoop.js\";\nimport Model from \"./Model.js\";\n\n/**\n * Represents the contents of a glTF, glb or\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n * This object is normally not instantiated directly, use {@link Model3DTileContent.fromGltf}, {@link Model3DTileContent.fromB3dm}, {@link Model3DTileContent.fromI3dm}, {@link Model3DTileContent.fromPnts}, or {@link Model3DTileContent.fromGeoJson}.\n *\n * @alias Model3DTileContent\n * @constructor\n * @private\n */\nfunction Model3DTileContent(tileset, tile, resource) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._model = undefined;\n  this._metadata = undefined;\n  this._group = undefined;\n  this._ready = false;\n}\nObject.defineProperties(Model3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId].featuresLength;\n      }\n      return 0;\n    }\n  },\n  pointsLength: {\n    get: function () {\n      return this._model.statistics.pointsLength;\n    }\n  },\n  trianglesLength: {\n    get: function () {\n      return this._model.statistics.trianglesLength;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      return this._model.statistics.geometryByteLength;\n    }\n  },\n  texturesByteLength: {\n    get: function () {\n      return this._model.statistics.texturesByteLength;\n    }\n  },\n  batchTableByteLength: {\n    get: function () {\n      const statistics = this._model.statistics;\n      return statistics.propertyTablesByteLength + statistics.batchTexturesByteLength;\n    }\n  },\n  innerContents: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Model3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    }\n  },\n  batchTable: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId];\n      }\n      return undefined;\n    }\n  },\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    }\n  },\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    }\n  }\n});\n\n/**\n * Returns an array containing the `texture.id` values for all textures\n * that are part of this content.\n *\n * @returns {string[]} The texture IDs\n */\nModel3DTileContent.prototype.getTextureIds = function () {\n  return this._model.statistics.getTextureIds();\n};\n\n/**\n * Returns the length, in bytes, of the texture data for the texture with\n * the given ID that is part of this content, or `undefined` if this\n * content does not contain the texture with the given ID.\n *\n * @param {string} textureId The texture ID\n * @returns {number|undefined} The texture byte length\n */\nModel3DTileContent.prototype.getTextureByteLengthById = function (textureId) {\n  return this._model.statistics.getTextureByteLengthById(textureId);\n};\n\n/**\n * Returns the object that was created for the given extension.\n *\n * The given name may be the name of a glTF extension, like `\"EXT_example_extension\"`.\n * If the specified extension was present in the root of the underlying glTF asset,\n * and a loader for the specified extension has processed the extension data, then\n * this will return the model representation of the extension.\n *\n * @param {string} extensionName The name of the extension\n * @returns {object|undefined} The object, or `undefined`\n *\n * @private\n */\nModel3DTileContent.prototype.getExtension = function (extensionName) {\n  const model = this._model;\n  const extension = model.getExtension(extensionName);\n  return extension;\n};\nModel3DTileContent.prototype.getFeature = function (featureId) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(featureTableId)) {\n    throw new DeveloperError(\"No feature ID set is selected. Make sure Cesium3DTileset.featureIdLabel or Cesium3DTileset.instanceFeatureIdLabel is defined\");\n  }\n  //>>includeEnd('debug');\n\n  const featureTable = model.featureTables[featureTableId];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(featureTable)) {\n    throw new DeveloperError(\"No feature table found for the selected feature ID set\");\n  }\n  //>>includeEnd('debug');\n\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = featureTable.featuresLength;\n  if (!defined(featureId) || featureId < 0 || featureId >= featuresLength) {\n    throw new DeveloperError(`featureId is required and must be between 0 and featuresLength - 1 (${featuresLength - 1}).`);\n  }\n  //>>includeEnd('debug');\n  return featureTable.getFeature(featureId);\n};\nModel3DTileContent.prototype.hasProperty = function (featureId, name) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n  if (!defined(featureTableId)) {\n    return false;\n  }\n  const featureTable = model.featureTables[featureTableId];\n  return featureTable.hasProperty(featureId, name);\n};\nModel3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  color = enabled ? color : Color.WHITE;\n  if (this.featuresLength === 0) {\n    this._model.color = color;\n  } else if (defined(this.batchTable)) {\n    this.batchTable.setAllColor(color);\n  }\n};\nModel3DTileContent.prototype.applyStyle = function (style) {\n  // the setter will call model.applyStyle()\n  this._model.style = style;\n};\nModel3DTileContent.prototype.update = function (tileset, frameState) {\n  const model = this._model;\n  const tile = this._tile;\n  model.colorBlendAmount = tileset.colorBlendAmount;\n  model.colorBlendMode = tileset.colorBlendMode;\n  model.modelMatrix = tile.computedTransform;\n  model.customShader = tileset.customShader;\n  model.featureIdLabel = tileset.featureIdLabel;\n  model.instanceFeatureIdLabel = tileset.instanceFeatureIdLabel;\n  model.lightColor = tileset.lightColor;\n  model.imageBasedLighting = tileset.imageBasedLighting;\n  model.backFaceCulling = tileset.backFaceCulling;\n  model.shadows = tileset.shadows;\n  model.showCreditsOnScreen = tileset.showCreditsOnScreen;\n  model.splitDirection = tileset.splitDirection;\n  model.debugWireframe = tileset.debugWireframe;\n  model.showOutline = tileset.showOutline;\n  model.outlineColor = tileset.outlineColor;\n  model.pointCloudShading = tileset.pointCloudShading;\n\n  // Updating clipping planes requires more effort because of ownership checks\n  const tilesetClippingPlanes = tileset.clippingPlanes;\n  model.referenceMatrix = tileset.clippingPlanesOriginMatrix;\n  if (defined(tilesetClippingPlanes) && tile.clippingPlanesDirty) {\n    // Dereference the clipping planes from the model if they are irrelevant.\n    model._clippingPlanes = tilesetClippingPlanes.enabled && tile._isClipped ? tilesetClippingPlanes : undefined;\n  }\n  const tilesetEnvironmentMapManager = tileset.environmentMapManager;\n  if (model.environmentMapManager !== tilesetClippingPlanes) {\n    model._environmentMapManager = tilesetEnvironmentMapManager;\n  }\n\n  // If the model references a different ClippingPlaneCollection from the tileset,\n  // update the model to use the new ClippingPlaneCollection.\n  if (defined(tilesetClippingPlanes) && defined(model._clippingPlanes) && model._clippingPlanes !== tilesetClippingPlanes) {\n    model._clippingPlanes = tilesetClippingPlanes;\n    model._clippingPlanesState = 0;\n  }\n\n  // Updating clipping polygons requires more effort because of ownership checks\n  const tilesetClippingPolygons = tileset.clippingPolygons;\n  if (defined(tilesetClippingPolygons) && tile.clippingPolygonsDirty) {\n    // Dereference the clipping polygons from the model if they are irrelevant.\n    model._clippingPolygons = tilesetClippingPolygons.enabled && tile._isClippedByPolygon ? tilesetClippingPolygons : undefined;\n  }\n\n  // If the model references a different ClippingPolygonCollection from the tileset,\n  // update the model to use the new ClippingPolygonCollection.\n  if (defined(tilesetClippingPolygons) && defined(model._clippingPolygons) && model._clippingPolygons !== tilesetClippingPolygons) {\n    model._clippingPolygons = tilesetClippingPolygons;\n    model._clippingPolygonsState = 0;\n  }\n  model.update(frameState);\n  if (!this._ready && model.ready) {\n    // Animation can only be added once the model is ready\n    model.activeAnimations.addAll({\n      loop: ModelAnimationLoop.REPEAT\n    });\n    this._ready = true;\n  }\n};\nModel3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\nModel3DTileContent.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  return destroyObject(this);\n};\nModel3DTileContent.fromGltf = async function (tileset, tile, resource, gltf) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n  const additionalOptions = {\n    gltf: gltf,\n    basePath: resource\n  };\n  const modelOptions = makeModelOptions(tileset, tile, content, additionalOptions);\n  const classificationType = tileset.vectorClassificationOnly ? undefined : tileset.classificationType;\n  modelOptions.classificationType = classificationType;\n  const model = await Model.fromGltfAsync(modelOptions);\n  content._model = model;\n  return content;\n};\nModel3DTileContent.fromB3dm = async function (tileset, tile, resource, arrayBuffer, byteOffset) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource\n  };\n  const modelOptions = makeModelOptions(tileset, tile, content, additionalOptions);\n  const classificationType = tileset.vectorClassificationOnly ? undefined : tileset.classificationType;\n  modelOptions.classificationType = classificationType;\n  const model = await Model.fromB3dm(modelOptions);\n  content._model = model;\n  return content;\n};\nModel3DTileContent.fromI3dm = async function (tileset, tile, resource, arrayBuffer, byteOffset) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource\n  };\n  const modelOptions = makeModelOptions(tileset, tile, content, additionalOptions);\n  const model = await Model.fromI3dm(modelOptions);\n  content._model = model;\n  return content;\n};\nModel3DTileContent.fromPnts = async function (tileset, tile, resource, arrayBuffer, byteOffset) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource\n  };\n  const modelOptions = makeModelOptions(tileset, tile, content, additionalOptions);\n  const model = await Model.fromPnts(modelOptions);\n  content._model = model;\n  return content;\n};\nModel3DTileContent.fromGeoJson = async function (tileset, tile, resource, geoJson) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n  const additionalOptions = {\n    geoJson: geoJson,\n    resource: resource\n  };\n  const modelOptions = makeModelOptions(tileset, tile, content, additionalOptions);\n  const model = await Model.fromGeoJson(modelOptions);\n  content._model = model;\n  return content;\n};\n\n/**\n * Find an intersection between a ray and the tile content surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nModel3DTileContent.prototype.pick = function (ray, frameState, result) {\n  if (!defined(this._model) || !this._ready) {\n    return undefined;\n  }\n  const verticalExaggeration = frameState.verticalExaggeration;\n  const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n\n  // All tilesets assume a WGS84 ellipsoid\n  return this._model.pick(ray, frameState, verticalExaggeration, relativeHeight, Ellipsoid.WGS84, result);\n};\nfunction makeModelOptions(tileset, tile, content, additionalOptions) {\n  const mainOptions = {\n    cull: false,\n    // The model is already culled by 3D Tiles\n    releaseGltfJson: true,\n    // Models are unique and will not benefit from caching so save memory\n    opaquePass: Pass.CESIUM_3D_TILE,\n    // Draw opaque portions of the model during the 3D Tiles pass\n    modelMatrix: tile.computedTransform,\n    upAxis: tileset._modelUpAxis,\n    forwardAxis: tileset._modelForwardAxis,\n    incrementallyLoadTextures: false,\n    customShader: tileset.customShader,\n    content: content,\n    colorBlendMode: tileset.colorBlendMode,\n    colorBlendAmount: tileset.colorBlendAmount,\n    lightColor: tileset.lightColor,\n    imageBasedLighting: tileset.imageBasedLighting,\n    featureIdLabel: tileset.featureIdLabel,\n    instanceFeatureIdLabel: tileset.instanceFeatureIdLabel,\n    pointCloudShading: tileset.pointCloudShading,\n    clippingPlanes: tileset.clippingPlanes,\n    backFaceCulling: tileset.backFaceCulling,\n    shadows: tileset.shadows,\n    showCreditsOnScreen: tileset.showCreditsOnScreen,\n    splitDirection: tileset.splitDirection,\n    enableDebugWireframe: tileset._enableDebugWireframe,\n    debugWireframe: tileset.debugWireframe,\n    projectTo2D: tileset._projectTo2D,\n    enablePick: tileset._enablePick,\n    enableShowOutline: tileset._enableShowOutline,\n    showOutline: tileset.showOutline,\n    outlineColor: tileset.outlineColor\n  };\n  return combine(additionalOptions, mainOptions);\n}\nexport default Model3DTileContent;","map":{"version":3,"names":["Color","combine","defined","destroyObject","DeveloperError","Ellipsoid","Pass","ModelAnimationLoop","Model","Model3DTileContent","tileset","tile","resource","_tileset","_tile","_resource","_model","undefined","_metadata","_group","_ready","Object","defineProperties","prototype","featuresLength","get","model","featureTables","featureTableId","pointsLength","statistics","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","propertyTablesByteLength","batchTexturesByteLength","innerContents","ready","url","getUrlComponent","batchTable","metadata","set","value","group","getTextureIds","getTextureByteLengthById","textureId","getExtension","extensionName","extension","getFeature","featureId","featureTable","hasProperty","name","applyDebugSettings","enabled","color","WHITE","setAllColor","applyStyle","style","update","frameState","colorBlendAmount","colorBlendMode","modelMatrix","computedTransform","customShader","featureIdLabel","instanceFeatureIdLabel","lightColor","imageBasedLighting","backFaceCulling","shadows","showCreditsOnScreen","splitDirection","debugWireframe","showOutline","outlineColor","pointCloudShading","tilesetClippingPlanes","clippingPlanes","referenceMatrix","clippingPlanesOriginMatrix","clippingPlanesDirty","_clippingPlanes","_isClipped","tilesetEnvironmentMapManager","environmentMapManager","_environmentMapManager","_clippingPlanesState","tilesetClippingPolygons","clippingPolygons","clippingPolygonsDirty","_clippingPolygons","_isClippedByPolygon","_clippingPolygonsState","activeAnimations","addAll","loop","REPEAT","isDestroyed","destroy","fromGltf","gltf","content","additionalOptions","basePath","modelOptions","makeModelOptions","classificationType","vectorClassificationOnly","fromGltfAsync","fromB3dm","arrayBuffer","byteOffset","fromI3dm","fromPnts","fromGeoJson","geoJson","pick","ray","result","verticalExaggeration","relativeHeight","verticalExaggerationRelativeHeight","WGS84","mainOptions","cull","releaseGltfJson","opaquePass","CESIUM_3D_TILE","upAxis","_modelUpAxis","forwardAxis","_modelForwardAxis","incrementallyLoadTextures","enableDebugWireframe","_enableDebugWireframe","projectTo2D","_projectTo2D","enablePick","_enablePick","enableShowOutline","_enableShowOutline"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/Model3DTileContent.js"],"sourcesContent":["import Color from \"../../Core/Color.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ModelAnimationLoop from \"../ModelAnimationLoop.js\";\nimport Model from \"./Model.js\";\n\n/**\n * Represents the contents of a glTF, glb or\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n * This object is normally not instantiated directly, use {@link Model3DTileContent.fromGltf}, {@link Model3DTileContent.fromB3dm}, {@link Model3DTileContent.fromI3dm}, {@link Model3DTileContent.fromPnts}, or {@link Model3DTileContent.fromGeoJson}.\n *\n * @alias Model3DTileContent\n * @constructor\n * @private\n */\nfunction Model3DTileContent(tileset, tile, resource) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._model = undefined;\n  this._metadata = undefined;\n  this._group = undefined;\n  this._ready = false;\n}\n\nObject.defineProperties(Model3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId].featuresLength;\n      }\n\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return this._model.statistics.pointsLength;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return this._model.statistics.trianglesLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._model.statistics.geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return this._model.statistics.texturesByteLength;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      const statistics = this._model.statistics;\n      return (\n        statistics.propertyTablesByteLength + statistics.batchTexturesByteLength\n      );\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Model3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId];\n      }\n\n      return undefined;\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\n/**\n * Returns an array containing the `texture.id` values for all textures\n * that are part of this content.\n *\n * @returns {string[]} The texture IDs\n */\nModel3DTileContent.prototype.getTextureIds = function () {\n  return this._model.statistics.getTextureIds();\n};\n\n/**\n * Returns the length, in bytes, of the texture data for the texture with\n * the given ID that is part of this content, or `undefined` if this\n * content does not contain the texture with the given ID.\n *\n * @param {string} textureId The texture ID\n * @returns {number|undefined} The texture byte length\n */\nModel3DTileContent.prototype.getTextureByteLengthById = function (textureId) {\n  return this._model.statistics.getTextureByteLengthById(textureId);\n};\n\n/**\n * Returns the object that was created for the given extension.\n *\n * The given name may be the name of a glTF extension, like `\"EXT_example_extension\"`.\n * If the specified extension was present in the root of the underlying glTF asset,\n * and a loader for the specified extension has processed the extension data, then\n * this will return the model representation of the extension.\n *\n * @param {string} extensionName The name of the extension\n * @returns {object|undefined} The object, or `undefined`\n *\n * @private\n */\nModel3DTileContent.prototype.getExtension = function (extensionName) {\n  const model = this._model;\n  const extension = model.getExtension(extensionName);\n  return extension;\n};\n\nModel3DTileContent.prototype.getFeature = function (featureId) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(featureTableId)) {\n    throw new DeveloperError(\n      \"No feature ID set is selected. Make sure Cesium3DTileset.featureIdLabel or Cesium3DTileset.instanceFeatureIdLabel is defined\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const featureTable = model.featureTables[featureTableId];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(featureTable)) {\n    throw new DeveloperError(\n      \"No feature table found for the selected feature ID set\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = featureTable.featuresLength;\n  if (!defined(featureId) || featureId < 0 || featureId >= featuresLength) {\n    throw new DeveloperError(\n      `featureId is required and must be between 0 and featuresLength - 1 (${\n        featuresLength - 1\n      }).`,\n    );\n  }\n  //>>includeEnd('debug');\n  return featureTable.getFeature(featureId);\n};\n\nModel3DTileContent.prototype.hasProperty = function (featureId, name) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n  if (!defined(featureTableId)) {\n    return false;\n  }\n\n  const featureTable = model.featureTables[featureTableId];\n  return featureTable.hasProperty(featureId, name);\n};\n\nModel3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  color = enabled ? color : Color.WHITE;\n  if (this.featuresLength === 0) {\n    this._model.color = color;\n  } else if (defined(this.batchTable)) {\n    this.batchTable.setAllColor(color);\n  }\n};\n\nModel3DTileContent.prototype.applyStyle = function (style) {\n  // the setter will call model.applyStyle()\n  this._model.style = style;\n};\n\nModel3DTileContent.prototype.update = function (tileset, frameState) {\n  const model = this._model;\n  const tile = this._tile;\n\n  model.colorBlendAmount = tileset.colorBlendAmount;\n  model.colorBlendMode = tileset.colorBlendMode;\n  model.modelMatrix = tile.computedTransform;\n  model.customShader = tileset.customShader;\n  model.featureIdLabel = tileset.featureIdLabel;\n  model.instanceFeatureIdLabel = tileset.instanceFeatureIdLabel;\n  model.lightColor = tileset.lightColor;\n  model.imageBasedLighting = tileset.imageBasedLighting;\n  model.backFaceCulling = tileset.backFaceCulling;\n  model.shadows = tileset.shadows;\n  model.showCreditsOnScreen = tileset.showCreditsOnScreen;\n  model.splitDirection = tileset.splitDirection;\n  model.debugWireframe = tileset.debugWireframe;\n  model.showOutline = tileset.showOutline;\n  model.outlineColor = tileset.outlineColor;\n  model.pointCloudShading = tileset.pointCloudShading;\n\n  // Updating clipping planes requires more effort because of ownership checks\n  const tilesetClippingPlanes = tileset.clippingPlanes;\n  model.referenceMatrix = tileset.clippingPlanesOriginMatrix;\n  if (defined(tilesetClippingPlanes) && tile.clippingPlanesDirty) {\n    // Dereference the clipping planes from the model if they are irrelevant.\n    model._clippingPlanes =\n      tilesetClippingPlanes.enabled && tile._isClipped\n        ? tilesetClippingPlanes\n        : undefined;\n  }\n\n  const tilesetEnvironmentMapManager = tileset.environmentMapManager;\n  if (model.environmentMapManager !== tilesetClippingPlanes) {\n    model._environmentMapManager = tilesetEnvironmentMapManager;\n  }\n\n  // If the model references a different ClippingPlaneCollection from the tileset,\n  // update the model to use the new ClippingPlaneCollection.\n  if (\n    defined(tilesetClippingPlanes) &&\n    defined(model._clippingPlanes) &&\n    model._clippingPlanes !== tilesetClippingPlanes\n  ) {\n    model._clippingPlanes = tilesetClippingPlanes;\n    model._clippingPlanesState = 0;\n  }\n\n  // Updating clipping polygons requires more effort because of ownership checks\n  const tilesetClippingPolygons = tileset.clippingPolygons;\n  if (defined(tilesetClippingPolygons) && tile.clippingPolygonsDirty) {\n    // Dereference the clipping polygons from the model if they are irrelevant.\n    model._clippingPolygons =\n      tilesetClippingPolygons.enabled && tile._isClippedByPolygon\n        ? tilesetClippingPolygons\n        : undefined;\n  }\n\n  // If the model references a different ClippingPolygonCollection from the tileset,\n  // update the model to use the new ClippingPolygonCollection.\n  if (\n    defined(tilesetClippingPolygons) &&\n    defined(model._clippingPolygons) &&\n    model._clippingPolygons !== tilesetClippingPolygons\n  ) {\n    model._clippingPolygons = tilesetClippingPolygons;\n    model._clippingPolygonsState = 0;\n  }\n\n  model.update(frameState);\n\n  if (!this._ready && model.ready) {\n    // Animation can only be added once the model is ready\n    model.activeAnimations.addAll({\n      loop: ModelAnimationLoop.REPEAT,\n    });\n\n    this._ready = true;\n  }\n};\n\nModel3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nModel3DTileContent.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  return destroyObject(this);\n};\n\nModel3DTileContent.fromGltf = async function (tileset, tile, resource, gltf) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    gltf: gltf,\n    basePath: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n\n  const classificationType = tileset.vectorClassificationOnly\n    ? undefined\n    : tileset.classificationType;\n\n  modelOptions.classificationType = classificationType;\n\n  const model = await Model.fromGltfAsync(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromB3dm = async function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n\n  const classificationType = tileset.vectorClassificationOnly\n    ? undefined\n    : tileset.classificationType;\n\n  modelOptions.classificationType = classificationType;\n\n  const model = await Model.fromB3dm(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromI3dm = async function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n\n  const model = await Model.fromI3dm(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromPnts = async function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n  const model = await Model.fromPnts(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\nModel3DTileContent.fromGeoJson = async function (\n  tileset,\n  tile,\n  resource,\n  geoJson,\n) {\n  const content = new Model3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    geoJson: geoJson,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions,\n  );\n  const model = await Model.fromGeoJson(modelOptions);\n  content._model = model;\n\n  return content;\n};\n\n/**\n * Find an intersection between a ray and the tile content surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nModel3DTileContent.prototype.pick = function (ray, frameState, result) {\n  if (!defined(this._model) || !this._ready) {\n    return undefined;\n  }\n\n  const verticalExaggeration = frameState.verticalExaggeration;\n  const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n\n  // All tilesets assume a WGS84 ellipsoid\n  return this._model.pick(\n    ray,\n    frameState,\n    verticalExaggeration,\n    relativeHeight,\n    Ellipsoid.WGS84,\n    result,\n  );\n};\n\nfunction makeModelOptions(tileset, tile, content, additionalOptions) {\n  const mainOptions = {\n    cull: false, // The model is already culled by 3D Tiles\n    releaseGltfJson: true, // Models are unique and will not benefit from caching so save memory\n    opaquePass: Pass.CESIUM_3D_TILE, // Draw opaque portions of the model during the 3D Tiles pass\n    modelMatrix: tile.computedTransform,\n    upAxis: tileset._modelUpAxis,\n    forwardAxis: tileset._modelForwardAxis,\n    incrementallyLoadTextures: false,\n    customShader: tileset.customShader,\n    content: content,\n    colorBlendMode: tileset.colorBlendMode,\n    colorBlendAmount: tileset.colorBlendAmount,\n    lightColor: tileset.lightColor,\n    imageBasedLighting: tileset.imageBasedLighting,\n    featureIdLabel: tileset.featureIdLabel,\n    instanceFeatureIdLabel: tileset.instanceFeatureIdLabel,\n    pointCloudShading: tileset.pointCloudShading,\n    clippingPlanes: tileset.clippingPlanes,\n    backFaceCulling: tileset.backFaceCulling,\n    shadows: tileset.shadows,\n    showCreditsOnScreen: tileset.showCreditsOnScreen,\n    splitDirection: tileset.splitDirection,\n    enableDebugWireframe: tileset._enableDebugWireframe,\n    debugWireframe: tileset.debugWireframe,\n    projectTo2D: tileset._projectTo2D,\n    enablePick: tileset._enablePick,\n    enableShowOutline: tileset._enableShowOutline,\n    showOutline: tileset.showOutline,\n    outlineColor: tileset.outlineColor,\n  };\n\n  return combine(additionalOptions, mainOptions);\n}\n\nexport default Model3DTileContent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}