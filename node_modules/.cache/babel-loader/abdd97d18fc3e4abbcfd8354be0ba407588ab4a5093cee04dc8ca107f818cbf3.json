{"ast":null,"code":"/*\n * Esri Contribution: This code implements support for I3S (Indexed 3D Scene Layers), an OGC Community Standard.\n * Co-authored-by: Alexandre Jean-Claude ajeanclaude@spiria.com\n * Co-authored-by: Anthony Mirabeau anthony.mirabeau@presagis.com\n * Co-authored-by: Elizabeth Rudkin elizabeth.rudkin@presagis.com\n * Co-authored-by: Tamrat Belayneh tbelayneh@esri.com\n *\n * The I3S format has been developed by Esri and is shared under an Apache 2.0 license and is maintained @ https://github.com/Esri/i3s-spec.\n * This implementation supports loading, displaying, and querying an I3S layer (supported versions include Esri github I3S versions 1.6, 1.7/1.8 -\n * whose OGC equivalent are I3S Community Standard Version 1.1 & 1.2) in the CesiumJS viewer.\n * It enables the user to access an I3S layer via its URL and load it inside of the CesiumJS viewer.\n *\n * When a scene layer is initialized it accomplishes the following:\n *\n * It processes the 3D Scene Layer resource (https://github.com/Esri/i3s-spec/blob/master/docs/1.8/3DSceneLayer.cmn.md) of an I3S dataset\n * and loads the layers data. It does so by creating a Cesium 3D Tileset for the given i3s layer and loads the root node.\n * When the root node is imported, it creates a Cesium 3D Tile that is parented to the Cesium 3D Tileset\n * and loads all children of the root node:\n *  for each children\n *   Create a place holder 3D tile so that the LOD display can use the nodes' selection criteria (maximumScreenSpaceError) to select the appropriate node\n *   based on the current LOD display & evaluation. If the Cesium 3D tile is visible, it invokes requestContent on it.\n *   At that moment, we intercept the call to requestContent, and we load the geometry in I3S format\n *   That geometry is transcoded on the fly to glTF format and ingested by CesiumJS\n *   When the geometry is loaded, we then load all children of this node as placeholders so that the LOD\n *   can know about them too.\n *\n * About transcoding:\n *\n * We use web workers to transcode I3S geometries into glTF\n * The steps are:\n *\n * Decode geometry attributes (positions, normals, etc..) either from DRACO or Binary format.\n * If requested, when creating an I3SDataProvider the user has the option to specify a tiled elevation terrain provider\n * (geoidTiledTerrainProvider) such as the one shown in the sandcastle example based on ArcGISTiledElevationTerrainProvider, that allows\n * conversion of heights for all vertices & bounding boxes of an I3S layer from (typically) gravity related (Orthometric) heights to Ellipsoidal.\n * This step is essential when fusing data with varying height sources (as is the case when fusing the I3S dataset (gravity related) in the sandcastle examples with the cesium world terrain (ellipsoidal)).\n * We then transform vertex coordinates from LONG/LAT/HEIGHT to Cartesian in local space and\n * scale appropriately if specified in the attribute metadata\n * Crop UVs if UV regions are defined in the attribute metadata\n * Create a glTF document in memory that will be ingested as part of a glb payload\n *\n * About GEOID data:\n *\n * We provide the ability to use GEOID data to convert heights from gravity related (orthometric) height systems to ellipsoidal.\n * We employ a service architecture to get the conversion factor for a given long lat values, leveraging existing implementation based on ArcGISTiledElevationTerrainProvider\n * to avoid requiring bloated look up files. The source Data used in this transcoding service was compiled from https://earth-info.nga.mil/#tab_wgs84-data and is based on\n * EGM2008 Gravity Model. The sandcastle examples show how to set the terrain provider service if required.\n */\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport HeightmapEncoding from \"../Core/HeightmapEncoding.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport I3SLayer from \"./I3SLayer.js\";\nimport I3SStatistics from \"./I3SStatistics.js\";\nimport I3SSublayer from \"./I3SSublayer.js\";\nimport Lerc from \"lerc\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * @typedef {Object} I3SDataProvider.ConstructorOptions\n *\n * Initialization options for the I3SDataProvider constructor\n *\n * @property {string} [name] The name of the I3S dataset.\n * @property {boolean} [show=true] Determines if the dataset will be shown.\n * @property {ArcGISTiledElevationTerrainProvider|Promise<ArcGISTiledElevationTerrainProvider>} [geoidTiledTerrainProvider] Tiled elevation provider describing an Earth Gravitational Model. If defined, geometry will be shifted based on the offsets given by this provider. Required to position I3S data sets with gravity-related height at the correct location.\n * @property {Cesium3DTileset.ConstructorOptions} [cesium3dTilesetOptions] Object containing options to pass to an internally created {@link Cesium3DTileset}. See {@link Cesium3DTileset} for list of valid properties. All options can be used with the exception of <code>url</code> and <code>show</code> which are overridden by values from I3SDataProvider.\n * @property {boolean} [showFeatures=false] Determines if the features will be shown.\n * @property {boolean} [adjustMaterialAlphaMode=false] The option to adjust the alpha mode of the material based on the transparency of the vertex color. When <code>true</code>, the alpha mode of the material (if not defined) will be set to BLEND for geometry with any transparency in the color vertex attribute.\n * @property {boolean} [applySymbology=false] Determines if the I3S symbology will be parsed and applied for the layers.\n * @property {boolean} [calculateNormals=false] Determines if the flat normals will be generated for I3S geometry without normals.\n *\n * @example\n * // Increase LOD by reducing SSE\n * const cesium3dTilesetOptions = {\n *   maximumScreenSpaceError: 1,\n * };\n * const i3sOptions = {\n *   cesium3dTilesetOptions: cesium3dTilesetOptions,\n * };\n *\n * @example\n * // Set a custom outline color to replace the color defined in I3S symbology\n * const cesium3dTilesetOptions = {\n *   outlineColor: Cesium.Color.BLUE,\n * };\n * const i3sOptions = {\n *   cesium3dTilesetOptions: cesium3dTilesetOptions,\n *   applySymbology: true,\n * };\n */\n\n/**\n * An I3SDataProvider is the main public class for I3S support. The url option\n * should return a scene object. Currently supported I3S versions are 1.6 and\n * 1.7/1.8 (OGC I3S 1.2). I3SFeature and I3SNode classes implement the\n * Object Model for I3S entities, with public interfaces.\n *\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link I3SDataProvider.fromUrl}.\n * </div>\n *\n * @alias I3SDataProvider\n * @constructor\n *\n * @param {I3SDataProvider.ConstructorOptions} options An object describing initialization options\n *\n * @see I3SDataProvider.fromUrl\n * @see ArcGISTiledElevationTerrainProvider\n *\n * @example\n * try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n * @example\n * try {\n *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\"\n *   );\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\", {\n *       geoidTiledTerrainProvider: geoidService\n *   });\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n */\nfunction I3SDataProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // All public configuration is defined as ES5 properties\n  // These are just the \"private\" variables and their defaults.\n  this._name = options.name;\n  this._show = defaultValue(options.show, true);\n  this._geoidTiledTerrainProvider = options.geoidTiledTerrainProvider;\n  this._showFeatures = defaultValue(options.showFeatures, false);\n  this._adjustMaterialAlphaMode = defaultValue(options.adjustMaterialAlphaMode, false);\n  this._applySymbology = defaultValue(options.applySymbology, false);\n  this._calculateNormals = defaultValue(options.calculateNormals, false);\n  this._cesium3dTilesetOptions = defaultValue(options.cesium3dTilesetOptions, defaultValue.EMPTY_OBJECT);\n  this._layers = [];\n  this._sublayers = [];\n  this._data = undefined;\n  this._extent = undefined;\n  this._geoidDataPromise = undefined;\n  this._geoidDataList = undefined;\n  this._decoderTaskProcessor = undefined;\n  this._taskProcessorReadyPromise = undefined;\n  this._attributeStatistics = [];\n  this._layersExtent = [];\n}\nObject.defineProperties(I3SDataProvider.prototype, {\n  /**\n   * Gets a human-readable name for this dataset.\n   * @memberof I3SDataProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * Determines if the dataset will be shown.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n        for (let i = 0; i < this._layers.length; i++) {\n          this._layers[i]._updateVisibility();\n        }\n      }\n    }\n  },\n  /**\n   * The terrain provider referencing the GEOID service to be used for orthometric to ellipsoidal conversion.\n   * @memberof I3SDataProvider.prototype\n   * @type {ArcGISTiledElevationTerrainProvider}\n   * @readonly\n   */\n  geoidTiledTerrainProvider: {\n    get: function () {\n      return this._geoidTiledTerrainProvider;\n    }\n  },\n  /**\n   * Gets the collection of layers.\n   * @memberof I3SDataProvider.prototype\n   * @type {I3SLayer[]}\n   * @readonly\n   */\n  layers: {\n    get: function () {\n      return this._layers;\n    }\n  },\n  /**\n   * Gets the collection of building sublayers.\n   * @memberof I3SDataProvider.prototype\n   * @type {I3SSublayer[]}\n   * @readonly\n   */\n  sublayers: {\n    get: function () {\n      return this._sublayers;\n    }\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SDataProvider.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    }\n  },\n  /**\n   * Gets the extent covered by this I3S.\n   * @memberof I3SDataProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  extent: {\n    get: function () {\n      return this._extent;\n    }\n  },\n  /**\n   * The resource used to fetch the I3S dataset.\n   * @memberof I3SDataProvider.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    }\n  },\n  /**\n   * Determines if the features will be shown.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  showFeatures: {\n    get: function () {\n      return this._showFeatures;\n    }\n  },\n  /**\n   * Determines if the alpha mode of the material will be adjusted depending on the color vertex attribute.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  adjustMaterialAlphaMode: {\n    get: function () {\n      return this._adjustMaterialAlphaMode;\n    }\n  },\n  /**\n   * Determines if the I3S symbology will be parsed and applied for the layers.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  applySymbology: {\n    get: function () {\n      return this._applySymbology;\n    }\n  },\n  /**\n   * Determines if the flat normals will be generated for I3S geometry without normals.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  calculateNormals: {\n    get: function () {\n      return this._calculateNormals;\n    }\n  }\n});\n\n/**\n * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see I3SDataProvider#isDestroyed\n */\nI3SDataProvider.prototype.destroy = function () {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.destroy();\n    }\n  }\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see I3SDataProvider#destroy\n */\nI3SDataProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.update = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.update(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.prePassesUpdate = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.prePassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.postPassesUpdate = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.postPassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.updateForPass = function (frameState, passState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.updateForPass(frameState, passState);\n    }\n  }\n};\nfunction buildLayerUrl(provider, layerId) {\n  const dataProviderUrl = provider.resource.getUrlComponent();\n  let layerUrl = \"\";\n  if (dataProviderUrl.match(/layers\\/\\d/)) {\n    layerUrl = `${dataProviderUrl}`.replace(/\\/+$/, \"\");\n  } else {\n    // Add '/' to url if needed + `$layers/${layerId}/` if tilesetUrl not already in ../layers/[id] format\n    layerUrl = `${dataProviderUrl}`.replace(/\\/?$/, \"/\").concat(`layers/${layerId}`);\n  }\n  return layerUrl;\n}\nasync function addLayers(provider, data, options) {\n  if (data.layerType === \"Building\") {\n    if (!defined(options.showFeatures)) {\n      // The Building Scene Layer requires features to be shown to support filtering\n      provider._showFeatures = true;\n    }\n    if (!defined(options.adjustMaterialAlphaMode)) {\n      // The Building Scene Layer enables transparency by default\n      provider._adjustMaterialAlphaMode = true;\n    }\n    if (!defined(options.applySymbology)) {\n      // The Building Scene Layer applies symbology by default\n      provider._applySymbology = true;\n    }\n    if (!defined(options.calculateNormals)) {\n      // The Building Scene Layer calculates flat normals by default\n      provider._calculateNormals = true;\n    }\n    const buildingLayerUrl = buildLayerUrl(provider, data.id);\n    if (defined(data.sublayers)) {\n      const promises = [];\n      for (let i = 0; i < data.sublayers.length; i++) {\n        const promise = I3SSublayer._fromData(provider, buildingLayerUrl, data.sublayers[i], provider);\n        promises.push(promise);\n      }\n      const sublayers = await Promise.all(promises);\n      for (let i = 0; i < sublayers.length; i++) {\n        const sublayer = sublayers[i];\n        provider._sublayers.push(sublayer);\n        provider._layers.push(...sublayer._i3sLayers);\n      }\n    }\n    if (defined(data.statisticsHRef)) {\n      const uri = buildingLayerUrl.concat(`/${data.statisticsHRef}`);\n      const statistics = new I3SStatistics(provider, uri);\n      await statistics.load();\n      provider._attributeStatistics.push(statistics);\n    }\n    if (defined(data.fullExtent)) {\n      const extent = Rectangle.fromDegrees(data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax);\n      provider._layersExtent.push(extent);\n    }\n  } else if (data.layerType === \"3DObject\" || data.layerType === \"IntegratedMesh\") {\n    if (!defined(options.calculateNormals) && !defined(data.textureSetDefinitions)) {\n      // I3S Layers without textures should calculate flat normals by default\n      provider._calculateNormals = true;\n    }\n    const newLayer = new I3SLayer(provider, data, provider);\n    provider._layers.push(newLayer);\n    if (defined(newLayer._extent)) {\n      provider._layersExtent.push(newLayer._extent);\n    }\n  } else {\n    // Filter other scene layer types out\n    console.log(`${data.layerType} layer ${data.name} is skipped as not supported.`);\n  }\n}\n\n/**\n * Creates an I3SDataProvider. Currently supported I3S versions are 1.6 and\n * 1.7/1.8 (OGC I3S 1.2).\n *\n * @param {string|Resource} url The url of the I3S dataset, which should return an I3S scene object\n * @param {I3SDataProvider.ConstructorOptions} options An object describing initialization options\n * @returns {Promise<I3SDataProvider>}\n *\n * @example\n * try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n * @example\n * try {\n *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\"\n *   );\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\", {\n *       geoidTiledTerrainProvider: geoidService\n *   });\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n */\nI3SDataProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resource = Resource.createIfNeeded(url);\n  // Set a query parameter for json to avoid failure on html pages\n  resource.setQueryParameters({\n    f: \"pjson\"\n  }, true);\n  const data = await I3SDataProvider.loadJson(resource);\n  const provider = new I3SDataProvider(options);\n  provider._resource = resource;\n  provider._data = data;\n\n  // Success\n  if (defined(data.layers)) {\n    const promises = [];\n    for (let layerIndex = 0; layerIndex < data.layers.length; layerIndex++) {\n      const promise = addLayers(provider, data.layers[layerIndex], options);\n      promises.push(promise);\n    }\n    await Promise.all(promises);\n  } else {\n    await addLayers(provider, data, options);\n  }\n  provider._computeExtent();\n\n  // Start loading all of the tiles\n  const layerPromises = [];\n  for (let i = 0; i < provider._layers.length; i++) {\n    layerPromises.push(provider._layers[i].load(options.cesium3dTilesetOptions));\n  }\n  await Promise.all(layerPromises);\n  return provider;\n};\n\n/**\n * @private\n */\nI3SDataProvider._fetchJson = function (resource) {\n  return resource.fetchJson();\n};\n\n/**\n * @private\n *\n * @param {Resource} resource The JSON resource to request\n * @returns {Promise<object>} The fetched data\n */\nI3SDataProvider.loadJson = async function (resource) {\n  const data = await I3SDataProvider._fetchJson(resource);\n  if (defined(data.error)) {\n    console.error(\"Failed to fetch I3S \", resource.url);\n    if (defined(data.error.message)) {\n      console.error(data.error.message);\n    }\n    if (defined(data.error.details)) {\n      for (let i = 0; i < data.error.details.length; i++) {\n        console.log(data.error.details[i]);\n      }\n    }\n    throw new RuntimeError(data.error);\n  }\n  return data;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._loadBinary = async function (resource) {\n  const buffer = await resource.fetchArrayBuffer();\n  if (buffer.byteLength > 0) {\n    // Check if we have a JSON response with 404\n    const array = new Uint8Array(buffer);\n    if (array[0] === \"{\".charCodeAt(0)) {\n      const textContent = new TextDecoder();\n      const str = textContent.decode(buffer);\n      if (str.includes(\"404\")) {\n        throw new RuntimeError(`Failed to load binary: ${resource.url}`);\n      }\n    }\n  }\n  return buffer;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._binarizeGltf = function (rawGltf) {\n  const encoder = new TextEncoder();\n  const rawGltfData = encoder.encode(JSON.stringify(rawGltf));\n  const binaryGltfData = new Uint8Array(rawGltfData.byteLength + 20);\n  const binaryGltf = {\n    magic: new Uint8Array(binaryGltfData.buffer, 0, 4),\n    version: new Uint32Array(binaryGltfData.buffer, 4, 1),\n    length: new Uint32Array(binaryGltfData.buffer, 8, 1),\n    chunkLength: new Uint32Array(binaryGltfData.buffer, 12, 1),\n    chunkType: new Uint32Array(binaryGltfData.buffer, 16, 1),\n    chunkData: new Uint8Array(binaryGltfData.buffer, 20, rawGltfData.byteLength)\n  };\n  binaryGltf.magic[0] = \"g\".charCodeAt();\n  binaryGltf.magic[1] = \"l\".charCodeAt();\n  binaryGltf.magic[2] = \"T\".charCodeAt();\n  binaryGltf.magic[3] = \"F\".charCodeAt();\n  binaryGltf.version[0] = 2;\n  binaryGltf.length[0] = binaryGltfData.byteLength;\n  binaryGltf.chunkLength[0] = rawGltfData.byteLength;\n  binaryGltf.chunkType[0] = 0x4e4f534a; // JSON\n  binaryGltf.chunkData.set(rawGltfData);\n  return binaryGltfData;\n};\nconst scratchCartesian2 = new Cartesian2();\nfunction getCoveredTiles(terrainProvider, extent) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  // Sort points into a set of tiles\n  const tileRequests = []; // Result will be an Array as it's easier to work with\n  const tileRequestSet = {}; // A unique set\n\n  const maxLevel = terrainProvider._lodCount;\n  const topLeftCorner = Cartographic.fromRadians(extent.west, extent.north);\n  const bottomRightCorner = Cartographic.fromRadians(extent.east, extent.south);\n  const minCornerXY = tilingScheme.positionToTileXY(topLeftCorner, maxLevel);\n  const maxCornerXY = tilingScheme.positionToTileXY(bottomRightCorner, maxLevel);\n\n  // Get all the tiles in between\n  for (let x = minCornerXY.x; x <= maxCornerXY.x; x++) {\n    for (let y = minCornerXY.y; y <= maxCornerXY.y; y++) {\n      const xy = Cartesian2.fromElements(x, y, scratchCartesian2);\n      const key = xy.toString();\n      if (!tileRequestSet.hasOwnProperty(key)) {\n        // When tile is requested for the first time\n        const value = {\n          x: xy.x,\n          y: xy.y,\n          level: maxLevel,\n          tilingScheme: tilingScheme,\n          terrainProvider: terrainProvider,\n          positions: []\n        };\n        tileRequestSet[key] = value;\n        tileRequests.push(value);\n      }\n    }\n  }\n\n  // Send request for each required tile\n  const tilePromises = [];\n  for (let i = 0; i < tileRequests.length; ++i) {\n    const tileRequest = tileRequests[i];\n    const requestPromise = tileRequest.terrainProvider.requestTileGeometry(tileRequest.x, tileRequest.y, tileRequest.level);\n    tilePromises.push(requestPromise);\n  }\n  return Promise.all(tilePromises).then(function (heightMapBuffers) {\n    const heightMaps = [];\n    for (let i = 0; i < heightMapBuffers.length; i++) {\n      const options = {\n        tilingScheme: tilingScheme,\n        x: tileRequests[i].x,\n        y: tileRequests[i].y,\n        level: tileRequests[i].level\n      };\n      const heightMap = heightMapBuffers[i];\n      let projectionType = \"Geographic\";\n      if (tilingScheme._projection instanceof WebMercatorProjection) {\n        projectionType = \"WebMercator\";\n      }\n      const heightMapData = {\n        projectionType: projectionType,\n        projection: tilingScheme._projection,\n        nativeExtent: tilingScheme.tileXYToNativeRectangle(options.x, options.y, options.level),\n        height: heightMap._height,\n        width: heightMap._width,\n        scale: heightMap._structure.heightScale,\n        offset: heightMap._structure.heightOffset\n      };\n      if (heightMap._encoding === HeightmapEncoding.LERC) {\n        const result = Lerc.decode(heightMap._buffer);\n        heightMapData.buffer = result.pixels[0];\n      } else {\n        heightMapData.buffer = heightMap._buffer;\n      }\n      heightMaps.push(heightMapData);\n    }\n    return heightMaps;\n  });\n}\nasync function loadGeoidData(provider) {\n  // Load tiles from arcgis\n  const geoidTerrainProvider = provider._geoidTiledTerrainProvider;\n  if (!defined(geoidTerrainProvider)) {\n    return;\n  }\n  try {\n    const heightMaps = await getCoveredTiles(geoidTerrainProvider, provider._extent);\n    provider._geoidDataList = heightMaps;\n  } catch (error) {\n    console.log(\"Error retrieving Geoid Terrain tiles - no geoid conversion will be performed.\");\n  }\n}\n\n/**\n * @private\n */\nI3SDataProvider.prototype.loadGeoidData = async function () {\n  if (defined(this._geoidDataPromise)) {\n    return this._geoidDataPromise;\n  }\n  this._geoidDataPromise = loadGeoidData(this);\n  return this._geoidDataPromise;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._computeExtent = function () {\n  let rectangle;\n\n  // Compute the extent from all layers\n  for (let layerIndex = 0; layerIndex < this._layersExtent.length; layerIndex++) {\n    const layerExtent = this._layersExtent[layerIndex];\n    if (!defined(rectangle)) {\n      rectangle = Rectangle.clone(layerExtent);\n    } else {\n      Rectangle.union(rectangle, layerExtent, rectangle);\n    }\n  }\n  this._extent = rectangle;\n};\n\n/**\n * Returns the collection of names for all available attributes\n * @returns {string[]} The collection of attribute names\n */\nI3SDataProvider.prototype.getAttributeNames = function () {\n  const attributes = [];\n  for (let i = 0; i < this._attributeStatistics.length; ++i) {\n    attributes.push(...this._attributeStatistics[i].names);\n  }\n  return attributes;\n};\n\n/**\n * Returns the collection of values for the attribute with the given name\n * @param {string} name The attribute name\n * @returns {string[]} The collection of attribute values\n */\nI3SDataProvider.prototype.getAttributeValues = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"name\", name);\n  //>>includeEnd('debug');\n\n  for (let i = 0; i < this._attributeStatistics.length; ++i) {\n    const values = this._attributeStatistics[i]._getValues(name);\n    if (defined(values)) {\n      return values;\n    }\n  }\n  return [];\n};\n\n/**\n * Filters the drawn elements of a scene to specific attribute names and values\n * @param {I3SNode.AttributeFilter[]} [filters=[]] The collection of attribute filters\n * @returns {Promise<void>} A promise that is resolved when the filter is applied\n */\nI3SDataProvider.prototype.filterByAttributes = function (filters) {\n  const promises = [];\n  for (let i = 0; i < this._layers.length; i++) {\n    const promise = this._layers[i].filterByAttributes(filters);\n    promises.push(promise);\n  }\n  return Promise.all(promises);\n};\nexport default I3SDataProvider;","map":{"version":3,"names":["Cartesian2","Cartographic","Check","defaultValue","defined","destroyObject","HeightmapEncoding","Resource","RuntimeError","WebMercatorProjection","I3SLayer","I3SStatistics","I3SSublayer","Lerc","Rectangle","I3SDataProvider","options","EMPTY_OBJECT","_name","name","_show","show","_geoidTiledTerrainProvider","geoidTiledTerrainProvider","_showFeatures","showFeatures","_adjustMaterialAlphaMode","adjustMaterialAlphaMode","_applySymbology","applySymbology","_calculateNormals","calculateNormals","_cesium3dTilesetOptions","cesium3dTilesetOptions","_layers","_sublayers","_data","undefined","_extent","_geoidDataPromise","_geoidDataList","_decoderTaskProcessor","_taskProcessorReadyPromise","_attributeStatistics","_layersExtent","Object","defineProperties","prototype","get","set","value","i","length","_updateVisibility","layers","sublayers","data","extent","resource","_resource","destroy","_tileset","isDestroyed","update","frameState","prePassesUpdate","postPassesUpdate","updateForPass","passState","buildLayerUrl","provider","layerId","dataProviderUrl","getUrlComponent","layerUrl","match","replace","concat","addLayers","layerType","buildingLayerUrl","id","promises","promise","_fromData","push","Promise","all","sublayer","_i3sLayers","statisticsHRef","uri","statistics","load","fullExtent","fromDegrees","xmin","ymin","xmax","ymax","textureSetDefinitions","newLayer","console","log","fromUrl","url","createIfNeeded","setQueryParameters","f","loadJson","layerIndex","_computeExtent","layerPromises","_fetchJson","fetchJson","error","message","details","_loadBinary","buffer","fetchArrayBuffer","byteLength","array","Uint8Array","charCodeAt","textContent","TextDecoder","str","decode","includes","_binarizeGltf","rawGltf","encoder","TextEncoder","rawGltfData","encode","JSON","stringify","binaryGltfData","binaryGltf","magic","version","Uint32Array","chunkLength","chunkType","chunkData","scratchCartesian2","getCoveredTiles","terrainProvider","tilingScheme","tileRequests","tileRequestSet","maxLevel","_lodCount","topLeftCorner","fromRadians","west","north","bottomRightCorner","east","south","minCornerXY","positionToTileXY","maxCornerXY","x","y","xy","fromElements","key","toString","hasOwnProperty","level","positions","tilePromises","tileRequest","requestPromise","requestTileGeometry","then","heightMapBuffers","heightMaps","heightMap","projectionType","_projection","heightMapData","projection","nativeExtent","tileXYToNativeRectangle","height","_height","width","_width","scale","_structure","heightScale","offset","heightOffset","_encoding","LERC","result","_buffer","pixels","loadGeoidData","geoidTerrainProvider","rectangle","layerExtent","clone","union","getAttributeNames","attributes","names","getAttributeValues","values","_getValues","filterByAttributes","filters"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/I3SDataProvider.js"],"sourcesContent":["/*\n * Esri Contribution: This code implements support for I3S (Indexed 3D Scene Layers), an OGC Community Standard.\n * Co-authored-by: Alexandre Jean-Claude ajeanclaude@spiria.com\n * Co-authored-by: Anthony Mirabeau anthony.mirabeau@presagis.com\n * Co-authored-by: Elizabeth Rudkin elizabeth.rudkin@presagis.com\n * Co-authored-by: Tamrat Belayneh tbelayneh@esri.com\n *\n * The I3S format has been developed by Esri and is shared under an Apache 2.0 license and is maintained @ https://github.com/Esri/i3s-spec.\n * This implementation supports loading, displaying, and querying an I3S layer (supported versions include Esri github I3S versions 1.6, 1.7/1.8 -\n * whose OGC equivalent are I3S Community Standard Version 1.1 & 1.2) in the CesiumJS viewer.\n * It enables the user to access an I3S layer via its URL and load it inside of the CesiumJS viewer.\n *\n * When a scene layer is initialized it accomplishes the following:\n *\n * It processes the 3D Scene Layer resource (https://github.com/Esri/i3s-spec/blob/master/docs/1.8/3DSceneLayer.cmn.md) of an I3S dataset\n * and loads the layers data. It does so by creating a Cesium 3D Tileset for the given i3s layer and loads the root node.\n * When the root node is imported, it creates a Cesium 3D Tile that is parented to the Cesium 3D Tileset\n * and loads all children of the root node:\n *  for each children\n *   Create a place holder 3D tile so that the LOD display can use the nodes' selection criteria (maximumScreenSpaceError) to select the appropriate node\n *   based on the current LOD display & evaluation. If the Cesium 3D tile is visible, it invokes requestContent on it.\n *   At that moment, we intercept the call to requestContent, and we load the geometry in I3S format\n *   That geometry is transcoded on the fly to glTF format and ingested by CesiumJS\n *   When the geometry is loaded, we then load all children of this node as placeholders so that the LOD\n *   can know about them too.\n *\n * About transcoding:\n *\n * We use web workers to transcode I3S geometries into glTF\n * The steps are:\n *\n * Decode geometry attributes (positions, normals, etc..) either from DRACO or Binary format.\n * If requested, when creating an I3SDataProvider the user has the option to specify a tiled elevation terrain provider\n * (geoidTiledTerrainProvider) such as the one shown in the sandcastle example based on ArcGISTiledElevationTerrainProvider, that allows\n * conversion of heights for all vertices & bounding boxes of an I3S layer from (typically) gravity related (Orthometric) heights to Ellipsoidal.\n * This step is essential when fusing data with varying height sources (as is the case when fusing the I3S dataset (gravity related) in the sandcastle examples with the cesium world terrain (ellipsoidal)).\n * We then transform vertex coordinates from LONG/LAT/HEIGHT to Cartesian in local space and\n * scale appropriately if specified in the attribute metadata\n * Crop UVs if UV regions are defined in the attribute metadata\n * Create a glTF document in memory that will be ingested as part of a glb payload\n *\n * About GEOID data:\n *\n * We provide the ability to use GEOID data to convert heights from gravity related (orthometric) height systems to ellipsoidal.\n * We employ a service architecture to get the conversion factor for a given long lat values, leveraging existing implementation based on ArcGISTiledElevationTerrainProvider\n * to avoid requiring bloated look up files. The source Data used in this transcoding service was compiled from https://earth-info.nga.mil/#tab_wgs84-data and is based on\n * EGM2008 Gravity Model. The sandcastle examples show how to set the terrain provider service if required.\n */\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport HeightmapEncoding from \"../Core/HeightmapEncoding.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport I3SLayer from \"./I3SLayer.js\";\nimport I3SStatistics from \"./I3SStatistics.js\";\nimport I3SSublayer from \"./I3SSublayer.js\";\nimport Lerc from \"lerc\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * @typedef {Object} I3SDataProvider.ConstructorOptions\n *\n * Initialization options for the I3SDataProvider constructor\n *\n * @property {string} [name] The name of the I3S dataset.\n * @property {boolean} [show=true] Determines if the dataset will be shown.\n * @property {ArcGISTiledElevationTerrainProvider|Promise<ArcGISTiledElevationTerrainProvider>} [geoidTiledTerrainProvider] Tiled elevation provider describing an Earth Gravitational Model. If defined, geometry will be shifted based on the offsets given by this provider. Required to position I3S data sets with gravity-related height at the correct location.\n * @property {Cesium3DTileset.ConstructorOptions} [cesium3dTilesetOptions] Object containing options to pass to an internally created {@link Cesium3DTileset}. See {@link Cesium3DTileset} for list of valid properties. All options can be used with the exception of <code>url</code> and <code>show</code> which are overridden by values from I3SDataProvider.\n * @property {boolean} [showFeatures=false] Determines if the features will be shown.\n * @property {boolean} [adjustMaterialAlphaMode=false] The option to adjust the alpha mode of the material based on the transparency of the vertex color. When <code>true</code>, the alpha mode of the material (if not defined) will be set to BLEND for geometry with any transparency in the color vertex attribute.\n * @property {boolean} [applySymbology=false] Determines if the I3S symbology will be parsed and applied for the layers.\n * @property {boolean} [calculateNormals=false] Determines if the flat normals will be generated for I3S geometry without normals.\n *\n * @example\n * // Increase LOD by reducing SSE\n * const cesium3dTilesetOptions = {\n *   maximumScreenSpaceError: 1,\n * };\n * const i3sOptions = {\n *   cesium3dTilesetOptions: cesium3dTilesetOptions,\n * };\n *\n * @example\n * // Set a custom outline color to replace the color defined in I3S symbology\n * const cesium3dTilesetOptions = {\n *   outlineColor: Cesium.Color.BLUE,\n * };\n * const i3sOptions = {\n *   cesium3dTilesetOptions: cesium3dTilesetOptions,\n *   applySymbology: true,\n * };\n */\n\n/**\n * An I3SDataProvider is the main public class for I3S support. The url option\n * should return a scene object. Currently supported I3S versions are 1.6 and\n * 1.7/1.8 (OGC I3S 1.2). I3SFeature and I3SNode classes implement the\n * Object Model for I3S entities, with public interfaces.\n *\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link I3SDataProvider.fromUrl}.\n * </div>\n *\n * @alias I3SDataProvider\n * @constructor\n *\n * @param {I3SDataProvider.ConstructorOptions} options An object describing initialization options\n *\n * @see I3SDataProvider.fromUrl\n * @see ArcGISTiledElevationTerrainProvider\n *\n * @example\n * try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n * @example\n * try {\n *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\"\n *   );\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\", {\n *       geoidTiledTerrainProvider: geoidService\n *   });\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n */\nfunction I3SDataProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // All public configuration is defined as ES5 properties\n  // These are just the \"private\" variables and their defaults.\n  this._name = options.name;\n  this._show = defaultValue(options.show, true);\n  this._geoidTiledTerrainProvider = options.geoidTiledTerrainProvider;\n  this._showFeatures = defaultValue(options.showFeatures, false);\n  this._adjustMaterialAlphaMode = defaultValue(\n    options.adjustMaterialAlphaMode,\n    false,\n  );\n  this._applySymbology = defaultValue(options.applySymbology, false);\n  this._calculateNormals = defaultValue(options.calculateNormals, false);\n\n  this._cesium3dTilesetOptions = defaultValue(\n    options.cesium3dTilesetOptions,\n    defaultValue.EMPTY_OBJECT,\n  );\n\n  this._layers = [];\n  this._sublayers = [];\n  this._data = undefined;\n  this._extent = undefined;\n  this._geoidDataPromise = undefined;\n  this._geoidDataList = undefined;\n  this._decoderTaskProcessor = undefined;\n  this._taskProcessorReadyPromise = undefined;\n  this._attributeStatistics = [];\n  this._layersExtent = [];\n}\n\nObject.defineProperties(I3SDataProvider.prototype, {\n  /**\n   * Gets a human-readable name for this dataset.\n   * @memberof I3SDataProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * Determines if the dataset will be shown.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n        for (let i = 0; i < this._layers.length; i++) {\n          this._layers[i]._updateVisibility();\n        }\n      }\n    },\n  },\n\n  /**\n   * The terrain provider referencing the GEOID service to be used for orthometric to ellipsoidal conversion.\n   * @memberof I3SDataProvider.prototype\n   * @type {ArcGISTiledElevationTerrainProvider}\n   * @readonly\n   */\n  geoidTiledTerrainProvider: {\n    get: function () {\n      return this._geoidTiledTerrainProvider;\n    },\n  },\n\n  /**\n   * Gets the collection of layers.\n   * @memberof I3SDataProvider.prototype\n   * @type {I3SLayer[]}\n   * @readonly\n   */\n  layers: {\n    get: function () {\n      return this._layers;\n    },\n  },\n\n  /**\n   * Gets the collection of building sublayers.\n   * @memberof I3SDataProvider.prototype\n   * @type {I3SSublayer[]}\n   * @readonly\n   */\n  sublayers: {\n    get: function () {\n      return this._sublayers;\n    },\n  },\n\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SDataProvider.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n\n  /**\n   * Gets the extent covered by this I3S.\n   * @memberof I3SDataProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  extent: {\n    get: function () {\n      return this._extent;\n    },\n  },\n\n  /**\n   * The resource used to fetch the I3S dataset.\n   * @memberof I3SDataProvider.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n\n  /**\n   * Determines if the features will be shown.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  showFeatures: {\n    get: function () {\n      return this._showFeatures;\n    },\n  },\n\n  /**\n   * Determines if the alpha mode of the material will be adjusted depending on the color vertex attribute.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  adjustMaterialAlphaMode: {\n    get: function () {\n      return this._adjustMaterialAlphaMode;\n    },\n  },\n\n  /**\n   * Determines if the I3S symbology will be parsed and applied for the layers.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  applySymbology: {\n    get: function () {\n      return this._applySymbology;\n    },\n  },\n\n  /**\n   * Determines if the flat normals will be generated for I3S geometry without normals.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  calculateNormals: {\n    get: function () {\n      return this._calculateNormals;\n    },\n  },\n});\n\n/**\n * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see I3SDataProvider#isDestroyed\n */\nI3SDataProvider.prototype.destroy = function () {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see I3SDataProvider#destroy\n */\nI3SDataProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.update = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.update(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.prePassesUpdate = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.prePassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.postPassesUpdate = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.postPassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.updateForPass = function (frameState, passState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.updateForPass(frameState, passState);\n    }\n  }\n};\n\nfunction buildLayerUrl(provider, layerId) {\n  const dataProviderUrl = provider.resource.getUrlComponent();\n\n  let layerUrl = \"\";\n  if (dataProviderUrl.match(/layers\\/\\d/)) {\n    layerUrl = `${dataProviderUrl}`.replace(/\\/+$/, \"\");\n  } else {\n    // Add '/' to url if needed + `$layers/${layerId}/` if tilesetUrl not already in ../layers/[id] format\n    layerUrl = `${dataProviderUrl}`\n      .replace(/\\/?$/, \"/\")\n      .concat(`layers/${layerId}`);\n  }\n  return layerUrl;\n}\n\nasync function addLayers(provider, data, options) {\n  if (data.layerType === \"Building\") {\n    if (!defined(options.showFeatures)) {\n      // The Building Scene Layer requires features to be shown to support filtering\n      provider._showFeatures = true;\n    }\n    if (!defined(options.adjustMaterialAlphaMode)) {\n      // The Building Scene Layer enables transparency by default\n      provider._adjustMaterialAlphaMode = true;\n    }\n    if (!defined(options.applySymbology)) {\n      // The Building Scene Layer applies symbology by default\n      provider._applySymbology = true;\n    }\n    if (!defined(options.calculateNormals)) {\n      // The Building Scene Layer calculates flat normals by default\n      provider._calculateNormals = true;\n    }\n\n    const buildingLayerUrl = buildLayerUrl(provider, data.id);\n    if (defined(data.sublayers)) {\n      const promises = [];\n      for (let i = 0; i < data.sublayers.length; i++) {\n        const promise = I3SSublayer._fromData(\n          provider,\n          buildingLayerUrl,\n          data.sublayers[i],\n          provider,\n        );\n        promises.push(promise);\n      }\n      const sublayers = await Promise.all(promises);\n      for (let i = 0; i < sublayers.length; i++) {\n        const sublayer = sublayers[i];\n        provider._sublayers.push(sublayer);\n        provider._layers.push(...sublayer._i3sLayers);\n      }\n    }\n\n    if (defined(data.statisticsHRef)) {\n      const uri = buildingLayerUrl.concat(`/${data.statisticsHRef}`);\n      const statistics = new I3SStatistics(provider, uri);\n      await statistics.load();\n      provider._attributeStatistics.push(statistics);\n    }\n\n    if (defined(data.fullExtent)) {\n      const extent = Rectangle.fromDegrees(\n        data.fullExtent.xmin,\n        data.fullExtent.ymin,\n        data.fullExtent.xmax,\n        data.fullExtent.ymax,\n      );\n      provider._layersExtent.push(extent);\n    }\n  } else if (\n    data.layerType === \"3DObject\" ||\n    data.layerType === \"IntegratedMesh\"\n  ) {\n    if (\n      !defined(options.calculateNormals) &&\n      !defined(data.textureSetDefinitions)\n    ) {\n      // I3S Layers without textures should calculate flat normals by default\n      provider._calculateNormals = true;\n    }\n\n    const newLayer = new I3SLayer(provider, data, provider);\n    provider._layers.push(newLayer);\n    if (defined(newLayer._extent)) {\n      provider._layersExtent.push(newLayer._extent);\n    }\n  } else {\n    // Filter other scene layer types out\n    console.log(\n      `${data.layerType} layer ${data.name} is skipped as not supported.`,\n    );\n  }\n}\n\n/**\n * Creates an I3SDataProvider. Currently supported I3S versions are 1.6 and\n * 1.7/1.8 (OGC I3S 1.2).\n *\n * @param {string|Resource} url The url of the I3S dataset, which should return an I3S scene object\n * @param {I3SDataProvider.ConstructorOptions} options An object describing initialization options\n * @returns {Promise<I3SDataProvider>}\n *\n * @example\n * try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n * @example\n * try {\n *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\"\n *   );\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\", {\n *       geoidTiledTerrainProvider: geoidService\n *   });\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n */\nI3SDataProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const resource = Resource.createIfNeeded(url);\n  // Set a query parameter for json to avoid failure on html pages\n  resource.setQueryParameters({ f: \"pjson\" }, true);\n  const data = await I3SDataProvider.loadJson(resource);\n\n  const provider = new I3SDataProvider(options);\n  provider._resource = resource;\n  provider._data = data;\n\n  // Success\n  if (defined(data.layers)) {\n    const promises = [];\n    for (let layerIndex = 0; layerIndex < data.layers.length; layerIndex++) {\n      const promise = addLayers(provider, data.layers[layerIndex], options);\n      promises.push(promise);\n    }\n    await Promise.all(promises);\n  } else {\n    await addLayers(provider, data, options);\n  }\n\n  provider._computeExtent();\n\n  // Start loading all of the tiles\n  const layerPromises = [];\n  for (let i = 0; i < provider._layers.length; i++) {\n    layerPromises.push(\n      provider._layers[i].load(options.cesium3dTilesetOptions),\n    );\n  }\n\n  await Promise.all(layerPromises);\n  return provider;\n};\n\n/**\n * @private\n */\nI3SDataProvider._fetchJson = function (resource) {\n  return resource.fetchJson();\n};\n\n/**\n * @private\n *\n * @param {Resource} resource The JSON resource to request\n * @returns {Promise<object>} The fetched data\n */\nI3SDataProvider.loadJson = async function (resource) {\n  const data = await I3SDataProvider._fetchJson(resource);\n  if (defined(data.error)) {\n    console.error(\"Failed to fetch I3S \", resource.url);\n    if (defined(data.error.message)) {\n      console.error(data.error.message);\n    }\n    if (defined(data.error.details)) {\n      for (let i = 0; i < data.error.details.length; i++) {\n        console.log(data.error.details[i]);\n      }\n    }\n\n    throw new RuntimeError(data.error);\n  }\n\n  return data;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._loadBinary = async function (resource) {\n  const buffer = await resource.fetchArrayBuffer();\n  if (buffer.byteLength > 0) {\n    // Check if we have a JSON response with 404\n    const array = new Uint8Array(buffer);\n    if (array[0] === \"{\".charCodeAt(0)) {\n      const textContent = new TextDecoder();\n      const str = textContent.decode(buffer);\n      if (str.includes(\"404\")) {\n        throw new RuntimeError(`Failed to load binary: ${resource.url}`);\n      }\n    }\n  }\n  return buffer;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._binarizeGltf = function (rawGltf) {\n  const encoder = new TextEncoder();\n  const rawGltfData = encoder.encode(JSON.stringify(rawGltf));\n  const binaryGltfData = new Uint8Array(rawGltfData.byteLength + 20);\n  const binaryGltf = {\n    magic: new Uint8Array(binaryGltfData.buffer, 0, 4),\n    version: new Uint32Array(binaryGltfData.buffer, 4, 1),\n    length: new Uint32Array(binaryGltfData.buffer, 8, 1),\n    chunkLength: new Uint32Array(binaryGltfData.buffer, 12, 1),\n    chunkType: new Uint32Array(binaryGltfData.buffer, 16, 1),\n    chunkData: new Uint8Array(\n      binaryGltfData.buffer,\n      20,\n      rawGltfData.byteLength,\n    ),\n  };\n\n  binaryGltf.magic[0] = \"g\".charCodeAt();\n  binaryGltf.magic[1] = \"l\".charCodeAt();\n  binaryGltf.magic[2] = \"T\".charCodeAt();\n  binaryGltf.magic[3] = \"F\".charCodeAt();\n\n  binaryGltf.version[0] = 2;\n  binaryGltf.length[0] = binaryGltfData.byteLength;\n  binaryGltf.chunkLength[0] = rawGltfData.byteLength;\n  binaryGltf.chunkType[0] = 0x4e4f534a; // JSON\n  binaryGltf.chunkData.set(rawGltfData);\n\n  return binaryGltfData;\n};\n\nconst scratchCartesian2 = new Cartesian2();\n\nfunction getCoveredTiles(terrainProvider, extent) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  // Sort points into a set of tiles\n  const tileRequests = []; // Result will be an Array as it's easier to work with\n  const tileRequestSet = {}; // A unique set\n\n  const maxLevel = terrainProvider._lodCount;\n\n  const topLeftCorner = Cartographic.fromRadians(extent.west, extent.north);\n  const bottomRightCorner = Cartographic.fromRadians(extent.east, extent.south);\n  const minCornerXY = tilingScheme.positionToTileXY(topLeftCorner, maxLevel);\n  const maxCornerXY = tilingScheme.positionToTileXY(\n    bottomRightCorner,\n    maxLevel,\n  );\n\n  // Get all the tiles in between\n  for (let x = minCornerXY.x; x <= maxCornerXY.x; x++) {\n    for (let y = minCornerXY.y; y <= maxCornerXY.y; y++) {\n      const xy = Cartesian2.fromElements(x, y, scratchCartesian2);\n      const key = xy.toString();\n      if (!tileRequestSet.hasOwnProperty(key)) {\n        // When tile is requested for the first time\n        const value = {\n          x: xy.x,\n          y: xy.y,\n          level: maxLevel,\n          tilingScheme: tilingScheme,\n          terrainProvider: terrainProvider,\n          positions: [],\n        };\n        tileRequestSet[key] = value;\n        tileRequests.push(value);\n      }\n    }\n  }\n\n  // Send request for each required tile\n  const tilePromises = [];\n  for (let i = 0; i < tileRequests.length; ++i) {\n    const tileRequest = tileRequests[i];\n    const requestPromise = tileRequest.terrainProvider.requestTileGeometry(\n      tileRequest.x,\n      tileRequest.y,\n      tileRequest.level,\n    );\n\n    tilePromises.push(requestPromise);\n  }\n\n  return Promise.all(tilePromises).then(function (heightMapBuffers) {\n    const heightMaps = [];\n    for (let i = 0; i < heightMapBuffers.length; i++) {\n      const options = {\n        tilingScheme: tilingScheme,\n        x: tileRequests[i].x,\n        y: tileRequests[i].y,\n        level: tileRequests[i].level,\n      };\n      const heightMap = heightMapBuffers[i];\n\n      let projectionType = \"Geographic\";\n      if (tilingScheme._projection instanceof WebMercatorProjection) {\n        projectionType = \"WebMercator\";\n      }\n\n      const heightMapData = {\n        projectionType: projectionType,\n        projection: tilingScheme._projection,\n        nativeExtent: tilingScheme.tileXYToNativeRectangle(\n          options.x,\n          options.y,\n          options.level,\n        ),\n        height: heightMap._height,\n        width: heightMap._width,\n        scale: heightMap._structure.heightScale,\n        offset: heightMap._structure.heightOffset,\n      };\n\n      if (heightMap._encoding === HeightmapEncoding.LERC) {\n        const result = Lerc.decode(heightMap._buffer);\n        heightMapData.buffer = result.pixels[0];\n      } else {\n        heightMapData.buffer = heightMap._buffer;\n      }\n\n      heightMaps.push(heightMapData);\n    }\n\n    return heightMaps;\n  });\n}\n\nasync function loadGeoidData(provider) {\n  // Load tiles from arcgis\n  const geoidTerrainProvider = provider._geoidTiledTerrainProvider;\n\n  if (!defined(geoidTerrainProvider)) {\n    return;\n  }\n\n  try {\n    const heightMaps = await getCoveredTiles(\n      geoidTerrainProvider,\n      provider._extent,\n    );\n    provider._geoidDataList = heightMaps;\n  } catch (error) {\n    console.log(\n      \"Error retrieving Geoid Terrain tiles - no geoid conversion will be performed.\",\n    );\n  }\n}\n\n/**\n * @private\n */\nI3SDataProvider.prototype.loadGeoidData = async function () {\n  if (defined(this._geoidDataPromise)) {\n    return this._geoidDataPromise;\n  }\n\n  this._geoidDataPromise = loadGeoidData(this);\n  return this._geoidDataPromise;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._computeExtent = function () {\n  let rectangle;\n\n  // Compute the extent from all layers\n  for (\n    let layerIndex = 0;\n    layerIndex < this._layersExtent.length;\n    layerIndex++\n  ) {\n    const layerExtent = this._layersExtent[layerIndex];\n    if (!defined(rectangle)) {\n      rectangle = Rectangle.clone(layerExtent);\n    } else {\n      Rectangle.union(rectangle, layerExtent, rectangle);\n    }\n  }\n\n  this._extent = rectangle;\n};\n\n/**\n * Returns the collection of names for all available attributes\n * @returns {string[]} The collection of attribute names\n */\nI3SDataProvider.prototype.getAttributeNames = function () {\n  const attributes = [];\n  for (let i = 0; i < this._attributeStatistics.length; ++i) {\n    attributes.push(...this._attributeStatistics[i].names);\n  }\n  return attributes;\n};\n\n/**\n * Returns the collection of values for the attribute with the given name\n * @param {string} name The attribute name\n * @returns {string[]} The collection of attribute values\n */\nI3SDataProvider.prototype.getAttributeValues = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"name\", name);\n  //>>includeEnd('debug');\n\n  for (let i = 0; i < this._attributeStatistics.length; ++i) {\n    const values = this._attributeStatistics[i]._getValues(name);\n    if (defined(values)) {\n      return values;\n    }\n  }\n  return [];\n};\n\n/**\n * Filters the drawn elements of a scene to specific attribute names and values\n * @param {I3SNode.AttributeFilter[]} [filters=[]] The collection of attribute filters\n * @returns {Promise<void>} A promise that is resolved when the filter is applied\n */\nI3SDataProvider.prototype.filterByAttributes = function (filters) {\n  const promises = [];\n  for (let i = 0; i < this._layers.length; i++) {\n    const promise = this._layers[i].filterByAttributes(filters);\n    promises.push(promise);\n  }\n  return Promise.all(promises);\n};\n\nexport default I3SDataProvider;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,IAAI,MAAM,MAAM;AACvB,OAAOC,SAAS,MAAM,sBAAsB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,OAAO,EAAE;EAChCA,OAAO,GAAGb,YAAY,CAACa,OAAO,EAAEb,YAAY,CAACc,YAAY,CAAC;;EAE1D;EACA;EACA,IAAI,CAACC,KAAK,GAAGF,OAAO,CAACG,IAAI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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}