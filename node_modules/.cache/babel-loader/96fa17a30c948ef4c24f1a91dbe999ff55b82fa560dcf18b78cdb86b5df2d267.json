{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CylinderGeometry from \"../Core/CylinderGeometry.js\";\nimport CylinderOutlineGeometry from \"../Core/CylinderOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport Property from \"./Property.js\";\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\nconst scratchColor = new Color();\nfunction CylinderGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.length = undefined;\n  this.topRadius = undefined;\n  this.bottomRadius = undefined;\n  this.slices = undefined;\n  this.numberOfVerticalLines = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for cylinders.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias CylinderGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction CylinderGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new CylinderGeometryOptions(entity),\n    geometryPropertyName: \"cylinder\",\n    observedPropertyNames: [\"availability\", \"position\", \"orientation\", \"cylinder\"]\n  });\n  this._onEntityPropertyChanged(entity, \"cylinder\", entity.cylinder, undefined);\n}\nif (defined(Object.create)) {\n  CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;\n}\nObject.defineProperties(CylinderGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof CylinderGeometryUpdater.prototype\n   * @readonly\n   * @private\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    }\n  }\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nCylinderGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CylinderGeometry(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.ellipsoid),\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nCylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CylinderOutlineGeometry(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.ellipsoid),\n    attributes: attributes\n  });\n};\nCylinderGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\nCylinderGeometryUpdater.prototype._isHidden = function (entity, cylinder) {\n  return !defined(entity.position) || !defined(cylinder.length) || !defined(cylinder.topRadius) || !defined(cylinder.bottomRadius) || GeometryUpdater.prototype._isHidden.call(this, entity, cylinder);\n};\nCylinderGeometryUpdater.prototype._isDynamic = function (entity, cylinder) {\n  return !entity.position.isConstant ||\n  //\n  !Property.isConstant(entity.orientation) ||\n  //\n  !cylinder.length.isConstant ||\n  //\n  !cylinder.topRadius.isConstant ||\n  //\n  !cylinder.bottomRadius.isConstant ||\n  //\n  !Property.isConstant(cylinder.slices) ||\n  //\n  !Property.isConstant(cylinder.outlineWidth) ||\n  //\n  !Property.isConstant(cylinder.numberOfVerticalLines);\n};\nCylinderGeometryUpdater.prototype._setStaticOptions = function (entity, cylinder) {\n  const heightReference = Property.getValueOrDefault(cylinder.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  const options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);\n  options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);\n  options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);\n  options.slices = Property.getValueOrUndefined(cylinder.slices, Iso8601.MINIMUM_VALUE);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n};\nCylinderGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\nCylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicCylinderGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\nif (defined(Object.create)) {\n  DynamicCylinderGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicCylinderGeometryUpdater.prototype.constructor = DynamicCylinderGeometryUpdater;\n}\nDynamicCylinderGeometryUpdater.prototype._isHidden = function (entity, cylinder, time) {\n  const options = this._options;\n  const position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n  return !defined(position) || !defined(options.length) || !defined(options.topRadius) ||\n  //\n  !defined(options.bottomRadius) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, cylinder, time);\n};\nDynamicCylinderGeometryUpdater.prototype._setOptions = function (entity, cylinder, time) {\n  const heightReference = Property.getValueOrDefault(cylinder.heightReference, time, HeightReference.NONE);\n  const options = this._options;\n  options.length = Property.getValueOrUndefined(cylinder.length, time);\n  options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);\n  options.bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);\n  options.slices = Property.getValueOrUndefined(cylinder.slices, time);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);\n  options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n};\nexport default CylinderGeometryUpdater;","map":{"version":3,"names":["Cartesian3","Check","Color","ColorGeometryInstanceAttribute","CylinderGeometry","CylinderOutlineGeometry","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","GeometryInstance","GeometryOffsetAttribute","Iso8601","OffsetGeometryInstanceAttribute","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","heightReferenceOnEntityPropertyChanged","Property","defaultOffset","ZERO","offsetScratch","positionScratch","scratchColor","CylinderGeometryOptions","entity","id","vertexFormat","undefined","length","topRadius","bottomRadius","slices","numberOfVerticalLines","offsetAttribute","CylinderGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","cylinder","Object","create","prototype","constructor","defineProperties","terrainOffsetProperty","get","_terrainOffsetProperty","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","_distanceDisplayConditionProperty","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","attributes","color","offset","_materialProperty","currentColor","isConstant","WHITE","fromColor","_options","fromCartesian3","getValueOrDefault","geometry","modelMatrix","computeModelMatrixForHeightReference","heightReference","_scene","ellipsoid","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","position","_isHidden","_isDynamic","orientation","outlineWidth","_setStaticOptions","MINIMUM_VALUE","NONE","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","ALL","DynamicCylinderGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/CylinderGeometryUpdater.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CylinderGeometry from \"../Core/CylinderGeometry.js\";\nimport CylinderOutlineGeometry from \"../Core/CylinderOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport Property from \"./Property.js\";\n\nconst defaultOffset = Cartesian3.ZERO;\n\nconst offsetScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\nconst scratchColor = new Color();\n\nfunction CylinderGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.length = undefined;\n  this.topRadius = undefined;\n  this.bottomRadius = undefined;\n  this.slices = undefined;\n  this.numberOfVerticalLines = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for cylinders.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias CylinderGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction CylinderGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new CylinderGeometryOptions(entity),\n    geometryPropertyName: \"cylinder\",\n    observedPropertyNames: [\n      \"availability\",\n      \"position\",\n      \"orientation\",\n      \"cylinder\",\n    ],\n  });\n\n  this._onEntityPropertyChanged(entity, \"cylinder\", entity.cylinder, undefined);\n}\n\nif (defined(Object.create)) {\n  CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;\n}\n\nObject.defineProperties(CylinderGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof CylinderGeometryUpdater.prototype\n   * @readonly\n   * @private\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    },\n  },\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nCylinderGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n\n  const show = new ShowGeometryInstanceAttribute(\n    isAvailable &&\n      entity.isShowing &&\n      this._showProperty.getValue(time) &&\n      this._fillProperty.getValue(time),\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute =\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition,\n    );\n\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined,\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CylinderGeometry(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(\n      time,\n      entity.cylinder.heightReference,\n      this._options.length * 0.5,\n      this._scene.ellipsoid,\n    ),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nCylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time),\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        distanceDisplayCondition,\n      ),\n    offset: undefined,\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new CylinderOutlineGeometry(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(\n      time,\n      entity.cylinder.heightReference,\n      this._options.length * 0.5,\n      this._scene.ellipsoid,\n    ),\n    attributes: attributes,\n  });\n};\n\nCylinderGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nCylinderGeometryUpdater.prototype._isHidden = function (entity, cylinder) {\n  return (\n    !defined(entity.position) ||\n    !defined(cylinder.length) ||\n    !defined(cylinder.topRadius) ||\n    !defined(cylinder.bottomRadius) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, cylinder)\n  );\n};\n\nCylinderGeometryUpdater.prototype._isDynamic = function (entity, cylinder) {\n  return (\n    !entity.position.isConstant || //\n    !Property.isConstant(entity.orientation) || //\n    !cylinder.length.isConstant || //\n    !cylinder.topRadius.isConstant || //\n    !cylinder.bottomRadius.isConstant || //\n    !Property.isConstant(cylinder.slices) || //\n    !Property.isConstant(cylinder.outlineWidth) || //\n    !Property.isConstant(cylinder.numberOfVerticalLines)\n  );\n};\n\nCylinderGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  cylinder,\n) {\n  const heightReference = Property.getValueOrDefault(\n    cylinder.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n  const options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);\n  options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);\n  options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);\n  options.slices = Property.getValueOrUndefined(\n    cylinder.slices,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.numberOfVerticalLines = Property.getValueOrUndefined(\n    cylinder.numberOfVerticalLines,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n};\n\nCylinderGeometryUpdater.prototype._onEntityPropertyChanged =\n  heightReferenceOnEntityPropertyChanged;\n\nCylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicCylinderGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives,\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives,\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicCylinderGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype,\n  );\n  DynamicCylinderGeometryUpdater.prototype.constructor =\n    DynamicCylinderGeometryUpdater;\n}\n\nDynamicCylinderGeometryUpdater.prototype._isHidden = function (\n  entity,\n  cylinder,\n  time,\n) {\n  const options = this._options;\n  const position = Property.getValueOrUndefined(\n    entity.position,\n    time,\n    positionScratch,\n  );\n  return (\n    !defined(position) ||\n    !defined(options.length) ||\n    !defined(options.topRadius) || //\n    !defined(options.bottomRadius) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(\n      this,\n      entity,\n      cylinder,\n      time,\n    )\n  );\n};\n\nDynamicCylinderGeometryUpdater.prototype._setOptions = function (\n  entity,\n  cylinder,\n  time,\n) {\n  const heightReference = Property.getValueOrDefault(\n    cylinder.heightReference,\n    time,\n    HeightReference.NONE,\n  );\n  const options = this._options;\n  options.length = Property.getValueOrUndefined(cylinder.length, time);\n  options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);\n  options.bottomRadius = Property.getValueOrUndefined(\n    cylinder.bottomRadius,\n    time,\n  );\n  options.slices = Property.getValueOrUndefined(cylinder.slices, time);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(\n    cylinder.numberOfVerticalLines,\n    time,\n  );\n  options.offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n};\nexport default CylinderGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}