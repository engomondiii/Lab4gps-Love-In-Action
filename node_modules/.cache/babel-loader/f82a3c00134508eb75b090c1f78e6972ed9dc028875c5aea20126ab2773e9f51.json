{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * Statistics for the GPU and CPU memory used by the models loaded through the\n * {@link ResourceCache}.\n *\n * @alias ResourceCacheStatistics\n * @constructor\n *\n * @private\n */\nfunction ResourceCacheStatistics() {\n  /**\n   * The size of vertex buffers and index buffers loaded in the cache in bytes.\n   *\n   * @type {number}\n   * @private\n   */\n  this.geometryByteLength = 0;\n\n  /**\n   * The size of all textures loaded in the cache in bytes\n   *\n   * @type {number}\n   * @private\n   */\n  this.texturesByteLength = 0;\n\n  // Track the sizes of resources by cache key. This is important so\n  // removeLoader() can decrement the counts correctly.\n  this._geometrySizes = {};\n  this._textureSizes = {};\n}\n\n/**\n * Reset the memory counts\n *\n * @private\n */\nResourceCacheStatistics.prototype.clear = function () {\n  this.geometryByteLength = 0;\n  this.texturesByteLength = 0;\n  this._geometrySizes = {};\n  this._textureSizes = {};\n};\n\n/**\n * Track the resources for a vertex or index buffer loader. This should be called after a loader is ready; that\n * is it has been loaded and processed.\n * This method handles the following cases gracefully:\n * <ul>\n *   <li>If the loader is added twice, its resources will not be double-counted</li>\n *   <li>If the geometry has a CPU copy of the GPU buffer, it will be added to the count</li>\n * </ul>\n * @param {GltfVertexBufferLoader|GltfIndexBufferLoader} loader The geometry buffer with resources to track\n *\n * @private\n */\nResourceCacheStatistics.prototype.addGeometryLoader = function (loader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"loader\", loader);\n  //>>includeEnd('debug');\n\n  const cacheKey = loader.cacheKey;\n\n  // Don't double count the same resource.\n  if (this._geometrySizes.hasOwnProperty(cacheKey)) {\n    return;\n  }\n  this._geometrySizes[cacheKey] = 0;\n  const buffer = loader.buffer;\n  const typedArray = loader.typedArray;\n  let totalSize = 0;\n  if (defined(buffer)) {\n    totalSize += buffer.sizeInBytes;\n  }\n  if (defined(typedArray)) {\n    totalSize += typedArray.byteLength;\n  }\n  this.geometryByteLength += totalSize;\n  this._geometrySizes[cacheKey] = totalSize;\n};\n\n/**\n * Track the resources for a texture loader. This should be called after a loader is ready; that\n * is it has been loaded and processed.\n * If the loader is added twice, its resources will not be double-counted.\n *\n * @param {GltfTextureLoader} loader The texture loader with resources to track\n *\n * @private\n */\nResourceCacheStatistics.prototype.addTextureLoader = function (loader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"loader\", loader);\n  //>>includeEnd('debug');\n\n  const cacheKey = loader.cacheKey;\n\n  // Don't double count the same resource.\n  if (this._textureSizes.hasOwnProperty(cacheKey)) {\n    return;\n  }\n  this._textureSizes[cacheKey] = 0;\n  const totalSize = loader.texture.sizeInBytes;\n  this.texturesByteLength += loader.texture.sizeInBytes;\n  this._textureSizes[cacheKey] = totalSize;\n};\n\n/**\n * Remove a loader's resources from the memory count. The loader's cache key\n * is used to determine information about the resource, so this method can\n * be used both for geometry and textures. If the loader does not have any\n * tracked resources, this is a no-op.\n * @param {ResourceLoader} loader The resource loader to remove from the cache\n *\n * @private\n */\nResourceCacheStatistics.prototype.removeLoader = function (loader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"loader\", loader);\n  //>>includeEnd('debug');\n\n  const cacheKey = loader.cacheKey;\n  const geometrySize = this._geometrySizes[cacheKey];\n  delete this._geometrySizes[cacheKey];\n  if (defined(geometrySize)) {\n    this.geometryByteLength -= geometrySize;\n  }\n  const textureSize = this._textureSizes[cacheKey];\n  delete this._textureSizes[cacheKey];\n  if (defined(textureSize)) {\n    this.texturesByteLength -= textureSize;\n  }\n};\nexport default ResourceCacheStatistics;","map":{"version":3,"names":["Check","defined","ResourceCacheStatistics","geometryByteLength","texturesByteLength","_geometrySizes","_textureSizes","prototype","clear","addGeometryLoader","loader","typeOf","object","cacheKey","hasOwnProperty","buffer","typedArray","totalSize","sizeInBytes","byteLength","addTextureLoader","texture","removeLoader","geometrySize","textureSize"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ResourceCacheStatistics.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * Statistics for the GPU and CPU memory used by the models loaded through the\n * {@link ResourceCache}.\n *\n * @alias ResourceCacheStatistics\n * @constructor\n *\n * @private\n */\nfunction ResourceCacheStatistics() {\n  /**\n   * The size of vertex buffers and index buffers loaded in the cache in bytes.\n   *\n   * @type {number}\n   * @private\n   */\n  this.geometryByteLength = 0;\n\n  /**\n   * The size of all textures loaded in the cache in bytes\n   *\n   * @type {number}\n   * @private\n   */\n  this.texturesByteLength = 0;\n\n  // Track the sizes of resources by cache key. This is important so\n  // removeLoader() can decrement the counts correctly.\n  this._geometrySizes = {};\n  this._textureSizes = {};\n}\n\n/**\n * Reset the memory counts\n *\n * @private\n */\nResourceCacheStatistics.prototype.clear = function () {\n  this.geometryByteLength = 0;\n  this.texturesByteLength = 0;\n\n  this._geometrySizes = {};\n  this._textureSizes = {};\n};\n\n/**\n * Track the resources for a vertex or index buffer loader. This should be called after a loader is ready; that\n * is it has been loaded and processed.\n * This method handles the following cases gracefully:\n * <ul>\n *   <li>If the loader is added twice, its resources will not be double-counted</li>\n *   <li>If the geometry has a CPU copy of the GPU buffer, it will be added to the count</li>\n * </ul>\n * @param {GltfVertexBufferLoader|GltfIndexBufferLoader} loader The geometry buffer with resources to track\n *\n * @private\n */\nResourceCacheStatistics.prototype.addGeometryLoader = function (loader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"loader\", loader);\n  //>>includeEnd('debug');\n\n  const cacheKey = loader.cacheKey;\n\n  // Don't double count the same resource.\n  if (this._geometrySizes.hasOwnProperty(cacheKey)) {\n    return;\n  }\n\n  this._geometrySizes[cacheKey] = 0;\n\n  const buffer = loader.buffer;\n  const typedArray = loader.typedArray;\n\n  let totalSize = 0;\n\n  if (defined(buffer)) {\n    totalSize += buffer.sizeInBytes;\n  }\n\n  if (defined(typedArray)) {\n    totalSize += typedArray.byteLength;\n  }\n\n  this.geometryByteLength += totalSize;\n  this._geometrySizes[cacheKey] = totalSize;\n};\n\n/**\n * Track the resources for a texture loader. This should be called after a loader is ready; that\n * is it has been loaded and processed.\n * If the loader is added twice, its resources will not be double-counted.\n *\n * @param {GltfTextureLoader} loader The texture loader with resources to track\n *\n * @private\n */\nResourceCacheStatistics.prototype.addTextureLoader = function (loader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"loader\", loader);\n  //>>includeEnd('debug');\n\n  const cacheKey = loader.cacheKey;\n\n  // Don't double count the same resource.\n  if (this._textureSizes.hasOwnProperty(cacheKey)) {\n    return;\n  }\n\n  this._textureSizes[cacheKey] = 0;\n  const totalSize = loader.texture.sizeInBytes;\n  this.texturesByteLength += loader.texture.sizeInBytes;\n  this._textureSizes[cacheKey] = totalSize;\n};\n\n/**\n * Remove a loader's resources from the memory count. The loader's cache key\n * is used to determine information about the resource, so this method can\n * be used both for geometry and textures. If the loader does not have any\n * tracked resources, this is a no-op.\n * @param {ResourceLoader} loader The resource loader to remove from the cache\n *\n * @private\n */\nResourceCacheStatistics.prototype.removeLoader = function (loader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"loader\", loader);\n  //>>includeEnd('debug');\n\n  const cacheKey = loader.cacheKey;\n  const geometrySize = this._geometrySizes[cacheKey];\n  delete this._geometrySizes[cacheKey];\n\n  if (defined(geometrySize)) {\n    this.geometryByteLength -= geometrySize;\n  }\n\n  const textureSize = this._textureSizes[cacheKey];\n  delete this._textureSizes[cacheKey];\n\n  if (defined(textureSize)) {\n    this.texturesByteLength -= textureSize;\n  }\n};\n\nexport default ResourceCacheStatistics;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}