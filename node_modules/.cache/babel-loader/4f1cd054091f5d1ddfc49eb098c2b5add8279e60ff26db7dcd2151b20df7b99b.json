{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"precision highp float;\\n\\\n\\n\\\nuniform sampler2D randomTexture;\\n\\\nuniform sampler2D depthTexture;\\n\\\nuniform float intensity;\\n\\\nuniform float bias;\\n\\\nuniform float lengthCap;\\n\\\nuniform int stepCount;\\n\\\nuniform int directionCount;\\n\\\n\\n\\\nvec4 pixelToEye(vec2 screenCoordinate)\\n\\\n{\\n\\\n    vec2 uv = screenCoordinate / czm_viewport.zw;\\n\\\n    float depth = czm_readDepth(depthTexture, uv);\\n\\\n    vec2 xy = 2.0 * uv - vec2(1.0);\\n\\\n    vec4 posEC = czm_inverseProjection * vec4(xy, depth, 1.0);\\n\\\n    posEC = posEC / posEC.w;\\n\\\n    // Avoid numerical error at far plane\\n\\\n    if (depth >= 1.0) {\\n\\\n        posEC.z = czm_currentFrustum.y;\\n\\\n    }\\n\\\n    return posEC;\\n\\\n}\\n\\\n\\n\\\n// Reconstruct surface normal in eye coordinates, avoiding edges\\n\\\nvec3 getNormalXEdge(vec3 positionEC)\\n\\\n{\\n\\\n    // Find the 3D surface positions at adjacent screen pixels\\n\\\n    vec2 centerCoord = gl_FragCoord.xy;\\n\\\n    vec3 positionLeft = pixelToEye(centerCoord + vec2(-1.0, 0.0)).xyz;\\n\\\n    vec3 positionRight = pixelToEye(centerCoord + vec2(1.0, 0.0)).xyz;\\n\\\n    vec3 positionUp = pixelToEye(centerCoord + vec2(0.0, 1.0)).xyz;\\n\\\n    vec3 positionDown = pixelToEye(centerCoord + vec2(0.0, -1.0)).xyz;\\n\\\n\\n\\\n    // Compute potential tangent vectors\\n\\\n    vec3 dx0 = positionEC - positionLeft;\\n\\\n    vec3 dx1 = positionRight - positionEC;\\n\\\n    vec3 dy0 = positionEC - positionDown;\\n\\\n    vec3 dy1 = positionUp - positionEC;\\n\\\n\\n\\\n    // The shorter tangent is more likely to be on the same surface\\n\\\n    vec3 dx = length(dx0) < length(dx1) ? dx0 : dx1;\\n\\\n    vec3 dy = length(dy0) < length(dy1) ? dy0 : dy1;\\n\\\n\\n\\\n    return normalize(cross(dx, dy));\\n\\\n}\\n\\\n\\n\\\nconst float sqrtTwoPi = sqrt(czm_twoPi);\\n\\\n\\n\\\nfloat gaussian(float x, float standardDeviation) {\\n\\\n    float argument = x / standardDeviation;\\n\\\n    return exp(-0.5 * argument * argument) / (sqrtTwoPi * standardDeviation);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 positionEC = pixelToEye(gl_FragCoord.xy);\\n\\\n\\n\\\n    // Exit if we are too close to the back of the frustum, where the depth value is invalid.\\n\\\n    float maxValidDepth = czm_currentFrustum.y - lengthCap;\\n\\\n    if (-positionEC.z > maxValidDepth)\\n\\\n    {\\n\\\n        out_FragColor = vec4(1.0);\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec3 normalEC = getNormalXEdge(positionEC.xyz);\\n\\\n    float gaussianVariance = lengthCap * sqrt(-positionEC.z);\\n\\\n    // Choose a step length such that the marching stops just before 3 * variance.\\n\\\n    float stepLength = 3.0 * gaussianVariance / (float(stepCount) + 1.0);\\n\\\n    float metersPerPixel = czm_metersPerPixel(positionEC, 1.0);\\n\\\n    // Minimum step is 1 pixel to avoid double sampling\\n\\\n    float pixelsPerStep = max(stepLength / metersPerPixel, 1.0);\\n\\\n    stepLength = pixelsPerStep * metersPerPixel;\\n\\\n\\n\\\n    float angleStepScale = 1.0 / float(directionCount);\\n\\\n    float angleStep = angleStepScale * czm_twoPi;\\n\\\n    float cosStep = cos(angleStep);\\n\\\n    float sinStep = sin(angleStep);\\n\\\n    mat2 rotateStep = mat2(cosStep, sinStep, -sinStep, cosStep);\\n\\\n\\n\\\n    // Initial sampling direction (different for each pixel)\\n\\\n    const float randomTextureSize = 255.0;\\n\\\n    vec2 randomTexCoord = fract(gl_FragCoord.xy / randomTextureSize);\\n\\\n    float randomVal = texture(randomTexture, randomTexCoord).x;\\n\\\n    vec2 sampleDirection = vec2(cos(angleStep * randomVal), sin(angleStep * randomVal));\\n\\\n\\n\\\n    float ao = 0.0;\\n\\\n    // Loop over sampling directions\\n\\\n#if __VERSION__ == 300\\n\\\n    for (int i = 0; i < directionCount; i++)\\n\\\n    {\\n\\\n#else\\n\\\n    for (int i = 0; i < 16; i++)\\n\\\n    {\\n\\\n        if (i >= directionCount) {\\n\\\n            break;\\n\\\n        }\\n\\\n#endif\\n\\\n        sampleDirection = rotateStep * sampleDirection;\\n\\\n\\n\\\n        float localAO = 0.0;\\n\\\n        vec2 radialStep = pixelsPerStep * sampleDirection;\\n\\\n\\n\\\n#if __VERSION__ == 300\\n\\\n        for (int j = 0; j < stepCount; j++)\\n\\\n        {\\n\\\n#else\\n\\\n        for (int j = 0; j < 64; j++)\\n\\\n        {\\n\\\n            if (j >= stepCount) {\\n\\\n                break;\\n\\\n            }\\n\\\n#endif\\n\\\n            // Step along sampling direction, away from output pixel\\n\\\n            vec2 samplePixel = floor(gl_FragCoord.xy + float(j + 1) * radialStep) + vec2(0.5);\\n\\\n\\n\\\n            // Exit if we stepped off the screen\\n\\\n            if (clamp(samplePixel, vec2(0.0), czm_viewport.zw) != samplePixel) {\\n\\\n                break;\\n\\\n            }\\n\\\n\\n\\\n            // Compute step vector from output point to sampled point\\n\\\n            vec4 samplePositionEC = pixelToEye(samplePixel);\\n\\\n            vec3 stepVector = samplePositionEC.xyz - positionEC.xyz;\\n\\\n\\n\\\n            // Estimate the angle from the surface normal.\\n\\\n            float dotVal = clamp(dot(normalEC, normalize(stepVector)), 0.0, 1.0);\\n\\\n            dotVal = czm_branchFreeTernary(dotVal > bias, dotVal, 0.0);\\n\\\n            dotVal = czm_branchFreeTernary(-samplePositionEC.z <= maxValidDepth, dotVal, 0.0);\\n\\\n\\n\\\n            // Weight contribution based on the distance from the output point\\n\\\n            float sampleDistance = length(stepVector);\\n\\\n            float weight = gaussian(sampleDistance, gaussianVariance);\\n\\\n            localAO += weight * dotVal;\\n\\\n        }\\n\\\n        ao += localAO;\\n\\\n    }\\n\\\n\\n\\\n    ao *= angleStepScale * stepLength;\\n\\\n    ao = 1.0 - clamp(ao, 0.0, 1.0);\\n\\\n    ao = pow(ao, intensity);\\n\\\n    out_FragColor = vec4(vec3(ao), 1.0);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/PostProcessStages/AmbientOcclusionGenerate.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"precision highp float;\\n\\\n\\n\\\nuniform sampler2D randomTexture;\\n\\\nuniform sampler2D depthTexture;\\n\\\nuniform float intensity;\\n\\\nuniform float bias;\\n\\\nuniform float lengthCap;\\n\\\nuniform int stepCount;\\n\\\nuniform int directionCount;\\n\\\n\\n\\\nvec4 pixelToEye(vec2 screenCoordinate)\\n\\\n{\\n\\\n    vec2 uv = screenCoordinate / czm_viewport.zw;\\n\\\n    float depth = czm_readDepth(depthTexture, uv);\\n\\\n    vec2 xy = 2.0 * uv - vec2(1.0);\\n\\\n    vec4 posEC = czm_inverseProjection * vec4(xy, depth, 1.0);\\n\\\n    posEC = posEC / posEC.w;\\n\\\n    // Avoid numerical error at far plane\\n\\\n    if (depth >= 1.0) {\\n\\\n        posEC.z = czm_currentFrustum.y;\\n\\\n    }\\n\\\n    return posEC;\\n\\\n}\\n\\\n\\n\\\n// Reconstruct surface normal in eye coordinates, avoiding edges\\n\\\nvec3 getNormalXEdge(vec3 positionEC)\\n\\\n{\\n\\\n    // Find the 3D surface positions at adjacent screen pixels\\n\\\n    vec2 centerCoord = gl_FragCoord.xy;\\n\\\n    vec3 positionLeft = pixelToEye(centerCoord + vec2(-1.0, 0.0)).xyz;\\n\\\n    vec3 positionRight = pixelToEye(centerCoord + vec2(1.0, 0.0)).xyz;\\n\\\n    vec3 positionUp = pixelToEye(centerCoord + vec2(0.0, 1.0)).xyz;\\n\\\n    vec3 positionDown = pixelToEye(centerCoord + vec2(0.0, -1.0)).xyz;\\n\\\n\\n\\\n    // Compute potential tangent vectors\\n\\\n    vec3 dx0 = positionEC - positionLeft;\\n\\\n    vec3 dx1 = positionRight - positionEC;\\n\\\n    vec3 dy0 = positionEC - positionDown;\\n\\\n    vec3 dy1 = positionUp - positionEC;\\n\\\n\\n\\\n    // The shorter tangent is more likely to be on the same surface\\n\\\n    vec3 dx = length(dx0) < length(dx1) ? dx0 : dx1;\\n\\\n    vec3 dy = length(dy0) < length(dy1) ? dy0 : dy1;\\n\\\n\\n\\\n    return normalize(cross(dx, dy));\\n\\\n}\\n\\\n\\n\\\nconst float sqrtTwoPi = sqrt(czm_twoPi);\\n\\\n\\n\\\nfloat gaussian(float x, float standardDeviation) {\\n\\\n    float argument = x / standardDeviation;\\n\\\n    return exp(-0.5 * argument * argument) / (sqrtTwoPi * standardDeviation);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 positionEC = pixelToEye(gl_FragCoord.xy);\\n\\\n\\n\\\n    // Exit if we are too close to the back of the frustum, where the depth value is invalid.\\n\\\n    float maxValidDepth = czm_currentFrustum.y - lengthCap;\\n\\\n    if (-positionEC.z > maxValidDepth)\\n\\\n    {\\n\\\n        out_FragColor = vec4(1.0);\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec3 normalEC = getNormalXEdge(positionEC.xyz);\\n\\\n    float gaussianVariance = lengthCap * sqrt(-positionEC.z);\\n\\\n    // Choose a step length such that the marching stops just before 3 * variance.\\n\\\n    float stepLength = 3.0 * gaussianVariance / (float(stepCount) + 1.0);\\n\\\n    float metersPerPixel = czm_metersPerPixel(positionEC, 1.0);\\n\\\n    // Minimum step is 1 pixel to avoid double sampling\\n\\\n    float pixelsPerStep = max(stepLength / metersPerPixel, 1.0);\\n\\\n    stepLength = pixelsPerStep * metersPerPixel;\\n\\\n\\n\\\n    float angleStepScale = 1.0 / float(directionCount);\\n\\\n    float angleStep = angleStepScale * czm_twoPi;\\n\\\n    float cosStep = cos(angleStep);\\n\\\n    float sinStep = sin(angleStep);\\n\\\n    mat2 rotateStep = mat2(cosStep, sinStep, -sinStep, cosStep);\\n\\\n\\n\\\n    // Initial sampling direction (different for each pixel)\\n\\\n    const float randomTextureSize = 255.0;\\n\\\n    vec2 randomTexCoord = fract(gl_FragCoord.xy / randomTextureSize);\\n\\\n    float randomVal = texture(randomTexture, randomTexCoord).x;\\n\\\n    vec2 sampleDirection = vec2(cos(angleStep * randomVal), sin(angleStep * randomVal));\\n\\\n\\n\\\n    float ao = 0.0;\\n\\\n    // Loop over sampling directions\\n\\\n#if __VERSION__ == 300\\n\\\n    for (int i = 0; i < directionCount; i++)\\n\\\n    {\\n\\\n#else\\n\\\n    for (int i = 0; i < 16; i++)\\n\\\n    {\\n\\\n        if (i >= directionCount) {\\n\\\n            break;\\n\\\n        }\\n\\\n#endif\\n\\\n        sampleDirection = rotateStep * sampleDirection;\\n\\\n\\n\\\n        float localAO = 0.0;\\n\\\n        vec2 radialStep = pixelsPerStep * sampleDirection;\\n\\\n\\n\\\n#if __VERSION__ == 300\\n\\\n        for (int j = 0; j < stepCount; j++)\\n\\\n        {\\n\\\n#else\\n\\\n        for (int j = 0; j < 64; j++)\\n\\\n        {\\n\\\n            if (j >= stepCount) {\\n\\\n                break;\\n\\\n            }\\n\\\n#endif\\n\\\n            // Step along sampling direction, away from output pixel\\n\\\n            vec2 samplePixel = floor(gl_FragCoord.xy + float(j + 1) * radialStep) + vec2(0.5);\\n\\\n\\n\\\n            // Exit if we stepped off the screen\\n\\\n            if (clamp(samplePixel, vec2(0.0), czm_viewport.zw) != samplePixel) {\\n\\\n                break;\\n\\\n            }\\n\\\n\\n\\\n            // Compute step vector from output point to sampled point\\n\\\n            vec4 samplePositionEC = pixelToEye(samplePixel);\\n\\\n            vec3 stepVector = samplePositionEC.xyz - positionEC.xyz;\\n\\\n\\n\\\n            // Estimate the angle from the surface normal.\\n\\\n            float dotVal = clamp(dot(normalEC, normalize(stepVector)), 0.0, 1.0);\\n\\\n            dotVal = czm_branchFreeTernary(dotVal > bias, dotVal, 0.0);\\n\\\n            dotVal = czm_branchFreeTernary(-samplePositionEC.z <= maxValidDepth, dotVal, 0.0);\\n\\\n\\n\\\n            // Weight contribution based on the distance from the output point\\n\\\n            float sampleDistance = length(stepVector);\\n\\\n            float weight = gaussian(sampleDistance, gaussianVariance);\\n\\\n            localAO += weight * dotVal;\\n\\\n        }\\n\\\n        ao += localAO;\\n\\\n    }\\n\\\n\\n\\\n    ao *= angleStepScale * stepLength;\\n\\\n    ao = 1.0 - clamp(ao, 0.0, 1.0);\\n\\\n    ao = pow(ao, intensity);\\n\\\n    out_FragColor = vec4(vec3(ao), 1.0);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}