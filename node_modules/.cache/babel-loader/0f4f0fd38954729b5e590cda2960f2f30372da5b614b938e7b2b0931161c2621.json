{"ast":null,"code":"import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Returns the accessor data in a contiguous array.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor.\n * @returns {Array} The accessor values in a contiguous array.\n *\n * @private\n */\nfunction readAccessorPacked(gltf, accessor) {\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const componentTypeByteLength = ComponentDatatype.getSizeInBytes(accessor.componentType);\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n  const count = accessor.count;\n  const values = new Array(numberOfComponents * count);\n  if (!defined(accessor.bufferView)) {\n    return values.fill(0);\n  }\n  const bufferView = gltf.bufferViews[accessor.bufferView];\n  const source = gltf.buffers[bufferView.buffer].extras._pipeline.source;\n  let byteOffset = accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(accessor.componentType);\n  for (let i = 0; i < count; ++i) {\n    componentReader(dataView, byteOffset, numberOfComponents, componentTypeByteLength, components);\n    for (let j = 0; j < numberOfComponents; ++j) {\n      values[i * numberOfComponents + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n  return values;\n}\nexport default readAccessorPacked;","map":{"version":3,"names":["getAccessorByteStride","getComponentReader","numberOfComponentsForType","ComponentDatatype","defined","readAccessorPacked","gltf","accessor","byteStride","componentTypeByteLength","getSizeInBytes","componentType","numberOfComponents","type","count","values","Array","bufferView","fill","bufferViews","source","buffers","buffer","extras","_pipeline","byteOffset","dataView","DataView","components","componentReader","i","j"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfPipeline/readAccessorPacked.js"],"sourcesContent":["import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Returns the accessor data in a contiguous array.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor.\n * @returns {Array} The accessor values in a contiguous array.\n *\n * @private\n */\nfunction readAccessorPacked(gltf, accessor) {\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const componentTypeByteLength = ComponentDatatype.getSizeInBytes(\n    accessor.componentType\n  );\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n  const count = accessor.count;\n  const values = new Array(numberOfComponents * count);\n\n  if (!defined(accessor.bufferView)) {\n    return values.fill(0);\n  }\n\n  const bufferView = gltf.bufferViews[accessor.bufferView];\n  const source = gltf.buffers[bufferView.buffer].extras._pipeline.source;\n  let byteOffset =\n    accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(accessor.componentType);\n\n  for (let i = 0; i < count; ++i) {\n    componentReader(\n      dataView,\n      byteOffset,\n      numberOfComponents,\n      componentTypeByteLength,\n      components\n    );\n    for (let j = 0; j < numberOfComponents; ++j) {\n      values[i * numberOfComponents + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n  return values;\n}\n\nexport default readAccessorPacked;\n"],"mappings":"AAAA,OAAOA,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,yBAAyB,MAAM,gCAAgC;AACtE,OAAOC,iBAAiB,MAAM,iCAAiC;AAC/D,OAAOC,OAAO,MAAM,uBAAuB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC1C,MAAMC,UAAU,GAAGR,qBAAqB,CAACM,IAAI,EAAEC,QAAQ,CAAC;EACxD,MAAME,uBAAuB,GAAGN,iBAAiB,CAACO,cAAc,CAC9DH,QAAQ,CAACI,aACX,CAAC;EACD,MAAMC,kBAAkB,GAAGV,yBAAyB,CAACK,QAAQ,CAACM,IAAI,CAAC;EACnE,MAAMC,KAAK,GAAGP,QAAQ,CAACO,KAAK;EAC5B,MAAMC,MAAM,GAAG,IAAIC,KAAK,CAACJ,kBAAkB,GAAGE,KAAK,CAAC;EAEpD,IAAI,CAACV,OAAO,CAACG,QAAQ,CAACU,UAAU,CAAC,EAAE;IACjC,OAAOF,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC;EACvB;EAEA,MAAMD,UAAU,GAAGX,IAAI,CAACa,WAAW,CAACZ,QAAQ,CAACU,UAAU,CAAC;EACxD,MAAMG,MAAM,GAAGd,IAAI,CAACe,OAAO,CAACJ,UAAU,CAACK,MAAM,CAAC,CAACC,MAAM,CAACC,SAAS,CAACJ,MAAM;EACtE,IAAIK,UAAU,GACZlB,QAAQ,CAACkB,UAAU,GAAGR,UAAU,CAACQ,UAAU,GAAGL,MAAM,CAACK,UAAU;EAEjE,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAACP,MAAM,CAACE,MAAM,CAAC;EAC5C,MAAMM,UAAU,GAAG,IAAIZ,KAAK,CAACJ,kBAAkB,CAAC;EAChD,MAAMiB,eAAe,GAAG5B,kBAAkB,CAACM,QAAQ,CAACI,aAAa,CAAC;EAElE,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,KAAK,EAAE,EAAEgB,CAAC,EAAE;IAC9BD,eAAe,CACbH,QAAQ,EACRD,UAAU,EACVb,kBAAkB,EAClBH,uBAAuB,EACvBmB,UACF,CAAC;IACD,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,kBAAkB,EAAE,EAAEmB,CAAC,EAAE;MAC3ChB,MAAM,CAACe,CAAC,GAAGlB,kBAAkB,GAAGmB,CAAC,CAAC,GAAGH,UAAU,CAACG,CAAC,CAAC;IACpD;IACAN,UAAU,IAAIjB,UAAU;EAC1B;EACA,OAAOO,MAAM;AACf;AAEA,eAAeV,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}