{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Vector3DTileClampedPolylinesVS from \"../Shaders/Vector3DTileClampedPolylinesVS.js\";\nimport Vector3DTileClampedPolylinesFS from \"../Shaders/Vector3DTileClampedPolylinesFS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\n\n/**\n * Creates a batch of polylines as volumes with shader-adjustable width.\n *\n * @alias Vector3DTileClampedPolylines\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polylines\n * @param {Uint32Array} options.counts The number or positions in the each polyline.\n * @param {Uint16Array} options.widths The width of each polyline.\n * @param {number} options.minimumHeight The minimum height of the tile's region.\n * @param {number} options.maximumHeight The maximum height of the tile's region.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polylines.\n * @param {Uint16Array} options.batchIds The batch ids for each polyline.\n * @param {ClassificationType} options.classificationType The classification type.\n * @param {boolean} options.keepDecodedPositions Whether to keep decoded positions in memory.\n *\n * @private\n */\nfunction Vector3DTileClampedPolylines(options) {\n  // these arrays hold data from the tile payload\n  // and are all released after the first update.\n  this._positions = options.positions;\n  this._widths = options.widths;\n  this._counts = options.counts;\n  this._batchIds = options.batchIds;\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._center = options.center;\n  this._rectangle = options.rectangle;\n  this._batchTable = options.batchTable;\n  this._va = undefined;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._uniformMap = undefined;\n  this._command = undefined;\n  this._transferrableBatchIds = undefined;\n  this._packedBuffer = undefined;\n  this._minimumMaximumVectorHeights = new Cartesian2(ApproximateTerrainHeights._defaultMinTerrainHeight, ApproximateTerrainHeights._defaultMaxTerrainHeight);\n  this._boundingVolume = OrientedBoundingBox.fromRectangle(options.rectangle, ApproximateTerrainHeights._defaultMinTerrainHeight, ApproximateTerrainHeights._defaultMaxTerrainHeight, this._ellipsoid);\n  this._classificationType = options.classificationType;\n  this._keepDecodedPositions = options.keepDecodedPositions;\n  this._decodedPositions = undefined;\n  this._decodedPositionOffsets = undefined;\n\n  // Fat vertices - all information for each volume packed to a vec3 and 5 vec4s\n  this._startEllipsoidNormals = undefined;\n  this._endEllipsoidNormals = undefined;\n  this._startPositionAndHeights = undefined;\n  this._startFaceNormalAndVertexCornerIds = undefined;\n  this._endPositionAndHeights = undefined;\n  this._endFaceNormalAndHalfWidths = undefined;\n  this._vertexBatchIds = undefined;\n  this._indices = undefined;\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n  this._trianglesLength = 0;\n  this._geometryByteLength = 0;\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n}\nObject.defineProperties(Vector3DTileClampedPolylines.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileClampedPolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileClampedPolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n  /**\n   * Returns true when the primitive is ready to render.\n   * @memberof Vector3DTileClampedPolylines.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  }\n});\nfunction updateMinimumMaximumHeights(polylines, rectangle, ellipsoid) {\n  const result = ApproximateTerrainHeights.getMinimumMaximumHeights(rectangle, ellipsoid);\n  const min = result.minimumTerrainHeight;\n  const max = result.maximumTerrainHeight;\n  const minimumMaximumVectorHeights = polylines._minimumMaximumVectorHeights;\n  minimumMaximumVectorHeights.x = min;\n  minimumMaximumVectorHeights.y = max;\n  const obb = polylines._boundingVolume;\n  const rect = polylines._rectangle;\n  OrientedBoundingBox.fromRectangle(rect, min, max, ellipsoid, obb);\n}\nfunction packBuffer(polylines) {\n  const rectangle = polylines._rectangle;\n  const minimumHeight = polylines._minimumHeight;\n  const maximumHeight = polylines._maximumHeight;\n  const ellipsoid = polylines._ellipsoid;\n  const center = polylines._center;\n  const packedLength = 2 + Rectangle.packedLength + Ellipsoid.packedLength + Cartesian3.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n  Cartesian3.pack(center, packedBuffer, offset);\n  return packedBuffer;\n}\nconst createVerticesTaskProcessor = new TaskProcessor(\"createVectorTileClampedPolylines\");\nconst attributeLocations = {\n  startEllipsoidNormal: 0,\n  endEllipsoidNormal: 1,\n  startPositionAndHeight: 2,\n  endPositionAndHeight: 3,\n  startFaceNormalAndVertexCorner: 4,\n  endFaceNormalAndHalfWidth: 5,\n  a_batchId: 6\n};\nfunction createVertexArray(polylines, context) {\n  if (defined(polylines._va)) {\n    return;\n  }\n  let positions = polylines._positions;\n  let widths = polylines._widths;\n  let counts = polylines._counts;\n  let batchIds = polylines._transferrableBatchIds;\n  let packedBuffer = polylines._packedBuffer;\n  if (!defined(packedBuffer)) {\n    // Copy because they may be the views on the same buffer.\n    positions = polylines._positions = positions.slice();\n    widths = polylines._widths = widths.slice();\n    counts = polylines._counts = counts.slice();\n    batchIds = polylines._transferrableBatchIds = polylines._batchIds.slice();\n    packedBuffer = polylines._packedBuffer = packBuffer(polylines);\n  }\n  const transferrableObjects = [positions.buffer, widths.buffer, counts.buffer, batchIds.buffer, packedBuffer.buffer];\n  const parameters = {\n    positions: positions.buffer,\n    widths: widths.buffer,\n    counts: counts.buffer,\n    batchIds: batchIds.buffer,\n    packedBuffer: packedBuffer.buffer,\n    keepDecodedPositions: polylines._keepDecodedPositions\n  };\n  const verticesPromise = createVerticesTaskProcessor.scheduleTask(parameters, transferrableObjects);\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return;\n  }\n  return verticesPromise.then(function (result) {\n    if (polylines.isDestroyed()) {\n      return;\n    }\n    if (polylines._keepDecodedPositions) {\n      polylines._decodedPositions = new Float64Array(result.decodedPositions);\n      polylines._decodedPositionOffsets = new Uint32Array(result.decodedPositionOffsets);\n    }\n    polylines._startEllipsoidNormals = new Float32Array(result.startEllipsoidNormals);\n    polylines._endEllipsoidNormals = new Float32Array(result.endEllipsoidNormals);\n    polylines._startPositionAndHeights = new Float32Array(result.startPositionAndHeights);\n    polylines._startFaceNormalAndVertexCornerIds = new Float32Array(result.startFaceNormalAndVertexCornerIds);\n    polylines._endPositionAndHeights = new Float32Array(result.endPositionAndHeights);\n    polylines._endFaceNormalAndHalfWidths = new Float32Array(result.endFaceNormalAndHalfWidths);\n    polylines._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n    const indexDatatype = result.indexDatatype;\n    polylines._indices = indexDatatype === IndexDatatype.UNSIGNED_SHORT ? new Uint16Array(result.indices) : new Uint32Array(result.indices);\n    finishVertexArray(polylines, context);\n    polylines._ready = true;\n  }).catch(error => {\n    if (polylines.isDestroyed()) {\n      return;\n    }\n\n    // Throw the error next frame\n    polylines._error = error;\n  });\n}\nfunction finishVertexArray(polylines, context) {\n  if (!defined(polylines._va)) {\n    const startEllipsoidNormals = polylines._startEllipsoidNormals;\n    const endEllipsoidNormals = polylines._endEllipsoidNormals;\n    const startPositionAndHeights = polylines._startPositionAndHeights;\n    const endPositionAndHeights = polylines._endPositionAndHeights;\n    const startFaceNormalAndVertexCornerIds = polylines._startFaceNormalAndVertexCornerIds;\n    const endFaceNormalAndHalfWidths = polylines._endFaceNormalAndHalfWidths;\n    const batchIdAttribute = polylines._vertexBatchIds;\n    const indices = polylines._indices;\n    let byteLength = startEllipsoidNormals.byteLength + endEllipsoidNormals.byteLength;\n    byteLength += startPositionAndHeights.byteLength + endPositionAndHeights.byteLength;\n    byteLength += startFaceNormalAndVertexCornerIds.byteLength + endFaceNormalAndHalfWidths.byteLength;\n    byteLength += batchIdAttribute.byteLength + indices.byteLength;\n    polylines._trianglesLength = indices.length / 3;\n    polylines._geometryByteLength = byteLength;\n    const startEllipsoidNormalsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startEllipsoidNormals,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const endEllipsoidNormalsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endEllipsoidNormals,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const startPositionAndHeightsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startPositionAndHeights,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const endPositionAndHeightsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endPositionAndHeights,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const startFaceNormalAndVertexCornerIdsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startFaceNormalAndVertexCornerIds,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const endFaceNormalAndHalfWidthsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endFaceNormalAndHalfWidths,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const batchIdAttributeBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdAttribute,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: indices.BYTES_PER_ELEMENT === 2 ? IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT\n    });\n    const vertexAttributes = [{\n      index: attributeLocations.startEllipsoidNormal,\n      vertexBuffer: startEllipsoidNormalsBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      index: attributeLocations.endEllipsoidNormal,\n      vertexBuffer: endEllipsoidNormalsBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      index: attributeLocations.startPositionAndHeight,\n      vertexBuffer: startPositionAndHeightsBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4\n    }, {\n      index: attributeLocations.endPositionAndHeight,\n      vertexBuffer: endPositionAndHeightsBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4\n    }, {\n      index: attributeLocations.startFaceNormalAndVertexCorner,\n      vertexBuffer: startFaceNormalAndVertexCornerIdsBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4\n    }, {\n      index: attributeLocations.endFaceNormalAndHalfWidth,\n      vertexBuffer: endFaceNormalAndHalfWidthsBuffer,\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4\n    }, {\n      index: attributeLocations.a_batchId,\n      vertexBuffer: batchIdAttributeBuffer,\n      componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      componentsPerAttribute: 1\n    }];\n    polylines._va = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: indexBuffer\n    });\n    polylines._positions = undefined;\n    polylines._widths = undefined;\n    polylines._counts = undefined;\n    polylines._ellipsoid = undefined;\n    polylines._minimumHeight = undefined;\n    polylines._maximumHeight = undefined;\n    polylines._rectangle = undefined;\n    polylines._transferrableBatchIds = undefined;\n    polylines._packedBuffer = undefined;\n    polylines._startEllipsoidNormals = undefined;\n    polylines._endEllipsoidNormals = undefined;\n    polylines._startPositionAndHeights = undefined;\n    polylines._startFaceNormalAndVertexCornerIds = undefined;\n    polylines._endPositionAndHeights = undefined;\n    polylines._endFaceNormalAndHalfWidths = undefined;\n    polylines._vertexBatchIds = undefined;\n    polylines._indices = undefined;\n  }\n}\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n  primitive._uniformMap = {\n    u_modifiedModelView: function () {\n      const viewMatrix = context.uniformState.view;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive._center, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n    u_minimumMaximumVectorHeights: function () {\n      return primitive._minimumMaximumVectorHeights;\n    }\n  };\n}\nfunction getRenderState(mask3DTiles) {\n  /**\n   * Cull front faces of each volume (relative to camera) to prevent\n   * classification drawing from both the front and back faces, double-draw.\n   * The geometry is \"inverted\" (inside-out winding order for the indices) but\n   * the vertex shader seems to re-invert so that the triangles face \"out\" again.\n   * So cull FRONT faces.\n   */\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    }\n  });\n}\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rs)) {\n    return;\n  }\n  primitive._rs = getRenderState(false);\n  primitive._rs3DTiles = getRenderState(true);\n}\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n  const batchTable = primitive._batchTable;\n  const vsSource = batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(Vector3DTileClampedPolylinesVS);\n  const fsSource = batchTable.getFragmentShaderCallback(false, undefined, true)(Vector3DTileClampedPolylinesFS);\n  const vs = new ShaderSource({\n    defines: [\"VECTOR_TILE\", !FeatureDetection.isInternetExplorer() ? \"CLIP_POLYLINE\" : \"\"],\n    sources: [PolylineCommon, vsSource]\n  });\n  const fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\nfunction queueCommands(primitive, frameState) {\n  let command = primitive._command;\n  if (!defined(primitive._command)) {\n    const uniformMap = primitive._batchTable.getUniformMapCallback()(primitive._uniformMap);\n    command = primitive._command = new DrawCommand({\n      owner: primitive,\n      vertexArray: primitive._va,\n      renderState: primitive._rs,\n      shaderProgram: primitive._sp,\n      uniformMap: uniformMap,\n      boundingVolume: primitive._boundingVolume,\n      pass: Pass.TERRAIN_CLASSIFICATION,\n      pickId: primitive._batchTable.getPickId()\n    });\n    const derivedTilesetCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedTilesetCommand.renderState = primitive._rs3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n  }\n  const classificationType = primitive._classificationType;\n  if (classificationType === ClassificationType.TERRAIN || classificationType === ClassificationType.BOTH) {\n    frameState.commandList.push(command);\n  }\n  if (classificationType === ClassificationType.CESIUM_3D_TILE || classificationType === ClassificationType.BOTH) {\n    frameState.commandList.push(command.derivedCommands.tileset);\n  }\n}\n\n/**\n * Get the polyline positions for the given feature.\n *\n * @param {number} batchId The batch ID of the feature.\n */\nVector3DTileClampedPolylines.prototype.getPositions = function (batchId) {\n  return Vector3DTilePolylines.getPolylinePositions(this, batchId);\n};\n\n/**\n * Creates features for each polyline and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileClampedPolylines.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polyline batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileClampedPolylines.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n}\nconst scratchColor = new Color();\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The dictionary of features.\n */\nVector3DTileClampedPolylines.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n    feature.color = defined(style.color) ? style.color.evaluateColor(feature, scratchColor) : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show) ? style.show.evaluate(feature) : DEFAULT_SHOW_VALUE;\n  }\n};\nfunction initialize(polylines) {\n  return ApproximateTerrainHeights.initialize().then(function () {\n    updateMinimumMaximumHeights(polylines, polylines._rectangle, polylines._ellipsoid);\n  }).catch(error => {\n    if (polylines.isDestroyed()) {\n      return;\n    }\n\n    // Throw the error next frame\n    polylines._error = error;\n  });\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileClampedPolylines.prototype.update = function (frameState) {\n  const context = frameState.context;\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = initialize(this).then(createVertexArray(this, context));\n    }\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n    return;\n  }\n  createUniformMap(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    queueCommands(this, frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileClampedPolylines.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileClampedPolylines.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileClampedPolylines;","map":{"version":3,"names":["ApproximateTerrainHeights","Cartesian2","Cartesian3","Color","ComponentDatatype","defaultValue","defined","destroyObject","Ellipsoid","FeatureDetection","IndexDatatype","OrientedBoundingBox","Matrix4","Rectangle","TaskProcessor","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","PolylineCommon","Vector3DTileClampedPolylinesVS","Vector3DTileClampedPolylinesFS","BlendingState","Cesium3DTileFeature","ClassificationType","CullFace","StencilConstants","StencilFunction","StencilOperation","Vector3DTilePolylines","Vector3DTileClampedPolylines","options","_positions","positions","_widths","widths","_counts","counts","_batchIds","batchIds","_ellipsoid","ellipsoid","WGS84","_minimumHeight","minimumHeight","_maximumHeight","maximumHeight","_center","center","_rectangle","rectangle","_batchTable","batchTable","_va","undefined","_sp","_rs","_uniformMap","_command","_transferrableBatchIds","_packedBuffer","_minimumMaximumVectorHeights","_defaultMinTerrainHeight","_defaultMaxTerrainHeight","_boundingVolume","fromRectangle","_classificationType","classificationType","_keepDecodedPositions","keepDecodedPositions","_decodedPositions","_decodedPositionOffsets","_startEllipsoidNormals","_endEllipsoidNormals","_startPositionAndHeights","_startFaceNormalAndVertexCornerIds","_endPositionAndHeights","_endFaceNormalAndHalfWidths","_vertexBatchIds","_indices","_constantColor","clone","WHITE","_highlightColor","_trianglesLength","_geometryByteLength","_ready","_promise","_error","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","ready","updateMinimumMaximumHeights","polylines","result","getMinimumMaximumHeights","min","minimumTerrainHeight","max","maximumTerrainHeight","minimumMaximumVectorHeights","x","y","obb","rect","packBuffer","packedLength","packedBuffer","Float64Array","offset","pack","createVerticesTaskProcessor","attributeLocations","startEllipsoidNormal","endEllipsoidNormal","startPositionAndHeight","endPositionAndHeight","startFaceNormalAndVertexCorner","endFaceNormalAndHalfWidth","a_batchId","createVertexArray","context","slice","transferrableObjects","buffer","parameters","verticesPromise","scheduleTask","then","isDestroyed","decodedPositions","Uint32Array","decodedPositionOffsets","Float32Array","startEllipsoidNormals","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","Uint16Array","vertexBatchIds","indexDatatype","UNSIGNED_SHORT","indices","finishVertexArray","catch","error","batchIdAttribute","byteLength","length","startEllipsoidNormalsBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","endEllipsoidNormalsBuffer","startPositionAndHeightsBuffer","endPositionAndHeightsBuffer","startFaceNormalAndVertexCornerIdsBuffer","endFaceNormalAndHalfWidthsBuffer","batchIdAttributeBuffer","indexBuffer","createIndexBuffer","BYTES_PER_ELEMENT","UNSIGNED_INT","vertexAttributes","index","vertexBuffer","componentDatatype","FLOAT","componentsPerAttribute","attributes","modifiedModelViewScratch","rtcScratch","createUniformMap","primitive","u_modifiedModelView","viewMatrix","uniformState","view","multiplyByPoint","setTranslation","u_highlightColor","u_minimumMaximumVectorHeights","getRenderState","mask3DTiles","fromCache","cull","enabled","face","FRONT","blending","PRE_MULTIPLIED_ALPHA_BLEND","depthMask","stencilTest","frontFunction","EQUAL","frontOperation","fail","KEEP","zFail","zPass","backFunction","backOperation","reference","CESIUM_3D_TILE_MASK","mask","createRenderStates","_rs3DTiles","createShaders","vsSource","getVertexShaderCallback","fsSource","getFragmentShaderCallback","vs","defines","isInternetExplorer","sources","fs","vertexShaderSource","fragmentShaderSource","queueCommands","frameState","command","uniformMap","getUniformMapCallback","owner","vertexArray","renderState","shaderProgram","boundingVolume","pass","TERRAIN_CLASSIFICATION","pickId","getPickId","derivedTilesetCommand","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","TERRAIN","BOTH","commandList","push","CESIUM_3D_TILE","getPositions","batchId","getPolylinePositions","createFeatures","content","features","i","applyDebugSettings","color","clearStyle","polygons","feature","show","scratchColor","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","applyStyle","style","evaluateColor","evaluate","initialize","update","passes","render","pick","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Vector3DTileClampedPolylines.js"],"sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Vector3DTileClampedPolylinesVS from \"../Shaders/Vector3DTileClampedPolylinesVS.js\";\nimport Vector3DTileClampedPolylinesFS from \"../Shaders/Vector3DTileClampedPolylinesFS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\n\n/**\n * Creates a batch of polylines as volumes with shader-adjustable width.\n *\n * @alias Vector3DTileClampedPolylines\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polylines\n * @param {Uint32Array} options.counts The number or positions in the each polyline.\n * @param {Uint16Array} options.widths The width of each polyline.\n * @param {number} options.minimumHeight The minimum height of the tile's region.\n * @param {number} options.maximumHeight The maximum height of the tile's region.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polylines.\n * @param {Uint16Array} options.batchIds The batch ids for each polyline.\n * @param {ClassificationType} options.classificationType The classification type.\n * @param {boolean} options.keepDecodedPositions Whether to keep decoded positions in memory.\n *\n * @private\n */\nfunction Vector3DTileClampedPolylines(options) {\n  // these arrays hold data from the tile payload\n  // and are all released after the first update.\n  this._positions = options.positions;\n  this._widths = options.widths;\n  this._counts = options.counts;\n  this._batchIds = options.batchIds;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._center = options.center;\n  this._rectangle = options.rectangle;\n\n  this._batchTable = options.batchTable;\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._transferrableBatchIds = undefined;\n  this._packedBuffer = undefined;\n  this._minimumMaximumVectorHeights = new Cartesian2(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    ApproximateTerrainHeights._defaultMaxTerrainHeight,\n  );\n  this._boundingVolume = OrientedBoundingBox.fromRectangle(\n    options.rectangle,\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    ApproximateTerrainHeights._defaultMaxTerrainHeight,\n    this._ellipsoid,\n  );\n  this._classificationType = options.classificationType;\n\n  this._keepDecodedPositions = options.keepDecodedPositions;\n  this._decodedPositions = undefined;\n  this._decodedPositionOffsets = undefined;\n\n  // Fat vertices - all information for each volume packed to a vec3 and 5 vec4s\n  this._startEllipsoidNormals = undefined;\n  this._endEllipsoidNormals = undefined;\n  this._startPositionAndHeights = undefined;\n  this._startFaceNormalAndVertexCornerIds = undefined;\n  this._endPositionAndHeights = undefined;\n  this._endFaceNormalAndHalfWidths = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._indices = undefined;\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._trianglesLength = 0;\n  this._geometryByteLength = 0;\n\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n}\n\nObject.defineProperties(Vector3DTileClampedPolylines.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileClampedPolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileClampedPolylines.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Returns true when the primitive is ready to render.\n   * @memberof Vector3DTileClampedPolylines.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\nfunction updateMinimumMaximumHeights(polylines, rectangle, ellipsoid) {\n  const result = ApproximateTerrainHeights.getMinimumMaximumHeights(\n    rectangle,\n    ellipsoid,\n  );\n  const min = result.minimumTerrainHeight;\n  const max = result.maximumTerrainHeight;\n  const minimumMaximumVectorHeights = polylines._minimumMaximumVectorHeights;\n  minimumMaximumVectorHeights.x = min;\n  minimumMaximumVectorHeights.y = max;\n\n  const obb = polylines._boundingVolume;\n  const rect = polylines._rectangle;\n  OrientedBoundingBox.fromRectangle(rect, min, max, ellipsoid, obb);\n}\n\nfunction packBuffer(polylines) {\n  const rectangle = polylines._rectangle;\n  const minimumHeight = polylines._minimumHeight;\n  const maximumHeight = polylines._maximumHeight;\n  const ellipsoid = polylines._ellipsoid;\n  const center = polylines._center;\n\n  const packedLength =\n    2 +\n    Rectangle.packedLength +\n    Ellipsoid.packedLength +\n    Cartesian3.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.pack(center, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTileClampedPolylines\",\n);\nconst attributeLocations = {\n  startEllipsoidNormal: 0,\n  endEllipsoidNormal: 1,\n  startPositionAndHeight: 2,\n  endPositionAndHeight: 3,\n  startFaceNormalAndVertexCorner: 4,\n  endFaceNormalAndHalfWidth: 5,\n  a_batchId: 6,\n};\n\nfunction createVertexArray(polylines, context) {\n  if (defined(polylines._va)) {\n    return;\n  }\n\n  let positions = polylines._positions;\n  let widths = polylines._widths;\n  let counts = polylines._counts;\n  let batchIds = polylines._transferrableBatchIds;\n\n  let packedBuffer = polylines._packedBuffer;\n\n  if (!defined(packedBuffer)) {\n    // Copy because they may be the views on the same buffer.\n    positions = polylines._positions = positions.slice();\n    widths = polylines._widths = widths.slice();\n    counts = polylines._counts = counts.slice();\n\n    batchIds = polylines._transferrableBatchIds = polylines._batchIds.slice();\n\n    packedBuffer = polylines._packedBuffer = packBuffer(polylines);\n  }\n\n  const transferrableObjects = [\n    positions.buffer,\n    widths.buffer,\n    counts.buffer,\n    batchIds.buffer,\n    packedBuffer.buffer,\n  ];\n  const parameters = {\n    positions: positions.buffer,\n    widths: widths.buffer,\n    counts: counts.buffer,\n    batchIds: batchIds.buffer,\n    packedBuffer: packedBuffer.buffer,\n    keepDecodedPositions: polylines._keepDecodedPositions,\n  };\n\n  const verticesPromise = createVerticesTaskProcessor.scheduleTask(\n    parameters,\n    transferrableObjects,\n  );\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return;\n  }\n\n  return verticesPromise\n    .then(function (result) {\n      if (polylines.isDestroyed()) {\n        return;\n      }\n\n      if (polylines._keepDecodedPositions) {\n        polylines._decodedPositions = new Float64Array(result.decodedPositions);\n        polylines._decodedPositionOffsets = new Uint32Array(\n          result.decodedPositionOffsets,\n        );\n      }\n\n      polylines._startEllipsoidNormals = new Float32Array(\n        result.startEllipsoidNormals,\n      );\n      polylines._endEllipsoidNormals = new Float32Array(\n        result.endEllipsoidNormals,\n      );\n      polylines._startPositionAndHeights = new Float32Array(\n        result.startPositionAndHeights,\n      );\n      polylines._startFaceNormalAndVertexCornerIds = new Float32Array(\n        result.startFaceNormalAndVertexCornerIds,\n      );\n      polylines._endPositionAndHeights = new Float32Array(\n        result.endPositionAndHeights,\n      );\n      polylines._endFaceNormalAndHalfWidths = new Float32Array(\n        result.endFaceNormalAndHalfWidths,\n      );\n      polylines._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n\n      const indexDatatype = result.indexDatatype;\n      polylines._indices =\n        indexDatatype === IndexDatatype.UNSIGNED_SHORT\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n\n      finishVertexArray(polylines, context);\n      polylines._ready = true;\n    })\n    .catch((error) => {\n      if (polylines.isDestroyed()) {\n        return;\n      }\n\n      // Throw the error next frame\n      polylines._error = error;\n    });\n}\n\nfunction finishVertexArray(polylines, context) {\n  if (!defined(polylines._va)) {\n    const startEllipsoidNormals = polylines._startEllipsoidNormals;\n    const endEllipsoidNormals = polylines._endEllipsoidNormals;\n    const startPositionAndHeights = polylines._startPositionAndHeights;\n    const endPositionAndHeights = polylines._endPositionAndHeights;\n    const startFaceNormalAndVertexCornerIds =\n      polylines._startFaceNormalAndVertexCornerIds;\n    const endFaceNormalAndHalfWidths = polylines._endFaceNormalAndHalfWidths;\n    const batchIdAttribute = polylines._vertexBatchIds;\n\n    const indices = polylines._indices;\n\n    let byteLength =\n      startEllipsoidNormals.byteLength + endEllipsoidNormals.byteLength;\n    byteLength +=\n      startPositionAndHeights.byteLength + endPositionAndHeights.byteLength;\n    byteLength +=\n      startFaceNormalAndVertexCornerIds.byteLength +\n      endFaceNormalAndHalfWidths.byteLength;\n    byteLength += batchIdAttribute.byteLength + indices.byteLength;\n\n    polylines._trianglesLength = indices.length / 3;\n    polylines._geometryByteLength = byteLength;\n\n    const startEllipsoidNormalsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startEllipsoidNormals,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const endEllipsoidNormalsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endEllipsoidNormals,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const startPositionAndHeightsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startPositionAndHeights,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const endPositionAndHeightsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endPositionAndHeights,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const startFaceNormalAndVertexCornerIdsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startFaceNormalAndVertexCornerIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const endFaceNormalAndHalfWidthsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endFaceNormalAndHalfWidths,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const batchIdAttributeBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdAttribute,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype:\n        indices.BYTES_PER_ELEMENT === 2\n          ? IndexDatatype.UNSIGNED_SHORT\n          : IndexDatatype.UNSIGNED_INT,\n    });\n\n    const vertexAttributes = [\n      {\n        index: attributeLocations.startEllipsoidNormal,\n        vertexBuffer: startEllipsoidNormalsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.endEllipsoidNormal,\n        vertexBuffer: endEllipsoidNormalsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.startPositionAndHeight,\n        vertexBuffer: startPositionAndHeightsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.endPositionAndHeight,\n        vertexBuffer: endPositionAndHeightsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.startFaceNormalAndVertexCorner,\n        vertexBuffer: startFaceNormalAndVertexCornerIdsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.endFaceNormalAndHalfWidth,\n        vertexBuffer: endFaceNormalAndHalfWidthsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.a_batchId,\n        vertexBuffer: batchIdAttributeBuffer,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        componentsPerAttribute: 1,\n      },\n    ];\n\n    polylines._va = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: indexBuffer,\n    });\n\n    polylines._positions = undefined;\n    polylines._widths = undefined;\n    polylines._counts = undefined;\n\n    polylines._ellipsoid = undefined;\n    polylines._minimumHeight = undefined;\n    polylines._maximumHeight = undefined;\n    polylines._rectangle = undefined;\n\n    polylines._transferrableBatchIds = undefined;\n    polylines._packedBuffer = undefined;\n\n    polylines._startEllipsoidNormals = undefined;\n    polylines._endEllipsoidNormals = undefined;\n    polylines._startPositionAndHeights = undefined;\n    polylines._startFaceNormalAndVertexCornerIds = undefined;\n    polylines._endPositionAndHeights = undefined;\n    polylines._endFaceNormalAndHalfWidths = undefined;\n    polylines._vertexBatchIds = undefined;\n\n    polylines._indices = undefined;\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  primitive._uniformMap = {\n    u_modifiedModelView: function () {\n      const viewMatrix = context.uniformState.view;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch,\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch,\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n    u_minimumMaximumVectorHeights: function () {\n      return primitive._minimumMaximumVectorHeights;\n    },\n  };\n}\n\nfunction getRenderState(mask3DTiles) {\n  /**\n   * Cull front faces of each volume (relative to camera) to prevent\n   * classification drawing from both the front and back faces, double-draw.\n   * The geometry is \"inverted\" (inside-out winding order for the indices) but\n   * the vertex shader seems to re-invert so that the triangles face \"out\" again.\n   * So cull FRONT faces.\n   */\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT,\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n  });\n}\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rs)) {\n    return;\n  }\n\n  primitive._rs = getRenderState(false);\n  primitive._rs3DTiles = getRenderState(true);\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  const batchTable = primitive._batchTable;\n\n  const vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined,\n  )(Vector3DTileClampedPolylinesVS);\n  const fsSource = batchTable.getFragmentShaderCallback(\n    false,\n    undefined,\n    true,\n  )(Vector3DTileClampedPolylinesFS);\n\n  const vs = new ShaderSource({\n    defines: [\n      \"VECTOR_TILE\",\n      !FeatureDetection.isInternetExplorer() ? \"CLIP_POLYLINE\" : \"\",\n    ],\n    sources: [PolylineCommon, vsSource],\n  });\n  const fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction queueCommands(primitive, frameState) {\n  let command = primitive._command;\n  if (!defined(primitive._command)) {\n    const uniformMap = primitive._batchTable.getUniformMapCallback()(\n      primitive._uniformMap,\n    );\n    command = primitive._command = new DrawCommand({\n      owner: primitive,\n      vertexArray: primitive._va,\n      renderState: primitive._rs,\n      shaderProgram: primitive._sp,\n      uniformMap: uniformMap,\n      boundingVolume: primitive._boundingVolume,\n      pass: Pass.TERRAIN_CLASSIFICATION,\n      pickId: primitive._batchTable.getPickId(),\n    });\n\n    const derivedTilesetCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset,\n    );\n    derivedTilesetCommand.renderState = primitive._rs3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n  }\n\n  const classificationType = primitive._classificationType;\n  if (\n    classificationType === ClassificationType.TERRAIN ||\n    classificationType === ClassificationType.BOTH\n  ) {\n    frameState.commandList.push(command);\n  }\n  if (\n    classificationType === ClassificationType.CESIUM_3D_TILE ||\n    classificationType === ClassificationType.BOTH\n  ) {\n    frameState.commandList.push(command.derivedCommands.tileset);\n  }\n}\n\n/**\n * Get the polyline positions for the given feature.\n *\n * @param {number} batchId The batch ID of the feature.\n */\nVector3DTileClampedPolylines.prototype.getPositions = function (batchId) {\n  return Vector3DTilePolylines.getPolylinePositions(this, batchId);\n};\n\n/**\n * Creates features for each polyline and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileClampedPolylines.prototype.createFeatures = function (\n  content,\n  features,\n) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polyline batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileClampedPolylines.prototype.applyDebugSettings = function (\n  enabled,\n  color,\n) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n}\n\nconst scratchColor = new Color();\n\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The dictionary of features.\n */\nVector3DTileClampedPolylines.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n};\n\nfunction initialize(polylines) {\n  return ApproximateTerrainHeights.initialize()\n    .then(function () {\n      updateMinimumMaximumHeights(\n        polylines,\n        polylines._rectangle,\n        polylines._ellipsoid,\n      );\n    })\n    .catch((error) => {\n      if (polylines.isDestroyed()) {\n        return;\n      }\n\n      // Throw the error next frame\n      polylines._error = error;\n    });\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileClampedPolylines.prototype.update = function (frameState) {\n  const context = frameState.context;\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = initialize(this).then(createVertexArray(this, context));\n    }\n\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n\n    return;\n  }\n\n  createUniformMap(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    queueCommands(this, frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileClampedPolylines.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileClampedPolylines.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileClampedPolylines;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}