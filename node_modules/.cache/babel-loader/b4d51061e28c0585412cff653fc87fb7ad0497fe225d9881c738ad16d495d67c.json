{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding rectangle given by a corner, width and height.\n * @alias BoundingRectangle\n * @constructor\n *\n * @param {number} [x=0.0] The x coordinate of the rectangle.\n * @param {number} [y=0.0] The y coordinate of the rectangle.\n * @param {number} [width=0.0] The width of the rectangle.\n * @param {number} [height=0.0] The height of the rectangle.\n *\n * @see BoundingSphere\n * @see Packable\n */\nfunction BoundingRectangle(x, y, width, height) {\n  /**\n   * The x coordinate of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The y coordinate of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The width of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.width = defaultValue(width, 0.0);\n\n  /**\n   * The height of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.height = defaultValue(height, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoundingRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingRectangle} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoundingRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.width;\n  array[startingIndex] = value.height;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.width = array[startingIndex++];\n  result.height = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes a bounding rectangle enclosing the list of 2D points.\n * The rectangle is oriented with the corner at the bottom left.\n *\n * @param {Cartesian2[]} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  if (!defined(positions) || positions.length === 0) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n  const length = positions.length;\n  let minimumX = positions[0].x;\n  let minimumY = positions[0].y;\n  let maximumX = positions[0].x;\n  let maximumY = positions[0].y;\n  for (let i = 1; i < length; i++) {\n    const p = positions[i];\n    const x = p.x;\n    const y = p.y;\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n  }\n  result.x = minimumX;\n  result.y = minimumY;\n  result.width = maximumX - minimumX;\n  result.height = maximumY - minimumY;\n  return result;\n};\nconst defaultProjection = new GeographicProjection();\nconst fromRectangleLowerLeft = new Cartographic();\nconst fromRectangleUpperRight = new Cartographic();\n/**\n * Computes a bounding rectangle from a rectangle.\n *\n * @param {Rectangle} rectangle The valid rectangle used to create a bounding rectangle.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromRectangle = function (rectangle, projection, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n  defaultProjection._ellipsoid = Ellipsoid.default;\n  projection = defaultValue(projection, defaultProjection);\n  const lowerLeft = projection.project(Rectangle.southwest(rectangle, fromRectangleLowerLeft));\n  const upperRight = projection.project(Rectangle.northeast(rectangle, fromRectangleUpperRight));\n  Cartesian2.subtract(upperRight, lowerLeft, upperRight);\n  result.x = lowerLeft.x;\n  result.y = lowerLeft.y;\n  result.width = upperRight.x;\n  result.height = upperRight.y;\n  return result;\n};\n\n/**\n * Duplicates a BoundingRectangle instance.\n *\n * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)\n */\nBoundingRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new BoundingRectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n  }\n  result.x = rectangle.x;\n  result.y = rectangle.y;\n  result.width = rectangle.width;\n  result.height = rectangle.height;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle that is the union of the left and right bounding rectangles.\n *\n * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.\n * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  const lowerLeftX = Math.min(left.x, right.x);\n  const lowerLeftY = Math.min(left.y, right.y);\n  const upperRightX = Math.max(left.x + left.width, right.x + right.width);\n  const upperRightY = Math.max(left.y + left.height, right.y + right.height);\n  result.x = lowerLeftX;\n  result.y = lowerLeftY;\n  result.width = upperRightX - lowerLeftX;\n  result.height = upperRightY - lowerLeftY;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.\n *\n * @param {BoundingRectangle} rectangle A rectangle to expand.\n * @param {Cartesian2} point A point to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.expand = function (rectangle, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingRectangle.clone(rectangle, result);\n  const width = point.x - result.x;\n  const height = point.y - result.y;\n  if (width > result.width) {\n    result.width = width;\n  } else if (width < 0) {\n    result.width -= width;\n    result.x = point.x;\n  }\n  if (height > result.height) {\n    result.height = height;\n  } else if (height < 0) {\n    result.height -= height;\n    result.y = point.y;\n  }\n  return result;\n};\n\n/**\n * Determines if two rectangles intersect.\n *\n * @param {BoundingRectangle} left A rectangle to check for intersection.\n * @param {BoundingRectangle} right The other rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.intersect = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const rightX = right.x;\n  const rightY = right.y;\n  if (!(leftX > rightX + right.width || leftX + left.width < rightX || leftY + left.height < rightY || leftY > rightY + right.height)) {\n    return Intersect.INTERSECTING;\n  }\n  return Intersect.OUTSIDE;\n};\n\n/**\n * Compares the provided BoundingRectangles componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [left] The first BoundingRectangle.\n * @param {BoundingRectangle} [right] The second BoundingRectangle.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.width === right.width && left.height === right.height;\n};\n\n/**\n * Duplicates this BoundingRectangle instance.\n *\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.prototype.clone = function (result) {\n  return BoundingRectangle.clone(this, result);\n};\n\n/**\n * Determines if this rectangle intersects with another.\n *\n * @param {BoundingRectangle} right A rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.prototype.intersect = function (right) {\n  return BoundingRectangle.intersect(this, right);\n};\n\n/**\n * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.prototype.equals = function (right) {\n  return BoundingRectangle.equals(this, right);\n};\nexport default BoundingRectangle;","map":{"version":3,"names":["Cartesian2","Cartographic","Check","defaultValue","defined","Ellipsoid","GeographicProjection","Intersect","Rectangle","BoundingRectangle","x","y","width","height","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","fromPoints","positions","length","minimumX","minimumY","maximumX","maximumY","i","p","Math","min","max","defaultProjection","fromRectangleLowerLeft","fromRectangleUpperRight","fromRectangle","rectangle","projection","_ellipsoid","default","lowerLeft","project","southwest","upperRight","northeast","subtract","clone","undefined","union","left","right","lowerLeftX","lowerLeftY","upperRightX","upperRightY","expand","point","intersect","leftX","leftY","rightX","rightY","INTERSECTING","OUTSIDE","equals","prototype"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/BoundingRectangle.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding rectangle given by a corner, width and height.\n * @alias BoundingRectangle\n * @constructor\n *\n * @param {number} [x=0.0] The x coordinate of the rectangle.\n * @param {number} [y=0.0] The y coordinate of the rectangle.\n * @param {number} [width=0.0] The width of the rectangle.\n * @param {number} [height=0.0] The height of the rectangle.\n *\n * @see BoundingSphere\n * @see Packable\n */\nfunction BoundingRectangle(x, y, width, height) {\n  /**\n   * The x coordinate of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The y coordinate of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The width of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.width = defaultValue(width, 0.0);\n\n  /**\n   * The height of the rectangle.\n   * @type {number}\n   * @default 0.0\n   */\n  this.height = defaultValue(height, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoundingRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingRectangle} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoundingRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.width;\n  array[startingIndex] = value.height;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.width = array[startingIndex++];\n  result.height = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes a bounding rectangle enclosing the list of 2D points.\n * The rectangle is oriented with the corner at the bottom left.\n *\n * @param {Cartesian2[]} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  const length = positions.length;\n\n  let minimumX = positions[0].x;\n  let minimumY = positions[0].y;\n\n  let maximumX = positions[0].x;\n  let maximumY = positions[0].y;\n\n  for (let i = 1; i < length; i++) {\n    const p = positions[i];\n    const x = p.x;\n    const y = p.y;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n  }\n\n  result.x = minimumX;\n  result.y = minimumY;\n  result.width = maximumX - minimumX;\n  result.height = maximumY - minimumY;\n  return result;\n};\n\nconst defaultProjection = new GeographicProjection();\nconst fromRectangleLowerLeft = new Cartographic();\nconst fromRectangleUpperRight = new Cartographic();\n/**\n * Computes a bounding rectangle from a rectangle.\n *\n * @param {Rectangle} rectangle The valid rectangle used to create a bounding rectangle.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.fromRectangle = function (rectangle, projection, result) {\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n\n  defaultProjection._ellipsoid = Ellipsoid.default;\n  projection = defaultValue(projection, defaultProjection);\n\n  const lowerLeft = projection.project(\n    Rectangle.southwest(rectangle, fromRectangleLowerLeft),\n  );\n  const upperRight = projection.project(\n    Rectangle.northeast(rectangle, fromRectangleUpperRight),\n  );\n\n  Cartesian2.subtract(upperRight, lowerLeft, upperRight);\n\n  result.x = lowerLeft.x;\n  result.y = lowerLeft.y;\n  result.width = upperRight.x;\n  result.height = upperRight.y;\n  return result;\n};\n\n/**\n * Duplicates a BoundingRectangle instance.\n *\n * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)\n */\nBoundingRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingRectangle(\n      rectangle.x,\n      rectangle.y,\n      rectangle.width,\n      rectangle.height,\n    );\n  }\n\n  result.x = rectangle.x;\n  result.y = rectangle.y;\n  result.width = rectangle.width;\n  result.height = rectangle.height;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle that is the union of the left and right bounding rectangles.\n *\n * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.\n * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  const lowerLeftX = Math.min(left.x, right.x);\n  const lowerLeftY = Math.min(left.y, right.y);\n  const upperRightX = Math.max(left.x + left.width, right.x + right.width);\n  const upperRightY = Math.max(left.y + left.height, right.y + right.height);\n\n  result.x = lowerLeftX;\n  result.y = lowerLeftY;\n  result.width = upperRightX - lowerLeftX;\n  result.height = upperRightY - lowerLeftY;\n  return result;\n};\n\n/**\n * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.\n *\n * @param {BoundingRectangle} rectangle A rectangle to expand.\n * @param {Cartesian2} point A point to enclose in a bounding rectangle.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.expand = function (rectangle, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingRectangle.clone(rectangle, result);\n\n  const width = point.x - result.x;\n  const height = point.y - result.y;\n\n  if (width > result.width) {\n    result.width = width;\n  } else if (width < 0) {\n    result.width -= width;\n    result.x = point.x;\n  }\n\n  if (height > result.height) {\n    result.height = height;\n  } else if (height < 0) {\n    result.height -= height;\n    result.y = point.y;\n  }\n\n  return result;\n};\n\n/**\n * Determines if two rectangles intersect.\n *\n * @param {BoundingRectangle} left A rectangle to check for intersection.\n * @param {BoundingRectangle} right The other rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.intersect = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const rightX = right.x;\n  const rightY = right.y;\n  if (\n    !(\n      leftX > rightX + right.width ||\n      leftX + left.width < rightX ||\n      leftY + left.height < rightY ||\n      leftY > rightY + right.height\n    )\n  ) {\n    return Intersect.INTERSECTING;\n  }\n\n  return Intersect.OUTSIDE;\n};\n\n/**\n * Compares the provided BoundingRectangles componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [left] The first BoundingRectangle.\n * @param {BoundingRectangle} [right] The second BoundingRectangle.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.width === right.width &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Duplicates this BoundingRectangle instance.\n *\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBoundingRectangle.prototype.clone = function (result) {\n  return BoundingRectangle.clone(this, result);\n};\n\n/**\n * Determines if this rectangle intersects with another.\n *\n * @param {BoundingRectangle} right A rectangle to check for intersection.\n * @returns {Intersect} <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.\n */\nBoundingRectangle.prototype.intersect = function (right) {\n  return BoundingRectangle.intersect(this, right);\n};\n\n/**\n * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingRectangle.prototype.equals = function (right) {\n  return BoundingRectangle.equals(this, right);\n};\nexport default BoundingRectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}