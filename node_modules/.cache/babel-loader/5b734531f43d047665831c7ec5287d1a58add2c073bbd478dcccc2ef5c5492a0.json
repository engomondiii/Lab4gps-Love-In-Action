{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BatchTexture from \"./BatchTexture.js\";\nimport BatchTableHierarchy from \"./BatchTableHierarchy.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileColorBlendMode from \"./Cesium3DTileColorBlendMode.js\";\nimport CullFace from \"./CullFace.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nconst DEFAULT_COLOR_VALUE = BatchTexture.DEFAULT_COLOR_VALUE;\nconst DEFAULT_SHOW_VALUE = BatchTexture.DEFAULT_SHOW_VALUE;\n\n/**\n * @private\n * @constructor\n */\nfunction Cesium3DTileBatchTable(content, featuresLength, batchTableJson, batchTableBinary, colorChangedCallback) {\n  /**\n   * @readonly\n   */\n  this.featuresLength = featuresLength;\n  let extensions;\n  if (defined(batchTableJson)) {\n    extensions = batchTableJson.extensions;\n  }\n  this._extensions = defaultValue(extensions, {});\n  const properties = initializeProperties(batchTableJson);\n  this._properties = properties;\n  this._batchTableHierarchy = initializeHierarchy(this, batchTableJson, batchTableBinary);\n  const binaryProperties = getBinaryProperties(featuresLength, properties, batchTableBinary);\n  this._binaryPropertiesByteLength = countBinaryPropertyMemory(binaryProperties);\n  this._batchTableBinaryProperties = binaryProperties;\n  this._content = content;\n  this._batchTexture = new BatchTexture({\n    featuresLength: featuresLength,\n    colorChangedCallback: colorChangedCallback,\n    owner: content,\n    statistics: content.tileset.statistics\n  });\n}\n\n// This can be overridden for testing purposes\nCesium3DTileBatchTable._deprecationWarning = deprecationWarning;\nObject.defineProperties(Cesium3DTileBatchTable.prototype, {\n  /**\n   * Size of the batch table, including the batch table hierarchy's binary\n   * buffers and any binary properties. JSON data is not counted.\n   *\n   * @memberof Cesium3DTileBatchTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  batchTableByteLength: {\n    get: function () {\n      let totalByteLength = this._binaryPropertiesByteLength;\n      if (defined(this._batchTableHierarchy)) {\n        totalByteLength += this._batchTableHierarchy.byteLength;\n      }\n      totalByteLength += this._batchTexture.byteLength;\n      return totalByteLength;\n    }\n  }\n});\nfunction initializeProperties(jsonHeader) {\n  const properties = {};\n  if (!defined(jsonHeader)) {\n    return properties;\n  }\n  for (const propertyName in jsonHeader) {\n    if (jsonHeader.hasOwnProperty(propertyName) && propertyName !== \"HIERARCHY\" &&\n    // Deprecated HIERARCHY property\n    propertyName !== \"extensions\" && propertyName !== \"extras\") {\n      properties[propertyName] = clone(jsonHeader[propertyName], true);\n    }\n  }\n  return properties;\n}\nfunction initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!defined(jsonHeader)) {\n    return;\n  }\n  let hierarchy = batchTable._extensions[\"3DTILES_batch_table_hierarchy\"];\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (defined(legacyHierarchy)) {\n    Cesium3DTileBatchTable._deprecationWarning(\"batchTableHierarchyExtension\", \"The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead.\");\n    batchTable._extensions[\"3DTILES_batch_table_hierarchy\"] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n  if (!defined(hierarchy)) {\n    return;\n  }\n  return new BatchTableHierarchy({\n    extension: hierarchy,\n    binaryBody: binaryBody\n  });\n}\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  let binaryProperties;\n  for (const name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      const property = properties[name];\n      const byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        const componentType = property.componentType;\n        const type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(`Property ${name} requires a batch table binary.`);\n        }\n        const binaryAccessor = getBinaryAccessor(property);\n        const componentCount = binaryAccessor.componentsPerAttribute;\n        const classType = binaryAccessor.classType;\n        const typedArray = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + byteOffset, featuresLength);\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\nfunction countBinaryPropertyMemory(binaryProperties) {\n  if (!defined(binaryProperties)) {\n    return 0;\n  }\n  let byteLength = 0;\n  for (const name in binaryProperties) {\n    if (binaryProperties.hasOwnProperty(name)) {\n      byteLength += binaryProperties[name].typedArray.byteLength;\n    }\n  }\n  return byteLength;\n}\nCesium3DTileBatchTable.getBinaryProperties = function (featuresLength, batchTableJson, batchTableBinary) {\n  return getBinaryProperties(featuresLength, batchTableJson, batchTableBinary);\n};\nCesium3DTileBatchTable.prototype.setShow = function (batchId, show) {\n  this._batchTexture.setShow(batchId, show);\n};\nCesium3DTileBatchTable.prototype.setAllShow = function (show) {\n  this._batchTexture.setAllShow(show);\n};\nCesium3DTileBatchTable.prototype.getShow = function (batchId) {\n  return this._batchTexture.getShow(batchId);\n};\nCesium3DTileBatchTable.prototype.setColor = function (batchId, color) {\n  this._batchTexture.setColor(batchId, color);\n};\nCesium3DTileBatchTable.prototype.setAllColor = function (color) {\n  this._batchTexture.setAllColor(color);\n};\nCesium3DTileBatchTable.prototype.getColor = function (batchId, result) {\n  return this._batchTexture.getColor(batchId, result);\n};\nCesium3DTileBatchTable.prototype.getPickColor = function (batchId) {\n  return this._batchTexture.getPickColor(batchId);\n};\nconst scratchColor = new Color();\nCesium3DTileBatchTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(DEFAULT_COLOR_VALUE);\n    this.setAllShow(DEFAULT_SHOW_VALUE);\n    return;\n  }\n  const content = this._content;\n  const length = this.featuresLength;\n  for (let i = 0; i < length; ++i) {\n    const feature = content.getFeature(i);\n    const color = defined(style.color) ? defaultValue(style.color.evaluateColor(feature, scratchColor), DEFAULT_COLOR_VALUE) : DEFAULT_COLOR_VALUE;\n    const show = defined(style.show) ? defaultValue(style.show.evaluate(feature), DEFAULT_SHOW_VALUE) : DEFAULT_SHOW_VALUE;\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(`batchId is required and must be between zero and featuresLength - 1 (${featuresLength}` - +\").\");\n  }\n}\nCesium3DTileBatchTable.prototype.isClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return false;\n  }\n  return hierarchy.isClass(batchId, className);\n};\nCesium3DTileBatchTable.prototype.isExactClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  return this.getExactClassName(batchId) === className;\n};\nCesium3DTileBatchTable.prototype.getExactClassName = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n  return hierarchy.getClassName(batchId);\n};\nCesium3DTileBatchTable.prototype.hasProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  return defined(this._properties[name]) || defined(this._batchTableHierarchy) && this._batchTableHierarchy.hasProperty(batchId, name);\n};\n\n/**\n * @private\n */\nCesium3DTileBatchTable.prototype.hasPropertyBySemantic = function () {\n  // Cesium 3D Tiles 1.0 formats do not have semantics\n  return false;\n};\nCesium3DTileBatchTable.prototype.getPropertyIds = function (batchId, results) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n  const scratchPropertyIds = Object.keys(this._properties);\n  results.push.apply(results, scratchPropertyIds);\n  if (defined(this._batchTableHierarchy)) {\n    results.push.apply(results, this._batchTableHierarchy.getPropertyIds(batchId, scratchPropertyIds));\n  }\n  return results;\n};\n\n/**\n * @private\n */\nCesium3DTileBatchTable.prototype.getPropertyBySemantic = function (batchId, name) {\n  // Cesium 3D Tiles 1.0 formats do not have semantics\n  return undefined;\n};\nCesium3DTileBatchTable.prototype.getProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    const binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      return getBinaryProperty(binaryProperty, batchId);\n    }\n  }\n  const propertyValues = this._properties[name];\n  if (defined(propertyValues)) {\n    return clone(propertyValues[batchId], true);\n  }\n  if (defined(this._batchTableHierarchy)) {\n    const hierarchyProperty = this._batchTableHierarchy.getProperty(batchId, name);\n    if (defined(hierarchyProperty)) {\n      return hierarchyProperty;\n    }\n  }\n  return undefined;\n};\nCesium3DTileBatchTable.prototype.setProperty = function (batchId, name, value) {\n  const featuresLength = this.featuresLength;\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    const binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      setBinaryProperty(binaryProperty, batchId, value);\n      return;\n    }\n  }\n  if (defined(this._batchTableHierarchy)) {\n    if (this._batchTableHierarchy.setProperty(batchId, name, value)) {\n      return;\n    }\n  }\n  let propertyValues = this._properties[name];\n  if (!defined(propertyValues)) {\n    // Property does not exist. Create it.\n    this._properties[name] = new Array(featuresLength);\n    propertyValues = this._properties[name];\n  }\n  propertyValues[batchId] = clone(value, true);\n};\nfunction getGlslComputeSt(batchTable) {\n  // GLSL batchId is zero-based: [0, featuresLength - 1]\n  if (batchTable._batchTexture.textureDimensions.y === 1) {\n    return \"uniform vec4 tile_textureStep; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = tile_textureStep.x; \\n\" + \"    float centerX = tile_textureStep.y; \\n\" + \"    return vec2(centerX + (batchId * stepX), 0.5); \\n\" + \"} \\n\";\n  }\n  return \"uniform vec4 tile_textureStep; \\n\" + \"uniform vec2 tile_textureDimensions; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = tile_textureStep.x; \\n\" + \"    float centerX = tile_textureStep.y; \\n\" + \"    float stepY = tile_textureStep.z; \\n\" + \"    float centerY = tile_textureStep.w; \\n\" + \"    float xId = mod(batchId, tile_textureDimensions.x); \\n\" + \"    float yId = floor(batchId / tile_textureDimensions.x); \\n\" + \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" + \"} \\n\";\n}\nCesium3DTileBatchTable.prototype.getVertexShaderCallback = function (handleTranslucent, batchIdAttributeName, diffuseAttributeOrUniformName) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  const that = this;\n  return function (source) {\n    // If the color blend mode is HIGHLIGHT, the highlight color will always be applied in the fragment shader.\n    // No need to apply the highlight color in the vertex shader as well.\n    const renamedSource = modifyDiffuse(source, diffuseAttributeOrUniformName, false);\n    let newMain;\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, perform per-feature show/hide in the vertex shader\n      newMain = \"\";\n      if (handleTranslucent) {\n        newMain += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      newMain += `${\"uniform sampler2D tile_batchTexture; \\n\" + \"out vec4 tile_featureColor; \\n\" + \"out vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 st = computeSt(\"}${batchIdAttributeName}); \\n` + `    vec4 featureProperties = texture(tile_batchTexture, st); \\n` + `    tile_color(featureProperties); \\n` + `    float show = ceil(featureProperties.a); \\n` +\n      // 0 - false, non-zero - true\n      `    gl_Position *= show; \\n`; // Per-feature show/hide\n      if (handleTranslucent) {\n        newMain += \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" + \"    if (czm_pass == czm_passTranslucent) \\n\" + \"    { \\n\" + \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" +\n        // Do not render opaque features in the translucent pass\n        \"        { \\n\" + \"            gl_Position *= 0.0; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        if (isStyleTranslucent) \\n\" +\n        // Do not render translucent features in the opaque pass\n        \"        { \\n\" + \"            gl_Position *= 0.0; \\n\" + \"        } \\n\" + \"    } \\n\";\n      }\n      newMain += \"    tile_featureColor = featureProperties; \\n\" + \"    tile_featureSt = st; \\n\" + \"}\";\n    } else {\n      // When VTF is not supported, color blend mode MIX will look incorrect due to the feature's color not being available in the vertex shader\n      newMain = `${\"out vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_color(vec4(1.0)); \\n\" + \"    tile_featureSt = computeSt(\"}${batchIdAttributeName}); \\n` + `}`;\n    }\n    return `${renamedSource}\\n${getGlslComputeSt(that)}${newMain}`;\n  };\n};\nfunction getDefaultShader(source, applyHighlight) {\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n  if (!applyHighlight) {\n    return `${source}void tile_color(vec4 tile_featureColor) \\n` + `{ \\n` + `    tile_main(); \\n` + `} \\n`;\n  }\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // out_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  return `${source}uniform float tile_colorBlend; \\n` + `void tile_color(vec4 tile_featureColor) \\n` + `{ \\n` + `    tile_main(); \\n` + `    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n` + `    out_FragColor.a *= tile_featureColor.a; \\n` + `    float highlight = ceil(tile_colorBlend); \\n` + `    out_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n` + `} \\n`;\n}\nfunction replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName) {\n  const functionCall = `texture(${diffuseAttributeOrUniformName}`;\n  let fromIndex = 0;\n  let startIndex = source.indexOf(functionCall, fromIndex);\n  let endIndex;\n  while (startIndex > -1) {\n    let nestedLevel = 0;\n    for (let i = startIndex; i < source.length; ++i) {\n      const character = source.charAt(i);\n      if (character === \"(\") {\n        ++nestedLevel;\n      } else if (character === \")\") {\n        --nestedLevel;\n        if (nestedLevel === 0) {\n          endIndex = i + 1;\n          break;\n        }\n      }\n    }\n    const extractedFunction = source.slice(startIndex, endIndex);\n    const replacedFunction = `tile_diffuse_final(${extractedFunction}, tile_diffuse)`;\n    source = source.slice(0, startIndex) + replacedFunction + source.slice(endIndex);\n    fromIndex = startIndex + replacedFunction.length;\n    startIndex = source.indexOf(functionCall, fromIndex);\n  }\n  return source;\n}\nfunction modifyDiffuse(source, diffuseAttributeOrUniformName, applyHighlight) {\n  // If the glTF does not specify the _3DTILESDIFFUSE semantic, return the default shader.\n  // Otherwise if _3DTILESDIFFUSE is defined prefer the shader below that can switch the color mode at runtime.\n  if (!defined(diffuseAttributeOrUniformName)) {\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  // Find the diffuse uniform. Examples matches:\n  //   uniform vec3 u_diffuseColor;\n  //   uniform sampler2D diffuseTexture;\n  let regex = new RegExp(`(uniform|attribute|in)\\\\s+(vec[34]|sampler2D)\\\\s+${diffuseAttributeOrUniformName};`);\n  const uniformMatch = source.match(regex);\n  if (!defined(uniformMatch)) {\n    // Could not find uniform declaration of type vec3, vec4, or sampler2D\n    return getDefaultShader(source, applyHighlight);\n  }\n  const declaration = uniformMatch[0];\n  const type = uniformMatch[2];\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n  source = source.replace(declaration, \"\"); // Remove uniform declaration for now so the replace below doesn't affect it\n\n  // If the tile color is white, use the source color. This implies the feature has not been styled.\n  // Highlight: tile_colorBlend is 0.0 and the source color is used\n  // Replace: tile_colorBlend is 1.0 and the tile color is used\n  // Mix: tile_colorBlend is between 0.0 and 1.0, causing the source color and tile color to mix\n  const finalDiffuseFunction = \"bool isWhite(vec3 color) \\n\" + \"{ \\n\" + \"    return all(greaterThan(color, vec3(1.0 - czm_epsilon3))); \\n\" + \"} \\n\" + \"vec4 tile_diffuse_final(vec4 sourceDiffuse, vec4 tileDiffuse) \\n\" + \"{ \\n\" + \"    vec4 blendDiffuse = mix(sourceDiffuse, tileDiffuse, tile_colorBlend); \\n\" + \"    vec4 diffuse = isWhite(tileDiffuse.rgb) ? sourceDiffuse : blendDiffuse; \\n\" + \"    return vec4(diffuse.rgb, sourceDiffuse.a); \\n\" + \"} \\n\";\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // out_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  const highlight = \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" + \"    out_FragColor.a *= tile_featureColor.a; \\n\" + \"    float highlight = ceil(tile_colorBlend); \\n\" + \"    out_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\";\n  let setColor;\n  if (type === \"vec3\" || type === \"vec4\") {\n    const sourceDiffuse = type === \"vec3\" ? `vec4(${diffuseAttributeOrUniformName}, 1.0)` : diffuseAttributeOrUniformName;\n    const replaceDiffuse = type === \"vec3\" ? \"tile_diffuse.xyz\" : \"tile_diffuse\";\n    regex = new RegExp(diffuseAttributeOrUniformName, \"g\");\n    source = source.replace(regex, replaceDiffuse);\n    setColor = `    vec4 source = ${sourceDiffuse}; \\n` + `    tile_diffuse = tile_diffuse_final(source, tile_featureColor); \\n` + `    tile_main(); \\n`;\n  } else if (type === \"sampler2D\") {\n    // Handles any number of nested parentheses\n    // E.g. texture(u_diffuse, uv)\n    // E.g. texture(u_diffuse, computeUV(index))\n    source = replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName);\n    setColor = \"    tile_diffuse = tile_featureColor; \\n\" + \"    tile_main(); \\n\";\n  }\n  source = `${\"uniform float tile_colorBlend; \\n\" + \"vec4 tile_diffuse = vec4(1.0); \\n\"}${finalDiffuseFunction}${declaration}\\n${source}\\n` + `void tile_color(vec4 tile_featureColor) \\n` + `{ \\n${setColor}`;\n  if (applyHighlight) {\n    source += highlight;\n  }\n  source += \"} \\n\";\n  return source;\n}\nCesium3DTileBatchTable.prototype.getFragmentShaderCallback = function (handleTranslucent, diffuseAttributeOrUniformName, hasPremultipliedAlpha) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = modifyDiffuse(source, diffuseAttributeOrUniformName, true);\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source += \"uniform sampler2D tile_pickTexture; \\n\" + \"in vec2 tile_featureSt; \\n\" + \"in vec4 tile_featureColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_color(tile_featureColor); \\n\";\n      if (hasPremultipliedAlpha) {\n        source += \"    out_FragColor.rgb *= out_FragColor.a; \\n\";\n      }\n      source += \"}\";\n    } else {\n      if (handleTranslucent) {\n        source += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      source += \"uniform sampler2D tile_pickTexture; \\n\" + \"uniform sampler2D tile_batchTexture; \\n\" + \"in vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec4 featureProperties = texture(tile_batchTexture, tile_featureSt); \\n\" + \"    if (featureProperties.a == 0.0) { \\n\" +\n      // show: alpha == 0 - false, non-zeo - true\n      \"        discard; \\n\" + \"    } \\n\";\n      if (handleTranslucent) {\n        source += \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" + \"    if (czm_pass == czm_passTranslucent) \\n\" + \"    { \\n\" + \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" +\n        // Do not render opaque features in the translucent pass\n        \"        { \\n\" + \"            discard; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        if (isStyleTranslucent) \\n\" +\n        // Do not render translucent features in the opaque pass\n        \"        { \\n\" + \"            discard; \\n\" + \"        } \\n\" + \"    } \\n\";\n      }\n      source += \"    tile_color(featureProperties); \\n\";\n      if (hasPremultipliedAlpha) {\n        source += \"    out_FragColor.rgb *= out_FragColor.a; \\n\";\n      }\n      source += \"} \\n\";\n    }\n    return source;\n  };\n};\nCesium3DTileBatchTable.prototype.getClassificationFragmentShaderCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = ShaderSource.replaceMain(source, \"tile_main\");\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source += \"uniform sampler2D tile_pickTexture;\\n\" + \"in vec2 tile_featureSt; \\n\" + \"in vec4 tile_featureColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_main(); \\n\" + \"    out_FragColor = tile_featureColor; \\n\" + \"    out_FragColor.rgb *= out_FragColor.a; \\n\" + \"}\";\n    } else {\n      source += \"uniform sampler2D tile_batchTexture; \\n\" + \"uniform sampler2D tile_pickTexture;\\n\" + \"in vec2 tile_featureSt; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    tile_main(); \\n\" + \"    vec4 featureProperties = texture(tile_batchTexture, tile_featureSt); \\n\" + \"    if (featureProperties.a == 0.0) { \\n\" +\n      // show: alpha == 0 - false, non-zero - true\n      \"        discard; \\n\" + \"    } \\n\" + \"    out_FragColor = featureProperties; \\n\" + \"    out_FragColor.rgb *= out_FragColor.a; \\n\" + \"} \\n\";\n    }\n    return source;\n  };\n};\nfunction getColorBlend(batchTable) {\n  const tileset = batchTable._content.tileset;\n  const colorBlendMode = tileset.colorBlendMode;\n  const colorBlendAmount = tileset.colorBlendAmount;\n  if (colorBlendMode === Cesium3DTileColorBlendMode.HIGHLIGHT) {\n    return 0.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.REPLACE) {\n    return 1.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.MIX) {\n    // The value 0.0 is reserved for highlight, so clamp to just above 0.0.\n    return CesiumMath.clamp(colorBlendAmount, CesiumMath.EPSILON4, 1.0);\n  }\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(`Invalid color blend mode \"${colorBlendMode}\".`);\n  //>>includeEnd('debug');\n}\nCesium3DTileBatchTable.prototype.getUniformMapCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  const that = this;\n  return function (uniformMap) {\n    const batchUniformMap = {\n      tile_batchTexture: function () {\n        // PERFORMANCE_IDEA: we could also use a custom shader that avoids the texture read.\n        return defaultValue(that._batchTexture.batchTexture, that._batchTexture.defaultTexture);\n      },\n      tile_textureDimensions: function () {\n        return that._batchTexture.textureDimensions;\n      },\n      tile_textureStep: function () {\n        return that._batchTexture.textureStep;\n      },\n      tile_colorBlend: function () {\n        return getColorBlend(that);\n      },\n      tile_pickTexture: function () {\n        return that._batchTexture.pickTexture;\n      }\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\nCesium3DTileBatchTable.prototype.getPickId = function () {\n  return \"texture(tile_pickTexture, tile_featureSt)\";\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nconst StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2\n};\nCesium3DTileBatchTable.prototype.addDerivedCommands = function (frameState, commandStart) {\n  const commandList = frameState.commandList;\n  const commandEnd = commandList.length;\n  const tile = this._content._tile;\n  const finalResolution = tile._finalResolution;\n  const tileset = tile.tileset;\n  const bivariateVisibilityTest = tileset.isSkippingLevelOfDetail && tileset.hasMixedContent && frameState.context.stencilBuffer;\n  const styleCommandsNeeded = getStyleCommandsNeeded(this);\n  for (let i = commandStart; i < commandEnd; ++i) {\n    const command = commandList[i];\n    if (command.pass === Pass.COMPUTE) {\n      continue;\n    }\n    let derivedCommands = command.derivedCommands.tileset;\n    if (!defined(derivedCommands) || command.dirty) {\n      derivedCommands = {};\n      command.derivedCommands.tileset = derivedCommands;\n      derivedCommands.originalCommand = deriveCommand(command);\n      command.dirty = false;\n    }\n    const originalCommand = derivedCommands.originalCommand;\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE && command.pass !== Pass.TRANSLUCENT) {\n      if (!defined(derivedCommands.translucent)) {\n        derivedCommands.translucent = deriveTranslucentCommand(originalCommand);\n      }\n    }\n    if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_TRANSLUCENT && command.pass !== Pass.TRANSLUCENT) {\n      if (!defined(derivedCommands.opaque)) {\n        derivedCommands.opaque = deriveOpaqueCommand(originalCommand);\n      }\n      if (bivariateVisibilityTest) {\n        if (!finalResolution) {\n          if (!defined(derivedCommands.zback)) {\n            derivedCommands.zback = deriveZBackfaceCommand(frameState.context, originalCommand);\n          }\n          tileset._backfaceCommands.push(derivedCommands.zback);\n        }\n        if (!defined(derivedCommands.stencil) || tile._selectionDepth !== getLastSelectionDepth(derivedCommands.stencil)) {\n          if (command.renderState.depthMask) {\n            derivedCommands.stencil = deriveStencilCommand(originalCommand, tile._selectionDepth);\n          } else {\n            // Ignore if tile does not write depth\n            derivedCommands.stencil = derivedCommands.opaque;\n          }\n        }\n      }\n    }\n    const opaqueCommand = bivariateVisibilityTest ? derivedCommands.stencil : derivedCommands.opaque;\n    const translucentCommand = derivedCommands.translucent;\n\n    // If the command was originally opaque:\n    //    * If the styling applied to the tile is all opaque, use the opaque command\n    //      (with one additional uniform needed for the shader).\n    //    * If the styling is all translucent, use new (cached) derived commands (front\n    //      and back faces) with a translucent render state.\n    //    * If the styling causes both opaque and translucent features in this tile,\n    //      then use both sets of commands.\n    if (command.pass !== Pass.TRANSLUCENT) {\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_OPAQUE) {\n        commandList[i] = opaqueCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n        commandList[i] = translucentCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT) {\n        // PERFORMANCE_IDEA: if the tile has multiple commands, we do not know what features are in what\n        // commands so this case may be overkill.\n        commandList[i] = opaqueCommand;\n        commandList.push(translucentCommand);\n      }\n    } else {\n      // Command was originally translucent so no need to derive new commands;\n      // as of now, a style can't change an originally translucent feature to\n      // opaque since the style's alpha is modulated, not a replacement.  When\n      // this changes, we need to derive new opaque commands here.\n      commandList[i] = originalCommand;\n    }\n  }\n};\nfunction getStyleCommandsNeeded(batchTable) {\n  const translucentFeaturesLength = batchTable._batchTexture.translucentFeaturesLength;\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === batchTable.featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n}\nfunction deriveCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n\n  // Add a uniform to indicate if the original command was translucent so\n  // the shader knows not to cull vertices that were originally transparent\n  // even though their style is opaque.\n  const translucentCommand = derivedCommand.pass === Pass.TRANSLUCENT;\n  derivedCommand.uniformMap = defined(derivedCommand.uniformMap) ? derivedCommand.uniformMap : {};\n  derivedCommand.uniformMap.tile_translucentCommand = function () {\n    return translucentCommand;\n  };\n  return derivedCommand;\n}\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  derivedCommand.renderState = getTranslucentRenderState(command.renderState);\n  return derivedCommand;\n}\nfunction deriveOpaqueCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.renderState = getOpaqueRenderState(command.renderState);\n  return derivedCommand;\n}\nfunction getLogDepthPolygonOffsetFragmentShaderProgram(context, shaderProgram) {\n  let shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"zBackfaceLogDepth\");\n  if (!defined(shader)) {\n    const fs = shaderProgram.fragmentShaderSource.clone();\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"POLYGON_OFFSET\");\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, \"zBackfaceLogDepth\", {\n      vertexShaderSource: shaderProgram.vertexShaderSource,\n      fragmentShaderSource: fs,\n      attributeLocations: shaderProgram._attributeLocations\n    });\n  }\n  return shader;\n}\nfunction deriveZBackfaceCommand(context, command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles do not appear in front\n  const derivedCommand = DrawCommand.shallowClone(command);\n  const rs = clone(derivedCommand.renderState, true);\n  rs.cull.enabled = true;\n  rs.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  rs.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0\n  };\n  // Set the 3D Tiles bit\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  derivedCommand.castShadows = false;\n  derivedCommand.receiveShadows = false;\n  derivedCommand.uniformMap = clone(command.uniformMap);\n  const polygonOffset = new Cartesian2(5.0, 5.0);\n  derivedCommand.uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n\n  // Make the log depth depth fragment write account for the polygon offset, too.\n  // Otherwise, the back face commands will cause the higher resolution\n  // tiles to disappear.\n  derivedCommand.shaderProgram = getLogDepthPolygonOffsetFragmentShaderProgram(context, command.shaderProgram);\n  return derivedCommand;\n}\nfunction deriveStencilCommand(command, reference) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  const derivedCommand = DrawCommand.shallowClone(command);\n  const rs = clone(derivedCommand.renderState, true);\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted. Writes 0 for the terrain bit\n  rs.stencilTest.enabled = true;\n  rs.stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  rs.stencilTest.reference = StencilConstants.CESIUM_3D_TILE_MASK | reference << StencilConstants.SKIP_LOD_BIT_SHIFT;\n  rs.stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  return derivedCommand;\n}\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  const reference = stencilCommand.renderState.stencilTest.reference;\n  return (reference & StencilConstants.SKIP_LOD_MASK) >>> StencilConstants.SKIP_LOD_BIT_SHIFT;\n}\nfunction getTranslucentRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  return RenderState.fromCache(rs);\n}\nfunction getOpaqueRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  return RenderState.fromCache(rs);\n}\nCesium3DTileBatchTable.prototype.update = function (tileset, frameState) {\n  this._batchTexture.update(tileset, frameState);\n};\nCesium3DTileBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\nCesium3DTileBatchTable.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  return destroyObject(this);\n};\nexport default Cesium3DTileBatchTable;","map":{"version":3,"names":["Cartesian2","Check","clone","Color","combine","defaultValue","defined","deprecationWarning","destroyObject","DeveloperError","CesiumMath","RuntimeError","ContextLimits","DrawCommand","Pass","RenderState","ShaderSource","BatchTexture","BatchTableHierarchy","BlendingState","Cesium3DTileColorBlendMode","CullFace","getBinaryAccessor","StencilConstants","StencilFunction","StencilOperation","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","Cesium3DTileBatchTable","content","featuresLength","batchTableJson","batchTableBinary","colorChangedCallback","extensions","_extensions","properties","initializeProperties","_properties","_batchTableHierarchy","initializeHierarchy","binaryProperties","getBinaryProperties","_binaryPropertiesByteLength","countBinaryPropertyMemory","_batchTableBinaryProperties","_content","_batchTexture","owner","statistics","tileset","_deprecationWarning","Object","defineProperties","prototype","batchTableByteLength","get","totalByteLength","byteLength","jsonHeader","propertyName","hasOwnProperty","batchTable","binaryBody","hierarchy","legacyHierarchy","HIERARCHY","extension","name","property","byteOffset","componentType","type","binaryAccessor","componentCount","componentsPerAttribute","classType","typedArray","createArrayBufferView","buffer","setShow","batchId","show","setAllShow","getShow","setColor","color","setAllColor","getColor","result","getPickColor","scratchColor","applyStyle","style","length","i","feature","getFeature","evaluateColor","evaluate","getBinaryProperty","binaryProperty","index","unpack","setBinaryProperty","value","pack","checkBatchId","isClass","className","typeOf","string","isExactClass","getExactClassName","undefined","getClassName","hasProperty","hasPropertyBySemantic","getPropertyIds","results","scratchPropertyIds","keys","push","apply","getPropertyBySemantic","getProperty","propertyValues","hierarchyProperty","setProperty","Array","getGlslComputeSt","textureDimensions","y","getVertexShaderCallback","handleTranslucent","batchIdAttributeName","diffuseAttributeOrUniformName","that","source","renamedSource","modifyDiffuse","newMain","maximumVertexTextureImageUnits","getDefaultShader","applyHighlight","replaceMain","replaceDiffuseTextureCalls","functionCall","fromIndex","startIndex","indexOf","endIndex","nestedLevel","character","charAt","extractedFunction","slice","replacedFunction","regex","RegExp","uniformMatch","match","declaration","replace","finalDiffuseFunction","highlight","sourceDiffuse","replaceDiffuse","getFragmentShaderCallback","hasPremultipliedAlpha","getClassificationFragmentShaderCallback","getColorBlend","colorBlendMode","colorBlendAmount","HIGHLIGHT","REPLACE","MIX","clamp","EPSILON4","getUniformMapCallback","uniformMap","batchUniformMap","tile_batchTexture","batchTexture","defaultTexture","tile_textureDimensions","tile_textureStep","textureStep","tile_colorBlend","tile_pickTexture","pickTexture","getPickId","StyleCommandsNeeded","ALL_OPAQUE","ALL_TRANSLUCENT","OPAQUE_AND_TRANSLUCENT","addDerivedCommands","frameState","commandStart","commandList","commandEnd","tile","_tile","finalResolution","_finalResolution","bivariateVisibilityTest","isSkippingLevelOfDetail","hasMixedContent","context","stencilBuffer","styleCommandsNeeded","getStyleCommandsNeeded","command","pass","COMPUTE","derivedCommands","dirty","originalCommand","deriveCommand","TRANSLUCENT","translucent","deriveTranslucentCommand","opaque","deriveOpaqueCommand","zback","deriveZBackfaceCommand","_backfaceCommands","stencil","_selectionDepth","getLastSelectionDepth","renderState","depthMask","deriveStencilCommand","opaqueCommand","translucentCommand","translucentFeaturesLength","derivedCommand","shallowClone","tile_translucentCommand","getTranslucentRenderState","getOpaqueRenderState","getLogDepthPolygonOffsetFragmentShaderProgram","shaderProgram","shader","shaderCache","getDerivedShaderProgram","fs","fragmentShaderSource","defines","createDerivedShaderProgram","vertexShaderSource","attributeLocations","_attributeLocations","rs","cull","enabled","face","FRONT","colorMask","red","green","blue","alpha","polygonOffset","factor","units","stencilTest","setCesium3DTileBit","stencilMask","CESIUM_3D_TILE_MASK","fromCache","castShadows","receiveShadows","u_polygonOffset","reference","mask","SKIP_LOD_MASK","SKIP_LOD_BIT_SHIFT","frontFunction","GREATER_OR_EQUAL","frontOperation","zPass","backFunction","backOperation","stencilCommand","depthTest","blending","ALPHA_BLEND","update","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Cesium3DTileBatchTable.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BatchTexture from \"./BatchTexture.js\";\nimport BatchTableHierarchy from \"./BatchTableHierarchy.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileColorBlendMode from \"./Cesium3DTileColorBlendMode.js\";\nimport CullFace from \"./CullFace.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\nconst DEFAULT_COLOR_VALUE = BatchTexture.DEFAULT_COLOR_VALUE;\nconst DEFAULT_SHOW_VALUE = BatchTexture.DEFAULT_SHOW_VALUE;\n\n/**\n * @private\n * @constructor\n */\nfunction Cesium3DTileBatchTable(\n  content,\n  featuresLength,\n  batchTableJson,\n  batchTableBinary,\n  colorChangedCallback,\n) {\n  /**\n   * @readonly\n   */\n  this.featuresLength = featuresLength;\n\n  let extensions;\n  if (defined(batchTableJson)) {\n    extensions = batchTableJson.extensions;\n  }\n  this._extensions = defaultValue(extensions, {});\n\n  const properties = initializeProperties(batchTableJson);\n  this._properties = properties;\n\n  this._batchTableHierarchy = initializeHierarchy(\n    this,\n    batchTableJson,\n    batchTableBinary,\n  );\n\n  const binaryProperties = getBinaryProperties(\n    featuresLength,\n    properties,\n    batchTableBinary,\n  );\n  this._binaryPropertiesByteLength =\n    countBinaryPropertyMemory(binaryProperties);\n  this._batchTableBinaryProperties = binaryProperties;\n\n  this._content = content;\n\n  this._batchTexture = new BatchTexture({\n    featuresLength: featuresLength,\n    colorChangedCallback: colorChangedCallback,\n    owner: content,\n    statistics: content.tileset.statistics,\n  });\n}\n\n// This can be overridden for testing purposes\nCesium3DTileBatchTable._deprecationWarning = deprecationWarning;\n\nObject.defineProperties(Cesium3DTileBatchTable.prototype, {\n  /**\n   * Size of the batch table, including the batch table hierarchy's binary\n   * buffers and any binary properties. JSON data is not counted.\n   *\n   * @memberof Cesium3DTileBatchTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  batchTableByteLength: {\n    get: function () {\n      let totalByteLength = this._binaryPropertiesByteLength;\n\n      if (defined(this._batchTableHierarchy)) {\n        totalByteLength += this._batchTableHierarchy.byteLength;\n      }\n\n      totalByteLength += this._batchTexture.byteLength;\n\n      return totalByteLength;\n    },\n  },\n});\n\nfunction initializeProperties(jsonHeader) {\n  const properties = {};\n\n  if (!defined(jsonHeader)) {\n    return properties;\n  }\n\n  for (const propertyName in jsonHeader) {\n    if (\n      jsonHeader.hasOwnProperty(propertyName) &&\n      propertyName !== \"HIERARCHY\" && // Deprecated HIERARCHY property\n      propertyName !== \"extensions\" &&\n      propertyName !== \"extras\"\n    ) {\n      properties[propertyName] = clone(jsonHeader[propertyName], true);\n    }\n  }\n\n  return properties;\n}\n\nfunction initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!defined(jsonHeader)) {\n    return;\n  }\n\n  let hierarchy = batchTable._extensions[\"3DTILES_batch_table_hierarchy\"];\n\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (defined(legacyHierarchy)) {\n    Cesium3DTileBatchTable._deprecationWarning(\n      \"batchTableHierarchyExtension\",\n      \"The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead.\",\n    );\n    batchTable._extensions[\"3DTILES_batch_table_hierarchy\"] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!defined(hierarchy)) {\n    return;\n  }\n\n  return new BatchTableHierarchy({\n    extension: hierarchy,\n    binaryBody: binaryBody,\n  });\n}\n\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  let binaryProperties;\n  for (const name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      const property = properties[name];\n      const byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        const componentType = property.componentType;\n        const type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(\n            `Property ${name} requires a batch table binary.`,\n          );\n        }\n\n        const binaryAccessor = getBinaryAccessor(property);\n        const componentCount = binaryAccessor.componentsPerAttribute;\n        const classType = binaryAccessor.classType;\n        const typedArray = binaryAccessor.createArrayBufferView(\n          binaryBody.buffer,\n          binaryBody.byteOffset + byteOffset,\n          featuresLength,\n        );\n\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType,\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\n\nfunction countBinaryPropertyMemory(binaryProperties) {\n  if (!defined(binaryProperties)) {\n    return 0;\n  }\n\n  let byteLength = 0;\n  for (const name in binaryProperties) {\n    if (binaryProperties.hasOwnProperty(name)) {\n      byteLength += binaryProperties[name].typedArray.byteLength;\n    }\n  }\n  return byteLength;\n}\n\nCesium3DTileBatchTable.getBinaryProperties = function (\n  featuresLength,\n  batchTableJson,\n  batchTableBinary,\n) {\n  return getBinaryProperties(featuresLength, batchTableJson, batchTableBinary);\n};\n\nCesium3DTileBatchTable.prototype.setShow = function (batchId, show) {\n  this._batchTexture.setShow(batchId, show);\n};\n\nCesium3DTileBatchTable.prototype.setAllShow = function (show) {\n  this._batchTexture.setAllShow(show);\n};\n\nCesium3DTileBatchTable.prototype.getShow = function (batchId) {\n  return this._batchTexture.getShow(batchId);\n};\n\nCesium3DTileBatchTable.prototype.setColor = function (batchId, color) {\n  this._batchTexture.setColor(batchId, color);\n};\n\nCesium3DTileBatchTable.prototype.setAllColor = function (color) {\n  this._batchTexture.setAllColor(color);\n};\n\nCesium3DTileBatchTable.prototype.getColor = function (batchId, result) {\n  return this._batchTexture.getColor(batchId, result);\n};\n\nCesium3DTileBatchTable.prototype.getPickColor = function (batchId) {\n  return this._batchTexture.getPickColor(batchId);\n};\n\nconst scratchColor = new Color();\n\nCesium3DTileBatchTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(DEFAULT_COLOR_VALUE);\n    this.setAllShow(DEFAULT_SHOW_VALUE);\n    return;\n  }\n\n  const content = this._content;\n  const length = this.featuresLength;\n  for (let i = 0; i < length; ++i) {\n    const feature = content.getFeature(i);\n    const color = defined(style.color)\n      ? defaultValue(\n          style.color.evaluateColor(feature, scratchColor),\n          DEFAULT_COLOR_VALUE,\n        )\n      : DEFAULT_COLOR_VALUE;\n    const show = defined(style.show)\n      ? defaultValue(style.show.evaluate(feature), DEFAULT_SHOW_VALUE)\n      : DEFAULT_SHOW_VALUE;\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and must be between zero and featuresLength - 1 (${featuresLength}` -\n        +\").\",\n    );\n  }\n}\n\nCesium3DTileBatchTable.prototype.isClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return false;\n  }\n\n  return hierarchy.isClass(batchId, className);\n};\n\nCesium3DTileBatchTable.prototype.isExactClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  return this.getExactClassName(batchId) === className;\n};\n\nCesium3DTileBatchTable.prototype.getExactClassName = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n\n  return hierarchy.getClassName(batchId);\n};\n\nCesium3DTileBatchTable.prototype.hasProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  return (\n    defined(this._properties[name]) ||\n    (defined(this._batchTableHierarchy) &&\n      this._batchTableHierarchy.hasProperty(batchId, name))\n  );\n};\n\n/**\n * @private\n */\nCesium3DTileBatchTable.prototype.hasPropertyBySemantic = function () {\n  // Cesium 3D Tiles 1.0 formats do not have semantics\n  return false;\n};\n\nCesium3DTileBatchTable.prototype.getPropertyIds = function (batchId, results) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  const scratchPropertyIds = Object.keys(this._properties);\n  results.push.apply(results, scratchPropertyIds);\n\n  if (defined(this._batchTableHierarchy)) {\n    results.push.apply(\n      results,\n      this._batchTableHierarchy.getPropertyIds(batchId, scratchPropertyIds),\n    );\n  }\n\n  return results;\n};\n\n/**\n * @private\n */\nCesium3DTileBatchTable.prototype.getPropertyBySemantic = function (\n  batchId,\n  name,\n) {\n  // Cesium 3D Tiles 1.0 formats do not have semantics\n  return undefined;\n};\n\nCesium3DTileBatchTable.prototype.getProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    const binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      return getBinaryProperty(binaryProperty, batchId);\n    }\n  }\n\n  const propertyValues = this._properties[name];\n  if (defined(propertyValues)) {\n    return clone(propertyValues[batchId], true);\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    const hierarchyProperty = this._batchTableHierarchy.getProperty(\n      batchId,\n      name,\n    );\n    if (defined(hierarchyProperty)) {\n      return hierarchyProperty;\n    }\n  }\n\n  return undefined;\n};\n\nCesium3DTileBatchTable.prototype.setProperty = function (batchId, name, value) {\n  const featuresLength = this.featuresLength;\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    const binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      setBinaryProperty(binaryProperty, batchId, value);\n      return;\n    }\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    if (this._batchTableHierarchy.setProperty(batchId, name, value)) {\n      return;\n    }\n  }\n\n  let propertyValues = this._properties[name];\n  if (!defined(propertyValues)) {\n    // Property does not exist. Create it.\n    this._properties[name] = new Array(featuresLength);\n    propertyValues = this._properties[name];\n  }\n\n  propertyValues[batchId] = clone(value, true);\n};\n\nfunction getGlslComputeSt(batchTable) {\n  // GLSL batchId is zero-based: [0, featuresLength - 1]\n  if (batchTable._batchTexture.textureDimensions.y === 1) {\n    return (\n      \"uniform vec4 tile_textureStep; \\n\" +\n      \"vec2 computeSt(float batchId) \\n\" +\n      \"{ \\n\" +\n      \"    float stepX = tile_textureStep.x; \\n\" +\n      \"    float centerX = tile_textureStep.y; \\n\" +\n      \"    return vec2(centerX + (batchId * stepX), 0.5); \\n\" +\n      \"} \\n\"\n    );\n  }\n\n  return (\n    \"uniform vec4 tile_textureStep; \\n\" +\n    \"uniform vec2 tile_textureDimensions; \\n\" +\n    \"vec2 computeSt(float batchId) \\n\" +\n    \"{ \\n\" +\n    \"    float stepX = tile_textureStep.x; \\n\" +\n    \"    float centerX = tile_textureStep.y; \\n\" +\n    \"    float stepY = tile_textureStep.z; \\n\" +\n    \"    float centerY = tile_textureStep.w; \\n\" +\n    \"    float xId = mod(batchId, tile_textureDimensions.x); \\n\" +\n    \"    float yId = floor(batchId / tile_textureDimensions.x); \\n\" +\n    \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" +\n    \"} \\n\"\n  );\n}\n\nCesium3DTileBatchTable.prototype.getVertexShaderCallback = function (\n  handleTranslucent,\n  batchIdAttributeName,\n  diffuseAttributeOrUniformName,\n) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  const that = this;\n  return function (source) {\n    // If the color blend mode is HIGHLIGHT, the highlight color will always be applied in the fragment shader.\n    // No need to apply the highlight color in the vertex shader as well.\n    const renamedSource = modifyDiffuse(\n      source,\n      diffuseAttributeOrUniformName,\n      false,\n    );\n    let newMain;\n\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, perform per-feature show/hide in the vertex shader\n      newMain = \"\";\n      if (handleTranslucent) {\n        newMain += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      newMain +=\n        `${\n          \"uniform sampler2D tile_batchTexture; \\n\" +\n          \"out vec4 tile_featureColor; \\n\" +\n          \"out vec2 tile_featureSt; \\n\" +\n          \"void main() \\n\" +\n          \"{ \\n\" +\n          \"    vec2 st = computeSt(\"\n        }${batchIdAttributeName}); \\n` +\n        `    vec4 featureProperties = texture(tile_batchTexture, st); \\n` +\n        `    tile_color(featureProperties); \\n` +\n        `    float show = ceil(featureProperties.a); \\n` + // 0 - false, non-zero - true\n        `    gl_Position *= show; \\n`; // Per-feature show/hide\n      if (handleTranslucent) {\n        newMain +=\n          \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" +\n          \"    if (czm_pass == czm_passTranslucent) \\n\" +\n          \"    { \\n\" +\n          \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n          \"        { \\n\" +\n          \"            gl_Position *= 0.0; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\" +\n          \"    else \\n\" +\n          \"    { \\n\" +\n          \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n          \"        { \\n\" +\n          \"            gl_Position *= 0.0; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\";\n      }\n      newMain +=\n        \"    tile_featureColor = featureProperties; \\n\" +\n        \"    tile_featureSt = st; \\n\" +\n        \"}\";\n    } else {\n      // When VTF is not supported, color blend mode MIX will look incorrect due to the feature's color not being available in the vertex shader\n      newMain =\n        `${\n          \"out vec2 tile_featureSt; \\n\" +\n          \"void main() \\n\" +\n          \"{ \\n\" +\n          \"    tile_color(vec4(1.0)); \\n\" +\n          \"    tile_featureSt = computeSt(\"\n        }${batchIdAttributeName}); \\n` + `}`;\n    }\n\n    return `${renamedSource}\\n${getGlslComputeSt(that)}${newMain}`;\n  };\n};\n\nfunction getDefaultShader(source, applyHighlight) {\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n\n  if (!applyHighlight) {\n    return (\n      `${source}void tile_color(vec4 tile_featureColor) \\n` +\n      `{ \\n` +\n      `    tile_main(); \\n` +\n      `} \\n`\n    );\n  }\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // out_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  return (\n    `${source}uniform float tile_colorBlend; \\n` +\n    `void tile_color(vec4 tile_featureColor) \\n` +\n    `{ \\n` +\n    `    tile_main(); \\n` +\n    `    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n` +\n    `    out_FragColor.a *= tile_featureColor.a; \\n` +\n    `    float highlight = ceil(tile_colorBlend); \\n` +\n    `    out_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n` +\n    `} \\n`\n  );\n}\n\nfunction replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName) {\n  const functionCall = `texture(${diffuseAttributeOrUniformName}`;\n\n  let fromIndex = 0;\n  let startIndex = source.indexOf(functionCall, fromIndex);\n  let endIndex;\n\n  while (startIndex > -1) {\n    let nestedLevel = 0;\n    for (let i = startIndex; i < source.length; ++i) {\n      const character = source.charAt(i);\n      if (character === \"(\") {\n        ++nestedLevel;\n      } else if (character === \")\") {\n        --nestedLevel;\n        if (nestedLevel === 0) {\n          endIndex = i + 1;\n          break;\n        }\n      }\n    }\n    const extractedFunction = source.slice(startIndex, endIndex);\n    const replacedFunction = `tile_diffuse_final(${extractedFunction}, tile_diffuse)`;\n\n    source =\n      source.slice(0, startIndex) + replacedFunction + source.slice(endIndex);\n    fromIndex = startIndex + replacedFunction.length;\n    startIndex = source.indexOf(functionCall, fromIndex);\n  }\n\n  return source;\n}\n\nfunction modifyDiffuse(source, diffuseAttributeOrUniformName, applyHighlight) {\n  // If the glTF does not specify the _3DTILESDIFFUSE semantic, return the default shader.\n  // Otherwise if _3DTILESDIFFUSE is defined prefer the shader below that can switch the color mode at runtime.\n  if (!defined(diffuseAttributeOrUniformName)) {\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  // Find the diffuse uniform. Examples matches:\n  //   uniform vec3 u_diffuseColor;\n  //   uniform sampler2D diffuseTexture;\n  let regex = new RegExp(\n    `(uniform|attribute|in)\\\\s+(vec[34]|sampler2D)\\\\s+${diffuseAttributeOrUniformName};`,\n  );\n  const uniformMatch = source.match(regex);\n\n  if (!defined(uniformMatch)) {\n    // Could not find uniform declaration of type vec3, vec4, or sampler2D\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  const declaration = uniformMatch[0];\n  const type = uniformMatch[2];\n\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n  source = source.replace(declaration, \"\"); // Remove uniform declaration for now so the replace below doesn't affect it\n\n  // If the tile color is white, use the source color. This implies the feature has not been styled.\n  // Highlight: tile_colorBlend is 0.0 and the source color is used\n  // Replace: tile_colorBlend is 1.0 and the tile color is used\n  // Mix: tile_colorBlend is between 0.0 and 1.0, causing the source color and tile color to mix\n  const finalDiffuseFunction =\n    \"bool isWhite(vec3 color) \\n\" +\n    \"{ \\n\" +\n    \"    return all(greaterThan(color, vec3(1.0 - czm_epsilon3))); \\n\" +\n    \"} \\n\" +\n    \"vec4 tile_diffuse_final(vec4 sourceDiffuse, vec4 tileDiffuse) \\n\" +\n    \"{ \\n\" +\n    \"    vec4 blendDiffuse = mix(sourceDiffuse, tileDiffuse, tile_colorBlend); \\n\" +\n    \"    vec4 diffuse = isWhite(tileDiffuse.rgb) ? sourceDiffuse : blendDiffuse; \\n\" +\n    \"    return vec4(diffuse.rgb, sourceDiffuse.a); \\n\" +\n    \"} \\n\";\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // out_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  const highlight =\n    \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" +\n    \"    out_FragColor.a *= tile_featureColor.a; \\n\" +\n    \"    float highlight = ceil(tile_colorBlend); \\n\" +\n    \"    out_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\";\n\n  let setColor;\n  if (type === \"vec3\" || type === \"vec4\") {\n    const sourceDiffuse =\n      type === \"vec3\"\n        ? `vec4(${diffuseAttributeOrUniformName}, 1.0)`\n        : diffuseAttributeOrUniformName;\n    const replaceDiffuse =\n      type === \"vec3\" ? \"tile_diffuse.xyz\" : \"tile_diffuse\";\n    regex = new RegExp(diffuseAttributeOrUniformName, \"g\");\n    source = source.replace(regex, replaceDiffuse);\n    setColor =\n      `    vec4 source = ${sourceDiffuse}; \\n` +\n      `    tile_diffuse = tile_diffuse_final(source, tile_featureColor); \\n` +\n      `    tile_main(); \\n`;\n  } else if (type === \"sampler2D\") {\n    // Handles any number of nested parentheses\n    // E.g. texture(u_diffuse, uv)\n    // E.g. texture(u_diffuse, computeUV(index))\n    source = replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName);\n    setColor =\n      \"    tile_diffuse = tile_featureColor; \\n\" + \"    tile_main(); \\n\";\n  }\n\n  source =\n    `${\n      \"uniform float tile_colorBlend; \\n\" + \"vec4 tile_diffuse = vec4(1.0); \\n\"\n    }${finalDiffuseFunction}${declaration}\\n${source}\\n` +\n    `void tile_color(vec4 tile_featureColor) \\n` +\n    `{ \\n${setColor}`;\n\n  if (applyHighlight) {\n    source += highlight;\n  }\n\n  source += \"} \\n\";\n  return source;\n}\n\nCesium3DTileBatchTable.prototype.getFragmentShaderCallback = function (\n  handleTranslucent,\n  diffuseAttributeOrUniformName,\n  hasPremultipliedAlpha,\n) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = modifyDiffuse(source, diffuseAttributeOrUniformName, true);\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source +=\n        \"uniform sampler2D tile_pickTexture; \\n\" +\n        \"in vec2 tile_featureSt; \\n\" +\n        \"in vec4 tile_featureColor; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_color(tile_featureColor); \\n\";\n\n      if (hasPremultipliedAlpha) {\n        source += \"    out_FragColor.rgb *= out_FragColor.a; \\n\";\n      }\n\n      source += \"}\";\n    } else {\n      if (handleTranslucent) {\n        source += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      source +=\n        \"uniform sampler2D tile_pickTexture; \\n\" +\n        \"uniform sampler2D tile_batchTexture; \\n\" +\n        \"in vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    vec4 featureProperties = texture(tile_batchTexture, tile_featureSt); \\n\" +\n        \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n        \"        discard; \\n\" +\n        \"    } \\n\";\n\n      if (handleTranslucent) {\n        source +=\n          \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" +\n          \"    if (czm_pass == czm_passTranslucent) \\n\" +\n          \"    { \\n\" +\n          \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n          \"        { \\n\" +\n          \"            discard; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\" +\n          \"    else \\n\" +\n          \"    { \\n\" +\n          \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n          \"        { \\n\" +\n          \"            discard; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\";\n      }\n\n      source += \"    tile_color(featureProperties); \\n\";\n\n      if (hasPremultipliedAlpha) {\n        source += \"    out_FragColor.rgb *= out_FragColor.a; \\n\";\n      }\n\n      source += \"} \\n\";\n    }\n    return source;\n  };\n};\n\nCesium3DTileBatchTable.prototype.getClassificationFragmentShaderCallback =\n  function () {\n    if (this.featuresLength === 0) {\n      return;\n    }\n    return function (source) {\n      source = ShaderSource.replaceMain(source, \"tile_main\");\n      if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n        // When VTF is supported, per-feature show/hide already happened in the fragment shader\n        source +=\n          \"uniform sampler2D tile_pickTexture;\\n\" +\n          \"in vec2 tile_featureSt; \\n\" +\n          \"in vec4 tile_featureColor; \\n\" +\n          \"void main() \\n\" +\n          \"{ \\n\" +\n          \"    tile_main(); \\n\" +\n          \"    out_FragColor = tile_featureColor; \\n\" +\n          \"    out_FragColor.rgb *= out_FragColor.a; \\n\" +\n          \"}\";\n      } else {\n        source +=\n          \"uniform sampler2D tile_batchTexture; \\n\" +\n          \"uniform sampler2D tile_pickTexture;\\n\" +\n          \"in vec2 tile_featureSt; \\n\" +\n          \"void main() \\n\" +\n          \"{ \\n\" +\n          \"    tile_main(); \\n\" +\n          \"    vec4 featureProperties = texture(tile_batchTexture, tile_featureSt); \\n\" +\n          \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zero - true\n          \"        discard; \\n\" +\n          \"    } \\n\" +\n          \"    out_FragColor = featureProperties; \\n\" +\n          \"    out_FragColor.rgb *= out_FragColor.a; \\n\" +\n          \"} \\n\";\n      }\n      return source;\n    };\n  };\n\nfunction getColorBlend(batchTable) {\n  const tileset = batchTable._content.tileset;\n  const colorBlendMode = tileset.colorBlendMode;\n  const colorBlendAmount = tileset.colorBlendAmount;\n  if (colorBlendMode === Cesium3DTileColorBlendMode.HIGHLIGHT) {\n    return 0.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.REPLACE) {\n    return 1.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.MIX) {\n    // The value 0.0 is reserved for highlight, so clamp to just above 0.0.\n    return CesiumMath.clamp(colorBlendAmount, CesiumMath.EPSILON4, 1.0);\n  }\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(`Invalid color blend mode \"${colorBlendMode}\".`);\n  //>>includeEnd('debug');\n}\n\nCesium3DTileBatchTable.prototype.getUniformMapCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  const that = this;\n  return function (uniformMap) {\n    const batchUniformMap = {\n      tile_batchTexture: function () {\n        // PERFORMANCE_IDEA: we could also use a custom shader that avoids the texture read.\n        return defaultValue(\n          that._batchTexture.batchTexture,\n          that._batchTexture.defaultTexture,\n        );\n      },\n      tile_textureDimensions: function () {\n        return that._batchTexture.textureDimensions;\n      },\n      tile_textureStep: function () {\n        return that._batchTexture.textureStep;\n      },\n      tile_colorBlend: function () {\n        return getColorBlend(that);\n      },\n      tile_pickTexture: function () {\n        return that._batchTexture.pickTexture;\n      },\n    };\n\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nCesium3DTileBatchTable.prototype.getPickId = function () {\n  return \"texture(tile_pickTexture, tile_featureSt)\";\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nconst StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2,\n};\n\nCesium3DTileBatchTable.prototype.addDerivedCommands = function (\n  frameState,\n  commandStart,\n) {\n  const commandList = frameState.commandList;\n  const commandEnd = commandList.length;\n  const tile = this._content._tile;\n  const finalResolution = tile._finalResolution;\n  const tileset = tile.tileset;\n  const bivariateVisibilityTest =\n    tileset.isSkippingLevelOfDetail &&\n    tileset.hasMixedContent &&\n    frameState.context.stencilBuffer;\n  const styleCommandsNeeded = getStyleCommandsNeeded(this);\n\n  for (let i = commandStart; i < commandEnd; ++i) {\n    const command = commandList[i];\n    if (command.pass === Pass.COMPUTE) {\n      continue;\n    }\n\n    let derivedCommands = command.derivedCommands.tileset;\n    if (!defined(derivedCommands) || command.dirty) {\n      derivedCommands = {};\n      command.derivedCommands.tileset = derivedCommands;\n      derivedCommands.originalCommand = deriveCommand(command);\n      command.dirty = false;\n    }\n    const originalCommand = derivedCommands.originalCommand;\n\n    if (\n      styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE &&\n      command.pass !== Pass.TRANSLUCENT\n    ) {\n      if (!defined(derivedCommands.translucent)) {\n        derivedCommands.translucent = deriveTranslucentCommand(originalCommand);\n      }\n    }\n\n    if (\n      styleCommandsNeeded !== StyleCommandsNeeded.ALL_TRANSLUCENT &&\n      command.pass !== Pass.TRANSLUCENT\n    ) {\n      if (!defined(derivedCommands.opaque)) {\n        derivedCommands.opaque = deriveOpaqueCommand(originalCommand);\n      }\n\n      if (bivariateVisibilityTest) {\n        if (!finalResolution) {\n          if (!defined(derivedCommands.zback)) {\n            derivedCommands.zback = deriveZBackfaceCommand(\n              frameState.context,\n              originalCommand,\n            );\n          }\n          tileset._backfaceCommands.push(derivedCommands.zback);\n        }\n        if (\n          !defined(derivedCommands.stencil) ||\n          tile._selectionDepth !==\n            getLastSelectionDepth(derivedCommands.stencil)\n        ) {\n          if (command.renderState.depthMask) {\n            derivedCommands.stencil = deriveStencilCommand(\n              originalCommand,\n              tile._selectionDepth,\n            );\n          } else {\n            // Ignore if tile does not write depth\n            derivedCommands.stencil = derivedCommands.opaque;\n          }\n        }\n      }\n    }\n\n    const opaqueCommand = bivariateVisibilityTest\n      ? derivedCommands.stencil\n      : derivedCommands.opaque;\n    const translucentCommand = derivedCommands.translucent;\n\n    // If the command was originally opaque:\n    //    * If the styling applied to the tile is all opaque, use the opaque command\n    //      (with one additional uniform needed for the shader).\n    //    * If the styling is all translucent, use new (cached) derived commands (front\n    //      and back faces) with a translucent render state.\n    //    * If the styling causes both opaque and translucent features in this tile,\n    //      then use both sets of commands.\n    if (command.pass !== Pass.TRANSLUCENT) {\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_OPAQUE) {\n        commandList[i] = opaqueCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n        commandList[i] = translucentCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT) {\n        // PERFORMANCE_IDEA: if the tile has multiple commands, we do not know what features are in what\n        // commands so this case may be overkill.\n        commandList[i] = opaqueCommand;\n        commandList.push(translucentCommand);\n      }\n    } else {\n      // Command was originally translucent so no need to derive new commands;\n      // as of now, a style can't change an originally translucent feature to\n      // opaque since the style's alpha is modulated, not a replacement.  When\n      // this changes, we need to derive new opaque commands here.\n      commandList[i] = originalCommand;\n    }\n  }\n};\n\nfunction getStyleCommandsNeeded(batchTable) {\n  const translucentFeaturesLength =\n    batchTable._batchTexture.translucentFeaturesLength;\n\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === batchTable.featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n}\n\nfunction deriveCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n\n  // Add a uniform to indicate if the original command was translucent so\n  // the shader knows not to cull vertices that were originally transparent\n  // even though their style is opaque.\n  const translucentCommand = derivedCommand.pass === Pass.TRANSLUCENT;\n\n  derivedCommand.uniformMap = defined(derivedCommand.uniformMap)\n    ? derivedCommand.uniformMap\n    : {};\n  derivedCommand.uniformMap.tile_translucentCommand = function () {\n    return translucentCommand;\n  };\n\n  return derivedCommand;\n}\n\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  derivedCommand.renderState = getTranslucentRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction deriveOpaqueCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.renderState = getOpaqueRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction getLogDepthPolygonOffsetFragmentShaderProgram(context, shaderProgram) {\n  let shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"zBackfaceLogDepth\",\n  );\n  if (!defined(shader)) {\n    const fs = shaderProgram.fragmentShaderSource.clone();\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"POLYGON_OFFSET\");\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"zBackfaceLogDepth\",\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: shaderProgram._attributeLocations,\n      },\n    );\n  }\n\n  return shader;\n}\n\nfunction deriveZBackfaceCommand(context, command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles do not appear in front\n  const derivedCommand = DrawCommand.shallowClone(command);\n  const rs = clone(derivedCommand.renderState, true);\n  rs.cull.enabled = true;\n  rs.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  rs.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0,\n  };\n  // Set the 3D Tiles bit\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  derivedCommand.castShadows = false;\n  derivedCommand.receiveShadows = false;\n  derivedCommand.uniformMap = clone(command.uniformMap);\n\n  const polygonOffset = new Cartesian2(5.0, 5.0);\n  derivedCommand.uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n\n  // Make the log depth depth fragment write account for the polygon offset, too.\n  // Otherwise, the back face commands will cause the higher resolution\n  // tiles to disappear.\n  derivedCommand.shaderProgram = getLogDepthPolygonOffsetFragmentShaderProgram(\n    context,\n    command.shaderProgram,\n  );\n  return derivedCommand;\n}\n\nfunction deriveStencilCommand(command, reference) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  const derivedCommand = DrawCommand.shallowClone(command);\n  const rs = clone(derivedCommand.renderState, true);\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted. Writes 0 for the terrain bit\n  rs.stencilTest.enabled = true;\n  rs.stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  rs.stencilTest.reference =\n    StencilConstants.CESIUM_3D_TILE_MASK |\n    (reference << StencilConstants.SKIP_LOD_BIT_SHIFT);\n  rs.stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilMask =\n    StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  return derivedCommand;\n}\n\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  const reference = stencilCommand.renderState.stencilTest.reference;\n  return (\n    (reference & StencilConstants.SKIP_LOD_MASK) >>>\n    StencilConstants.SKIP_LOD_BIT_SHIFT\n  );\n}\n\nfunction getTranslucentRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  return RenderState.fromCache(rs);\n}\n\nfunction getOpaqueRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  return RenderState.fromCache(rs);\n}\n\nCesium3DTileBatchTable.prototype.update = function (tileset, frameState) {\n  this._batchTexture.update(tileset, frameState);\n};\n\nCesium3DTileBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\nCesium3DTileBatchTable.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  return destroyObject(this);\n};\nexport default Cesium3DTileBatchTable;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}