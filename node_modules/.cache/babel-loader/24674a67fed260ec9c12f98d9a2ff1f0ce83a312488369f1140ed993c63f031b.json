{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport TileMetadata from \"./TileMetadata.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\n/**\n * Check if a tile has metadata, either defined in its metadata field (3D Tiles 1.1)\n * or in the <code>3DTILES_metadata</code> extension. If defined, get the tile metadata\n * with the corresponding class.\n * <p>\n * This assumes that tileset.metadata has been created before any tiles are constructed.\n * </p>\n * @function\n *\n * @param {Cesium3DTileset} tileset The tileset to query for tile metadata\n * @param {object} tileHeader the JSON header for a {@link Cesium3DTile}\n * @return {TileMetadata} the tile metadata, or <code>undefined</code> if not found\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction findTileMetadata(tileset, tileHeader) {\n  const metadataJson = hasExtension(tileHeader, \"3DTILES_metadata\") ? tileHeader.extensions[\"3DTILES_metadata\"] : tileHeader.metadata;\n  if (!defined(metadataJson)) {\n    return undefined;\n  }\n  if (!defined(tileset.schema)) {\n    findTileMetadata._oneTimeWarning(\"findTileMetadata-missing-root-schema\", \"Could not find a metadata schema for tile metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.\");\n    return undefined;\n  }\n  const classes = defaultValue(tileset.schema.classes, defaultValue.EMPTY_OBJECT);\n  if (defined(metadataJson.class)) {\n    const tileClass = classes[metadataJson.class];\n    return new TileMetadata({\n      tile: metadataJson,\n      class: tileClass\n    });\n  }\n  return undefined;\n}\n\n// Exposed for testing\nfindTileMetadata._oneTimeWarning = oneTimeWarning;\nexport default findTileMetadata;","map":{"version":3,"names":["defaultValue","defined","hasExtension","TileMetadata","oneTimeWarning","findTileMetadata","tileset","tileHeader","metadataJson","extensions","metadata","undefined","schema","_oneTimeWarning","classes","EMPTY_OBJECT","class","tileClass","tile"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/findTileMetadata.js"],"sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport TileMetadata from \"./TileMetadata.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\n/**\n * Check if a tile has metadata, either defined in its metadata field (3D Tiles 1.1)\n * or in the <code>3DTILES_metadata</code> extension. If defined, get the tile metadata\n * with the corresponding class.\n * <p>\n * This assumes that tileset.metadata has been created before any tiles are constructed.\n * </p>\n * @function\n *\n * @param {Cesium3DTileset} tileset The tileset to query for tile metadata\n * @param {object} tileHeader the JSON header for a {@link Cesium3DTile}\n * @return {TileMetadata} the tile metadata, or <code>undefined</code> if not found\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction findTileMetadata(tileset, tileHeader) {\n  const metadataJson = hasExtension(tileHeader, \"3DTILES_metadata\")\n    ? tileHeader.extensions[\"3DTILES_metadata\"]\n    : tileHeader.metadata;\n\n  if (!defined(metadataJson)) {\n    return undefined;\n  }\n\n  if (!defined(tileset.schema)) {\n    findTileMetadata._oneTimeWarning(\n      \"findTileMetadata-missing-root-schema\",\n      \"Could not find a metadata schema for tile metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.\",\n    );\n    return undefined;\n  }\n\n  const classes = defaultValue(\n    tileset.schema.classes,\n    defaultValue.EMPTY_OBJECT,\n  );\n  if (defined(metadataJson.class)) {\n    const tileClass = classes[metadataJson.class];\n    return new TileMetadata({\n      tile: metadataJson,\n      class: tileClass,\n    });\n  }\n\n  return undefined;\n}\n\n// Exposed for testing\nfindTileMetadata._oneTimeWarning = oneTimeWarning;\nexport default findTileMetadata;\n"],"mappings":"AAAA,OAAOA,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,cAAc,MAAM,2BAA2B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,OAAO,EAAEC,UAAU,EAAE;EAC7C,MAAMC,YAAY,GAAGN,YAAY,CAACK,UAAU,EAAE,kBAAkB,CAAC,GAC7DA,UAAU,CAACE,UAAU,CAAC,kBAAkB,CAAC,GACzCF,UAAU,CAACG,QAAQ;EAEvB,IAAI,CAACT,OAAO,CAACO,YAAY,CAAC,EAAE;IAC1B,OAAOG,SAAS;EAClB;EAEA,IAAI,CAACV,OAAO,CAACK,OAAO,CAACM,MAAM,CAAC,EAAE;IAC5BP,gBAAgB,CAACQ,eAAe,CAC9B,sCAAsC,EACtC,0JACF,CAAC;IACD,OAAOF,SAAS;EAClB;EAEA,MAAMG,OAAO,GAAGd,YAAY,CAC1BM,OAAO,CAACM,MAAM,CAACE,OAAO,EACtBd,YAAY,CAACe,YACf,CAAC;EACD,IAAId,OAAO,CAACO,YAAY,CAACQ,KAAK,CAAC,EAAE;IAC/B,MAAMC,SAAS,GAAGH,OAAO,CAACN,YAAY,CAACQ,KAAK,CAAC;IAC7C,OAAO,IAAIb,YAAY,CAAC;MACtBe,IAAI,EAAEV,YAAY;MAClBQ,KAAK,EAAEC;IACT,CAAC,CAAC;EACJ;EAEA,OAAON,SAAS;AAClB;;AAEA;AACAN,gBAAgB,CAACQ,eAAe,GAAGT,cAAc;AACjD,eAAeC,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}