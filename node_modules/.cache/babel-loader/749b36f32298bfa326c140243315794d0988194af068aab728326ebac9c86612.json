{"ast":null,"code":"import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A utility for dynamically-generating a GLSL function\n *\n * @alias ShaderFunction\n * @constructor\n *\n * @see {@link ShaderBuilder}\n * @param {string} signature The full signature of the function as it will appear in the shader. Do not include the curly braces.\n * @example\n * // generate the following function\n * //\n * // void assignVaryings(vec3 position)\n * // {\n * //    v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\n * //    v_texCoord = a_texCoord;\n * // }\n * const signature = \"void assignVaryings(vec3 position)\";\n * const func = new ShaderFunction(signature);\n * func.addLine(\"v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\");\n * func.addLine(\"v_texCoord = a_texCoord;\");\n * const generatedLines = func.generateGlslLines();\n *\n * @private\n */\nfunction ShaderFunction(signature) {\n  this.signature = signature;\n  this.body = [];\n}\n\n/**\n * Adds one or more lines to the body of the function\n * @param {string|string[]} lines One or more lines of GLSL code to add to the function body. Do not include any preceding or ending whitespace, but do include the semicolon for each line.\n */\nShaderFunction.prototype.addLines = function (lines) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(`Expected lines to be a string or an array of strings, actual value was ${lines}`);\n  }\n  //>>includeEnd('debug');\n  const body = this.body;\n\n  // Indent the body of the function by 4 spaces\n  if (Array.isArray(lines)) {\n    const length = lines.length;\n    for (let i = 0; i < length; i++) {\n      body.push(`    ${lines[i]}`);\n    }\n  } else {\n    // Single string case\n    body.push(`    ${lines}`);\n  }\n};\n\n/**\n * Generate lines of GLSL code for use with {@link ShaderBuilder}\n * @return {string[]}\n */\nShaderFunction.prototype.generateGlslLines = function () {\n  return [].concat(this.signature, \"{\", this.body, \"}\");\n};\nexport default ShaderFunction;","map":{"version":3,"names":["DeveloperError","ShaderFunction","signature","body","prototype","addLines","lines","Array","isArray","length","i","push","generateGlslLines","concat"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/ShaderFunction.js"],"sourcesContent":["import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A utility for dynamically-generating a GLSL function\n *\n * @alias ShaderFunction\n * @constructor\n *\n * @see {@link ShaderBuilder}\n * @param {string} signature The full signature of the function as it will appear in the shader. Do not include the curly braces.\n * @example\n * // generate the following function\n * //\n * // void assignVaryings(vec3 position)\n * // {\n * //    v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\n * //    v_texCoord = a_texCoord;\n * // }\n * const signature = \"void assignVaryings(vec3 position)\";\n * const func = new ShaderFunction(signature);\n * func.addLine(\"v_positionEC = (czm_modelView * vec4(a_position, 1.0)).xyz;\");\n * func.addLine(\"v_texCoord = a_texCoord;\");\n * const generatedLines = func.generateGlslLines();\n *\n * @private\n */\nfunction ShaderFunction(signature) {\n  this.signature = signature;\n  this.body = [];\n}\n\n/**\n * Adds one or more lines to the body of the function\n * @param {string|string[]} lines One or more lines of GLSL code to add to the function body. Do not include any preceding or ending whitespace, but do include the semicolon for each line.\n */\nShaderFunction.prototype.addLines = function (lines) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(\n      `Expected lines to be a string or an array of strings, actual value was ${lines}`,\n    );\n  }\n  //>>includeEnd('debug');\n  const body = this.body;\n\n  // Indent the body of the function by 4 spaces\n  if (Array.isArray(lines)) {\n    const length = lines.length;\n    for (let i = 0; i < length; i++) {\n      body.push(`    ${lines[i]}`);\n    }\n  } else {\n    // Single string case\n    body.push(`    ${lines}`);\n  }\n};\n\n/**\n * Generate lines of GLSL code for use with {@link ShaderBuilder}\n * @return {string[]}\n */\nShaderFunction.prototype.generateGlslLines = function () {\n  return [].concat(this.signature, \"{\", this.body, \"}\");\n};\n\nexport default ShaderFunction;\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,2BAA2B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,SAAS,EAAE;EACjC,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC1B,IAAI,CAACC,IAAI,GAAG,EAAE;AAChB;;AAEA;AACA;AACA;AACA;AACAF,cAAc,CAACG,SAAS,CAACC,QAAQ,GAAG,UAAUC,KAAK,EAAE;EACnD;EACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtD,MAAM,IAAIN,cAAc,CACtB,0EAA0EM,KAAK,EACjF,CAAC;EACH;EACA;EACA,MAAMH,IAAI,GAAG,IAAI,CAACA,IAAI;;EAEtB;EACA,IAAII,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxB,MAAMG,MAAM,GAAGH,KAAK,CAACG,MAAM;IAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/BP,IAAI,CAACQ,IAAI,CAAC,OAAOL,KAAK,CAACI,CAAC,CAAC,EAAE,CAAC;IAC9B;EACF,CAAC,MAAM;IACL;IACAP,IAAI,CAACQ,IAAI,CAAC,OAAOL,KAAK,EAAE,CAAC;EAC3B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAL,cAAc,CAACG,SAAS,CAACQ,iBAAiB,GAAG,YAAY;EACvD,OAAO,EAAE,CAACC,MAAM,CAAC,IAAI,CAACX,SAAS,EAAE,GAAG,EAAE,IAAI,CAACC,IAAI,EAAE,GAAG,CAAC;AACvD,CAAC;AAED,eAAeF,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}