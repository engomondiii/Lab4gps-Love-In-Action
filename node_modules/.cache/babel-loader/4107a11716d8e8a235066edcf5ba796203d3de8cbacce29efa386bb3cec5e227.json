{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef USE_CLIPPING_PLANES_FLOAT_TEXTURE\\n\\\nvec4 getClippingPlane(\\n\\\n    highp sampler2D packedClippingPlanes,\\n\\\n    int clippingPlaneNumber,\\n\\\n    mat4 transform\\n\\\n) {\\n\\\n    int pixY = clippingPlaneNumber / CLIPPING_PLANES_TEXTURE_WIDTH;\\n\\\n    int pixX = clippingPlaneNumber - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT);\\n\\\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\\n\\\n    float v = (float(pixY) + 0.5) * pixelHeight;\\n\\\n    vec4 plane = texture(packedClippingPlanes, vec2(u, v));\\n\\\n    return czm_transformPlane(plane, transform);\\n\\\n}\\n\\\n#else\\n\\\n// Handle uint8 clipping texture instead\\n\\\nvec4 getClippingPlane(\\n\\\n    highp sampler2D packedClippingPlanes,\\n\\\n    int clippingPlaneNumber,\\n\\\n    mat4 transform\\n\\\n) {\\n\\\n    int clippingPlaneStartIndex = clippingPlaneNumber * 2; // clipping planes are two pixels each\\n\\\n    int pixY = clippingPlaneStartIndex / CLIPPING_PLANES_TEXTURE_WIDTH;\\n\\\n    int pixX = clippingPlaneStartIndex - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT);\\n\\\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\\n\\\n    float v = (float(pixY) + 0.5) * pixelHeight;\\n\\\n    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;\\n\\\n    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\\n\\\n    vec4 plane;\\n\\\n    plane.xyz = czm_octDecode(oct, 65535.0);\\n\\\n    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + pixelWidth, v)));\\n\\\n    return czm_transformPlane(plane, transform);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nfloat clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix) {\\n\\\n    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\\\n    vec3 clipNormal = vec3(0.0);\\n\\\n    vec3 clipPosition = vec3(0.0);\\n\\\n    float pixelWidth = czm_metersPerPixel(position);\\n\\\n    \\n\\\n    #ifdef UNION_CLIPPING_REGIONS\\n\\\n    float clipAmount; // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below.\\n\\\n    #else\\n\\\n    float clipAmount = 0.0;\\n\\\n    bool clipped = true;\\n\\\n    #endif\\n\\\n\\n\\\n    for (int i = 0; i < CLIPPING_PLANES_LENGTH; ++i) {\\n\\\n        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n\\\n        clipNormal = clippingPlane.xyz;\\n\\\n        clipPosition = -clippingPlane.w * clipNormal;\\n\\\n        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n\\\n        \\n\\\n        #ifdef UNION_CLIPPING_REGIONS\\n\\\n        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\\n\\\n        if (amount <= 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        #else\\n\\\n        clipAmount = max(amount, clipAmount);\\n\\\n        clipped = clipped && (amount <= 0.0);\\n\\\n        #endif\\n\\\n    }\\n\\\n\\n\\\n    #ifndef UNION_CLIPPING_REGIONS\\n\\\n    if (clipped) {\\n\\\n        discard;\\n\\\n    }\\n\\\n    #endif\\n\\\n    \\n\\\n    return clipAmount;\\n\\\n}\\n\\\n\\n\\\nvoid modelClippingPlanesStage(inout vec4 color)\\n\\\n{\\n\\\n    float clipDistance = clip(gl_FragCoord, model_clippingPlanes, model_clippingPlanesMatrix);\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = model_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = model_clippingPlanesEdgeStyle.a;\\n\\\n    \\n\\\n    if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) {\\n\\\n        color = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Model/ModelClippingPlanesStageFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef USE_CLIPPING_PLANES_FLOAT_TEXTURE\\n\\\nvec4 getClippingPlane(\\n\\\n    highp sampler2D packedClippingPlanes,\\n\\\n    int clippingPlaneNumber,\\n\\\n    mat4 transform\\n\\\n) {\\n\\\n    int pixY = clippingPlaneNumber / CLIPPING_PLANES_TEXTURE_WIDTH;\\n\\\n    int pixX = clippingPlaneNumber - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT);\\n\\\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\\n\\\n    float v = (float(pixY) + 0.5) * pixelHeight;\\n\\\n    vec4 plane = texture(packedClippingPlanes, vec2(u, v));\\n\\\n    return czm_transformPlane(plane, transform);\\n\\\n}\\n\\\n#else\\n\\\n// Handle uint8 clipping texture instead\\n\\\nvec4 getClippingPlane(\\n\\\n    highp sampler2D packedClippingPlanes,\\n\\\n    int clippingPlaneNumber,\\n\\\n    mat4 transform\\n\\\n) {\\n\\\n    int clippingPlaneStartIndex = clippingPlaneNumber * 2; // clipping planes are two pixels each\\n\\\n    int pixY = clippingPlaneStartIndex / CLIPPING_PLANES_TEXTURE_WIDTH;\\n\\\n    int pixX = clippingPlaneStartIndex - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH);\\n\\\n    float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT);\\n\\\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\\n\\\n    float v = (float(pixY) + 0.5) * pixelHeight;\\n\\\n    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;\\n\\\n    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\\n\\\n    vec4 plane;\\n\\\n    plane.xyz = czm_octDecode(oct, 65535.0);\\n\\\n    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + pixelWidth, v)));\\n\\\n    return czm_transformPlane(plane, transform);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nfloat clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix) {\\n\\\n    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\\\n    vec3 clipNormal = vec3(0.0);\\n\\\n    vec3 clipPosition = vec3(0.0);\\n\\\n    float pixelWidth = czm_metersPerPixel(position);\\n\\\n    \\n\\\n    #ifdef UNION_CLIPPING_REGIONS\\n\\\n    float clipAmount; // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below.\\n\\\n    #else\\n\\\n    float clipAmount = 0.0;\\n\\\n    bool clipped = true;\\n\\\n    #endif\\n\\\n\\n\\\n    for (int i = 0; i < CLIPPING_PLANES_LENGTH; ++i) {\\n\\\n        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n\\\n        clipNormal = clippingPlane.xyz;\\n\\\n        clipPosition = -clippingPlane.w * clipNormal;\\n\\\n        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n\\\n        \\n\\\n        #ifdef UNION_CLIPPING_REGIONS\\n\\\n        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\\n\\\n        if (amount <= 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        #else\\n\\\n        clipAmount = max(amount, clipAmount);\\n\\\n        clipped = clipped && (amount <= 0.0);\\n\\\n        #endif\\n\\\n    }\\n\\\n\\n\\\n    #ifndef UNION_CLIPPING_REGIONS\\n\\\n    if (clipped) {\\n\\\n        discard;\\n\\\n    }\\n\\\n    #endif\\n\\\n    \\n\\\n    return clipAmount;\\n\\\n}\\n\\\n\\n\\\nvoid modelClippingPlanesStage(inout vec4 color)\\n\\\n{\\n\\\n    float clipDistance = clip(gl_FragCoord, model_clippingPlanes, model_clippingPlanesMatrix);\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = model_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = model_clippingPlanesEdgeStyle.a;\\n\\\n    \\n\\\n    if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) {\\n\\\n        color = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}