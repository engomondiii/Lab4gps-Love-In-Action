{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestType from \"../Core/RequestType.js\";\n\n/**\n * Provides functionality for ImageryProviders that have time dynamic imagery\n *\n * @alias TimeDynamicImagery\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Clock} options.clock A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.\n * @param {TimeIntervalCollection} options.times TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Function} options.requestImageFunction A function that will request imagery tiles.\n * @param {Function} options.reloadFunction A function that will be called when all imagery tiles need to be reloaded.\n */\nfunction TimeDynamicImagery(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.times\", options.times);\n  Check.typeOf.func(\"options.requestImageFunction\", options.requestImageFunction);\n  Check.typeOf.func(\"options.reloadFunction\", options.reloadFunction);\n  //>>includeEnd('debug');\n\n  this._tileCache = {};\n  this._tilesRequestedForInterval = [];\n  const clock = this._clock = options.clock;\n  this._times = options.times;\n  this._requestImageFunction = options.requestImageFunction;\n  this._reloadFunction = options.reloadFunction;\n  this._currentIntervalIndex = -1;\n  clock.onTick.addEventListener(this._clockOnTick, this);\n  this._clockOnTick(clock);\n}\nObject.defineProperties(TimeDynamicImagery.prototype, {\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._clock !== value) {\n        this._clock = value;\n        this._clockOnTick(value);\n        this._reloadFunction();\n      }\n    }\n  },\n  /**\n   * Gets or sets a time interval collection.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._times !== value) {\n        this._times = value;\n        this._clockOnTick(this._clock);\n        this._reloadFunction();\n      }\n    }\n  },\n  /**\n   * Gets the current interval.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeInterval}\n   */\n  currentInterval: {\n    get: function () {\n      return this._times.get(this._currentIntervalIndex);\n    }\n  }\n});\n\n/**\n * Gets the tile from the cache if its available.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<HTMLImageElement>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if the tile is not in the cache.\n */\nTimeDynamicImagery.prototype.getFromCache = function (x, y, level, request) {\n  const key = getKey(x, y, level);\n  let result;\n  const cache = this._tileCache[this._currentIntervalIndex];\n  if (defined(cache) && defined(cache[key])) {\n    const item = cache[key];\n    result = item.promise.catch(function (e) {\n      // Set the correct state in case it was cancelled\n      request.state = item.request.state;\n      throw e;\n    });\n    delete cache[key];\n  }\n  return result;\n};\n\n/**\n * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will\n * just add the tile to a list to preload when we approach the next interval.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n */\nTimeDynamicImagery.prototype.checkApproachingInterval = function (x, y, level, request) {\n  const key = getKey(x, y, level);\n  const tilesRequestedForInterval = this._tilesRequestedForInterval;\n\n  // If we are approaching an interval, preload this tile in the next interval\n  const approachingInterval = getApproachingInterval(this);\n  const tile = {\n    key: key,\n    // Determines priority based on camera distance to the tile.\n    // Since the imagery regardless of time will be attached to the same tile we can just steal it.\n    priorityFunction: request.priorityFunction\n  };\n  if (!defined(approachingInterval) || !addToCache(this, tile, approachingInterval)) {\n    // Add to recent request list if we aren't approaching and interval or the request was throttled\n    tilesRequestedForInterval.push(tile);\n  }\n\n  // Don't let the tile list get out of hand\n  if (tilesRequestedForInterval.length >= 512) {\n    tilesRequestedForInterval.splice(0, 256);\n  }\n};\nTimeDynamicImagery.prototype._clockOnTick = function (clock) {\n  const time = clock.currentTime;\n  const times = this._times;\n  const index = times.indexOf(time);\n  const currentIntervalIndex = this._currentIntervalIndex;\n  if (index !== currentIntervalIndex) {\n    // Cancel all outstanding requests and clear out caches not from current time interval\n    const currentCache = this._tileCache[currentIntervalIndex];\n    for (const t in currentCache) {\n      if (currentCache.hasOwnProperty(t)) {\n        currentCache[t].request.cancel();\n      }\n    }\n    delete this._tileCache[currentIntervalIndex];\n    this._tilesRequestedForInterval = [];\n    this._currentIntervalIndex = index;\n    this._reloadFunction();\n    return;\n  }\n  const approachingInterval = getApproachingInterval(this);\n  if (defined(approachingInterval)) {\n    // Start loading recent tiles from end of this._tilesRequestedForInterval\n    //  We keep preloading until we hit a throttling limit.\n    const tilesRequested = this._tilesRequestedForInterval;\n    let success = true;\n    while (success) {\n      if (tilesRequested.length === 0) {\n        break;\n      }\n      const tile = tilesRequested.pop();\n      success = addToCache(this, tile, approachingInterval);\n      if (!success) {\n        tilesRequested.push(tile);\n      }\n    }\n  }\n};\nfunction getKey(x, y, level) {\n  return `${x}-${y}-${level}`;\n}\nfunction getKeyElements(key) {\n  const s = key.split(\"-\");\n  if (s.length !== 3) {\n    return undefined;\n  }\n  return {\n    x: Number(s[0]),\n    y: Number(s[1]),\n    level: Number(s[2])\n  };\n}\nfunction getApproachingInterval(that) {\n  const times = that._times;\n  if (!defined(times)) {\n    return undefined;\n  }\n  const clock = that._clock;\n  const time = clock.currentTime;\n  const isAnimating = clock.canAnimate && clock.shouldAnimate;\n  const multiplier = clock.multiplier;\n  if (!isAnimating && multiplier !== 0) {\n    return undefined;\n  }\n  let seconds;\n  let index = times.indexOf(time);\n  if (index < 0) {\n    return undefined;\n  }\n  const interval = times.get(index);\n  if (multiplier > 0) {\n    // animating forward\n    seconds = JulianDate.secondsDifference(interval.stop, time);\n    ++index;\n  } else {\n    //backwards\n    seconds = JulianDate.secondsDifference(interval.start, time); // Will be negative\n    --index;\n  }\n  seconds /= multiplier; // Will always be positive\n\n  // Less than 5 wall time seconds\n  return index >= 0 && seconds <= 5.0 ? times.get(index) : undefined;\n}\nfunction addToCache(that, tile, interval) {\n  const index = that._times.indexOf(interval.start);\n  const tileCache = that._tileCache;\n  let intervalTileCache = tileCache[index];\n  if (!defined(intervalTileCache)) {\n    intervalTileCache = tileCache[index] = {};\n  }\n  const key = tile.key;\n  if (defined(intervalTileCache[key])) {\n    return true; // Already in the cache\n  }\n  const keyElements = getKeyElements(key);\n  const request = new Request({\n    throttle: false,\n    throttleByServer: true,\n    type: RequestType.IMAGERY,\n    priorityFunction: tile.priorityFunction\n  });\n  const promise = that._requestImageFunction(keyElements.x, keyElements.y, keyElements.level, request, interval);\n  if (!defined(promise)) {\n    return false;\n  }\n  intervalTileCache[key] = {\n    promise: promise,\n    request: request\n  };\n  return true;\n}\nexport default TimeDynamicImagery;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","JulianDate","Request","RequestType","TimeDynamicImagery","options","EMPTY_OBJECT","typeOf","object","clock","times","func","requestImageFunction","reloadFunction","_tileCache","_tilesRequestedForInterval","_clock","_times","_requestImageFunction","_reloadFunction","_currentIntervalIndex","onTick","addEventListener","_clockOnTick","Object","defineProperties","prototype","get","set","value","currentInterval","getFromCache","x","y","level","request","key","getKey","result","cache","item","promise","catch","e","state","checkApproachingInterval","tilesRequestedForInterval","approachingInterval","getApproachingInterval","tile","priorityFunction","addToCache","push","length","splice","time","currentTime","index","indexOf","currentIntervalIndex","currentCache","t","hasOwnProperty","cancel","tilesRequested","success","pop","getKeyElements","s","split","undefined","Number","that","isAnimating","canAnimate","shouldAnimate","multiplier","seconds","interval","secondsDifference","stop","start","tileCache","intervalTileCache","keyElements","throttle","throttleByServer","type","IMAGERY"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TimeDynamicImagery.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestType from \"../Core/RequestType.js\";\n\n/**\n * Provides functionality for ImageryProviders that have time dynamic imagery\n *\n * @alias TimeDynamicImagery\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Clock} options.clock A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.\n * @param {TimeIntervalCollection} options.times TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Function} options.requestImageFunction A function that will request imagery tiles.\n * @param {Function} options.reloadFunction A function that will be called when all imagery tiles need to be reloaded.\n */\nfunction TimeDynamicImagery(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.times\", options.times);\n  Check.typeOf.func(\n    \"options.requestImageFunction\",\n    options.requestImageFunction,\n  );\n  Check.typeOf.func(\"options.reloadFunction\", options.reloadFunction);\n  //>>includeEnd('debug');\n\n  this._tileCache = {};\n  this._tilesRequestedForInterval = [];\n\n  const clock = (this._clock = options.clock);\n  this._times = options.times;\n  this._requestImageFunction = options.requestImageFunction;\n  this._reloadFunction = options.reloadFunction;\n  this._currentIntervalIndex = -1;\n\n  clock.onTick.addEventListener(this._clockOnTick, this);\n  this._clockOnTick(clock);\n}\n\nObject.defineProperties(TimeDynamicImagery.prototype, {\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._clock !== value) {\n        this._clock = value;\n        this._clockOnTick(value);\n        this._reloadFunction();\n      }\n    },\n  },\n  /**\n   * Gets or sets a time interval collection.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._times !== value) {\n        this._times = value;\n        this._clockOnTick(this._clock);\n        this._reloadFunction();\n      }\n    },\n  },\n  /**\n   * Gets the current interval.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeInterval}\n   */\n  currentInterval: {\n    get: function () {\n      return this._times.get(this._currentIntervalIndex);\n    },\n  },\n});\n\n/**\n * Gets the tile from the cache if its available.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<HTMLImageElement>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if the tile is not in the cache.\n */\nTimeDynamicImagery.prototype.getFromCache = function (x, y, level, request) {\n  const key = getKey(x, y, level);\n  let result;\n  const cache = this._tileCache[this._currentIntervalIndex];\n  if (defined(cache) && defined(cache[key])) {\n    const item = cache[key];\n    result = item.promise.catch(function (e) {\n      // Set the correct state in case it was cancelled\n      request.state = item.request.state;\n      throw e;\n    });\n    delete cache[key];\n  }\n\n  return result;\n};\n\n/**\n * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will\n * just add the tile to a list to preload when we approach the next interval.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n */\nTimeDynamicImagery.prototype.checkApproachingInterval = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  const key = getKey(x, y, level);\n  const tilesRequestedForInterval = this._tilesRequestedForInterval;\n\n  // If we are approaching an interval, preload this tile in the next interval\n  const approachingInterval = getApproachingInterval(this);\n  const tile = {\n    key: key,\n    // Determines priority based on camera distance to the tile.\n    // Since the imagery regardless of time will be attached to the same tile we can just steal it.\n    priorityFunction: request.priorityFunction,\n  };\n  if (\n    !defined(approachingInterval) ||\n    !addToCache(this, tile, approachingInterval)\n  ) {\n    // Add to recent request list if we aren't approaching and interval or the request was throttled\n    tilesRequestedForInterval.push(tile);\n  }\n\n  // Don't let the tile list get out of hand\n  if (tilesRequestedForInterval.length >= 512) {\n    tilesRequestedForInterval.splice(0, 256);\n  }\n};\n\nTimeDynamicImagery.prototype._clockOnTick = function (clock) {\n  const time = clock.currentTime;\n  const times = this._times;\n  const index = times.indexOf(time);\n  const currentIntervalIndex = this._currentIntervalIndex;\n\n  if (index !== currentIntervalIndex) {\n    // Cancel all outstanding requests and clear out caches not from current time interval\n    const currentCache = this._tileCache[currentIntervalIndex];\n    for (const t in currentCache) {\n      if (currentCache.hasOwnProperty(t)) {\n        currentCache[t].request.cancel();\n      }\n    }\n    delete this._tileCache[currentIntervalIndex];\n    this._tilesRequestedForInterval = [];\n\n    this._currentIntervalIndex = index;\n    this._reloadFunction();\n\n    return;\n  }\n\n  const approachingInterval = getApproachingInterval(this);\n  if (defined(approachingInterval)) {\n    // Start loading recent tiles from end of this._tilesRequestedForInterval\n    //  We keep preloading until we hit a throttling limit.\n    const tilesRequested = this._tilesRequestedForInterval;\n    let success = true;\n    while (success) {\n      if (tilesRequested.length === 0) {\n        break;\n      }\n\n      const tile = tilesRequested.pop();\n      success = addToCache(this, tile, approachingInterval);\n      if (!success) {\n        tilesRequested.push(tile);\n      }\n    }\n  }\n};\n\nfunction getKey(x, y, level) {\n  return `${x}-${y}-${level}`;\n}\n\nfunction getKeyElements(key) {\n  const s = key.split(\"-\");\n  if (s.length !== 3) {\n    return undefined;\n  }\n\n  return {\n    x: Number(s[0]),\n    y: Number(s[1]),\n    level: Number(s[2]),\n  };\n}\n\nfunction getApproachingInterval(that) {\n  const times = that._times;\n  if (!defined(times)) {\n    return undefined;\n  }\n  const clock = that._clock;\n  const time = clock.currentTime;\n  const isAnimating = clock.canAnimate && clock.shouldAnimate;\n  const multiplier = clock.multiplier;\n\n  if (!isAnimating && multiplier !== 0) {\n    return undefined;\n  }\n\n  let seconds;\n  let index = times.indexOf(time);\n  if (index < 0) {\n    return undefined;\n  }\n\n  const interval = times.get(index);\n  if (multiplier > 0) {\n    // animating forward\n    seconds = JulianDate.secondsDifference(interval.stop, time);\n    ++index;\n  } else {\n    //backwards\n    seconds = JulianDate.secondsDifference(interval.start, time); // Will be negative\n    --index;\n  }\n  seconds /= multiplier; // Will always be positive\n\n  // Less than 5 wall time seconds\n  return index >= 0 && seconds <= 5.0 ? times.get(index) : undefined;\n}\n\nfunction addToCache(that, tile, interval) {\n  const index = that._times.indexOf(interval.start);\n  const tileCache = that._tileCache;\n  let intervalTileCache = tileCache[index];\n  if (!defined(intervalTileCache)) {\n    intervalTileCache = tileCache[index] = {};\n  }\n\n  const key = tile.key;\n  if (defined(intervalTileCache[key])) {\n    return true; // Already in the cache\n  }\n\n  const keyElements = getKeyElements(key);\n  const request = new Request({\n    throttle: false,\n    throttleByServer: true,\n    type: RequestType.IMAGERY,\n    priorityFunction: tile.priorityFunction,\n  });\n  const promise = that._requestImageFunction(\n    keyElements.x,\n    keyElements.y,\n    keyElements.level,\n    request,\n    interval,\n  );\n  if (!defined(promise)) {\n    return false;\n  }\n\n  intervalTileCache[key] = {\n    promise: promise,\n    request: request,\n  };\n\n  return true;\n}\nexport default TimeDynamicImagery;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,WAAW,MAAM,wBAAwB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,OAAO,EAAE;EACnCA,OAAO,GAAGP,YAAY,CAACO,OAAO,EAAEP,YAAY,CAACQ,YAAY,CAAC;;EAE1D;EACAT,KAAK,CAACU,MAAM,CAACC,MAAM,CAAC,eAAe,EAAEH,OAAO,CAACI,KAAK,CAAC;EACnDZ,KAAK,CAACU,MAAM,CAACC,MAAM,CAAC,eAAe,EAAEH,OAAO,CAACK,KAAK,CAAC;EACnDb,KAAK,CAACU,MAAM,CAACI,IAAI,CACf,8BAA8B,EAC9BN,OAAO,CAACO,oBACV,CAAC;EACDf,KAAK,CAACU,MAAM,CAACI,IAAI,CAAC,wBAAwB,EAAEN,OAAO,CAACQ,cAAc,CAAC;EACnE;;EAEA,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;EACpB,IAAI,CAACC,0BAA0B,GAAG,EAAE;EAEpC,MAAMN,KAAK,GAAI,IAAI,CAACO,MAAM,GAAGX,OAAO,CAACI,KAAM;EAC3C,IAAI,CAACQ,MAAM,GAAGZ,OAAO,CAACK,KAAK;EAC3B,IAAI,CAACQ,qBAAqB,GAAGb,OAAO,CAACO,oBAAoB;EACzD,IAAI,CAACO,eAAe,GAAGd,OAAO,CAACQ,cAAc;EAC7C,IAAI,CAACO,qBAAqB,GAAG,CAAC,CAAC;EAE/BX,KAAK,CAACY,MAAM,CAACC,gBAAgB,CAAC,IAAI,CAACC,YAAY,EAAE,IAAI,CAAC;EACtD,IAAI,CAACA,YAAY,CAACd,KAAK,CAAC;AAC1B;AAEAe,MAAM,CAACC,gBAAgB,CAACrB,kBAAkB,CAACsB,SAAS,EAAE;EACpD;AACF;AACA;AACA;AACA;EACEjB,KAAK,EAAE;IACLkB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACX,MAAM;IACpB,CAAC;IACDY,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MACpB;MACA,IAAI,CAAC9B,OAAO,CAAC8B,KAAK,CAAC,EAAE;QACnB,MAAM,IAAI7B,cAAc,CAAC,oBAAoB,CAAC;MAChD;MACA;;MAEA,IAAI,IAAI,CAACgB,MAAM,KAAKa,KAAK,EAAE;QACzB,IAAI,CAACb,MAAM,GAAGa,KAAK;QACnB,IAAI,CAACN,YAAY,CAACM,KAAK,CAAC;QACxB,IAAI,CAACV,eAAe,CAAC,CAAC;MACxB;IACF;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACET,KAAK,EAAE;IACLiB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,MAAM;IACpB,CAAC;IACDW,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MACpB;MACA,IAAI,CAAC9B,OAAO,CAAC8B,KAAK,CAAC,EAAE;QACnB,MAAM,IAAI7B,cAAc,CAAC,oBAAoB,CAAC;MAChD;MACA;;MAEA,IAAI,IAAI,CAACiB,MAAM,KAAKY,KAAK,EAAE;QACzB,IAAI,CAACZ,MAAM,GAAGY,KAAK;QACnB,IAAI,CAACN,YAAY,CAAC,IAAI,CAACP,MAAM,CAAC;QAC9B,IAAI,CAACG,eAAe,CAAC,CAAC;MACxB;IACF;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEW,eAAe,EAAE;IACfH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,MAAM,CAACU,GAAG,CAAC,IAAI,CAACP,qBAAqB,CAAC;IACpD;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhB,kBAAkB,CAACsB,SAAS,CAACK,YAAY,GAAG,UAAUC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,OAAO,EAAE;EAC1E,MAAMC,GAAG,GAAGC,MAAM,CAACL,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC;EAC/B,IAAII,MAAM;EACV,MAAMC,KAAK,GAAG,IAAI,CAACzB,UAAU,CAAC,IAAI,CAACM,qBAAqB,CAAC;EACzD,IAAIrB,OAAO,CAACwC,KAAK,CAAC,IAAIxC,OAAO,CAACwC,KAAK,CAACH,GAAG,CAAC,CAAC,EAAE;IACzC,MAAMI,IAAI,GAAGD,KAAK,CAACH,GAAG,CAAC;IACvBE,MAAM,GAAGE,IAAI,CAACC,OAAO,CAACC,KAAK,CAAC,UAAUC,CAAC,EAAE;MACvC;MACAR,OAAO,CAACS,KAAK,GAAGJ,IAAI,CAACL,OAAO,CAACS,KAAK;MAClC,MAAMD,CAAC;IACT,CAAC,CAAC;IACF,OAAOJ,KAAK,CAACH,GAAG,CAAC;EACnB;EAEA,OAAOE,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlC,kBAAkB,CAACsB,SAAS,CAACmB,wBAAwB,GAAG,UACtDb,CAAC,EACDC,CAAC,EACDC,KAAK,EACLC,OAAO,EACP;EACA,MAAMC,GAAG,GAAGC,MAAM,CAACL,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC;EAC/B,MAAMY,yBAAyB,GAAG,IAAI,CAAC/B,0BAA0B;;EAEjE;EACA,MAAMgC,mBAAmB,GAAGC,sBAAsB,CAAC,IAAI,CAAC;EACxD,MAAMC,IAAI,GAAG;IACXb,GAAG,EAAEA,GAAG;IACR;IACA;IACAc,gBAAgB,EAAEf,OAAO,CAACe;EAC5B,CAAC;EACD,IACE,CAACnD,OAAO,CAACgD,mBAAmB,CAAC,IAC7B,CAACI,UAAU,CAAC,IAAI,EAAEF,IAAI,EAAEF,mBAAmB,CAAC,EAC5C;IACA;IACAD,yBAAyB,CAACM,IAAI,CAACH,IAAI,CAAC;EACtC;;EAEA;EACA,IAAIH,yBAAyB,CAACO,MAAM,IAAI,GAAG,EAAE;IAC3CP,yBAAyB,CAACQ,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;EAC1C;AACF,CAAC;AAEDlD,kBAAkB,CAACsB,SAAS,CAACH,YAAY,GAAG,UAAUd,KAAK,EAAE;EAC3D,MAAM8C,IAAI,GAAG9C,KAAK,CAAC+C,WAAW;EAC9B,MAAM9C,KAAK,GAAG,IAAI,CAACO,MAAM;EACzB,MAAMwC,KAAK,GAAG/C,KAAK,CAACgD,OAAO,CAACH,IAAI,CAAC;EACjC,MAAMI,oBAAoB,GAAG,IAAI,CAACvC,qBAAqB;EAEvD,IAAIqC,KAAK,KAAKE,oBAAoB,EAAE;IAClC;IACA,MAAMC,YAAY,GAAG,IAAI,CAAC9C,UAAU,CAAC6C,oBAAoB,CAAC;IAC1D,KAAK,MAAME,CAAC,IAAID,YAAY,EAAE;MAC5B,IAAIA,YAAY,CAACE,cAAc,CAACD,CAAC,CAAC,EAAE;QAClCD,YAAY,CAACC,CAAC,CAAC,CAAC1B,OAAO,CAAC4B,MAAM,CAAC,CAAC;MAClC;IACF;IACA,OAAO,IAAI,CAACjD,UAAU,CAAC6C,oBAAoB,CAAC;IAC5C,IAAI,CAAC5C,0BAA0B,GAAG,EAAE;IAEpC,IAAI,CAACK,qBAAqB,GAAGqC,KAAK;IAClC,IAAI,CAACtC,eAAe,CAAC,CAAC;IAEtB;EACF;EAEA,MAAM4B,mBAAmB,GAAGC,sBAAsB,CAAC,IAAI,CAAC;EACxD,IAAIjD,OAAO,CAACgD,mBAAmB,CAAC,EAAE;IAChC;IACA;IACA,MAAMiB,cAAc,GAAG,IAAI,CAACjD,0BAA0B;IACtD,IAAIkD,OAAO,GAAG,IAAI;IAClB,OAAOA,OAAO,EAAE;MACd,IAAID,cAAc,CAACX,MAAM,KAAK,CAAC,EAAE;QAC/B;MACF;MAEA,MAAMJ,IAAI,GAAGe,cAAc,CAACE,GAAG,CAAC,CAAC;MACjCD,OAAO,GAAGd,UAAU,CAAC,IAAI,EAAEF,IAAI,EAAEF,mBAAmB,CAAC;MACrD,IAAI,CAACkB,OAAO,EAAE;QACZD,cAAc,CAACZ,IAAI,CAACH,IAAI,CAAC;MAC3B;IACF;EACF;AACF,CAAC;AAED,SAASZ,MAAMA,CAACL,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAE;EAC3B,OAAO,GAAGF,CAAC,IAAIC,CAAC,IAAIC,KAAK,EAAE;AAC7B;AAEA,SAASiC,cAAcA,CAAC/B,GAAG,EAAE;EAC3B,MAAMgC,CAAC,GAAGhC,GAAG,CAACiC,KAAK,CAAC,GAAG,CAAC;EACxB,IAAID,CAAC,CAACf,MAAM,KAAK,CAAC,EAAE;IAClB,OAAOiB,SAAS;EAClB;EAEA,OAAO;IACLtC,CAAC,EAAEuC,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;IACfnC,CAAC,EAAEsC,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;IACflC,KAAK,EAAEqC,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC;EACpB,CAAC;AACH;AAEA,SAASpB,sBAAsBA,CAACwB,IAAI,EAAE;EACpC,MAAM9D,KAAK,GAAG8D,IAAI,CAACvD,MAAM;EACzB,IAAI,CAAClB,OAAO,CAACW,KAAK,CAAC,EAAE;IACnB,OAAO4D,SAAS;EAClB;EACA,MAAM7D,KAAK,GAAG+D,IAAI,CAACxD,MAAM;EACzB,MAAMuC,IAAI,GAAG9C,KAAK,CAAC+C,WAAW;EAC9B,MAAMiB,WAAW,GAAGhE,KAAK,CAACiE,UAAU,IAAIjE,KAAK,CAACkE,aAAa;EAC3D,MAAMC,UAAU,GAAGnE,KAAK,CAACmE,UAAU;EAEnC,IAAI,CAACH,WAAW,IAAIG,UAAU,KAAK,CAAC,EAAE;IACpC,OAAON,SAAS;EAClB;EAEA,IAAIO,OAAO;EACX,IAAIpB,KAAK,GAAG/C,KAAK,CAACgD,OAAO,CAACH,IAAI,CAAC;EAC/B,IAAIE,KAAK,GAAG,CAAC,EAAE;IACb,OAAOa,SAAS;EAClB;EAEA,MAAMQ,QAAQ,GAAGpE,KAAK,CAACiB,GAAG,CAAC8B,KAAK,CAAC;EACjC,IAAImB,UAAU,GAAG,CAAC,EAAE;IAClB;IACAC,OAAO,GAAG5E,UAAU,CAAC8E,iBAAiB,CAACD,QAAQ,CAACE,IAAI,EAAEzB,IAAI,CAAC;IAC3D,EAAEE,KAAK;EACT,CAAC,MAAM;IACL;IACAoB,OAAO,GAAG5E,UAAU,CAAC8E,iBAAiB,CAACD,QAAQ,CAACG,KAAK,EAAE1B,IAAI,CAAC,CAAC,CAAC;IAC9D,EAAEE,KAAK;EACT;EACAoB,OAAO,IAAID,UAAU,CAAC,CAAC;;EAEvB;EACA,OAAOnB,KAAK,IAAI,CAAC,IAAIoB,OAAO,IAAI,GAAG,GAAGnE,KAAK,CAACiB,GAAG,CAAC8B,KAAK,CAAC,GAAGa,SAAS;AACpE;AAEA,SAASnB,UAAUA,CAACqB,IAAI,EAAEvB,IAAI,EAAE6B,QAAQ,EAAE;EACxC,MAAMrB,KAAK,GAAGe,IAAI,CAACvD,MAAM,CAACyC,OAAO,CAACoB,QAAQ,CAACG,KAAK,CAAC;EACjD,MAAMC,SAAS,GAAGV,IAAI,CAAC1D,UAAU;EACjC,IAAIqE,iBAAiB,GAAGD,SAAS,CAACzB,KAAK,CAAC;EACxC,IAAI,CAAC1D,OAAO,CAACoF,iBAAiB,CAAC,EAAE;IAC/BA,iBAAiB,GAAGD,SAAS,CAACzB,KAAK,CAAC,GAAG,CAAC,CAAC;EAC3C;EAEA,MAAMrB,GAAG,GAAGa,IAAI,CAACb,GAAG;EACpB,IAAIrC,OAAO,CAACoF,iBAAiB,CAAC/C,GAAG,CAAC,CAAC,EAAE;IACnC,OAAO,IAAI,CAAC,CAAC;EACf;EAEA,MAAMgD,WAAW,GAAGjB,cAAc,CAAC/B,GAAG,CAAC;EACvC,MAAMD,OAAO,GAAG,IAAIjC,OAAO,CAAC;IAC1BmF,QAAQ,EAAE,KAAK;IACfC,gBAAgB,EAAE,IAAI;IACtBC,IAAI,EAAEpF,WAAW,CAACqF,OAAO;IACzBtC,gBAAgB,EAAED,IAAI,CAACC;EACzB,CAAC,CAAC;EACF,MAAMT,OAAO,GAAG+B,IAAI,CAACtD,qBAAqB,CACxCkE,WAAW,CAACpD,CAAC,EACboD,WAAW,CAACnD,CAAC,EACbmD,WAAW,CAAClD,KAAK,EACjBC,OAAO,EACP2C,QACF,CAAC;EACD,IAAI,CAAC/E,OAAO,CAAC0C,OAAO,CAAC,EAAE;IACrB,OAAO,KAAK;EACd;EAEA0C,iBAAiB,CAAC/C,GAAG,CAAC,GAAG;IACvBK,OAAO,EAAEA,OAAO;IAChBN,OAAO,EAAEA;EACX,CAAC;EAED,OAAO,IAAI;AACb;AACA,eAAe/B,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}