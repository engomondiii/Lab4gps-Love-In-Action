{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Transforms from \"./Transforms.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.west = defaultValue(west, 0.0);\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.south = defaultValue(south, 0.0);\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.east = defaultValue(east, 0.0);\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.north = defaultValue(north, 0.0);\n}\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {number}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    }\n  },\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {number}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    }\n  }\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  let east = rectangle.east;\n  const west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = defaultValue(west, 0.0);\n  result.south = defaultValue(south, 0.0);\n  result.east = defaultValue(east, 0.0);\n  result.north = defaultValue(north, 0.0);\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n  for (let i = 0, len = cartographics.length; i < len; i++) {\n    const position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n    const lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n  for (let i = 0, len = cartesians.length; i < len; i++) {\n    const position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n    const lonAdjusted = position.longitude >= 0 ? position.longitude : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\nconst fromBoundingSphereMatrixScratch = new Cartesian3();\nconst fromBoundingSphereEastScratch = new Cartesian3();\nconst fromBoundingSphereNorthScratch = new Cartesian3();\nconst fromBoundingSphereWestScratch = new Cartesian3();\nconst fromBoundingSphereSouthScratch = new Cartesian3();\nconst fromBoundingSpherePositionsScratch = new Array(5);\nfor (let n = 0; n < fromBoundingSpherePositionsScratch.length; ++n) {\n  fromBoundingSpherePositionsScratch[n] = new Cartesian3();\n}\n/**\n * Create a rectangle from a bounding sphere, ignoring height.\n *\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromBoundingSphere = function (boundingSphere, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingSphere\", boundingSphere);\n  //>>includeEnd('debug');\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n  if (!defined(ellipsoid)) {\n    ellipsoid = Ellipsoid.default;\n  }\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    Rectangle.clone(Rectangle.MAX_VALUE, result);\n    return result;\n  }\n  const fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, fromBoundingSphereMatrixScratch);\n  const east = Matrix4.multiplyByPointAsVector(fromENU, Cartesian3.UNIT_X, fromBoundingSphereEastScratch);\n  Cartesian3.normalize(east, east);\n  const north = Matrix4.multiplyByPointAsVector(fromENU, Cartesian3.UNIT_Y, fromBoundingSphereNorthScratch);\n  Cartesian3.normalize(north, north);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n  const south = Cartesian3.negate(north, fromBoundingSphereSouthScratch);\n  const west = Cartesian3.negate(east, fromBoundingSphereWestScratch);\n  const positions = fromBoundingSpherePositionsScratch;\n\n  // North\n  let corner = positions[0];\n  Cartesian3.add(center, north, corner);\n\n  // West\n  corner = positions[1];\n  Cartesian3.add(center, west, corner);\n\n  // South\n  corner = positions[2];\n  Cartesian3.add(center, south, corner);\n\n  // East\n  corner = positions[3];\n  Cartesian3.add(center, east, corner);\n  positions[4] = center;\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);\n  }\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  absoluteEpsilon = defaultValue(absoluteEpsilon, 0);\n  return left === right || defined(left) && defined(right) && Math.abs(left.west - right.west) <= absoluteEpsilon && Math.abs(left.south - right.south) <= absoluteEpsilon && Math.abs(left.east - right.east) <= absoluteEpsilon && Math.abs(left.north - right.north) <= absoluteEpsilon;\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.west === right.west && left.south === right.south && left.east === right.east && left.north === right.north;\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @private\n */\nRectangle._validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  const north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\"north\", north, -CesiumMath.PI_OVER_TWO);\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n  const south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\"south\", south, -CesiumMath.PI_OVER_TWO);\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n  const west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n  const east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  let east = rectangle.east;\n  const west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  const longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  const latitude = (rectangle.south + rectangle.north) * 0.5;\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n  const west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));\n  const east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));\n  if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {\n    return undefined;\n  }\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n  if (south >= north) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  const west = Math.max(rectangle.west, otherRectangle.west);\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const east = Math.min(rectangle.east, otherRectangle.east);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n  const west = CesiumMath.negativePiToPi(Math.min(rectangleWest, otherRectangleWest));\n  const east = CesiumMath.negativePiToPi(Math.max(rectangleEast, otherRectangleEast));\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  let longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n  const west = rectangle.west;\n  let east = rectangle.east;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n  return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) && (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) && latitude >= rectangle.south && latitude <= rectangle.north;\n};\nconst subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n * @param {number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n  if (!defined(result)) {\n    result = [];\n  }\n  let length = 0;\n  const north = rectangle.north;\n  const south = rectangle.south;\n  const east = rectangle.east;\n  const west = rectangle.west;\n  const lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n  for (let i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].\n *\n * @param {Rectangle} rectangle The rectangle to subsection.\n * @param {number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.\n * @param {number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.\n * @param {number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.\n * @param {number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.subsection = function (rectangle, westLerp, southLerp, eastLerp, northLerp, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.number.greaterThanOrEquals(\"westLerp\", westLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"southLerp\", southLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"eastLerp\", eastLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"eastLerp\", eastLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"northLerp\", northLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"northLerp\", northLerp, 1.0);\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, eastLerp);\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, northLerp);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  // This function doesn't use CesiumMath.lerp because it has floating point precision problems\n  // when the start and end values are the same but the t changes.\n\n  if (rectangle.west <= rectangle.east) {\n    const width = rectangle.east - rectangle.west;\n    result.west = rectangle.west + westLerp * width;\n    result.east = rectangle.west + eastLerp * width;\n  } else {\n    const width = CesiumMath.TWO_PI + rectangle.east - rectangle.west;\n    result.west = CesiumMath.negativePiToPi(rectangle.west + westLerp * width);\n    result.east = CesiumMath.negativePiToPi(rectangle.west + eastLerp * width);\n  }\n  const height = rectangle.north - rectangle.south;\n  result.south = rectangle.south + southLerp * height;\n  result.north = rectangle.south + northLerp * height;\n\n  // Fix floating point precision problems when t = 1\n  if (westLerp === 1.0) {\n    result.west = rectangle.east;\n  }\n  if (eastLerp === 1.0) {\n    result.east = rectangle.east;\n  }\n  if (southLerp === 1.0) {\n    result.south = rectangle.north;\n  }\n  if (northLerp === 1.0) {\n    result.north = rectangle.north;\n  }\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));\nexport default Rectangle;","map":{"version":3,"names":["Cartesian3","Cartographic","Check","defaultValue","defined","Ellipsoid","CesiumMath","Transforms","Matrix4","Rectangle","west","south","east","north","Object","defineProperties","prototype","width","get","computeWidth","height","computeHeight","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","rectangle","TWO_PI","fromDegrees","toRadians","fromRadians","fromCartographicArray","cartographics","Number","MAX_VALUE","westOverIDL","eastOverIDL","i","len","length","position","Math","min","longitude","max","latitude","lonAdjusted","PI","fromCartesianArray","cartesians","ellipsoid","default","cartesianToCartographic","fromBoundingSphereMatrixScratch","fromBoundingSphereEastScratch","fromBoundingSphereNorthScratch","fromBoundingSphereWestScratch","fromBoundingSphereSouthScratch","fromBoundingSpherePositionsScratch","Array","n","fromBoundingSphere","boundingSphere","center","radius","equals","ZERO","clone","fromENU","eastNorthUpToFixedFrame","multiplyByPointAsVector","UNIT_X","normalize","UNIT_Y","multiplyByScalar","negate","positions","corner","add","undefined","equalsEpsilon","left","right","absoluteEpsilon","abs","other","epsilon","_validate","number","greaterThanOrEquals","PI_OVER_TWO","lessThanOrEquals","southwest","northwest","northeast","southeast","negativePiToPi","intersection","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","expand","cartographic","contains","EPSILON14","subsampleLlaScratch","subsample","surfaceHeight","lla","cartographicToCartesian","subsection","westLerp","southLerp","eastLerp","northLerp","freeze"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Rectangle.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Transforms from \"./Transforms.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.west = defaultValue(west, 0.0);\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.south = defaultValue(south, 0.0);\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.east = defaultValue(east, 0.0);\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.north = defaultValue(north, 0.0);\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {number}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    },\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {number}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  let east = rectangle.east;\n  const west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = defaultValue(west, 0.0);\n  result.south = defaultValue(south, 0.0);\n  result.east = defaultValue(east, 0.0);\n  result.north = defaultValue(north, 0.0);\n\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n\n  for (let i = 0, len = cartographics.length; i < len; i++) {\n    const position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    const lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  let west = Number.MAX_VALUE;\n  let east = -Number.MAX_VALUE;\n  let westOverIDL = Number.MAX_VALUE;\n  let eastOverIDL = -Number.MAX_VALUE;\n  let south = Number.MAX_VALUE;\n  let north = -Number.MAX_VALUE;\n\n  for (let i = 0, len = cartesians.length; i < len; i++) {\n    const position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    const lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\nconst fromBoundingSphereMatrixScratch = new Cartesian3();\nconst fromBoundingSphereEastScratch = new Cartesian3();\nconst fromBoundingSphereNorthScratch = new Cartesian3();\nconst fromBoundingSphereWestScratch = new Cartesian3();\nconst fromBoundingSphereSouthScratch = new Cartesian3();\nconst fromBoundingSpherePositionsScratch = new Array(5);\nfor (let n = 0; n < fromBoundingSpherePositionsScratch.length; ++n) {\n  fromBoundingSpherePositionsScratch[n] = new Cartesian3();\n}\n/**\n * Create a rectangle from a bounding sphere, ignoring height.\n *\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromBoundingSphere = function (boundingSphere, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingSphere\", boundingSphere);\n  //>>includeEnd('debug');\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n\n  if (!defined(ellipsoid)) {\n    ellipsoid = Ellipsoid.default;\n  }\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    Rectangle.clone(Rectangle.MAX_VALUE, result);\n    return result;\n  }\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    fromBoundingSphereMatrixScratch,\n  );\n  const east = Matrix4.multiplyByPointAsVector(\n    fromENU,\n    Cartesian3.UNIT_X,\n    fromBoundingSphereEastScratch,\n  );\n  Cartesian3.normalize(east, east);\n  const north = Matrix4.multiplyByPointAsVector(\n    fromENU,\n    Cartesian3.UNIT_Y,\n    fromBoundingSphereNorthScratch,\n  );\n  Cartesian3.normalize(north, north);\n\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n\n  const south = Cartesian3.negate(north, fromBoundingSphereSouthScratch);\n  const west = Cartesian3.negate(east, fromBoundingSphereWestScratch);\n\n  const positions = fromBoundingSpherePositionsScratch;\n\n  // North\n  let corner = positions[0];\n  Cartesian3.add(center, north, corner);\n\n  // West\n  corner = positions[1];\n  Cartesian3.add(center, west, corner);\n\n  // South\n  corner = positions[2];\n  Cartesian3.add(center, south, corner);\n\n  // East\n  corner = positions[3];\n  Cartesian3.add(center, east, corner);\n\n  positions[4] = center;\n\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(\n      rectangle.west,\n      rectangle.south,\n      rectangle.east,\n      rectangle.north,\n    );\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  absoluteEpsilon = defaultValue(absoluteEpsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\n  );\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.west === right.west &&\n      left.south === right.south &&\n      left.east === right.east &&\n      left.north === right.north)\n  );\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @private\n */\nRectangle._validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n\n  const north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"north\",\n    north,\n    -CesiumMath.PI_OVER_TWO,\n  );\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n\n  const south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"south\",\n    south,\n    -CesiumMath.PI_OVER_TWO,\n  );\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n\n  const west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n\n  const east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  let east = rectangle.east;\n  const west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  const longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  const latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  const west = CesiumMath.negativePiToPi(\n    Math.max(rectangleWest, otherRectangleWest),\n  );\n  const east = CesiumMath.negativePiToPi(\n    Math.min(rectangleEast, otherRectangleEast),\n  );\n\n  if (\n    (rectangle.west < rectangle.east ||\n      otherRectangle.west < otherRectangle.east) &&\n    east <= west\n  ) {\n    return undefined;\n  }\n\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  const west = Math.max(rectangle.west, otherRectangle.west);\n  const south = Math.max(rectangle.south, otherRectangle.south);\n  const east = Math.min(rectangle.east, otherRectangle.east);\n  const north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  let rectangleEast = rectangle.east;\n  let rectangleWest = rectangle.west;\n\n  let otherRectangleEast = otherRectangle.east;\n  let otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  const west = CesiumMath.negativePiToPi(\n    Math.min(rectangleWest, otherRectangleWest),\n  );\n  const east = CesiumMath.negativePiToPi(\n    Math.max(rectangleEast, otherRectangleEast),\n  );\n\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  let longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n\n  const west = rectangle.west;\n  let east = rectangle.east;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n  return (\n    (longitude > west ||\n      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\n    (longitude < east ||\n      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\n    latitude >= rectangle.south &&\n    latitude <= rectangle.north\n  );\n};\n\nconst subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use.\n * @param {number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = [];\n  }\n  let length = 0;\n\n  const north = rectangle.north;\n  const south = rectangle.south;\n  const east = rectangle.east;\n  const west = rectangle.west;\n\n  const lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (let i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].\n *\n * @param {Rectangle} rectangle The rectangle to subsection.\n * @param {number} westLerp The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.\n * @param {number} southLerp The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.\n * @param {number} eastLerp The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.\n * @param {number} northLerp The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.subsection = function (\n  rectangle,\n  westLerp,\n  southLerp,\n  eastLerp,\n  northLerp,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.number.greaterThanOrEquals(\"westLerp\", westLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"southLerp\", southLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"eastLerp\", eastLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"eastLerp\", eastLerp, 1.0);\n  Check.typeOf.number.greaterThanOrEquals(\"northLerp\", northLerp, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"northLerp\", northLerp, 1.0);\n\n  Check.typeOf.number.lessThanOrEquals(\"westLerp\", westLerp, eastLerp);\n  Check.typeOf.number.lessThanOrEquals(\"southLerp\", southLerp, northLerp);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  // This function doesn't use CesiumMath.lerp because it has floating point precision problems\n  // when the start and end values are the same but the t changes.\n\n  if (rectangle.west <= rectangle.east) {\n    const width = rectangle.east - rectangle.west;\n    result.west = rectangle.west + westLerp * width;\n    result.east = rectangle.west + eastLerp * width;\n  } else {\n    const width = CesiumMath.TWO_PI + rectangle.east - rectangle.west;\n    result.west = CesiumMath.negativePiToPi(rectangle.west + westLerp * width);\n    result.east = CesiumMath.negativePiToPi(rectangle.west + eastLerp * width);\n  }\n  const height = rectangle.north - rectangle.south;\n  result.south = rectangle.south + southLerp * height;\n  result.north = rectangle.south + northLerp * height;\n\n  // Fix floating point precision problems when t = 1\n  if (westLerp === 1.0) {\n    result.west = rectangle.east;\n  }\n  if (eastLerp === 1.0) {\n    result.east = rectangle.east;\n  }\n  if (southLerp === 1.0) {\n    result.south = rectangle.north;\n  }\n  if (northLerp === 1.0) {\n    result.north = rectangle.north;\n  }\n\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(\n  new Rectangle(\n    -Math.PI,\n    -CesiumMath.PI_OVER_TWO,\n    Math.PI,\n    CesiumMath.PI_OVER_TWO,\n  ),\n);\nexport default Rectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}