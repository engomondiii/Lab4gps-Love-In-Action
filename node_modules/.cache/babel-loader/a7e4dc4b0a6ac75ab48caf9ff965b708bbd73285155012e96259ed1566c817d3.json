{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\n/**\n * A property in a property texture.\n *\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n * @param {Object<number, Texture>} options.textures An object mapping texture IDs to {@link Texture} objects.\n *\n * @alias PropertyTextureProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTextureProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const property = options.property;\n  const classProperty = options.classProperty;\n  const textures = options.textures;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  Check.typeOf.object(\"options.textures\", textures);\n  //>>includeEnd('debug');\n\n  // in EXT_structural_metadata, the property is a valid glTF textureInfo\n  const channels = defined(property.channels) ? property.channels : [0];\n  const textureInfo = property;\n  const textureReader = GltfLoaderUtil.createModelTextureReader({\n    textureInfo: textureInfo,\n    channels: reformatChannels(channels),\n    texture: textures[textureInfo.index]\n  });\n  this._min = property.min;\n  this._max = property.max;\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform = classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the property attribute does not define an offset/scale, it inherits from\n  // the class property. The class property handles setting the default of\n  // identity: (offset 0, scale 1) with the same scalar/vector/matrix types.\n  // array types are disallowed by the spec.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // offset and scale are applied on the GPU, so unpack the values\n  // as math types we can use in uniform callbacks.\n  offset = classProperty.unpackVectorAndMatrixTypes(offset);\n  scale = classProperty.unpackVectorAndMatrixTypes(scale);\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n  this._textureReader = textureReader;\n  this._classProperty = classProperty;\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n}\nObject.defineProperties(PropertyTextureProperty.prototype, {\n  /**\n   * The texture reader.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {ModelComponents.TextureReader}\n   * @readonly\n   * @private\n   */\n  textureReader: {\n    get: function () {\n      return this._textureReader;\n    }\n  },\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    }\n  },\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the property JSON itself did not define it, then it will inherit the\n   * value from the `MetadataClassProperty`. There, it also is always\n   * defined, and initialized to the default value if it was not contained\n   * in the class property JSON.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    }\n  },\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the property JSON itself did not define it, then it will inherit the\n   * value from the `MetadataClassProperty`. There, it also is always\n   * defined, and initialized to the default value if it was not contained\n   * in the class property JSON.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    }\n  },\n  /**\n   * The properties inherited from this property's class\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {MetadataClassProperty}\n   * @readonly\n   * @private\n   */\n  classProperty: {\n    get: function () {\n      return this._classProperty;\n    }\n  },\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    }\n  },\n  /**\n   * An object containing extensions.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    }\n  }\n});\nPropertyTextureProperty.prototype.isGpuCompatible = function () {\n  const classProperty = this._classProperty;\n  const type = classProperty.type;\n  const componentType = classProperty.componentType;\n  if (classProperty.isArray) {\n    // only support arrays of 1-4 UINT8 scalars (normalized or unnormalized)\n    if (classProperty.isVariableLengthArray) {\n      oneTimeWarning(`Property texture property ${classProperty.id} is a variable-length array, which is not supported`);\n      return false;\n    }\n    if (classProperty.arrayLength > 4) {\n      oneTimeWarning(`Property texture property ${classProperty.id} is an array of length ${classProperty.arrayLength}, but may have at most a length of 4`);\n      return false;\n    }\n    if (type !== MetadataType.SCALAR) {\n      oneTimeWarning(`Property texture property ${classProperty.id} is an array of type ${type}, but only SCALAR is supported`);\n      return false;\n    }\n    if (componentType !== MetadataComponentType.UINT8) {\n      oneTimeWarning(`Property texture property ${classProperty.id} is an array with component type ${componentType}, but only UINT8 is supported`);\n      return false;\n    }\n    return true;\n  }\n  if (MetadataType.isVectorType(type) || type === MetadataType.SCALAR) {\n    if (componentType !== MetadataComponentType.UINT8) {\n      oneTimeWarning(`Property texture property ${classProperty.id} has component type ${componentType}, but only UINT8 is supported`);\n      return false;\n    }\n    return true;\n  }\n\n  // For this initial implementation, only UINT8-based properties\n  // are supported.\n  oneTimeWarning(`Property texture property ${classProperty.id} has an unsupported type`);\n  return false;\n};\nconst floatTypesByComponentCount = [undefined, \"float\", \"vec2\", \"vec3\", \"vec4\"];\nconst integerTypesByComponentCount = [undefined, \"int\", \"ivec2\", \"ivec3\", \"ivec4\"];\nPropertyTextureProperty.prototype.getGlslType = function () {\n  const classProperty = this._classProperty;\n  let componentCount = MetadataType.getComponentCount(classProperty.type);\n  if (classProperty.isArray) {\n    // fixed-sized arrays of length 2-4 UINT8s are represented as vectors as the\n    // shader since those are more useful in GLSL.\n    componentCount = classProperty.arrayLength;\n  }\n\n  // Normalized UINT8 properties are float types in the shader\n  if (classProperty.normalized) {\n    return floatTypesByComponentCount[componentCount];\n  }\n\n  // other UINT8-based properties are represented as integer types.\n  return integerTypesByComponentCount[componentCount];\n};\nPropertyTextureProperty.prototype.unpackInShader = function (packedValueGlsl) {\n  const classProperty = this._classProperty;\n\n  // no unpacking needed if for normalized types\n  if (classProperty.normalized) {\n    return packedValueGlsl;\n  }\n\n  // integer types are read from the texture as normalized float values.\n  // these need to be rescaled to [0, 255] and cast to the appropriate integer\n  // type.\n  const glslType = this.getGlslType();\n  return `${glslType}(255.0 * ${packedValueGlsl})`;\n};\n\n/**\n * Reformat from an array of channel indices like <code>[0, 1]</code> to a\n * string of channels as would be used in GLSL swizzling (e.g. \"rg\")\n *\n * @param {number[]} channels the channel indices\n * @return {string} The channels as a string of \"r\", \"g\", \"b\" or \"a\" characters.\n * @private\n */\nfunction reformatChannels(channels) {\n  return channels.map(function (channelIndex) {\n    return \"rgba\".charAt(channelIndex);\n  }).join(\"\");\n}\nexport default PropertyTextureProperty;","map":{"version":3,"names":["Check","defaultValue","defined","GltfLoaderUtil","MetadataType","MetadataComponentType","oneTimeWarning","PropertyTextureProperty","options","EMPTY_OBJECT","property","classProperty","textures","typeOf","object","channels","textureInfo","textureReader","createModelTextureReader","reformatChannels","texture","index","_min","min","_max","max","offset","scale","hasValueTransform","unpackVectorAndMatrixTypes","_offset","_scale","_hasValueTransform","_textureReader","_classProperty","_extras","extras","_extensions","extensions","Object","defineProperties","prototype","get","isGpuCompatible","type","componentType","isArray","isVariableLengthArray","id","arrayLength","SCALAR","UINT8","isVectorType","floatTypesByComponentCount","undefined","integerTypesByComponentCount","getGlslType","componentCount","getComponentCount","normalized","unpackInShader","packedValueGlsl","glslType","map","channelIndex","charAt","join"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PropertyTextureProperty.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\n/**\n * A property in a property texture.\n *\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n * @param {Object<number, Texture>} options.textures An object mapping texture IDs to {@link Texture} objects.\n *\n * @alias PropertyTextureProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTextureProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const property = options.property;\n  const classProperty = options.classProperty;\n  const textures = options.textures;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  Check.typeOf.object(\"options.textures\", textures);\n  //>>includeEnd('debug');\n\n  // in EXT_structural_metadata, the property is a valid glTF textureInfo\n  const channels = defined(property.channels) ? property.channels : [0];\n  const textureInfo = property;\n  const textureReader = GltfLoaderUtil.createModelTextureReader({\n    textureInfo: textureInfo,\n    channels: reformatChannels(channels),\n    texture: textures[textureInfo.index],\n  });\n\n  this._min = property.min;\n  this._max = property.max;\n\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform =\n    classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the property attribute does not define an offset/scale, it inherits from\n  // the class property. The class property handles setting the default of\n  // identity: (offset 0, scale 1) with the same scalar/vector/matrix types.\n  // array types are disallowed by the spec.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // offset and scale are applied on the GPU, so unpack the values\n  // as math types we can use in uniform callbacks.\n  offset = classProperty.unpackVectorAndMatrixTypes(offset);\n  scale = classProperty.unpackVectorAndMatrixTypes(scale);\n\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n\n  this._textureReader = textureReader;\n  this._classProperty = classProperty;\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n}\n\nObject.defineProperties(PropertyTextureProperty.prototype, {\n  /**\n   * The texture reader.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {ModelComponents.TextureReader}\n   * @readonly\n   * @private\n   */\n  textureReader: {\n    get: function () {\n      return this._textureReader;\n    },\n  },\n\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the property JSON itself did not define it, then it will inherit the\n   * value from the `MetadataClassProperty`. There, it also is always\n   * defined, and initialized to the default value if it was not contained\n   * in the class property JSON.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * This is always defined, even when `hasValueTransform` is `false`. If\n   * the property JSON itself did not define it, then it will inherit the\n   * value from the `MetadataClassProperty`. There, it also is always\n   * defined, and initialized to the default value if it was not contained\n   * in the class property JSON.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * The properties inherited from this property's class\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {MetadataClassProperty}\n   * @readonly\n   * @private\n   */\n  classProperty: {\n    get: function () {\n      return this._classProperty;\n    },\n  },\n\n  /**\n   * Extra user-defined properties.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * An object containing extensions.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nPropertyTextureProperty.prototype.isGpuCompatible = function () {\n  const classProperty = this._classProperty;\n  const type = classProperty.type;\n  const componentType = classProperty.componentType;\n\n  if (classProperty.isArray) {\n    // only support arrays of 1-4 UINT8 scalars (normalized or unnormalized)\n    if (classProperty.isVariableLengthArray) {\n      oneTimeWarning(\n        `Property texture property ${classProperty.id} is a variable-length array, which is not supported`,\n      );\n      return false;\n    }\n    if (classProperty.arrayLength > 4) {\n      oneTimeWarning(\n        `Property texture property ${classProperty.id} is an array of length ${classProperty.arrayLength}, but may have at most a length of 4`,\n      );\n      return false;\n    }\n    if (type !== MetadataType.SCALAR) {\n      oneTimeWarning(\n        `Property texture property ${classProperty.id} is an array of type ${type}, but only SCALAR is supported`,\n      );\n      return false;\n    }\n    if (componentType !== MetadataComponentType.UINT8) {\n      oneTimeWarning(\n        `Property texture property ${classProperty.id} is an array with component type ${componentType}, but only UINT8 is supported`,\n      );\n      return false;\n    }\n    return true;\n  }\n\n  if (MetadataType.isVectorType(type) || type === MetadataType.SCALAR) {\n    if (componentType !== MetadataComponentType.UINT8) {\n      oneTimeWarning(\n        `Property texture property ${classProperty.id} has component type ${componentType}, but only UINT8 is supported`,\n      );\n      return false;\n    }\n    return true;\n  }\n\n  // For this initial implementation, only UINT8-based properties\n  // are supported.\n  oneTimeWarning(\n    `Property texture property ${classProperty.id} has an unsupported type`,\n  );\n  return false;\n};\n\nconst floatTypesByComponentCount = [undefined, \"float\", \"vec2\", \"vec3\", \"vec4\"];\nconst integerTypesByComponentCount = [\n  undefined,\n  \"int\",\n  \"ivec2\",\n  \"ivec3\",\n  \"ivec4\",\n];\nPropertyTextureProperty.prototype.getGlslType = function () {\n  const classProperty = this._classProperty;\n\n  let componentCount = MetadataType.getComponentCount(classProperty.type);\n  if (classProperty.isArray) {\n    // fixed-sized arrays of length 2-4 UINT8s are represented as vectors as the\n    // shader since those are more useful in GLSL.\n    componentCount = classProperty.arrayLength;\n  }\n\n  // Normalized UINT8 properties are float types in the shader\n  if (classProperty.normalized) {\n    return floatTypesByComponentCount[componentCount];\n  }\n\n  // other UINT8-based properties are represented as integer types.\n  return integerTypesByComponentCount[componentCount];\n};\n\nPropertyTextureProperty.prototype.unpackInShader = function (packedValueGlsl) {\n  const classProperty = this._classProperty;\n\n  // no unpacking needed if for normalized types\n  if (classProperty.normalized) {\n    return packedValueGlsl;\n  }\n\n  // integer types are read from the texture as normalized float values.\n  // these need to be rescaled to [0, 255] and cast to the appropriate integer\n  // type.\n  const glslType = this.getGlslType();\n  return `${glslType}(255.0 * ${packedValueGlsl})`;\n};\n\n/**\n * Reformat from an array of channel indices like <code>[0, 1]</code> to a\n * string of channels as would be used in GLSL swizzling (e.g. \"rg\")\n *\n * @param {number[]} channels the channel indices\n * @return {string} The channels as a string of \"r\", \"g\", \"b\" or \"a\" characters.\n * @private\n */\nfunction reformatChannels(channels) {\n  return channels\n    .map(function (channelIndex) {\n      return \"rgba\".charAt(channelIndex);\n    })\n    .join(\"\");\n}\n\nexport default PropertyTextureProperty;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}