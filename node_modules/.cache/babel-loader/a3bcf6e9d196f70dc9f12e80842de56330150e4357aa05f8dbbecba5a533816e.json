{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport SkyAtmosphereCommon from \"../Shaders/SkyAtmosphereCommon.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid. Based on\n * {@link http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf|Display of The Earth Taking Into Account Atmospheric Scattering}.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @see Scene.skyAtmosphere\n */\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = true;\n\n  /**\n   * Compute atmosphere per-fragment instead of per-vertex.\n   * This produces better looking atmosphere with a slight performance penalty.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.perFragmentAtmosphere = false;\n  this._ellipsoid = ellipsoid;\n  const outerEllipsoidScale = 1.025;\n  const scaleVector = Cartesian3.multiplyByScalar(ellipsoid.radii, outerEllipsoidScale, new Cartesian3());\n  this._scaleMatrix = Matrix4.fromScale(scaleVector);\n  this._modelMatrix = new Matrix4();\n  this._command = new DrawCommand({\n    owner: this,\n    modelMatrix: this._modelMatrix\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n  this._flags = undefined;\n\n  /**\n   * The intensity of the light that is used for computing the sky atmosphere color.\n   *\n   * @type {number}\n   * @default 50.0\n   */\n  this.atmosphereLightIntensity = 50.0;\n\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(5.5e-6, 13.0e-6, 28.4e-6)\n   */\n  this.atmosphereRayleighCoefficient = new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6);\n\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(21e-6, 21e-6, 21e-6)\n   */\n  this.atmosphereMieCoefficient = new Cartesian3(21e-6, 21e-6, 21e-6);\n\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 10000.0\n   */\n  this.atmosphereRayleighScaleHeight = 10000.0;\n\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 3200.0\n   */\n  this.atmosphereMieScaleHeight = 3200.0;\n\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * <p>\n   * Valid values are between -1.0 and 1.0.\n   * </p>\n   * @type {number}\n   * @default 0.9\n   */\n  this.atmosphereMieAnisotropy = 0.9;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {number}\n   * @default 0.0\n   */\n  this.hueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {number}\n   * @default 0.0\n   */\n  this.saturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {number}\n   * @default 0.0\n   */\n  this.brightnessShift = 0.0;\n  this._hueSaturationBrightness = new Cartesian3();\n\n  // outer radius, inner radius, dynamic atmosphere color flag\n  const radiiAndDynamicAtmosphereColor = new Cartesian3();\n  radiiAndDynamicAtmosphereColor.x = ellipsoid.maximumRadius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = ellipsoid.maximumRadius;\n\n  // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n  radiiAndDynamicAtmosphereColor.z = 0;\n  this._radiiAndDynamicAtmosphereColor = radiiAndDynamicAtmosphereColor;\n  const that = this;\n  this._command.uniformMap = {\n    u_radiiAndDynamicAtmosphereColor: function () {\n      return that._radiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function () {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    },\n    u_atmosphereLightIntensity: function () {\n      return that.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return that.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return that.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return that.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return that.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return that.atmosphereMieAnisotropy;\n    }\n  };\n}\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  }\n});\n\n/**\n * Set the dynamic lighting enum value for the shader\n * @param {DynamicAtmosphereLightingType} lightingEnum The enum that determines the dynamic atmosphere light source\n *\n * @private\n */\nSkyAtmosphere.prototype.setDynamicLighting = function (lightingEnum) {\n  this._radiiAndDynamicAtmosphereColor.z = lightingEnum;\n};\nconst scratchModelMatrix = new Matrix4();\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.update = function (frameState, globe) {\n  if (!this.show) {\n    return undefined;\n  }\n  const mode = frameState.mode;\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  }\n\n  // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  // Align the ellipsoid geometry so it always faces the same direction as the\n  // camera to reduce artifacts when rendering atmosphere per-vertex\n  const rotationMatrix = Matrix4.fromRotationTranslation(frameState.context.uniformState.inverseViewRotation, Cartesian3.ZERO, scratchModelMatrix);\n  const rotationOffsetMatrix = Matrix4.multiplyTransformation(rotationMatrix, Axis.Y_UP_TO_Z_UP, scratchModelMatrix);\n  const modelMatrix = Matrix4.multiply(this._scaleMatrix, rotationOffsetMatrix, scratchModelMatrix);\n  Matrix4.clone(modelMatrix, this._modelMatrix);\n  const context = frameState.context;\n  const colorCorrect = hasColorCorrection(this);\n  const translucent = frameState.globeTranslucencyState.translucent;\n  const perFragmentAtmosphere = this.perFragmentAtmosphere || translucent || !defined(globe) || !globe.show;\n  const command = this._command;\n  if (!defined(command.vertexArray)) {\n    const geometry = EllipsoidGeometry.createGeometry(new EllipsoidGeometry({\n      radii: new Cartesian3(1.0, 1.0, 1.0),\n      slicePartitions: 256,\n      stackPartitions: 256,\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false\n    });\n  }\n  const flags = colorCorrect | perFragmentAtmosphere << 2 | translucent << 3;\n  if (flags !== this._flags) {\n    this._flags = flags;\n    const defines = [];\n    if (colorCorrect) {\n      defines.push(\"COLOR_CORRECT\");\n    }\n    if (perFragmentAtmosphere) {\n      defines.push(\"PER_FRAGMENT_ATMOSPHERE\");\n    }\n    if (translucent) {\n      defines.push(\"GLOBE_TRANSLUCENT\");\n    }\n    const vs = new ShaderSource({\n      defines: defines,\n      sources: [AtmosphereCommon, SkyAtmosphereCommon, SkyAtmosphereVS]\n    });\n    const fs = new ShaderSource({\n      defines: defines,\n      sources: [AtmosphereCommon, SkyAtmosphereCommon, SkyAtmosphereFS]\n    });\n    this._spSkyAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs\n    });\n    command.shaderProgram = this._spSkyAtmosphere;\n  }\n  return command;\n};\nfunction hasColorCorrection(skyAtmosphere) {\n  return !(CesiumMath.equalsEpsilon(skyAtmosphere.hueShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(skyAtmosphere.saturationShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(skyAtmosphere.brightnessShift, 0.0, CesiumMath.EPSILON7));\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\nSkyAtmosphere.prototype.destroy = function () {\n  const command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyAtmosphere = this._spSkyAtmosphere && this._spSkyAtmosphere.destroy();\n  return destroyObject(this);\n};\nexport default SkyAtmosphere;","map":{"version":3,"names":["Cartesian3","defaultValue","defined","destroyObject","Ellipsoid","EllipsoidGeometry","GeometryPipeline","CesiumMath","Matrix4","VertexFormat","BufferUsage","DrawCommand","RenderState","ShaderProgram","ShaderSource","VertexArray","AtmosphereCommon","SkyAtmosphereCommon","SkyAtmosphereFS","SkyAtmosphereVS","Axis","BlendingState","CullFace","SceneMode","SkyAtmosphere","ellipsoid","WGS84","show","perFragmentAtmosphere","_ellipsoid","outerEllipsoidScale","scaleVector","multiplyByScalar","radii","_scaleMatrix","fromScale","_modelMatrix","_command","owner","modelMatrix","_spSkyFromSpace","undefined","_spSkyFromAtmosphere","_flags","atmosphereLightIntensity","atmosphereRayleighCoefficient","atmosphereMieCoefficient","atmosphereRayleighScaleHeight","atmosphereMieScaleHeight","atmosphereMieAnisotropy","hueShift","saturationShift","brightnessShift","_hueSaturationBrightness","radiiAndDynamicAtmosphereColor","x","maximumRadius","y","z","_radiiAndDynamicAtmosphereColor","that","uniformMap","u_radiiAndDynamicAtmosphereColor","u_hsbShift","u_atmosphereLightIntensity","u_atmosphereRayleighCoefficient","u_atmosphereMieCoefficient","u_atmosphereRayleighScaleHeight","u_atmosphereMieScaleHeight","u_atmosphereMieAnisotropy","Object","defineProperties","prototype","get","setDynamicLighting","lightingEnum","scratchModelMatrix","update","frameState","globe","mode","SCENE3D","MORPHING","passes","render","rotationMatrix","fromRotationTranslation","context","uniformState","inverseViewRotation","ZERO","rotationOffsetMatrix","multiplyTransformation","Y_UP_TO_Z_UP","multiply","clone","colorCorrect","hasColorCorrection","translucent","globeTranslucencyState","command","vertexArray","geometry","createGeometry","slicePartitions","stackPartitions","vertexFormat","POSITION_ONLY","fromGeometry","attributeLocations","createAttributeLocations","bufferUsage","STATIC_DRAW","renderState","fromCache","cull","enabled","face","FRONT","blending","ALPHA_BLEND","depthMask","flags","defines","push","vs","sources","fs","_spSkyAtmosphere","vertexShaderSource","fragmentShaderSource","shaderProgram","skyAtmosphere","equalsEpsilon","EPSILON7","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/SkyAtmosphere.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport SkyAtmosphereCommon from \"../Shaders/SkyAtmosphereCommon.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid. Based on\n * {@link http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf|Display of The Earth Taking Into Account Atmospheric Scattering}.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @see Scene.skyAtmosphere\n */\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = true;\n\n  /**\n   * Compute atmosphere per-fragment instead of per-vertex.\n   * This produces better looking atmosphere with a slight performance penalty.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.perFragmentAtmosphere = false;\n\n  this._ellipsoid = ellipsoid;\n\n  const outerEllipsoidScale = 1.025;\n  const scaleVector = Cartesian3.multiplyByScalar(\n    ellipsoid.radii,\n    outerEllipsoidScale,\n    new Cartesian3(),\n  );\n  this._scaleMatrix = Matrix4.fromScale(scaleVector);\n  this._modelMatrix = new Matrix4();\n\n  this._command = new DrawCommand({\n    owner: this,\n    modelMatrix: this._modelMatrix,\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n\n  this._flags = undefined;\n\n  /**\n   * The intensity of the light that is used for computing the sky atmosphere color.\n   *\n   * @type {number}\n   * @default 50.0\n   */\n  this.atmosphereLightIntensity = 50.0;\n\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(5.5e-6, 13.0e-6, 28.4e-6)\n   */\n  this.atmosphereRayleighCoefficient = new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6);\n\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(21e-6, 21e-6, 21e-6)\n   */\n  this.atmosphereMieCoefficient = new Cartesian3(21e-6, 21e-6, 21e-6);\n\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 10000.0\n   */\n  this.atmosphereRayleighScaleHeight = 10000.0;\n\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   *\n   * @type {number}\n   * @default 3200.0\n   */\n  this.atmosphereMieScaleHeight = 3200.0;\n\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * <p>\n   * Valid values are between -1.0 and 1.0.\n   * </p>\n   * @type {number}\n   * @default 0.9\n   */\n  this.atmosphereMieAnisotropy = 0.9;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {number}\n   * @default 0.0\n   */\n  this.hueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {number}\n   * @default 0.0\n   */\n  this.saturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {number}\n   * @default 0.0\n   */\n  this.brightnessShift = 0.0;\n\n  this._hueSaturationBrightness = new Cartesian3();\n\n  // outer radius, inner radius, dynamic atmosphere color flag\n  const radiiAndDynamicAtmosphereColor = new Cartesian3();\n\n  radiiAndDynamicAtmosphereColor.x =\n    ellipsoid.maximumRadius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = ellipsoid.maximumRadius;\n\n  // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n  radiiAndDynamicAtmosphereColor.z = 0;\n\n  this._radiiAndDynamicAtmosphereColor = radiiAndDynamicAtmosphereColor;\n\n  const that = this;\n\n  this._command.uniformMap = {\n    u_radiiAndDynamicAtmosphereColor: function () {\n      return that._radiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function () {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    },\n    u_atmosphereLightIntensity: function () {\n      return that.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return that.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return that.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return that.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return that.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return that.atmosphereMieAnisotropy;\n    },\n  };\n}\n\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Set the dynamic lighting enum value for the shader\n * @param {DynamicAtmosphereLightingType} lightingEnum The enum that determines the dynamic atmosphere light source\n *\n * @private\n */\nSkyAtmosphere.prototype.setDynamicLighting = function (lightingEnum) {\n  this._radiiAndDynamicAtmosphereColor.z = lightingEnum;\n};\n\nconst scratchModelMatrix = new Matrix4();\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.update = function (frameState, globe) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  const mode = frameState.mode;\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  }\n\n  // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  // Align the ellipsoid geometry so it always faces the same direction as the\n  // camera to reduce artifacts when rendering atmosphere per-vertex\n  const rotationMatrix = Matrix4.fromRotationTranslation(\n    frameState.context.uniformState.inverseViewRotation,\n    Cartesian3.ZERO,\n    scratchModelMatrix,\n  );\n  const rotationOffsetMatrix = Matrix4.multiplyTransformation(\n    rotationMatrix,\n    Axis.Y_UP_TO_Z_UP,\n    scratchModelMatrix,\n  );\n  const modelMatrix = Matrix4.multiply(\n    this._scaleMatrix,\n    rotationOffsetMatrix,\n    scratchModelMatrix,\n  );\n  Matrix4.clone(modelMatrix, this._modelMatrix);\n\n  const context = frameState.context;\n\n  const colorCorrect = hasColorCorrection(this);\n  const translucent = frameState.globeTranslucencyState.translucent;\n  const perFragmentAtmosphere =\n    this.perFragmentAtmosphere || translucent || !defined(globe) || !globe.show;\n\n  const command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    const geometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        slicePartitions: 256,\n        stackPartitions: 256,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      }),\n    );\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false,\n    });\n  }\n\n  const flags =\n    colorCorrect | (perFragmentAtmosphere << 2) | (translucent << 3);\n\n  if (flags !== this._flags) {\n    this._flags = flags;\n\n    const defines = [];\n\n    if (colorCorrect) {\n      defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (perFragmentAtmosphere) {\n      defines.push(\"PER_FRAGMENT_ATMOSPHERE\");\n    }\n\n    if (translucent) {\n      defines.push(\"GLOBE_TRANSLUCENT\");\n    }\n\n    const vs = new ShaderSource({\n      defines: defines,\n      sources: [AtmosphereCommon, SkyAtmosphereCommon, SkyAtmosphereVS],\n    });\n\n    const fs = new ShaderSource({\n      defines: defines,\n      sources: [AtmosphereCommon, SkyAtmosphereCommon, SkyAtmosphereFS],\n    });\n\n    this._spSkyAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n    });\n\n    command.shaderProgram = this._spSkyAtmosphere;\n  }\n\n  return command;\n};\n\nfunction hasColorCorrection(skyAtmosphere) {\n  return !(\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.hueShift,\n      0.0,\n      CesiumMath.EPSILON7,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.saturationShift,\n      0.0,\n      CesiumMath.EPSILON7,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.brightnessShift,\n      0.0,\n      CesiumMath.EPSILON7,\n    )\n  );\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\nSkyAtmosphere.prototype.destroy = function () {\n  const command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyAtmosphere =\n    this._spSkyAtmosphere && this._spSkyAtmosphere.destroy();\n  return destroyObject(this);\n};\nexport default SkyAtmosphere;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}