{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nfunction setConstants(ellipsoidGeodesic) {\n  const uSquared = ellipsoidGeodesic._uSquared;\n  const a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  const b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  const f = (a - b) / a;\n  const cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  const sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n  const tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n  const cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  const sineU = cosineU * tanU;\n  const sigma = Math.atan2(tanU, cosineHeading);\n  const sineAlpha = cosineU * sineHeading;\n  const sineSquaredAlpha = sineAlpha * sineAlpha;\n  const cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  const cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n  const u2Over4 = uSquared / 4.0;\n  const u4Over16 = u2Over4 * u2Over4;\n  const u6Over64 = u4Over16 * u2Over4;\n  const u8Over256 = u4Over16 * u4Over16;\n  const a0 = 1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0;\n  const a1 = 1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0;\n  const a2 = 1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0;\n  const a3 = 1.0 - 5.0 * u2Over4;\n  const distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 - a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;\n  const constants = ellipsoidGeodesic._constants;\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\nfunction computeC(f, cosineSquaredAlpha) {\n  return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;\n}\nfunction computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {\n  const C = computeC(f, cosineSquaredAlpha);\n  return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));\n}\nfunction vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {\n  const eff = (major - minor) / major;\n  const l = secondLongitude - firstLongitude;\n  const u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  const u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n  const cosineU1 = Math.cos(u1);\n  const sineU1 = Math.sin(u1);\n  const cosineU2 = Math.cos(u2);\n  const sineU2 = Math.sin(u2);\n  const cc = cosineU1 * cosineU2;\n  const cs = cosineU1 * sineU2;\n  const ss = sineU1 * sineU2;\n  const sc = sineU1 * cosineU2;\n  let lambda = l;\n  let lambdaDot = CesiumMath.TWO_PI;\n  let cosineLambda = Math.cos(lambda);\n  let sineLambda = Math.sin(lambda);\n  let sigma;\n  let cosineSigma;\n  let sineSigma;\n  let cosineSquaredAlpha;\n  let cosineTwiceSigmaMidpoint;\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n    const temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);\n    cosineSigma = ss + cc * cosineLambda;\n    sigma = Math.atan2(sineSigma, cosineSigma);\n    let sineAlpha;\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = cc * sineLambda / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n    lambdaDot = lambda;\n    cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;\n    if (!isFinite(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n    lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\n  } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n  const uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);\n  const A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;\n  const B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;\n  const cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  const deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint * (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);\n  const distance = minor * A * (sigma - deltaSigma);\n  const startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);\n  const endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);\n  const lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"value\", Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI), 0.0125);\n  //>>includeEnd('debug');\n\n  vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius, start.longitude, start.latitude, end.longitude, end.latitude);\n  ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);\n  ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  const e = defaultValue(ellipsoid, Ellipsoid.default);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    }\n  },\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    }\n  },\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    }\n  },\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._startHeading;\n    }\n  },\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._endHeading;\n    }\n  }\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (fraction, result) {\n  return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {number} distance The distance from the initial point to the point of interest along the geodesic\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (distance, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"distance\", this._distance);\n  //>>includeEnd('debug');\n\n  const constants = this._constants;\n  const s = constants.distanceRatio + distance / constants.b;\n  const cosine2S = Math.cos(2.0 * s);\n  const cosine4S = Math.cos(4.0 * s);\n  const cosine6S = Math.cos(6.0 * s);\n  const sine2S = Math.sin(2.0 * s);\n  const sine4S = Math.sin(4.0 * s);\n  const sine6S = Math.sin(6.0 * s);\n  const sine8S = Math.sin(8.0 * s);\n  const s2 = s * s;\n  const s3 = s * s2;\n  const u8Over256 = constants.u8Over256;\n  const u2Over4 = constants.u2Over4;\n  const u6Over64 = constants.u6Over64;\n  const u4Over16 = constants.u4Over16;\n  let sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 + s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 - (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S - (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S - 29.0 * u8Over256 * cosine6S / 16.0) + (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S + (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S - s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) + (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S + 539.0 * u8Over256 * sine8S / 1536.0;\n  const theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  const latitude = Math.atan(constants.a / constants.b * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n  const cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n  const sineSigma = Math.sin(sigma);\n  const cosineSigma = Math.cos(sigma);\n  const cc = constants.cosineU * cosineSigma;\n  const ss = constants.sineU * sineSigma;\n  const lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);\n  const l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\n  if (defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n  return new Cartographic(this._start.longitude + l, latitude, 0.0);\n};\nexport default EllipsoidGeodesic;","map":{"version":3,"names":["Cartesian3","Cartographic","Check","defaultValue","defined","Ellipsoid","CesiumMath","setConstants","ellipsoidGeodesic","uSquared","_uSquared","a","_ellipsoid","maximumRadius","b","minimumRadius","f","cosineHeading","Math","cos","_startHeading","sineHeading","sin","tanU","tan","_start","latitude","cosineU","sqrt","sineU","sigma","atan2","sineAlpha","sineSquaredAlpha","cosineSquaredAlpha","cosineAlpha","u2Over4","u4Over16","u6Over64","u8Over256","a0","a1","a2","a3","distanceRatio","constants","_constants","computeC","computeDeltaLambda","sineSigma","cosineSigma","cosineTwiceSigmaMidpoint","C","vincentyInverseFormula","major","minor","firstLongitude","firstLatitude","secondLongitude","secondLatitude","eff","l","u1","atan","u2","cosineU1","sineU1","cosineU2","sineU2","cc","cs","ss","sc","lambda","lambdaDot","TWO_PI","cosineLambda","sineLambda","temp","isFinite","abs","EPSILON12","A","B","cosineSquaredTwiceSigmaMidpoint","deltaSigma","distance","startHeading","endHeading","_distance","_endHeading","scratchCart1","scratchCart2","computeProperties","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","typeOf","number","greaterThanOrEquals","angleBetween","PI","longitude","clone","_end","height","EllipsoidGeodesic","e","default","undefined","Object","defineProperties","prototype","get","surfaceDistance","setEndPoints","interpolateUsingFraction","fraction","result","interpolateUsingSurfaceDistance","s","cosine2S","cosine4S","cosine6S","sine2S","sine4S","sine6S","sine8S","s2","s3","theta","asin"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EllipsoidGeodesic.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction setConstants(ellipsoidGeodesic) {\n  const uSquared = ellipsoidGeodesic._uSquared;\n  const a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  const b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  const f = (a - b) / a;\n\n  const cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  const sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n  const tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n  const cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  const sineU = cosineU * tanU;\n\n  const sigma = Math.atan2(tanU, cosineHeading);\n\n  const sineAlpha = cosineU * sineHeading;\n  const sineSquaredAlpha = sineAlpha * sineAlpha;\n\n  const cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  const cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n  const u2Over4 = uSquared / 4.0;\n  const u4Over16 = u2Over4 * u2Over4;\n  const u6Over64 = u4Over16 * u2Over4;\n  const u8Over256 = u4Over16 * u4Over16;\n\n  const a0 =\n    1.0 +\n    u2Over4 -\n    (3.0 * u4Over16) / 4.0 +\n    (5.0 * u6Over64) / 4.0 -\n    (175.0 * u8Over256) / 64.0;\n  const a1 = 1.0 - u2Over4 + (15.0 * u4Over16) / 8.0 - (35.0 * u6Over64) / 8.0;\n  const a2 = 1.0 - 3.0 * u2Over4 + (35.0 * u4Over16) / 4.0;\n  const a3 = 1.0 - 5.0 * u2Over4;\n\n  const distanceRatio =\n    a0 * sigma -\n    (a1 * Math.sin(2.0 * sigma) * u2Over4) / 2.0 -\n    (a2 * Math.sin(4.0 * sigma) * u4Over16) / 16.0 -\n    (a3 * Math.sin(6.0 * sigma) * u6Over64) / 48.0 -\n    (Math.sin(8.0 * sigma) * 5.0 * u8Over256) / 512;\n\n  const constants = ellipsoidGeodesic._constants;\n\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return (\n    (f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha))) /\n    16.0\n  );\n}\n\nfunction computeDeltaLambda(\n  f,\n  sineAlpha,\n  cosineSquaredAlpha,\n  sigma,\n  sineSigma,\n  cosineSigma,\n  cosineTwiceSigmaMidpoint,\n) {\n  const C = computeC(f, cosineSquaredAlpha);\n\n  return (\n    (1.0 - C) *\n    f *\n    sineAlpha *\n    (sigma +\n      C *\n        sineSigma *\n        (cosineTwiceSigmaMidpoint +\n          C *\n            cosineSigma *\n            (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)))\n  );\n}\n\nfunction vincentyInverseFormula(\n  ellipsoidGeodesic,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude,\n) {\n  const eff = (major - minor) / major;\n  const l = secondLongitude - firstLongitude;\n\n  const u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  const u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n  const cosineU1 = Math.cos(u1);\n  const sineU1 = Math.sin(u1);\n  const cosineU2 = Math.cos(u2);\n  const sineU2 = Math.sin(u2);\n\n  const cc = cosineU1 * cosineU2;\n  const cs = cosineU1 * sineU2;\n  const ss = sineU1 * sineU2;\n  const sc = sineU1 * cosineU2;\n\n  let lambda = l;\n  let lambdaDot = CesiumMath.TWO_PI;\n\n  let cosineLambda = Math.cos(lambda);\n  let sineLambda = Math.sin(lambda);\n\n  let sigma;\n  let cosineSigma;\n  let sineSigma;\n  let cosineSquaredAlpha;\n  let cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n\n    const temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(\n      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp,\n    );\n    cosineSigma = ss + cc * cosineLambda;\n\n    sigma = Math.atan2(sineSigma, cosineSigma);\n\n    let sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = (cc * sineLambda) / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n\n    cosineTwiceSigmaMidpoint = cosineSigma - (2.0 * ss) / cosineSquaredAlpha;\n\n    if (!isFinite(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda =\n      l +\n      computeDeltaLambda(\n        eff,\n        sineAlpha,\n        cosineSquaredAlpha,\n        sigma,\n        sineSigma,\n        cosineSigma,\n        cosineTwiceSigmaMidpoint,\n      );\n  } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n\n  const uSquared =\n    (cosineSquaredAlpha * (major * major - minor * minor)) / (minor * minor);\n  const A =\n    1.0 +\n    (uSquared *\n      (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0))) /\n      16384.0;\n  const B =\n    (uSquared *\n      (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0))) /\n    1024.0;\n\n  const cosineSquaredTwiceSigmaMidpoint =\n    cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  const deltaSigma =\n    B *\n    sineSigma *\n    (cosineTwiceSigmaMidpoint +\n      (B *\n        (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) -\n          (B *\n            cosineTwiceSigmaMidpoint *\n            (4.0 * sineSigma * sineSigma - 3.0) *\n            (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0)) /\n            6.0)) /\n        4.0);\n\n  const distance = minor * A * (sigma - deltaSigma);\n\n  const startHeading = Math.atan2(\n    cosineU2 * sineLambda,\n    cs - sc * cosineLambda,\n  );\n  const endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1,\n  );\n  const lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2,\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) -\n        Math.PI,\n    ),\n    0.0125,\n  );\n  //>>includeEnd('debug');\n\n  vincentyInverseFormula(\n    ellipsoidGeodesic,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude,\n  );\n\n  ellipsoidGeodesic._start = Cartographic.clone(\n    start,\n    ellipsoidGeodesic._start,\n  );\n  ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  const e = defaultValue(ellipsoid, Ellipsoid.default);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._startHeading;\n    },\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._endHeading;\n    },\n  },\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (\n  fraction,\n  result,\n) {\n  return this.interpolateUsingSurfaceDistance(\n    this._distance * fraction,\n    result,\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {number} distance The distance from the initial point to the point of interest along the geodesic\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"distance\", this._distance);\n  //>>includeEnd('debug');\n\n  const constants = this._constants;\n\n  const s = constants.distanceRatio + distance / constants.b;\n\n  const cosine2S = Math.cos(2.0 * s);\n  const cosine4S = Math.cos(4.0 * s);\n  const cosine6S = Math.cos(6.0 * s);\n  const sine2S = Math.sin(2.0 * s);\n  const sine4S = Math.sin(4.0 * s);\n  const sine6S = Math.sin(6.0 * s);\n  const sine8S = Math.sin(8.0 * s);\n\n  const s2 = s * s;\n  const s3 = s * s2;\n\n  const u8Over256 = constants.u8Over256;\n  const u2Over4 = constants.u2Over4;\n  const u6Over64 = constants.u6Over64;\n  const u4Over16 = constants.u4Over16;\n  let sigma =\n    (2.0 * s3 * u8Over256 * cosine2S) / 3.0 +\n    s *\n      (1.0 -\n        u2Over4 +\n        (7.0 * u4Over16) / 4.0 -\n        (15.0 * u6Over64) / 4.0 +\n        (579.0 * u8Over256) / 64.0 -\n        (u4Over16 - (15.0 * u6Over64) / 4.0 + (187.0 * u8Over256) / 16.0) *\n          cosine2S -\n        ((5.0 * u6Over64) / 4.0 - (115.0 * u8Over256) / 16.0) * cosine4S -\n        (29.0 * u8Over256 * cosine6S) / 16.0) +\n    (u2Over4 / 2.0 -\n      u4Over16 +\n      (71.0 * u6Over64) / 32.0 -\n      (85.0 * u8Over256) / 16.0) *\n      sine2S +\n    ((5.0 * u4Over16) / 16.0 -\n      (5.0 * u6Over64) / 4.0 +\n      (383.0 * u8Over256) / 96.0) *\n      sine4S -\n    s2 *\n      ((u6Over64 - (11.0 * u8Over256) / 2.0) * sine2S +\n        (5.0 * u8Over256 * sine4S) / 2.0) +\n    ((29.0 * u6Over64) / 96.0 - (29.0 * u8Over256) / 16.0) * sine6S +\n    (539.0 * u8Over256 * sine8S) / 1536.0;\n\n  const theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  const latitude = Math.atan((constants.a / constants.b) * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n\n  const cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n  const sineSigma = Math.sin(sigma);\n  const cosineSigma = Math.cos(sigma);\n\n  const cc = constants.cosineU * cosineSigma;\n  const ss = constants.sineU * sineSigma;\n\n  const lambda = Math.atan2(\n    sineSigma * constants.sineHeading,\n    cc - ss * constants.cosineHeading,\n  );\n\n  const l =\n    lambda -\n    computeDeltaLambda(\n      constants.f,\n      constants.sineAlpha,\n      constants.cosineSquaredAlpha,\n      sigma,\n      sineSigma,\n      cosineSigma,\n      cosineTwiceSigmaMidpoint,\n    );\n\n  if (defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new Cartographic(this._start.longitude + l, latitude, 0.0);\n};\nexport default EllipsoidGeodesic;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}