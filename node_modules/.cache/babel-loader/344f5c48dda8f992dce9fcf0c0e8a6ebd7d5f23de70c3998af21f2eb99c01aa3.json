{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometry objects. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = 2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength + VertexFormat.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n  array[startingIndex++] = frustumType;\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n  return array;\n};\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const frustumType = array[startingIndex++];\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(array, startingIndex, scratchPackPerspective);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(array, startingIndex, scratchPackOrthographic);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(array, startingIndex, scratchPackQuaternion);\n  startingIndex += Quaternion.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane\n    });\n  }\n  const frustumResult = frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n  return result;\n};\nfunction getAttributes(offset, normals, tangents, bitangents, st, normal, tangent, bitangent) {\n  const stOffset = offset / 3 * 2;\n  for (let i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n    offset += 3;\n  }\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\nconst scratchRotationMatrix = new Matrix3();\nconst scratchViewMatrix = new Matrix4();\nconst scratchInverseMatrix = new Matrix4();\nconst scratchXDirection = new Cartesian3();\nconst scratchYDirection = new Cartesian3();\nconst scratchZDirection = new Cartesian3();\nconst scratchNegativeX = new Cartesian3();\nconst scratchNegativeY = new Cartesian3();\nconst scratchNegativeZ = new Cartesian3();\nconst frustumSplits = new Array(3);\nconst frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\nconst scratchFrustumCorners = new Array(4);\nfor (let i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\nFrustumGeometry._computeNearFarPlanes = function (origin, orientation, frustumType, frustum, positions, xDirection, yDirection, zDirection) {\n  const rotationMatrix = Matrix3.fromQuaternion(orientation, scratchRotationMatrix);\n  let x = defaultValue(xDirection, scratchXDirection);\n  let y = defaultValue(yDirection, scratchYDirection);\n  let z = defaultValue(zDirection, scratchZDirection);\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n  Cartesian3.negate(x, x);\n  const view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n  let inverseView;\n  let inverseViewProjection;\n  const projection = frustum.projectionMatrix;\n  if (frustumType === PERSPECTIVE) {\n    const viewProjection = Matrix4.multiply(projection, view, scratchInverseMatrix);\n    inverseViewProjection = Matrix4.inverse(viewProjection, scratchInverseMatrix);\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n  for (let i = 0; i < 2; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      let corner = Cartesian4.clone(frustumCornersNDC[j], scratchFrustumCorners[j]);\n      if (!defined(inverseViewProjection)) {\n        const offCenterFrustum = frustum.offCenterFrustum;\n        if (defined(offCenterFrustum)) {\n          frustum = offCenterFrustum;\n        }\n        const near = frustumSplits[i];\n        const far = frustumSplits[i + 1];\n        corner.x = (corner.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;\n        corner.y = (corner.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(inverseViewProjection, corner, corner);\n\n        // Reverse perspective divide\n        const w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n        const fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n  const vertexFormat = frustumGeometry._vertexFormat;\n  const numberOfPlanes = drawNearPlane ? 6 : 5;\n  let positions = new Float64Array(3 * 4 * 6);\n  FrustumGeometry._computeNearFarPlanes(origin, orientation, frustumType, frustum, positions);\n\n  // -x plane\n  let offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2];\n\n  // -y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2];\n\n  // +x plane\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2];\n\n  // +y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n  if (defined(vertexFormat.normal) || defined(vertexFormat.tangent) || defined(vertexFormat.bitangent) || defined(vertexFormat.st)) {\n    const normals = defined(vertexFormat.normal) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\n    const tangents = defined(vertexFormat.tangent) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\n    const bitangents = defined(vertexFormat.bitangent) ? new Float32Array(3 * 4 * numberOfPlanes) : undefined;\n    const st = defined(vertexFormat.st) ? new Float32Array(2 * 4 * numberOfPlanes) : undefined;\n    const x = scratchXDirection;\n    const y = scratchYDirection;\n    const z = scratchZDirection;\n    const negativeX = Cartesian3.negate(x, scratchNegativeX);\n    const negativeY = Cartesian3.negate(y, scratchNegativeY);\n    const negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n    offset = 0;\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n      offset += 3 * 4;\n    }\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, negativeX, negativeZ, y); // -x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, negativeY, negativeZ, negativeX); // -y\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals\n      });\n    }\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents\n      });\n    }\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents\n      });\n    }\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st\n      });\n    }\n  }\n  const indices = new Uint16Array(6 * numberOfPlanes);\n  for (let i = 0; i < numberOfPlanes; ++i) {\n    const indexOffset = i * 6;\n    const index = i * 4;\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions)\n  });\n};\nexport default FrustumGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Cartesian4","Check","ComponentDatatype","defaultValue","defined","Geometry","GeometryAttribute","GeometryAttributes","Matrix3","Matrix4","OrthographicFrustum","PerspectiveFrustum","PrimitiveType","Quaternion","VertexFormat","PERSPECTIVE","ORTHOGRAPHIC","FrustumGeometry","options","typeOf","object","frustum","origin","orientation","vertexFormat","DEFAULT","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","packedLength","_frustumType","_frustum","clone","_origin","_orientation","_vertexFormat","_workerName","pack","value","array","startingIndex","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","scratchVertexFormat","unpack","result","frustumResult","undefined","getAttributes","offset","normals","tangents","bitangents","st","normal","tangent","bitangent","stOffset","i","x","y","z","scratchRotationMatrix","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","Array","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","positions","xDirection","yDirection","zDirection","rotationMatrix","fromQuaternion","getColumn","normalize","negate","view","computeView","inverseView","inverseViewProjection","projection","projectionMatrix","viewProjection","multiply","inverse","inverseTransformation","near","far","j","corner","offCenterFrustum","right","left","top","bottom","w","multiplyByVector","multiplyByScalar","subtract","fac","dot","add","createGeometry","frustumGeometry","numberOfPlanes","Float64Array","subarray","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","Float32Array","negativeX","negativeY","negativeZ","FLOAT","indices","Uint16Array","indexOffset","index","primitiveType","TRIANGLES","boundingSphere","fromVertices"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/FrustumGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometry objects. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    2 +\n    frustumPackedLength +\n    Cartesian3.packedLength +\n    Quaternion.packedLength +\n    VertexFormat.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective,\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic,\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion,\n  );\n  startingIndex += Quaternion.packedLength;\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\nfunction getAttributes(\n  offset,\n  normals,\n  tangents,\n  bitangents,\n  st,\n  normal,\n  tangent,\n  bitangent,\n) {\n  const stOffset = (offset / 3) * 2;\n\n  for (let i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n    offset += 3;\n  }\n\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\n\nconst scratchRotationMatrix = new Matrix3();\nconst scratchViewMatrix = new Matrix4();\nconst scratchInverseMatrix = new Matrix4();\n\nconst scratchXDirection = new Cartesian3();\nconst scratchYDirection = new Cartesian3();\nconst scratchZDirection = new Cartesian3();\nconst scratchNegativeX = new Cartesian3();\nconst scratchNegativeY = new Cartesian3();\nconst scratchNegativeZ = new Cartesian3();\n\nconst frustumSplits = new Array(3);\n\nconst frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nconst scratchFrustumCorners = new Array(4);\nfor (let i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nFrustumGeometry._computeNearFarPlanes = function (\n  origin,\n  orientation,\n  frustumType,\n  frustum,\n  positions,\n  xDirection,\n  yDirection,\n  zDirection,\n) {\n  const rotationMatrix = Matrix3.fromQuaternion(\n    orientation,\n    scratchRotationMatrix,\n  );\n  let x = defaultValue(xDirection, scratchXDirection);\n  let y = defaultValue(yDirection, scratchYDirection);\n  let z = defaultValue(zDirection, scratchZDirection);\n\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n\n  Cartesian3.negate(x, x);\n\n  const view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n\n  let inverseView;\n  let inverseViewProjection;\n  const projection = frustum.projectionMatrix;\n  if (frustumType === PERSPECTIVE) {\n    const viewProjection = Matrix4.multiply(\n      projection,\n      view,\n      scratchInverseMatrix,\n    );\n    inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchInverseMatrix,\n    );\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n\n  for (let i = 0; i < 2; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      let corner = Cartesian4.clone(\n        frustumCornersNDC[j],\n        scratchFrustumCorners[j],\n      );\n\n      if (!defined(inverseViewProjection)) {\n        const offCenterFrustum = frustum.offCenterFrustum;\n        if (defined(offCenterFrustum)) {\n          frustum = offCenterFrustum;\n        }\n\n        const near = frustumSplits[i];\n        const far = frustumSplits[i + 1];\n\n        corner.x =\n          (corner.x * (frustum.right - frustum.left) +\n            frustum.left +\n            frustum.right) *\n          0.5;\n        corner.y =\n          (corner.y * (frustum.top - frustum.bottom) +\n            frustum.bottom +\n            frustum.top) *\n          0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(\n          inverseViewProjection,\n          corner,\n          corner,\n        );\n\n        // Reverse perspective divide\n        const w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n\n        const fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n  const vertexFormat = frustumGeometry._vertexFormat;\n\n  const numberOfPlanes = drawNearPlane ? 6 : 5;\n  let positions = new Float64Array(3 * 4 * 6);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions,\n  );\n\n  // -x plane\n  let offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2];\n\n  // -y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2];\n\n  // +x plane\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2];\n\n  // +y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (\n    defined(vertexFormat.normal) ||\n    defined(vertexFormat.tangent) ||\n    defined(vertexFormat.bitangent) ||\n    defined(vertexFormat.st)\n  ) {\n    const normals = defined(vertexFormat.normal)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const tangents = defined(vertexFormat.tangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const bitangents = defined(vertexFormat.bitangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const st = defined(vertexFormat.st)\n      ? new Float32Array(2 * 4 * numberOfPlanes)\n      : undefined;\n\n    const x = scratchXDirection;\n    const y = scratchYDirection;\n    const z = scratchZDirection;\n\n    const negativeX = Cartesian3.negate(x, scratchNegativeX);\n    const negativeY = Cartesian3.negate(y, scratchNegativeY);\n    const negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n\n    offset = 0;\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n      offset += 3 * 4;\n    }\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeX,\n      negativeZ,\n      y,\n    ); // -x\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeY,\n      negativeZ,\n      negativeX,\n    ); // -y\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n  }\n\n  const indices = new Uint16Array(6 * numberOfPlanes);\n  for (let i = 0; i < numberOfPlanes; ++i) {\n    const indexOffset = i * 6;\n    const index = i * 4;\n\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumGeometry;\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,qBAAqB;AAChD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,mBAAmB,MAAM,0BAA0B;AAC1D,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,YAAY,MAAM,mBAAmB;AAE5C,MAAMC,WAAW,GAAG,CAAC;AACrB,MAAMC,YAAY,GAAG,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,OAAO,EAAE;EAChC;EACAjB,KAAK,CAACkB,MAAM,CAACC,MAAM,CAAC,SAAS,EAAEF,OAAO,CAAC;EACvCjB,KAAK,CAACkB,MAAM,CAACC,MAAM,CAAC,iBAAiB,EAAEF,OAAO,CAACG,OAAO,CAAC;EACvDpB,KAAK,CAACkB,MAAM,CAACC,MAAM,CAAC,gBAAgB,EAAEF,OAAO,CAACI,MAAM,CAAC;EACrDrB,KAAK,CAACkB,MAAM,CAACC,MAAM,CAAC,qBAAqB,EAAEF,OAAO,CAACK,WAAW,CAAC;EAC/D;;EAEA,MAAMF,OAAO,GAAGH,OAAO,CAACG,OAAO;EAC/B,MAAME,WAAW,GAAGL,OAAO,CAACK,WAAW;EACvC,MAAMD,MAAM,GAAGJ,OAAO,CAACI,MAAM;EAC7B,MAAME,YAAY,GAAGrB,YAAY,CAACe,OAAO,CAACM,YAAY,EAAEV,YAAY,CAACW,OAAO,CAAC;;EAE7E;EACA;EACA;EACA,MAAMC,aAAa,GAAGvB,YAAY,CAACe,OAAO,CAACS,cAAc,EAAE,IAAI,CAAC;EAEhE,IAAIC,WAAW;EACf,IAAIC,mBAAmB;EACvB,IAAIR,OAAO,YAAYV,kBAAkB,EAAE;IACzCiB,WAAW,GAAGb,WAAW;IACzBc,mBAAmB,GAAGlB,kBAAkB,CAACmB,YAAY;EACvD,CAAC,MAAM,IAAIT,OAAO,YAAYX,mBAAmB,EAAE;IACjDkB,WAAW,GAAGZ,YAAY;IAC1Ba,mBAAmB,GAAGnB,mBAAmB,CAACoB,YAAY;EACxD;EAEA,IAAI,CAACC,YAAY,GAAGH,WAAW;EAC/B,IAAI,CAACI,QAAQ,GAAGX,OAAO,CAACY,KAAK,CAAC,CAAC;EAC/B,IAAI,CAACC,OAAO,GAAGnC,UAAU,CAACkC,KAAK,CAACX,MAAM,CAAC;EACvC,IAAI,CAACa,YAAY,GAAGtB,UAAU,CAACoB,KAAK,CAACV,WAAW,CAAC;EACjD,IAAI,CAACI,cAAc,GAAGD,aAAa;EACnC,IAAI,CAACU,aAAa,GAAGZ,YAAY;EACjC,IAAI,CAACa,WAAW,GAAG,uBAAuB;;EAE1C;AACF;AACA;AACA;EACE,IAAI,CAACP,YAAY,GACf,CAAC,GACDD,mBAAmB,GACnB9B,UAAU,CAAC+B,YAAY,GACvBjB,UAAU,CAACiB,YAAY,GACvBhB,YAAY,CAACgB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,eAAe,CAACqB,IAAI,GAAG,UAAUC,KAAK,EAAEC,KAAK,EAAEC,aAAa,EAAE;EAC5D;EACAxC,KAAK,CAACkB,MAAM,CAACC,MAAM,CAAC,OAAO,EAAEmB,KAAK,CAAC;EACnCtC,KAAK,CAACG,OAAO,CAAC,OAAO,EAAEoC,KAAK,CAAC;EAC7B;;EAEAC,aAAa,GAAGtC,YAAY,CAACsC,aAAa,EAAE,CAAC,CAAC;EAE9C,MAAMb,WAAW,GAAGW,KAAK,CAACR,YAAY;EACtC,MAAMV,OAAO,GAAGkB,KAAK,CAACP,QAAQ;EAE9BQ,KAAK,CAACC,aAAa,EAAE,CAAC,GAAGb,WAAW;EAEpC,IAAIA,WAAW,KAAKb,WAAW,EAAE;IAC/BJ,kBAAkB,CAAC2B,IAAI,CAACjB,OAAO,EAAEmB,KAAK,EAAEC,aAAa,CAAC;IACtDA,aAAa,IAAI9B,kBAAkB,CAACmB,YAAY;EAClD,CAAC,MAAM;IACLpB,mBAAmB,CAAC4B,IAAI,CAACjB,OAAO,EAAEmB,KAAK,EAAEC,aAAa,CAAC;IACvDA,aAAa,IAAI/B,mBAAmB,CAACoB,YAAY;EACnD;EAEA/B,UAAU,CAACuC,IAAI,CAACC,KAAK,CAACL,OAAO,EAAEM,KAAK,EAAEC,aAAa,CAAC;EACpDA,aAAa,IAAI1C,UAAU,CAAC+B,YAAY;EACxCjB,UAAU,CAACyB,IAAI,CAACC,KAAK,CAACJ,YAAY,EAAEK,KAAK,EAAEC,aAAa,CAAC;EACzDA,aAAa,IAAI5B,UAAU,CAACiB,YAAY;EACxChB,YAAY,CAACwB,IAAI,CAACC,KAAK,CAACH,aAAa,EAAEI,KAAK,EAAEC,aAAa,CAAC;EAC5DA,aAAa,IAAI3B,YAAY,CAACgB,YAAY;EAC1CU,KAAK,CAACC,aAAa,CAAC,GAAGF,KAAK,CAACZ,cAAc,GAAG,GAAG,GAAG,GAAG;EAEvD,OAAOa,KAAK;AACd,CAAC;AAED,MAAME,sBAAsB,GAAG,IAAI/B,kBAAkB,CAAC,CAAC;AACvD,MAAMgC,uBAAuB,GAAG,IAAIjC,mBAAmB,CAAC,CAAC;AACzD,MAAMkC,qBAAqB,GAAG,IAAI/B,UAAU,CAAC,CAAC;AAC9C,MAAMgC,iBAAiB,GAAG,IAAI9C,UAAU,CAAC,CAAC;AAC1C,MAAM+C,mBAAmB,GAAG,IAAIhC,YAAY,CAAC,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACAG,eAAe,CAAC8B,MAAM,GAAG,UAAUP,KAAK,EAAEC,aAAa,EAAEO,MAAM,EAAE;EAC/D;EACA/C,KAAK,CAACG,OAAO,CAAC,OAAO,EAAEoC,KAAK,CAAC;EAC7B;;EAEAC,aAAa,GAAGtC,YAAY,CAACsC,aAAa,EAAE,CAAC,CAAC;EAE9C,MAAMb,WAAW,GAAGY,KAAK,CAACC,aAAa,EAAE,CAAC;EAE1C,IAAIpB,OAAO;EACX,IAAIO,WAAW,KAAKb,WAAW,EAAE;IAC/BM,OAAO,GAAGV,kBAAkB,CAACoC,MAAM,CACjCP,KAAK,EACLC,aAAa,EACbC,sBACF,CAAC;IACDD,aAAa,IAAI9B,kBAAkB,CAACmB,YAAY;EAClD,CAAC,MAAM;IACLT,OAAO,GAAGX,mBAAmB,CAACqC,MAAM,CAClCP,KAAK,EACLC,aAAa,EACbE,uBACF,CAAC;IACDF,aAAa,IAAI/B,mBAAmB,CAACoB,YAAY;EACnD;EAEA,MAAMR,MAAM,GAAGvB,UAAU,CAACgD,MAAM,CAACP,KAAK,EAAEC,aAAa,EAAEI,iBAAiB,CAAC;EACzEJ,aAAa,IAAI1C,UAAU,CAAC+B,YAAY;EACxC,MAAMP,WAAW,GAAGV,UAAU,CAACkC,MAAM,CACnCP,KAAK,EACLC,aAAa,EACbG,qBACF,CAAC;EACDH,aAAa,IAAI5B,UAAU,CAACiB,YAAY;EACxC,MAAMN,YAAY,GAAGV,YAAY,CAACiC,MAAM,CACtCP,KAAK,EACLC,aAAa,EACbK,mBACF,CAAC;EACDL,aAAa,IAAI3B,YAAY,CAACgB,YAAY;EAC1C,MAAMJ,aAAa,GAAGc,KAAK,CAACC,aAAa,CAAC,KAAK,GAAG;EAElD,IAAI,CAACrC,OAAO,CAAC4C,MAAM,CAAC,EAAE;IACpB,OAAO,IAAI/B,eAAe,CAAC;MACzBI,OAAO,EAAEA,OAAO;MAChBC,MAAM,EAAEA,MAAM;MACdC,WAAW,EAAEA,WAAW;MACxBC,YAAY,EAAEA,YAAY;MAC1BG,cAAc,EAAED;IAClB,CAAC,CAAC;EACJ;EAEA,MAAMuB,aAAa,GACjBrB,WAAW,KAAKoB,MAAM,CAACjB,YAAY,GAAGiB,MAAM,CAAChB,QAAQ,GAAGkB,SAAS;EACnEF,MAAM,CAAChB,QAAQ,GAAGX,OAAO,CAACY,KAAK,CAACgB,aAAa,CAAC;EAE9CD,MAAM,CAACjB,YAAY,GAAGH,WAAW;EACjCoB,MAAM,CAACd,OAAO,GAAGnC,UAAU,CAACkC,KAAK,CAACX,MAAM,EAAE0B,MAAM,CAACd,OAAO,CAAC;EACzDc,MAAM,CAACb,YAAY,GAAGtB,UAAU,CAACoB,KAAK,CAACV,WAAW,EAAEyB,MAAM,CAACb,YAAY,CAAC;EACxEa,MAAM,CAACZ,aAAa,GAAGtB,YAAY,CAACmB,KAAK,CAACT,YAAY,EAAEwB,MAAM,CAACZ,aAAa,CAAC;EAC7EY,MAAM,CAACrB,cAAc,GAAGD,aAAa;EAErC,OAAOsB,MAAM;AACf,CAAC;AAED,SAASG,aAAaA,CACpBC,MAAM,EACNC,OAAO,EACPC,QAAQ,EACRC,UAAU,EACVC,EAAE,EACFC,MAAM,EACNC,OAAO,EACPC,SAAS,EACT;EACA,MAAMC,QAAQ,GAAIR,MAAM,GAAG,CAAC,GAAI,CAAC;EAEjC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;IAC1B,IAAIzD,OAAO,CAACiD,OAAO,CAAC,EAAE;MACpBA,OAAO,CAACD,MAAM,CAAC,GAAGK,MAAM,CAACK,CAAC;MAC1BT,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,MAAM,CAACM,CAAC;MAC9BV,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,MAAM,CAACO,CAAC;IAChC;IACA,IAAI5D,OAAO,CAACkD,QAAQ,CAAC,EAAE;MACrBA,QAAQ,CAACF,MAAM,CAAC,GAAGM,OAAO,CAACI,CAAC;MAC5BR,QAAQ,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGM,OAAO,CAACK,CAAC;MAChCT,QAAQ,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGM,OAAO,CAACM,CAAC;IAClC;IACA,IAAI5D,OAAO,CAACmD,UAAU,CAAC,EAAE;MACvBA,UAAU,CAACH,MAAM,CAAC,GAAGO,SAAS,CAACG,CAAC;MAChCP,UAAU,CAACH,MAAM,GAAG,CAAC,CAAC,GAAGO,SAAS,CAACI,CAAC;MACpCR,UAAU,CAACH,MAAM,GAAG,CAAC,CAAC,GAAGO,SAAS,CAACK,CAAC;IACtC;IACAZ,MAAM,IAAI,CAAC;EACb;EAEAI,EAAE,CAACI,QAAQ,CAAC,GAAG,GAAG;EAClBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;EACtBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;EACtBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;EACtBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;EACtBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;EACtBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;EACtBJ,EAAE,CAACI,QAAQ,GAAG,CAAC,CAAC,GAAG,GAAG;AACxB;AAEA,MAAMK,qBAAqB,GAAG,IAAIzD,OAAO,CAAC,CAAC;AAC3C,MAAM0D,iBAAiB,GAAG,IAAIzD,OAAO,CAAC,CAAC;AACvC,MAAM0D,oBAAoB,GAAG,IAAI1D,OAAO,CAAC,CAAC;AAE1C,MAAM2D,iBAAiB,GAAG,IAAIrE,UAAU,CAAC,CAAC;AAC1C,MAAMsE,iBAAiB,GAAG,IAAItE,UAAU,CAAC,CAAC;AAC1C,MAAMuE,iBAAiB,GAAG,IAAIvE,UAAU,CAAC,CAAC;AAC1C,MAAMwE,gBAAgB,GAAG,IAAIxE,UAAU,CAAC,CAAC;AACzC,MAAMyE,gBAAgB,GAAG,IAAIzE,UAAU,CAAC,CAAC;AACzC,MAAM0E,gBAAgB,GAAG,IAAI1E,UAAU,CAAC,CAAC;AAEzC,MAAM2E,aAAa,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC;AAElC,MAAMC,iBAAiB,GAAG,IAAID,KAAK,CAAC,CAAC,CAAC;AACtCC,iBAAiB,CAAC,CAAC,CAAC,GAAG,IAAI5E,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAC3D4E,iBAAiB,CAAC,CAAC,CAAC,GAAG,IAAI5E,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAC1D4E,iBAAiB,CAAC,CAAC,CAAC,GAAG,IAAI5E,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACzD4E,iBAAiB,CAAC,CAAC,CAAC,GAAG,IAAI5E,UAAU,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAE1D,MAAM6E,qBAAqB,GAAG,IAAIF,KAAK,CAAC,CAAC,CAAC;AAC1C,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;EAC1BgB,qBAAqB,CAAChB,CAAC,CAAC,GAAG,IAAI7D,UAAU,CAAC,CAAC;AAC7C;AAEAiB,eAAe,CAAC6D,qBAAqB,GAAG,UACtCxD,MAAM,EACNC,WAAW,EACXK,WAAW,EACXP,OAAO,EACP0D,SAAS,EACTC,UAAU,EACVC,UAAU,EACVC,UAAU,EACV;EACA,MAAMC,cAAc,GAAG3E,OAAO,CAAC4E,cAAc,CAC3C7D,WAAW,EACX0C,qBACF,CAAC;EACD,IAAIH,CAAC,GAAG3D,YAAY,CAAC6E,UAAU,EAAEZ,iBAAiB,CAAC;EACnD,IAAIL,CAAC,GAAG5D,YAAY,CAAC8E,UAAU,EAAEZ,iBAAiB,CAAC;EACnD,IAAIL,CAAC,GAAG7D,YAAY,CAAC+E,UAAU,EAAEZ,iBAAiB,CAAC;EAEnDR,CAAC,GAAGtD,OAAO,CAAC6E,SAAS,CAACF,cAAc,EAAE,CAAC,EAAErB,CAAC,CAAC;EAC3CC,CAAC,GAAGvD,OAAO,CAAC6E,SAAS,CAACF,cAAc,EAAE,CAAC,EAAEpB,CAAC,CAAC;EAC3CC,CAAC,GAAGxD,OAAO,CAAC6E,SAAS,CAACF,cAAc,EAAE,CAAC,EAAEnB,CAAC,CAAC;EAE3CjE,UAAU,CAACuF,SAAS,CAACxB,CAAC,EAAEA,CAAC,CAAC;EAC1B/D,UAAU,CAACuF,SAAS,CAACvB,CAAC,EAAEA,CAAC,CAAC;EAC1BhE,UAAU,CAACuF,SAAS,CAACtB,CAAC,EAAEA,CAAC,CAAC;EAE1BjE,UAAU,CAACwF,MAAM,CAACzB,CAAC,EAAEA,CAAC,CAAC;EAEvB,MAAM0B,IAAI,GAAG/E,OAAO,CAACgF,WAAW,CAACnE,MAAM,EAAE0C,CAAC,EAAED,CAAC,EAAED,CAAC,EAAEI,iBAAiB,CAAC;EAEpE,IAAIwB,WAAW;EACf,IAAIC,qBAAqB;EACzB,MAAMC,UAAU,GAAGvE,OAAO,CAACwE,gBAAgB;EAC3C,IAAIjE,WAAW,KAAKb,WAAW,EAAE;IAC/B,MAAM+E,cAAc,GAAGrF,OAAO,CAACsF,QAAQ,CACrCH,UAAU,EACVJ,IAAI,EACJrB,oBACF,CAAC;IACDwB,qBAAqB,GAAGlF,OAAO,CAACuF,OAAO,CACrCF,cAAc,EACd3B,oBACF,CAAC;EACH,CAAC,MAAM;IACLuB,WAAW,GAAGjF,OAAO,CAACwF,qBAAqB,CAACT,IAAI,EAAErB,oBAAoB,CAAC;EACzE;EAEA,IAAI/D,OAAO,CAACuF,qBAAqB,CAAC,EAAE;IAClCjB,aAAa,CAAC,CAAC,CAAC,GAAGrD,OAAO,CAAC6E,IAAI;IAC/BxB,aAAa,CAAC,CAAC,CAAC,GAAGrD,OAAO,CAAC8E,GAAG;EAChC,CAAC,MAAM;IACLzB,aAAa,CAAC,CAAC,CAAC,GAAG,GAAG;IACtBA,aAAa,CAAC,CAAC,CAAC,GAAGrD,OAAO,CAAC6E,IAAI;IAC/BxB,aAAa,CAAC,CAAC,CAAC,GAAGrD,OAAO,CAAC8E,GAAG;EAChC;EAEA,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;IAC1B,KAAK,IAAIuC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;MAC1B,IAAIC,MAAM,GAAGrG,UAAU,CAACiC,KAAK,CAC3B2C,iBAAiB,CAACwB,CAAC,CAAC,EACpBvB,qBAAqB,CAACuB,CAAC,CACzB,CAAC;MAED,IAAI,CAAChG,OAAO,CAACuF,qBAAqB,CAAC,EAAE;QACnC,MAAMW,gBAAgB,GAAGjF,OAAO,CAACiF,gBAAgB;QACjD,IAAIlG,OAAO,CAACkG,gBAAgB,CAAC,EAAE;UAC7BjF,OAAO,GAAGiF,gBAAgB;QAC5B;QAEA,MAAMJ,IAAI,GAAGxB,aAAa,CAACb,CAAC,CAAC;QAC7B,MAAMsC,GAAG,GAAGzB,aAAa,CAACb,CAAC,GAAG,CAAC,CAAC;QAEhCwC,MAAM,CAACvC,CAAC,GACN,CAACuC,MAAM,CAACvC,CAAC,IAAIzC,OAAO,CAACkF,KAAK,GAAGlF,OAAO,CAACmF,IAAI,CAAC,GACxCnF,OAAO,CAACmF,IAAI,GACZnF,OAAO,CAACkF,KAAK,IACf,GAAG;QACLF,MAAM,CAACtC,CAAC,GACN,CAACsC,MAAM,CAACtC,CAAC,IAAI1C,OAAO,CAACoF,GAAG,GAAGpF,OAAO,CAACqF,MAAM,CAAC,GACxCrF,OAAO,CAACqF,MAAM,GACdrF,OAAO,CAACoF,GAAG,IACb,GAAG;QACLJ,MAAM,CAACrC,CAAC,GAAG,CAACqC,MAAM,CAACrC,CAAC,IAAIkC,IAAI,GAAGC,GAAG,CAAC,GAAGD,IAAI,GAAGC,GAAG,IAAI,GAAG;QACvDE,MAAM,CAACM,CAAC,GAAG,GAAG;QAEdlG,OAAO,CAACmG,gBAAgB,CAAClB,WAAW,EAAEW,MAAM,EAAEA,MAAM,CAAC;MACvD,CAAC,MAAM;QACLA,MAAM,GAAG5F,OAAO,CAACmG,gBAAgB,CAC/BjB,qBAAqB,EACrBU,MAAM,EACNA,MACF,CAAC;;QAED;QACA,MAAMM,CAAC,GAAG,GAAG,GAAGN,MAAM,CAACM,CAAC;QACxB5G,UAAU,CAAC8G,gBAAgB,CAACR,MAAM,EAAEM,CAAC,EAAEN,MAAM,CAAC;QAE9CtG,UAAU,CAAC+G,QAAQ,CAACT,MAAM,EAAE/E,MAAM,EAAE+E,MAAM,CAAC;QAC3CtG,UAAU,CAACuF,SAAS,CAACe,MAAM,EAAEA,MAAM,CAAC;QAEpC,MAAMU,GAAG,GAAGhH,UAAU,CAACiH,GAAG,CAAChD,CAAC,EAAEqC,MAAM,CAAC;QACrCtG,UAAU,CAAC8G,gBAAgB,CAACR,MAAM,EAAE3B,aAAa,CAACb,CAAC,CAAC,GAAGkD,GAAG,EAAEV,MAAM,CAAC;QACnEtG,UAAU,CAACkH,GAAG,CAACZ,MAAM,EAAE/E,MAAM,EAAE+E,MAAM,CAAC;MACxC;MAEAtB,SAAS,CAAC,EAAE,GAAGlB,CAAC,GAAGuC,CAAC,GAAG,CAAC,CAAC,GAAGC,MAAM,CAACvC,CAAC;MACpCiB,SAAS,CAAC,EAAE,GAAGlB,CAAC,GAAGuC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGC,MAAM,CAACtC,CAAC;MACxCgB,SAAS,CAAC,EAAE,GAAGlB,CAAC,GAAGuC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGC,MAAM,CAACrC,CAAC;IAC1C;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA/C,eAAe,CAACiG,cAAc,GAAG,UAAUC,eAAe,EAAE;EAC1D,MAAMvF,WAAW,GAAGuF,eAAe,CAACpF,YAAY;EAChD,MAAMV,OAAO,GAAG8F,eAAe,CAACnF,QAAQ;EACxC,MAAMV,MAAM,GAAG6F,eAAe,CAACjF,OAAO;EACtC,MAAMX,WAAW,GAAG4F,eAAe,CAAChF,YAAY;EAChD,MAAMT,aAAa,GAAGyF,eAAe,CAACxF,cAAc;EACpD,MAAMH,YAAY,GAAG2F,eAAe,CAAC/E,aAAa;EAElD,MAAMgF,cAAc,GAAG1F,aAAa,GAAG,CAAC,GAAG,CAAC;EAC5C,IAAIqD,SAAS,GAAG,IAAIsC,YAAY,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC3CpG,eAAe,CAAC6D,qBAAqB,CACnCxD,MAAM,EACNC,WAAW,EACXK,WAAW,EACXP,OAAO,EACP0D,SACF,CAAC;;EAED;EACA,IAAI3B,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;EACtB2B,SAAS,CAAC3B,MAAM,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC7CA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;EAE7C;EACA3B,MAAM,IAAI,CAAC,GAAG,CAAC;EACf2B,SAAS,CAAC3B,MAAM,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC7CA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;EAE7C;EACA3B,MAAM,IAAI,CAAC,GAAG,CAAC;EACf2B,SAAS,CAAC3B,MAAM,CAAC,GAAG2B,SAAS,CAAC,CAAC,CAAC;EAChCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC7CA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;EAE7C;EACA3B,MAAM,IAAI,CAAC,GAAG,CAAC;EACf2B,SAAS,CAAC3B,MAAM,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACpCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC5CA,SAAS,CAAC3B,MAAM,GAAG,CAAC,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;EACxCA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC7CA,SAAS,CAAC3B,MAAM,GAAG,EAAE,CAAC,GAAG2B,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAE7C,IAAI,CAACrD,aAAa,EAAE;IAClBqD,SAAS,GAAGA,SAAS,CAACuC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;EACvC;EAEA,MAAMC,UAAU,GAAG,IAAIhH,kBAAkB,CAAC;IACxCiH,QAAQ,EAAE,IAAIlH,iBAAiB,CAAC;MAC9BmH,iBAAiB,EAAEvH,iBAAiB,CAACwH,MAAM;MAC3CC,sBAAsB,EAAE,CAAC;MACzBC,MAAM,EAAE7C;IACV,CAAC;EACH,CAAC,CAAC;EAEF,IACE3E,OAAO,CAACoB,YAAY,CAACiC,MAAM,CAAC,IAC5BrD,OAAO,CAACoB,YAAY,CAACkC,OAAO,CAAC,IAC7BtD,OAAO,CAACoB,YAAY,CAACmC,SAAS,CAAC,IAC/BvD,OAAO,CAACoB,YAAY,CAACgC,EAAE,CAAC,EACxB;IACA,MAAMH,OAAO,GAAGjD,OAAO,CAACoB,YAAY,CAACiC,MAAM,CAAC,GACxC,IAAIoE,YAAY,CAAC,CAAC,GAAG,CAAC,GAAGT,cAAc,CAAC,GACxClE,SAAS;IACb,MAAMI,QAAQ,GAAGlD,OAAO,CAACoB,YAAY,CAACkC,OAAO,CAAC,GAC1C,IAAImE,YAAY,CAAC,CAAC,GAAG,CAAC,GAAGT,cAAc,CAAC,GACxClE,SAAS;IACb,MAAMK,UAAU,GAAGnD,OAAO,CAACoB,YAAY,CAACmC,SAAS,CAAC,GAC9C,IAAIkE,YAAY,CAAC,CAAC,GAAG,CAAC,GAAGT,cAAc,CAAC,GACxClE,SAAS;IACb,MAAMM,EAAE,GAAGpD,OAAO,CAACoB,YAAY,CAACgC,EAAE,CAAC,GAC/B,IAAIqE,YAAY,CAAC,CAAC,GAAG,CAAC,GAAGT,cAAc,CAAC,GACxClE,SAAS;IAEb,MAAMY,CAAC,GAAGM,iBAAiB;IAC3B,MAAML,CAAC,GAAGM,iBAAiB;IAC3B,MAAML,CAAC,GAAGM,iBAAiB;IAE3B,MAAMwD,SAAS,GAAG/H,UAAU,CAACwF,MAAM,CAACzB,CAAC,EAAES,gBAAgB,CAAC;IACxD,MAAMwD,SAAS,GAAGhI,UAAU,CAACwF,MAAM,CAACxB,CAAC,EAAES,gBAAgB,CAAC;IACxD,MAAMwD,SAAS,GAAGjI,UAAU,CAACwF,MAAM,CAACvB,CAAC,EAAES,gBAAgB,CAAC;IAExDrB,MAAM,GAAG,CAAC;IACV,IAAI1B,aAAa,EAAE;MACjByB,aAAa,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,EAAE,EAAEwE,SAAS,EAAElE,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC;MAC3EX,MAAM,IAAI,CAAC,GAAG,CAAC;IACjB;IACAD,aAAa,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,EAAE,EAAEQ,CAAC,EAAE8D,SAAS,EAAE/D,CAAC,CAAC,CAAC,CAAC;IAC3EX,MAAM,IAAI,CAAC,GAAG,CAAC;IACfD,aAAa,CACXC,MAAM,EACNC,OAAO,EACPC,QAAQ,EACRC,UAAU,EACVC,EAAE,EACFsE,SAAS,EACTE,SAAS,EACTjE,CACF,CAAC,CAAC,CAAC;IACHX,MAAM,IAAI,CAAC,GAAG,CAAC;IACfD,aAAa,CACXC,MAAM,EACNC,OAAO,EACPC,QAAQ,EACRC,UAAU,EACVC,EAAE,EACFuE,SAAS,EACTC,SAAS,EACTF,SACF,CAAC,CAAC,CAAC;IACH1E,MAAM,IAAI,CAAC,GAAG,CAAC;IACfD,aAAa,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,EAAE,EAAEM,CAAC,EAAEE,CAAC,EAAED,CAAC,CAAC,CAAC,CAAC;IACnEX,MAAM,IAAI,CAAC,GAAG,CAAC;IACfD,aAAa,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,EAAE,EAAEO,CAAC,EAAEC,CAAC,EAAE8D,SAAS,CAAC,CAAC,CAAC;;IAE3E,IAAI1H,OAAO,CAACiD,OAAO,CAAC,EAAE;MACpBkE,UAAU,CAAC9D,MAAM,GAAG,IAAInD,iBAAiB,CAAC;QACxCmH,iBAAiB,EAAEvH,iBAAiB,CAAC+H,KAAK;QAC1CN,sBAAsB,EAAE,CAAC;QACzBC,MAAM,EAAEvE;MACV,CAAC,CAAC;IACJ;IACA,IAAIjD,OAAO,CAACkD,QAAQ,CAAC,EAAE;MACrBiE,UAAU,CAAC7D,OAAO,GAAG,IAAIpD,iBAAiB,CAAC;QACzCmH,iBAAiB,EAAEvH,iBAAiB,CAAC+H,KAAK;QAC1CN,sBAAsB,EAAE,CAAC;QACzBC,MAAM,EAAEtE;MACV,CAAC,CAAC;IACJ;IACA,IAAIlD,OAAO,CAACmD,UAAU,CAAC,EAAE;MACvBgE,UAAU,CAAC5D,SAAS,GAAG,IAAIrD,iBAAiB,CAAC;QAC3CmH,iBAAiB,EAAEvH,iBAAiB,CAAC+H,KAAK;QAC1CN,sBAAsB,EAAE,CAAC;QACzBC,MAAM,EAAErE;MACV,CAAC,CAAC;IACJ;IACA,IAAInD,OAAO,CAACoD,EAAE,CAAC,EAAE;MACf+D,UAAU,CAAC/D,EAAE,GAAG,IAAIlD,iBAAiB,CAAC;QACpCmH,iBAAiB,EAAEvH,iBAAiB,CAAC+H,KAAK;QAC1CN,sBAAsB,EAAE,CAAC;QACzBC,MAAM,EAAEpE;MACV,CAAC,CAAC;IACJ;EACF;EAEA,MAAM0E,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC,GAAGf,cAAc,CAAC;EACnD,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuD,cAAc,EAAE,EAAEvD,CAAC,EAAE;IACvC,MAAMuE,WAAW,GAAGvE,CAAC,GAAG,CAAC;IACzB,MAAMwE,KAAK,GAAGxE,CAAC,GAAG,CAAC;IAEnBqE,OAAO,CAACE,WAAW,CAAC,GAAGC,KAAK;IAC5BH,OAAO,CAACE,WAAW,GAAG,CAAC,CAAC,GAAGC,KAAK,GAAG,CAAC;IACpCH,OAAO,CAACE,WAAW,GAAG,CAAC,CAAC,GAAGC,KAAK,GAAG,CAAC;IACpCH,OAAO,CAACE,WAAW,GAAG,CAAC,CAAC,GAAGC,KAAK;IAChCH,OAAO,CAACE,WAAW,GAAG,CAAC,CAAC,GAAGC,KAAK,GAAG,CAAC;IACpCH,OAAO,CAACE,WAAW,GAAG,CAAC,CAAC,GAAGC,KAAK,GAAG,CAAC;EACtC;EAEA,OAAO,IAAIhI,QAAQ,CAAC;IAClBkH,UAAU,EAAEA,UAAU;IACtBW,OAAO,EAAEA,OAAO;IAChBI,aAAa,EAAE1H,aAAa,CAAC2H,SAAS;IACtCC,cAAc,EAAE1I,cAAc,CAAC2I,YAAY,CAAC1D,SAAS;EACvD,CAAC,CAAC;AACJ,CAAC;AACD,eAAe9D,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}