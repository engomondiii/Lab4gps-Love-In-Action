{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * The assocation between a terrain tile and an imagery tile.\n *\n * @alias TileImagery\n * @private\n *\n * @param {Imagery} imagery The imagery tile.\n * @param {Cartesian4} textureCoordinateRectangle The texture rectangle of the tile that is covered\n *        by the imagery, where X=west, Y=south, Z=east, W=north.\n * @param {boolean} useWebMercatorT true to use the Web Mercator texture coordinates for this imagery tile.\n */\nfunction TileImagery(imagery, textureCoordinateRectangle, useWebMercatorT) {\n  this.readyImagery = undefined;\n  this.loadingImagery = imagery;\n  this.textureCoordinateRectangle = textureCoordinateRectangle;\n  this.textureTranslationAndScale = undefined;\n  this.useWebMercatorT = useWebMercatorT;\n}\n\n/**\n * Frees the resources held by this instance.\n */\nTileImagery.prototype.freeResources = function () {\n  if (defined(this.readyImagery)) {\n    this.readyImagery.releaseReference();\n  }\n  if (defined(this.loadingImagery)) {\n    this.loadingImagery.releaseReference();\n  }\n};\n\n/**\n * Processes the load state machine for this instance.\n *\n * @param {Tile} tile The tile to which this instance belongs.\n * @param {FrameState} frameState The frameState.\n * @param {boolean} skipLoading True to skip loading, e.g. new requests, creating textures. This function will\n *                  still synchronously process imagery that's already mostly ready to go, e.g. use textures\n *                  already loaded on ancestor tiles.\n * @returns {boolean} True if this instance is done loading; otherwise, false.\n */\nTileImagery.prototype.processStateMachine = function (tile, frameState, skipLoading) {\n  const loadingImagery = this.loadingImagery;\n  const imageryLayer = loadingImagery.imageryLayer;\n  loadingImagery.processStateMachine(frameState, !this.useWebMercatorT, skipLoading);\n  if (loadingImagery.state === ImageryState.READY) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n    this.readyImagery = this.loadingImagery;\n    this.loadingImagery = undefined;\n    this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, this);\n    return true; // done loading\n  }\n\n  // Find some ancestor imagery we can use while this imagery is still loading.\n  let ancestor = loadingImagery.parent;\n  let closestAncestorThatNeedsLoading;\n  while (defined(ancestor) && (ancestor.state !== ImageryState.READY || !this.useWebMercatorT && !defined(ancestor.texture))) {\n    if (ancestor.state !== ImageryState.FAILED && ancestor.state !== ImageryState.INVALID) {\n      // ancestor is still loading\n      closestAncestorThatNeedsLoading = closestAncestorThatNeedsLoading || ancestor;\n    }\n    ancestor = ancestor.parent;\n  }\n  if (this.readyImagery !== ancestor) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n    this.readyImagery = ancestor;\n    if (defined(ancestor)) {\n      ancestor.addReference();\n      this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, this);\n    }\n  }\n  if (loadingImagery.state === ImageryState.FAILED || loadingImagery.state === ImageryState.INVALID) {\n    // The imagery tile is failed or invalid, so we'd like to use an ancestor instead.\n    if (defined(closestAncestorThatNeedsLoading)) {\n      // Push the ancestor's load process along a bit.  This is necessary because some ancestor imagery\n      // tiles may not be attached directly to a terrain tile.  Such tiles will never load if\n      // we don't do it here.\n      closestAncestorThatNeedsLoading.processStateMachine(frameState, !this.useWebMercatorT, skipLoading);\n      return false; // not done loading\n    }\n    // This imagery tile is failed or invalid, and we have the \"best available\" substitute.\n    return true; // done loading\n  }\n  return false; // not done loading\n};\nexport default TileImagery;","map":{"version":3,"names":["defined","ImageryState","TileImagery","imagery","textureCoordinateRectangle","useWebMercatorT","readyImagery","undefined","loadingImagery","textureTranslationAndScale","prototype","freeResources","releaseReference","processStateMachine","tile","frameState","skipLoading","imageryLayer","state","READY","_calculateTextureTranslationAndScale","ancestor","parent","closestAncestorThatNeedsLoading","texture","FAILED","INVALID","addReference"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TileImagery.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * The assocation between a terrain tile and an imagery tile.\n *\n * @alias TileImagery\n * @private\n *\n * @param {Imagery} imagery The imagery tile.\n * @param {Cartesian4} textureCoordinateRectangle The texture rectangle of the tile that is covered\n *        by the imagery, where X=west, Y=south, Z=east, W=north.\n * @param {boolean} useWebMercatorT true to use the Web Mercator texture coordinates for this imagery tile.\n */\nfunction TileImagery(imagery, textureCoordinateRectangle, useWebMercatorT) {\n  this.readyImagery = undefined;\n  this.loadingImagery = imagery;\n  this.textureCoordinateRectangle = textureCoordinateRectangle;\n  this.textureTranslationAndScale = undefined;\n  this.useWebMercatorT = useWebMercatorT;\n}\n\n/**\n * Frees the resources held by this instance.\n */\nTileImagery.prototype.freeResources = function () {\n  if (defined(this.readyImagery)) {\n    this.readyImagery.releaseReference();\n  }\n\n  if (defined(this.loadingImagery)) {\n    this.loadingImagery.releaseReference();\n  }\n};\n\n/**\n * Processes the load state machine for this instance.\n *\n * @param {Tile} tile The tile to which this instance belongs.\n * @param {FrameState} frameState The frameState.\n * @param {boolean} skipLoading True to skip loading, e.g. new requests, creating textures. This function will\n *                  still synchronously process imagery that's already mostly ready to go, e.g. use textures\n *                  already loaded on ancestor tiles.\n * @returns {boolean} True if this instance is done loading; otherwise, false.\n */\nTileImagery.prototype.processStateMachine = function (\n  tile,\n  frameState,\n  skipLoading,\n) {\n  const loadingImagery = this.loadingImagery;\n  const imageryLayer = loadingImagery.imageryLayer;\n\n  loadingImagery.processStateMachine(\n    frameState,\n    !this.useWebMercatorT,\n    skipLoading,\n  );\n\n  if (loadingImagery.state === ImageryState.READY) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n    this.readyImagery = this.loadingImagery;\n    this.loadingImagery = undefined;\n    this.textureTranslationAndScale =\n      imageryLayer._calculateTextureTranslationAndScale(tile, this);\n    return true; // done loading\n  }\n\n  // Find some ancestor imagery we can use while this imagery is still loading.\n  let ancestor = loadingImagery.parent;\n  let closestAncestorThatNeedsLoading;\n  while (\n    defined(ancestor) &&\n    (ancestor.state !== ImageryState.READY ||\n      (!this.useWebMercatorT && !defined(ancestor.texture)))\n  ) {\n    if (\n      ancestor.state !== ImageryState.FAILED &&\n      ancestor.state !== ImageryState.INVALID\n    ) {\n      // ancestor is still loading\n      closestAncestorThatNeedsLoading =\n        closestAncestorThatNeedsLoading || ancestor;\n    }\n    ancestor = ancestor.parent;\n  }\n\n  if (this.readyImagery !== ancestor) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n\n    this.readyImagery = ancestor;\n\n    if (defined(ancestor)) {\n      ancestor.addReference();\n      this.textureTranslationAndScale =\n        imageryLayer._calculateTextureTranslationAndScale(tile, this);\n    }\n  }\n\n  if (\n    loadingImagery.state === ImageryState.FAILED ||\n    loadingImagery.state === ImageryState.INVALID\n  ) {\n    // The imagery tile is failed or invalid, so we'd like to use an ancestor instead.\n    if (defined(closestAncestorThatNeedsLoading)) {\n      // Push the ancestor's load process along a bit.  This is necessary because some ancestor imagery\n      // tiles may not be attached directly to a terrain tile.  Such tiles will never load if\n      // we don't do it here.\n      closestAncestorThatNeedsLoading.processStateMachine(\n        frameState,\n        !this.useWebMercatorT,\n        skipLoading,\n      );\n      return false; // not done loading\n    }\n    // This imagery tile is failed or invalid, and we have the \"best available\" substitute.\n    return true; // done loading\n  }\n\n  return false; // not done loading\n};\nexport default TileImagery;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}