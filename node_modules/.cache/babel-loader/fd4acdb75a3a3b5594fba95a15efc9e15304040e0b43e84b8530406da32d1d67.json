{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport AttributeType from \"../Scene/AttributeType.js\";\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @namespace AttributeCompression\n *\n * @private\n */\nconst AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  const magSquared = Cartesian3.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\nconst octEncodeScratch = new Cartesian2();\nconst uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {number} x The x component of the oct-encoded unit length vector.\n * @param {number} y The y component of the oct-encoded unit length vector.\n * @param {number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);\n  }\n  //>>includeEnd('debug');\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {number} x The x component of the oct-encoded unit length vector.\n * @param {number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  const x = encoded.x;\n  const y = encoded.y;\n  const z = encoded.z;\n  const w = encoded.w;\n  //>>includeStart('debug', pragmas.debug);\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new DeveloperError(\"x, y, z, and w must be unsigned normalized integers between 0 and 255\");\n  }\n  //>>includeEnd('debug');\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded);\n  //>>includeEnd('debug');\n  return 256.0 * encoded.x + encoded.y;\n};\nconst scratchEncodeCart2 = new Cartesian2();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  //>>includeEnd('debug');\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const encoded1 = AttributeCompression.octEncodeFloat(v1);\n  const encoded2 = AttributeCompression.octEncodeFloat(v2);\n  const encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  //>>includeEnd('debug');\n\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (textureCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates);\n  //>>includeEnd('debug');\n\n  // Move x and y to the range 0-4095;\n  const x = textureCoordinates.x * 4095.0 | 0;\n  const y = textureCoordinates.y * 4095.0 | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (compressed, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\nfunction zigZagDecode(value) {\n  return value >> 1 ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (uBuffer, vBuffer, heightBuffer) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\"uBuffer.length\", \"vBuffer.length\", uBuffer.length, vBuffer.length);\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\"uBuffer.length\", \"heightBuffer.length\", uBuffer.length, heightBuffer.length);\n  }\n  //>>includeEnd('debug');\n\n  const count = uBuffer.length;\n  let u = 0;\n  let v = 0;\n  let height = 0;\n  for (let i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\n\n/**\n * Dequantizes a quantized typed array into a floating point typed array.\n *\n * @see {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data}\n *\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array} typedArray The typed array for the quantized data.\n * @param {ComponentDatatype} componentDatatype The component datatype of the quantized data.\n * @param {AttributeType} type The attribute type of the quantized data.\n * @param {number} count The number of attributes referenced in the dequantized array.\n *\n * @returns {Float32Array} The dequantized array.\n */\nAttributeCompression.dequantize = function (typedArray, componentDatatype, type, count) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n  Check.defined(\"componentDatatype\", componentDatatype);\n  Check.defined(\"type\", type);\n  Check.defined(\"count\", count);\n  //>>includeEnd('debug');\n\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n  let divisor;\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      divisor = 127.0;\n      break;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      divisor = 255.0;\n      break;\n    case ComponentDatatype.SHORT:\n      divisor = 32767.0;\n      break;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      divisor = 65535.0;\n      break;\n    case ComponentDatatype.INT:\n      divisor = 2147483647.0;\n      break;\n    case ComponentDatatype.UNSIGNED_INT:\n      divisor = 4294967295.0;\n      break;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(`Cannot dequantize component datatype: ${componentDatatype}`);\n    //>>includeEnd('debug');\n  }\n  const dequantizedTypedArray = new Float32Array(count * componentsPerAttribute);\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < componentsPerAttribute; j++) {\n      const index = i * componentsPerAttribute + j;\n      dequantizedTypedArray[index] = Math.max(typedArray[index] / divisor, -1.0);\n    }\n  }\n  return dequantizedTypedArray;\n};\n\n/**\n * Decode RGB565-encoded colors into a floating point typed array containing\n * normalized RGB values.\n *\n * @param {Uint16Array} typedArray Array of RGB565 values\n * @param {Float32Array} [result] Array to store the normalized VEC3 result\n */\nAttributeCompression.decodeRGB565 = function (typedArray, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n  const expectedLength = typedArray.length * 3;\n  if (defined(result)) {\n    Check.typeOf.number.equals(\"result.length\", \"typedArray.length * 3\", result.length, expectedLength);\n  }\n  //>>includeEnd('debug');\n\n  const count = typedArray.length;\n  if (!defined(result)) {\n    result = new Float32Array(count * 3);\n  }\n  const mask5 = (1 << 5) - 1;\n  const mask6 = (1 << 6) - 1;\n  const normalize5 = 1.0 / 31.0;\n  const normalize6 = 1.0 / 63.0;\n  for (let i = 0; i < count; i++) {\n    const value = typedArray[i];\n    const red = value >> 11;\n    const green = value >> 5 & mask6;\n    const blue = value & mask5;\n    const offset = 3 * i;\n    result[offset] = red * normalize5;\n    result[offset + 1] = green * normalize6;\n    result[offset + 2] = blue * normalize5;\n  }\n  return result;\n};\nexport default AttributeCompression;","map":{"version":3,"names":["Cartesian2","Cartesian3","ComponentDatatype","Check","defined","DeveloperError","CesiumMath","AttributeType","RIGHT_SHIFT","LEFT_SHIFT","AttributeCompression","octEncodeInRange","vector","rangeMax","result","magSquared","magnitudeSquared","Math","abs","EPSILON6","x","y","z","signNotZero","toSNorm","octEncode","octEncodeScratch","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","typeOf","object","xOct16","yOct16","octPackFloat","scratchEncodeCart2","octEncodeFloat","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDecode","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i","dequantize","typedArray","componentDatatype","type","componentsPerAttribute","getNumberOfComponents","divisor","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","dequantizedTypedArray","Float32Array","j","index","max","decodeRGB565","expectedLength","mask5","mask6","normalize5","normalize6","red","green","blue","offset"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/AttributeCompression.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport AttributeType from \"../Scene/AttributeType.js\";\n\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @namespace AttributeCompression\n *\n * @private\n */\nconst AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  const magSquared = Cartesian3.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  result.x =\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y =\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nconst octEncodeScratch = new Cartesian2();\nconst uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {number} x The x component of the oct-encoded unit length vector.\n * @param {number} y The y component of the oct-encoded unit length vector.\n * @param {number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(\n      `x and y must be unsigned normalized integers between 0 and ${rangeMax}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {number} x The x component of the oct-encoded unit length vector.\n * @param {number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  const x = encoded.x;\n  const y = encoded.y;\n  const z = encoded.z;\n  const w = encoded.w;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    x < 0 ||\n    x > 255 ||\n    y < 0 ||\n    y > 255 ||\n    z < 0 ||\n    z > 255 ||\n    w < 0 ||\n    w > 255\n  ) {\n    throw new DeveloperError(\n      \"x, y, z, and w must be unsigned normalized integers between 0 and 255\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded);\n  //>>includeEnd('debug');\n  return 256.0 * encoded.x + encoded.y;\n};\n\nconst scratchEncodeCart2 = new Cartesian2();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  //>>includeEnd('debug');\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const encoded1 = AttributeCompression.octEncodeFloat(v1);\n  const encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n  const encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  //>>includeEnd('debug');\n\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (\n  textureCoordinates,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates);\n  //>>includeEnd('debug');\n\n  // Move x and y to the range 0-4095;\n  const x = (textureCoordinates.x * 4095.0) | 0;\n  const y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (\n  compressed,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (\n  uBuffer,\n  vBuffer,\n  heightBuffer,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\n    \"uBuffer.length\",\n    \"vBuffer.length\",\n    uBuffer.length,\n    vBuffer.length,\n  );\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\n      \"uBuffer.length\",\n      \"heightBuffer.length\",\n      uBuffer.length,\n      heightBuffer.length,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const count = uBuffer.length;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\n\n/**\n * Dequantizes a quantized typed array into a floating point typed array.\n *\n * @see {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data}\n *\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array} typedArray The typed array for the quantized data.\n * @param {ComponentDatatype} componentDatatype The component datatype of the quantized data.\n * @param {AttributeType} type The attribute type of the quantized data.\n * @param {number} count The number of attributes referenced in the dequantized array.\n *\n * @returns {Float32Array} The dequantized array.\n */\nAttributeCompression.dequantize = function (\n  typedArray,\n  componentDatatype,\n  type,\n  count,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n  Check.defined(\"componentDatatype\", componentDatatype);\n  Check.defined(\"type\", type);\n  Check.defined(\"count\", count);\n  //>>includeEnd('debug');\n\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n\n  let divisor;\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      divisor = 127.0;\n      break;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      divisor = 255.0;\n      break;\n    case ComponentDatatype.SHORT:\n      divisor = 32767.0;\n      break;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      divisor = 65535.0;\n      break;\n    case ComponentDatatype.INT:\n      divisor = 2147483647.0;\n      break;\n    case ComponentDatatype.UNSIGNED_INT:\n      divisor = 4294967295.0;\n      break;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        `Cannot dequantize component datatype: ${componentDatatype}`,\n      );\n    //>>includeEnd('debug');\n  }\n\n  const dequantizedTypedArray = new Float32Array(\n    count * componentsPerAttribute,\n  );\n\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < componentsPerAttribute; j++) {\n      const index = i * componentsPerAttribute + j;\n      dequantizedTypedArray[index] = Math.max(\n        typedArray[index] / divisor,\n        -1.0,\n      );\n    }\n  }\n\n  return dequantizedTypedArray;\n};\n\n/**\n * Decode RGB565-encoded colors into a floating point typed array containing\n * normalized RGB values.\n *\n * @param {Uint16Array} typedArray Array of RGB565 values\n * @param {Float32Array} [result] Array to store the normalized VEC3 result\n */\nAttributeCompression.decodeRGB565 = function (typedArray, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n\n  const expectedLength = typedArray.length * 3;\n  if (defined(result)) {\n    Check.typeOf.number.equals(\n      \"result.length\",\n      \"typedArray.length * 3\",\n      result.length,\n      expectedLength,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const count = typedArray.length;\n  if (!defined(result)) {\n    result = new Float32Array(count * 3);\n  }\n\n  const mask5 = (1 << 5) - 1;\n  const mask6 = (1 << 6) - 1;\n  const normalize5 = 1.0 / 31.0;\n  const normalize6 = 1.0 / 63.0;\n  for (let i = 0; i < count; i++) {\n    const value = typedArray[i];\n    const red = value >> 11;\n    const green = (value >> 5) & mask6;\n    const blue = value & mask5;\n\n    const offset = 3 * i;\n    result[offset] = red * normalize5;\n    result[offset + 1] = green * normalize6;\n    result[offset + 2] = blue * normalize5;\n  }\n\n  return result;\n};\n\nexport default AttributeCompression;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}