{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * A box {@link VoxelShape}.\n *\n * @alias VoxelBoxShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelEllipsoidShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelBoxShape() {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  this.orientedBoundingBox = new OrientedBoundingBox();\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  this.boundingSphere = new BoundingSphere();\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.boundTransform = new Matrix4();\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.shapeTransform = new Matrix4();\n\n  /**\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = Cartesian3.clone(VoxelBoxShape.DefaultMinBounds, new Cartesian3());\n\n  /**\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = Cartesian3.clone(VoxelBoxShape.DefaultMaxBounds, new Cartesian3());\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderUniforms = {\n    renderMinBounds: new Cartesian3(),\n    renderMaxBounds: new Cartesian3(),\n    boxUvToShapeUvScale: new Cartesian3(),\n    boxUvToShapeUvTranslate: new Cartesian3()\n  };\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderDefines = {\n    BOX_INTERSECTION_INDEX: undefined,\n    BOX_HAS_SHAPE_BOUNDS: undefined\n  };\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @type {number}\n   * @readonly\n   */\n  this.shaderMaximumIntersectionsLength = 0; // not known until update\n}\nconst scratchCenter = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst transformLocalToUv = Matrix4.fromRotationTranslation(Matrix3.fromUniformScale(0.5, new Matrix3()), new Cartesian3(0.5, 0.5, 0.5), new Matrix4());\n\n/**\n * Update the shape's state.\n *\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelBoxShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelBoxShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelBoxShape.prototype.update = function (modelMatrix, minBounds, maxBounds, clipMinBounds, clipMaxBounds) {\n  clipMinBounds = defaultValue(clipMinBounds, VoxelBoxShape.DefaultMinBounds);\n  clipMaxBounds = defaultValue(clipMaxBounds, VoxelBoxShape.DefaultMaxBounds);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const defaultMinBounds = VoxelBoxShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelBoxShape.DefaultMaxBounds;\n  minBounds = this._minBounds = Cartesian3.clamp(minBounds, defaultMinBounds, defaultMaxBounds, this._minBounds);\n  maxBounds = this._maxBounds = Cartesian3.clamp(maxBounds, defaultMinBounds, defaultMaxBounds, this._maxBounds);\n  clipMinBounds = Cartesian3.clamp(clipMinBounds, defaultMinBounds, defaultMaxBounds, scratchClipMinBounds);\n  clipMaxBounds = Cartesian3.clamp(clipMaxBounds, defaultMinBounds, defaultMaxBounds, scratchClipMaxBounds);\n  const renderMinBounds = Cartesian3.clamp(minBounds, clipMinBounds, clipMaxBounds, scratchRenderMinBounds);\n  const renderMaxBounds = Cartesian3.clamp(maxBounds, clipMinBounds, clipMaxBounds, scratchRenderMaxBounds);\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n\n  // Box is not visible if:\n  // - any of the min render bounds exceed the max render bounds\n  // - two or more of the min bounds equal the max bounds (line / point)\n  // - any of the min clip bounds exceed the max clip bounds\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  if (renderMinBounds.x > renderMaxBounds.x || renderMinBounds.y > renderMaxBounds.y || renderMinBounds.z > renderMaxBounds.z || (renderMinBounds.x === renderMaxBounds.x) + (renderMinBounds.y === renderMaxBounds.y) + (renderMinBounds.z === renderMaxBounds.z) >= 2 || clipMinBounds.x > clipMaxBounds.x || clipMinBounds.y > clipMaxBounds.y || clipMinBounds.z > clipMaxBounds.z || scale.x === 0.0 || scale.y === 0.0 || scale.z === 0.0) {\n    return false;\n  }\n  this.shapeTransform = Matrix4.clone(modelMatrix, this.shapeTransform);\n  this.orientedBoundingBox = getBoxChunkObb(renderMinBounds, renderMaxBounds, this.shapeTransform, this.orientedBoundingBox);\n\n  // All of the box bounds go from -1 to +1, so the model matrix scale can be\n  // used as the oriented bounding box half axes.\n  this.boundTransform = Matrix4.fromRotationTranslation(this.orientedBoundingBox.halfAxes, this.orientedBoundingBox.center, this.boundTransform);\n  this.boundingSphere = BoundingSphere.fromOrientedBoundingBox(this.orientedBoundingBox, this.boundingSphere);\n  const {\n    shaderUniforms,\n    shaderDefines\n  } = this;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n  const hasShapeBounds = !Cartesian3.equals(minBounds, defaultMinBounds) || !Cartesian3.equals(maxBounds, defaultMaxBounds);\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n  shaderDefines[\"BOX_INTERSECTION_INDEX\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderUniforms.renderMinBounds = Matrix4.multiplyByPoint(transformLocalToUv, renderMinBounds, shaderUniforms.renderMinBounds);\n  shaderUniforms.renderMaxBounds = Matrix4.multiplyByPoint(transformLocalToUv, renderMaxBounds, shaderUniforms.renderMaxBounds);\n  if (hasShapeBounds) {\n    shaderDefines[\"BOX_HAS_SHAPE_BOUNDS\"] = true;\n    const min = minBounds;\n    const max = maxBounds;\n\n    // Go from UV space to bounded UV space:\n    // delerp(posUv, minBoundsUv, maxBoundsUv)\n    // (posUv - minBoundsUv) / (maxBoundsUv - minBoundsUv)\n    // posUv / (maxBoundsUv - minBoundsUv) - minBoundsUv / (maxBoundsUv - minBoundsUv)\n    // scale = 1.0 / (maxBoundsUv - minBoundsUv)\n    // scale = 1.0 / ((maxBounds * 0.5 + 0.5) - (minBounds * 0.5 + 0.5))\n    // scale = 2.0 / (maxBounds - minBounds)\n    // offset = -minBoundsUv / ((maxBounds * 0.5 + 0.5) - (minBounds * 0.5 + 0.5))\n    // offset = -2.0 * (minBounds * 0.5 + 0.5) / (maxBounds - minBounds)\n    // offset = -scale * (minBounds * 0.5 + 0.5)\n    shaderUniforms.boxUvToShapeUvScale = Cartesian3.fromElements(2.0 / (min.x === max.x ? 1.0 : max.x - min.x), 2.0 / (min.y === max.y ? 1.0 : max.y - min.y), 2.0 / (min.z === max.z ? 1.0 : max.z - min.z), shaderUniforms.boxUvToShapeUvScale);\n    shaderUniforms.boxUvToShapeUvTranslate = Cartesian3.fromElements(-shaderUniforms.boxUvToShapeUvScale.x * (min.x * 0.5 + 0.5), -shaderUniforms.boxUvToShapeUvScale.y * (min.y * 0.5 + 0.5), -shaderUniforms.boxUvToShapeUvScale.z * (min.z * 0.5 + 0.5), shaderUniforms.boxUvToShapeUvTranslate);\n  }\n  this.shaderMaximumIntersectionsLength = intersectionCount;\n  return true;\n};\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForTile = function (tileLevel, tileX, tileY, tileZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sizeAtLevel = 1.0 / Math.pow(2, tileLevel);\n  const tileMinBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * tileX), CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * tileY), CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * tileZ), scratchTileMinBounds);\n  const tileMaxBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * (tileX + 1)), CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * (tileY + 1)), CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * (tileZ + 1)), scratchTileMaxBounds);\n  return getBoxChunkObb(tileMinBounds, tileMaxBounds, this.shapeTransform, result);\n};\nconst sampleSizeScratch = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForSample = function (spatialNode, tileDimensions, tileUv, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(Cartesian3.ONE, tileDimensions, sampleSizeScratch);\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(sampleSize, tileSizeAtLevel, sampleSizeScratch);\n  const minLerp = Cartesian3.multiplyByScalar(Cartesian3.fromElements(spatialNode.x + tileUv.x, spatialNode.y + tileUv.y, spatialNode.z + tileUv.z, scratchTileMinBounds), tileSizeAtLevel, scratchTileMinBounds);\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchTileMaxBounds);\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sampleMinBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, minLerp.x), CesiumMath.lerp(minBounds.y, maxBounds.y, minLerp.y), CesiumMath.lerp(minBounds.z, maxBounds.z, minLerp.z), scratchTileMinBounds);\n  const sampleMaxBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, maxLerp.x), CesiumMath.lerp(minBounds.y, maxBounds.y, maxLerp.y), CesiumMath.lerp(minBounds.z, maxBounds.z, maxLerp.z), scratchTileMaxBounds);\n  return getBoxChunkObb(sampleMinBounds, sampleMaxBounds, this.shapeTransform, result);\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum X, Y, Z.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMinBounds = Object.freeze(new Cartesian3(-1.0, -1.0, -1.0));\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum X, Y, Z.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMaxBounds = Object.freeze(new Cartesian3(+1.0, +1.0, +1.0));\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Cartesian3} minimumBounds The minimum bounds, in the local coordinates of the shape.\n * @param {Cartesian3} maximumBounds The maximum bounds, in the local coordinates of the shape.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getBoxChunkObb(minimumBounds, maximumBounds, matrix, result) {\n  const defaultMinBounds = VoxelBoxShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelBoxShape.DefaultMaxBounds;\n  const isDefaultBounds = Cartesian3.equals(minimumBounds, defaultMinBounds) && Cartesian3.equals(maximumBounds, defaultMaxBounds);\n  if (isDefaultBounds) {\n    result.center = Matrix4.getTranslation(matrix, result.center);\n    result.halfAxes = Matrix4.getMatrix3(matrix, result.halfAxes);\n  } else {\n    let scale = Matrix4.getScale(matrix, scratchScale);\n    const localCenter = Cartesian3.midpoint(minimumBounds, maximumBounds, scratchCenter);\n    result.center = Matrix4.multiplyByPoint(matrix, localCenter, result.center);\n    scale = Cartesian3.fromElements(scale.x * 0.5 * (maximumBounds.x - minimumBounds.x), scale.y * 0.5 * (maximumBounds.y - minimumBounds.y), scale.z * 0.5 * (maximumBounds.z - minimumBounds.z), scratchScale);\n    const rotation = Matrix4.getRotation(matrix, scratchRotation);\n    result.halfAxes = Matrix3.setScale(rotation, scale, result.halfAxes);\n  }\n  return result;\n}\nexport default VoxelBoxShape;","map":{"version":3,"names":["BoundingSphere","Cartesian3","CesiumMath","Check","Matrix3","Matrix4","OrientedBoundingBox","defaultValue","VoxelBoxShape","orientedBoundingBox","boundingSphere","boundTransform","shapeTransform","_minBounds","clone","DefaultMinBounds","_maxBounds","DefaultMaxBounds","shaderUniforms","renderMinBounds","renderMaxBounds","boxUvToShapeUvScale","boxUvToShapeUvTranslate","shaderDefines","BOX_INTERSECTION_INDEX","undefined","BOX_HAS_SHAPE_BOUNDS","shaderMaximumIntersectionsLength","scratchCenter","scratchScale","scratchRotation","scratchClipMinBounds","scratchClipMaxBounds","scratchRenderMinBounds","scratchRenderMaxBounds","transformLocalToUv","fromRotationTranslation","fromUniformScale","prototype","update","modelMatrix","minBounds","maxBounds","clipMinBounds","clipMaxBounds","typeOf","object","defaultMinBounds","defaultMaxBounds","clamp","scale","getScale","x","y","z","getBoxChunkObb","halfAxes","center","fromOrientedBoundingBox","key","hasOwnProperty","hasShapeBounds","equals","intersectionCount","multiplyByPoint","min","max","fromElements","scratchTileMinBounds","scratchTileMaxBounds","computeOrientedBoundingBoxForTile","tileLevel","tileX","tileY","tileZ","result","number","sizeAtLevel","Math","pow","tileMinBounds","lerp","tileMaxBounds","sampleSizeScratch","computeOrientedBoundingBoxForSample","spatialNode","tileDimensions","tileUv","tileSizeAtLevel","level","sampleSize","divideComponents","ONE","sampleSizeAtLevel","multiplyByScalar","minLerp","maxLerp","add","sampleMinBounds","sampleMaxBounds","Object","freeze","minimumBounds","maximumBounds","matrix","isDefaultBounds","getTranslation","getMatrix3","localCenter","midpoint","rotation","getRotation","setScale"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelBoxShape.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * A box {@link VoxelShape}.\n *\n * @alias VoxelBoxShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelEllipsoidShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelBoxShape() {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  this.orientedBoundingBox = new OrientedBoundingBox();\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  this.boundingSphere = new BoundingSphere();\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.boundTransform = new Matrix4();\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.shapeTransform = new Matrix4();\n\n  /**\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = Cartesian3.clone(\n    VoxelBoxShape.DefaultMinBounds,\n    new Cartesian3(),\n  );\n\n  /**\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = Cartesian3.clone(\n    VoxelBoxShape.DefaultMaxBounds,\n    new Cartesian3(),\n  );\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderUniforms = {\n    renderMinBounds: new Cartesian3(),\n    renderMaxBounds: new Cartesian3(),\n    boxUvToShapeUvScale: new Cartesian3(),\n    boxUvToShapeUvTranslate: new Cartesian3(),\n  };\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderDefines = {\n    BOX_INTERSECTION_INDEX: undefined,\n    BOX_HAS_SHAPE_BOUNDS: undefined,\n  };\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @type {number}\n   * @readonly\n   */\n  this.shaderMaximumIntersectionsLength = 0; // not known until update\n}\n\nconst scratchCenter = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\n\nconst transformLocalToUv = Matrix4.fromRotationTranslation(\n  Matrix3.fromUniformScale(0.5, new Matrix3()),\n  new Cartesian3(0.5, 0.5, 0.5),\n  new Matrix4(),\n);\n\n/**\n * Update the shape's state.\n *\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelBoxShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelBoxShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelBoxShape.prototype.update = function (\n  modelMatrix,\n  minBounds,\n  maxBounds,\n  clipMinBounds,\n  clipMaxBounds,\n) {\n  clipMinBounds = defaultValue(clipMinBounds, VoxelBoxShape.DefaultMinBounds);\n  clipMaxBounds = defaultValue(clipMaxBounds, VoxelBoxShape.DefaultMaxBounds);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const defaultMinBounds = VoxelBoxShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelBoxShape.DefaultMaxBounds;\n\n  minBounds = this._minBounds = Cartesian3.clamp(\n    minBounds,\n    defaultMinBounds,\n    defaultMaxBounds,\n    this._minBounds,\n  );\n\n  maxBounds = this._maxBounds = Cartesian3.clamp(\n    maxBounds,\n    defaultMinBounds,\n    defaultMaxBounds,\n    this._maxBounds,\n  );\n\n  clipMinBounds = Cartesian3.clamp(\n    clipMinBounds,\n    defaultMinBounds,\n    defaultMaxBounds,\n    scratchClipMinBounds,\n  );\n\n  clipMaxBounds = Cartesian3.clamp(\n    clipMaxBounds,\n    defaultMinBounds,\n    defaultMaxBounds,\n    scratchClipMaxBounds,\n  );\n\n  const renderMinBounds = Cartesian3.clamp(\n    minBounds,\n    clipMinBounds,\n    clipMaxBounds,\n    scratchRenderMinBounds,\n  );\n\n  const renderMaxBounds = Cartesian3.clamp(\n    maxBounds,\n    clipMinBounds,\n    clipMaxBounds,\n    scratchRenderMaxBounds,\n  );\n\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n\n  // Box is not visible if:\n  // - any of the min render bounds exceed the max render bounds\n  // - two or more of the min bounds equal the max bounds (line / point)\n  // - any of the min clip bounds exceed the max clip bounds\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  if (\n    renderMinBounds.x > renderMaxBounds.x ||\n    renderMinBounds.y > renderMaxBounds.y ||\n    renderMinBounds.z > renderMaxBounds.z ||\n    (renderMinBounds.x === renderMaxBounds.x) +\n      (renderMinBounds.y === renderMaxBounds.y) +\n      (renderMinBounds.z === renderMaxBounds.z) >=\n      2 ||\n    clipMinBounds.x > clipMaxBounds.x ||\n    clipMinBounds.y > clipMaxBounds.y ||\n    clipMinBounds.z > clipMaxBounds.z ||\n    scale.x === 0.0 ||\n    scale.y === 0.0 ||\n    scale.z === 0.0\n  ) {\n    return false;\n  }\n\n  this.shapeTransform = Matrix4.clone(modelMatrix, this.shapeTransform);\n\n  this.orientedBoundingBox = getBoxChunkObb(\n    renderMinBounds,\n    renderMaxBounds,\n    this.shapeTransform,\n    this.orientedBoundingBox,\n  );\n\n  // All of the box bounds go from -1 to +1, so the model matrix scale can be\n  // used as the oriented bounding box half axes.\n  this.boundTransform = Matrix4.fromRotationTranslation(\n    this.orientedBoundingBox.halfAxes,\n    this.orientedBoundingBox.center,\n    this.boundTransform,\n  );\n\n  this.boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this.orientedBoundingBox,\n    this.boundingSphere,\n  );\n\n  const { shaderUniforms, shaderDefines } = this;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  const hasShapeBounds =\n    !Cartesian3.equals(minBounds, defaultMinBounds) ||\n    !Cartesian3.equals(maxBounds, defaultMaxBounds);\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  shaderDefines[\"BOX_INTERSECTION_INDEX\"] = intersectionCount;\n  intersectionCount += 1;\n\n  shaderUniforms.renderMinBounds = Matrix4.multiplyByPoint(\n    transformLocalToUv,\n    renderMinBounds,\n    shaderUniforms.renderMinBounds,\n  );\n  shaderUniforms.renderMaxBounds = Matrix4.multiplyByPoint(\n    transformLocalToUv,\n    renderMaxBounds,\n    shaderUniforms.renderMaxBounds,\n  );\n\n  if (hasShapeBounds) {\n    shaderDefines[\"BOX_HAS_SHAPE_BOUNDS\"] = true;\n\n    const min = minBounds;\n    const max = maxBounds;\n\n    // Go from UV space to bounded UV space:\n    // delerp(posUv, minBoundsUv, maxBoundsUv)\n    // (posUv - minBoundsUv) / (maxBoundsUv - minBoundsUv)\n    // posUv / (maxBoundsUv - minBoundsUv) - minBoundsUv / (maxBoundsUv - minBoundsUv)\n    // scale = 1.0 / (maxBoundsUv - minBoundsUv)\n    // scale = 1.0 / ((maxBounds * 0.5 + 0.5) - (minBounds * 0.5 + 0.5))\n    // scale = 2.0 / (maxBounds - minBounds)\n    // offset = -minBoundsUv / ((maxBounds * 0.5 + 0.5) - (minBounds * 0.5 + 0.5))\n    // offset = -2.0 * (minBounds * 0.5 + 0.5) / (maxBounds - minBounds)\n    // offset = -scale * (minBounds * 0.5 + 0.5)\n    shaderUniforms.boxUvToShapeUvScale = Cartesian3.fromElements(\n      2.0 / (min.x === max.x ? 1.0 : max.x - min.x),\n      2.0 / (min.y === max.y ? 1.0 : max.y - min.y),\n      2.0 / (min.z === max.z ? 1.0 : max.z - min.z),\n      shaderUniforms.boxUvToShapeUvScale,\n    );\n\n    shaderUniforms.boxUvToShapeUvTranslate = Cartesian3.fromElements(\n      -shaderUniforms.boxUvToShapeUvScale.x * (min.x * 0.5 + 0.5),\n      -shaderUniforms.boxUvToShapeUvScale.y * (min.y * 0.5 + 0.5),\n      -shaderUniforms.boxUvToShapeUvScale.z * (min.z * 0.5 + 0.5),\n      shaderUniforms.boxUvToShapeUvTranslate,\n    );\n  }\n\n  this.shaderMaximumIntersectionsLength = intersectionCount;\n\n  return true;\n};\n\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForTile = function (\n  tileLevel,\n  tileX,\n  tileY,\n  tileZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sizeAtLevel = 1.0 / Math.pow(2, tileLevel);\n\n  const tileMinBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * tileX),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * tileY),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * tileZ),\n    scratchTileMinBounds,\n  );\n\n  const tileMaxBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * (tileX + 1)),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * (tileY + 1)),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * (tileZ + 1)),\n    scratchTileMaxBounds,\n  );\n\n  return getBoxChunkObb(\n    tileMinBounds,\n    tileMaxBounds,\n    this.shapeTransform,\n    result,\n  );\n};\n\nconst sampleSizeScratch = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForSample = function (\n  spatialNode,\n  tileDimensions,\n  tileUv,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    tileDimensions,\n    sampleSizeScratch,\n  );\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(\n    sampleSize,\n    tileSizeAtLevel,\n    sampleSizeScratch,\n  );\n\n  const minLerp = Cartesian3.multiplyByScalar(\n    Cartesian3.fromElements(\n      spatialNode.x + tileUv.x,\n      spatialNode.y + tileUv.y,\n      spatialNode.z + tileUv.z,\n      scratchTileMinBounds,\n    ),\n    tileSizeAtLevel,\n    scratchTileMinBounds,\n  );\n  const maxLerp = Cartesian3.add(\n    minLerp,\n    sampleSizeAtLevel,\n    scratchTileMaxBounds,\n  );\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sampleMinBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, minLerp.x),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, minLerp.y),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, minLerp.z),\n    scratchTileMinBounds,\n  );\n  const sampleMaxBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, maxLerp.x),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, maxLerp.y),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, maxLerp.z),\n    scratchTileMaxBounds,\n  );\n\n  return getBoxChunkObb(\n    sampleMinBounds,\n    sampleMaxBounds,\n    this.shapeTransform,\n    result,\n  );\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum X, Y, Z.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMinBounds = Object.freeze(\n  new Cartesian3(-1.0, -1.0, -1.0),\n);\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum X, Y, Z.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMaxBounds = Object.freeze(\n  new Cartesian3(+1.0, +1.0, +1.0),\n);\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Cartesian3} minimumBounds The minimum bounds, in the local coordinates of the shape.\n * @param {Cartesian3} maximumBounds The maximum bounds, in the local coordinates of the shape.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getBoxChunkObb(minimumBounds, maximumBounds, matrix, result) {\n  const defaultMinBounds = VoxelBoxShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelBoxShape.DefaultMaxBounds;\n\n  const isDefaultBounds =\n    Cartesian3.equals(minimumBounds, defaultMinBounds) &&\n    Cartesian3.equals(maximumBounds, defaultMaxBounds);\n\n  if (isDefaultBounds) {\n    result.center = Matrix4.getTranslation(matrix, result.center);\n    result.halfAxes = Matrix4.getMatrix3(matrix, result.halfAxes);\n  } else {\n    let scale = Matrix4.getScale(matrix, scratchScale);\n    const localCenter = Cartesian3.midpoint(\n      minimumBounds,\n      maximumBounds,\n      scratchCenter,\n    );\n    result.center = Matrix4.multiplyByPoint(matrix, localCenter, result.center);\n    scale = Cartesian3.fromElements(\n      scale.x * 0.5 * (maximumBounds.x - minimumBounds.x),\n      scale.y * 0.5 * (maximumBounds.y - minimumBounds.y),\n      scale.z * 0.5 * (maximumBounds.z - minimumBounds.z),\n      scratchScale,\n    );\n    const rotation = Matrix4.getRotation(matrix, scratchRotation);\n    result.halfAxes = Matrix3.setScale(rotation, scale, result.halfAxes);\n  }\n\n  return result;\n}\n\nexport default VoxelBoxShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}