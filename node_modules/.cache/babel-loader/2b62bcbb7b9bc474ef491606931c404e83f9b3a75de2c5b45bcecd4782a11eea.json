{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Stereographic from \"./Stereographic.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst scratchCarto1 = new Cartographic();\nconst scratchCarto2 = new Cartographic();\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  const height = carto1.height;\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\nconst scratchBoundingRectangle = new BoundingRectangle();\nconst scratchPosition = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nlet scratchPerPosNormal = new Cartesian3();\nlet scratchPerPosTangent = new Cartesian3();\nlet scratchPerPosBitangent = new Cartesian3();\nconst appendTextureCoordinatesOrigin = new Cartesian2();\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\nconst appendTextureCoordinatesQuaternion = new Quaternion();\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\nfunction computeAttributes(options) {\n  const vertexFormat = options.vertexFormat;\n  const geometry = options.geometry;\n  const shadowVolume = options.shadowVolume;\n  const flatPositions = geometry.attributes.position.values;\n  const flatTexcoords = defined(geometry.attributes.st) ? geometry.attributes.st.values : undefined;\n  let length = flatPositions.length;\n  const wall = options.wall;\n  const top = options.top || wall;\n  const bottom = options.bottom || wall;\n  if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    const boundingRectangle = options.boundingRectangle;\n    const rotationAxis = options.rotationAxis;\n    const projectTo2d = options.projectTo2d;\n    const ellipsoid = options.ellipsoid;\n    const stRotation = options.stRotation;\n    const perPositionHeight = options.perPositionHeight;\n    const origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n    const textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\n    let normals;\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n    const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n    const bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n    let textureCoordIndex = 0;\n    let attrIndex = 0;\n    let normal = scratchNormal;\n    let tangent = scratchTangent;\n    let bitangent = scratchBitangent;\n    let recomputeNormal = true;\n    let textureMatrix = appendTextureCoordinatesMatrix3;\n    let tangentRotationMatrix = tangentMatrixScratch;\n    if (stRotation !== 0.0) {\n      let rotation = Quaternion.fromAxisAngle(rotationAxis, stRotation, appendTextureCoordinatesQuaternion);\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n      rotation = Quaternion.fromAxisAngle(rotationAxis, -stRotation, appendTextureCoordinatesQuaternion);\n      tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n    }\n    let bottomOffset = 0;\n    let bottomOffset2 = 0;\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n      length /= 2;\n    }\n    for (let i = 0; i < length; i += 3) {\n      const position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\n      if (vertexFormat.st) {\n        if (!defined(flatTexcoords)) {\n          let p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\n          const st = projectTo2d([p], appendTextureCoordinatesCartesian2)[0];\n          Cartesian2.subtract(st, origin, st);\n          const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n          const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n          if (bottom) {\n            textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n          }\n          if (top) {\n            textureCoordinates[textureCoordIndex] = stx;\n            textureCoordinates[textureCoordIndex + 1] = sty;\n          }\n          textureCoordIndex += 2;\n        }\n      }\n      if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n        const attrIndex1 = attrIndex + 1;\n        const attrIndex2 = attrIndex + 2;\n        if (wall) {\n          if (i + 3 < length) {\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n            if (recomputeNormal) {\n              const p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n              recomputeNormal = false;\n            }\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\n              scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\n              scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\n              }\n            }\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n            }\n          }\n        }\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n          if (top && !perPositionHeight || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n        attrIndex += 3;\n      }\n    }\n    if (vertexFormat.st && !defined(flatTexcoords)) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates\n      });\n    }\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals\n      });\n    }\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents\n      });\n    }\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents\n      });\n    }\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals\n      });\n    }\n  }\n  if (options.extrude && defined(options.offsetAttribute)) {\n    const size = flatPositions.length / 3;\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if (top && bottom || wall) {\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = offsetAttribute.fill(1);\n      }\n    } else {\n      const offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n  return geometry;\n}\nconst createGeometryFromPositionsExtrudedPositions = [];\nfunction createGeometryFromPositionsExtruded(ellipsoid, polygon, textureCoordinates, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\n  const geos = {\n    walls: []\n  };\n  let i;\n  if (closeTop || closeBottom) {\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, textureCoordinates, granularity, perPositionHeight, vertexFormat, arcType);\n    const edgePoints = topGeo.attributes.position.values;\n    const indices = topGeo.indices;\n    let numPositions;\n    let newIndices;\n    if (closeTop && closeBottom) {\n      const topBottomPositions = edgePoints.concat(edgePoints);\n      numPositions = topBottomPositions.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\n      newIndices.set(indices);\n      const ilength = indices.length;\n      const length = numPositions / 2;\n      for (i = 0; i < ilength; i += 3) {\n        const i0 = newIndices[i] + length;\n        const i1 = newIndices[i + 1] + length;\n        const i2 = newIndices[i + 2] + length;\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n      topGeo.attributes.position.values = topBottomPositions;\n      if (perPositionHeight && vertexFormat.normal) {\n        const normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\n        topGeo.attributes.normal.values.set(normals);\n      }\n      if (vertexFormat.st && defined(textureCoordinates)) {\n        const texcoords = topGeo.attributes.st.values;\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\n      }\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n      topGeo.indices = newIndices;\n    }\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo\n    });\n  }\n  let outerRing = hierarchy.outerRing;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  let positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, textureCoordinates, ellipsoid, granularity, perPositionHeight, arcType);\n  geos.walls.push(new GeometryInstance({\n    geometry: wallGeo\n  }));\n  const holes = hierarchy.holes;\n  for (i = 0; i < holes.length; i++) {\n    let hole = holes[i];\n    positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, textureCoordinates, ellipsoid, granularity, perPositionHeight, arcType);\n    geos.walls.push(new GeometryInstance({\n      geometry: wallGeo\n    }));\n  }\n  return geos;\n}\n\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * const polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * const polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * const extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (defined(options.perPositionHeight) && options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\"Cannot use both options.perPositionHeight and options.height\");\n  }\n  if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\");\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const stRotation = defaultValue(options.stRotation, 0.0);\n  const textureCoordinates = options.textureCoordinates;\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = defaultValue(options.closeTop, true);\n  this._closeBottom = defaultValue(options.closeBottom, true);\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n  this._textureCoordinates = textureCoordinates;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy, Cartesian3) + Ellipsoid.packedLength + VertexFormat.packedLength + (textureCoordinates ? PolygonGeometryLibrary.computeHierarchyPackedLength(textureCoordinates, Cartesian2) : 1) + 12;\n}\n\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {number} [options.height=0.0] The height of the polygon.\n * @param {number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n * @returns {PolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType,\n    textureCoordinates: options.textureCoordinates\n  };\n  return new PolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex, Cartesian3);\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex++] = value._arcType;\n  if (defined(value._textureCoordinates)) {\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._textureCoordinates, array, startingIndex, Cartesian2);\n  } else {\n    array[startingIndex++] = -1.0;\n  }\n  array[startingIndex++] = value.packedLength;\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\n\n//Only used to avoid inability to default construct.\nconst dummyOptions = {\n  polygonHierarchy: {}\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex, Cartesian3);\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const closeTop = array[startingIndex++] === 1.0;\n  const closeBottom = array[startingIndex++] === 1.0;\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex++];\n  const arcType = array[startingIndex++];\n  const textureCoordinates = array[startingIndex] === -1.0 ? undefined : PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex, Cartesian2);\n  if (defined(textureCoordinates)) {\n    startingIndex = textureCoordinates.startingIndex;\n    delete textureCoordinates.startingIndex;\n  } else {\n    startingIndex++;\n  }\n  const packedLength = array[startingIndex++];\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result._textureCoordinates = textureCoordinates;\n  result.packedLength = packedLength;\n  return result;\n};\nconst scratchCartesian0 = new Cartesian2();\nconst scratchCartesian1 = new Cartesian2();\nconst scratchPolarClosest = new Stereographic();\nfunction expandRectangle(polar, lastPolar, ellipsoid, arcType, polygon, result) {\n  const longitude = polar.longitude;\n  const lonAdjusted = longitude >= 0.0 ? longitude : longitude + CesiumMath.TWO_PI;\n  polygon.westOverIdl = Math.min(polygon.westOverIdl, lonAdjusted);\n  polygon.eastOverIdl = Math.max(polygon.eastOverIdl, lonAdjusted);\n  result.west = Math.min(result.west, longitude);\n  result.east = Math.max(result.east, longitude);\n  const latitude = polar.getLatitude(ellipsoid);\n  let segmentLatitude = latitude;\n  result.south = Math.min(result.south, latitude);\n  result.north = Math.max(result.north, latitude);\n  if (arcType !== ArcType.RHUMB) {\n    // Geodesics will need to find the closest point on line. Rhumb lines will not have a latitude greater in magnitude than either of their endpoints.\n    const segment = Cartesian2.subtract(lastPolar.position, polar.position, scratchCartesian0);\n    const t = Cartesian2.dot(lastPolar.position, segment) / Cartesian2.dot(segment, segment);\n    if (t > 0.0 && t < 1.0) {\n      const projected = Cartesian2.add(lastPolar.position, Cartesian2.multiplyByScalar(segment, -t, segment), scratchCartesian1);\n      const closestPolar = Stereographic.clone(lastPolar, scratchPolarClosest);\n      closestPolar.position = projected;\n      const adjustedLatitude = closestPolar.getLatitude(ellipsoid);\n      result.south = Math.min(result.south, adjustedLatitude);\n      result.north = Math.max(result.north, adjustedLatitude);\n      if (Math.abs(latitude) > Math.abs(adjustedLatitude)) {\n        segmentLatitude = adjustedLatitude;\n      }\n    }\n  }\n  const direction = lastPolar.x * polar.y - polar.x * lastPolar.y;\n\n  // The total internal angle in either hemisphere determines if the pole is inside or outside the polygon\n  let angle = Math.sign(direction);\n  if (angle !== 0.0) {\n    angle *= Cartesian2.angleBetween(lastPolar.position, polar.position);\n  }\n  if (segmentLatitude >= 0.0) {\n    polygon.northAngle += angle;\n  }\n  if (segmentLatitude <= 0.0) {\n    polygon.southAngle += angle;\n  }\n}\nconst scratchPolar = new Stereographic();\nconst scratchPolarPrevious = new Stereographic();\nconst polygon = {\n  northAngle: 0.0,\n  southAngle: 0.0,\n  westOverIdl: 0.0,\n  eastOverIdl: 0.0\n};\n\n/**\n * Computes a rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Cartesian3[]} positions A linear ring defining the outer boundary of the polygon.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {ArcType} [arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nPolygonGeometry.computeRectangleFromPositions = function (positions, ellipsoid, arcType, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  if (positions.length < 3) {\n    return result;\n  }\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n  polygon.northAngle = 0.0;\n  polygon.southAngle = 0.0;\n  polygon.westOverIdl = Number.POSITIVE_INFINITY;\n  polygon.eastOverIdl = Number.NEGATIVE_INFINITY;\n  const positionsLength = positions.length;\n  let lastPolarPosition = Stereographic.fromCartesian(positions[0], scratchPolarPrevious);\n  for (let i = 1; i < positionsLength; i++) {\n    const polarPosition = Stereographic.fromCartesian(positions[i], scratchPolar);\n    expandRectangle(polarPosition, lastPolarPosition, ellipsoid, arcType, polygon, result);\n    lastPolarPosition = Stereographic.clone(polarPosition, lastPolarPosition);\n  }\n  expandRectangle(Stereographic.fromCartesian(positions[0], scratchPolar), lastPolarPosition, ellipsoid, arcType, polygon, result);\n  if (result.east - result.west > polygon.eastOverIdl - polygon.westOverIdl) {\n    result.west = polygon.westOverIdl;\n    result.east = polygon.eastOverIdl;\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  // If either pole is inside the polygon, adjust the rectangle so the pole is included\n  if (CesiumMath.equalsEpsilon(Math.abs(polygon.northAngle), CesiumMath.TWO_PI, CesiumMath.EPSILON10)) {\n    result.north = CesiumMath.PI_OVER_TWO;\n    result.east = CesiumMath.PI;\n    result.west = -CesiumMath.PI;\n  }\n  if (CesiumMath.equalsEpsilon(Math.abs(polygon.southAngle), CesiumMath.TWO_PI, CesiumMath.EPSILON10)) {\n    result.south = -CesiumMath.PI_OVER_TWO;\n    result.east = CesiumMath.PI;\n    result.west = -CesiumMath.PI;\n  }\n  return result;\n};\nconst scratchPolarForPlane = new Stereographic();\nfunction getTangentPlane(rectangle, positions, ellipsoid) {\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    const polar = Stereographic.fromCartesian(positions[0], scratchPolarForPlane);\n    return polar.tangentPlane;\n  }\n\n  // Use a local tangent plane for smaller extents\n  return EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n}\nconst scratchCartographicCyllindrical = new Cartographic();\nfunction createProjectTo2d(rectangle, outerPositions, ellipsoid) {\n  return (positions, results) => {\n    // If the polygon positions span a large enough extent, use a specialized projection\n    if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n      // polygons that cross the equator must use cyllindrical coordinates to correctly compute winding order.\n      if (rectangle.south < 0 && rectangle.north > 0) {\n        if (!defined(results)) {\n          results = [];\n        }\n        for (let i = 0; i < positions.length; ++i) {\n          const cartographic = ellipsoid.cartesianToCartographic(positions[i], scratchCartographicCyllindrical);\n          results[i] = new Cartesian2(cartographic.longitude / CesiumMath.PI, cartographic.latitude / CesiumMath.PI_OVER_TWO);\n        }\n        results.length = positions.length;\n        return results;\n      }\n      return Stereographic.fromCartesianArray(positions, results);\n    }\n\n    // Use a local tangent plane for smaller extents\n    const tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n    return tangentPlane.projectPointsOntoPlane(positions, results);\n  };\n}\nfunction createProjectPositionTo2d(rectangle, outerRing, ellipsoid) {\n  // If the polygon positions span a large enough extent, use a specialized projection\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    return (position, result) => {\n      // polygons that cross the equator must use cyllindrical coordinates to correctly compute winding order.\n      if (rectangle.south < 0 && rectangle.north > 0) {\n        const cartographic = ellipsoid.cartesianToCartographic(position, scratchCartographicCyllindrical);\n        if (!defined(result)) {\n          result = new Cartesian2();\n        }\n        result.x = cartographic.longitude / CesiumMath.PI;\n        result.y = cartographic.latitude / CesiumMath.PI_OVER_TWO;\n        return result;\n      }\n      return Stereographic.fromCartesian(position, result);\n    };\n  }\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  return (position, result) => {\n    // Use a local tangent plane for smaller extents\n    return tangentPlane.projectPointsOntoPlane(position, result);\n  };\n}\nfunction createSplitPolygons(rectangle, ellipsoid, arcType, perPositionHeight) {\n  return (polygons, results) => {\n    if (!perPositionHeight && (rectangle.height >= CesiumMath.PI_OVER_TWO || rectangle.width >= 2 * CesiumMath.PI_OVER_THREE)) {\n      return PolygonGeometryLibrary.splitPolygonsOnEquator(polygons, ellipsoid, arcType, results);\n    }\n    return polygons;\n  };\n}\nfunction computeBoundingRectangle(outerRing, rectangle, ellipsoid, stRotation) {\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    return BoundingRectangle.fromRectangle(rectangle, undefined, scratchBoundingRectangle);\n  }\n  const outerPositions = outerRing;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n  return PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\n}\n\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  const vertexFormat = polygonGeometry._vertexFormat;\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const stRotation = polygonGeometry._stRotation;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const closeTop = polygonGeometry._closeTop;\n  const closeBottom = polygonGeometry._closeBottom;\n  const arcType = polygonGeometry._arcType;\n  const textureCoordinates = polygonGeometry._textureCoordinates;\n  const hasTextureCoordinates = defined(textureCoordinates);\n  const outerPositions = polygonHierarchy.positions;\n  if (outerPositions.length < 3) {\n    return;\n  }\n  const rectangle = polygonGeometry.rectangle;\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, hasTextureCoordinates, createProjectTo2d(rectangle, outerPositions, ellipsoid), !perPositionHeight, ellipsoid, createSplitPolygons(rectangle, ellipsoid, arcType, perPositionHeight));\n  const hierarchy = results.hierarchy;\n  const polygons = results.polygons;\n  const dummyFunction = function (identity) {\n    return identity;\n  };\n  const textureCoordinatePolygons = hasTextureCoordinates ? PolygonGeometryLibrary.polygonsFromHierarchy(textureCoordinates, true, dummyFunction, false, ellipsoid).polygons : undefined;\n  if (hierarchy.length === 0) {\n    return;\n  }\n  const outerRing = hierarchy[0].outerRing;\n  const boundingRectangle = computeBoundingRectangle(outerRing, rectangle, ellipsoid, stRotation);\n  const geometries = [];\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  const options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    rotationAxis: getTangentPlane(rectangle, outerRing, ellipsoid).plane.normal,\n    projectTo2d: createProjectPositionTo2d(rectangle, outerRing, ellipsoid),\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    textureCoordinates: undefined,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType\n  };\n  let i;\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n    for (i = 0; i < polygons.length; i++) {\n      const splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined, granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\n      let topAndBottom;\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\n        options.geometry = topAndBottom.geometry;\n      }\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n      const walls = splitGeometry.walls;\n      options.wall = true;\n      for (let k = 0; k < walls.length; k++) {\n        const wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      const geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined, granularity, perPositionHeight, vertexFormat, arcType)\n      });\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n      options.geometry = geometryInstance.geometry;\n      geometryInstance.geometry = computeAttributes(options);\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length = geometryInstance.geometry.attributes.position.values.length;\n        const offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1,\n          values: applyOffset\n        });\n      }\n      geometries.push(geometryInstance);\n    }\n  }\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n  geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n  const attributes = geometry.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute\n  });\n};\n\n/**\n * @private\n */\nPolygonGeometry.createShadowVolume = function (polygonGeometry, minHeightFunc, maxHeightFunc) {\n  const granularity = polygonGeometry._granularity;\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType\n  });\n};\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  const stRotation = -polygonGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const positions = polygonGeometry._polygonHierarchy.positions;\n  const boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n}\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        const positions = this._polygonHierarchy.positions;\n        this._rectangle = PolygonGeometry.computeRectangleFromPositions(positions, this._ellipsoid, this._arcType);\n      }\n      return this._rectangle;\n    }\n  },\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    }\n  }\n});\nexport default PolygonGeometry;","map":{"version":3,"names":["ArcType","BoundingRectangle","BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidTangentPlane","Geometry","GeometryAttribute","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","Matrix3","PolygonGeometryLibrary","PolygonPipeline","Quaternion","Rectangle","Stereographic","VertexFormat","WindingOrder","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","position","p1","p2","ellipsoid","carto1","cartesianToCartographic","height","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","scratchPosition","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","tangentMatrixScratch","computeAttributes","options","vertexFormat","geometry","shadowVolume","flatPositions","attributes","values","flatTexcoords","st","undefined","length","wall","top","bottom","normal","tangent","bitangent","boundingRectangle","rotationAxis","projectTo2d","stRotation","perPositionHeight","origin","x","y","textureCoordinates","Float32Array","normals","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","fromAxisAngle","fromQuaternion","clone","IDENTITY","bottomOffset","bottomOffset2","i","fromArray","p","multiplyByVector","scaleToGeodeticSurface","subtract","stx","clamp","width","sty","attrIndex1","attrIndex2","normalize","cross","equalsEpsilon","EPSILON10","geodeticSurfaceNormal","UNIT_Z","z","componentDatatype","FLOAT","componentsPerAttribute","extrudeDirection","extrude","offsetAttribute","size","Uint8Array","TOP","fill","offsetValue","NONE","applyOffset","UNSIGNED_BYTE","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","granularity","hierarchy","closeTop","closeBottom","arcType","geos","walls","topGeo","createGeometryFromPositions","edgePoints","indices","numPositions","newIndices","topBottomPositions","concat","createTypedArray","set","ilength","i0","i1","i2","texcoords","topAndBottom","outerRing","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","windingOrder","computeWindingOrder2D","CLOCKWISE","slice","reverse","wallGeo","computeWallGeometry","push","holes","hole","COUNTER_CLOCKWISE","PolygonGeometry","typeOf","object","polygonHierarchy","GEODESIC","RHUMB","DEFAULT","default","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","_textureCoordinates","packedLength","computeHierarchyPackedLength","fromPositions","EMPTY_OBJECT","positions","newOptions","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","dummyOptions","unpack","result","unpackPolygonHierarchy","scratchCartesian0","scratchCartesian1","scratchPolarClosest","expandRectangle","polar","lastPolar","longitude","lonAdjusted","TWO_PI","westOverIdl","eastOverIdl","west","east","latitude","getLatitude","segmentLatitude","south","north","segment","t","dot","projected","add","multiplyByScalar","closestPolar","adjustedLatitude","abs","direction","angle","sign","angleBetween","northAngle","southAngle","scratchPolar","scratchPolarPrevious","computeRectangleFromPositions","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","positionsLength","lastPolarPosition","fromCartesian","polarPosition","PI","PI_OVER_TWO","scratchPolarForPlane","getTangentPlane","rectangle","scratchCartographicCyllindrical","createProjectTo2d","outerPositions","results","cartographic","fromCartesianArray","createProjectPositionTo2d","createSplitPolygons","polygons","PI_OVER_THREE","splitPolygonsOnEquator","computeBoundingRectangle","fromRectangle","plane","projectPointOntoPlane","bind","createGeometry","polygonGeometry","hasTextureCoordinates","polygonsFromHierarchy","dummyFunction","identity","textureCoordinatePolygons","geometries","EPSILON2","splitGeometry","scaleToGeodeticHeightExtruded","scaleToGeodeticHeight","k","geometryInstance","combineInstances","Float64Array","boundingSphere","fromVertices","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","Object","defineProperties","prototype","get"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/PolygonGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Stereographic from \"./Stereographic.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nconst scratchCarto1 = new Cartographic();\nconst scratchCarto2 = new Cartographic();\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  const height = carto1.height;\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\n\nconst scratchBoundingRectangle = new BoundingRectangle();\nconst scratchPosition = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nlet scratchPerPosNormal = new Cartesian3();\nlet scratchPerPosTangent = new Cartesian3();\nlet scratchPerPosBitangent = new Cartesian3();\n\nconst appendTextureCoordinatesOrigin = new Cartesian2();\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\nconst appendTextureCoordinatesQuaternion = new Quaternion();\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\n\nfunction computeAttributes(options) {\n  const vertexFormat = options.vertexFormat;\n  const geometry = options.geometry;\n  const shadowVolume = options.shadowVolume;\n  const flatPositions = geometry.attributes.position.values;\n  const flatTexcoords = defined(geometry.attributes.st)\n    ? geometry.attributes.st.values\n    : undefined;\n\n  let length = flatPositions.length;\n  const wall = options.wall;\n  const top = options.top || wall;\n  const bottom = options.bottom || wall;\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent ||\n    shadowVolume\n  ) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    const boundingRectangle = options.boundingRectangle;\n    const rotationAxis = options.rotationAxis;\n    const projectTo2d = options.projectTo2d;\n    const ellipsoid = options.ellipsoid;\n    const stRotation = options.stRotation;\n    const perPositionHeight = options.perPositionHeight;\n\n    const origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n\n    const textureCoordinates = vertexFormat.st\n      ? new Float32Array(2 * (length / 3))\n      : undefined;\n    let normals;\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n    const tangents = vertexFormat.tangent\n      ? new Float32Array(length)\n      : undefined;\n    const bitangents = vertexFormat.bitangent\n      ? new Float32Array(length)\n      : undefined;\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n    let textureCoordIndex = 0;\n    let attrIndex = 0;\n\n    let normal = scratchNormal;\n    let tangent = scratchTangent;\n    let bitangent = scratchBitangent;\n    let recomputeNormal = true;\n\n    let textureMatrix = appendTextureCoordinatesMatrix3;\n    let tangentRotationMatrix = tangentMatrixScratch;\n    if (stRotation !== 0.0) {\n      let rotation = Quaternion.fromAxisAngle(\n        rotationAxis,\n        stRotation,\n        appendTextureCoordinatesQuaternion,\n      );\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n      rotation = Quaternion.fromAxisAngle(\n        rotationAxis,\n        -stRotation,\n        appendTextureCoordinatesQuaternion,\n      );\n      tangentRotationMatrix = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationMatrix,\n      );\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(\n        Matrix3.IDENTITY,\n        tangentRotationMatrix,\n      );\n    }\n\n    let bottomOffset = 0;\n    let bottomOffset2 = 0;\n\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n\n      length /= 2;\n    }\n\n    for (let i = 0; i < length; i += 3) {\n      const position = Cartesian3.fromArray(\n        flatPositions,\n        i,\n        appendTextureCoordinatesCartesian3,\n      );\n\n      if (vertexFormat.st) {\n        if (!defined(flatTexcoords)) {\n          let p = Matrix3.multiplyByVector(\n            textureMatrix,\n            position,\n            scratchPosition,\n          );\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\n          const st = projectTo2d([p], appendTextureCoordinatesCartesian2)[0];\n          Cartesian2.subtract(st, origin, st);\n\n          const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n          const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n          if (bottom) {\n            textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n          }\n          if (top) {\n            textureCoordinates[textureCoordIndex] = stx;\n            textureCoordinates[textureCoordIndex + 1] = sty;\n          }\n\n          textureCoordIndex += 2;\n        }\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent ||\n        shadowVolume\n      ) {\n        const attrIndex1 = attrIndex + 1;\n        const attrIndex2 = attrIndex + 2;\n\n        if (wall) {\n          if (i + 3 < length) {\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n            if (recomputeNormal) {\n              const p2 = Cartesian3.fromArray(\n                flatPositions,\n                i + length,\n                p2Scratch,\n              );\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(\n                Cartesian3.cross(p2, p1, normal),\n                normal,\n              );\n              recomputeNormal = false;\n            }\n\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(\n                Cartesian3.cross(bitangent, normal, tangent),\n                tangent,\n              );\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(\n                normals,\n                attrIndex,\n                scratchPerPosNormal,\n              );\n              scratchPerPosTangent = Cartesian3.cross(\n                Cartesian3.UNIT_Z,\n                scratchPerPosNormal,\n                scratchPerPosTangent,\n              );\n              scratchPerPosTangent = Cartesian3.normalize(\n                Matrix3.multiplyByVector(\n                  tangentRotationMatrix,\n                  scratchPerPosTangent,\n                  scratchPerPosTangent,\n                ),\n                scratchPerPosTangent,\n              );\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(\n                  Cartesian3.cross(\n                    scratchPerPosNormal,\n                    scratchPerPosTangent,\n                    scratchPerPosBitangent,\n                  ),\n                  scratchPerPosBitangent,\n                );\n              }\n            }\n\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\n              tangent,\n            );\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(\n                Cartesian3.cross(normal, tangent, bitangent),\n                bitangent,\n              );\n            }\n          }\n        }\n\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n\n          if ((top && !perPositionHeight) || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n        attrIndex += 3;\n      }\n    }\n\n    if (vertexFormat.st && !defined(flatTexcoords)) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals,\n      });\n    }\n  }\n\n  if (options.extrude && defined(options.offsetAttribute)) {\n    const size = flatPositions.length / 3;\n    let offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if ((top && bottom) || wall) {\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = offsetAttribute.fill(1);\n      }\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return geometry;\n}\n\nconst createGeometryFromPositionsExtrudedPositions = [];\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  hierarchy,\n  perPositionHeight,\n  closeTop,\n  closeBottom,\n  vertexFormat,\n  arcType,\n) {\n  const geos = {\n    walls: [],\n  };\n  let i;\n\n  if (closeTop || closeBottom) {\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\n      ellipsoid,\n      polygon,\n      textureCoordinates,\n      granularity,\n      perPositionHeight,\n      vertexFormat,\n      arcType,\n    );\n\n    const edgePoints = topGeo.attributes.position.values;\n    const indices = topGeo.indices;\n    let numPositions;\n    let newIndices;\n\n    if (closeTop && closeBottom) {\n      const topBottomPositions = edgePoints.concat(edgePoints);\n\n      numPositions = topBottomPositions.length / 3;\n\n      newIndices = IndexDatatype.createTypedArray(\n        numPositions,\n        indices.length * 2,\n      );\n      newIndices.set(indices);\n      const ilength = indices.length;\n\n      const length = numPositions / 2;\n\n      for (i = 0; i < ilength; i += 3) {\n        const i0 = newIndices[i] + length;\n        const i1 = newIndices[i + 1] + length;\n        const i2 = newIndices[i + 2] + length;\n\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n\n      topGeo.attributes.position.values = topBottomPositions;\n      if (perPositionHeight && vertexFormat.normal) {\n        const normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(\n          topBottomPositions.length,\n        );\n        topGeo.attributes.normal.values.set(normals);\n      }\n\n      if (vertexFormat.st && defined(textureCoordinates)) {\n        const texcoords = topGeo.attributes.st.values;\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\n      }\n\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n\n      topGeo.indices = newIndices;\n    }\n\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo,\n    });\n  }\n\n  let outerRing = hierarchy.outerRing;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  let positions2D = tangentPlane.projectPointsOntoPlane(\n    outerRing,\n    createGeometryFromPositionsExtrudedPositions,\n  );\n\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n    outerRing,\n    textureCoordinates,\n    ellipsoid,\n    granularity,\n    perPositionHeight,\n    arcType,\n  );\n  geos.walls.push(\n    new GeometryInstance({\n      geometry: wallGeo,\n    }),\n  );\n\n  const holes = hierarchy.holes;\n  for (i = 0; i < holes.length; i++) {\n    let hole = holes[i];\n    positions2D = tangentPlane.projectPointsOntoPlane(\n      hole,\n      createGeometryFromPositionsExtrudedPositions,\n    );\n\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n      hole,\n      textureCoordinates,\n      ellipsoid,\n      granularity,\n      perPositionHeight,\n      arcType,\n    );\n    geos.walls.push(\n      new GeometryInstance({\n        geometry: wallGeo,\n      }),\n    );\n  }\n\n  return geos;\n}\n\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * const polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * const polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * const extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (\n    defined(options.perPositionHeight) &&\n    options.perPositionHeight &&\n    defined(options.height)\n  ) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\",\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const stRotation = defaultValue(options.stRotation, 0.0);\n  const textureCoordinates = options.textureCoordinates;\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = defaultValue(options.closeTop, true);\n  this._closeBottom = defaultValue(options.closeBottom, true);\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n  this._textureCoordinates = textureCoordinates;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3,\n    ) +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    (textureCoordinates\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\n          textureCoordinates,\n          Cartesian2,\n        )\n      : 1) +\n    12;\n}\n\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {number} [options.height=0.0] The height of the polygon.\n * @param {number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n * @returns {PolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType,\n    textureCoordinates: options.textureCoordinates,\n  };\n  return new PolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex++] = value._arcType;\n  if (defined(value._textureCoordinates)) {\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n      value._textureCoordinates,\n      array,\n      startingIndex,\n      Cartesian2,\n    );\n  } else {\n    array[startingIndex++] = -1.0;\n  }\n  array[startingIndex++] = value.packedLength;\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\n\n//Only used to avoid inability to default construct.\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3,\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const closeTop = array[startingIndex++] === 1.0;\n  const closeBottom = array[startingIndex++] === 1.0;\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex++];\n  const arcType = array[startingIndex++];\n  const textureCoordinates =\n    array[startingIndex] === -1.0\n      ? undefined\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\n          array,\n          startingIndex,\n          Cartesian2,\n        );\n  if (defined(textureCoordinates)) {\n    startingIndex = textureCoordinates.startingIndex;\n    delete textureCoordinates.startingIndex;\n  } else {\n    startingIndex++;\n  }\n  const packedLength = array[startingIndex++];\n\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result._textureCoordinates = textureCoordinates;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\nconst scratchCartesian0 = new Cartesian2();\nconst scratchCartesian1 = new Cartesian2();\nconst scratchPolarClosest = new Stereographic();\nfunction expandRectangle(\n  polar,\n  lastPolar,\n  ellipsoid,\n  arcType,\n  polygon,\n  result,\n) {\n  const longitude = polar.longitude;\n  const lonAdjusted =\n    longitude >= 0.0 ? longitude : longitude + CesiumMath.TWO_PI;\n  polygon.westOverIdl = Math.min(polygon.westOverIdl, lonAdjusted);\n  polygon.eastOverIdl = Math.max(polygon.eastOverIdl, lonAdjusted);\n\n  result.west = Math.min(result.west, longitude);\n  result.east = Math.max(result.east, longitude);\n\n  const latitude = polar.getLatitude(ellipsoid);\n  let segmentLatitude = latitude;\n\n  result.south = Math.min(result.south, latitude);\n  result.north = Math.max(result.north, latitude);\n\n  if (arcType !== ArcType.RHUMB) {\n    // Geodesics will need to find the closest point on line. Rhumb lines will not have a latitude greater in magnitude than either of their endpoints.\n    const segment = Cartesian2.subtract(\n      lastPolar.position,\n      polar.position,\n      scratchCartesian0,\n    );\n    const t =\n      Cartesian2.dot(lastPolar.position, segment) /\n      Cartesian2.dot(segment, segment);\n    if (t > 0.0 && t < 1.0) {\n      const projected = Cartesian2.add(\n        lastPolar.position,\n        Cartesian2.multiplyByScalar(segment, -t, segment),\n        scratchCartesian1,\n      );\n      const closestPolar = Stereographic.clone(lastPolar, scratchPolarClosest);\n      closestPolar.position = projected;\n      const adjustedLatitude = closestPolar.getLatitude(ellipsoid);\n      result.south = Math.min(result.south, adjustedLatitude);\n      result.north = Math.max(result.north, adjustedLatitude);\n\n      if (Math.abs(latitude) > Math.abs(adjustedLatitude)) {\n        segmentLatitude = adjustedLatitude;\n      }\n    }\n  }\n  const direction = lastPolar.x * polar.y - polar.x * lastPolar.y;\n\n  // The total internal angle in either hemisphere determines if the pole is inside or outside the polygon\n  let angle = Math.sign(direction);\n  if (angle !== 0.0) {\n    angle *= Cartesian2.angleBetween(lastPolar.position, polar.position);\n  }\n\n  if (segmentLatitude >= 0.0) {\n    polygon.northAngle += angle;\n  }\n\n  if (segmentLatitude <= 0.0) {\n    polygon.southAngle += angle;\n  }\n}\n\nconst scratchPolar = new Stereographic();\nconst scratchPolarPrevious = new Stereographic();\nconst polygon = {\n  northAngle: 0.0,\n  southAngle: 0.0,\n  westOverIdl: 0.0,\n  eastOverIdl: 0.0,\n};\n\n/**\n * Computes a rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Cartesian3[]} positions A linear ring defining the outer boundary of the polygon.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {ArcType} [arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nPolygonGeometry.computeRectangleFromPositions = function (\n  positions,\n  ellipsoid,\n  arcType,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  if (positions.length < 3) {\n    return result;\n  }\n\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n\n  polygon.northAngle = 0.0;\n  polygon.southAngle = 0.0;\n  polygon.westOverIdl = Number.POSITIVE_INFINITY;\n  polygon.eastOverIdl = Number.NEGATIVE_INFINITY;\n\n  const positionsLength = positions.length;\n  let lastPolarPosition = Stereographic.fromCartesian(\n    positions[0],\n    scratchPolarPrevious,\n  );\n  for (let i = 1; i < positionsLength; i++) {\n    const polarPosition = Stereographic.fromCartesian(\n      positions[i],\n      scratchPolar,\n    );\n    expandRectangle(\n      polarPosition,\n      lastPolarPosition,\n      ellipsoid,\n      arcType,\n      polygon,\n      result,\n    );\n\n    lastPolarPosition = Stereographic.clone(polarPosition, lastPolarPosition);\n  }\n\n  expandRectangle(\n    Stereographic.fromCartesian(positions[0], scratchPolar),\n    lastPolarPosition,\n    ellipsoid,\n    arcType,\n    polygon,\n    result,\n  );\n\n  if (result.east - result.west > polygon.eastOverIdl - polygon.westOverIdl) {\n    result.west = polygon.westOverIdl;\n    result.east = polygon.eastOverIdl;\n\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  // If either pole is inside the polygon, adjust the rectangle so the pole is included\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(polygon.northAngle),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    result.north = CesiumMath.PI_OVER_TWO;\n    result.east = CesiumMath.PI;\n    result.west = -CesiumMath.PI;\n  }\n\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(polygon.southAngle),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    result.south = -CesiumMath.PI_OVER_TWO;\n    result.east = CesiumMath.PI;\n    result.west = -CesiumMath.PI;\n  }\n\n  return result;\n};\n\nconst scratchPolarForPlane = new Stereographic();\nfunction getTangentPlane(rectangle, positions, ellipsoid) {\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    const polar = Stereographic.fromCartesian(\n      positions[0],\n      scratchPolarForPlane,\n    );\n    return polar.tangentPlane;\n  }\n\n  // Use a local tangent plane for smaller extents\n  return EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n}\n\nconst scratchCartographicCyllindrical = new Cartographic();\nfunction createProjectTo2d(rectangle, outerPositions, ellipsoid) {\n  return (positions, results) => {\n    // If the polygon positions span a large enough extent, use a specialized projection\n    if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n      // polygons that cross the equator must use cyllindrical coordinates to correctly compute winding order.\n      if (rectangle.south < 0 && rectangle.north > 0) {\n        if (!defined(results)) {\n          results = [];\n        }\n\n        for (let i = 0; i < positions.length; ++i) {\n          const cartographic = ellipsoid.cartesianToCartographic(\n            positions[i],\n            scratchCartographicCyllindrical,\n          );\n          results[i] = new Cartesian2(\n            cartographic.longitude / CesiumMath.PI,\n            cartographic.latitude / CesiumMath.PI_OVER_TWO,\n          );\n        }\n\n        results.length = positions.length;\n        return results;\n      }\n\n      return Stereographic.fromCartesianArray(positions, results);\n    }\n\n    // Use a local tangent plane for smaller extents\n    const tangentPlane = EllipsoidTangentPlane.fromPoints(\n      outerPositions,\n      ellipsoid,\n    );\n    return tangentPlane.projectPointsOntoPlane(positions, results);\n  };\n}\n\nfunction createProjectPositionTo2d(rectangle, outerRing, ellipsoid) {\n  // If the polygon positions span a large enough extent, use a specialized projection\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    return (position, result) => {\n      // polygons that cross the equator must use cyllindrical coordinates to correctly compute winding order.\n      if (rectangle.south < 0 && rectangle.north > 0) {\n        const cartographic = ellipsoid.cartesianToCartographic(\n          position,\n          scratchCartographicCyllindrical,\n        );\n        if (!defined(result)) {\n          result = new Cartesian2();\n        }\n        result.x = cartographic.longitude / CesiumMath.PI;\n        result.y = cartographic.latitude / CesiumMath.PI_OVER_TWO;\n\n        return result;\n      }\n\n      return Stereographic.fromCartesian(position, result);\n    };\n  }\n\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  return (position, result) => {\n    // Use a local tangent plane for smaller extents\n    return tangentPlane.projectPointsOntoPlane(position, result);\n  };\n}\n\nfunction createSplitPolygons(rectangle, ellipsoid, arcType, perPositionHeight) {\n  return (polygons, results) => {\n    if (\n      !perPositionHeight &&\n      (rectangle.height >= CesiumMath.PI_OVER_TWO ||\n        rectangle.width >= 2 * CesiumMath.PI_OVER_THREE)\n    ) {\n      return PolygonGeometryLibrary.splitPolygonsOnEquator(\n        polygons,\n        ellipsoid,\n        arcType,\n        results,\n      );\n    }\n\n    return polygons;\n  };\n}\n\nfunction computeBoundingRectangle(outerRing, rectangle, ellipsoid, stRotation) {\n  if (rectangle.height >= CesiumMath.PI || rectangle.width >= CesiumMath.PI) {\n    return BoundingRectangle.fromRectangle(\n      rectangle,\n      undefined,\n      scratchBoundingRectangle,\n    );\n  }\n\n  const outerPositions = outerRing;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(\n    outerPositions,\n    ellipsoid,\n  );\n  return PolygonGeometryLibrary.computeBoundingRectangle(\n    tangentPlane.plane.normal,\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\n    outerPositions,\n    stRotation,\n    scratchBoundingRectangle,\n  );\n}\n\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  const vertexFormat = polygonGeometry._vertexFormat;\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const stRotation = polygonGeometry._stRotation;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const closeTop = polygonGeometry._closeTop;\n  const closeBottom = polygonGeometry._closeBottom;\n  const arcType = polygonGeometry._arcType;\n  const textureCoordinates = polygonGeometry._textureCoordinates;\n\n  const hasTextureCoordinates = defined(textureCoordinates);\n\n  const outerPositions = polygonHierarchy.positions;\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  const rectangle = polygonGeometry.rectangle;\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    hasTextureCoordinates,\n    createProjectTo2d(rectangle, outerPositions, ellipsoid),\n    !perPositionHeight,\n    ellipsoid,\n    createSplitPolygons(rectangle, ellipsoid, arcType, perPositionHeight),\n  );\n\n  const hierarchy = results.hierarchy;\n  const polygons = results.polygons;\n\n  const dummyFunction = function (identity) {\n    return identity;\n  };\n\n  const textureCoordinatePolygons = hasTextureCoordinates\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\n        textureCoordinates,\n        true,\n        dummyFunction,\n        false,\n        ellipsoid,\n      ).polygons\n    : undefined;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  const outerRing = hierarchy[0].outerRing;\n  const boundingRectangle = computeBoundingRectangle(\n    outerRing,\n    rectangle,\n    ellipsoid,\n    stRotation,\n  );\n\n  const geometries = [];\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n  const options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    rotationAxis: getTangentPlane(rectangle, outerRing, ellipsoid).plane.normal,\n    projectTo2d: createProjectPositionTo2d(rectangle, outerRing, ellipsoid),\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    textureCoordinates: undefined,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType,\n  };\n\n  let i;\n\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n    for (i = 0; i < polygons.length; i++) {\n      const splitGeometry = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n        granularity,\n        hierarchy[i],\n        perPositionHeight,\n        closeTop,\n        closeBottom,\n        vertexFormat,\n        arcType,\n      );\n\n      let topAndBottom;\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          topAndBottom.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight,\n        );\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values =\n          PolygonPipeline.scaleToGeodeticHeight(\n            topAndBottom.geometry.attributes.position.values,\n            height,\n            ellipsoid,\n            !perPositionHeight,\n          );\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values =\n          PolygonPipeline.scaleToGeodeticHeight(\n            topAndBottom.geometry.attributes.position.values,\n            extrudedHeight,\n            ellipsoid,\n            true,\n          );\n        options.geometry = topAndBottom.geometry;\n      }\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n\n      const walls = splitGeometry.walls;\n      options.wall = true;\n      for (let k = 0; k < walls.length; k++) {\n        const wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          wall.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight,\n        );\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      const geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\n          ellipsoid,\n          polygons[i],\n          hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n          granularity,\n          perPositionHeight,\n          vertexFormat,\n          arcType,\n        ),\n      });\n      geometryInstance.geometry.attributes.position.values =\n        PolygonPipeline.scaleToGeodeticHeight(\n          geometryInstance.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight,\n        );\n      options.geometry = geometryInstance.geometry;\n\n      geometryInstance.geometry = computeAttributes(options);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        const offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n        geometryInstance.geometry.attributes.applyOffset =\n          new GeometryAttribute({\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          });\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values,\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices,\n  );\n\n  const attributes = geometry.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n  );\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nPolygonGeometry.createShadowVolume = function (\n  polygonGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = polygonGeometry._granularity;\n  const ellipsoid = polygonGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType,\n  });\n};\n\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  const stRotation = -polygonGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const positions = polygonGeometry._polygonHierarchy.positions;\n  const boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle,\n  );\n}\n\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        const positions = this._polygonHierarchy.positions;\n        this._rectangle = PolygonGeometry.computeRectangleFromPositions(\n          positions,\n          this._ellipsoid,\n          this._arcType,\n        );\n      }\n\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints =\n          textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default PolygonGeometry;\n"],"mappings":"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,gBAAgB,CAAC;IACnB6C,QAAQ,EAAE8G;EACZ,CAAC,CACH,CAAC;EAED,MAAMG,KAAK,GAAGnC,SAAS,CAACmC,KAAK;EAC7B,KAAKxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,KAAK,CAACzG,MAAM,EAAEiC,CAAC,EAAE,EAAE;IACjC,IAAIyE,IAAI,GAAGD,KAAK,CAACxE,CAAC,CAAC;IACnB8D,WAAW,GAAGF,YAAY,CAACG,sBAAsB,CAC/CU,IAAI,EACJxC,4CACF,CAAC;IAED+B,YAAY,GAAG/I,eAAe,CAACgJ,qBAAqB,CAACH,WAAW,CAAC;IACjE,IAAIE,YAAY,KAAK1I,YAAY,CAACoJ,iBAAiB,EAAE;MACnDD,IAAI,GAAGA,IAAI,CAACN,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IAC/B;IAEAC,OAAO,GAAGrJ,sBAAsB,CAACsJ,mBAAmB,CAClDG,IAAI,EACJ3F,kBAAkB,EAClBjD,SAAS,EACTuG,WAAW,EACX1D,iBAAiB,EACjB8D,OACF,CAAC;IACDC,IAAI,CAACC,KAAK,CAAC6B,IAAI,CACb,IAAI7J,gBAAgB,CAAC;MACnB6C,QAAQ,EAAE8G;IACZ,CAAC,CACH,CAAC;EACH;EAEA,OAAO5B,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkC,eAAeA,CAACtH,OAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}