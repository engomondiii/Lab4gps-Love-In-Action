{"ast":null,"code":"import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ConstantSpline from \"../../Core/ConstantSpline.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport HermiteSpline from \"../../Core/HermiteSpline.js\";\nimport InterpolationType from \"../../Core/InterpolationType.js\";\nimport LinearSpline from \"../../Core/LinearSpline.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport SteppedSpline from \"../../Core/SteppedSpline.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport QuaternionSpline from \"../../Core/QuaternionSpline.js\";\nconst AnimatedPropertyType = ModelComponents.AnimatedPropertyType;\n\n/**\n * A runtime animation channel for a {@link ModelAnimation}. An animation\n * channel is responsible for interpolating between the keyframe values of an animated\n * property, then applying the change to the target node.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.AnimationChannel} options.channel The corresponding animation channel components from the 3D model.\n * @param {ModelAnimation} options.runtimeAnimation The runtime animation containing this channel.\n * @param {ModelRuntimeNode} options.runtimeNode The runtime node that this channel will animate.\n *\n * @alias ModelAnimationChannel\n * @constructor\n *\n * @private\n */\nfunction ModelAnimationChannel(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const channel = options.channel;\n  const runtimeAnimation = options.runtimeAnimation;\n  const runtimeNode = options.runtimeNode;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.channel\", channel);\n  Check.typeOf.object(\"options.runtimeAnimation\", runtimeAnimation);\n  Check.typeOf.object(\"options.runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  this._channel = channel;\n  this._runtimeAnimation = runtimeAnimation;\n  this._runtimeNode = runtimeNode;\n\n  // An animation channel can have multiple splines if it animates\n  // a node's morph weights, which will involve multiple morph targets.\n  this._splines = [];\n  this._path = undefined;\n  initialize(this);\n}\nObject.defineProperties(ModelAnimationChannel.prototype, {\n  /**\n   * The glTF animation channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelComponents.AnimationChannel}\n   * @readonly\n   *\n   * @private\n   */\n  channel: {\n    get: function () {\n      return this._channel;\n    }\n  },\n  /**\n   * The runtime animation that owns this channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelAnimation}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeAnimation: {\n    get: function () {\n      return this._runtimeAnimation;\n    }\n  },\n  /**\n   * The runtime node that this channel animates.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelRuntimeNode}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeNode: {\n    get: function () {\n      return this._runtimeNode;\n    }\n  },\n  /**\n   * The splines used to evaluate this animation channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {Spline[]}\n   * @readonly\n   *\n   * @private\n   */\n  splines: {\n    get: function () {\n      return this._splines;\n    }\n  }\n});\nfunction createCubicSpline(times, points) {\n  const cubicPoints = [];\n  const inTangents = [];\n  const outTangents = [];\n  const length = points.length;\n  for (let i = 0; i < length; i += 3) {\n    inTangents.push(points[i]);\n    cubicPoints.push(points[i + 1]);\n    outTangents.push(points[i + 2]);\n  }\n\n  // Remove the first in-tangent and last out-tangent, since they\n  // are not used in the spline calculations\n  inTangents.splice(0, 1);\n  outTangents.length = outTangents.length - 1;\n  return new HermiteSpline({\n    times: times,\n    points: cubicPoints,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n}\nfunction createSpline(times, points, interpolation, path) {\n  if (times.length === 1 && points.length === 1) {\n    return new ConstantSpline(points[0]);\n  }\n  switch (interpolation) {\n    case InterpolationType.STEP:\n      return new SteppedSpline({\n        times: times,\n        points: points\n      });\n    case InterpolationType.CUBICSPLINE:\n      return createCubicSpline(times, points);\n    case InterpolationType.LINEAR:\n      if (path === AnimatedPropertyType.ROTATION) {\n        return new QuaternionSpline({\n          times: times,\n          points: points\n        });\n      }\n      return new LinearSpline({\n        times: times,\n        points: points\n      });\n  }\n}\nfunction createSplines(times, points, interpolation, path, count) {\n  const splines = [];\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const pointsLength = points.length;\n    // Get the number of keyframes in each weight's output.\n    const outputLength = pointsLength / count;\n\n    // Iterate over the array using the number of morph targets in the model.\n    let targetIndex, i;\n    for (targetIndex = 0; targetIndex < count; targetIndex++) {\n      const output = new Array(outputLength);\n\n      // Weights are ordered such that they are keyframed in the order in which\n      // their targets appear the glTF. For example, the weights of three targets\n      // may appear as [w(0,0), w(0,1), w(0,2), w(1,0), w(1,1), w(1,2) ...],\n      // where i and j in w(i,j) are the time indices and target indices, respectively.\n\n      // However, for morph targets with cubic interpolation, the data is stored per\n      // keyframe in the order [a1, a2, ..., an, v1, v2, ... vn, b1, b2, ..., bn],\n      // where ai, vi, and bi are the in-tangent, property, and out-tangents of\n      // the ith morph target respectively.\n      let pointsIndex = targetIndex;\n      if (interpolation === InterpolationType.CUBICSPLINE) {\n        for (i = 0; i < outputLength; i += 3) {\n          output[i] = points[pointsIndex];\n          output[i + 1] = points[pointsIndex + count];\n          output[i + 2] = points[pointsIndex + 2 * count];\n          pointsIndex += count * 3;\n        }\n      } else {\n        for (i = 0; i < outputLength; i++) {\n          output[i] = points[pointsIndex];\n          pointsIndex += count;\n        }\n      }\n      splines.push(createSpline(times, output, interpolation, path));\n    }\n  } else {\n    splines.push(createSpline(times, points, interpolation, path));\n  }\n  return splines;\n}\nconst scratchCartesian3 = new Cartesian3();\nconst scratchQuaternion = new Quaternion();\nfunction initialize(runtimeChannel) {\n  const channel = runtimeChannel._channel;\n  const sampler = channel.sampler;\n  const times = sampler.input;\n  const points = sampler.output;\n  const interpolation = sampler.interpolation;\n  const target = channel.target;\n  const path = target.path;\n  const runtimeNode = runtimeChannel._runtimeNode;\n  const count = defined(runtimeNode.morphWeights) ? runtimeNode.morphWeights.length : 1;\n  const splines = createSplines(times, points, interpolation, path, count);\n  runtimeChannel._splines = splines;\n  runtimeChannel._path = path;\n}\n\n/**\n * Animates the target node property based on its spline.\n *\n * @param {number} time The local animation time.\n *\n * @private\n */\nModelAnimationChannel.prototype.animate = function (time) {\n  const splines = this._splines;\n  const path = this._path;\n  const model = this._runtimeAnimation.model;\n  const runtimeNode = this._runtimeNode;\n\n  // Weights are handled differently than the other properties because\n  // they need to be updated in place.\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const morphWeights = runtimeNode.morphWeights;\n    const length = morphWeights.length;\n    for (let i = 0; i < length; i++) {\n      const spline = splines[i];\n      const localAnimationTime = model.clampAnimations ? spline.clampTime(time) : spline.wrapTime(time);\n      morphWeights[i] = spline.evaluate(localAnimationTime);\n    }\n  } else if (runtimeNode.userAnimated) {\n    // If the node is being animated externally, ignore the glTF animation.\n    return;\n  } else {\n    const spline = splines[0];\n    const localAnimationTime = model.clampAnimations ? spline.clampTime(time) : spline.wrapTime(time);\n\n    // This sets the translate, rotate, and scale properties.\n    if (path === AnimatedPropertyType.TRANSLATION || path === AnimatedPropertyType.SCALE) {\n      runtimeNode[path] = spline.evaluate(localAnimationTime, scratchCartesian3);\n    } else if (path === AnimatedPropertyType.ROTATION) {\n      runtimeNode[path] = spline.evaluate(localAnimationTime, scratchQuaternion);\n    }\n  }\n};\nexport default ModelAnimationChannel;","map":{"version":3,"names":["Cartesian3","Check","ConstantSpline","defaultValue","defined","HermiteSpline","InterpolationType","LinearSpline","ModelComponents","SteppedSpline","Quaternion","QuaternionSpline","AnimatedPropertyType","ModelAnimationChannel","options","EMPTY_OBJECT","channel","runtimeAnimation","runtimeNode","typeOf","object","_channel","_runtimeAnimation","_runtimeNode","_splines","_path","undefined","initialize","Object","defineProperties","prototype","get","splines","createCubicSpline","times","points","cubicPoints","inTangents","outTangents","length","i","push","splice","createSpline","interpolation","path","STEP","CUBICSPLINE","LINEAR","ROTATION","createSplines","count","WEIGHTS","pointsLength","outputLength","targetIndex","output","Array","pointsIndex","scratchCartesian3","scratchQuaternion","runtimeChannel","sampler","input","target","morphWeights","animate","time","model","spline","localAnimationTime","clampAnimations","clampTime","wrapTime","evaluate","userAnimated","TRANSLATION","SCALE"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelAnimationChannel.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ConstantSpline from \"../../Core/ConstantSpline.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport HermiteSpline from \"../../Core/HermiteSpline.js\";\nimport InterpolationType from \"../../Core/InterpolationType.js\";\nimport LinearSpline from \"../../Core/LinearSpline.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport SteppedSpline from \"../../Core/SteppedSpline.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport QuaternionSpline from \"../../Core/QuaternionSpline.js\";\n\nconst AnimatedPropertyType = ModelComponents.AnimatedPropertyType;\n\n/**\n * A runtime animation channel for a {@link ModelAnimation}. An animation\n * channel is responsible for interpolating between the keyframe values of an animated\n * property, then applying the change to the target node.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.AnimationChannel} options.channel The corresponding animation channel components from the 3D model.\n * @param {ModelAnimation} options.runtimeAnimation The runtime animation containing this channel.\n * @param {ModelRuntimeNode} options.runtimeNode The runtime node that this channel will animate.\n *\n * @alias ModelAnimationChannel\n * @constructor\n *\n * @private\n */\nfunction ModelAnimationChannel(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const channel = options.channel;\n  const runtimeAnimation = options.runtimeAnimation;\n  const runtimeNode = options.runtimeNode;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.channel\", channel);\n  Check.typeOf.object(\"options.runtimeAnimation\", runtimeAnimation);\n  Check.typeOf.object(\"options.runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  this._channel = channel;\n  this._runtimeAnimation = runtimeAnimation;\n  this._runtimeNode = runtimeNode;\n\n  // An animation channel can have multiple splines if it animates\n  // a node's morph weights, which will involve multiple morph targets.\n  this._splines = [];\n  this._path = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelAnimationChannel.prototype, {\n  /**\n   * The glTF animation channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelComponents.AnimationChannel}\n   * @readonly\n   *\n   * @private\n   */\n  channel: {\n    get: function () {\n      return this._channel;\n    },\n  },\n\n  /**\n   * The runtime animation that owns this channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelAnimation}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeAnimation: {\n    get: function () {\n      return this._runtimeAnimation;\n    },\n  },\n\n  /**\n   * The runtime node that this channel animates.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {ModelRuntimeNode}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeNode: {\n    get: function () {\n      return this._runtimeNode;\n    },\n  },\n\n  /**\n   * The splines used to evaluate this animation channel.\n   *\n   * @memberof ModelAnimationChannel.prototype\n   *\n   * @type {Spline[]}\n   * @readonly\n   *\n   * @private\n   */\n  splines: {\n    get: function () {\n      return this._splines;\n    },\n  },\n});\n\nfunction createCubicSpline(times, points) {\n  const cubicPoints = [];\n  const inTangents = [];\n  const outTangents = [];\n\n  const length = points.length;\n  for (let i = 0; i < length; i += 3) {\n    inTangents.push(points[i]);\n    cubicPoints.push(points[i + 1]);\n    outTangents.push(points[i + 2]);\n  }\n\n  // Remove the first in-tangent and last out-tangent, since they\n  // are not used in the spline calculations\n  inTangents.splice(0, 1);\n  outTangents.length = outTangents.length - 1;\n\n  return new HermiteSpline({\n    times: times,\n    points: cubicPoints,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n}\n\nfunction createSpline(times, points, interpolation, path) {\n  if (times.length === 1 && points.length === 1) {\n    return new ConstantSpline(points[0]);\n  }\n\n  switch (interpolation) {\n    case InterpolationType.STEP:\n      return new SteppedSpline({\n        times: times,\n        points: points,\n      });\n    case InterpolationType.CUBICSPLINE:\n      return createCubicSpline(times, points);\n    case InterpolationType.LINEAR:\n      if (path === AnimatedPropertyType.ROTATION) {\n        return new QuaternionSpline({\n          times: times,\n          points: points,\n        });\n      }\n      return new LinearSpline({\n        times: times,\n        points: points,\n      });\n  }\n}\n\nfunction createSplines(times, points, interpolation, path, count) {\n  const splines = [];\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const pointsLength = points.length;\n    // Get the number of keyframes in each weight's output.\n    const outputLength = pointsLength / count;\n\n    // Iterate over the array using the number of morph targets in the model.\n    let targetIndex, i;\n    for (targetIndex = 0; targetIndex < count; targetIndex++) {\n      const output = new Array(outputLength);\n\n      // Weights are ordered such that they are keyframed in the order in which\n      // their targets appear the glTF. For example, the weights of three targets\n      // may appear as [w(0,0), w(0,1), w(0,2), w(1,0), w(1,1), w(1,2) ...],\n      // where i and j in w(i,j) are the time indices and target indices, respectively.\n\n      // However, for morph targets with cubic interpolation, the data is stored per\n      // keyframe in the order [a1, a2, ..., an, v1, v2, ... vn, b1, b2, ..., bn],\n      // where ai, vi, and bi are the in-tangent, property, and out-tangents of\n      // the ith morph target respectively.\n      let pointsIndex = targetIndex;\n      if (interpolation === InterpolationType.CUBICSPLINE) {\n        for (i = 0; i < outputLength; i += 3) {\n          output[i] = points[pointsIndex];\n          output[i + 1] = points[pointsIndex + count];\n          output[i + 2] = points[pointsIndex + 2 * count];\n          pointsIndex += count * 3;\n        }\n      } else {\n        for (i = 0; i < outputLength; i++) {\n          output[i] = points[pointsIndex];\n          pointsIndex += count;\n        }\n      }\n\n      splines.push(createSpline(times, output, interpolation, path));\n    }\n  } else {\n    splines.push(createSpline(times, points, interpolation, path));\n  }\n\n  return splines;\n}\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchQuaternion = new Quaternion();\n\nfunction initialize(runtimeChannel) {\n  const channel = runtimeChannel._channel;\n\n  const sampler = channel.sampler;\n  const times = sampler.input;\n  const points = sampler.output;\n\n  const interpolation = sampler.interpolation;\n  const target = channel.target;\n  const path = target.path;\n\n  const runtimeNode = runtimeChannel._runtimeNode;\n  const count = defined(runtimeNode.morphWeights)\n    ? runtimeNode.morphWeights.length\n    : 1;\n  const splines = createSplines(times, points, interpolation, path, count);\n\n  runtimeChannel._splines = splines;\n  runtimeChannel._path = path;\n}\n\n/**\n * Animates the target node property based on its spline.\n *\n * @param {number} time The local animation time.\n *\n * @private\n */\nModelAnimationChannel.prototype.animate = function (time) {\n  const splines = this._splines;\n  const path = this._path;\n  const model = this._runtimeAnimation.model;\n  const runtimeNode = this._runtimeNode;\n\n  // Weights are handled differently than the other properties because\n  // they need to be updated in place.\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const morphWeights = runtimeNode.morphWeights;\n    const length = morphWeights.length;\n    for (let i = 0; i < length; i++) {\n      const spline = splines[i];\n      const localAnimationTime = model.clampAnimations\n        ? spline.clampTime(time)\n        : spline.wrapTime(time);\n      morphWeights[i] = spline.evaluate(localAnimationTime);\n    }\n  } else if (runtimeNode.userAnimated) {\n    // If the node is being animated externally, ignore the glTF animation.\n    return;\n  } else {\n    const spline = splines[0];\n    const localAnimationTime = model.clampAnimations\n      ? spline.clampTime(time)\n      : spline.wrapTime(time);\n\n    // This sets the translate, rotate, and scale properties.\n    if (\n      path === AnimatedPropertyType.TRANSLATION ||\n      path === AnimatedPropertyType.SCALE\n    ) {\n      runtimeNode[path] = spline.evaluate(\n        localAnimationTime,\n        scratchCartesian3,\n      );\n    } else if (path === AnimatedPropertyType.ROTATION) {\n      runtimeNode[path] = spline.evaluate(\n        localAnimationTime,\n        scratchQuaternion,\n      );\n    }\n  }\n};\n\nexport default ModelAnimationChannel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}