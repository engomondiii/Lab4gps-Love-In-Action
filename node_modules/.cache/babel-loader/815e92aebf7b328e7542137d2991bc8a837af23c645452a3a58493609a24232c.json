{"ast":null,"code":"import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nconst scratchInterpolateColorsArray = [];\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  const colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  let i;\n  const r0 = color0.red;\n  const g0 = color0.green;\n  const b0 = color0.blue;\n  const a0 = color0.alpha;\n  const r1 = color1.red;\n  const g1 = color1.green;\n  const b1 = color1.blue;\n  const a1 = color1.alpha;\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n    return colors;\n  }\n  const redPerVertex = (r1 - r0) / numPoints;\n  const greenPerVertex = (g1 - g0) / numPoints;\n  const bluePerVertex = (b1 - b0) / numPoints;\n  const alphaPerVertex = (a1 - a0) / numPoints;\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);\n  }\n  return colors;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * const polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\nfunction PolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const colors = options.colors;\n  const width = defaultValue(options.width, 1.0);\n  const colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n  if (defined(colors) && (colorsPerVertex && colors.length < positions.length || !colorsPerVertex && colors.length < positions.length - 1)) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.default));\n  this._workerName = \"createPolylineGeometry\";\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  let i;\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  const colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  let i;\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  length = array[startingIndex++];\n  const colors = length > 0 ? new Array(length) : undefined;\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const width = array[startingIndex++];\n  const colorsPerVertex = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const granularity = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n  return result;\n};\nconst scratchCartesian3 = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nconst scratchPrevPosition = new Cartesian3();\nconst scratchNextPosition = new Cartesian3();\n\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  const width = polylineGeometry._width;\n  const vertexFormat = polylineGeometry._vertexFormat;\n  let colors = polylineGeometry._colors;\n  const colorsPerVertex = polylineGeometry._colorsPerVertex;\n  const arcType = polylineGeometry._arcType;\n  const granularity = polylineGeometry._granularity;\n  const ellipsoid = polylineGeometry._ellipsoid;\n  let i;\n  let j;\n  let k;\n  const removedIndices = [];\n  let positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon, false, removedIndices);\n  if (defined(colors) && removedIndices.length > 0) {\n    let removedArrayIndex = 0;\n    let nextRemovedIndex = removedIndices[0];\n    colors = colors.filter(function (color, index) {\n      let remove = false;\n      if (colorsPerVertex) {\n        remove = index === nextRemovedIndex || index === 0 && nextRemovedIndex === 1;\n      } else {\n        remove = index + 1 === nextRemovedIndex;\n      }\n      if (remove) {\n        removedArrayIndex++;\n        nextRemovedIndex = removedIndices[removedArrayIndex];\n        return false;\n      }\n      return true;\n    });\n  }\n  let positionsLength = positions.length;\n\n  // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    let subdivisionSize;\n    let numberOfPointsFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n    if (defined(colors)) {\n      let colorLength = 1;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);\n      }\n      const newColors = new Array(colorLength);\n      let newColorIndex = 0;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        const p0 = positions[i];\n        const p1 = positions[i + 1];\n        const c0 = colors[i];\n        const numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n        if (colorsPerVertex && i < colorLength) {\n          const c1 = colors[i + 1];\n          const interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n          const interpolatedColorsLength = interpolatedColors.length;\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n      scratchInterpolateColorsArray.length = 0;\n    }\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights\n      });\n    }\n  }\n  positionsLength = positions.length;\n  const size = positionsLength * 4.0 - 4.0;\n  const finalPositions = new Float64Array(size * 3);\n  const prevPositions = new Float64Array(size * 3);\n  const nextPositions = new Float64Array(size * 3);\n  const expandAndWidth = new Float32Array(size * 2);\n  const st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  const finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n  let positionIndex = 0;\n  let expandAndWidthIndex = 0;\n  let stIndex = 0;\n  let colorIndex = 0;\n  let position;\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n    Cartesian3.clone(position, scratchNextPosition);\n    let color0, color1;\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n    const startK = j === 0 ? 2 : 0;\n    const endK = j === positionsLength - 1 ? 2 : 4;\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n      const direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n      if (defined(finalColors)) {\n        const color = k < 2 ? color0 : color1;\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions\n  });\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions\n  });\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions\n  });\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth\n  });\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st\n    });\n  }\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true\n    });\n  }\n  const indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  let index = 0;\n  let indicesIndex = 0;\n  const length = positionsLength - 1.0;\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n    index += 4;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES\n  });\n};\nexport default PolylineGeometry;","map":{"version":3,"names":["ArcType","arrayRemoveDuplicates","BoundingSphere","Cartesian3","Color","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryType","IndexDatatype","CesiumMath","PolylinePipeline","PrimitiveType","VertexFormat","scratchInterpolateColorsArray","interpolateColors","p0","p1","color0","color1","numPoints","colors","length","i","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","equals","clone","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","options","EMPTY_OBJECT","positions","width","colorsPerVertex","_positions","_colors","_width","_colorsPerVertex","_vertexFormat","vertexFormat","DEFAULT","_arcType","arcType","GEODESIC","_granularity","granularity","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","default","_workerName","numComponents","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","undefined","unpack","result","Array","scratchCartesian3","scratchPosition","scratchPrevPosition","scratchNextPosition","createGeometry","polylineGeometry","j","k","removedIndices","equalsEpsilon","removedArrayIndex","nextRemovedIndex","filter","color","index","remove","positionsLength","RHUMB","subdivisionSize","numberOfPointsFunction","chordLength","maximumRadius","numberOfPoints","numberOfPointsRhumbLine","heights","extractHeights","colorLength","newColors","newColorIndex","c0","numColors","c1","interpolatedColors","interpolatedColorsLength","generateCartesianArc","minDistance","height","generateCartesianRhumbArc","size","finalPositions","Float64Array","prevPositions","nextPositions","expandAndWidth","Float32Array","st","finalColors","Uint8Array","positionIndex","expandAndWidthIndex","stIndex","colorIndex","position","subtract","add","startK","endK","direction","Math","max","floatToByte","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","prevPosition","nextPosition","FLOAT","UNSIGNED_BYTE","normalize","indices","createTypedArray","indicesIndex","primitiveType","TRIANGLES","boundingSphere","fromPoints","geometryType","POLYLINES"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/PolylineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchInterpolateColorsArray = [];\n\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  const colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  let i;\n\n  const r0 = color0.red;\n  const g0 = color0.green;\n  const b0 = color0.blue;\n  const a0 = color0.alpha;\n\n  const r1 = color1.red;\n  const g1 = color1.green;\n  const b1 = color1.blue;\n  const a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n    return colors;\n  }\n\n  const redPerVertex = (r1 - r0) / numPoints;\n  const greenPerVertex = (g1 - g0) / numPoints;\n  const bluePerVertex = (b1 - b0) / numPoints;\n  const alphaPerVertex = (a1 - a0) / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(\n      r0 + i * redPerVertex,\n      g0 + i * greenPerVertex,\n      b0 + i * bluePerVertex,\n      a0 + i * alphaPerVertex,\n    );\n  }\n\n  return colors;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * const polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\nfunction PolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const colors = options.colors;\n  const width = defaultValue(options.width, 1.0);\n  const colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT),\n  );\n\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.default),\n  );\n  this._workerName = \"createPolylineGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const width = array[startingIndex++];\n  const colorsPerVertex = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nconst scratchPrevPosition = new Cartesian3();\nconst scratchNextPosition = new Cartesian3();\n\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  const width = polylineGeometry._width;\n  const vertexFormat = polylineGeometry._vertexFormat;\n  let colors = polylineGeometry._colors;\n  const colorsPerVertex = polylineGeometry._colorsPerVertex;\n  const arcType = polylineGeometry._arcType;\n  const granularity = polylineGeometry._granularity;\n  const ellipsoid = polylineGeometry._ellipsoid;\n\n  let i;\n  let j;\n  let k;\n\n  const removedIndices = [];\n  let positions = arrayRemoveDuplicates(\n    polylineGeometry._positions,\n    Cartesian3.equalsEpsilon,\n    false,\n    removedIndices,\n  );\n\n  if (defined(colors) && removedIndices.length > 0) {\n    let removedArrayIndex = 0;\n    let nextRemovedIndex = removedIndices[0];\n    colors = colors.filter(function (color, index) {\n      let remove = false;\n      if (colorsPerVertex) {\n        remove =\n          index === nextRemovedIndex || (index === 0 && nextRemovedIndex === 1);\n      } else {\n        remove = index + 1 === nextRemovedIndex;\n      }\n\n      if (remove) {\n        removedArrayIndex++;\n        nextRemovedIndex = removedIndices[removedArrayIndex];\n        return false;\n      }\n      return true;\n    });\n  }\n\n  let positionsLength = positions.length;\n\n  // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    let subdivisionSize;\n    let numberOfPointsFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius,\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    if (defined(colors)) {\n      let colorLength = 1;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(\n          positions[i],\n          positions[i + 1],\n          subdivisionSize,\n        );\n      }\n\n      const newColors = new Array(colorLength);\n      let newColorIndex = 0;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        const p0 = positions[i];\n        const p1 = positions[i + 1];\n        const c0 = colors[i];\n\n        const numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n        if (colorsPerVertex && i < colorLength) {\n          const c1 = colors[i + 1];\n          const interpolatedColors = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            numColors,\n          );\n          const interpolatedColorsLength = interpolatedColors.length;\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n\n      scratchInterpolateColorsArray.length = 0;\n    }\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    }\n  }\n\n  positionsLength = positions.length;\n  const size = positionsLength * 4.0 - 4.0;\n\n  const finalPositions = new Float64Array(size * 3);\n  const prevPositions = new Float64Array(size * 3);\n  const nextPositions = new Float64Array(size * 3);\n  const expandAndWidth = new Float32Array(size * 2);\n  const st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  const finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n  let positionIndex = 0;\n  let expandAndWidthIndex = 0;\n  let stIndex = 0;\n  let colorIndex = 0;\n  let position;\n\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(\n        positions[positionsLength - 1],\n        positions[positionsLength - 2],\n        position,\n      );\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n\n    Cartesian3.clone(position, scratchNextPosition);\n\n    let color0, color1;\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n\n    const startK = j === 0 ? 2 : 0;\n    const endK = j === positionsLength - 1 ? 2 : 4;\n\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n\n      const direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n\n      if (defined(finalColors)) {\n        const color = k < 2 ? color0 : color1;\n\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions,\n  });\n\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions,\n  });\n\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth,\n  });\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true,\n    });\n  }\n\n  const indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  let index = 0;\n  let indicesIndex = 0;\n  const length = positionsLength - 1.0;\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n\n    index += 4;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES,\n  });\n};\nexport default PolylineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}