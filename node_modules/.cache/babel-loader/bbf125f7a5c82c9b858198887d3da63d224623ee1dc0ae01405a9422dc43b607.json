{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * Stores details about a tile of imagery.\n *\n * @alias Imagery\n * @private\n */\nfunction Imagery(imageryLayer, x, y, level, rectangle) {\n  this.imageryLayer = imageryLayer;\n  this.x = x;\n  this.y = y;\n  this.level = level;\n  this.request = undefined;\n  if (level !== 0) {\n    const parentX = x / 2 | 0;\n    const parentY = y / 2 | 0;\n    const parentLevel = level - 1;\n    this.parent = imageryLayer.getImageryFromCache(parentX, parentY, parentLevel);\n  }\n  this.state = ImageryState.UNLOADED;\n  this.imageUrl = undefined;\n  this.image = undefined;\n  this.texture = undefined;\n  this.textureWebMercator = undefined;\n  this.credits = undefined;\n  this.referenceCount = 0;\n  if (!defined(rectangle) && imageryLayer.ready) {\n    const tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n    rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  }\n  this.rectangle = rectangle;\n}\nImagery.createPlaceholder = function (imageryLayer) {\n  const result = new Imagery(imageryLayer, 0, 0, 0);\n  result.addReference();\n  result.state = ImageryState.PLACEHOLDER;\n  return result;\n};\nImagery.prototype.addReference = function () {\n  ++this.referenceCount;\n};\nImagery.prototype.releaseReference = function () {\n  --this.referenceCount;\n  if (this.referenceCount === 0) {\n    this.imageryLayer.removeImageryFromCache(this);\n    if (defined(this.parent)) {\n      this.parent.releaseReference();\n    }\n    if (defined(this.image) && defined(this.image.destroy)) {\n      this.image.destroy();\n    }\n    if (defined(this.texture)) {\n      this.texture.destroy();\n    }\n    if (defined(this.textureWebMercator) && this.texture !== this.textureWebMercator) {\n      this.textureWebMercator.destroy();\n    }\n    destroyObject(this);\n    return 0;\n  }\n  return this.referenceCount;\n};\nImagery.prototype.processStateMachine = function (frameState, needGeographicProjection, skipLoading) {\n  if (this.state === ImageryState.UNLOADED && !skipLoading) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._requestImagery(this);\n  }\n  if (this.state === ImageryState.RECEIVED) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._createTexture(frameState.context, this);\n  }\n\n  // If the imagery is already ready, but we need a geographic version and don't have it yet,\n  // we still need to do the reprojection step. This can happen if the Web Mercator version\n  // is fine initially, but the geographic one is needed later.\n  const needsReprojection = this.state === ImageryState.READY && needGeographicProjection && !this.texture;\n  if (this.state === ImageryState.TEXTURE_LOADED || needsReprojection) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._reprojectTexture(frameState, this, needGeographicProjection);\n  }\n};\nexport default Imagery;","map":{"version":3,"names":["defined","destroyObject","ImageryState","Imagery","imageryLayer","x","y","level","rectangle","request","undefined","parentX","parentY","parentLevel","parent","getImageryFromCache","state","UNLOADED","imageUrl","image","texture","textureWebMercator","credits","referenceCount","ready","tilingScheme","imageryProvider","tileXYToRectangle","createPlaceholder","result","addReference","PLACEHOLDER","prototype","releaseReference","removeImageryFromCache","destroy","processStateMachine","frameState","needGeographicProjection","skipLoading","TRANSITIONING","_requestImagery","RECEIVED","_createTexture","context","needsReprojection","READY","TEXTURE_LOADED","_reprojectTexture"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Imagery.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * Stores details about a tile of imagery.\n *\n * @alias Imagery\n * @private\n */\nfunction Imagery(imageryLayer, x, y, level, rectangle) {\n  this.imageryLayer = imageryLayer;\n  this.x = x;\n  this.y = y;\n  this.level = level;\n  this.request = undefined;\n\n  if (level !== 0) {\n    const parentX = (x / 2) | 0;\n    const parentY = (y / 2) | 0;\n    const parentLevel = level - 1;\n    this.parent = imageryLayer.getImageryFromCache(\n      parentX,\n      parentY,\n      parentLevel,\n    );\n  }\n\n  this.state = ImageryState.UNLOADED;\n  this.imageUrl = undefined;\n  this.image = undefined;\n  this.texture = undefined;\n  this.textureWebMercator = undefined;\n  this.credits = undefined;\n  this.referenceCount = 0;\n\n  if (!defined(rectangle) && imageryLayer.ready) {\n    const tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n    rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  }\n\n  this.rectangle = rectangle;\n}\nImagery.createPlaceholder = function (imageryLayer) {\n  const result = new Imagery(imageryLayer, 0, 0, 0);\n  result.addReference();\n  result.state = ImageryState.PLACEHOLDER;\n  return result;\n};\n\nImagery.prototype.addReference = function () {\n  ++this.referenceCount;\n};\n\nImagery.prototype.releaseReference = function () {\n  --this.referenceCount;\n\n  if (this.referenceCount === 0) {\n    this.imageryLayer.removeImageryFromCache(this);\n\n    if (defined(this.parent)) {\n      this.parent.releaseReference();\n    }\n\n    if (defined(this.image) && defined(this.image.destroy)) {\n      this.image.destroy();\n    }\n\n    if (defined(this.texture)) {\n      this.texture.destroy();\n    }\n\n    if (\n      defined(this.textureWebMercator) &&\n      this.texture !== this.textureWebMercator\n    ) {\n      this.textureWebMercator.destroy();\n    }\n\n    destroyObject(this);\n\n    return 0;\n  }\n\n  return this.referenceCount;\n};\n\nImagery.prototype.processStateMachine = function (\n  frameState,\n  needGeographicProjection,\n  skipLoading,\n) {\n  if (this.state === ImageryState.UNLOADED && !skipLoading) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._requestImagery(this);\n  }\n\n  if (this.state === ImageryState.RECEIVED) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._createTexture(frameState.context, this);\n  }\n\n  // If the imagery is already ready, but we need a geographic version and don't have it yet,\n  // we still need to do the reprojection step. This can happen if the Web Mercator version\n  // is fine initially, but the geographic one is needed later.\n  const needsReprojection =\n    this.state === ImageryState.READY &&\n    needGeographicProjection &&\n    !this.texture;\n\n  if (this.state === ImageryState.TEXTURE_LOADED || needsReprojection) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._reprojectTexture(\n      frameState,\n      this,\n      needGeographicProjection,\n    );\n  }\n};\nexport default Imagery;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}