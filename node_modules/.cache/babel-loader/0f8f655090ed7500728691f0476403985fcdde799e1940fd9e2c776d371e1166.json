{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PropertyTable from \"./PropertyTable.js\";\nimport PropertyTexture from \"./PropertyTexture.js\";\nimport StructuralMetadata from \"./StructuralMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\n\n/**\n * Parse the <code>EXT_feature_metadata</code> glTF extension to create a\n * structural metadata object.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The extension JSON object.\n * @param {MetadataSchema} options.schema The parsed schema.\n * @param {Object<string, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n * @param {Object<string, Texture>} [options.textures] An object mapping texture IDs to {@link Texture} objects.\n * @return {StructuralMetadata} A structural metadata object\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction parseFeatureMetadataLegacy(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const extension = options.extension;\n\n  // The calling code is responsible for loading the schema.\n  // This keeps metadata parsing synchronous.\n  const schema = options.schema;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.schema\", schema);\n  //>>includeEnd('debug');\n\n  let i;\n  const propertyTables = [];\n  let sortedIds;\n  if (defined(extension.featureTables)) {\n    // Store textures in an array sorted by the dictionary keys. This\n    // allows compatibility with the newer EXT_structural_metadata extension\n    // which is array-based.\n    sortedIds = Object.keys(extension.featureTables).sort();\n    for (i = 0; i < sortedIds.length; i++) {\n      const featureTableId = sortedIds[i];\n      const featureTable = extension.featureTables[featureTableId];\n      const classDefinition = schema.classes[featureTable.class];\n      const metadataTable = new MetadataTable({\n        count: featureTable.count,\n        properties: featureTable.properties,\n        class: classDefinition,\n        bufferViews: options.bufferViews\n      });\n      propertyTables.push(new PropertyTable({\n        id: featureTableId,\n        count: featureTable.count,\n        metadataTable: metadataTable,\n        extras: featureTable.extras,\n        extensions: featureTable.extensions\n      }));\n    }\n  }\n  const propertyTextures = [];\n  if (defined(extension.featureTextures)) {\n    // Store textures in an array sorted by the dictionary keys. This\n    // allows compatibility with the newer EXT_structural_metadata extension\n    // which is array-based.\n    sortedIds = Object.keys(extension.featureTextures).sort();\n    for (i = 0; i < sortedIds.length; i++) {\n      const featureTextureId = sortedIds[i];\n      const featureTexture = extension.featureTextures[featureTextureId];\n      propertyTextures.push(new PropertyTexture({\n        id: featureTextureId,\n        propertyTexture: transcodeToPropertyTexture(featureTexture),\n        class: schema.classes[featureTexture.class],\n        textures: options.textures\n      }));\n    }\n  }\n  return new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n    propertyTextures: propertyTextures,\n    statistics: extension.statistics,\n    extras: extension.extras,\n    extensions: extension.extensions\n  });\n}\nfunction transcodeToPropertyTexture(featureTexture) {\n  const propertyTexture = {\n    class: featureTexture.class,\n    properties: {}\n  };\n  const properties = featureTexture.properties;\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const oldProperty = properties[propertyId];\n      const property = {\n        // EXT_structural_metadata uses numeric channel indices instead of\n        // a string of channel letters like \"rgba\".\n        channels: reformatChannels(oldProperty.channels),\n        extras: oldProperty.extras,\n        extensions: oldProperty.extensions\n      };\n\n      // EXT_feature_metadata puts the textureInfo in property.texture.\n      // EXT_structural_metadata flattens this structure; essentially a\n      // textureInfo + channels\n      propertyTexture.properties[propertyId] = combine(oldProperty.texture, property, true);\n    }\n  }\n  return propertyTexture;\n}\nfunction reformatChannels(channelsString) {\n  const length = channelsString.length;\n  const result = new Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = \"rgba\".indexOf(channelsString[i]);\n  }\n  return result;\n}\nexport default parseFeatureMetadataLegacy;","map":{"version":3,"names":["Check","combine","defaultValue","defined","PropertyTable","PropertyTexture","StructuralMetadata","MetadataTable","parseFeatureMetadataLegacy","options","EMPTY_OBJECT","extension","schema","typeOf","object","i","propertyTables","sortedIds","featureTables","Object","keys","sort","length","featureTableId","featureTable","classDefinition","classes","class","metadataTable","count","properties","bufferViews","push","id","extras","extensions","propertyTextures","featureTextures","featureTextureId","featureTexture","propertyTexture","transcodeToPropertyTexture","textures","statistics","propertyId","hasOwnProperty","oldProperty","property","channels","reformatChannels","texture","channelsString","result","Array","indexOf"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/parseFeatureMetadataLegacy.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PropertyTable from \"./PropertyTable.js\";\nimport PropertyTexture from \"./PropertyTexture.js\";\nimport StructuralMetadata from \"./StructuralMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\n\n/**\n * Parse the <code>EXT_feature_metadata</code> glTF extension to create a\n * structural metadata object.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The extension JSON object.\n * @param {MetadataSchema} options.schema The parsed schema.\n * @param {Object<string, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n * @param {Object<string, Texture>} [options.textures] An object mapping texture IDs to {@link Texture} objects.\n * @return {StructuralMetadata} A structural metadata object\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction parseFeatureMetadataLegacy(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const extension = options.extension;\n\n  // The calling code is responsible for loading the schema.\n  // This keeps metadata parsing synchronous.\n  const schema = options.schema;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", extension);\n  Check.typeOf.object(\"options.schema\", schema);\n  //>>includeEnd('debug');\n\n  let i;\n  const propertyTables = [];\n  let sortedIds;\n  if (defined(extension.featureTables)) {\n    // Store textures in an array sorted by the dictionary keys. This\n    // allows compatibility with the newer EXT_structural_metadata extension\n    // which is array-based.\n    sortedIds = Object.keys(extension.featureTables).sort();\n    for (i = 0; i < sortedIds.length; i++) {\n      const featureTableId = sortedIds[i];\n      const featureTable = extension.featureTables[featureTableId];\n      const classDefinition = schema.classes[featureTable.class];\n\n      const metadataTable = new MetadataTable({\n        count: featureTable.count,\n        properties: featureTable.properties,\n        class: classDefinition,\n        bufferViews: options.bufferViews,\n      });\n\n      propertyTables.push(\n        new PropertyTable({\n          id: featureTableId,\n          count: featureTable.count,\n          metadataTable: metadataTable,\n          extras: featureTable.extras,\n          extensions: featureTable.extensions,\n        }),\n      );\n    }\n  }\n\n  const propertyTextures = [];\n  if (defined(extension.featureTextures)) {\n    // Store textures in an array sorted by the dictionary keys. This\n    // allows compatibility with the newer EXT_structural_metadata extension\n    // which is array-based.\n    sortedIds = Object.keys(extension.featureTextures).sort();\n    for (i = 0; i < sortedIds.length; i++) {\n      const featureTextureId = sortedIds[i];\n      const featureTexture = extension.featureTextures[featureTextureId];\n      propertyTextures.push(\n        new PropertyTexture({\n          id: featureTextureId,\n          propertyTexture: transcodeToPropertyTexture(featureTexture),\n          class: schema.classes[featureTexture.class],\n          textures: options.textures,\n        }),\n      );\n    }\n  }\n\n  return new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n    propertyTextures: propertyTextures,\n    statistics: extension.statistics,\n    extras: extension.extras,\n    extensions: extension.extensions,\n  });\n}\n\nfunction transcodeToPropertyTexture(featureTexture) {\n  const propertyTexture = {\n    class: featureTexture.class,\n    properties: {},\n  };\n\n  const properties = featureTexture.properties;\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const oldProperty = properties[propertyId];\n      const property = {\n        // EXT_structural_metadata uses numeric channel indices instead of\n        // a string of channel letters like \"rgba\".\n        channels: reformatChannels(oldProperty.channels),\n        extras: oldProperty.extras,\n        extensions: oldProperty.extensions,\n      };\n\n      // EXT_feature_metadata puts the textureInfo in property.texture.\n      // EXT_structural_metadata flattens this structure; essentially a\n      // textureInfo + channels\n      propertyTexture.properties[propertyId] = combine(\n        oldProperty.texture,\n        property,\n        true,\n      );\n    }\n  }\n\n  return propertyTexture;\n}\n\nfunction reformatChannels(channelsString) {\n  const length = channelsString.length;\n  const result = new Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = \"rgba\".indexOf(channelsString[i]);\n  }\n  return result;\n}\n\nexport default parseFeatureMetadataLegacy;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}