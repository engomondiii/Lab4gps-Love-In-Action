{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JobType from \"./JobType.js\";\n\n/**\n *\n * @private\n * @constructor\n */\nfunction JobTypeBudget(total) {\n  /**\n   * Total budget, in milliseconds, allowed for one frame\n   */\n  this._total = total;\n\n  /**\n   * Time, in milliseconds, used so far during this frame\n   */\n  this.usedThisFrame = 0.0;\n\n  /**\n   * Time, in milliseconds, that other job types stole this frame\n   */\n  this.stolenFromMeThisFrame = 0.0;\n\n  /**\n   * Indicates if this job type was starved this frame, i.e., a job\n   * tried to run but didn't have budget\n   */\n  this.starvedThisFrame = false;\n\n  /**\n   * Indicates if this job was starved last frame.  This prevents it\n   * from being stolen from this frame.\n   */\n  this.starvedLastFrame = false;\n}\nObject.defineProperties(JobTypeBudget.prototype, {\n  total: {\n    get: function () {\n      return this._total;\n    }\n  }\n});\n\n/**\n * Engine for time slicing jobs during a frame to amortize work over multiple frames.  This supports:\n * <ul>\n *   <li>\n *     Separate budgets for different job types, e.g., texture, shader program, and buffer creation.  This\n *     allows all job types to make progress each frame.\n *   </li>\n *   <li>\n *     Stealing from other jobs type budgets if they were not exhausted in the previous frame.  This allows\n *     using the entire budget for all job types each frame even if, for example, all the jobs are the same type.\n *   </li>\n *   <li>\n *     Guaranteed progress on all job types each frame, even if it means exceeding the total budget for the frame.\n *     This prevents, for example, several expensive texture uploads over many frames from prevent a shader compile.\n *   </li>\n * </ul>\n *\n * @private\n */\nfunction JobScheduler(budgets) {\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(budgets) && budgets.length !== JobType.NUMBER_OF_JOB_TYPES) {\n    throw new DeveloperError(\"A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.\");\n  }\n  //>>includeEnd('debug');\n\n  // Total for defaults is half of of one frame at 10 fps\n  const jobBudgets = new Array(JobType.NUMBER_OF_JOB_TYPES);\n  jobBudgets[JobType.TEXTURE] = new JobTypeBudget(defined(budgets) ? budgets[JobType.TEXTURE] : 10.0);\n  // On cache miss, this most likely only allows one shader compile per frame\n  jobBudgets[JobType.PROGRAM] = new JobTypeBudget(defined(budgets) ? budgets[JobType.PROGRAM] : 10.0);\n  jobBudgets[JobType.BUFFER] = new JobTypeBudget(defined(budgets) ? budgets[JobType.BUFFER] : 30.0);\n  const length = jobBudgets.length;\n  let i;\n  let totalBudget = 0.0;\n  for (i = 0; i < length; ++i) {\n    totalBudget += jobBudgets[i].total;\n  }\n  const executedThisFrame = new Array(length);\n  for (i = 0; i < length; ++i) {\n    executedThisFrame[i] = false;\n  }\n  this._totalBudget = totalBudget;\n  this._totalUsedThisFrame = 0.0;\n  this._budgets = jobBudgets;\n  this._executedThisFrame = executedThisFrame;\n}\n\n// For unit testing\nJobScheduler.getTimestamp = getTimestamp;\nObject.defineProperties(JobScheduler.prototype, {\n  totalBudget: {\n    get: function () {\n      return this._totalBudget;\n    }\n  }\n});\nJobScheduler.prototype.disableThisFrame = function () {\n  // Prevent jobs from running this frame\n  this._totalUsedThisFrame = this._totalBudget;\n};\nJobScheduler.prototype.resetBudgets = function () {\n  const budgets = this._budgets;\n  const length = budgets.length;\n  for (let i = 0; i < length; ++i) {\n    const budget = budgets[i];\n    budget.starvedLastFrame = budget.starvedThisFrame;\n    budget.starvedThisFrame = false;\n    budget.usedThisFrame = 0.0;\n    budget.stolenFromMeThisFrame = 0.0;\n  }\n  this._totalUsedThisFrame = 0.0;\n};\nJobScheduler.prototype.execute = function (job, jobType) {\n  const budgets = this._budgets;\n  const budget = budgets[jobType];\n\n  // This ensures each job type makes progress each frame by executing at least once\n  const progressThisFrame = this._executedThisFrame[jobType];\n  if (this._totalUsedThisFrame >= this._totalBudget && progressThisFrame) {\n    // No budget left this frame for jobs of any type\n    budget.starvedThisFrame = true;\n    return false;\n  }\n  let stolenBudget;\n  if (budget.usedThisFrame + budget.stolenFromMeThisFrame >= budget.total) {\n    // No budget remaining for jobs of this type. Try to steal from other job types.\n    const length = budgets.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      stolenBudget = budgets[i];\n\n      // Steal from this budget if it has time left and it wasn't starved last fame\n      if (stolenBudget.usedThisFrame + stolenBudget.stolenFromMeThisFrame < stolenBudget.total && !stolenBudget.starvedLastFrame) {\n        break;\n      }\n    }\n    if (i === length && progressThisFrame) {\n      // No other job types can give up their budget this frame, and\n      // this job type already progressed this frame\n      return false;\n    }\n    if (progressThisFrame) {\n      // It is considered \"starved\" even if it executes using stolen time so that\n      // next frame, no other job types can steal time from it.\n      budget.starvedThisFrame = true;\n    }\n  }\n  const startTime = JobScheduler.getTimestamp();\n  job.execute();\n  const duration = JobScheduler.getTimestamp() - startTime;\n\n  // Track both time remaining for this job type and all jobs\n  // so budget stealing does send us way over the total budget.\n  this._totalUsedThisFrame += duration;\n  if (stolenBudget) {\n    stolenBudget.stolenFromMeThisFrame += duration;\n  } else {\n    budget.usedThisFrame += duration;\n  }\n  this._executedThisFrame[jobType] = true;\n  return true;\n};\nexport default JobScheduler;","map":{"version":3,"names":["defined","DeveloperError","getTimestamp","JobType","JobTypeBudget","total","_total","usedThisFrame","stolenFromMeThisFrame","starvedThisFrame","starvedLastFrame","Object","defineProperties","prototype","get","JobScheduler","budgets","length","NUMBER_OF_JOB_TYPES","jobBudgets","Array","TEXTURE","PROGRAM","BUFFER","i","totalBudget","executedThisFrame","_totalBudget","_totalUsedThisFrame","_budgets","_executedThisFrame","disableThisFrame","resetBudgets","budget","execute","job","jobType","progressThisFrame","stolenBudget","startTime","duration"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/JobScheduler.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JobType from \"./JobType.js\";\n\n/**\n *\n * @private\n * @constructor\n */\nfunction JobTypeBudget(total) {\n  /**\n   * Total budget, in milliseconds, allowed for one frame\n   */\n  this._total = total;\n\n  /**\n   * Time, in milliseconds, used so far during this frame\n   */\n  this.usedThisFrame = 0.0;\n\n  /**\n   * Time, in milliseconds, that other job types stole this frame\n   */\n  this.stolenFromMeThisFrame = 0.0;\n\n  /**\n   * Indicates if this job type was starved this frame, i.e., a job\n   * tried to run but didn't have budget\n   */\n  this.starvedThisFrame = false;\n\n  /**\n   * Indicates if this job was starved last frame.  This prevents it\n   * from being stolen from this frame.\n   */\n  this.starvedLastFrame = false;\n}\n\nObject.defineProperties(JobTypeBudget.prototype, {\n  total: {\n    get: function () {\n      return this._total;\n    },\n  },\n});\n\n/**\n * Engine for time slicing jobs during a frame to amortize work over multiple frames.  This supports:\n * <ul>\n *   <li>\n *     Separate budgets for different job types, e.g., texture, shader program, and buffer creation.  This\n *     allows all job types to make progress each frame.\n *   </li>\n *   <li>\n *     Stealing from other jobs type budgets if they were not exhausted in the previous frame.  This allows\n *     using the entire budget for all job types each frame even if, for example, all the jobs are the same type.\n *   </li>\n *   <li>\n *     Guaranteed progress on all job types each frame, even if it means exceeding the total budget for the frame.\n *     This prevents, for example, several expensive texture uploads over many frames from prevent a shader compile.\n *   </li>\n * </ul>\n *\n * @private\n */\nfunction JobScheduler(budgets) {\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(budgets) && budgets.length !== JobType.NUMBER_OF_JOB_TYPES) {\n    throw new DeveloperError(\n      \"A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Total for defaults is half of of one frame at 10 fps\n  const jobBudgets = new Array(JobType.NUMBER_OF_JOB_TYPES);\n  jobBudgets[JobType.TEXTURE] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.TEXTURE] : 10.0,\n  );\n  // On cache miss, this most likely only allows one shader compile per frame\n  jobBudgets[JobType.PROGRAM] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.PROGRAM] : 10.0,\n  );\n  jobBudgets[JobType.BUFFER] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.BUFFER] : 30.0,\n  );\n\n  const length = jobBudgets.length;\n  let i;\n\n  let totalBudget = 0.0;\n  for (i = 0; i < length; ++i) {\n    totalBudget += jobBudgets[i].total;\n  }\n\n  const executedThisFrame = new Array(length);\n  for (i = 0; i < length; ++i) {\n    executedThisFrame[i] = false;\n  }\n\n  this._totalBudget = totalBudget;\n  this._totalUsedThisFrame = 0.0;\n  this._budgets = jobBudgets;\n  this._executedThisFrame = executedThisFrame;\n}\n\n// For unit testing\nJobScheduler.getTimestamp = getTimestamp;\n\nObject.defineProperties(JobScheduler.prototype, {\n  totalBudget: {\n    get: function () {\n      return this._totalBudget;\n    },\n  },\n});\n\nJobScheduler.prototype.disableThisFrame = function () {\n  // Prevent jobs from running this frame\n  this._totalUsedThisFrame = this._totalBudget;\n};\n\nJobScheduler.prototype.resetBudgets = function () {\n  const budgets = this._budgets;\n  const length = budgets.length;\n  for (let i = 0; i < length; ++i) {\n    const budget = budgets[i];\n    budget.starvedLastFrame = budget.starvedThisFrame;\n    budget.starvedThisFrame = false;\n    budget.usedThisFrame = 0.0;\n    budget.stolenFromMeThisFrame = 0.0;\n  }\n  this._totalUsedThisFrame = 0.0;\n};\n\nJobScheduler.prototype.execute = function (job, jobType) {\n  const budgets = this._budgets;\n  const budget = budgets[jobType];\n\n  // This ensures each job type makes progress each frame by executing at least once\n  const progressThisFrame = this._executedThisFrame[jobType];\n\n  if (this._totalUsedThisFrame >= this._totalBudget && progressThisFrame) {\n    // No budget left this frame for jobs of any type\n    budget.starvedThisFrame = true;\n    return false;\n  }\n\n  let stolenBudget;\n\n  if (budget.usedThisFrame + budget.stolenFromMeThisFrame >= budget.total) {\n    // No budget remaining for jobs of this type. Try to steal from other job types.\n    const length = budgets.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      stolenBudget = budgets[i];\n\n      // Steal from this budget if it has time left and it wasn't starved last fame\n      if (\n        stolenBudget.usedThisFrame + stolenBudget.stolenFromMeThisFrame <\n          stolenBudget.total &&\n        !stolenBudget.starvedLastFrame\n      ) {\n        break;\n      }\n    }\n\n    if (i === length && progressThisFrame) {\n      // No other job types can give up their budget this frame, and\n      // this job type already progressed this frame\n      return false;\n    }\n\n    if (progressThisFrame) {\n      // It is considered \"starved\" even if it executes using stolen time so that\n      // next frame, no other job types can steal time from it.\n      budget.starvedThisFrame = true;\n    }\n  }\n\n  const startTime = JobScheduler.getTimestamp();\n  job.execute();\n  const duration = JobScheduler.getTimestamp() - startTime;\n\n  // Track both time remaining for this job type and all jobs\n  // so budget stealing does send us way over the total budget.\n  this._totalUsedThisFrame += duration;\n\n  if (stolenBudget) {\n    stolenBudget.stolenFromMeThisFrame += duration;\n  } else {\n    budget.usedThisFrame += duration;\n  }\n  this._executedThisFrame[jobType] = true;\n\n  return true;\n};\nexport default JobScheduler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}