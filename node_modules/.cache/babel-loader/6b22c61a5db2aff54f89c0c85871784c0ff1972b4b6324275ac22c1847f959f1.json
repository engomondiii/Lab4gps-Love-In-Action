{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See Octree.glsl for the definitions of SampleData and intMod\\n\\\n\\n\\\n/* Megatexture defines (set in Scene/VoxelRenderResources.js)\\n\\\n#define SAMPLE_COUNT ###\\n\\\n#define NEAREST_SAMPLING\\n\\\n#define PADDING\\n\\\n*/\\n\\\n\\n\\\nuniform ivec2 u_megatextureSliceDimensions; // number of slices per tile, in two dimensions\\n\\\nuniform ivec2 u_megatextureTileDimensions; // number of tiles per megatexture, in two dimensions\\n\\\nuniform vec2 u_megatextureVoxelSizeUv;\\n\\\nuniform vec2 u_megatextureSliceSizeUv;\\n\\\nuniform vec2 u_megatextureTileSizeUv;\\n\\\n\\n\\\nuniform ivec3 u_dimensions; // does not include padding\\n\\\n#if defined(PADDING)\\n\\\n    uniform ivec3 u_paddingBefore;\\n\\\n    uniform ivec3 u_paddingAfter;\\n\\\n#endif\\n\\\n\\n\\\n// Integer min, max, clamp: For WebGL1 only\\n\\\nint intMin(int a, int b) {\\n\\\n    return a <= b ? a : b;\\n\\\n}\\n\\\nint intMax(int a, int b) {\\n\\\n    return a >= b ? a : b;\\n\\\n}\\n\\\nint intClamp(int v, int minVal, int maxVal) {\\n\\\n    return intMin(intMax(v, minVal), maxVal);\\n\\\n}\\n\\\n\\n\\\nvec2 index1DTo2DTexcoord(int index, ivec2 dimensions, vec2 uvScale)\\n\\\n{\\n\\\n    int indexX = intMod(index, dimensions.x);\\n\\\n    int indexY = index / dimensions.x;\\n\\\n    return vec2(indexX, indexY) * uvScale;\\n\\\n}\\n\\\n\\n\\\n/*\\n\\\n    How is 3D data stored in a 2D megatexture?\\n\\\n\\n\\\n    In this example there is only one loaded tile and it has 2x2x2 voxels (8 voxels total).\\n\\\n    The data is sliced by Z. The data at Z = 0 is placed in texels (0,0), (0,1), (1,0), (1,1) and\\n\\\n    the data at Z = 1 is placed in texels (2,0), (2,1), (3,0), (3,1).\\n\\\n    Note that there could be empty space in the megatexture because it's a power of two.\\n\\\n\\n\\\n      0   1   2   3\\n\\\n    +---+---+---+---+\\n\\\n    |   |   |   |   | 3\\n\\\n    +---+---+---+---+\\n\\\n    |   |   |   |   | 2\\n\\\n    +-------+-------+\\n\\\n    |010|110|011|111| 1\\n\\\n    |--- ---|--- ---|\\n\\\n    |000|100|001|101| 0\\n\\\n    +-------+-------+\\n\\\n\\n\\\n    When doing linear interpolation the megatexture needs to be sampled twice: once for\\n\\\n    the Z slice above the voxel coordinate and once for the slice below. The two slices\\n\\\n    are interpolated with fract(coord.z - 0.5). For example, a Z coordinate of 1.0 is\\n\\\n    halfway between two Z slices so the interpolation factor is 0.5. Below is a side view\\n\\\n    of the 3D voxel grid with voxel coordinates on the left side.\\n\\\n\\n\\\n    2 +---+\\n\\\n      |001|\\n\\\n    1 +-z-+\\n\\\n      |000|\\n\\\n    0 +---+\\n\\\n\\n\\\n    When doing nearest neighbor the megatexture only needs to be sampled once at the closest Z slice.\\n\\\n*/\\n\\\n\\n\\\nProperties getPropertiesFromMegatexture(in SampleData sampleData) {\\n\\\n    int tileIndex = sampleData.megatextureIndex;\\n\\\n    vec3 voxelCoord = sampleData.tileUv * vec3(u_dimensions);\\n\\\n    ivec3 voxelDimensions = u_dimensions;\\n\\\n\\n\\\n    #if defined(PADDING)\\n\\\n        voxelDimensions += u_paddingBefore + u_paddingAfter;\\n\\\n        voxelCoord += vec3(u_paddingBefore);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(NEAREST_SAMPLING)\\n\\\n        // Round to the center of the nearest voxel\\n\\\n        voxelCoord = floor(voxelCoord) + vec3(0.5);\\n\\\n    #endif\\n\\\n\\n\\\n    // Tile location\\n\\\n    vec2 tileUvOffset = index1DTo2DTexcoord(tileIndex, u_megatextureTileDimensions, u_megatextureTileSizeUv);\\n\\\n\\n\\\n    // Slice location\\n\\\n    float slice = voxelCoord.z - 0.5;\\n\\\n    int sliceIndex = int(floor(slice));\\n\\\n    int sliceIndex0 = intClamp(sliceIndex, 0, voxelDimensions.z - 1);\\n\\\n    vec2 sliceUvOffset0 = index1DTo2DTexcoord(sliceIndex0, u_megatextureSliceDimensions, u_megatextureSliceSizeUv);\\n\\\n\\n\\\n    // Voxel location\\n\\\n    vec2 voxelUvOffset = clamp(voxelCoord.xy, vec2(0.5), vec2(voxelDimensions.xy) - vec2(0.5)) * u_megatextureVoxelSizeUv;\\n\\\n\\n\\\n    // Final location in the megatexture\\n\\\n    vec2 uv0 = tileUvOffset + sliceUvOffset0 + voxelUvOffset;\\n\\\n\\n\\\n    #if defined(NEAREST_SAMPLING)\\n\\\n        return getPropertiesFromMegatextureAtUv(uv0);\\n\\\n    #else\\n\\\n        float sliceLerp = fract(slice);\\n\\\n        int sliceIndex1 = intMin(sliceIndex + 1, voxelDimensions.z - 1);\\n\\\n        vec2 sliceUvOffset1 = index1DTo2DTexcoord(sliceIndex1, u_megatextureSliceDimensions, u_megatextureSliceSizeUv);\\n\\\n        vec2 uv1 = tileUvOffset + sliceUvOffset1 + voxelUvOffset;\\n\\\n        Properties properties0 = getPropertiesFromMegatextureAtUv(uv0);\\n\\\n        Properties properties1 = getPropertiesFromMegatextureAtUv(uv1);\\n\\\n        return mixProperties(properties0, properties1, sliceLerp);\\n\\\n    #endif\\n\\\n}\\n\\\n\\n\\\n// Convert an array of sample datas to a final weighted properties.\\n\\\nProperties accumulatePropertiesFromMegatexture(in SampleData sampleDatas[SAMPLE_COUNT]) {\\n\\\n    #if (SAMPLE_COUNT == 1)\\n\\\n        return getPropertiesFromMegatexture(sampleDatas[0]);\\n\\\n    #else\\n\\\n        // When more than one sample is taken the accumulator needs to start at 0\\n\\\n        Properties properties = clearProperties();\\n\\\n        for (int i = 0; i < SAMPLE_COUNT; ++i) {\\n\\\n            float weight = sampleDatas[i].weight;\\n\\\n\\n\\\n            // Avoid reading the megatexture when the weight is 0 as it can be costly.\\n\\\n            if (weight > 0.0) {\\n\\\n                Properties tempProperties = getPropertiesFromMegatexture(sampleDatas[i]);\\n\\\n                tempProperties = scaleProperties(tempProperties, weight);\\n\\\n                properties = sumProperties(properties, tempProperties);\\n\\\n            }\\n\\\n        }\\n\\\n        return properties;\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/Megatexture.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See Octree.glsl for the definitions of SampleData and intMod\\n\\\n\\n\\\n/* Megatexture defines (set in Scene/VoxelRenderResources.js)\\n\\\n#define SAMPLE_COUNT ###\\n\\\n#define NEAREST_SAMPLING\\n\\\n#define PADDING\\n\\\n*/\\n\\\n\\n\\\nuniform ivec2 u_megatextureSliceDimensions; // number of slices per tile, in two dimensions\\n\\\nuniform ivec2 u_megatextureTileDimensions; // number of tiles per megatexture, in two dimensions\\n\\\nuniform vec2 u_megatextureVoxelSizeUv;\\n\\\nuniform vec2 u_megatextureSliceSizeUv;\\n\\\nuniform vec2 u_megatextureTileSizeUv;\\n\\\n\\n\\\nuniform ivec3 u_dimensions; // does not include padding\\n\\\n#if defined(PADDING)\\n\\\n    uniform ivec3 u_paddingBefore;\\n\\\n    uniform ivec3 u_paddingAfter;\\n\\\n#endif\\n\\\n\\n\\\n// Integer min, max, clamp: For WebGL1 only\\n\\\nint intMin(int a, int b) {\\n\\\n    return a <= b ? a : b;\\n\\\n}\\n\\\nint intMax(int a, int b) {\\n\\\n    return a >= b ? a : b;\\n\\\n}\\n\\\nint intClamp(int v, int minVal, int maxVal) {\\n\\\n    return intMin(intMax(v, minVal), maxVal);\\n\\\n}\\n\\\n\\n\\\nvec2 index1DTo2DTexcoord(int index, ivec2 dimensions, vec2 uvScale)\\n\\\n{\\n\\\n    int indexX = intMod(index, dimensions.x);\\n\\\n    int indexY = index / dimensions.x;\\n\\\n    return vec2(indexX, indexY) * uvScale;\\n\\\n}\\n\\\n\\n\\\n/*\\n\\\n    How is 3D data stored in a 2D megatexture?\\n\\\n\\n\\\n    In this example there is only one loaded tile and it has 2x2x2 voxels (8 voxels total).\\n\\\n    The data is sliced by Z. The data at Z = 0 is placed in texels (0,0), (0,1), (1,0), (1,1) and\\n\\\n    the data at Z = 1 is placed in texels (2,0), (2,1), (3,0), (3,1).\\n\\\n    Note that there could be empty space in the megatexture because it's a power of two.\\n\\\n\\n\\\n      0   1   2   3\\n\\\n    +---+---+---+---+\\n\\\n    |   |   |   |   | 3\\n\\\n    +---+---+---+---+\\n\\\n    |   |   |   |   | 2\\n\\\n    +-------+-------+\\n\\\n    |010|110|011|111| 1\\n\\\n    |--- ---|--- ---|\\n\\\n    |000|100|001|101| 0\\n\\\n    +-------+-------+\\n\\\n\\n\\\n    When doing linear interpolation the megatexture needs to be sampled twice: once for\\n\\\n    the Z slice above the voxel coordinate and once for the slice below. The two slices\\n\\\n    are interpolated with fract(coord.z - 0.5). For example, a Z coordinate of 1.0 is\\n\\\n    halfway between two Z slices so the interpolation factor is 0.5. Below is a side view\\n\\\n    of the 3D voxel grid with voxel coordinates on the left side.\\n\\\n\\n\\\n    2 +---+\\n\\\n      |001|\\n\\\n    1 +-z-+\\n\\\n      |000|\\n\\\n    0 +---+\\n\\\n\\n\\\n    When doing nearest neighbor the megatexture only needs to be sampled once at the closest Z slice.\\n\\\n*/\\n\\\n\\n\\\nProperties getPropertiesFromMegatexture(in SampleData sampleData) {\\n\\\n    int tileIndex = sampleData.megatextureIndex;\\n\\\n    vec3 voxelCoord = sampleData.tileUv * vec3(u_dimensions);\\n\\\n    ivec3 voxelDimensions = u_dimensions;\\n\\\n\\n\\\n    #if defined(PADDING)\\n\\\n        voxelDimensions += u_paddingBefore + u_paddingAfter;\\n\\\n        voxelCoord += vec3(u_paddingBefore);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(NEAREST_SAMPLING)\\n\\\n        // Round to the center of the nearest voxel\\n\\\n        voxelCoord = floor(voxelCoord) + vec3(0.5);\\n\\\n    #endif\\n\\\n\\n\\\n    // Tile location\\n\\\n    vec2 tileUvOffset = index1DTo2DTexcoord(tileIndex, u_megatextureTileDimensions, u_megatextureTileSizeUv);\\n\\\n\\n\\\n    // Slice location\\n\\\n    float slice = voxelCoord.z - 0.5;\\n\\\n    int sliceIndex = int(floor(slice));\\n\\\n    int sliceIndex0 = intClamp(sliceIndex, 0, voxelDimensions.z - 1);\\n\\\n    vec2 sliceUvOffset0 = index1DTo2DTexcoord(sliceIndex0, u_megatextureSliceDimensions, u_megatextureSliceSizeUv);\\n\\\n\\n\\\n    // Voxel location\\n\\\n    vec2 voxelUvOffset = clamp(voxelCoord.xy, vec2(0.5), vec2(voxelDimensions.xy) - vec2(0.5)) * u_megatextureVoxelSizeUv;\\n\\\n\\n\\\n    // Final location in the megatexture\\n\\\n    vec2 uv0 = tileUvOffset + sliceUvOffset0 + voxelUvOffset;\\n\\\n\\n\\\n    #if defined(NEAREST_SAMPLING)\\n\\\n        return getPropertiesFromMegatextureAtUv(uv0);\\n\\\n    #else\\n\\\n        float sliceLerp = fract(slice);\\n\\\n        int sliceIndex1 = intMin(sliceIndex + 1, voxelDimensions.z - 1);\\n\\\n        vec2 sliceUvOffset1 = index1DTo2DTexcoord(sliceIndex1, u_megatextureSliceDimensions, u_megatextureSliceSizeUv);\\n\\\n        vec2 uv1 = tileUvOffset + sliceUvOffset1 + voxelUvOffset;\\n\\\n        Properties properties0 = getPropertiesFromMegatextureAtUv(uv0);\\n\\\n        Properties properties1 = getPropertiesFromMegatextureAtUv(uv1);\\n\\\n        return mixProperties(properties0, properties1, sliceLerp);\\n\\\n    #endif\\n\\\n}\\n\\\n\\n\\\n// Convert an array of sample datas to a final weighted properties.\\n\\\nProperties accumulatePropertiesFromMegatexture(in SampleData sampleDatas[SAMPLE_COUNT]) {\\n\\\n    #if (SAMPLE_COUNT == 1)\\n\\\n        return getPropertiesFromMegatexture(sampleDatas[0]);\\n\\\n    #else\\n\\\n        // When more than one sample is taken the accumulator needs to start at 0\\n\\\n        Properties properties = clearProperties();\\n\\\n        for (int i = 0; i < SAMPLE_COUNT; ++i) {\\n\\\n            float weight = sampleDatas[i].weight;\\n\\\n\\n\\\n            // Avoid reading the megatexture when the weight is 0 as it can be costly.\\n\\\n            if (weight > 0.0) {\\n\\\n                Properties tempProperties = getPropertiesFromMegatexture(sampleDatas[i]);\\n\\\n                tempProperties = scaleProperties(tempProperties, weight);\\n\\\n                properties = sumProperties(properties, tempProperties);\\n\\\n            }\\n\\\n        }\\n\\\n        return properties;\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}