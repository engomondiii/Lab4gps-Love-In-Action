{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport sampleTerrainMostDetailed from \"../Core/sampleTerrainMostDetailed.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Computes the final camera location to view a rectangle adjusted for the current terrain.\n * If the terrain does not support availability, the height above the ellipsoid is used.\n *\n * @param {Rectangle} rectangle The rectangle being zoomed to.\n * @param {Scene} scene The scene being used.\n *\n * @returns {Promise<Cartographic>} The optimal location to place the camera so that the entire rectangle is in view.\n *\n * @private\n */\nasync function computeFlyToLocationForRectangle(rectangle, scene) {\n  const terrainProvider = scene.terrainProvider;\n  const mapProjection = scene.mapProjection;\n  const ellipsoid = mapProjection.ellipsoid;\n  let positionWithoutTerrain;\n  const tmp = scene.camera.getRectangleCameraCoordinates(rectangle);\n  if (scene.mode === SceneMode.SCENE3D) {\n    positionWithoutTerrain = ellipsoid.cartesianToCartographic(tmp);\n  } else {\n    positionWithoutTerrain = mapProjection.unproject(tmp);\n  }\n  if (!defined(terrainProvider)) {\n    return positionWithoutTerrain;\n  }\n  const availability = terrainProvider.availability;\n  if (!defined(availability) || scene.mode === SceneMode.SCENE2D) {\n    return positionWithoutTerrain;\n  }\n  const cartographics = [Rectangle.center(rectangle), Rectangle.southeast(rectangle), Rectangle.southwest(rectangle), Rectangle.northeast(rectangle), Rectangle.northwest(rectangle)];\n  const positionsOnTerrain = await computeFlyToLocationForRectangle._sampleTerrainMostDetailed(terrainProvider, cartographics);\n  let heightFound = false;\n  const maxHeight = positionsOnTerrain.reduce(function (currentMax, item) {\n    if (!defined(item.height)) {\n      return currentMax;\n    }\n    heightFound = true;\n    return Math.max(item.height, currentMax);\n  }, -Number.MAX_VALUE);\n  const finalPosition = positionWithoutTerrain;\n  if (heightFound) {\n    finalPosition.height += maxHeight;\n  }\n  return finalPosition;\n}\n\n//Exposed for testing.\ncomputeFlyToLocationForRectangle._sampleTerrainMostDetailed = sampleTerrainMostDetailed;\nexport default computeFlyToLocationForRectangle;","map":{"version":3,"names":["defined","Rectangle","sampleTerrainMostDetailed","SceneMode","computeFlyToLocationForRectangle","rectangle","scene","terrainProvider","mapProjection","ellipsoid","positionWithoutTerrain","tmp","camera","getRectangleCameraCoordinates","mode","SCENE3D","cartesianToCartographic","unproject","availability","SCENE2D","cartographics","center","southeast","southwest","northeast","northwest","positionsOnTerrain","_sampleTerrainMostDetailed","heightFound","maxHeight","reduce","currentMax","item","height","Math","max","Number","MAX_VALUE","finalPosition"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/computeFlyToLocationForRectangle.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport sampleTerrainMostDetailed from \"../Core/sampleTerrainMostDetailed.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Computes the final camera location to view a rectangle adjusted for the current terrain.\n * If the terrain does not support availability, the height above the ellipsoid is used.\n *\n * @param {Rectangle} rectangle The rectangle being zoomed to.\n * @param {Scene} scene The scene being used.\n *\n * @returns {Promise<Cartographic>} The optimal location to place the camera so that the entire rectangle is in view.\n *\n * @private\n */\nasync function computeFlyToLocationForRectangle(rectangle, scene) {\n  const terrainProvider = scene.terrainProvider;\n  const mapProjection = scene.mapProjection;\n  const ellipsoid = mapProjection.ellipsoid;\n\n  let positionWithoutTerrain;\n  const tmp = scene.camera.getRectangleCameraCoordinates(rectangle);\n  if (scene.mode === SceneMode.SCENE3D) {\n    positionWithoutTerrain = ellipsoid.cartesianToCartographic(tmp);\n  } else {\n    positionWithoutTerrain = mapProjection.unproject(tmp);\n  }\n\n  if (!defined(terrainProvider)) {\n    return positionWithoutTerrain;\n  }\n\n  const availability = terrainProvider.availability;\n\n  if (!defined(availability) || scene.mode === SceneMode.SCENE2D) {\n    return positionWithoutTerrain;\n  }\n\n  const cartographics = [\n    Rectangle.center(rectangle),\n    Rectangle.southeast(rectangle),\n    Rectangle.southwest(rectangle),\n    Rectangle.northeast(rectangle),\n    Rectangle.northwest(rectangle),\n  ];\n\n  const positionsOnTerrain =\n    await computeFlyToLocationForRectangle._sampleTerrainMostDetailed(\n      terrainProvider,\n      cartographics,\n    );\n\n  let heightFound = false;\n  const maxHeight = positionsOnTerrain.reduce(function (currentMax, item) {\n    if (!defined(item.height)) {\n      return currentMax;\n    }\n    heightFound = true;\n    return Math.max(item.height, currentMax);\n  }, -Number.MAX_VALUE);\n\n  const finalPosition = positionWithoutTerrain;\n  if (heightFound) {\n    finalPosition.height += maxHeight;\n  }\n\n  return finalPosition;\n}\n\n//Exposed for testing.\ncomputeFlyToLocationForRectangle._sampleTerrainMostDetailed =\n  sampleTerrainMostDetailed;\nexport default computeFlyToLocationForRectangle;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,oBAAoB;AACxC,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,yBAAyB,MAAM,sCAAsC;AAC5E,OAAOC,SAAS,MAAM,gBAAgB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,gCAAgCA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAChE,MAAMC,eAAe,GAAGD,KAAK,CAACC,eAAe;EAC7C,MAAMC,aAAa,GAAGF,KAAK,CAACE,aAAa;EACzC,MAAMC,SAAS,GAAGD,aAAa,CAACC,SAAS;EAEzC,IAAIC,sBAAsB;EAC1B,MAAMC,GAAG,GAAGL,KAAK,CAACM,MAAM,CAACC,6BAA6B,CAACR,SAAS,CAAC;EACjE,IAAIC,KAAK,CAACQ,IAAI,KAAKX,SAAS,CAACY,OAAO,EAAE;IACpCL,sBAAsB,GAAGD,SAAS,CAACO,uBAAuB,CAACL,GAAG,CAAC;EACjE,CAAC,MAAM;IACLD,sBAAsB,GAAGF,aAAa,CAACS,SAAS,CAACN,GAAG,CAAC;EACvD;EAEA,IAAI,CAACX,OAAO,CAACO,eAAe,CAAC,EAAE;IAC7B,OAAOG,sBAAsB;EAC/B;EAEA,MAAMQ,YAAY,GAAGX,eAAe,CAACW,YAAY;EAEjD,IAAI,CAAClB,OAAO,CAACkB,YAAY,CAAC,IAAIZ,KAAK,CAACQ,IAAI,KAAKX,SAAS,CAACgB,OAAO,EAAE;IAC9D,OAAOT,sBAAsB;EAC/B;EAEA,MAAMU,aAAa,GAAG,CACpBnB,SAAS,CAACoB,MAAM,CAAChB,SAAS,CAAC,EAC3BJ,SAAS,CAACqB,SAAS,CAACjB,SAAS,CAAC,EAC9BJ,SAAS,CAACsB,SAAS,CAAClB,SAAS,CAAC,EAC9BJ,SAAS,CAACuB,SAAS,CAACnB,SAAS,CAAC,EAC9BJ,SAAS,CAACwB,SAAS,CAACpB,SAAS,CAAC,CAC/B;EAED,MAAMqB,kBAAkB,GACtB,MAAMtB,gCAAgC,CAACuB,0BAA0B,CAC/DpB,eAAe,EACfa,aACF,CAAC;EAEH,IAAIQ,WAAW,GAAG,KAAK;EACvB,MAAMC,SAAS,GAAGH,kBAAkB,CAACI,MAAM,CAAC,UAAUC,UAAU,EAAEC,IAAI,EAAE;IACtE,IAAI,CAAChC,OAAO,CAACgC,IAAI,CAACC,MAAM,CAAC,EAAE;MACzB,OAAOF,UAAU;IACnB;IACAH,WAAW,GAAG,IAAI;IAClB,OAAOM,IAAI,CAACC,GAAG,CAACH,IAAI,CAACC,MAAM,EAAEF,UAAU,CAAC;EAC1C,CAAC,EAAE,CAACK,MAAM,CAACC,SAAS,CAAC;EAErB,MAAMC,aAAa,GAAG5B,sBAAsB;EAC5C,IAAIkB,WAAW,EAAE;IACfU,aAAa,CAACL,MAAM,IAAIJ,SAAS;EACnC;EAEA,OAAOS,aAAa;AACtB;;AAEA;AACAlC,gCAAgC,CAACuB,0BAA0B,GACzDzB,yBAAyB;AAC3B,eAAeE,gCAAgC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}