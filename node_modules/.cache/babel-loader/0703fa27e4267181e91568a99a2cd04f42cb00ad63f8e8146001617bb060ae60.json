{"ast":null,"code":"import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport AcesTonemapping from \"../Shaders/PostProcessStages/AcesTonemappingStage.js\";\nimport AmbientOcclusionGenerate from \"../Shaders/PostProcessStages/AmbientOcclusionGenerate.js\";\nimport AmbientOcclusionModulate from \"../Shaders/PostProcessStages/AmbientOcclusionModulate.js\";\nimport BlackAndWhite from \"../Shaders/PostProcessStages/BlackAndWhite.js\";\nimport BloomComposite from \"../Shaders/PostProcessStages/BloomComposite.js\";\nimport Brightness from \"../Shaders/PostProcessStages/Brightness.js\";\nimport ContrastBias from \"../Shaders/PostProcessStages/ContrastBias.js\";\nimport DepthOfField from \"../Shaders/PostProcessStages/DepthOfField.js\";\nimport DepthView from \"../Shaders/PostProcessStages/DepthView.js\";\nimport EdgeDetection from \"../Shaders/PostProcessStages/EdgeDetection.js\";\nimport FilmicTonemapping from \"../Shaders/PostProcessStages/FilmicTonemapping.js\";\nimport PbrNeutralTonemapping from \"../Shaders/PostProcessStages/PbrNeutralTonemapping.js\";\nimport FXAA from \"../Shaders/PostProcessStages/FXAA.js\";\nimport GaussianBlur1D from \"../Shaders/PostProcessStages/GaussianBlur1D.js\";\nimport LensFlare from \"../Shaders/PostProcessStages/LensFlare.js\";\nimport ModifiedReinhardTonemapping from \"../Shaders/PostProcessStages/ModifiedReinhardTonemapping.js\";\nimport NightVision from \"../Shaders/PostProcessStages/NightVision.js\";\nimport ReinhardTonemapping from \"../Shaders/PostProcessStages/ReinhardTonemapping.js\";\nimport Silhouette from \"../Shaders/PostProcessStages/Silhouette.js\";\nimport FXAA3_11 from \"../Shaders/FXAA3_11.js\";\nimport AutoExposure from \"./AutoExposure.js\";\nimport PostProcessStage from \"./PostProcessStage.js\";\nimport PostProcessStageComposite from \"./PostProcessStageComposite.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\n\n/**\n * Contains functions for creating common post-process stages.\n *\n * @namespace PostProcessStageLibrary\n */\nconst PostProcessStageLibrary = {};\nfunction createBlur(name) {\n  const delta = 1.0;\n  const sigma = 2.0;\n  const stepSize = 1.0;\n  const blurShader = `#define USE_STEP_SIZE\\n${GaussianBlur1D}`;\n  const blurX = new PostProcessStage({\n    name: `${name}_x_direction`,\n    fragmentShader: blurShader,\n    uniforms: {\n      delta: delta,\n      sigma: sigma,\n      stepSize: stepSize,\n      direction: 0.0\n    },\n    sampleMode: PostProcessStageSampleMode.LINEAR\n  });\n  const blurY = new PostProcessStage({\n    name: `${name}_y_direction`,\n    fragmentShader: blurShader,\n    uniforms: {\n      delta: delta,\n      sigma: sigma,\n      stepSize: stepSize,\n      direction: 1.0\n    },\n    sampleMode: PostProcessStageSampleMode.LINEAR\n  });\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    delta: {\n      get: function () {\n        return blurX.uniforms.delta;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.delta = blurYUniforms.delta = value;\n      }\n    },\n    sigma: {\n      get: function () {\n        return blurX.uniforms.sigma;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.sigma = blurYUniforms.sigma = value;\n      }\n    },\n    stepSize: {\n      get: function () {\n        return blurX.uniforms.stepSize;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.stepSize = blurYUniforms.stepSize = value;\n      }\n    }\n  });\n  return new PostProcessStageComposite({\n    name: name,\n    stages: [blurX, blurY],\n    uniforms: uniforms\n  });\n}\n\n/**\n * Creates a post-process stage that applies a Gaussian blur to the input texture. This stage is usually applied in conjunction with another stage.\n * <p>\n * This stage has the following uniforms: <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <p>\n * <code>delta</code> and <code>sigma</code> are used to compute the weights of a Gaussian filter. The equation is <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>.\n * The default value for <code>delta</code> is <code>1.0</code>. The default value for <code>sigma</code> is <code>2.0</code>.\n * <code>stepSize</code> is the distance to the next texel. The default is <code>1.0</code>.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies a Gaussian blur to the input texture.\n */\nPostProcessStageLibrary.createBlurStage = function () {\n  return createBlur(\"czm_blur\");\n};\n\n/**\n * Creates a post-process stage that applies a depth of field effect.\n * <p>\n * Depth of field simulates camera focus. Objects in the scene that are in focus\n * will be clear whereas objects not in focus will be blurred.\n * </p>\n * <p>\n * This stage has the following uniforms: <code>focalDistance</code>, <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <p>\n * <code>focalDistance</code> is the distance in meters from the camera to set the camera focus.\n * </p>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * The blur is applied to the areas out of focus.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies a depth of field effect.\n */\nPostProcessStageLibrary.createDepthOfFieldStage = function () {\n  const blur = createBlur(\"czm_depth_of_field_blur\");\n  const dof = new PostProcessStage({\n    name: \"czm_depth_of_field_composite\",\n    fragmentShader: DepthOfField,\n    uniforms: {\n      focalDistance: 5.0,\n      blurTexture: blur.name\n    }\n  });\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    focalDistance: {\n      get: function () {\n        return dof.uniforms.focalDistance;\n      },\n      set: function (value) {\n        dof.uniforms.focalDistance = value;\n      }\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      }\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      }\n    },\n    stepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      }\n    }\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_depth_of_field\",\n    stages: [blur, dof],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms\n  });\n};\n\n/**\n * Whether or not a depth of field stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isDepthOfFieldSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\n/**\n * Creates a post-process stage that detects edges.\n * <p>\n * Writes the color to the output texture with alpha set to 1.0 when it is on an edge.\n * </p>\n * <p>\n * This stage has the following uniforms: <code>color</code> and <code>length</code>\n * </p>\n * <ul>\n * <li><code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.</li>\n * <li><code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.</li>\n * </ul>\n * <p>\n * This stage is not supported in 2D.\n * </p>\n * @return {PostProcessStage} A post-process stage that applies an edge detection effect.\n *\n * @example\n * // multiple silhouette effects\n * const yellowEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * yellowEdge.uniforms.color = Cesium.Color.YELLOW;\n * yellowEdge.selected = [feature0];\n *\n * const greenEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * greenEdge.uniforms.color = Cesium.Color.LIME;\n * greenEdge.selected = [feature1];\n *\n * // draw edges around feature0 and feature1\n * postProcessStages.add(Cesium.PostProcessStageLibrary.createSilhouetteStage([yellowEdge, greenEdge]);\n */\nPostProcessStageLibrary.createEdgeDetectionStage = function () {\n  // unique name generated on call so more than one effect can be added\n  const name = createGuid();\n  return new PostProcessStage({\n    name: `czm_edge_detection_${name}`,\n    fragmentShader: EdgeDetection,\n    uniforms: {\n      length: 0.25,\n      color: Color.clone(Color.BLACK)\n    }\n  });\n};\n\n/**\n * Whether or not an edge detection stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isEdgeDetectionSupported = function (scene) {\n  return scene.context.depthTexture;\n};\nfunction getSilhouetteEdgeDetection(edgeDetectionStages) {\n  if (!defined(edgeDetectionStages)) {\n    return PostProcessStageLibrary.createEdgeDetectionStage();\n  }\n  const edgeDetection = new PostProcessStageComposite({\n    name: \"czm_edge_detection_multiple\",\n    stages: edgeDetectionStages,\n    inputPreviousStageTexture: false\n  });\n  const compositeUniforms = {};\n  let fsDecl = \"\";\n  let fsLoop = \"\";\n  for (let i = 0; i < edgeDetectionStages.length; ++i) {\n    fsDecl += `uniform sampler2D edgeTexture${i}; \\n`;\n    fsLoop += `        vec4 edge${i} = texture(edgeTexture${i}, v_textureCoordinates); \\n` + `        if (edge${i}.a > 0.0) \\n` + `        { \\n` + `            color = edge${i}; \\n` + `            break; \\n` + `        } \\n`;\n    compositeUniforms[`edgeTexture${i}`] = edgeDetectionStages[i].name;\n  }\n  const fs = `${fsDecl}in vec2 v_textureCoordinates; \\n` + `void main() { \\n` + `    vec4 color = vec4(0.0); \\n` + `    for (int i = 0; i < ${edgeDetectionStages.length}; i++) \\n` + `    { \\n${fsLoop}    } \\n` + `    out_FragColor = color; \\n` + `} \\n`;\n  const edgeComposite = new PostProcessStage({\n    name: \"czm_edge_detection_combine\",\n    fragmentShader: fs,\n    uniforms: compositeUniforms\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_edge_detection_composite\",\n    stages: [edgeDetection, edgeComposite]\n  });\n}\n\n/**\n * Creates a post-process stage that applies a silhouette effect.\n * <p>\n * A silhouette effect composites the color from the edge detection pass with input color texture.\n * </p>\n * <p>\n * This stage has the following uniforms when <code>edgeDetectionStages</code> is <code>undefined</code>: <code>color</code> and <code>length</code>\n * </p>\n * <p>\n * <code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.\n * <code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.\n * </p>\n * @param {PostProcessStage[]} [edgeDetectionStages] An array of edge detection post process stages.\n * @return {PostProcessStageComposite} A post-process stage that applies a silhouette effect.\n */\nPostProcessStageLibrary.createSilhouetteStage = function (edgeDetectionStages) {\n  const edgeDetection = getSilhouetteEdgeDetection(edgeDetectionStages);\n  const silhouetteProcess = new PostProcessStage({\n    name: \"czm_silhouette_color_edges\",\n    fragmentShader: Silhouette,\n    uniforms: {\n      silhouetteTexture: edgeDetection.name\n    }\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_silhouette\",\n    stages: [edgeDetection, silhouetteProcess],\n    inputPreviousStageTexture: false,\n    uniforms: edgeDetection.uniforms\n  });\n};\n\n/**\n * Whether or not a silhouette stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isSilhouetteSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\n/**\n * Creates a post-process stage that applies a bloom effect to the input texture.\n * <p>\n * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.\n * </p>\n * <p>\n * This post-process stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <ul>\n * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>\n * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is\n * added to the brightness. The default value is <code>-0.3</code>.</li>\n * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.\n * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>\n * </ul>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage to applies a bloom effect.\n *\n * @private\n */\nPostProcessStageLibrary.createBloomStage = function () {\n  const contrastBias = new PostProcessStage({\n    name: \"czm_bloom_contrast_bias\",\n    fragmentShader: ContrastBias,\n    uniforms: {\n      contrast: 128.0,\n      brightness: -0.3\n    }\n  });\n  const blur = createBlur(\"czm_bloom_blur\");\n  const generateComposite = new PostProcessStageComposite({\n    name: \"czm_bloom_contrast_bias_blur\",\n    stages: [contrastBias, blur]\n  });\n  const bloomComposite = new PostProcessStage({\n    name: \"czm_bloom_generate_composite\",\n    fragmentShader: BloomComposite,\n    uniforms: {\n      glowOnly: false,\n      bloomTexture: generateComposite.name\n    }\n  });\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    glowOnly: {\n      get: function () {\n        return bloomComposite.uniforms.glowOnly;\n      },\n      set: function (value) {\n        bloomComposite.uniforms.glowOnly = value;\n      }\n    },\n    contrast: {\n      get: function () {\n        return contrastBias.uniforms.contrast;\n      },\n      set: function (value) {\n        contrastBias.uniforms.contrast = value;\n      }\n    },\n    brightness: {\n      get: function () {\n        return contrastBias.uniforms.brightness;\n      },\n      set: function (value) {\n        contrastBias.uniforms.brightness = value;\n      }\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      }\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      }\n    },\n    stepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      }\n    }\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_bloom\",\n    stages: [generateComposite, bloomComposite],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms\n  });\n};\n\n/**\n * Creates a post-process stage that Horizon-based Ambient Occlusion (HBAO) to the input texture.\n * <p>\n * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the\n * surface receives light and regardless of the light's position.\n * </p>\n * <p>\n * The uniforms have the following properties:\n * <ul>\n * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>\n * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,\n * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>\n * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,\n * sampling stops in the current direction. The default value is <code>0.26</code>.</li>\n * <li><code>directionCount</code> is the number of directions along which the ray marching will search for occluders. The default value is <code>8</code>.</li>\n * <li><code>stepCount</code> is the number of steps the ray marching will take along each direction. The default value is <code>32</code>.</li>\n * <li><code>randomTexture</code> is a texture where the red channel is a random value in [0.0, 1.0]. The default value is <code>undefined</code>. This texture needs to be set.</li>\n * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated\n * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>\n * </ul>\n * @return {PostProcessStageComposite} A post-process stage that applies an ambient occlusion effect.\n *\n * @private\n */\nPostProcessStageLibrary.createAmbientOcclusionStage = function () {\n  const generate = new PostProcessStage({\n    name: \"czm_ambient_occlusion_generate\",\n    fragmentShader: AmbientOcclusionGenerate,\n    uniforms: {\n      intensity: 3.0,\n      bias: 0.1,\n      lengthCap: 0.26,\n      directionCount: 8,\n      stepCount: 32,\n      randomTexture: undefined\n    }\n  });\n  const ambientOcclusionModulate = new PostProcessStage({\n    name: \"czm_ambient_occlusion_composite\",\n    fragmentShader: AmbientOcclusionModulate,\n    uniforms: {\n      ambientOcclusionOnly: false,\n      ambientOcclusionTexture: generate.name\n    }\n  });\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    intensity: {\n      get: function () {\n        return generate.uniforms.intensity;\n      },\n      set: function (value) {\n        generate.uniforms.intensity = value;\n      }\n    },\n    bias: {\n      get: function () {\n        return generate.uniforms.bias;\n      },\n      set: function (value) {\n        generate.uniforms.bias = value;\n      }\n    },\n    lengthCap: {\n      get: function () {\n        return generate.uniforms.lengthCap;\n      },\n      set: function (value) {\n        generate.uniforms.lengthCap = value;\n      }\n    },\n    directionCount: {\n      get: function () {\n        return generate.uniforms.directionCount;\n      },\n      set: function (value) {\n        generate.uniforms.directionCount = value;\n      }\n    },\n    stepCount: {\n      get: function () {\n        return generate.uniforms.stepCount;\n      },\n      set: function (value) {\n        generate.uniforms.stepCount = value;\n      }\n    },\n    randomTexture: {\n      get: function () {\n        return generate.uniforms.randomTexture;\n      },\n      set: function (value) {\n        generate.uniforms.randomTexture = value;\n      }\n    },\n    ambientOcclusionOnly: {\n      get: function () {\n        return ambientOcclusionModulate.uniforms.ambientOcclusionOnly;\n      },\n      set: function (value) {\n        ambientOcclusionModulate.uniforms.ambientOcclusionOnly = value;\n      }\n    }\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_ambient_occlusion\",\n    stages: [generate, ambientOcclusionModulate],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms\n  });\n};\n\n/**\n * Whether or not an ambient occlusion stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isAmbientOcclusionSupported = function (scene) {\n  return scene.context.depthTexture;\n};\nconst fxaaFS = `#define FXAA_QUALITY_PRESET 39 \\n${FXAA3_11}\\n${FXAA}`;\n\n/**\n * Creates a post-process stage that applies Fast Approximate Anti-aliasing (FXAA) to the input texture.\n * @return {PostProcessStage} A post-process stage that applies Fast Approximate Anti-aliasing to the input texture.\n *\n * @private\n */\nPostProcessStageLibrary.createFXAAStage = function () {\n  return new PostProcessStage({\n    name: \"czm_FXAA\",\n    fragmentShader: fxaaFS,\n    sampleMode: PostProcessStageSampleMode.LINEAR\n  });\n};\n\n/**\n * Creates a post-process stage that applies ACES tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies ACES tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createAcesTonemappingStage = function (useAutoExposure) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += AcesTonemapping;\n  return new PostProcessStage({\n    name: \"czm_aces\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that applies filmic tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies filmic tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createFilmicTonemappingStage = function (useAutoExposure) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += FilmicTonemapping;\n  return new PostProcessStage({\n    name: \"czm_filmic\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that applies filmic tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies filmic tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createPbrNeutralTonemappingStage = function (useAutoExposure) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += PbrNeutralTonemapping;\n  return new PostProcessStage({\n    name: \"czm_pbr_neutral\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that applies Reinhard tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies Reinhard tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createReinhardTonemappingStage = function (useAutoExposure) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += ReinhardTonemapping;\n  return new PostProcessStage({\n    name: \"czm_reinhard\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that applies modified Reinhard tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies modified Reinhard tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createModifiedReinhardTonemappingStage = function (useAutoExposure) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += ModifiedReinhardTonemapping;\n  return new PostProcessStage({\n    name: \"czm_modified_reinhard\",\n    fragmentShader: fs,\n    uniforms: {\n      white: Color.WHITE,\n      autoExposure: undefined,\n      exposure: 1.0\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that finds the average luminance of the input texture.\n * @return {PostProcessStage} A post-process stage that finds the average luminance of the input texture.\n * @private\n */\nPostProcessStageLibrary.createAutoExposureStage = function () {\n  return new AutoExposure();\n};\n\n/**\n * Creates a post-process stage that renders the input texture with black and white gradations.\n * <p>\n * This stage has one uniform value, <code>gradations</code>, which scales the luminance of each pixel.\n * </p>\n * @return {PostProcessStage} A post-process stage that renders the input texture with black and white gradations.\n */\nPostProcessStageLibrary.createBlackAndWhiteStage = function () {\n  return new PostProcessStage({\n    name: \"czm_black_and_white\",\n    fragmentShader: BlackAndWhite,\n    uniforms: {\n      gradations: 5.0\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that saturates the input texture.\n * <p>\n * This stage has one uniform value, <code>brightness</code>, which scales the saturation of each pixel.\n * </p>\n * @return {PostProcessStage} A post-process stage that saturates the input texture.\n */\nPostProcessStageLibrary.createBrightnessStage = function () {\n  return new PostProcessStage({\n    name: \"czm_brightness\",\n    fragmentShader: Brightness,\n    uniforms: {\n      brightness: 0.5\n    }\n  });\n};\n\n/**\n * Creates a post-process stage that adds a night vision effect to the input texture.\n * @return {PostProcessStage} A post-process stage that adds a night vision effect to the input texture.\n */\nPostProcessStageLibrary.createNightVisionStage = function () {\n  return new PostProcessStage({\n    name: \"czm_night_vision\",\n    fragmentShader: NightVision\n  });\n};\n\n/**\n * Creates a post-process stage that replaces the input color texture with a black and white texture representing the fragment depth at each pixel.\n * @return {PostProcessStage} A post-process stage that replaces the input color texture with a black and white texture representing the fragment depth at each pixel.\n *\n * @private\n */\nPostProcessStageLibrary.createDepthViewStage = function () {\n  return new PostProcessStage({\n    name: \"czm_depth_view\",\n    fragmentShader: DepthView\n  });\n};\n\n/**\n * Creates a post-process stage that applies an effect simulating light flaring a camera lens.\n * <p>\n * This stage has the following uniforms: <code>dirtTexture</code>, <code>starTexture</code>, <code>intensity</code>, <code>distortion</code>, <code>ghostDispersal</code>,\n * <code>haloWidth</code>, <code>dirtAmount</code>, and <code>earthRadius</code>.\n * <ul>\n * <li><code>dirtTexture</code> is a texture sampled to simulate dirt on the lens.</li>\n * <li><code>starTexture</code> is the texture sampled for the star pattern of the flare.</li>\n * <li><code>intensity</code> is a scalar multiplied by the result of the lens flare. The default value is <code>2.0</code>.</li>\n * <li><code>distortion</code> is a scalar value that affects the chromatic effect distortion. The default value is <code>10.0</code>.</li>\n * <li><code>ghostDispersal</code> is a scalar indicating how far the halo effect is from the center of the texture. The default value is <code>0.4</code>.</li>\n * <li><code>haloWidth</code> is a scalar representing the width of the halo  from the ghost dispersal. The default value is <code>0.4</code>.</li>\n * <li><code>dirtAmount</code> is a scalar representing the amount of dirt on the lens. The default value is <code>0.4</code>.</li>\n * <li><code>earthRadius</code> is the maximum radius of the earth. The default value is <code>Ellipsoid.WGS84.maximumRadius</code>.</li>\n * </ul>\n * </p>\n * @return {PostProcessStage} A post-process stage for applying a lens flare effect.\n */\nPostProcessStageLibrary.createLensFlareStage = function () {\n  return new PostProcessStage({\n    name: \"czm_lens_flare\",\n    fragmentShader: LensFlare,\n    uniforms: {\n      dirtTexture: buildModuleUrl(\"Assets/Textures/LensFlare/DirtMask.jpg\"),\n      starTexture: buildModuleUrl(\"Assets/Textures/LensFlare/StarBurst.jpg\"),\n      intensity: 2.0,\n      distortion: 10.0,\n      ghostDispersal: 0.4,\n      haloWidth: 0.4,\n      dirtAmount: 0.4,\n      earthRadius: Ellipsoid.WGS84.maximumRadius\n    }\n  });\n};\nexport default PostProcessStageLibrary;","map":{"version":3,"names":["buildModuleUrl","Color","createGuid","defined","Ellipsoid","AcesTonemapping","AmbientOcclusionGenerate","AmbientOcclusionModulate","BlackAndWhite","BloomComposite","Brightness","ContrastBias","DepthOfField","DepthView","EdgeDetection","FilmicTonemapping","PbrNeutralTonemapping","FXAA","GaussianBlur1D","LensFlare","ModifiedReinhardTonemapping","NightVision","ReinhardTonemapping","Silhouette","FXAA3_11","AutoExposure","PostProcessStage","PostProcessStageComposite","PostProcessStageSampleMode","PostProcessStageLibrary","createBlur","name","delta","sigma","stepSize","blurShader","blurX","fragmentShader","uniforms","direction","sampleMode","LINEAR","blurY","Object","defineProperties","get","set","value","blurXUniforms","blurYUniforms","stages","createBlurStage","createDepthOfFieldStage","blur","dof","focalDistance","blurTexture","inputPreviousStageTexture","isDepthOfFieldSupported","scene","context","depthTexture","createEdgeDetectionStage","length","color","clone","BLACK","isEdgeDetectionSupported","getSilhouetteEdgeDetection","edgeDetectionStages","edgeDetection","compositeUniforms","fsDecl","fsLoop","i","fs","edgeComposite","createSilhouetteStage","silhouetteProcess","silhouetteTexture","isSilhouetteSupported","createBloomStage","contrastBias","contrast","brightness","generateComposite","bloomComposite","glowOnly","bloomTexture","createAmbientOcclusionStage","generate","intensity","bias","lengthCap","directionCount","stepCount","randomTexture","undefined","ambientOcclusionModulate","ambientOcclusionOnly","ambientOcclusionTexture","isAmbientOcclusionSupported","fxaaFS","createFXAAStage","createAcesTonemappingStage","useAutoExposure","autoExposure","exposure","createFilmicTonemappingStage","createPbrNeutralTonemappingStage","createReinhardTonemappingStage","createModifiedReinhardTonemappingStage","white","WHITE","createAutoExposureStage","createBlackAndWhiteStage","gradations","createBrightnessStage","createNightVisionStage","createDepthViewStage","createLensFlareStage","dirtTexture","starTexture","distortion","ghostDispersal","haloWidth","dirtAmount","earthRadius","WGS84","maximumRadius"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PostProcessStageLibrary.js"],"sourcesContent":["import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport AcesTonemapping from \"../Shaders/PostProcessStages/AcesTonemappingStage.js\";\nimport AmbientOcclusionGenerate from \"../Shaders/PostProcessStages/AmbientOcclusionGenerate.js\";\nimport AmbientOcclusionModulate from \"../Shaders/PostProcessStages/AmbientOcclusionModulate.js\";\nimport BlackAndWhite from \"../Shaders/PostProcessStages/BlackAndWhite.js\";\nimport BloomComposite from \"../Shaders/PostProcessStages/BloomComposite.js\";\nimport Brightness from \"../Shaders/PostProcessStages/Brightness.js\";\nimport ContrastBias from \"../Shaders/PostProcessStages/ContrastBias.js\";\nimport DepthOfField from \"../Shaders/PostProcessStages/DepthOfField.js\";\nimport DepthView from \"../Shaders/PostProcessStages/DepthView.js\";\nimport EdgeDetection from \"../Shaders/PostProcessStages/EdgeDetection.js\";\nimport FilmicTonemapping from \"../Shaders/PostProcessStages/FilmicTonemapping.js\";\nimport PbrNeutralTonemapping from \"../Shaders/PostProcessStages/PbrNeutralTonemapping.js\";\nimport FXAA from \"../Shaders/PostProcessStages/FXAA.js\";\nimport GaussianBlur1D from \"../Shaders/PostProcessStages/GaussianBlur1D.js\";\nimport LensFlare from \"../Shaders/PostProcessStages/LensFlare.js\";\nimport ModifiedReinhardTonemapping from \"../Shaders/PostProcessStages/ModifiedReinhardTonemapping.js\";\nimport NightVision from \"../Shaders/PostProcessStages/NightVision.js\";\nimport ReinhardTonemapping from \"../Shaders/PostProcessStages/ReinhardTonemapping.js\";\nimport Silhouette from \"../Shaders/PostProcessStages/Silhouette.js\";\nimport FXAA3_11 from \"../Shaders/FXAA3_11.js\";\nimport AutoExposure from \"./AutoExposure.js\";\nimport PostProcessStage from \"./PostProcessStage.js\";\nimport PostProcessStageComposite from \"./PostProcessStageComposite.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\n\n/**\n * Contains functions for creating common post-process stages.\n *\n * @namespace PostProcessStageLibrary\n */\nconst PostProcessStageLibrary = {};\n\nfunction createBlur(name) {\n  const delta = 1.0;\n  const sigma = 2.0;\n  const stepSize = 1.0;\n\n  const blurShader = `#define USE_STEP_SIZE\\n${GaussianBlur1D}`;\n  const blurX = new PostProcessStage({\n    name: `${name}_x_direction`,\n    fragmentShader: blurShader,\n    uniforms: {\n      delta: delta,\n      sigma: sigma,\n      stepSize: stepSize,\n      direction: 0.0,\n    },\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n  const blurY = new PostProcessStage({\n    name: `${name}_y_direction`,\n    fragmentShader: blurShader,\n    uniforms: {\n      delta: delta,\n      sigma: sigma,\n      stepSize: stepSize,\n      direction: 1.0,\n    },\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    delta: {\n      get: function () {\n        return blurX.uniforms.delta;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.delta = blurYUniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blurX.uniforms.sigma;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.sigma = blurYUniforms.sigma = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return blurX.uniforms.stepSize;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.stepSize = blurYUniforms.stepSize = value;\n      },\n    },\n  });\n  return new PostProcessStageComposite({\n    name: name,\n    stages: [blurX, blurY],\n    uniforms: uniforms,\n  });\n}\n\n/**\n * Creates a post-process stage that applies a Gaussian blur to the input texture. This stage is usually applied in conjunction with another stage.\n * <p>\n * This stage has the following uniforms: <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <p>\n * <code>delta</code> and <code>sigma</code> are used to compute the weights of a Gaussian filter. The equation is <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>.\n * The default value for <code>delta</code> is <code>1.0</code>. The default value for <code>sigma</code> is <code>2.0</code>.\n * <code>stepSize</code> is the distance to the next texel. The default is <code>1.0</code>.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies a Gaussian blur to the input texture.\n */\nPostProcessStageLibrary.createBlurStage = function () {\n  return createBlur(\"czm_blur\");\n};\n\n/**\n * Creates a post-process stage that applies a depth of field effect.\n * <p>\n * Depth of field simulates camera focus. Objects in the scene that are in focus\n * will be clear whereas objects not in focus will be blurred.\n * </p>\n * <p>\n * This stage has the following uniforms: <code>focalDistance</code>, <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <p>\n * <code>focalDistance</code> is the distance in meters from the camera to set the camera focus.\n * </p>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * The blur is applied to the areas out of focus.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies a depth of field effect.\n */\nPostProcessStageLibrary.createDepthOfFieldStage = function () {\n  const blur = createBlur(\"czm_depth_of_field_blur\");\n  const dof = new PostProcessStage({\n    name: \"czm_depth_of_field_composite\",\n    fragmentShader: DepthOfField,\n    uniforms: {\n      focalDistance: 5.0,\n      blurTexture: blur.name,\n    },\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    focalDistance: {\n      get: function () {\n        return dof.uniforms.focalDistance;\n      },\n      set: function (value) {\n        dof.uniforms.focalDistance = value;\n      },\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      },\n    },\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_depth_of_field\",\n    stages: [blur, dof],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms,\n  });\n};\n\n/**\n * Whether or not a depth of field stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isDepthOfFieldSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\n/**\n * Creates a post-process stage that detects edges.\n * <p>\n * Writes the color to the output texture with alpha set to 1.0 when it is on an edge.\n * </p>\n * <p>\n * This stage has the following uniforms: <code>color</code> and <code>length</code>\n * </p>\n * <ul>\n * <li><code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.</li>\n * <li><code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.</li>\n * </ul>\n * <p>\n * This stage is not supported in 2D.\n * </p>\n * @return {PostProcessStage} A post-process stage that applies an edge detection effect.\n *\n * @example\n * // multiple silhouette effects\n * const yellowEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * yellowEdge.uniforms.color = Cesium.Color.YELLOW;\n * yellowEdge.selected = [feature0];\n *\n * const greenEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();\n * greenEdge.uniforms.color = Cesium.Color.LIME;\n * greenEdge.selected = [feature1];\n *\n * // draw edges around feature0 and feature1\n * postProcessStages.add(Cesium.PostProcessStageLibrary.createSilhouetteStage([yellowEdge, greenEdge]);\n */\nPostProcessStageLibrary.createEdgeDetectionStage = function () {\n  // unique name generated on call so more than one effect can be added\n  const name = createGuid();\n  return new PostProcessStage({\n    name: `czm_edge_detection_${name}`,\n    fragmentShader: EdgeDetection,\n    uniforms: {\n      length: 0.25,\n      color: Color.clone(Color.BLACK),\n    },\n  });\n};\n\n/**\n * Whether or not an edge detection stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isEdgeDetectionSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\nfunction getSilhouetteEdgeDetection(edgeDetectionStages) {\n  if (!defined(edgeDetectionStages)) {\n    return PostProcessStageLibrary.createEdgeDetectionStage();\n  }\n\n  const edgeDetection = new PostProcessStageComposite({\n    name: \"czm_edge_detection_multiple\",\n    stages: edgeDetectionStages,\n    inputPreviousStageTexture: false,\n  });\n\n  const compositeUniforms = {};\n  let fsDecl = \"\";\n  let fsLoop = \"\";\n  for (let i = 0; i < edgeDetectionStages.length; ++i) {\n    fsDecl += `uniform sampler2D edgeTexture${i}; \\n`;\n    fsLoop +=\n      `        vec4 edge${i} = texture(edgeTexture${i}, v_textureCoordinates); \\n` +\n      `        if (edge${i}.a > 0.0) \\n` +\n      `        { \\n` +\n      `            color = edge${i}; \\n` +\n      `            break; \\n` +\n      `        } \\n`;\n    compositeUniforms[`edgeTexture${i}`] = edgeDetectionStages[i].name;\n  }\n\n  const fs =\n    `${fsDecl}in vec2 v_textureCoordinates; \\n` +\n    `void main() { \\n` +\n    `    vec4 color = vec4(0.0); \\n` +\n    `    for (int i = 0; i < ${edgeDetectionStages.length}; i++) \\n` +\n    `    { \\n${fsLoop}    } \\n` +\n    `    out_FragColor = color; \\n` +\n    `} \\n`;\n\n  const edgeComposite = new PostProcessStage({\n    name: \"czm_edge_detection_combine\",\n    fragmentShader: fs,\n    uniforms: compositeUniforms,\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_edge_detection_composite\",\n    stages: [edgeDetection, edgeComposite],\n  });\n}\n\n/**\n * Creates a post-process stage that applies a silhouette effect.\n * <p>\n * A silhouette effect composites the color from the edge detection pass with input color texture.\n * </p>\n * <p>\n * This stage has the following uniforms when <code>edgeDetectionStages</code> is <code>undefined</code>: <code>color</code> and <code>length</code>\n * </p>\n * <p>\n * <code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.\n * <code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.\n * </p>\n * @param {PostProcessStage[]} [edgeDetectionStages] An array of edge detection post process stages.\n * @return {PostProcessStageComposite} A post-process stage that applies a silhouette effect.\n */\nPostProcessStageLibrary.createSilhouetteStage = function (edgeDetectionStages) {\n  const edgeDetection = getSilhouetteEdgeDetection(edgeDetectionStages);\n  const silhouetteProcess = new PostProcessStage({\n    name: \"czm_silhouette_color_edges\",\n    fragmentShader: Silhouette,\n    uniforms: {\n      silhouetteTexture: edgeDetection.name,\n    },\n  });\n\n  return new PostProcessStageComposite({\n    name: \"czm_silhouette\",\n    stages: [edgeDetection, silhouetteProcess],\n    inputPreviousStageTexture: false,\n    uniforms: edgeDetection.uniforms,\n  });\n};\n\n/**\n * Whether or not a silhouette stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isSilhouetteSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\n/**\n * Creates a post-process stage that applies a bloom effect to the input texture.\n * <p>\n * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.\n * </p>\n * <p>\n * This post-process stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <ul>\n * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>\n * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is\n * added to the brightness. The default value is <code>-0.3</code>.</li>\n * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.\n * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>\n * </ul>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage to applies a bloom effect.\n *\n * @private\n */\nPostProcessStageLibrary.createBloomStage = function () {\n  const contrastBias = new PostProcessStage({\n    name: \"czm_bloom_contrast_bias\",\n    fragmentShader: ContrastBias,\n    uniforms: {\n      contrast: 128.0,\n      brightness: -0.3,\n    },\n  });\n  const blur = createBlur(\"czm_bloom_blur\");\n  const generateComposite = new PostProcessStageComposite({\n    name: \"czm_bloom_contrast_bias_blur\",\n    stages: [contrastBias, blur],\n  });\n\n  const bloomComposite = new PostProcessStage({\n    name: \"czm_bloom_generate_composite\",\n    fragmentShader: BloomComposite,\n    uniforms: {\n      glowOnly: false,\n      bloomTexture: generateComposite.name,\n    },\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    glowOnly: {\n      get: function () {\n        return bloomComposite.uniforms.glowOnly;\n      },\n      set: function (value) {\n        bloomComposite.uniforms.glowOnly = value;\n      },\n    },\n    contrast: {\n      get: function () {\n        return contrastBias.uniforms.contrast;\n      },\n      set: function (value) {\n        contrastBias.uniforms.contrast = value;\n      },\n    },\n    brightness: {\n      get: function () {\n        return contrastBias.uniforms.brightness;\n      },\n      set: function (value) {\n        contrastBias.uniforms.brightness = value;\n      },\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      },\n    },\n  });\n\n  return new PostProcessStageComposite({\n    name: \"czm_bloom\",\n    stages: [generateComposite, bloomComposite],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms,\n  });\n};\n\n/**\n * Creates a post-process stage that Horizon-based Ambient Occlusion (HBAO) to the input texture.\n * <p>\n * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the\n * surface receives light and regardless of the light's position.\n * </p>\n * <p>\n * The uniforms have the following properties:\n * <ul>\n * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>\n * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,\n * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>\n * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,\n * sampling stops in the current direction. The default value is <code>0.26</code>.</li>\n * <li><code>directionCount</code> is the number of directions along which the ray marching will search for occluders. The default value is <code>8</code>.</li>\n * <li><code>stepCount</code> is the number of steps the ray marching will take along each direction. The default value is <code>32</code>.</li>\n * <li><code>randomTexture</code> is a texture where the red channel is a random value in [0.0, 1.0]. The default value is <code>undefined</code>. This texture needs to be set.</li>\n * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated\n * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>\n * </ul>\n * @return {PostProcessStageComposite} A post-process stage that applies an ambient occlusion effect.\n *\n * @private\n */\nPostProcessStageLibrary.createAmbientOcclusionStage = function () {\n  const generate = new PostProcessStage({\n    name: \"czm_ambient_occlusion_generate\",\n    fragmentShader: AmbientOcclusionGenerate,\n    uniforms: {\n      intensity: 3.0,\n      bias: 0.1,\n      lengthCap: 0.26,\n      directionCount: 8,\n      stepCount: 32,\n      randomTexture: undefined,\n    },\n  });\n\n  const ambientOcclusionModulate = new PostProcessStage({\n    name: \"czm_ambient_occlusion_composite\",\n    fragmentShader: AmbientOcclusionModulate,\n    uniforms: {\n      ambientOcclusionOnly: false,\n      ambientOcclusionTexture: generate.name,\n    },\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    intensity: {\n      get: function () {\n        return generate.uniforms.intensity;\n      },\n      set: function (value) {\n        generate.uniforms.intensity = value;\n      },\n    },\n    bias: {\n      get: function () {\n        return generate.uniforms.bias;\n      },\n      set: function (value) {\n        generate.uniforms.bias = value;\n      },\n    },\n    lengthCap: {\n      get: function () {\n        return generate.uniforms.lengthCap;\n      },\n      set: function (value) {\n        generate.uniforms.lengthCap = value;\n      },\n    },\n    directionCount: {\n      get: function () {\n        return generate.uniforms.directionCount;\n      },\n      set: function (value) {\n        generate.uniforms.directionCount = value;\n      },\n    },\n    stepCount: {\n      get: function () {\n        return generate.uniforms.stepCount;\n      },\n      set: function (value) {\n        generate.uniforms.stepCount = value;\n      },\n    },\n    randomTexture: {\n      get: function () {\n        return generate.uniforms.randomTexture;\n      },\n      set: function (value) {\n        generate.uniforms.randomTexture = value;\n      },\n    },\n    ambientOcclusionOnly: {\n      get: function () {\n        return ambientOcclusionModulate.uniforms.ambientOcclusionOnly;\n      },\n      set: function (value) {\n        ambientOcclusionModulate.uniforms.ambientOcclusionOnly = value;\n      },\n    },\n  });\n\n  return new PostProcessStageComposite({\n    name: \"czm_ambient_occlusion\",\n    stages: [generate, ambientOcclusionModulate],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms,\n  });\n};\n\n/**\n * Whether or not an ambient occlusion stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isAmbientOcclusionSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\nconst fxaaFS = `#define FXAA_QUALITY_PRESET 39 \\n${FXAA3_11}\\n${FXAA}`;\n\n/**\n * Creates a post-process stage that applies Fast Approximate Anti-aliasing (FXAA) to the input texture.\n * @return {PostProcessStage} A post-process stage that applies Fast Approximate Anti-aliasing to the input texture.\n *\n * @private\n */\nPostProcessStageLibrary.createFXAAStage = function () {\n  return new PostProcessStage({\n    name: \"czm_FXAA\",\n    fragmentShader: fxaaFS,\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n};\n\n/**\n * Creates a post-process stage that applies ACES tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies ACES tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createAcesTonemappingStage = function (\n  useAutoExposure,\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += AcesTonemapping;\n  return new PostProcessStage({\n    name: \"czm_aces\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies filmic tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies filmic tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createFilmicTonemappingStage = function (\n  useAutoExposure,\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += FilmicTonemapping;\n  return new PostProcessStage({\n    name: \"czm_filmic\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies filmic tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies filmic tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createPbrNeutralTonemappingStage = function (\n  useAutoExposure,\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += PbrNeutralTonemapping;\n  return new PostProcessStage({\n    name: \"czm_pbr_neutral\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies Reinhard tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies Reinhard tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createReinhardTonemappingStage = function (\n  useAutoExposure,\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += ReinhardTonemapping;\n  return new PostProcessStage({\n    name: \"czm_reinhard\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n      exposure: 1.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies modified Reinhard tonemapping operator.\n * @param {boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies modified Reinhard tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createModifiedReinhardTonemappingStage = function (\n  useAutoExposure,\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += ModifiedReinhardTonemapping;\n  return new PostProcessStage({\n    name: \"czm_modified_reinhard\",\n    fragmentShader: fs,\n    uniforms: {\n      white: Color.WHITE,\n      autoExposure: undefined,\n      exposure: 1.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that finds the average luminance of the input texture.\n * @return {PostProcessStage} A post-process stage that finds the average luminance of the input texture.\n * @private\n */\nPostProcessStageLibrary.createAutoExposureStage = function () {\n  return new AutoExposure();\n};\n\n/**\n * Creates a post-process stage that renders the input texture with black and white gradations.\n * <p>\n * This stage has one uniform value, <code>gradations</code>, which scales the luminance of each pixel.\n * </p>\n * @return {PostProcessStage} A post-process stage that renders the input texture with black and white gradations.\n */\nPostProcessStageLibrary.createBlackAndWhiteStage = function () {\n  return new PostProcessStage({\n    name: \"czm_black_and_white\",\n    fragmentShader: BlackAndWhite,\n    uniforms: {\n      gradations: 5.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that saturates the input texture.\n * <p>\n * This stage has one uniform value, <code>brightness</code>, which scales the saturation of each pixel.\n * </p>\n * @return {PostProcessStage} A post-process stage that saturates the input texture.\n */\nPostProcessStageLibrary.createBrightnessStage = function () {\n  return new PostProcessStage({\n    name: \"czm_brightness\",\n    fragmentShader: Brightness,\n    uniforms: {\n      brightness: 0.5,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that adds a night vision effect to the input texture.\n * @return {PostProcessStage} A post-process stage that adds a night vision effect to the input texture.\n */\nPostProcessStageLibrary.createNightVisionStage = function () {\n  return new PostProcessStage({\n    name: \"czm_night_vision\",\n    fragmentShader: NightVision,\n  });\n};\n\n/**\n * Creates a post-process stage that replaces the input color texture with a black and white texture representing the fragment depth at each pixel.\n * @return {PostProcessStage} A post-process stage that replaces the input color texture with a black and white texture representing the fragment depth at each pixel.\n *\n * @private\n */\nPostProcessStageLibrary.createDepthViewStage = function () {\n  return new PostProcessStage({\n    name: \"czm_depth_view\",\n    fragmentShader: DepthView,\n  });\n};\n\n/**\n * Creates a post-process stage that applies an effect simulating light flaring a camera lens.\n * <p>\n * This stage has the following uniforms: <code>dirtTexture</code>, <code>starTexture</code>, <code>intensity</code>, <code>distortion</code>, <code>ghostDispersal</code>,\n * <code>haloWidth</code>, <code>dirtAmount</code>, and <code>earthRadius</code>.\n * <ul>\n * <li><code>dirtTexture</code> is a texture sampled to simulate dirt on the lens.</li>\n * <li><code>starTexture</code> is the texture sampled for the star pattern of the flare.</li>\n * <li><code>intensity</code> is a scalar multiplied by the result of the lens flare. The default value is <code>2.0</code>.</li>\n * <li><code>distortion</code> is a scalar value that affects the chromatic effect distortion. The default value is <code>10.0</code>.</li>\n * <li><code>ghostDispersal</code> is a scalar indicating how far the halo effect is from the center of the texture. The default value is <code>0.4</code>.</li>\n * <li><code>haloWidth</code> is a scalar representing the width of the halo  from the ghost dispersal. The default value is <code>0.4</code>.</li>\n * <li><code>dirtAmount</code> is a scalar representing the amount of dirt on the lens. The default value is <code>0.4</code>.</li>\n * <li><code>earthRadius</code> is the maximum radius of the earth. The default value is <code>Ellipsoid.WGS84.maximumRadius</code>.</li>\n * </ul>\n * </p>\n * @return {PostProcessStage} A post-process stage for applying a lens flare effect.\n */\nPostProcessStageLibrary.createLensFlareStage = function () {\n  return new PostProcessStage({\n    name: \"czm_lens_flare\",\n    fragmentShader: LensFlare,\n    uniforms: {\n      dirtTexture: buildModuleUrl(\"Assets/Textures/LensFlare/DirtMask.jpg\"),\n      starTexture: buildModuleUrl(\"Assets/Textures/LensFlare/StarBurst.jpg\"),\n      intensity: 2.0,\n      distortion: 10.0,\n      ghostDispersal: 0.4,\n      haloWidth: 0.4,\n      dirtAmount: 0.4,\n      earthRadius: Ellipsoid.WGS84.maximumRadius,\n    },\n  });\n};\nexport default PostProcessStageLibrary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}