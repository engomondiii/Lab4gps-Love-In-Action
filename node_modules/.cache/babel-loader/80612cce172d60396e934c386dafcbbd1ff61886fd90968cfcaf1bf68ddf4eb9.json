{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n * @param {number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian4s into an array of components.\n *\n * @param {Cartesian4[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {number[]} The packed array.\n */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 4 elements\");\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n  for (let i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian4s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * const v = [1.0, 2.0, 3.0, 4.0];\n * const p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian4} value The value to clamp.\n * @param {Cartesian4} min The minimum bound.\n * @param {Cartesian4} max The maximum bound.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} The clamped value such that min <= result <= max.\n */\nCartesian4.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n  const w = CesiumMath.clamp(value.w, min.w, max.w);\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\nconst distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian4.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z) || isNaN(result.w)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\nconst lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\nconst mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon);\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nconst scratchF32Array = new Float32Array(1);\nconst scratchU8Array = new Uint8Array(scratchF32Array.buffer);\nconst testU32 = new Uint32Array([0x11223344]);\nconst testU8 = new Uint8Array(testU32.buffer);\nconst littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\nexport default Cartesian4;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","Cartesian4","x","y","z","w","fromElements","result","fromColor","color","typeOf","object","red","green","blue","alpha","clone","cartesian","undefined","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_W","UNIT_Z","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","ONE","prototype","toString","scratchF32Array","Float32Array","scratchU8Array","Uint8Array","buffer","testU32","Uint32Array","testU8","littleEndian","packFloat","unpackFloat","packedFloat"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Cartesian4.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n * @param {number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian4s into an array of components.\n *\n * @param {Cartesian4[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {number[]} The packed array.\n */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian4s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * const v = [1.0, 2.0, 3.0, 4.0];\n * const p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * const p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian4} value The value to clamp.\n * @param {Cartesian4} min The minimum bound.\n * @param {Cartesian4} max The maximum bound.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} The clamped value such that min <= result <= max.\n */\nCartesian4.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n  const w = CesiumMath.clamp(value.w, min.w, max.w);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nconst lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nconst scratchF32Array = new Float32Array(1);\nconst scratchU8Array = new Uint8Array(scratchF32Array.buffer);\n\nconst testU32 = new Uint32Array([0x11223344]);\nconst testU8 = new Uint8Array(testU32.buffer);\nconst littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\nexport default Cartesian4;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}