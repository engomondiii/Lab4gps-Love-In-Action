{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n  // If center was not defined, compute it.\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from its corners.\n *\n * @param {Cartesian3} minimum The minimum point along the x, y, and z axes.\n * @param {Cartesian3} maximum The maximum point along the x, y, and z axes.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box from the two corners.\n * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));\n */\nAxisAlignedBoundingBox.fromCorners = function (minimum, maximum, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"minimum\", minimum);\n  Check.defined(\"maximum\", maximum);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n  result.minimum = Cartesian3.clone(minimum, result.minimum);\n  result.maximum = Cartesian3.clone(maximum, result.maximum);\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n  return result;\n};\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n  let minimumX = positions[0].x;\n  let minimumY = positions[0].y;\n  let minimumZ = positions[0].z;\n  let maximumX = positions[0].x;\n  let maximumY = positions[0].y;\n  let maximumZ = positions[0].z;\n  const length = positions.length;\n  for (let i = 1; i < length; i++) {\n    const p = positions[i];\n    const x = p.x;\n    const y = p.y;\n    const z = p.z;\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n  const minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n  const maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && Cartesian3.equals(left.minimum, right.minimum) && Cartesian3.equals(left.maximum, right.maximum);\n};\nlet intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);\n  const h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n  const normal = plane.normal;\n  const e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n  const s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\nexport default AxisAlignedBoundingBox;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","Intersect","AxisAlignedBoundingBox","minimum","maximum","center","clone","ZERO","midpoint","fromCorners","result","fromPoints","positions","length","minimumX","x","minimumY","y","minimumZ","z","maximumX","maximumY","maximumZ","i","p","Math","min","max","box","undefined","equals","left","right","intersectScratch","intersectPlane","plane","subtract","h","multiplyByScalar","normal","e","abs","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","prototype"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/AxisAlignedBoundingBox.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n  // If center was not defined, compute it.\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from its corners.\n *\n * @param {Cartesian3} minimum The minimum point along the x, y, and z axes.\n * @param {Cartesian3} maximum The maximum point along the x, y, and z axes.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box from the two corners.\n * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));\n */\nAxisAlignedBoundingBox.fromCorners = function (minimum, maximum, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"minimum\", minimum);\n  Check.defined(\"maximum\", maximum);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  result.minimum = Cartesian3.clone(minimum, result.minimum);\n  result.maximum = Cartesian3.clone(maximum, result.maximum);\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n\n  let minimumX = positions[0].x;\n  let minimumY = positions[0].y;\n  let minimumZ = positions[0].z;\n\n  let maximumX = positions[0].x;\n  let maximumY = positions[0].y;\n  let maximumZ = positions[0].z;\n\n  const length = positions.length;\n  for (let i = 1; i < length; i++) {\n    const p = positions[i];\n    const x = p.x;\n    const y = p.y;\n    const z = p.z;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  const minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n\n  const maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Cartesian3.equals(left.minimum, right.minimum) &&\n      Cartesian3.equals(left.maximum, right.maximum))\n  );\n};\n\nlet intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(\n    box.maximum,\n    box.minimum,\n    intersectScratch,\n  );\n  const h = Cartesian3.multiplyByScalar(\n    intersectScratch,\n    0.5,\n    intersectScratch,\n  ); //The positive half diagonal\n  const normal = plane.normal;\n  const e =\n    h.x * Math.abs(normal.x) +\n    h.y * Math.abs(normal.y) +\n    h.z * Math.abs(normal.z);\n  const s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\nexport default AxisAlignedBoundingBox;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}