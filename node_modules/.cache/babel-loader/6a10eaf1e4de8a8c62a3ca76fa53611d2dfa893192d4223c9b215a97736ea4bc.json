{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport createWorldImageryAsync from \"../Scene/createWorldImageryAsync.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport MipmapHint from \"../Renderer/MipmapHint.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ReprojectWebMercatorFS from \"../Shaders/ReprojectWebMercatorFS.js\";\nimport ReprojectWebMercatorVS from \"../Shaders/ReprojectWebMercatorVS.js\";\nimport Imagery from \"./Imagery.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport TileImagery from \"./TileImagery.js\";\n\n/**\n * @typedef {Object} ImageryLayer.ConstructorOptions\n *\n * Initialization options for the ImageryLayer constructor.\n *\n * @property {Rectangle} [rectangle=imageryProvider.rectangle] The rectangle of the layer.  This rectangle\n *        can limit the visible portion of the imagery provider.\n * @property {number|Function} [alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile.\n * @property {number|Function} [nightAlpha=1.0] The alpha blending value of this layer on the night side of the globe, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.\n * @property {number|Function} [dayAlpha=1.0] The alpha blending value of this layer on the day side of the globe, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.\n * @property {number|Function} [brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery\n *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the brightness is required, and it is expected to return\n *                          the brightness value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the contrast is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [hue=0.0] The hue of this layer.  0.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the hue is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [saturation=1.0] The saturation of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the saturation is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the gamma is required, and it is expected to return\n *                          the gamma value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {SplitDirection|Function} [splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this layer.\n * @property {TextureMinificationFilter} [minificationFilter=TextureMinificationFilter.LINEAR] The\n *                                    texture minification filter to apply to this layer. Possible values\n *                                    are <code>TextureMinificationFilter.LINEAR</code> and\n *                                    <code>TextureMinificationFilter.NEAREST</code>.\n * @property {TextureMagnificationFilter} [magnificationFilter=TextureMagnificationFilter.LINEAR] The\n *                                     texture minification filter to apply to this layer. Possible values\n *                                     are <code>TextureMagnificationFilter.LINEAR</code> and\n *                                     <code>TextureMagnificationFilter.NEAREST</code>.\n * @property {boolean} [show=true] True if the layer is shown; otherwise, false.\n * @property {number} [maximumAnisotropy=maximum supported] The maximum anisotropy level to use\n *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported\n *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon\n *        views.\n * @property {number} [minimumTerrainLevel] The minimum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @property {number} [maximumTerrainLevel] The maximum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @property {Rectangle} [cutoutRectangle] Cartographic rectangle for cutting out a portion of this ImageryLayer.\n * @property {Color} [colorToAlpha] Color to be used as alpha.\n * @property {number} [colorToAlphaThreshold=0.004] Threshold for color-to-alpha.\n */\n\n/**\n * An imagery layer that displays tiled image data from a single imagery provider\n * on a {@link Globe}.\n *\n * @alias ImageryLayer\n * @constructor\n *\n * @param {ImageryProvider} [imageryProvider] The imagery provider to use.\n * @param {ImageryLayer.ConstructorOptions} [options] An object describing initialization options\n *\n * @see ImageryLayer.fromProviderAsync\n * @see ImageryLayer.fromWorldImagery\n *\n * @example\n * // Add an OpenStreetMaps layer\n * const imageryLayer = new Cesium.ImageryLayer(new Cesium.OpenStreetMapImageryProvider({\n *   url: \"https://tile.openstreetmap.org/\"\n * }));\n * scene.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Add Cesium ion's default world imagery layer\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * scene.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Add a new transparent layer from Cesium ion\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * imageryLayer.alpha = 0.5;\n * scene.imageryLayers.add(imageryLayer);\n */\nfunction ImageryLayer(imageryProvider, options) {\n  this._imageryProvider = imageryProvider;\n  this._readyEvent = new Event();\n  this._errorEvent = new Event();\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  imageryProvider = defaultValue(imageryProvider, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The alpha blending value of this layer, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {number}\n   * @default 1.0\n   */\n  this.alpha = defaultValue(options.alpha, defaultValue(imageryProvider._defaultAlpha, 1.0));\n\n  /**\n   * The alpha blending value of this layer on the night side of the globe, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.\n   *\n   * @type {number}\n   * @default 1.0\n   */\n  this.nightAlpha = defaultValue(options.nightAlpha, defaultValue(imageryProvider._defaultNightAlpha, 1.0));\n\n  /**\n   * The alpha blending value of this layer on the day side of the globe, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.\n   *\n   * @type {number}\n   * @default 1.0\n   */\n  this.dayAlpha = defaultValue(options.dayAlpha, defaultValue(imageryProvider._defaultDayAlpha, 1.0));\n\n  /**\n   * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_BRIGHTNESS}\n   */\n  this.brightness = defaultValue(options.brightness, defaultValue(imageryProvider._defaultBrightness, ImageryLayer.DEFAULT_BRIGHTNESS));\n\n  /**\n   * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_CONTRAST}\n   */\n  this.contrast = defaultValue(options.contrast, defaultValue(imageryProvider._defaultContrast, ImageryLayer.DEFAULT_CONTRAST));\n\n  /**\n   * The hue of this layer in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_HUE}\n   */\n  this.hue = defaultValue(options.hue, defaultValue(imageryProvider._defaultHue, ImageryLayer.DEFAULT_HUE));\n\n  /**\n   * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_SATURATION}\n   */\n  this.saturation = defaultValue(options.saturation, defaultValue(imageryProvider._defaultSaturation, ImageryLayer.DEFAULT_SATURATION));\n\n  /**\n   * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_GAMMA}\n   */\n  this.gamma = defaultValue(options.gamma, defaultValue(imageryProvider._defaultGamma, ImageryLayer.DEFAULT_GAMMA));\n\n  /**\n   * The {@link SplitDirection} to apply to this layer.\n   *\n   * @type {SplitDirection}\n   * @default {@link ImageryLayer.DEFAULT_SPLIT}\n   */\n  this.splitDirection = defaultValue(options.splitDirection, ImageryLayer.DEFAULT_SPLIT);\n\n  /**\n   * The {@link TextureMinificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)\n   * and {@link TextureMinificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMinificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MINIFICATION_FILTER}\n   */\n  this.minificationFilter = defaultValue(options.minificationFilter, defaultValue(imageryProvider._defaultMinificationFilter, ImageryLayer.DEFAULT_MINIFICATION_FILTER));\n\n  /**\n   * The {@link TextureMagnificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)\n   * and {@link TextureMagnificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MAGNIFICATION_FILTER}\n   */\n  this.magnificationFilter = defaultValue(options.magnificationFilter, defaultValue(imageryProvider._defaultMagnificationFilter, ImageryLayer.DEFAULT_MAGNIFICATION_FILTER));\n\n  /**\n   * Determines if this layer is shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  this._minimumTerrainLevel = options.minimumTerrainLevel;\n  this._maximumTerrainLevel = options.maximumTerrainLevel;\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._maximumAnisotropy = options.maximumAnisotropy;\n  this._imageryCache = {};\n  this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this));\n\n  // The value of the show property on the last update.\n  this._show = true;\n\n  // The index of this layer in the ImageryLayerCollection.\n  this._layerIndex = -1;\n\n  // true if this is the base (lowest shown) layer.\n  this._isBaseLayer = false;\n  this._requestImageError = undefined;\n  this._reprojectComputeCommands = [];\n\n  /**\n   * Rectangle cutout in this layer of imagery.\n   *\n   * @type {Rectangle}\n   */\n  this.cutoutRectangle = options.cutoutRectangle;\n\n  /**\n   * Color value that should be set to transparent.\n   *\n   * @type {Color}\n   */\n  this.colorToAlpha = options.colorToAlpha;\n\n  /**\n   * Normalized (0-1) threshold for color-to-alpha.\n   *\n   * @type {number}\n   */\n  this.colorToAlphaThreshold = defaultValue(options.colorToAlphaThreshold, ImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD);\n}\nObject.defineProperties(ImageryLayer.prototype, {\n  /**\n   * Gets the imagery provider for this layer. This should not be called before {@link ImageryLayer#ready} returns true.\n   * @memberof ImageryLayer.prototype\n   * @type {ImageryProvider}\n   * @readonly\n   */\n  imageryProvider: {\n    get: function () {\n      return this._imageryProvider;\n    }\n  },\n  /**\n   * Returns true when the terrain provider has been successfully created. Otherwise, returns false.\n   * @memberof ImageryLayer.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return defined(this._imageryProvider);\n    }\n  },\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of the thrown error.\n   * @memberof Imagery.prototype\n   * @type {Event<Imagery.ErrorEventCallback>}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n  /**\n   * Gets an event that is raised when the imagery provider has been successfully created. Event listeners\n   * are passed the created instance of {@link ImageryProvider}.\n   * @memberof ImageryLayer.prototype\n   * @type {Event<ImageryLayer.ReadyEventCallback>}\n   * @readonly\n   */\n  readyEvent: {\n    get: function () {\n      return this._readyEvent;\n    }\n  },\n  /**\n   * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the\n   * {@link ImageryProvider}, only a portion of the imagery provider is shown.\n   * @memberof ImageryLayer.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    }\n  }\n});\n\n/**\n * This value is used as the default brightness for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the brightness of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_BRIGHTNESS = 1.0;\n/**\n * This value is used as the default contrast for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the contrast of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_CONTRAST = 1.0;\n/**\n * This value is used as the default hue for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the hue of the imagery.\n * @type {number}\n * @default 0.0\n */\nImageryLayer.DEFAULT_HUE = 0.0;\n/**\n * This value is used as the default saturation for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the saturation of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_SATURATION = 1.0;\n/**\n * This value is used as the default gamma for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the gamma of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_GAMMA = 1.0;\n\n/**\n * This value is used as the default split for the imagery layer if one is not provided during construction\n * or by the imagery provider.\n * @type {SplitDirection}\n * @default SplitDirection.NONE\n */\nImageryLayer.DEFAULT_SPLIT = SplitDirection.NONE;\n\n/**\n * This value is used as the default texture minification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMinificationFilter}\n * @default TextureMinificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MINIFICATION_FILTER = TextureMinificationFilter.LINEAR;\n\n/**\n * This value is used as the default texture magnification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMagnificationFilter}\n * @default TextureMagnificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MAGNIFICATION_FILTER = TextureMagnificationFilter.LINEAR;\n\n/**\n * This value is used as the default threshold for color-to-alpha if one is not provided\n * during construction or by the imagery provider.\n * @type {number}\n * @default 0.004\n */\nImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = 0.004;\n\n/**\n * Create a new imagery layer from an asynchronous imagery provider. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.\n *\n * @param {Promise<ImageryProvider>} imageryProviderPromise A promise which resolves to a imagery provider\n * @param {ImageryLayer.ConstructorOptions} options An object describing initialization options\n * @returns {ImageryLayer} The created imagery layer.\n *\n * @example\n * // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * });\n *\n * @example\n * // Add a new transparent layer\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * imageryLayer.alpha = 0.5;\n * viewer.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Handle loading events\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * viewer.imageryLayers.add(imageryLayer);\n *\n * imageryLayer.readyEvent.addEventListener(provider => {\n *   imageryLayer.provider.errorEvent.addEventListener(error => {\n *     alert(`Encountered an error while loading imagery tiles! ${error}`);\n *   });\n * });\n *\n * imageryLayer.errorEvent.addEventListener(error => {\n *   alert(`Encountered an error while creating an imagery layer! ${error}`);\n * });\n *\n * @see ImageryLayer.errorEvent\n * @see ImageryLayer.readyEvent\n * @see ImageryLayer.provider\n * @see ImageryLayer.fromWorldImagery\n */\nImageryLayer.fromProviderAsync = function (imageryProviderPromise, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"imageryProviderPromise\", imageryProviderPromise);\n  //>>includeEnd('debug');\n\n  const layer = new ImageryLayer(undefined, options);\n  handlePromise(layer, Promise.resolve(imageryProviderPromise));\n  return layer;\n};\n\n/**\n * @typedef {ImageryLayer.ConstructorOptions} ImageryLayer.WorldImageryConstructorOptions\n *\n * Initialization options for ImageryLayer.fromWorldImagery\n *\n * @property {IonWorldImageryStyle} [options.style=IonWorldImageryStyle] The style of base imagery, only AERIAL, AERIAL_WITH_LABELS, and ROAD are currently supported.\n */\n\n/**\n * Create a new imagery layer for ion's default global base imagery layer, currently Bing Maps. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.\n *\n * @param {ImageryLayer.WorldImageryConstructorOptions} options An object describing initialization options\n * @returns {ImageryLayer} The created imagery layer.\n *\n * * @example\n * // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromWorldImagery();\n * });\n *\n * @example\n * // Add a new transparent layer\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * imageryLayer.alpha = 0.5;\n * viewer.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Handle loading events\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * viewer.imageryLayers.add(imageryLayer);\n *\n * imageryLayer.readyEvent.addEventListener(provider => {\n *   imageryLayer.provider.errorEvent.addEventListener(error => {\n *     alert(`Encountered an error while loading imagery tiles! ${error}`);\n *   });\n * });\n *\n * imageryLayer.errorEvent.addEventListener(error => {\n *   alert(`Encountered an error while creating an imagery layer! ${error}`);\n * });\n *\n * @see ImageryLayer.errorEvent\n * @see ImageryLayer.readyEvent\n * @see ImageryLayer.provider\n */\nImageryLayer.fromWorldImagery = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  return ImageryLayer.fromProviderAsync(createWorldImageryAsync({\n    style: options.style\n  }), options);\n};\n\n/**\n * Gets a value indicating whether this layer is the base layer in the\n * {@link ImageryLayerCollection}.  The base layer is the one that underlies all\n * others.  It is special in that it is treated as if it has global rectangle, even if\n * it actually does not, by stretching the texels at the edges over the entire\n * globe.\n *\n * @returns {boolean} true if this is the base layer; otherwise, false.\n */\nImageryLayer.prototype.isBaseLayer = function () {\n  return this._isBaseLayer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayer#destroy\n */\nImageryLayer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n * @see ImageryLayer#isDestroyed\n */\nImageryLayer.prototype.destroy = function () {\n  return destroyObject(this);\n};\nconst imageryBoundsScratch = new Rectangle();\nconst tileImageryBoundsScratch = new Rectangle();\nconst clippedRectangleScratch = new Rectangle();\nconst terrainRectangleScratch = new Rectangle();\n\n/**\n * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,\n * producing the overall bounds of imagery that can be produced by this layer.\n *\n * @returns {Rectangle} A rectangle which defines the overall bounds of imagery that can be produced by this layer.\n *\n * @example\n * // Zoom to an imagery layer.\n * const imageryRectangle = imageryLayer.getImageryRectangle();\n * scene.camera.flyTo({\n *     destination: rectangle\n * });\n *\n */\nImageryLayer.prototype.getImageryRectangle = function () {\n  const imageryProvider = this._imageryProvider;\n  const rectangle = this._rectangle;\n  return Rectangle.intersection(imageryProvider.rectangle, rectangle);\n};\n\n/**\n * Create skeletons for the imagery tiles that partially or completely overlap a given terrain\n * tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TerrainProvider|undefined} terrainProvider The terrain provider associated with the terrain tile.\n * @param {number} insertionPoint The position to insert new skeletons before in the tile's imagery list.\n * @returns {boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.\n */\nImageryLayer.prototype._createTileImagerySkeletons = function (tile, terrainProvider, insertionPoint) {\n  const surfaceTile = tile.data;\n  if (!defined(terrainProvider) || defined(this._minimumTerrainLevel) && tile.level < this._minimumTerrainLevel) {\n    return false;\n  }\n  if (defined(this._maximumTerrainLevel) && tile.level > this._maximumTerrainLevel) {\n    return false;\n  }\n  if (!defined(insertionPoint)) {\n    insertionPoint = surfaceTile.imagery.length;\n  }\n  const imageryProvider = this._imageryProvider;\n  if (!this.ready) {\n    // The imagery provider is not ready, so we can't create skeletons, yet.\n    // Instead, add a placeholder so that we'll know to create\n    // the skeletons once the provider is ready.\n    this._skeletonPlaceholder.loadingImagery.addReference();\n    surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);\n    return true;\n  }\n\n  // Use Web Mercator for our texture coordinate computations if this imagery layer uses\n  // that projection and the terrain tile falls entirely inside the valid bounds of the\n  // projection.\n  const useWebMercatorT = imageryProvider.tilingScheme.projection instanceof WebMercatorProjection && tile.rectangle.north < WebMercatorProjection.MaximumLatitude && tile.rectangle.south > -WebMercatorProjection.MaximumLatitude;\n\n  // Compute the rectangle of the imagery from this imageryProvider that overlaps\n  // the geometry tile.  The ImageryProvider and ImageryLayer both have the\n  // opportunity to constrain the rectangle.  The imagery TilingScheme's rectangle\n  // always fully contains the ImageryProvider's rectangle.\n  const imageryBounds = Rectangle.intersection(imageryProvider.rectangle, this._rectangle, imageryBoundsScratch);\n  let rectangle = Rectangle.intersection(tile.rectangle, imageryBounds, tileImageryBoundsScratch);\n  if (!defined(rectangle)) {\n    // There is no overlap between this terrain tile and this imagery\n    // provider.  Unless this is the base layer, no skeletons need to be created.\n    // We stretch texels at the edge of the base layer over the entire globe.\n    if (!this.isBaseLayer()) {\n      return false;\n    }\n    const baseImageryRectangle = imageryBounds;\n    const baseTerrainRectangle = tile.rectangle;\n    rectangle = tileImageryBoundsScratch;\n    if (baseTerrainRectangle.south >= baseImageryRectangle.north) {\n      rectangle.north = rectangle.south = baseImageryRectangle.north;\n    } else if (baseTerrainRectangle.north <= baseImageryRectangle.south) {\n      rectangle.north = rectangle.south = baseImageryRectangle.south;\n    } else {\n      rectangle.south = Math.max(baseTerrainRectangle.south, baseImageryRectangle.south);\n      rectangle.north = Math.min(baseTerrainRectangle.north, baseImageryRectangle.north);\n    }\n    if (baseTerrainRectangle.west >= baseImageryRectangle.east) {\n      rectangle.west = rectangle.east = baseImageryRectangle.east;\n    } else if (baseTerrainRectangle.east <= baseImageryRectangle.west) {\n      rectangle.west = rectangle.east = baseImageryRectangle.west;\n    } else {\n      rectangle.west = Math.max(baseTerrainRectangle.west, baseImageryRectangle.west);\n      rectangle.east = Math.min(baseTerrainRectangle.east, baseImageryRectangle.east);\n    }\n  }\n  let latitudeClosestToEquator = 0.0;\n  if (rectangle.south > 0.0) {\n    latitudeClosestToEquator = rectangle.south;\n  } else if (rectangle.north < 0.0) {\n    latitudeClosestToEquator = rectangle.north;\n  }\n\n  // Compute the required level in the imagery tiling scheme.\n  // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.\n  // But first we need configurable imagery SSE and we need the rendering to be able to handle more\n  // images attached to a terrain tile than there are available texture units.  So that's for the future.\n  const errorRatio = 1.0;\n  const targetGeometricError = errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);\n  let imageryLevel = getLevelWithMaximumTexelSpacing(this, targetGeometricError, latitudeClosestToEquator);\n  imageryLevel = Math.max(0, imageryLevel);\n  const maximumLevel = imageryProvider.maximumLevel;\n  if (imageryLevel > maximumLevel) {\n    imageryLevel = maximumLevel;\n  }\n  if (defined(imageryProvider.minimumLevel)) {\n    const minimumLevel = imageryProvider.minimumLevel;\n    if (imageryLevel < minimumLevel) {\n      imageryLevel = minimumLevel;\n    }\n  }\n  const imageryTilingScheme = imageryProvider.tilingScheme;\n  const northwestTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.northwest(rectangle), imageryLevel);\n  const southeastTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.southeast(rectangle), imageryLevel);\n\n  // If the southeast corner of the rectangle lies very close to the north or west side\n  // of the southeast tile, we don't actually need the southernmost or easternmost\n  // tiles.\n  // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n  // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n\n  // We define \"very close\" as being within 1/512 of the width of the tile.\n  let veryCloseX = tile.rectangle.width / 512.0;\n  let veryCloseY = tile.rectangle.height / 512.0;\n  const northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);\n  if (Math.abs(northwestTileRectangle.south - tile.rectangle.north) < veryCloseY && northwestTileCoordinates.y < southeastTileCoordinates.y) {\n    ++northwestTileCoordinates.y;\n  }\n  if (Math.abs(northwestTileRectangle.east - tile.rectangle.west) < veryCloseX && northwestTileCoordinates.x < southeastTileCoordinates.x) {\n    ++northwestTileCoordinates.x;\n  }\n  const southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(southeastTileCoordinates.x, southeastTileCoordinates.y, imageryLevel);\n  if (Math.abs(southeastTileRectangle.north - tile.rectangle.south) < veryCloseY && southeastTileCoordinates.y > northwestTileCoordinates.y) {\n    --southeastTileCoordinates.y;\n  }\n  if (Math.abs(southeastTileRectangle.west - tile.rectangle.east) < veryCloseX && southeastTileCoordinates.x > northwestTileCoordinates.x) {\n    --southeastTileCoordinates.x;\n  }\n\n  // Create TileImagery instances for each imagery tile overlapping this terrain tile.\n  // We need to do all texture coordinate computations in the imagery tile's tiling scheme.\n\n  const terrainRectangle = Rectangle.clone(tile.rectangle, terrainRectangleScratch);\n  let imageryRectangle = imageryTilingScheme.tileXYToRectangle(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);\n  let clippedImageryRectangle = Rectangle.intersection(imageryRectangle, imageryBounds, clippedRectangleScratch);\n  let imageryTileXYToRectangle;\n  if (useWebMercatorT) {\n    imageryTilingScheme.rectangleToNativeRectangle(terrainRectangle, terrainRectangle);\n    imageryTilingScheme.rectangleToNativeRectangle(imageryRectangle, imageryRectangle);\n    imageryTilingScheme.rectangleToNativeRectangle(clippedImageryRectangle, clippedImageryRectangle);\n    imageryTilingScheme.rectangleToNativeRectangle(imageryBounds, imageryBounds);\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToNativeRectangle.bind(imageryTilingScheme);\n    veryCloseX = terrainRectangle.width / 512.0;\n    veryCloseY = terrainRectangle.height / 512.0;\n  } else {\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToRectangle.bind(imageryTilingScheme);\n  }\n  let minU;\n  let maxU = 0.0;\n  let minV = 1.0;\n  let maxV;\n\n  // If this is the northern-most or western-most tile in the imagery tiling scheme,\n  // it may not start at the northern or western edge of the terrain tile.\n  // Calculate where it does start.\n  if (!this.isBaseLayer() && Math.abs(clippedImageryRectangle.west - terrainRectangle.west) >= veryCloseX) {\n    maxU = Math.min(1.0, (clippedImageryRectangle.west - terrainRectangle.west) / terrainRectangle.width);\n  }\n  if (!this.isBaseLayer() && Math.abs(clippedImageryRectangle.north - terrainRectangle.north) >= veryCloseY) {\n    minV = Math.max(0.0, (clippedImageryRectangle.north - terrainRectangle.south) / terrainRectangle.height);\n  }\n  const initialMinV = minV;\n  for (let i = northwestTileCoordinates.x; i <= southeastTileCoordinates.x; i++) {\n    minU = maxU;\n    imageryRectangle = imageryTileXYToRectangle(i, northwestTileCoordinates.y, imageryLevel);\n    clippedImageryRectangle = Rectangle.simpleIntersection(imageryRectangle, imageryBounds, clippedRectangleScratch);\n    if (!defined(clippedImageryRectangle)) {\n      continue;\n    }\n    maxU = Math.min(1.0, (clippedImageryRectangle.east - terrainRectangle.west) / terrainRectangle.width);\n\n    // If this is the eastern-most imagery tile mapped to this terrain tile,\n    // and there are more imagery tiles to the east of this one, the maxU\n    // should be 1.0 to make sure rounding errors don't make the last\n    // image fall shy of the edge of the terrain tile.\n    if (i === southeastTileCoordinates.x && (this.isBaseLayer() || Math.abs(clippedImageryRectangle.east - terrainRectangle.east) < veryCloseX)) {\n      maxU = 1.0;\n    }\n    minV = initialMinV;\n    for (let j = northwestTileCoordinates.y; j <= southeastTileCoordinates.y; j++) {\n      maxV = minV;\n      imageryRectangle = imageryTileXYToRectangle(i, j, imageryLevel);\n      clippedImageryRectangle = Rectangle.simpleIntersection(imageryRectangle, imageryBounds, clippedRectangleScratch);\n      if (!defined(clippedImageryRectangle)) {\n        continue;\n      }\n      minV = Math.max(0.0, (clippedImageryRectangle.south - terrainRectangle.south) / terrainRectangle.height);\n\n      // If this is the southern-most imagery tile mapped to this terrain tile,\n      // and there are more imagery tiles to the south of this one, the minV\n      // should be 0.0 to make sure rounding errors don't make the last\n      // image fall shy of the edge of the terrain tile.\n      if (j === southeastTileCoordinates.y && (this.isBaseLayer() || Math.abs(clippedImageryRectangle.south - terrainRectangle.south) < veryCloseY)) {\n        minV = 0.0;\n      }\n      const texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);\n      const imagery = this.getImageryFromCache(i, j, imageryLevel);\n      surfaceTile.imagery.splice(insertionPoint, 0, new TileImagery(imagery, texCoordsRectangle, useWebMercatorT));\n      ++insertionPoint;\n    }\n  }\n  return true;\n};\n\n/**\n * Calculate the translation and scale for a particular {@link TileImagery} attached to a\n * particular terrain tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TileImagery} tileImagery The imagery tile mapping.\n * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W\n *          are the scale.\n */\nImageryLayer.prototype._calculateTextureTranslationAndScale = function (tile, tileImagery) {\n  let imageryRectangle = tileImagery.readyImagery.rectangle;\n  let terrainRectangle = tile.rectangle;\n  if (tileImagery.useWebMercatorT) {\n    const tilingScheme = tileImagery.readyImagery.imageryLayer.imageryProvider.tilingScheme;\n    imageryRectangle = tilingScheme.rectangleToNativeRectangle(imageryRectangle, imageryBoundsScratch);\n    terrainRectangle = tilingScheme.rectangleToNativeRectangle(terrainRectangle, terrainRectangleScratch);\n  }\n  const terrainWidth = terrainRectangle.width;\n  const terrainHeight = terrainRectangle.height;\n  const scaleX = terrainWidth / imageryRectangle.width;\n  const scaleY = terrainHeight / imageryRectangle.height;\n  return new Cartesian4(scaleX * (terrainRectangle.west - imageryRectangle.west) / terrainWidth, scaleY * (terrainRectangle.south - imageryRectangle.south) / terrainHeight, scaleX, scaleY);\n};\n\n/**\n * Request a particular piece of imagery from the imagery provider.  This method handles raising an\n * error event if the request fails, and retrying the request if necessary.\n *\n * @private\n *\n * @param {Imagery} imagery The imagery to request.\n */\nImageryLayer.prototype._requestImagery = function (imagery) {\n  const imageryProvider = this._imageryProvider;\n  const that = this;\n  function success(image) {\n    if (!defined(image)) {\n      return failure();\n    }\n    imagery.image = image;\n    imagery.state = ImageryState.RECEIVED;\n    imagery.request = undefined;\n    TileProviderError.reportSuccess(that._requestImageError);\n  }\n  function failure(e) {\n    if (imagery.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    // Initially assume failure. An error handler may retry, in which case the state will\n    // change to TRANSITIONING.\n    imagery.state = ImageryState.FAILED;\n    imagery.request = undefined;\n    const message = `Failed to obtain image tile X: ${imagery.x} Y: ${imagery.y} Level: ${imagery.level}.`;\n    that._requestImageError = TileProviderError.reportError(that._requestImageError, imageryProvider, imageryProvider.errorEvent, message, imagery.x, imagery.y, imagery.level, e);\n    if (that._requestImageError.retry) {\n      doRequest();\n    }\n  }\n  function doRequest() {\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.IMAGERY\n    });\n    imagery.request = request;\n    imagery.state = ImageryState.TRANSITIONING;\n    const imagePromise = imageryProvider.requestImage(imagery.x, imagery.y, imagery.level, request);\n    if (!defined(imagePromise)) {\n      // Too many parallel requests, so postpone loading tile.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n    if (defined(imageryProvider.getTileCredits)) {\n      imagery.credits = imageryProvider.getTileCredits(imagery.x, imagery.y, imagery.level);\n    }\n    imagePromise.then(function (image) {\n      success(image);\n    }).catch(function (e) {\n      failure(e);\n    });\n  }\n  doRequest();\n};\nImageryLayer.prototype._createTextureWebGL = function (context, imagery) {\n  const sampler = new Sampler({\n    minificationFilter: this.minificationFilter,\n    magnificationFilter: this.magnificationFilter\n  });\n  const image = imagery.image;\n  if (defined(image.internalFormat)) {\n    return new Texture({\n      context: context,\n      pixelFormat: image.internalFormat,\n      width: image.width,\n      height: image.height,\n      source: {\n        arrayBufferView: image.bufferView\n      },\n      sampler: sampler\n    });\n  }\n  return new Texture({\n    context: context,\n    source: image,\n    pixelFormat: this._imageryProvider.hasAlphaChannel ? PixelFormat.RGBA : PixelFormat.RGB,\n    sampler: sampler\n  });\n};\n\n/**\n * Create a WebGL texture for a given {@link Imagery} instance.\n *\n * @private\n *\n * @param {Context} context The rendered context to use to create textures.\n * @param {Imagery} imagery The imagery for which to create a texture.\n */\nImageryLayer.prototype._createTexture = function (context, imagery) {\n  const imageryProvider = this._imageryProvider;\n  const image = imagery.image;\n\n  // If this imagery provider has a discard policy, use it to check if this\n  // image should be discarded.\n  if (defined(imageryProvider.tileDiscardPolicy)) {\n    const discardPolicy = imageryProvider.tileDiscardPolicy;\n    if (defined(discardPolicy)) {\n      // If the discard policy is not ready yet, transition back to the\n      // RECEIVED state and we'll try again next time.\n      if (!discardPolicy.isReady()) {\n        imagery.state = ImageryState.RECEIVED;\n        return;\n      }\n\n      // Mark discarded imagery tiles invalid.  Parent imagery will be used instead.\n      if (discardPolicy.shouldDiscardImage(image)) {\n        imagery.state = ImageryState.INVALID;\n        return;\n      }\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (this.minificationFilter !== TextureMinificationFilter.NEAREST && this.minificationFilter !== TextureMinificationFilter.LINEAR) {\n    throw new DeveloperError(\"ImageryLayer minification filter must be NEAREST or LINEAR\");\n  }\n  //>>includeEnd('debug');\n\n  // Imagery does not need to be discarded, so upload it to WebGL.\n  const texture = this._createTextureWebGL(context, imagery);\n  if (imageryProvider.tilingScheme.projection instanceof WebMercatorProjection) {\n    imagery.textureWebMercator = texture;\n  } else {\n    imagery.texture = texture;\n  }\n  imagery.image = undefined;\n  imagery.state = ImageryState.TEXTURE_LOADED;\n};\nfunction getSamplerKey(minificationFilter, magnificationFilter, maximumAnisotropy) {\n  return `${minificationFilter}:${magnificationFilter}:${maximumAnisotropy}`;\n}\nImageryLayer.prototype._finalizeReprojectTexture = function (context, texture) {\n  let minificationFilter = this.minificationFilter;\n  const magnificationFilter = this.magnificationFilter;\n  const usesLinearTextureFilter = minificationFilter === TextureMinificationFilter.LINEAR && magnificationFilter === TextureMagnificationFilter.LINEAR;\n  // Use mipmaps if this texture has power-of-two dimensions.\n  // In addition, mipmaps are only generated if the texture filters are both LINEAR.\n  if (usesLinearTextureFilter && !PixelFormat.isCompressedFormat(texture.pixelFormat) && CesiumMath.isPowerOfTwo(texture.width) && CesiumMath.isPowerOfTwo(texture.height)) {\n    minificationFilter = TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n    const maximumSupportedAnisotropy = ContextLimits.maximumTextureFilterAnisotropy;\n    const maximumAnisotropy = Math.min(maximumSupportedAnisotropy, defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy));\n    const mipmapSamplerKey = getSamplerKey(minificationFilter, magnificationFilter, maximumAnisotropy);\n    let mipmapSamplers = context.cache.imageryLayerMipmapSamplers;\n    if (!defined(mipmapSamplers)) {\n      mipmapSamplers = {};\n      context.cache.imageryLayerMipmapSamplers = mipmapSamplers;\n    }\n    let mipmapSampler = mipmapSamplers[mipmapSamplerKey];\n    if (!defined(mipmapSampler)) {\n      mipmapSampler = mipmapSamplers[mipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n        maximumAnisotropy: maximumAnisotropy\n      });\n    }\n    texture.generateMipmap(MipmapHint.NICEST);\n    texture.sampler = mipmapSampler;\n  } else {\n    const nonMipmapSamplerKey = getSamplerKey(minificationFilter, magnificationFilter, 0);\n    let nonMipmapSamplers = context.cache.imageryLayerNonMipmapSamplers;\n    if (!defined(nonMipmapSamplers)) {\n      nonMipmapSamplers = {};\n      context.cache.imageryLayerNonMipmapSamplers = nonMipmapSamplers;\n    }\n    let nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey];\n    if (!defined(nonMipmapSampler)) {\n      nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter\n      });\n    }\n    texture.sampler = nonMipmapSampler;\n  }\n};\n\n/**\n * Enqueues a command re-projecting a texture to a {@link GeographicProjection} on the next update, if necessary, and generate\n * mipmaps for the geographic texture.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n * @param {Imagery} imagery The imagery instance to reproject.\n * @param {boolean} [needGeographicProjection=true] True to reproject to geographic, or false if Web Mercator is fine.\n */\nImageryLayer.prototype._reprojectTexture = function (frameState, imagery, needGeographicProjection) {\n  const texture = imagery.textureWebMercator || imagery.texture;\n  const rectangle = imagery.rectangle;\n  const context = frameState.context;\n  needGeographicProjection = defaultValue(needGeographicProjection, true);\n\n  // Reproject this texture if it is not already in a geographic projection and\n  // the pixels are more than 1e-5 radians apart.  The pixel spacing cutoff\n  // avoids precision problems in the reprojection transformation while making\n  // no noticeable difference in the georeferencing of the image.\n  if (needGeographicProjection && !(this._imageryProvider.tilingScheme.projection instanceof GeographicProjection) && rectangle.width / texture.width > 1e-5) {\n    const that = this;\n    imagery.addReference();\n    const computeCommand = new ComputeCommand({\n      persists: true,\n      owner: this,\n      // Update render resources right before execution instead of now.\n      // This allows different ImageryLayers to share the same vao and buffers.\n      preExecute: function (command) {\n        reprojectToGeographic(command, context, texture, imagery.rectangle);\n      },\n      postExecute: function (outputTexture) {\n        imagery.texture = outputTexture;\n        that._finalizeReprojectTexture(context, outputTexture);\n        imagery.state = ImageryState.READY;\n        imagery.releaseReference();\n      },\n      canceled: function () {\n        imagery.state = ImageryState.TEXTURE_LOADED;\n        imagery.releaseReference();\n      }\n    });\n    this._reprojectComputeCommands.push(computeCommand);\n  } else {\n    if (needGeographicProjection) {\n      imagery.texture = texture;\n    }\n    this._finalizeReprojectTexture(context, texture);\n    imagery.state = ImageryState.READY;\n  }\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayer.prototype.queueReprojectionCommands = function (frameState) {\n  const computeCommands = this._reprojectComputeCommands;\n  const length = computeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    frameState.commandList.push(computeCommands[i]);\n  }\n  computeCommands.length = 0;\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayer.prototype.cancelReprojections = function () {\n  this._reprojectComputeCommands.forEach(function (command) {\n    if (defined(command.canceled)) {\n      command.canceled();\n    }\n  });\n  this._reprojectComputeCommands.length = 0;\n};\nImageryLayer.prototype.getImageryFromCache = function (x, y, level, imageryRectangle) {\n  const cacheKey = getImageryCacheKey(x, y, level);\n  let imagery = this._imageryCache[cacheKey];\n  if (!defined(imagery)) {\n    imagery = new Imagery(this, x, y, level, imageryRectangle);\n    this._imageryCache[cacheKey] = imagery;\n  }\n  imagery.addReference();\n  return imagery;\n};\nImageryLayer.prototype.removeImageryFromCache = function (imagery) {\n  const cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);\n  delete this._imageryCache[cacheKey];\n};\nfunction getImageryCacheKey(x, y, level) {\n  return JSON.stringify([x, y, level]);\n}\nconst uniformMap = {\n  u_textureDimensions: function () {\n    return this.textureDimensions;\n  },\n  u_texture: function () {\n    return this.texture;\n  },\n  textureDimensions: new Cartesian2(),\n  texture: undefined\n};\nconst float32ArrayScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(2 * 64) : undefined;\nfunction reprojectToGeographic(command, context, texture, rectangle) {\n  // This function has gone through a number of iterations, because GPUs are awesome.\n  //\n  // Originally, we had a very simple vertex shader and computed the Web Mercator texture coordinates\n  // per-fragment in the fragment shader.  That worked well, except on mobile devices, because\n  // fragment shaders have limited precision on many mobile devices.  The result was smearing artifacts\n  // at medium zoom levels because different geographic texture coordinates would be reprojected to Web\n  // Mercator as the same value.\n  //\n  // Our solution was to reproject to Web Mercator in the vertex shader instead of the fragment shader.\n  // This required far more vertex data.  With fragment shader reprojection, we only needed a single quad.\n  // But to achieve the same precision with vertex shader reprojection, we needed a vertex for each\n  // output pixel.  So we used a grid of 256x256 vertices, because most of our imagery\n  // tiles are 256x256.  Fortunately the grid could be created and uploaded to the GPU just once and\n  // re-used for all reprojections, so the performance was virtually unchanged from our original fragment\n  // shader approach.  See https://github.com/CesiumGS/cesium/pull/714.\n  //\n  // Over a year later, we noticed (https://github.com/CesiumGS/cesium/issues/2110)\n  // that our reprojection code was creating a rare but severe artifact on some GPUs (Intel HD 4600\n  // for one).  The problem was that the GLSL sin function on these GPUs had a discontinuity at fine scales in\n  // a few places.\n  //\n  // We solved this by implementing a more reliable sin function based on the CORDIC algorithm\n  // (https://github.com/CesiumGS/cesium/pull/2111).  Even though this was a fair\n  // amount of code to be executing per vertex, the performance seemed to be pretty good on most GPUs.\n  // Unfortunately, on some GPUs, the performance was absolutely terrible\n  // (https://github.com/CesiumGS/cesium/issues/2258).\n  //\n  // So that brings us to our current solution, the one you see here.  Effectively, we compute the Web\n  // Mercator texture coordinates on the CPU and store the T coordinate with each vertex (the S coordinate\n  // is the same in Geographic and Web Mercator).  To make this faster, we reduced our reprojection mesh\n  // to be only 2 vertices wide and 64 vertices high.  We should have reduced the width to 2 sooner,\n  // because the extra vertices weren't buying us anything.  The height of 64 means we are technically\n  // doing a slightly less accurate reprojection than we were before, but we can't see the difference\n  // so it's worth the 4x speedup.\n\n  let reproject = context.cache.imageryLayer_reproject;\n  if (!defined(reproject)) {\n    reproject = context.cache.imageryLayer_reproject = {\n      vertexArray: undefined,\n      shaderProgram: undefined,\n      sampler: undefined,\n      destroy: function () {\n        if (defined(this.framebuffer)) {\n          this.framebuffer.destroy();\n        }\n        if (defined(this.vertexArray)) {\n          this.vertexArray.destroy();\n        }\n        if (defined(this.shaderProgram)) {\n          this.shaderProgram.destroy();\n        }\n      }\n    };\n    const positions = new Float32Array(2 * 64 * 2);\n    let index = 0;\n    for (let j = 0; j < 64; ++j) {\n      const y = j / 63.0;\n      positions[index++] = 0.0;\n      positions[index++] = y;\n      positions[index++] = 1.0;\n      positions[index++] = y;\n    }\n    const reprojectAttributeIndices = {\n      position: 0,\n      webMercatorT: 1\n    };\n    const indices = TerrainProvider.getRegularGridIndices(2, 64);\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.UNSIGNED_SHORT\n    });\n    reproject.vertexArray = new VertexArray({\n      context: context,\n      attributes: [{\n        index: reprojectAttributeIndices.position,\n        vertexBuffer: Buffer.createVertexBuffer({\n          context: context,\n          typedArray: positions,\n          usage: BufferUsage.STATIC_DRAW\n        }),\n        componentsPerAttribute: 2\n      }, {\n        index: reprojectAttributeIndices.webMercatorT,\n        vertexBuffer: Buffer.createVertexBuffer({\n          context: context,\n          sizeInBytes: 64 * 2 * 4,\n          usage: BufferUsage.STREAM_DRAW\n        }),\n        componentsPerAttribute: 1\n      }],\n      indexBuffer: indexBuffer\n    });\n    const vs = new ShaderSource({\n      sources: [ReprojectWebMercatorVS]\n    });\n    reproject.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: ReprojectWebMercatorFS,\n      attributeLocations: reprojectAttributeIndices\n    });\n    reproject.sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    });\n  }\n  texture.sampler = reproject.sampler;\n  const width = texture.width;\n  const height = texture.height;\n  uniformMap.textureDimensions.x = width;\n  uniformMap.textureDimensions.y = height;\n  uniformMap.texture = texture;\n  let sinLatitude = Math.sin(rectangle.south);\n  const southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  sinLatitude = Math.sin(rectangle.north);\n  const northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  const oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n  const outputTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: texture.pixelFormat,\n    pixelDatatype: texture.pixelDatatype,\n    preMultiplyAlpha: texture.preMultiplyAlpha\n  });\n\n  // Allocate memory for the mipmaps.  Failure to do this before rendering\n  // to the texture via the FBO, and calling generateMipmap later,\n  // will result in the texture appearing blank.  I can't pretend to\n  // understand exactly why this is.\n  if (CesiumMath.isPowerOfTwo(width) && CesiumMath.isPowerOfTwo(height)) {\n    outputTexture.generateMipmap(MipmapHint.NICEST);\n  }\n  const south = rectangle.south;\n  const north = rectangle.north;\n  const webMercatorT = float32ArrayScratch;\n  let outputIndex = 0;\n  for (let webMercatorTIndex = 0; webMercatorTIndex < 64; ++webMercatorTIndex) {\n    const fraction = webMercatorTIndex / 63.0;\n    const latitude = CesiumMath.lerp(south, north, fraction);\n    sinLatitude = Math.sin(latitude);\n    const mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    const mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\n    webMercatorT[outputIndex++] = mercatorFraction;\n    webMercatorT[outputIndex++] = mercatorFraction;\n  }\n  reproject.vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(webMercatorT);\n  command.shaderProgram = reproject.shaderProgram;\n  command.outputTexture = outputTexture;\n  command.uniformMap = uniformMap;\n  command.vertexArray = reproject.vertexArray;\n}\n\n/**\n * Gets the level with the specified world coordinate spacing between texels, or less.\n *\n * @param {ImageryLayer} layer The imagery layer to use.\n * @param {number} texelSpacing The texel spacing for which to find a corresponding level.\n * @param {number} latitudeClosestToEquator The latitude closest to the equator that we're concerned with.\n * @returns {number} The level with the specified texel spacing or less.\n * @private\n */\nfunction getLevelWithMaximumTexelSpacing(layer, texelSpacing, latitudeClosestToEquator) {\n  // PERFORMANCE_IDEA: factor out the stuff that doesn't change.\n  const imageryProvider = layer._imageryProvider;\n  const tilingScheme = imageryProvider.tilingScheme;\n  const ellipsoid = tilingScheme.ellipsoid;\n  const latitudeFactor = !(layer._imageryProvider.tilingScheme.projection instanceof GeographicProjection) ? Math.cos(latitudeClosestToEquator) : 1.0;\n  const tilingSchemeRectangle = tilingScheme.rectangle;\n  const levelZeroMaximumTexelSpacing = ellipsoid.maximumRadius * tilingSchemeRectangle.width * latitudeFactor / (imageryProvider.tileWidth * tilingScheme.getNumberOfXTilesAtLevel(0));\n  const twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;\n  const level = Math.log(twoToTheLevelPower) / Math.log(2);\n  const rounded = Math.round(level);\n  return rounded | 0;\n}\nfunction handleError(errorEvent, error) {\n  if (errorEvent.numberOfListeners > 0) {\n    errorEvent.raiseEvent(error);\n  } else {\n    // Default handler is to log to the console\n    console.error(error);\n  }\n}\nasync function handlePromise(instance, promise) {\n  let provider;\n  try {\n    provider = await Promise.resolve(promise);\n    if (instance.isDestroyed()) {\n      return;\n    }\n    instance._imageryProvider = provider;\n    instance._readyEvent.raiseEvent(provider);\n  } catch (error) {\n    handleError(instance._errorEvent, error);\n  }\n}\nexport default ImageryLayer;\n\n/**\n * A function that is called when an error occurs.\n * @callback ImageryLayer.ErrorEventCallback\n *\n * @this ImageryLayer\n * @param {Error} err An object holding details about the error that occurred.\n */\n\n/**\n * A function that is called when the provider has been created\n * @callback ImageryLayer.ReadyEventCallback\n *\n * @this ImageryLayer\n * @param {ImageryProvider} provider The created imagery provider.\n */","map":{"version":3,"names":["Cartesian2","Cartesian4","Check","createWorldImageryAsync","defaultValue","defined","destroyObject","DeveloperError","Event","FeatureDetection","GeographicProjection","IndexDatatype","CesiumMath","PixelFormat","Rectangle","Request","RequestState","RequestType","TerrainProvider","TileProviderError","WebMercatorProjection","Buffer","BufferUsage","ComputeCommand","ContextLimits","MipmapHint","Sampler","ShaderProgram","ShaderSource","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","VertexArray","ReprojectWebMercatorFS","ReprojectWebMercatorVS","Imagery","ImageryState","SplitDirection","TileImagery","ImageryLayer","imageryProvider","options","_imageryProvider","_readyEvent","_errorEvent","EMPTY_OBJECT","alpha","_defaultAlpha","nightAlpha","_defaultNightAlpha","dayAlpha","_defaultDayAlpha","brightness","_defaultBrightness","DEFAULT_BRIGHTNESS","contrast","_defaultContrast","DEFAULT_CONTRAST","hue","_defaultHue","DEFAULT_HUE","saturation","_defaultSaturation","DEFAULT_SATURATION","gamma","_defaultGamma","DEFAULT_GAMMA","splitDirection","DEFAULT_SPLIT","minificationFilter","_defaultMinificationFilter","DEFAULT_MINIFICATION_FILTER","magnificationFilter","_defaultMagnificationFilter","DEFAULT_MAGNIFICATION_FILTER","show","_minimumTerrainLevel","minimumTerrainLevel","_maximumTerrainLevel","maximumTerrainLevel","_rectangle","rectangle","MAX_VALUE","_maximumAnisotropy","maximumAnisotropy","_imageryCache","_skeletonPlaceholder","createPlaceholder","_show","_layerIndex","_isBaseLayer","_requestImageError","undefined","_reprojectComputeCommands","cutoutRectangle","colorToAlpha","colorToAlphaThreshold","DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD","Object","defineProperties","prototype","get","ready","errorEvent","readyEvent","NONE","LINEAR","fromProviderAsync","imageryProviderPromise","typeOf","object","layer","handlePromise","Promise","resolve","fromWorldImagery","style","isBaseLayer","isDestroyed","destroy","imageryBoundsScratch","tileImageryBoundsScratch","clippedRectangleScratch","terrainRectangleScratch","getImageryRectangle","intersection","_createTileImagerySkeletons","tile","terrainProvider","insertionPoint","surfaceTile","data","level","imagery","length","loadingImagery","addReference","splice","useWebMercatorT","tilingScheme","projection","north","MaximumLatitude","south","imageryBounds","baseImageryRectangle","baseTerrainRectangle","Math","max","min","west","east","latitudeClosestToEquator","errorRatio","targetGeometricError","getLevelMaximumGeometricError","imageryLevel","getLevelWithMaximumTexelSpacing","maximumLevel","minimumLevel","imageryTilingScheme","northwestTileCoordinates","positionToTileXY","northwest","southeastTileCoordinates","southeast","veryCloseX","width","veryCloseY","height","northwestTileRectangle","tileXYToRectangle","x","y","abs","southeastTileRectangle","terrainRectangle","clone","imageryRectangle","clippedImageryRectangle","imageryTileXYToRectangle","rectangleToNativeRectangle","tileXYToNativeRectangle","bind","minU","maxU","minV","maxV","initialMinV","i","simpleIntersection","j","texCoordsRectangle","getImageryFromCache","_calculateTextureTranslationAndScale","tileImagery","readyImagery","imageryLayer","terrainWidth","terrainHeight","scaleX","scaleY","_requestImagery","that","success","image","failure","state","RECEIVED","request","reportSuccess","e","CANCELLED","UNLOADED","FAILED","message","reportError","retry","doRequest","throttle","throttleByServer","type","IMAGERY","TRANSITIONING","imagePromise","requestImage","getTileCredits","credits","then","catch","_createTextureWebGL","context","sampler","internalFormat","pixelFormat","source","arrayBufferView","bufferView","hasAlphaChannel","RGBA","RGB","_createTexture","tileDiscardPolicy","discardPolicy","isReady","shouldDiscardImage","INVALID","NEAREST","texture","textureWebMercator","TEXTURE_LOADED","getSamplerKey","_finalizeReprojectTexture","usesLinearTextureFilter","isCompressedFormat","isPowerOfTwo","LINEAR_MIPMAP_LINEAR","maximumSupportedAnisotropy","maximumTextureFilterAnisotropy","mipmapSamplerKey","mipmapSamplers","cache","imageryLayerMipmapSamplers","mipmapSampler","wrapS","CLAMP_TO_EDGE","wrapT","generateMipmap","NICEST","nonMipmapSamplerKey","nonMipmapSamplers","imageryLayerNonMipmapSamplers","nonMipmapSampler","_reprojectTexture","frameState","needGeographicProjection","computeCommand","persists","owner","preExecute","command","reprojectToGeographic","postExecute","outputTexture","READY","releaseReference","canceled","push","queueReprojectionCommands","computeCommands","commandList","cancelReprojections","forEach","cacheKey","getImageryCacheKey","removeImageryFromCache","JSON","stringify","uniformMap","u_textureDimensions","textureDimensions","u_texture","float32ArrayScratch","supportsTypedArrays","Float32Array","reproject","imageryLayer_reproject","vertexArray","shaderProgram","framebuffer","positions","index","reprojectAttributeIndices","position","webMercatorT","indices","getRegularGridIndices","indexBuffer","createIndexBuffer","typedArray","usage","STATIC_DRAW","indexDatatype","UNSIGNED_SHORT","attributes","vertexBuffer","createVertexBuffer","componentsPerAttribute","sizeInBytes","STREAM_DRAW","vs","sources","fromCache","vertexShaderSource","fragmentShaderSource","attributeLocations","sinLatitude","sin","southMercatorY","log","northMercatorY","oneOverMercatorHeight","pixelDatatype","preMultiplyAlpha","outputIndex","webMercatorTIndex","fraction","latitude","lerp","mercatorY","mercatorFraction","getAttribute","copyFromArrayView","texelSpacing","ellipsoid","latitudeFactor","cos","tilingSchemeRectangle","levelZeroMaximumTexelSpacing","maximumRadius","tileWidth","getNumberOfXTilesAtLevel","twoToTheLevelPower","rounded","round","handleError","error","numberOfListeners","raiseEvent","console","instance","promise","provider"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ImageryLayer.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport createWorldImageryAsync from \"../Scene/createWorldImageryAsync.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport MipmapHint from \"../Renderer/MipmapHint.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ReprojectWebMercatorFS from \"../Shaders/ReprojectWebMercatorFS.js\";\nimport ReprojectWebMercatorVS from \"../Shaders/ReprojectWebMercatorVS.js\";\nimport Imagery from \"./Imagery.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport TileImagery from \"./TileImagery.js\";\n\n/**\n * @typedef {Object} ImageryLayer.ConstructorOptions\n *\n * Initialization options for the ImageryLayer constructor.\n *\n * @property {Rectangle} [rectangle=imageryProvider.rectangle] The rectangle of the layer.  This rectangle\n *        can limit the visible portion of the imagery provider.\n * @property {number|Function} [alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile.\n * @property {number|Function} [nightAlpha=1.0] The alpha blending value of this layer on the night side of the globe, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.\n * @property {number|Function} [dayAlpha=1.0] The alpha blending value of this layer on the day side of the globe, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.\n * @property {number|Function} [brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery\n *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the brightness is required, and it is expected to return\n *                          the brightness value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the contrast is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [hue=0.0] The hue of this layer.  0.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the hue is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [saturation=1.0] The saturation of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the saturation is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {number|Function} [gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the gamma is required, and it is expected to return\n *                          the gamma value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @property {SplitDirection|Function} [splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this layer.\n * @property {TextureMinificationFilter} [minificationFilter=TextureMinificationFilter.LINEAR] The\n *                                    texture minification filter to apply to this layer. Possible values\n *                                    are <code>TextureMinificationFilter.LINEAR</code> and\n *                                    <code>TextureMinificationFilter.NEAREST</code>.\n * @property {TextureMagnificationFilter} [magnificationFilter=TextureMagnificationFilter.LINEAR] The\n *                                     texture minification filter to apply to this layer. Possible values\n *                                     are <code>TextureMagnificationFilter.LINEAR</code> and\n *                                     <code>TextureMagnificationFilter.NEAREST</code>.\n * @property {boolean} [show=true] True if the layer is shown; otherwise, false.\n * @property {number} [maximumAnisotropy=maximum supported] The maximum anisotropy level to use\n *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported\n *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon\n *        views.\n * @property {number} [minimumTerrainLevel] The minimum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @property {number} [maximumTerrainLevel] The maximum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @property {Rectangle} [cutoutRectangle] Cartographic rectangle for cutting out a portion of this ImageryLayer.\n * @property {Color} [colorToAlpha] Color to be used as alpha.\n * @property {number} [colorToAlphaThreshold=0.004] Threshold for color-to-alpha.\n */\n\n/**\n * An imagery layer that displays tiled image data from a single imagery provider\n * on a {@link Globe}.\n *\n * @alias ImageryLayer\n * @constructor\n *\n * @param {ImageryProvider} [imageryProvider] The imagery provider to use.\n * @param {ImageryLayer.ConstructorOptions} [options] An object describing initialization options\n *\n * @see ImageryLayer.fromProviderAsync\n * @see ImageryLayer.fromWorldImagery\n *\n * @example\n * // Add an OpenStreetMaps layer\n * const imageryLayer = new Cesium.ImageryLayer(new Cesium.OpenStreetMapImageryProvider({\n *   url: \"https://tile.openstreetmap.org/\"\n * }));\n * scene.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Add Cesium ion's default world imagery layer\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * scene.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Add a new transparent layer from Cesium ion\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * imageryLayer.alpha = 0.5;\n * scene.imageryLayers.add(imageryLayer);\n */\nfunction ImageryLayer(imageryProvider, options) {\n  this._imageryProvider = imageryProvider;\n\n  this._readyEvent = new Event();\n  this._errorEvent = new Event();\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  imageryProvider = defaultValue(imageryProvider, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The alpha blending value of this layer, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {number}\n   * @default 1.0\n   */\n  this.alpha = defaultValue(\n    options.alpha,\n    defaultValue(imageryProvider._defaultAlpha, 1.0),\n  );\n\n  /**\n   * The alpha blending value of this layer on the night side of the globe, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.\n   *\n   * @type {number}\n   * @default 1.0\n   */\n  this.nightAlpha = defaultValue(\n    options.nightAlpha,\n    defaultValue(imageryProvider._defaultNightAlpha, 1.0),\n  );\n\n  /**\n   * The alpha blending value of this layer on the day side of the globe, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.\n   *\n   * @type {number}\n   * @default 1.0\n   */\n  this.dayAlpha = defaultValue(\n    options.dayAlpha,\n    defaultValue(imageryProvider._defaultDayAlpha, 1.0),\n  );\n\n  /**\n   * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_BRIGHTNESS}\n   */\n  this.brightness = defaultValue(\n    options.brightness,\n    defaultValue(\n      imageryProvider._defaultBrightness,\n      ImageryLayer.DEFAULT_BRIGHTNESS,\n    ),\n  );\n\n  /**\n   * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_CONTRAST}\n   */\n  this.contrast = defaultValue(\n    options.contrast,\n    defaultValue(\n      imageryProvider._defaultContrast,\n      ImageryLayer.DEFAULT_CONTRAST,\n    ),\n  );\n\n  /**\n   * The hue of this layer in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_HUE}\n   */\n  this.hue = defaultValue(\n    options.hue,\n    defaultValue(imageryProvider._defaultHue, ImageryLayer.DEFAULT_HUE),\n  );\n\n  /**\n   * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_SATURATION}\n   */\n  this.saturation = defaultValue(\n    options.saturation,\n    defaultValue(\n      imageryProvider._defaultSaturation,\n      ImageryLayer.DEFAULT_SATURATION,\n    ),\n  );\n\n  /**\n   * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n   *\n   * @type {number}\n   * @default {@link ImageryLayer.DEFAULT_GAMMA}\n   */\n  this.gamma = defaultValue(\n    options.gamma,\n    defaultValue(imageryProvider._defaultGamma, ImageryLayer.DEFAULT_GAMMA),\n  );\n\n  /**\n   * The {@link SplitDirection} to apply to this layer.\n   *\n   * @type {SplitDirection}\n   * @default {@link ImageryLayer.DEFAULT_SPLIT}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    ImageryLayer.DEFAULT_SPLIT,\n  );\n\n  /**\n   * The {@link TextureMinificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)\n   * and {@link TextureMinificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMinificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MINIFICATION_FILTER}\n   */\n  this.minificationFilter = defaultValue(\n    options.minificationFilter,\n    defaultValue(\n      imageryProvider._defaultMinificationFilter,\n      ImageryLayer.DEFAULT_MINIFICATION_FILTER,\n    ),\n  );\n\n  /**\n   * The {@link TextureMagnificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)\n   * and {@link TextureMagnificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MAGNIFICATION_FILTER}\n   */\n  this.magnificationFilter = defaultValue(\n    options.magnificationFilter,\n    defaultValue(\n      imageryProvider._defaultMagnificationFilter,\n      ImageryLayer.DEFAULT_MAGNIFICATION_FILTER,\n    ),\n  );\n\n  /**\n   * Determines if this layer is shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._minimumTerrainLevel = options.minimumTerrainLevel;\n  this._maximumTerrainLevel = options.maximumTerrainLevel;\n\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._maximumAnisotropy = options.maximumAnisotropy;\n\n  this._imageryCache = {};\n\n  this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this));\n\n  // The value of the show property on the last update.\n  this._show = true;\n\n  // The index of this layer in the ImageryLayerCollection.\n  this._layerIndex = -1;\n\n  // true if this is the base (lowest shown) layer.\n  this._isBaseLayer = false;\n\n  this._requestImageError = undefined;\n\n  this._reprojectComputeCommands = [];\n\n  /**\n   * Rectangle cutout in this layer of imagery.\n   *\n   * @type {Rectangle}\n   */\n  this.cutoutRectangle = options.cutoutRectangle;\n\n  /**\n   * Color value that should be set to transparent.\n   *\n   * @type {Color}\n   */\n  this.colorToAlpha = options.colorToAlpha;\n\n  /**\n   * Normalized (0-1) threshold for color-to-alpha.\n   *\n   * @type {number}\n   */\n  this.colorToAlphaThreshold = defaultValue(\n    options.colorToAlphaThreshold,\n    ImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD,\n  );\n}\n\nObject.defineProperties(ImageryLayer.prototype, {\n  /**\n   * Gets the imagery provider for this layer. This should not be called before {@link ImageryLayer#ready} returns true.\n   * @memberof ImageryLayer.prototype\n   * @type {ImageryProvider}\n   * @readonly\n   */\n  imageryProvider: {\n    get: function () {\n      return this._imageryProvider;\n    },\n  },\n\n  /**\n   * Returns true when the terrain provider has been successfully created. Otherwise, returns false.\n   * @memberof ImageryLayer.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return defined(this._imageryProvider);\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of the thrown error.\n   * @memberof Imagery.prototype\n   * @type {Event<Imagery.ErrorEventCallback>}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider has been successfully created. Event listeners\n   * are passed the created instance of {@link ImageryProvider}.\n   * @memberof ImageryLayer.prototype\n   * @type {Event<ImageryLayer.ReadyEventCallback>}\n   * @readonly\n   */\n  readyEvent: {\n    get: function () {\n      return this._readyEvent;\n    },\n  },\n\n  /**\n   * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the\n   * {@link ImageryProvider}, only a portion of the imagery provider is shown.\n   * @memberof ImageryLayer.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n});\n\n/**\n * This value is used as the default brightness for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the brightness of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_BRIGHTNESS = 1.0;\n/**\n * This value is used as the default contrast for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the contrast of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_CONTRAST = 1.0;\n/**\n * This value is used as the default hue for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the hue of the imagery.\n * @type {number}\n * @default 0.0\n */\nImageryLayer.DEFAULT_HUE = 0.0;\n/**\n * This value is used as the default saturation for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the saturation of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_SATURATION = 1.0;\n/**\n * This value is used as the default gamma for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the gamma of the imagery.\n * @type {number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_GAMMA = 1.0;\n\n/**\n * This value is used as the default split for the imagery layer if one is not provided during construction\n * or by the imagery provider.\n * @type {SplitDirection}\n * @default SplitDirection.NONE\n */\nImageryLayer.DEFAULT_SPLIT = SplitDirection.NONE;\n\n/**\n * This value is used as the default texture minification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMinificationFilter}\n * @default TextureMinificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MINIFICATION_FILTER = TextureMinificationFilter.LINEAR;\n\n/**\n * This value is used as the default texture magnification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMagnificationFilter}\n * @default TextureMagnificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MAGNIFICATION_FILTER = TextureMagnificationFilter.LINEAR;\n\n/**\n * This value is used as the default threshold for color-to-alpha if one is not provided\n * during construction or by the imagery provider.\n * @type {number}\n * @default 0.004\n */\nImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = 0.004;\n\n/**\n * Create a new imagery layer from an asynchronous imagery provider. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.\n *\n * @param {Promise<ImageryProvider>} imageryProviderPromise A promise which resolves to a imagery provider\n * @param {ImageryLayer.ConstructorOptions} options An object describing initialization options\n * @returns {ImageryLayer} The created imagery layer.\n *\n * @example\n * // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * });\n *\n * @example\n * // Add a new transparent layer\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * imageryLayer.alpha = 0.5;\n * viewer.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Handle loading events\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * viewer.imageryLayers.add(imageryLayer);\n *\n * imageryLayer.readyEvent.addEventListener(provider => {\n *   imageryLayer.provider.errorEvent.addEventListener(error => {\n *     alert(`Encountered an error while loading imagery tiles! ${error}`);\n *   });\n * });\n *\n * imageryLayer.errorEvent.addEventListener(error => {\n *   alert(`Encountered an error while creating an imagery layer! ${error}`);\n * });\n *\n * @see ImageryLayer.errorEvent\n * @see ImageryLayer.readyEvent\n * @see ImageryLayer.provider\n * @see ImageryLayer.fromWorldImagery\n */\nImageryLayer.fromProviderAsync = function (imageryProviderPromise, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"imageryProviderPromise\", imageryProviderPromise);\n  //>>includeEnd('debug');\n\n  const layer = new ImageryLayer(undefined, options);\n\n  handlePromise(layer, Promise.resolve(imageryProviderPromise));\n\n  return layer;\n};\n\n/**\n * @typedef {ImageryLayer.ConstructorOptions} ImageryLayer.WorldImageryConstructorOptions\n *\n * Initialization options for ImageryLayer.fromWorldImagery\n *\n * @property {IonWorldImageryStyle} [options.style=IonWorldImageryStyle] The style of base imagery, only AERIAL, AERIAL_WITH_LABELS, and ROAD are currently supported.\n */\n\n/**\n * Create a new imagery layer for ion's default global base imagery layer, currently Bing Maps. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.\n *\n * @param {ImageryLayer.WorldImageryConstructorOptions} options An object describing initialization options\n * @returns {ImageryLayer} The created imagery layer.\n *\n * * @example\n * // Create a new base layer\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   baseLayer: Cesium.ImageryLayer.fromWorldImagery();\n * });\n *\n * @example\n * // Add a new transparent layer\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * imageryLayer.alpha = 0.5;\n * viewer.imageryLayers.add(imageryLayer);\n *\n * @example\n * // Handle loading events\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * viewer.imageryLayers.add(imageryLayer);\n *\n * imageryLayer.readyEvent.addEventListener(provider => {\n *   imageryLayer.provider.errorEvent.addEventListener(error => {\n *     alert(`Encountered an error while loading imagery tiles! ${error}`);\n *   });\n * });\n *\n * imageryLayer.errorEvent.addEventListener(error => {\n *   alert(`Encountered an error while creating an imagery layer! ${error}`);\n * });\n *\n * @see ImageryLayer.errorEvent\n * @see ImageryLayer.readyEvent\n * @see ImageryLayer.provider\n */\nImageryLayer.fromWorldImagery = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  return ImageryLayer.fromProviderAsync(\n    createWorldImageryAsync({\n      style: options.style,\n    }),\n    options,\n  );\n};\n\n/**\n * Gets a value indicating whether this layer is the base layer in the\n * {@link ImageryLayerCollection}.  The base layer is the one that underlies all\n * others.  It is special in that it is treated as if it has global rectangle, even if\n * it actually does not, by stretching the texels at the edges over the entire\n * globe.\n *\n * @returns {boolean} true if this is the base layer; otherwise, false.\n */\nImageryLayer.prototype.isBaseLayer = function () {\n  return this._isBaseLayer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayer#destroy\n */\nImageryLayer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n * @see ImageryLayer#isDestroyed\n */\nImageryLayer.prototype.destroy = function () {\n  return destroyObject(this);\n};\n\nconst imageryBoundsScratch = new Rectangle();\nconst tileImageryBoundsScratch = new Rectangle();\nconst clippedRectangleScratch = new Rectangle();\nconst terrainRectangleScratch = new Rectangle();\n\n/**\n * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,\n * producing the overall bounds of imagery that can be produced by this layer.\n *\n * @returns {Rectangle} A rectangle which defines the overall bounds of imagery that can be produced by this layer.\n *\n * @example\n * // Zoom to an imagery layer.\n * const imageryRectangle = imageryLayer.getImageryRectangle();\n * scene.camera.flyTo({\n *     destination: rectangle\n * });\n *\n */\nImageryLayer.prototype.getImageryRectangle = function () {\n  const imageryProvider = this._imageryProvider;\n  const rectangle = this._rectangle;\n  return Rectangle.intersection(imageryProvider.rectangle, rectangle);\n};\n\n/**\n * Create skeletons for the imagery tiles that partially or completely overlap a given terrain\n * tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TerrainProvider|undefined} terrainProvider The terrain provider associated with the terrain tile.\n * @param {number} insertionPoint The position to insert new skeletons before in the tile's imagery list.\n * @returns {boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.\n */\nImageryLayer.prototype._createTileImagerySkeletons = function (\n  tile,\n  terrainProvider,\n  insertionPoint,\n) {\n  const surfaceTile = tile.data;\n\n  if (\n    !defined(terrainProvider) ||\n    (defined(this._minimumTerrainLevel) &&\n      tile.level < this._minimumTerrainLevel)\n  ) {\n    return false;\n  }\n  if (\n    defined(this._maximumTerrainLevel) &&\n    tile.level > this._maximumTerrainLevel\n  ) {\n    return false;\n  }\n\n  if (!defined(insertionPoint)) {\n    insertionPoint = surfaceTile.imagery.length;\n  }\n\n  const imageryProvider = this._imageryProvider;\n  if (!this.ready) {\n    // The imagery provider is not ready, so we can't create skeletons, yet.\n    // Instead, add a placeholder so that we'll know to create\n    // the skeletons once the provider is ready.\n    this._skeletonPlaceholder.loadingImagery.addReference();\n    surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);\n    return true;\n  }\n\n  // Use Web Mercator for our texture coordinate computations if this imagery layer uses\n  // that projection and the terrain tile falls entirely inside the valid bounds of the\n  // projection.\n  const useWebMercatorT =\n    imageryProvider.tilingScheme.projection instanceof WebMercatorProjection &&\n    tile.rectangle.north < WebMercatorProjection.MaximumLatitude &&\n    tile.rectangle.south > -WebMercatorProjection.MaximumLatitude;\n\n  // Compute the rectangle of the imagery from this imageryProvider that overlaps\n  // the geometry tile.  The ImageryProvider and ImageryLayer both have the\n  // opportunity to constrain the rectangle.  The imagery TilingScheme's rectangle\n  // always fully contains the ImageryProvider's rectangle.\n  const imageryBounds = Rectangle.intersection(\n    imageryProvider.rectangle,\n    this._rectangle,\n    imageryBoundsScratch,\n  );\n  let rectangle = Rectangle.intersection(\n    tile.rectangle,\n    imageryBounds,\n    tileImageryBoundsScratch,\n  );\n\n  if (!defined(rectangle)) {\n    // There is no overlap between this terrain tile and this imagery\n    // provider.  Unless this is the base layer, no skeletons need to be created.\n    // We stretch texels at the edge of the base layer over the entire globe.\n    if (!this.isBaseLayer()) {\n      return false;\n    }\n\n    const baseImageryRectangle = imageryBounds;\n    const baseTerrainRectangle = tile.rectangle;\n    rectangle = tileImageryBoundsScratch;\n\n    if (baseTerrainRectangle.south >= baseImageryRectangle.north) {\n      rectangle.north = rectangle.south = baseImageryRectangle.north;\n    } else if (baseTerrainRectangle.north <= baseImageryRectangle.south) {\n      rectangle.north = rectangle.south = baseImageryRectangle.south;\n    } else {\n      rectangle.south = Math.max(\n        baseTerrainRectangle.south,\n        baseImageryRectangle.south,\n      );\n      rectangle.north = Math.min(\n        baseTerrainRectangle.north,\n        baseImageryRectangle.north,\n      );\n    }\n\n    if (baseTerrainRectangle.west >= baseImageryRectangle.east) {\n      rectangle.west = rectangle.east = baseImageryRectangle.east;\n    } else if (baseTerrainRectangle.east <= baseImageryRectangle.west) {\n      rectangle.west = rectangle.east = baseImageryRectangle.west;\n    } else {\n      rectangle.west = Math.max(\n        baseTerrainRectangle.west,\n        baseImageryRectangle.west,\n      );\n      rectangle.east = Math.min(\n        baseTerrainRectangle.east,\n        baseImageryRectangle.east,\n      );\n    }\n  }\n\n  let latitudeClosestToEquator = 0.0;\n  if (rectangle.south > 0.0) {\n    latitudeClosestToEquator = rectangle.south;\n  } else if (rectangle.north < 0.0) {\n    latitudeClosestToEquator = rectangle.north;\n  }\n\n  // Compute the required level in the imagery tiling scheme.\n  // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.\n  // But first we need configurable imagery SSE and we need the rendering to be able to handle more\n  // images attached to a terrain tile than there are available texture units.  So that's for the future.\n  const errorRatio = 1.0;\n  const targetGeometricError =\n    errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);\n  let imageryLevel = getLevelWithMaximumTexelSpacing(\n    this,\n    targetGeometricError,\n    latitudeClosestToEquator,\n  );\n  imageryLevel = Math.max(0, imageryLevel);\n  const maximumLevel = imageryProvider.maximumLevel;\n  if (imageryLevel > maximumLevel) {\n    imageryLevel = maximumLevel;\n  }\n\n  if (defined(imageryProvider.minimumLevel)) {\n    const minimumLevel = imageryProvider.minimumLevel;\n    if (imageryLevel < minimumLevel) {\n      imageryLevel = minimumLevel;\n    }\n  }\n\n  const imageryTilingScheme = imageryProvider.tilingScheme;\n  const northwestTileCoordinates = imageryTilingScheme.positionToTileXY(\n    Rectangle.northwest(rectangle),\n    imageryLevel,\n  );\n  const southeastTileCoordinates = imageryTilingScheme.positionToTileXY(\n    Rectangle.southeast(rectangle),\n    imageryLevel,\n  );\n\n  // If the southeast corner of the rectangle lies very close to the north or west side\n  // of the southeast tile, we don't actually need the southernmost or easternmost\n  // tiles.\n  // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n  // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n\n  // We define \"very close\" as being within 1/512 of the width of the tile.\n  let veryCloseX = tile.rectangle.width / 512.0;\n  let veryCloseY = tile.rectangle.height / 512.0;\n\n  const northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(\n    northwestTileCoordinates.x,\n    northwestTileCoordinates.y,\n    imageryLevel,\n  );\n  if (\n    Math.abs(northwestTileRectangle.south - tile.rectangle.north) <\n      veryCloseY &&\n    northwestTileCoordinates.y < southeastTileCoordinates.y\n  ) {\n    ++northwestTileCoordinates.y;\n  }\n  if (\n    Math.abs(northwestTileRectangle.east - tile.rectangle.west) < veryCloseX &&\n    northwestTileCoordinates.x < southeastTileCoordinates.x\n  ) {\n    ++northwestTileCoordinates.x;\n  }\n\n  const southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(\n    southeastTileCoordinates.x,\n    southeastTileCoordinates.y,\n    imageryLevel,\n  );\n  if (\n    Math.abs(southeastTileRectangle.north - tile.rectangle.south) <\n      veryCloseY &&\n    southeastTileCoordinates.y > northwestTileCoordinates.y\n  ) {\n    --southeastTileCoordinates.y;\n  }\n  if (\n    Math.abs(southeastTileRectangle.west - tile.rectangle.east) < veryCloseX &&\n    southeastTileCoordinates.x > northwestTileCoordinates.x\n  ) {\n    --southeastTileCoordinates.x;\n  }\n\n  // Create TileImagery instances for each imagery tile overlapping this terrain tile.\n  // We need to do all texture coordinate computations in the imagery tile's tiling scheme.\n\n  const terrainRectangle = Rectangle.clone(\n    tile.rectangle,\n    terrainRectangleScratch,\n  );\n  let imageryRectangle = imageryTilingScheme.tileXYToRectangle(\n    northwestTileCoordinates.x,\n    northwestTileCoordinates.y,\n    imageryLevel,\n  );\n  let clippedImageryRectangle = Rectangle.intersection(\n    imageryRectangle,\n    imageryBounds,\n    clippedRectangleScratch,\n  );\n\n  let imageryTileXYToRectangle;\n  if (useWebMercatorT) {\n    imageryTilingScheme.rectangleToNativeRectangle(\n      terrainRectangle,\n      terrainRectangle,\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryRectangle,\n      imageryRectangle,\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      clippedImageryRectangle,\n      clippedImageryRectangle,\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryBounds,\n      imageryBounds,\n    );\n    imageryTileXYToRectangle =\n      imageryTilingScheme.tileXYToNativeRectangle.bind(imageryTilingScheme);\n    veryCloseX = terrainRectangle.width / 512.0;\n    veryCloseY = terrainRectangle.height / 512.0;\n  } else {\n    imageryTileXYToRectangle =\n      imageryTilingScheme.tileXYToRectangle.bind(imageryTilingScheme);\n  }\n\n  let minU;\n  let maxU = 0.0;\n\n  let minV = 1.0;\n  let maxV;\n\n  // If this is the northern-most or western-most tile in the imagery tiling scheme,\n  // it may not start at the northern or western edge of the terrain tile.\n  // Calculate where it does start.\n  if (\n    !this.isBaseLayer() &&\n    Math.abs(clippedImageryRectangle.west - terrainRectangle.west) >= veryCloseX\n  ) {\n    maxU = Math.min(\n      1.0,\n      (clippedImageryRectangle.west - terrainRectangle.west) /\n        terrainRectangle.width,\n    );\n  }\n\n  if (\n    !this.isBaseLayer() &&\n    Math.abs(clippedImageryRectangle.north - terrainRectangle.north) >=\n      veryCloseY\n  ) {\n    minV = Math.max(\n      0.0,\n      (clippedImageryRectangle.north - terrainRectangle.south) /\n        terrainRectangle.height,\n    );\n  }\n\n  const initialMinV = minV;\n\n  for (\n    let i = northwestTileCoordinates.x;\n    i <= southeastTileCoordinates.x;\n    i++\n  ) {\n    minU = maxU;\n\n    imageryRectangle = imageryTileXYToRectangle(\n      i,\n      northwestTileCoordinates.y,\n      imageryLevel,\n    );\n    clippedImageryRectangle = Rectangle.simpleIntersection(\n      imageryRectangle,\n      imageryBounds,\n      clippedRectangleScratch,\n    );\n\n    if (!defined(clippedImageryRectangle)) {\n      continue;\n    }\n\n    maxU = Math.min(\n      1.0,\n      (clippedImageryRectangle.east - terrainRectangle.west) /\n        terrainRectangle.width,\n    );\n\n    // If this is the eastern-most imagery tile mapped to this terrain tile,\n    // and there are more imagery tiles to the east of this one, the maxU\n    // should be 1.0 to make sure rounding errors don't make the last\n    // image fall shy of the edge of the terrain tile.\n    if (\n      i === southeastTileCoordinates.x &&\n      (this.isBaseLayer() ||\n        Math.abs(clippedImageryRectangle.east - terrainRectangle.east) <\n          veryCloseX)\n    ) {\n      maxU = 1.0;\n    }\n\n    minV = initialMinV;\n\n    for (\n      let j = northwestTileCoordinates.y;\n      j <= southeastTileCoordinates.y;\n      j++\n    ) {\n      maxV = minV;\n\n      imageryRectangle = imageryTileXYToRectangle(i, j, imageryLevel);\n      clippedImageryRectangle = Rectangle.simpleIntersection(\n        imageryRectangle,\n        imageryBounds,\n        clippedRectangleScratch,\n      );\n\n      if (!defined(clippedImageryRectangle)) {\n        continue;\n      }\n\n      minV = Math.max(\n        0.0,\n        (clippedImageryRectangle.south - terrainRectangle.south) /\n          terrainRectangle.height,\n      );\n\n      // If this is the southern-most imagery tile mapped to this terrain tile,\n      // and there are more imagery tiles to the south of this one, the minV\n      // should be 0.0 to make sure rounding errors don't make the last\n      // image fall shy of the edge of the terrain tile.\n      if (\n        j === southeastTileCoordinates.y &&\n        (this.isBaseLayer() ||\n          Math.abs(clippedImageryRectangle.south - terrainRectangle.south) <\n            veryCloseY)\n      ) {\n        minV = 0.0;\n      }\n\n      const texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);\n      const imagery = this.getImageryFromCache(i, j, imageryLevel);\n      surfaceTile.imagery.splice(\n        insertionPoint,\n        0,\n        new TileImagery(imagery, texCoordsRectangle, useWebMercatorT),\n      );\n      ++insertionPoint;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Calculate the translation and scale for a particular {@link TileImagery} attached to a\n * particular terrain tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TileImagery} tileImagery The imagery tile mapping.\n * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W\n *          are the scale.\n */\nImageryLayer.prototype._calculateTextureTranslationAndScale = function (\n  tile,\n  tileImagery,\n) {\n  let imageryRectangle = tileImagery.readyImagery.rectangle;\n  let terrainRectangle = tile.rectangle;\n\n  if (tileImagery.useWebMercatorT) {\n    const tilingScheme =\n      tileImagery.readyImagery.imageryLayer.imageryProvider.tilingScheme;\n    imageryRectangle = tilingScheme.rectangleToNativeRectangle(\n      imageryRectangle,\n      imageryBoundsScratch,\n    );\n    terrainRectangle = tilingScheme.rectangleToNativeRectangle(\n      terrainRectangle,\n      terrainRectangleScratch,\n    );\n  }\n\n  const terrainWidth = terrainRectangle.width;\n  const terrainHeight = terrainRectangle.height;\n\n  const scaleX = terrainWidth / imageryRectangle.width;\n  const scaleY = terrainHeight / imageryRectangle.height;\n  return new Cartesian4(\n    (scaleX * (terrainRectangle.west - imageryRectangle.west)) / terrainWidth,\n    (scaleY * (terrainRectangle.south - imageryRectangle.south)) /\n      terrainHeight,\n    scaleX,\n    scaleY,\n  );\n};\n\n/**\n * Request a particular piece of imagery from the imagery provider.  This method handles raising an\n * error event if the request fails, and retrying the request if necessary.\n *\n * @private\n *\n * @param {Imagery} imagery The imagery to request.\n */\nImageryLayer.prototype._requestImagery = function (imagery) {\n  const imageryProvider = this._imageryProvider;\n\n  const that = this;\n\n  function success(image) {\n    if (!defined(image)) {\n      return failure();\n    }\n\n    imagery.image = image;\n    imagery.state = ImageryState.RECEIVED;\n    imagery.request = undefined;\n\n    TileProviderError.reportSuccess(that._requestImageError);\n  }\n\n  function failure(e) {\n    if (imagery.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    // Initially assume failure. An error handler may retry, in which case the state will\n    // change to TRANSITIONING.\n    imagery.state = ImageryState.FAILED;\n    imagery.request = undefined;\n\n    const message = `Failed to obtain image tile X: ${imagery.x} Y: ${imagery.y} Level: ${imagery.level}.`;\n    that._requestImageError = TileProviderError.reportError(\n      that._requestImageError,\n      imageryProvider,\n      imageryProvider.errorEvent,\n      message,\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      e,\n    );\n    if (that._requestImageError.retry) {\n      doRequest();\n    }\n  }\n\n  function doRequest() {\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.IMAGERY,\n    });\n    imagery.request = request;\n    imagery.state = ImageryState.TRANSITIONING;\n    const imagePromise = imageryProvider.requestImage(\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      request,\n    );\n\n    if (!defined(imagePromise)) {\n      // Too many parallel requests, so postpone loading tile.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    if (defined(imageryProvider.getTileCredits)) {\n      imagery.credits = imageryProvider.getTileCredits(\n        imagery.x,\n        imagery.y,\n        imagery.level,\n      );\n    }\n\n    imagePromise\n      .then(function (image) {\n        success(image);\n      })\n      .catch(function (e) {\n        failure(e);\n      });\n  }\n\n  doRequest();\n};\n\nImageryLayer.prototype._createTextureWebGL = function (context, imagery) {\n  const sampler = new Sampler({\n    minificationFilter: this.minificationFilter,\n    magnificationFilter: this.magnificationFilter,\n  });\n\n  const image = imagery.image;\n\n  if (defined(image.internalFormat)) {\n    return new Texture({\n      context: context,\n      pixelFormat: image.internalFormat,\n      width: image.width,\n      height: image.height,\n      source: {\n        arrayBufferView: image.bufferView,\n      },\n      sampler: sampler,\n    });\n  }\n  return new Texture({\n    context: context,\n    source: image,\n    pixelFormat: this._imageryProvider.hasAlphaChannel\n      ? PixelFormat.RGBA\n      : PixelFormat.RGB,\n    sampler: sampler,\n  });\n};\n\n/**\n * Create a WebGL texture for a given {@link Imagery} instance.\n *\n * @private\n *\n * @param {Context} context The rendered context to use to create textures.\n * @param {Imagery} imagery The imagery for which to create a texture.\n */\nImageryLayer.prototype._createTexture = function (context, imagery) {\n  const imageryProvider = this._imageryProvider;\n  const image = imagery.image;\n\n  // If this imagery provider has a discard policy, use it to check if this\n  // image should be discarded.\n  if (defined(imageryProvider.tileDiscardPolicy)) {\n    const discardPolicy = imageryProvider.tileDiscardPolicy;\n    if (defined(discardPolicy)) {\n      // If the discard policy is not ready yet, transition back to the\n      // RECEIVED state and we'll try again next time.\n      if (!discardPolicy.isReady()) {\n        imagery.state = ImageryState.RECEIVED;\n        return;\n      }\n\n      // Mark discarded imagery tiles invalid.  Parent imagery will be used instead.\n      if (discardPolicy.shouldDiscardImage(image)) {\n        imagery.state = ImageryState.INVALID;\n        return;\n      }\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    this.minificationFilter !== TextureMinificationFilter.NEAREST &&\n    this.minificationFilter !== TextureMinificationFilter.LINEAR\n  ) {\n    throw new DeveloperError(\n      \"ImageryLayer minification filter must be NEAREST or LINEAR\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Imagery does not need to be discarded, so upload it to WebGL.\n  const texture = this._createTextureWebGL(context, imagery);\n\n  if (\n    imageryProvider.tilingScheme.projection instanceof WebMercatorProjection\n  ) {\n    imagery.textureWebMercator = texture;\n  } else {\n    imagery.texture = texture;\n  }\n  imagery.image = undefined;\n  imagery.state = ImageryState.TEXTURE_LOADED;\n};\n\nfunction getSamplerKey(\n  minificationFilter,\n  magnificationFilter,\n  maximumAnisotropy,\n) {\n  return `${minificationFilter}:${magnificationFilter}:${maximumAnisotropy}`;\n}\n\nImageryLayer.prototype._finalizeReprojectTexture = function (context, texture) {\n  let minificationFilter = this.minificationFilter;\n  const magnificationFilter = this.magnificationFilter;\n  const usesLinearTextureFilter =\n    minificationFilter === TextureMinificationFilter.LINEAR &&\n    magnificationFilter === TextureMagnificationFilter.LINEAR;\n  // Use mipmaps if this texture has power-of-two dimensions.\n  // In addition, mipmaps are only generated if the texture filters are both LINEAR.\n  if (\n    usesLinearTextureFilter &&\n    !PixelFormat.isCompressedFormat(texture.pixelFormat) &&\n    CesiumMath.isPowerOfTwo(texture.width) &&\n    CesiumMath.isPowerOfTwo(texture.height)\n  ) {\n    minificationFilter = TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n    const maximumSupportedAnisotropy =\n      ContextLimits.maximumTextureFilterAnisotropy;\n    const maximumAnisotropy = Math.min(\n      maximumSupportedAnisotropy,\n      defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy),\n    );\n    const mipmapSamplerKey = getSamplerKey(\n      minificationFilter,\n      magnificationFilter,\n      maximumAnisotropy,\n    );\n    let mipmapSamplers = context.cache.imageryLayerMipmapSamplers;\n    if (!defined(mipmapSamplers)) {\n      mipmapSamplers = {};\n      context.cache.imageryLayerMipmapSamplers = mipmapSamplers;\n    }\n    let mipmapSampler = mipmapSamplers[mipmapSamplerKey];\n    if (!defined(mipmapSampler)) {\n      mipmapSampler = mipmapSamplers[mipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n        maximumAnisotropy: maximumAnisotropy,\n      });\n    }\n    texture.generateMipmap(MipmapHint.NICEST);\n    texture.sampler = mipmapSampler;\n  } else {\n    const nonMipmapSamplerKey = getSamplerKey(\n      minificationFilter,\n      magnificationFilter,\n      0,\n    );\n    let nonMipmapSamplers = context.cache.imageryLayerNonMipmapSamplers;\n    if (!defined(nonMipmapSamplers)) {\n      nonMipmapSamplers = {};\n      context.cache.imageryLayerNonMipmapSamplers = nonMipmapSamplers;\n    }\n    let nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey];\n    if (!defined(nonMipmapSampler)) {\n      nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n      });\n    }\n    texture.sampler = nonMipmapSampler;\n  }\n};\n\n/**\n * Enqueues a command re-projecting a texture to a {@link GeographicProjection} on the next update, if necessary, and generate\n * mipmaps for the geographic texture.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n * @param {Imagery} imagery The imagery instance to reproject.\n * @param {boolean} [needGeographicProjection=true] True to reproject to geographic, or false if Web Mercator is fine.\n */\nImageryLayer.prototype._reprojectTexture = function (\n  frameState,\n  imagery,\n  needGeographicProjection,\n) {\n  const texture = imagery.textureWebMercator || imagery.texture;\n  const rectangle = imagery.rectangle;\n  const context = frameState.context;\n\n  needGeographicProjection = defaultValue(needGeographicProjection, true);\n\n  // Reproject this texture if it is not already in a geographic projection and\n  // the pixels are more than 1e-5 radians apart.  The pixel spacing cutoff\n  // avoids precision problems in the reprojection transformation while making\n  // no noticeable difference in the georeferencing of the image.\n  if (\n    needGeographicProjection &&\n    !(\n      this._imageryProvider.tilingScheme.projection instanceof\n      GeographicProjection\n    ) &&\n    rectangle.width / texture.width > 1e-5\n  ) {\n    const that = this;\n    imagery.addReference();\n    const computeCommand = new ComputeCommand({\n      persists: true,\n      owner: this,\n      // Update render resources right before execution instead of now.\n      // This allows different ImageryLayers to share the same vao and buffers.\n      preExecute: function (command) {\n        reprojectToGeographic(command, context, texture, imagery.rectangle);\n      },\n      postExecute: function (outputTexture) {\n        imagery.texture = outputTexture;\n        that._finalizeReprojectTexture(context, outputTexture);\n        imagery.state = ImageryState.READY;\n        imagery.releaseReference();\n      },\n      canceled: function () {\n        imagery.state = ImageryState.TEXTURE_LOADED;\n        imagery.releaseReference();\n      },\n    });\n    this._reprojectComputeCommands.push(computeCommand);\n  } else {\n    if (needGeographicProjection) {\n      imagery.texture = texture;\n    }\n    this._finalizeReprojectTexture(context, texture);\n    imagery.state = ImageryState.READY;\n  }\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayer.prototype.queueReprojectionCommands = function (frameState) {\n  const computeCommands = this._reprojectComputeCommands;\n  const length = computeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    frameState.commandList.push(computeCommands[i]);\n  }\n  computeCommands.length = 0;\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayer.prototype.cancelReprojections = function () {\n  this._reprojectComputeCommands.forEach(function (command) {\n    if (defined(command.canceled)) {\n      command.canceled();\n    }\n  });\n  this._reprojectComputeCommands.length = 0;\n};\n\nImageryLayer.prototype.getImageryFromCache = function (\n  x,\n  y,\n  level,\n  imageryRectangle,\n) {\n  const cacheKey = getImageryCacheKey(x, y, level);\n  let imagery = this._imageryCache[cacheKey];\n\n  if (!defined(imagery)) {\n    imagery = new Imagery(this, x, y, level, imageryRectangle);\n    this._imageryCache[cacheKey] = imagery;\n  }\n\n  imagery.addReference();\n  return imagery;\n};\n\nImageryLayer.prototype.removeImageryFromCache = function (imagery) {\n  const cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);\n  delete this._imageryCache[cacheKey];\n};\n\nfunction getImageryCacheKey(x, y, level) {\n  return JSON.stringify([x, y, level]);\n}\n\nconst uniformMap = {\n  u_textureDimensions: function () {\n    return this.textureDimensions;\n  },\n  u_texture: function () {\n    return this.texture;\n  },\n\n  textureDimensions: new Cartesian2(),\n  texture: undefined,\n};\n\nconst float32ArrayScratch = FeatureDetection.supportsTypedArrays()\n  ? new Float32Array(2 * 64)\n  : undefined;\n\nfunction reprojectToGeographic(command, context, texture, rectangle) {\n  // This function has gone through a number of iterations, because GPUs are awesome.\n  //\n  // Originally, we had a very simple vertex shader and computed the Web Mercator texture coordinates\n  // per-fragment in the fragment shader.  That worked well, except on mobile devices, because\n  // fragment shaders have limited precision on many mobile devices.  The result was smearing artifacts\n  // at medium zoom levels because different geographic texture coordinates would be reprojected to Web\n  // Mercator as the same value.\n  //\n  // Our solution was to reproject to Web Mercator in the vertex shader instead of the fragment shader.\n  // This required far more vertex data.  With fragment shader reprojection, we only needed a single quad.\n  // But to achieve the same precision with vertex shader reprojection, we needed a vertex for each\n  // output pixel.  So we used a grid of 256x256 vertices, because most of our imagery\n  // tiles are 256x256.  Fortunately the grid could be created and uploaded to the GPU just once and\n  // re-used for all reprojections, so the performance was virtually unchanged from our original fragment\n  // shader approach.  See https://github.com/CesiumGS/cesium/pull/714.\n  //\n  // Over a year later, we noticed (https://github.com/CesiumGS/cesium/issues/2110)\n  // that our reprojection code was creating a rare but severe artifact on some GPUs (Intel HD 4600\n  // for one).  The problem was that the GLSL sin function on these GPUs had a discontinuity at fine scales in\n  // a few places.\n  //\n  // We solved this by implementing a more reliable sin function based on the CORDIC algorithm\n  // (https://github.com/CesiumGS/cesium/pull/2111).  Even though this was a fair\n  // amount of code to be executing per vertex, the performance seemed to be pretty good on most GPUs.\n  // Unfortunately, on some GPUs, the performance was absolutely terrible\n  // (https://github.com/CesiumGS/cesium/issues/2258).\n  //\n  // So that brings us to our current solution, the one you see here.  Effectively, we compute the Web\n  // Mercator texture coordinates on the CPU and store the T coordinate with each vertex (the S coordinate\n  // is the same in Geographic and Web Mercator).  To make this faster, we reduced our reprojection mesh\n  // to be only 2 vertices wide and 64 vertices high.  We should have reduced the width to 2 sooner,\n  // because the extra vertices weren't buying us anything.  The height of 64 means we are technically\n  // doing a slightly less accurate reprojection than we were before, but we can't see the difference\n  // so it's worth the 4x speedup.\n\n  let reproject = context.cache.imageryLayer_reproject;\n\n  if (!defined(reproject)) {\n    reproject = context.cache.imageryLayer_reproject = {\n      vertexArray: undefined,\n      shaderProgram: undefined,\n      sampler: undefined,\n      destroy: function () {\n        if (defined(this.framebuffer)) {\n          this.framebuffer.destroy();\n        }\n        if (defined(this.vertexArray)) {\n          this.vertexArray.destroy();\n        }\n        if (defined(this.shaderProgram)) {\n          this.shaderProgram.destroy();\n        }\n      },\n    };\n\n    const positions = new Float32Array(2 * 64 * 2);\n    let index = 0;\n    for (let j = 0; j < 64; ++j) {\n      const y = j / 63.0;\n      positions[index++] = 0.0;\n      positions[index++] = y;\n      positions[index++] = 1.0;\n      positions[index++] = y;\n    }\n\n    const reprojectAttributeIndices = {\n      position: 0,\n      webMercatorT: 1,\n    };\n\n    const indices = TerrainProvider.getRegularGridIndices(2, 64);\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n    });\n\n    reproject.vertexArray = new VertexArray({\n      context: context,\n      attributes: [\n        {\n          index: reprojectAttributeIndices.position,\n          vertexBuffer: Buffer.createVertexBuffer({\n            context: context,\n            typedArray: positions,\n            usage: BufferUsage.STATIC_DRAW,\n          }),\n          componentsPerAttribute: 2,\n        },\n        {\n          index: reprojectAttributeIndices.webMercatorT,\n          vertexBuffer: Buffer.createVertexBuffer({\n            context: context,\n            sizeInBytes: 64 * 2 * 4,\n            usage: BufferUsage.STREAM_DRAW,\n          }),\n          componentsPerAttribute: 1,\n        },\n      ],\n      indexBuffer: indexBuffer,\n    });\n\n    const vs = new ShaderSource({\n      sources: [ReprojectWebMercatorVS],\n    });\n\n    reproject.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: ReprojectWebMercatorFS,\n      attributeLocations: reprojectAttributeIndices,\n    });\n\n    reproject.sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    });\n  }\n\n  texture.sampler = reproject.sampler;\n\n  const width = texture.width;\n  const height = texture.height;\n\n  uniformMap.textureDimensions.x = width;\n  uniformMap.textureDimensions.y = height;\n  uniformMap.texture = texture;\n\n  let sinLatitude = Math.sin(rectangle.south);\n  const southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n\n  sinLatitude = Math.sin(rectangle.north);\n  const northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  const oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n\n  const outputTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: texture.pixelFormat,\n    pixelDatatype: texture.pixelDatatype,\n    preMultiplyAlpha: texture.preMultiplyAlpha,\n  });\n\n  // Allocate memory for the mipmaps.  Failure to do this before rendering\n  // to the texture via the FBO, and calling generateMipmap later,\n  // will result in the texture appearing blank.  I can't pretend to\n  // understand exactly why this is.\n  if (CesiumMath.isPowerOfTwo(width) && CesiumMath.isPowerOfTwo(height)) {\n    outputTexture.generateMipmap(MipmapHint.NICEST);\n  }\n\n  const south = rectangle.south;\n  const north = rectangle.north;\n\n  const webMercatorT = float32ArrayScratch;\n\n  let outputIndex = 0;\n  for (let webMercatorTIndex = 0; webMercatorTIndex < 64; ++webMercatorTIndex) {\n    const fraction = webMercatorTIndex / 63.0;\n    const latitude = CesiumMath.lerp(south, north, fraction);\n    sinLatitude = Math.sin(latitude);\n    const mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    const mercatorFraction =\n      (mercatorY - southMercatorY) * oneOverMercatorHeight;\n    webMercatorT[outputIndex++] = mercatorFraction;\n    webMercatorT[outputIndex++] = mercatorFraction;\n  }\n\n  reproject.vertexArray\n    .getAttribute(1)\n    .vertexBuffer.copyFromArrayView(webMercatorT);\n\n  command.shaderProgram = reproject.shaderProgram;\n  command.outputTexture = outputTexture;\n  command.uniformMap = uniformMap;\n  command.vertexArray = reproject.vertexArray;\n}\n\n/**\n * Gets the level with the specified world coordinate spacing between texels, or less.\n *\n * @param {ImageryLayer} layer The imagery layer to use.\n * @param {number} texelSpacing The texel spacing for which to find a corresponding level.\n * @param {number} latitudeClosestToEquator The latitude closest to the equator that we're concerned with.\n * @returns {number} The level with the specified texel spacing or less.\n * @private\n */\nfunction getLevelWithMaximumTexelSpacing(\n  layer,\n  texelSpacing,\n  latitudeClosestToEquator,\n) {\n  // PERFORMANCE_IDEA: factor out the stuff that doesn't change.\n  const imageryProvider = layer._imageryProvider;\n  const tilingScheme = imageryProvider.tilingScheme;\n  const ellipsoid = tilingScheme.ellipsoid;\n  const latitudeFactor = !(\n    layer._imageryProvider.tilingScheme.projection instanceof\n    GeographicProjection\n  )\n    ? Math.cos(latitudeClosestToEquator)\n    : 1.0;\n  const tilingSchemeRectangle = tilingScheme.rectangle;\n  const levelZeroMaximumTexelSpacing =\n    (ellipsoid.maximumRadius * tilingSchemeRectangle.width * latitudeFactor) /\n    (imageryProvider.tileWidth * tilingScheme.getNumberOfXTilesAtLevel(0));\n\n  const twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;\n  const level = Math.log(twoToTheLevelPower) / Math.log(2);\n  const rounded = Math.round(level);\n  return rounded | 0;\n}\n\nfunction handleError(errorEvent, error) {\n  if (errorEvent.numberOfListeners > 0) {\n    errorEvent.raiseEvent(error);\n  } else {\n    // Default handler is to log to the console\n    console.error(error);\n  }\n}\n\nasync function handlePromise(instance, promise) {\n  let provider;\n  try {\n    provider = await Promise.resolve(promise);\n    if (instance.isDestroyed()) {\n      return;\n    }\n    instance._imageryProvider = provider;\n    instance._readyEvent.raiseEvent(provider);\n  } catch (error) {\n    handleError(instance._errorEvent, error);\n  }\n}\n\nexport default ImageryLayer;\n\n/**\n * A function that is called when an error occurs.\n * @callback ImageryLayer.ErrorEventCallback\n *\n * @this ImageryLayer\n * @param {Error} err An object holding details about the error that occurred.\n */\n\n/**\n * A function that is called when the provider has been created\n * @callback ImageryLayer.ReadyEventCallback\n *\n * @this ImageryLayer\n * @param {ImageryProvider} provider The created imagery provider.\n */\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,uBAAuB,MAAM,qCAAqC;AACzE,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,oBAAoB,MAAM,iCAAiC;AAClE,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,WAAW,MAAM,wBAAwB;AAChD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,WAAW,MAAM,wBAAwB;AAChD,OAAOC,eAAe,MAAM,4BAA4B;AACxD,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,MAAM,MAAM,uBAAuB;AAC1C,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,cAAc,MAAM,+BAA+B;AAC1D,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,UAAU,MAAM,2BAA2B;AAClD,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,YAAY,MAAM,6BAA6B;AACtD,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,0BAA0B,MAAM,2CAA2C;AAClF,OAAOC,yBAAyB,MAAM,0CAA0C;AAChF,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,WAAW,MAAM,4BAA4B;AACpD,OAAOC,sBAAsB,MAAM,sCAAsC;AACzE,OAAOC,sBAAsB,MAAM,sCAAsC;AACzE,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,WAAW,MAAM,kBAAkB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,eAAe,EAAEC,OAAO,EAAE;EAC9C,IAAI,CAACC,gBAAgB,GAAGF,eAAe;EAEvC,IAAI,CAACG,WAAW,GAAG,IAAIpC,KAAK,CAAC,CAAC;EAC9B,IAAI,CAACqC,WAAW,GAAG,IAAIrC,KAAK,CAAC,CAAC;EAE9BkC,OAAO,GAAGtC,YAAY,CAACsC,OAAO,EAAEtC,YAAY,CAAC0C,YAAY,CAAC;EAC1DL,eAAe,GAAGrC,YAAY,CAACqC,eAAe,EAAErC,YAAY,CAAC0C,YAAY,CAAC;;EAE1E;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG3C,YAAY,CACvBsC,OAAO,CAACK,KAAK,EACb3C,YAAY,CAACqC,eAAe,CAACO,aAAa,EAAE,GAAG,CACjD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG7C,YAAY,CAC5BsC,OAAO,CAACO,UAAU,EAClB7C,YAAY,CAACqC,eAAe,CAACS,kBAAkB,EAAE,GAAG,CACtD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG/C,YAAY,CAC1BsC,OAAO,CAACS,QAAQ,EAChB/C,YAAY,CAACqC,eAAe,CAACW,gBAAgB,EAAE,GAAG,CACpD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGjD,YAAY,CAC5BsC,OAAO,CAACW,UAAU,EAClBjD,YAAY,CACVqC,eAAe,CAACa,kBAAkB,EAClCd,YAAY,CAACe,kBACf,CACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAGpD,YAAY,CAC1BsC,OAAO,CAACc,QAAQ,EAChBpD,YAAY,CACVqC,eAAe,CAACgB,gBAAgB,EAChCjB,YAAY,CAACkB,gBACf,CACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,GAAG,GAAGvD,YAAY,CACrBsC,OAAO,CAACiB,GAAG,EACXvD,YAAY,CAACqC,eAAe,CAACmB,WAAW,EAAEpB,YAAY,CAACqB,WAAW,CACpE,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG1D,YAAY,CAC5BsC,OAAO,CAACoB,UAAU,EAClB1D,YAAY,CACVqC,eAAe,CAACsB,kBAAkB,EAClCvB,YAAY,CAACwB,kBACf,CACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAG7D,YAAY,CACvBsC,OAAO,CAACuB,KAAK,EACb7D,YAAY,CAACqC,eAAe,CAACyB,aAAa,EAAE1B,YAAY,CAAC2B,aAAa,CACxE,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAGhE,YAAY,CAChCsC,OAAO,CAAC0B,cAAc,EACtB5B,YAAY,CAAC6B,aACf,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAGlE,YAAY,CACpCsC,OAAO,CAAC4B,kBAAkB,EAC1BlE,YAAY,CACVqC,eAAe,CAAC8B,0BAA0B,EAC1C/B,YAAY,CAACgC,2BACf,CACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGrE,YAAY,CACrCsC,OAAO,CAAC+B,mBAAmB,EAC3BrE,YAAY,CACVqC,eAAe,CAACiC,2BAA2B,EAC3ClC,YAAY,CAACmC,4BACf,CACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAGxE,YAAY,CAACsC,OAAO,CAACkC,IAAI,EAAE,IAAI,CAAC;EAE5C,IAAI,CAACC,oBAAoB,GAAGnC,OAAO,CAACoC,mBAAmB;EACvD,IAAI,CAACC,oBAAoB,GAAGrC,OAAO,CAACsC,mBAAmB;EAEvD,IAAI,CAACC,UAAU,GAAG7E,YAAY,CAACsC,OAAO,CAACwC,SAAS,EAAEpE,SAAS,CAACqE,SAAS,CAAC;EACtE,IAAI,CAACC,kBAAkB,GAAG1C,OAAO,CAAC2C,iBAAiB;EAEnD,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;EAEvB,IAAI,CAACC,oBAAoB,GAAG,IAAIhD,WAAW,CAACH,OAAO,CAACoD,iBAAiB,CAAC,IAAI,CAAC,CAAC;;EAE5E;EACA,IAAI,CAACC,KAAK,GAAG,IAAI;;EAEjB;EACA,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;;EAErB;EACA,IAAI,CAACC,YAAY,GAAG,KAAK;EAEzB,IAAI,CAACC,kBAAkB,GAAGC,SAAS;EAEnC,IAAI,CAACC,yBAAyB,GAAG,EAAE;;EAEnC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGrD,OAAO,CAACqD,eAAe;;EAE9C;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAGtD,OAAO,CAACsD,YAAY;;EAExC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,qBAAqB,GAAG7F,YAAY,CACvCsC,OAAO,CAACuD,qBAAqB,EAC7BzD,YAAY,CAAC0D,sCACf,CAAC;AACH;AAEAC,MAAM,CAACC,gBAAgB,CAAC5D,YAAY,CAAC6D,SAAS,EAAE;EAC9C;AACF;AACA;AACA;AACA;AACA;EACE5D,eAAe,EAAE;IACf6D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC3D,gBAAgB;IAC9B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACE4D,KAAK,EAAE;IACLD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAOjG,OAAO,CAAC,IAAI,CAACsC,gBAAgB,CAAC;IACvC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE6D,UAAU,EAAE;IACVF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACzD,WAAW;IACzB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE4D,UAAU,EAAE;IACVH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC1D,WAAW;IACzB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEsC,SAAS,EAAE;IACToB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACrB,UAAU;IACxB;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACAzC,YAAY,CAACe,kBAAkB,GAAG,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACAf,YAAY,CAACkB,gBAAgB,GAAG,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACAlB,YAAY,CAACqB,WAAW,GAAG,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACArB,YAAY,CAACwB,kBAAkB,GAAG,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACAxB,YAAY,CAAC2B,aAAa,GAAG,GAAG;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA3B,YAAY,CAAC6B,aAAa,GAAG/B,cAAc,CAACoE,IAAI;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACAlE,YAAY,CAACgC,2BAA2B,GAAGzC,yBAAyB,CAAC4E,MAAM;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACAnE,YAAY,CAACmC,4BAA4B,GAAG7C,0BAA0B,CAAC6E,MAAM;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACAnE,YAAY,CAAC0D,sCAAsC,GAAG,KAAK;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1D,YAAY,CAACoE,iBAAiB,GAAG,UAAUC,sBAAsB,EAAEnE,OAAO,EAAE;EAC1E;EACAxC,KAAK,CAAC4G,MAAM,CAACC,MAAM,CAAC,wBAAwB,EAAEF,sBAAsB,CAAC;EACrE;;EAEA,MAAMG,KAAK,GAAG,IAAIxE,YAAY,CAACqD,SAAS,EAAEnD,OAAO,CAAC;EAElDuE,aAAa,CAACD,KAAK,EAAEE,OAAO,CAACC,OAAO,CAACN,sBAAsB,CAAC,CAAC;EAE7D,OAAOG,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxE,YAAY,CAAC4E,gBAAgB,GAAG,UAAU1E,OAAO,EAAE;EACjDA,OAAO,GAAGtC,YAAY,CAACsC,OAAO,EAAEtC,YAAY,CAAC0C,YAAY,CAAC;EAE1D,OAAON,YAAY,CAACoE,iBAAiB,CACnCzG,uBAAuB,CAAC;IACtBkH,KAAK,EAAE3E,OAAO,CAAC2E;EACjB,CAAC,CAAC,EACF3E,OACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,YAAY,CAAC6D,SAAS,CAACiB,WAAW,GAAG,YAAY;EAC/C,OAAO,IAAI,CAAC3B,Y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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}