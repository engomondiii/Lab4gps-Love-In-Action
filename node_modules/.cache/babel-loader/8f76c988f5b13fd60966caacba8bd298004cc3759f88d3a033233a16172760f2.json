{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Gets the GLSL functions needed to retrieve clipping planes from a ClippingPlaneCollection's texture.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection ClippingPlaneCollection with a defined texture.\n * @param {Context} context The current rendering context.\n * @returns {string} A string containing GLSL functions for retrieving clipping planes.\n * @private\n */\nfunction getClippingFunction(clippingPlaneCollection, context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"clippingPlaneCollection\", clippingPlaneCollection);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n  const unionClippingRegions = clippingPlaneCollection.unionClippingRegions;\n  const clippingPlanesLength = clippingPlaneCollection.length;\n  const usingFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n  const textureResolution = ClippingPlaneCollection.getTextureResolution(clippingPlaneCollection, context, textureResolutionScratch);\n  const width = textureResolution.x;\n  const height = textureResolution.y;\n  let functions = usingFloatTexture ? getClippingPlaneFloat(width, height) : getClippingPlaneUint8(width, height);\n  functions += \"\\n\";\n  functions += unionClippingRegions ? clippingFunctionUnion(clippingPlanesLength) : clippingFunctionIntersect(clippingPlanesLength);\n  return functions;\n}\nfunction clippingFunctionUnion(clippingPlanesLength) {\n  const functionString = `${\"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" + \"{\\n\" + \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" + \"    vec3 clipNormal = vec3(0.0);\\n\" + \"    vec3 clipPosition = vec3(0.0);\\n\" + \"    float clipAmount;\\n\" +\n  // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below.\n  \"    float pixelWidth = czm_metersPerPixel(position);\\n\" + \"    bool breakAndDiscard = false;\\n\" + \"    for (int i = 0; i < \"}${clippingPlanesLength}; ++i)\\n` + `    {\\n` + `        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n` + `        clipNormal = clippingPlane.xyz;\\n` + `        clipPosition = -clippingPlane.w * clipNormal;\\n` + `        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n` + `        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\\n` + `        if (amount <= 0.0)\\n` + `        {\\n` + `           breakAndDiscard = true;\\n` + `           break;\\n` +\n  // HLSL compiler bug if we discard here: https://bugs.chromium.org/p/angleproject/issues/detail?id=1945#c6\n  `        }\\n` + `    }\\n` + `    if (breakAndDiscard) {\\n` + `        discard;\\n` + `    }\\n` + `    return clipAmount;\\n` + `}\\n`;\n  return functionString;\n}\nfunction clippingFunctionIntersect(clippingPlanesLength) {\n  const functionString = `${\"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" + \"{\\n\" + \"    bool clipped = true;\\n\" + \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" + \"    vec3 clipNormal = vec3(0.0);\\n\" + \"    vec3 clipPosition = vec3(0.0);\\n\" + \"    float clipAmount = 0.0;\\n\" + \"    float pixelWidth = czm_metersPerPixel(position);\\n\" + \"    for (int i = 0; i < \"}${clippingPlanesLength}; ++i)\\n` + `    {\\n` + `        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n` + `        clipNormal = clippingPlane.xyz;\\n` + `        clipPosition = -clippingPlane.w * clipNormal;\\n` + `        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n` + `        clipAmount = max(amount, clipAmount);\\n` + `        clipped = clipped && (amount <= 0.0);\\n` + `    }\\n` + `    if (clipped)\\n` + `    {\\n` + `        discard;\\n` + `    }\\n` + `    return clipAmount;\\n` + `}\\n`;\n  return functionString;\n}\nfunction getClippingPlaneFloat(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n  const functionString = `${\"vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" + \"{\\n\" + \"    int pixY = clippingPlaneNumber / \"}${width};\\n` + `    int pixX = clippingPlaneNumber - (pixY * ${width});\\n` + `    float u = (float(pixX) + 0.5) * ${pixelWidthString};\\n` +\n  // sample from center of pixel\n  `    float v = (float(pixY) + 0.5) * ${pixelHeightString};\\n` + `    vec4 plane = texture(packedClippingPlanes, vec2(u, v));\\n` + `    return czm_transformPlane(plane, transform);\\n` + `}\\n`;\n  return functionString;\n}\nfunction getClippingPlaneUint8(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n  const functionString = `${\"vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" + \"{\\n\" + \"    int clippingPlaneStartIndex = clippingPlaneNumber * 2;\\n\" +\n  // clipping planes are two pixels each\n  \"    int pixY = clippingPlaneStartIndex / \"}${width};\\n` + `    int pixX = clippingPlaneStartIndex - (pixY * ${width});\\n` + `    float u = (float(pixX) + 0.5) * ${pixelWidthString};\\n` +\n  // sample from center of pixel\n  `    float v = (float(pixY) + 0.5) * ${pixelHeightString};\\n` + `    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;\\n` + `    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\\n` + `    vec4 plane;\\n` + `    plane.xyz = czm_octDecode(oct, 65535.0);\\n` + `    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + ${pixelWidthString}, v)));\\n` + `    return czm_transformPlane(plane, transform);\\n` + `}\\n`;\n  return functionString;\n}\nexport default getClippingFunction;","map":{"version":3,"names":["Cartesian2","Check","ClippingPlaneCollection","textureResolutionScratch","getClippingFunction","clippingPlaneCollection","context","typeOf","object","unionClippingRegions","clippingPlanesLength","length","usingFloatTexture","useFloatTexture","textureResolution","getTextureResolution","width","x","height","y","functions","getClippingPlaneFloat","getClippingPlaneUint8","clippingFunctionUnion","clippingFunctionIntersect","functionString","pixelWidth","pixelHeight","pixelWidthString","indexOf","pixelHeightString"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/getClippingFunction.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Gets the GLSL functions needed to retrieve clipping planes from a ClippingPlaneCollection's texture.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection ClippingPlaneCollection with a defined texture.\n * @param {Context} context The current rendering context.\n * @returns {string} A string containing GLSL functions for retrieving clipping planes.\n * @private\n */\nfunction getClippingFunction(clippingPlaneCollection, context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"clippingPlaneCollection\", clippingPlaneCollection);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n  const unionClippingRegions = clippingPlaneCollection.unionClippingRegions;\n  const clippingPlanesLength = clippingPlaneCollection.length;\n  const usingFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n  const textureResolution = ClippingPlaneCollection.getTextureResolution(\n    clippingPlaneCollection,\n    context,\n    textureResolutionScratch,\n  );\n  const width = textureResolution.x;\n  const height = textureResolution.y;\n\n  let functions = usingFloatTexture\n    ? getClippingPlaneFloat(width, height)\n    : getClippingPlaneUint8(width, height);\n  functions += \"\\n\";\n  functions += unionClippingRegions\n    ? clippingFunctionUnion(clippingPlanesLength)\n    : clippingFunctionIntersect(clippingPlanesLength);\n  return functions;\n}\n\nfunction clippingFunctionUnion(clippingPlanesLength) {\n  const functionString =\n    `${\n      \"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" +\n      \"{\\n\" +\n      \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" +\n      \"    vec3 clipNormal = vec3(0.0);\\n\" +\n      \"    vec3 clipPosition = vec3(0.0);\\n\" +\n      \"    float clipAmount;\\n\" + // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below.\n      \"    float pixelWidth = czm_metersPerPixel(position);\\n\" +\n      \"    bool breakAndDiscard = false;\\n\" +\n      \"    for (int i = 0; i < \"\n    }${clippingPlanesLength}; ++i)\\n` +\n    `    {\\n` +\n    `        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n` +\n    `        clipNormal = clippingPlane.xyz;\\n` +\n    `        clipPosition = -clippingPlane.w * clipNormal;\\n` +\n    `        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n` +\n    `        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\\n` +\n    `        if (amount <= 0.0)\\n` +\n    `        {\\n` +\n    `           breakAndDiscard = true;\\n` +\n    `           break;\\n` + // HLSL compiler bug if we discard here: https://bugs.chromium.org/p/angleproject/issues/detail?id=1945#c6\n    `        }\\n` +\n    `    }\\n` +\n    `    if (breakAndDiscard) {\\n` +\n    `        discard;\\n` +\n    `    }\\n` +\n    `    return clipAmount;\\n` +\n    `}\\n`;\n  return functionString;\n}\n\nfunction clippingFunctionIntersect(clippingPlanesLength) {\n  const functionString =\n    `${\n      \"float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\\n\" +\n      \"{\\n\" +\n      \"    bool clipped = true;\\n\" +\n      \"    vec4 position = czm_windowToEyeCoordinates(fragCoord);\\n\" +\n      \"    vec3 clipNormal = vec3(0.0);\\n\" +\n      \"    vec3 clipPosition = vec3(0.0);\\n\" +\n      \"    float clipAmount = 0.0;\\n\" +\n      \"    float pixelWidth = czm_metersPerPixel(position);\\n\" +\n      \"    for (int i = 0; i < \"\n    }${clippingPlanesLength}; ++i)\\n` +\n    `    {\\n` +\n    `        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\\n` +\n    `        clipNormal = clippingPlane.xyz;\\n` +\n    `        clipPosition = -clippingPlane.w * clipNormal;\\n` +\n    `        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\\n` +\n    `        clipAmount = max(amount, clipAmount);\\n` +\n    `        clipped = clipped && (amount <= 0.0);\\n` +\n    `    }\\n` +\n    `    if (clipped)\\n` +\n    `    {\\n` +\n    `        discard;\\n` +\n    `    }\\n` +\n    `    return clipAmount;\\n` +\n    `}\\n`;\n  return functionString;\n}\n\nfunction getClippingPlaneFloat(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  const functionString =\n    `${\n      \"vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" +\n      \"{\\n\" +\n      \"    int pixY = clippingPlaneNumber / \"\n    }${width};\\n` +\n    `    int pixX = clippingPlaneNumber - (pixY * ${width});\\n` +\n    `    float u = (float(pixX) + 0.5) * ${pixelWidthString};\\n` + // sample from center of pixel\n    `    float v = (float(pixY) + 0.5) * ${pixelHeightString};\\n` +\n    `    vec4 plane = texture(packedClippingPlanes, vec2(u, v));\\n` +\n    `    return czm_transformPlane(plane, transform);\\n` +\n    `}\\n`;\n  return functionString;\n}\n\nfunction getClippingPlaneUint8(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  const functionString =\n    `${\n      \"vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\\n\" +\n      \"{\\n\" +\n      \"    int clippingPlaneStartIndex = clippingPlaneNumber * 2;\\n\" + // clipping planes are two pixels each\n      \"    int pixY = clippingPlaneStartIndex / \"\n    }${width};\\n` +\n    `    int pixX = clippingPlaneStartIndex - (pixY * ${width});\\n` +\n    `    float u = (float(pixX) + 0.5) * ${pixelWidthString};\\n` + // sample from center of pixel\n    `    float v = (float(pixY) + 0.5) * ${pixelHeightString};\\n` +\n    `    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;\\n` +\n    `    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\\n` +\n    `    vec4 plane;\\n` +\n    `    plane.xyz = czm_octDecode(oct, 65535.0);\\n` +\n    `    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + ${pixelWidthString}, v)));\\n` +\n    `    return czm_transformPlane(plane, transform);\\n` +\n    `}\\n`;\n  return functionString;\n}\nexport default getClippingFunction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}