{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport ShaderDestination from \"./ShaderDestination.js\";\nimport ShaderProgram from \"./ShaderProgram.js\";\nimport ShaderSource from \"./ShaderSource.js\";\nimport ShaderStruct from \"./ShaderStruct.js\";\nimport ShaderFunction from \"./ShaderFunction.js\";\n\n/**\n * An object that makes it easier to build the text of a {@link ShaderProgram}. This tracks GLSL code for both the vertex shader and the fragment shader.\n * <p>\n * For vertex shaders, the shader builder tracks a list of <code>#defines</code>,\n * a list of attributes, a list of uniforms, and a list of shader lines. It also\n * tracks the location of each attribute so the caller can easily build the {@link VertexArray}\n * </p>\n * <p>\n * For fragment shaders, the shader builder tracks a list of <code>#defines</code>,\n * a list of attributes, a list of uniforms, and a list of shader lines.\n * </p>\n *\n * @alias ShaderBuilder\n * @constructor\n *\n * @example\n * const shaderBuilder = new ShaderBuilder();\n * shaderBuilder.addDefine(\"SOLID_COLOR\", undefined, ShaderDestination.FRAGMENT);\n * shaderBuilder.addUniform(\"vec3\", \"u_color\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addVarying(\"vec3\", v_color\");\n * // These locations can be used when creating the VertexArray\n * const positionLocation = shaderBuilder.addPositionAttribute(\"vec3\", \"a_position\");\n * const colorLocation = shaderBuilder.addAttribute(\"vec3\", \"a_color\");\n * shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);\n * shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);\n * const shaderProgram = shaderBuilder.build(context);\n *\n * @private\n */\nfunction ShaderBuilder() {\n  // Some WebGL implementations require attribute 0 to always\n  // be active, so the position attribute is tracked separately\n  this._positionAttributeLine = undefined;\n  this._nextAttributeLocation = 1;\n  this._attributeLocations = {};\n  this._attributeLines = [];\n\n  // Dynamically-generated structs and functions\n  // these are dictionaries of id -> ShaderStruct or ShaderFunction respectively\n  this._structs = {};\n  this._functions = {};\n  this._vertexShaderParts = {\n    defineLines: [],\n    uniformLines: [],\n    shaderLines: [],\n    varyingLines: [],\n    // identifiers of structs/functions to include, listed in insertion order\n    structIds: [],\n    functionIds: []\n  };\n  this._fragmentShaderParts = {\n    defineLines: [],\n    uniformLines: [],\n    shaderLines: [],\n    varyingLines: [],\n    // identifiers of structs/functions to include, listed in insertion order\n    structIds: [],\n    functionIds: []\n  };\n}\nObject.defineProperties(ShaderBuilder.prototype, {\n  /**\n   * Get a dictionary of attribute names to the integer location in\n   * the vertex shader.\n   *\n   * @memberof ShaderBuilder.prototype\n   * @type {Object<string, number>}\n   * @readonly\n   * @private\n   */\n  attributeLocations: {\n    get: function () {\n      return this._attributeLocations;\n    }\n  }\n});\n\n/**\n * Add a <code>#define</code> macro to one or both of the shaders. These lines\n * will appear at the top of the final shader source.\n *\n * @param {string} identifier An identifier for the macro. Identifiers must use uppercase letters with underscores to be consistent with Cesium's style guide.\n * @param {string} [value] The value of the macro. If undefined, the define will not include a value. The value will be converted to GLSL code via <code>toString()</code>\n * @param {ShaderDestination} [destination=ShaderDestination.BOTH] Whether the define appears in the vertex shader, the fragment shader, or both.\n *\n * @example\n * // creates the line \"#define ENABLE_LIGHTING\" in both shaders\n * shaderBuilder.addDefine(\"ENABLE_LIGHTING\");\n * // creates the line \"#define PI 3.141592\" in the fragment shader\n * shaderBuilder.addDefine(\"PI\", 3.141593, ShaderDestination.FRAGMENT);\n */\nShaderBuilder.prototype.addDefine = function (identifier, value, destination) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  destination = defaultValue(destination, ShaderDestination.BOTH);\n\n  // The ShaderSource created in build() will add the #define part\n  let line = identifier;\n  if (defined(value)) {\n    line += ` ${value.toString()}`;\n  }\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.defineLines.push(line);\n  }\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.defineLines.push(line);\n  }\n};\n\n/**\n * Add a new dynamically-generated struct to the shader\n * @param {string} structId A unique ID to identify this struct in {@link ShaderBuilder#addStructField}\n * @param {string} structName The name of the struct as it will appear in the shader.\n * @param {ShaderDestination} destination Whether the struct will appear in the vertex shader, the fragment shader, or both.\n *\n * @example\n * // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);\n */\nShaderBuilder.prototype.addStruct = function (structId, structName, destination) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"structId\", structId);\n  Check.typeOf.string(\"structName\", structName);\n  Check.typeOf.number(\"destination\", destination);\n  //>>includeEnd('debug');\n  this._structs[structId] = new ShaderStruct(structName);\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.structIds.push(structId);\n  }\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.structIds.push(structId);\n  }\n};\n\n/**\n * Add a field to a dynamically-generated struct.\n * @param {string} structId The ID of the struct. This must be created first with {@link ShaderBuilder#addStruct}\n * @param {string} type The GLSL type of the field\n * @param {string} identifier The identifier of the field.\n *\n * @example\n * // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * //    float minimum;\n * //    float maximum;\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"maximum\");\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"minimum\");\n */\nShaderBuilder.prototype.addStructField = function (structId, type, identifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"structId\", structId);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n  this._structs[structId].addField(type, identifier);\n};\n\n/**\n * Add a new dynamically-generated function to the shader.\n * @param {string} functionName The name of the function. This will be used to identify the function in {@link ShaderBuilder#addFunctionLines}.\n * @param {string} signature The full signature of the function as it will appear in the shader. Do not include the curly braces.\n * @param {ShaderDestination} destination Whether the struct will appear in the vertex shader, the fragment shader, or both.\n * @example\n * // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);\n */\nShaderBuilder.prototype.addFunction = function (functionName, signature, destination) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"functionName\", functionName);\n  Check.typeOf.string(\"signature\", signature);\n  Check.typeOf.number(\"destination\", destination);\n  //>>includeEnd('debug');\n  this._functions[functionName] = new ShaderFunction(signature);\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.functionIds.push(functionName);\n  }\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.functionIds.push(functionName);\n  }\n};\n\n/**\n * Add lines to a dynamically-generated function\n * @param {string} functionName The name of the function. This must be created beforehand using {@link ShaderBuilder#addFunction}\n * @param {string|string[]} lines One or more lines of GLSL code to add to the function body. Do not include any preceding or ending whitespace, but do include the semicolon for each line.\n *\n * @example\n * // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * //   float signed = 2.0 * parameter - 1.0;\n * //   return vec3(signed, 0.0, 0.0);\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);\n * shaderBuilder.addFunctionLines(\"testFunction\", [\n *   \"float signed = 2.0 * parameter - 1.0;\",\n *   \"return vec3(parameter);\"\n * ]);\n */\nShaderBuilder.prototype.addFunctionLines = function (functionName, lines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"functionName\", functionName);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(`Expected lines to be a string or an array of strings, actual value was ${lines}`);\n  }\n  //>>includeEnd('debug');\n  this._functions[functionName].addLines(lines);\n};\n\n/**\n * Add a uniform declaration to one or both of the shaders. These lines\n * will appear grouped near the top of the final shader source.\n *\n * @param {string} type The GLSL type of the uniform.\n * @param {string} identifier An identifier for the uniform. Identifiers must begin with <code>u_</code> to be consistent with Cesium's style guide.\n * @param {ShaderDestination} [destination=ShaderDestination.BOTH] Whether the uniform appears in the vertex shader, the fragment shader, or both.\n *\n * @example\n * // creates the line \"uniform vec3 u_resolution;\"\n * shaderBuilder.addUniform(\"vec3\", \"u_resolution\", ShaderDestination.FRAGMENT);\n * // creates the line \"uniform float u_time;\" in both shaders\n * shaderBuilder.addUniform(\"float\", \"u_time\", ShaderDestination.BOTH);\n */\nShaderBuilder.prototype.addUniform = function (type, identifier, destination) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  destination = defaultValue(destination, ShaderDestination.BOTH);\n  const line = `uniform ${type} ${identifier};`;\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.uniformLines.push(line);\n  }\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.uniformLines.push(line);\n  }\n};\n\n/**\n * Add a position attribute declaration to the vertex shader. These lines\n * will appear grouped near the top of the final shader source.\n * <p>\n * Some WebGL implementations require attribute 0 to be enabled, so this is\n * reserved for the position attribute. For all other attributes, see\n * {@link ShaderBuilder#addAttribute}\n * </p>\n *\n * @param {string} type The GLSL type of the attribute\n * @param {string} identifier An identifier for the attribute. Identifiers must begin with <code>a_</code> to be consistent with Cesium's style guide.\n * @return {number} The integer location of the attribute. This location can be used when creating attributes for a {@link VertexArray}. This will always be 0.\n *\n * @example\n * // creates the line \"in vec3 a_position;\"\n * shaderBuilder.setPositionAttribute(\"vec3\", \"a_position\");\n */\nShaderBuilder.prototype.setPositionAttribute = function (type, identifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  if (defined(this._positionAttributeLine)) {\n    throw new DeveloperError(\"setPositionAttribute() must be called exactly once for the attribute used for gl_Position. For other attributes, use addAttribute()\");\n  }\n  //>>includeEnd('debug');\n\n  this._positionAttributeLine = `in ${type} ${identifier};`;\n\n  // Some WebGL implementations require attribute 0 to always be active, so\n  // this builder assumes the position will always go in location 0\n  this._attributeLocations[identifier] = 0;\n  return 0;\n};\n\n/**\n * Add an attribute declaration to the vertex shader. These lines\n * will appear grouped near the top of the final shader source.\n * <p>\n * Some WebGL implementations require attribute 0 to be enabled, so this is\n * reserved for the position attribute. See {@link ShaderBuilder#setPositionAttribute}\n * </p>\n *\n * @param {string} type The GLSL type of the attribute\n * @param {string} identifier An identifier for the attribute. Identifiers must begin with <code>a_</code> to be consistent with Cesium's style guide.\n * @return {number} The integer location of the attribute. This location can be used when creating attributes for a {@link VertexArray}\n *\n * @example\n * // creates the line \"in vec2 a_texCoord0;\" in the vertex shader\n * shaderBuilder.addAttribute(\"vec2\", \"a_texCoord0\");\n */\nShaderBuilder.prototype.addAttribute = function (type, identifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  const line = `in ${type} ${identifier};`;\n  this._attributeLines.push(line);\n  const location = this._nextAttributeLocation;\n  this._attributeLocations[identifier] = location;\n\n  // Most attributes only require a single attribute location, but matrices\n  // require more.\n  this._nextAttributeLocation += getAttributeLocationCount(type);\n  return location;\n};\n\n/**\n * Add a varying declaration to both the vertex and fragment shaders.\n *\n * @param {string} type The GLSL type of the varying\n * @param {string} identifier An identifier for the varying. Identifiers must begin with <code>v_</code> to be consistent with Cesium's style guide.\n * @param {string} [qualifier] A qualifier for the varying, such as <code>flat</code>.\n *\n * @example\n * // creates the line \"in vec3 v_color;\" in the vertex shader\n * // creates the line \"out vec3 v_color;\" in the fragment shader\n * shaderBuilder.addVarying(\"vec3\", \"v_color\");\n */\nShaderBuilder.prototype.addVarying = function (type, identifier, qualifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  qualifier = defined(qualifier) ? `${qualifier} ` : \"\";\n  const line = `${type} ${identifier};`;\n  this._vertexShaderParts.varyingLines.push(`${qualifier}out ${line}`);\n  this._fragmentShaderParts.varyingLines.push(`${qualifier}in ${line}`);\n};\n\n/**\n * Appends lines of GLSL code to the vertex shader\n *\n * @param {string|string[]} lines One or more lines to add to the end of the vertex shader source\n *\n * @example\n * shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);\n */\nShaderBuilder.prototype.addVertexLines = function (lines) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(`Expected lines to be a string or an array of strings, actual value was ${lines}`);\n  }\n  //>>includeEnd('debug');\n\n  const vertexLines = this._vertexShaderParts.shaderLines;\n  if (Array.isArray(lines)) {\n    vertexLines.push.apply(vertexLines, lines);\n  } else {\n    // Single string case\n    vertexLines.push(lines);\n  }\n};\n\n/**\n * Appends lines of GLSL code to the fragment shader\n *\n * @param {string[]} lines The lines to add to the end of the fragment shader source\n *\n * @example\n * shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);\n */\nShaderBuilder.prototype.addFragmentLines = function (lines) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(`Expected lines to be a string or an array of strings, actual value was ${lines}`);\n  }\n  //>>includeEnd('debug');\n\n  const fragmentLines = this._fragmentShaderParts.shaderLines;\n  if (Array.isArray(lines)) {\n    fragmentLines.push.apply(fragmentLines, lines);\n  } else {\n    // Single string case\n    fragmentLines.push(lines);\n  }\n};\n\n/**\n * Builds the {@link ShaderProgram} from the pieces added by the other methods.\n * Call this one time at the end of modifying the shader through the other\n * methods in this class.\n *\n * @param {Context} context The context to use for creating the shader.\n * @return {ShaderProgram} A shader program to use for rendering.\n *\n * @example\n * const shaderProgram = shaderBuilder.buildShaderProgram(context);\n */\nShaderBuilder.prototype.buildShaderProgram = function (context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n\n  const positionAttribute = defined(this._positionAttributeLine) ? [this._positionAttributeLine] : [];\n  const structLines = generateStructLines(this);\n  const functionLines = generateFunctionLines(this);\n\n  // Lines are joined here so the ShaderSource\n  // generates a single #line 0 directive\n  const vertexLines = positionAttribute.concat(this._attributeLines, this._vertexShaderParts.uniformLines, this._vertexShaderParts.varyingLines, structLines.vertexLines, functionLines.vertexLines, this._vertexShaderParts.shaderLines).join(\"\\n\");\n  const vertexShaderSource = new ShaderSource({\n    defines: this._vertexShaderParts.defineLines,\n    sources: [vertexLines]\n  });\n  const fragmentLines = this._fragmentShaderParts.uniformLines.concat(this._fragmentShaderParts.varyingLines, structLines.fragmentLines, functionLines.fragmentLines, this._fragmentShaderParts.shaderLines).join(\"\\n\");\n  const fragmentShaderSource = new ShaderSource({\n    defines: this._fragmentShaderParts.defineLines,\n    sources: [fragmentLines]\n  });\n  return ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vertexShaderSource,\n    fragmentShaderSource: fragmentShaderSource,\n    attributeLocations: this._attributeLocations\n  });\n};\nShaderBuilder.prototype.clone = function () {\n  return clone(this, true);\n};\nfunction generateStructLines(shaderBuilder) {\n  const vertexLines = [];\n  const fragmentLines = [];\n  let i;\n  let structIds = shaderBuilder._vertexShaderParts.structIds;\n  let structId;\n  let struct;\n  let structLines;\n  for (i = 0; i < structIds.length; i++) {\n    structId = structIds[i];\n    struct = shaderBuilder._structs[structId];\n    structLines = struct.generateGlslLines();\n    vertexLines.push.apply(vertexLines, structLines);\n  }\n  structIds = shaderBuilder._fragmentShaderParts.structIds;\n  for (i = 0; i < structIds.length; i++) {\n    structId = structIds[i];\n    struct = shaderBuilder._structs[structId];\n    structLines = struct.generateGlslLines();\n    fragmentLines.push.apply(fragmentLines, structLines);\n  }\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines\n  };\n}\nfunction getAttributeLocationCount(glslType) {\n  switch (glslType) {\n    case \"mat2\":\n      return 2;\n    case \"mat3\":\n      return 3;\n    case \"mat4\":\n      return 4;\n    default:\n      return 1;\n  }\n}\nfunction generateFunctionLines(shaderBuilder) {\n  const vertexLines = [];\n  const fragmentLines = [];\n  let i;\n  let functionIds = shaderBuilder._vertexShaderParts.functionIds;\n  let functionId;\n  let func;\n  let functionLines;\n  for (i = 0; i < functionIds.length; i++) {\n    functionId = functionIds[i];\n    func = shaderBuilder._functions[functionId];\n    functionLines = func.generateGlslLines();\n    vertexLines.push.apply(vertexLines, functionLines);\n  }\n  functionIds = shaderBuilder._fragmentShaderParts.functionIds;\n  for (i = 0; i < functionIds.length; i++) {\n    functionId = functionIds[i];\n    func = shaderBuilder._functions[functionId];\n    functionLines = func.generateGlslLines();\n    fragmentLines.push.apply(fragmentLines, functionLines);\n  }\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines\n  };\n}\nexport default ShaderBuilder;","map":{"version":3,"names":["Check","clone","defined","defaultValue","DeveloperError","ShaderDestination","ShaderProgram","ShaderSource","ShaderStruct","ShaderFunction","ShaderBuilder","_positionAttributeLine","undefined","_nextAttributeLocation","_attributeLocations","_attributeLines","_structs","_functions","_vertexShaderParts","defineLines","uniformLines","shaderLines","varyingLines","structIds","functionIds","_fragmentShaderParts","Object","defineProperties","prototype","attributeLocations","get","addDefine","identifier","value","destination","typeOf","string","BOTH","line","toString","includesVertexShader","push","includesFragmentShader","addStruct","structId","structName","number","addStructField","type","addField","addFunction","functionName","signature","addFunctionLines","lines","Array","isArray","addLines","addUniform","setPositionAttribute","addAttribute","location","getAttributeLocationCount","addVarying","qualifier","addVertexLines","vertexLines","apply","addFragmentLines","fragmentLines","buildShaderProgram","context","object","positionAttribute","structLines","generateStructLines","functionLines","generateFunctionLines","concat","join","vertexShaderSource","defines","sources","fragmentShaderSource","fromCache","shaderBuilder","i","struct","length","generateGlslLines","glslType","functionId","func"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/ShaderBuilder.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport ShaderDestination from \"./ShaderDestination.js\";\nimport ShaderProgram from \"./ShaderProgram.js\";\nimport ShaderSource from \"./ShaderSource.js\";\nimport ShaderStruct from \"./ShaderStruct.js\";\nimport ShaderFunction from \"./ShaderFunction.js\";\n\n/**\n * An object that makes it easier to build the text of a {@link ShaderProgram}. This tracks GLSL code for both the vertex shader and the fragment shader.\n * <p>\n * For vertex shaders, the shader builder tracks a list of <code>#defines</code>,\n * a list of attributes, a list of uniforms, and a list of shader lines. It also\n * tracks the location of each attribute so the caller can easily build the {@link VertexArray}\n * </p>\n * <p>\n * For fragment shaders, the shader builder tracks a list of <code>#defines</code>,\n * a list of attributes, a list of uniforms, and a list of shader lines.\n * </p>\n *\n * @alias ShaderBuilder\n * @constructor\n *\n * @example\n * const shaderBuilder = new ShaderBuilder();\n * shaderBuilder.addDefine(\"SOLID_COLOR\", undefined, ShaderDestination.FRAGMENT);\n * shaderBuilder.addUniform(\"vec3\", \"u_color\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addVarying(\"vec3\", v_color\");\n * // These locations can be used when creating the VertexArray\n * const positionLocation = shaderBuilder.addPositionAttribute(\"vec3\", \"a_position\");\n * const colorLocation = shaderBuilder.addAttribute(\"vec3\", \"a_color\");\n * shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);\n * shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);\n * const shaderProgram = shaderBuilder.build(context);\n *\n * @private\n */\nfunction ShaderBuilder() {\n  // Some WebGL implementations require attribute 0 to always\n  // be active, so the position attribute is tracked separately\n  this._positionAttributeLine = undefined;\n  this._nextAttributeLocation = 1;\n  this._attributeLocations = {};\n  this._attributeLines = [];\n\n  // Dynamically-generated structs and functions\n  // these are dictionaries of id -> ShaderStruct or ShaderFunction respectively\n  this._structs = {};\n  this._functions = {};\n\n  this._vertexShaderParts = {\n    defineLines: [],\n    uniformLines: [],\n    shaderLines: [],\n    varyingLines: [],\n    // identifiers of structs/functions to include, listed in insertion order\n    structIds: [],\n    functionIds: [],\n  };\n  this._fragmentShaderParts = {\n    defineLines: [],\n    uniformLines: [],\n    shaderLines: [],\n    varyingLines: [],\n    // identifiers of structs/functions to include, listed in insertion order\n    structIds: [],\n    functionIds: [],\n  };\n}\n\nObject.defineProperties(ShaderBuilder.prototype, {\n  /**\n   * Get a dictionary of attribute names to the integer location in\n   * the vertex shader.\n   *\n   * @memberof ShaderBuilder.prototype\n   * @type {Object<string, number>}\n   * @readonly\n   * @private\n   */\n  attributeLocations: {\n    get: function () {\n      return this._attributeLocations;\n    },\n  },\n});\n\n/**\n * Add a <code>#define</code> macro to one or both of the shaders. These lines\n * will appear at the top of the final shader source.\n *\n * @param {string} identifier An identifier for the macro. Identifiers must use uppercase letters with underscores to be consistent with Cesium's style guide.\n * @param {string} [value] The value of the macro. If undefined, the define will not include a value. The value will be converted to GLSL code via <code>toString()</code>\n * @param {ShaderDestination} [destination=ShaderDestination.BOTH] Whether the define appears in the vertex shader, the fragment shader, or both.\n *\n * @example\n * // creates the line \"#define ENABLE_LIGHTING\" in both shaders\n * shaderBuilder.addDefine(\"ENABLE_LIGHTING\");\n * // creates the line \"#define PI 3.141592\" in the fragment shader\n * shaderBuilder.addDefine(\"PI\", 3.141593, ShaderDestination.FRAGMENT);\n */\nShaderBuilder.prototype.addDefine = function (identifier, value, destination) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  destination = defaultValue(destination, ShaderDestination.BOTH);\n\n  // The ShaderSource created in build() will add the #define part\n  let line = identifier;\n  if (defined(value)) {\n    line += ` ${value.toString()}`;\n  }\n\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.defineLines.push(line);\n  }\n\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.defineLines.push(line);\n  }\n};\n\n/**\n * Add a new dynamically-generated struct to the shader\n * @param {string} structId A unique ID to identify this struct in {@link ShaderBuilder#addStructField}\n * @param {string} structName The name of the struct as it will appear in the shader.\n * @param {ShaderDestination} destination Whether the struct will appear in the vertex shader, the fragment shader, or both.\n *\n * @example\n * // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);\n */\nShaderBuilder.prototype.addStruct = function (\n  structId,\n  structName,\n  destination,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"structId\", structId);\n  Check.typeOf.string(\"structName\", structName);\n  Check.typeOf.number(\"destination\", destination);\n  //>>includeEnd('debug');\n  this._structs[structId] = new ShaderStruct(structName);\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.structIds.push(structId);\n  }\n\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.structIds.push(structId);\n  }\n};\n\n/**\n * Add a field to a dynamically-generated struct.\n * @param {string} structId The ID of the struct. This must be created first with {@link ShaderBuilder#addStruct}\n * @param {string} type The GLSL type of the field\n * @param {string} identifier The identifier of the field.\n *\n * @example\n * // generates the following struct in the fragment shader\n * // struct TestStruct\n * // {\n * //    float minimum;\n * //    float maximum;\n * // };\n * shaderBuilder.addStruct(\"testStructId\", \"TestStruct\", ShaderDestination.FRAGMENT);\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"maximum\");\n * shaderBuilder.addStructField(\"testStructId\", \"float\", \"minimum\");\n */\nShaderBuilder.prototype.addStructField = function (structId, type, identifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"structId\", structId);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n  this._structs[structId].addField(type, identifier);\n};\n\n/**\n * Add a new dynamically-generated function to the shader.\n * @param {string} functionName The name of the function. This will be used to identify the function in {@link ShaderBuilder#addFunctionLines}.\n * @param {string} signature The full signature of the function as it will appear in the shader. Do not include the curly braces.\n * @param {ShaderDestination} destination Whether the struct will appear in the vertex shader, the fragment shader, or both.\n * @example\n * // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);\n */\nShaderBuilder.prototype.addFunction = function (\n  functionName,\n  signature,\n  destination,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"functionName\", functionName);\n  Check.typeOf.string(\"signature\", signature);\n  Check.typeOf.number(\"destination\", destination);\n  //>>includeEnd('debug');\n  this._functions[functionName] = new ShaderFunction(signature);\n\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.functionIds.push(functionName);\n  }\n\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.functionIds.push(functionName);\n  }\n};\n\n/**\n * Add lines to a dynamically-generated function\n * @param {string} functionName The name of the function. This must be created beforehand using {@link ShaderBuilder#addFunction}\n * @param {string|string[]} lines One or more lines of GLSL code to add to the function body. Do not include any preceding or ending whitespace, but do include the semicolon for each line.\n *\n * @example\n * // generates the following function in the vertex shader\n * // vec3 testFunction(float parameter)\n * // {\n * //   float signed = 2.0 * parameter - 1.0;\n * //   return vec3(signed, 0.0, 0.0);\n * // }\n * shaderBuilder.addStruct(\"testFunction\", \"vec3 testFunction(float parameter)\", ShaderDestination.VERTEX);\n * shaderBuilder.addFunctionLines(\"testFunction\", [\n *   \"float signed = 2.0 * parameter - 1.0;\",\n *   \"return vec3(parameter);\"\n * ]);\n */\nShaderBuilder.prototype.addFunctionLines = function (functionName, lines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"functionName\", functionName);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(\n      `Expected lines to be a string or an array of strings, actual value was ${lines}`,\n    );\n  }\n  //>>includeEnd('debug');\n  this._functions[functionName].addLines(lines);\n};\n\n/**\n * Add a uniform declaration to one or both of the shaders. These lines\n * will appear grouped near the top of the final shader source.\n *\n * @param {string} type The GLSL type of the uniform.\n * @param {string} identifier An identifier for the uniform. Identifiers must begin with <code>u_</code> to be consistent with Cesium's style guide.\n * @param {ShaderDestination} [destination=ShaderDestination.BOTH] Whether the uniform appears in the vertex shader, the fragment shader, or both.\n *\n * @example\n * // creates the line \"uniform vec3 u_resolution;\"\n * shaderBuilder.addUniform(\"vec3\", \"u_resolution\", ShaderDestination.FRAGMENT);\n * // creates the line \"uniform float u_time;\" in both shaders\n * shaderBuilder.addUniform(\"float\", \"u_time\", ShaderDestination.BOTH);\n */\nShaderBuilder.prototype.addUniform = function (type, identifier, destination) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  destination = defaultValue(destination, ShaderDestination.BOTH);\n  const line = `uniform ${type} ${identifier};`;\n\n  if (ShaderDestination.includesVertexShader(destination)) {\n    this._vertexShaderParts.uniformLines.push(line);\n  }\n\n  if (ShaderDestination.includesFragmentShader(destination)) {\n    this._fragmentShaderParts.uniformLines.push(line);\n  }\n};\n\n/**\n * Add a position attribute declaration to the vertex shader. These lines\n * will appear grouped near the top of the final shader source.\n * <p>\n * Some WebGL implementations require attribute 0 to be enabled, so this is\n * reserved for the position attribute. For all other attributes, see\n * {@link ShaderBuilder#addAttribute}\n * </p>\n *\n * @param {string} type The GLSL type of the attribute\n * @param {string} identifier An identifier for the attribute. Identifiers must begin with <code>a_</code> to be consistent with Cesium's style guide.\n * @return {number} The integer location of the attribute. This location can be used when creating attributes for a {@link VertexArray}. This will always be 0.\n *\n * @example\n * // creates the line \"in vec3 a_position;\"\n * shaderBuilder.setPositionAttribute(\"vec3\", \"a_position\");\n */\nShaderBuilder.prototype.setPositionAttribute = function (type, identifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n\n  if (defined(this._positionAttributeLine)) {\n    throw new DeveloperError(\n      \"setPositionAttribute() must be called exactly once for the attribute used for gl_Position. For other attributes, use addAttribute()\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._positionAttributeLine = `in ${type} ${identifier};`;\n\n  // Some WebGL implementations require attribute 0 to always be active, so\n  // this builder assumes the position will always go in location 0\n  this._attributeLocations[identifier] = 0;\n  return 0;\n};\n\n/**\n * Add an attribute declaration to the vertex shader. These lines\n * will appear grouped near the top of the final shader source.\n * <p>\n * Some WebGL implementations require attribute 0 to be enabled, so this is\n * reserved for the position attribute. See {@link ShaderBuilder#setPositionAttribute}\n * </p>\n *\n * @param {string} type The GLSL type of the attribute\n * @param {string} identifier An identifier for the attribute. Identifiers must begin with <code>a_</code> to be consistent with Cesium's style guide.\n * @return {number} The integer location of the attribute. This location can be used when creating attributes for a {@link VertexArray}\n *\n * @example\n * // creates the line \"in vec2 a_texCoord0;\" in the vertex shader\n * shaderBuilder.addAttribute(\"vec2\", \"a_texCoord0\");\n */\nShaderBuilder.prototype.addAttribute = function (type, identifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  const line = `in ${type} ${identifier};`;\n  this._attributeLines.push(line);\n\n  const location = this._nextAttributeLocation;\n  this._attributeLocations[identifier] = location;\n\n  // Most attributes only require a single attribute location, but matrices\n  // require more.\n  this._nextAttributeLocation += getAttributeLocationCount(type);\n  return location;\n};\n\n/**\n * Add a varying declaration to both the vertex and fragment shaders.\n *\n * @param {string} type The GLSL type of the varying\n * @param {string} identifier An identifier for the varying. Identifiers must begin with <code>v_</code> to be consistent with Cesium's style guide.\n * @param {string} [qualifier] A qualifier for the varying, such as <code>flat</code>.\n *\n * @example\n * // creates the line \"in vec3 v_color;\" in the vertex shader\n * // creates the line \"out vec3 v_color;\" in the fragment shader\n * shaderBuilder.addVarying(\"vec3\", \"v_color\");\n */\nShaderBuilder.prototype.addVarying = function (type, identifier, qualifier) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  Check.typeOf.string(\"identifier\", identifier);\n  //>>includeEnd('debug');\n\n  qualifier = defined(qualifier) ? `${qualifier} ` : \"\";\n\n  const line = `${type} ${identifier};`;\n  this._vertexShaderParts.varyingLines.push(`${qualifier}out ${line}`);\n  this._fragmentShaderParts.varyingLines.push(`${qualifier}in ${line}`);\n};\n\n/**\n * Appends lines of GLSL code to the vertex shader\n *\n * @param {string|string[]} lines One or more lines to add to the end of the vertex shader source\n *\n * @example\n * shaderBuilder.addVertexLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    v_color = a_color;\",\n *  \"    gl_Position = vec4(a_position, 1.0);\",\n *  \"}\"\n * ]);\n */\nShaderBuilder.prototype.addVertexLines = function (lines) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(\n      `Expected lines to be a string or an array of strings, actual value was ${lines}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertexLines = this._vertexShaderParts.shaderLines;\n  if (Array.isArray(lines)) {\n    vertexLines.push.apply(vertexLines, lines);\n  } else {\n    // Single string case\n    vertexLines.push(lines);\n  }\n};\n\n/**\n * Appends lines of GLSL code to the fragment shader\n *\n * @param {string[]} lines The lines to add to the end of the fragment shader source\n *\n * @example\n * shaderBuilder.addFragmentLines([\n *  \"void main()\",\n *  \"{\",\n *  \"    #ifdef SOLID_COLOR\",\n *  \"    out_FragColor = vec4(u_color, 1.0);\",\n *  \"    #else\",\n *  \"    out_FragColor = vec4(v_color, 1.0);\",\n *  \"    #endif\",\n *  \"}\"\n * ]);\n */\nShaderBuilder.prototype.addFragmentLines = function (lines) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof lines !== \"string\" && !Array.isArray(lines)) {\n    throw new DeveloperError(\n      `Expected lines to be a string or an array of strings, actual value was ${lines}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  const fragmentLines = this._fragmentShaderParts.shaderLines;\n  if (Array.isArray(lines)) {\n    fragmentLines.push.apply(fragmentLines, lines);\n  } else {\n    // Single string case\n    fragmentLines.push(lines);\n  }\n};\n\n/**\n * Builds the {@link ShaderProgram} from the pieces added by the other methods.\n * Call this one time at the end of modifying the shader through the other\n * methods in this class.\n *\n * @param {Context} context The context to use for creating the shader.\n * @return {ShaderProgram} A shader program to use for rendering.\n *\n * @example\n * const shaderProgram = shaderBuilder.buildShaderProgram(context);\n */\nShaderBuilder.prototype.buildShaderProgram = function (context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n\n  const positionAttribute = defined(this._positionAttributeLine)\n    ? [this._positionAttributeLine]\n    : [];\n\n  const structLines = generateStructLines(this);\n  const functionLines = generateFunctionLines(this);\n\n  // Lines are joined here so the ShaderSource\n  // generates a single #line 0 directive\n  const vertexLines = positionAttribute\n    .concat(\n      this._attributeLines,\n      this._vertexShaderParts.uniformLines,\n      this._vertexShaderParts.varyingLines,\n      structLines.vertexLines,\n      functionLines.vertexLines,\n      this._vertexShaderParts.shaderLines,\n    )\n    .join(\"\\n\");\n  const vertexShaderSource = new ShaderSource({\n    defines: this._vertexShaderParts.defineLines,\n    sources: [vertexLines],\n  });\n\n  const fragmentLines = this._fragmentShaderParts.uniformLines\n    .concat(\n      this._fragmentShaderParts.varyingLines,\n      structLines.fragmentLines,\n      functionLines.fragmentLines,\n      this._fragmentShaderParts.shaderLines,\n    )\n    .join(\"\\n\");\n  const fragmentShaderSource = new ShaderSource({\n    defines: this._fragmentShaderParts.defineLines,\n    sources: [fragmentLines],\n  });\n\n  return ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vertexShaderSource,\n    fragmentShaderSource: fragmentShaderSource,\n    attributeLocations: this._attributeLocations,\n  });\n};\n\nShaderBuilder.prototype.clone = function () {\n  return clone(this, true);\n};\n\nfunction generateStructLines(shaderBuilder) {\n  const vertexLines = [];\n  const fragmentLines = [];\n\n  let i;\n  let structIds = shaderBuilder._vertexShaderParts.structIds;\n  let structId;\n  let struct;\n  let structLines;\n  for (i = 0; i < structIds.length; i++) {\n    structId = structIds[i];\n    struct = shaderBuilder._structs[structId];\n    structLines = struct.generateGlslLines();\n    vertexLines.push.apply(vertexLines, structLines);\n  }\n\n  structIds = shaderBuilder._fragmentShaderParts.structIds;\n  for (i = 0; i < structIds.length; i++) {\n    structId = structIds[i];\n    struct = shaderBuilder._structs[structId];\n    structLines = struct.generateGlslLines();\n    fragmentLines.push.apply(fragmentLines, structLines);\n  }\n\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines,\n  };\n}\n\nfunction getAttributeLocationCount(glslType) {\n  switch (glslType) {\n    case \"mat2\":\n      return 2;\n    case \"mat3\":\n      return 3;\n    case \"mat4\":\n      return 4;\n    default:\n      return 1;\n  }\n}\n\nfunction generateFunctionLines(shaderBuilder) {\n  const vertexLines = [];\n  const fragmentLines = [];\n\n  let i;\n  let functionIds = shaderBuilder._vertexShaderParts.functionIds;\n  let functionId;\n  let func;\n  let functionLines;\n  for (i = 0; i < functionIds.length; i++) {\n    functionId = functionIds[i];\n    func = shaderBuilder._functions[functionId];\n    functionLines = func.generateGlslLines();\n    vertexLines.push.apply(vertexLines, functionLines);\n  }\n\n  functionIds = shaderBuilder._fragmentShaderParts.functionIds;\n  for (i = 0; i < functionIds.length; i++) {\n    functionId = functionIds[i];\n    func = shaderBuilder._functions[functionId];\n    functionLines = func.generateGlslLines();\n    fragmentLines.push.apply(fragmentLines, functionLines);\n  }\n\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines,\n  };\n}\n\nexport default ShaderBuilder;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,cAAc,MAAM,qBAAqB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAAA,EAAG;EACvB;EACA;EACA,IAAI,CAACC,sBAAsB,GAAGC,SAAS;EACvC,IAAI,CAACC,sBAAsB,GAAG,CAAC;EAC/B,IAAI,CAACC,mBAAmB,GAAG,CAAC,CAAC;EAC7B,IAAI,CAACC,eAAe,GAAG,EAAE;;EAEzB;EACA;EACA,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC;EAClB,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;EAEpB,IAAI,CAACC,kBAAkB,GAAG;IACxBC,WAAW,EAAE,EAAE;IACfC,YAAY,EAAE,EAAE;IAChBC,WAAW,EAAE,EAAE;IACfC,YAAY,EAAE,EAAE;IAChB;IACAC,SAAS,EAAE,EAAE;IACbC,WAAW,EAAE;EACf,CAAC;EACD,IAAI,CAACC,oBAAoB,GAAG;IAC1BN,WAAW,EAAE,EAAE;IACfC,YAAY,EAAE,EAAE;IAChBC,WAAW,EAAE,EAAE;IACfC,YAAY,EAAE,EAAE;IAChB;IACAC,SAAS,EAAE,EAAE;IACbC,WAAW,EAAE;EACf,CAAC;AACH;AAEAE,MAAM,CAACC,gBAAgB,CAACjB,aAAa,CAACkB,SAAS,EAAE;EAC/C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,kBAAkB,EAAE;IAClBC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAChB,mBAAmB;IACjC;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,aAAa,CAACkB,SAAS,CAACG,SAAS,GAAG,UAAUC,UAAU,EAAEC,KAAK,EAAEC,WAAW,EAAE;EAC5E;EACAlC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEJ,UAAU,CAAC;EAC7C;;EAEAE,WAAW,GAAG/B,YAAY,CAAC+B,WAAW,EAAE7B,iBAAiB,CAACgC,IAAI,CAAC;;EAE/D;EACA,IAAIC,IAAI,GAAGN,UAAU;EACrB,IAAI9B,OAAO,CAAC+B,KAAK,CAAC,EAAE;IAClBK,IAAI,IAAI,IAAIL,KAAK,CAACM,QAAQ,CAAC,CAAC,EAAE;EAChC;EAEA,IAAIlC,iBAAiB,CAACmC,oBAAoB,CAACN,WAAW,CAAC,EAAE;IACvD,IAAI,CAAChB,kBAAkB,CAACC,WAAW,CAACsB,IAAI,CAACH,IAAI,CAAC;EAChD;EAEA,IAAIjC,iBAAiB,CAACqC,sBAAsB,CAACR,WAAW,CAAC,EAAE;IACzD,IAAI,CAACT,oBAAoB,CAACN,WAAW,CAACsB,IAAI,CAACH,IAAI,CAAC;EAClD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,aAAa,CAACkB,SAAS,CAACe,SAAS,GAAG,UAClCC,QAAQ,EACRC,UAAU,EACVX,WAAW,EACX;EACA;EACAlC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,UAAU,EAAEQ,QAAQ,CAAC;EACzC5C,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAES,UAAU,CAAC;EAC7C7C,KAAK,CAACmC,MAAM,CAACW,MAAM,CAAC,aAAa,EAAEZ,WAAW,CAAC;EAC/C;EACA,IAAI,CAAClB,QAAQ,CAAC4B,QAAQ,CAAC,GAAG,IAAIpC,YAAY,CAACqC,UAAU,CAAC;EACtD,IAAIxC,iBAAiB,CAACmC,oBAAoB,CAACN,WAAW,CAAC,EAAE;IACvD,IAAI,CAAChB,kBAAkB,CAACK,SAAS,CAACkB,IAAI,CAACG,QAAQ,CAAC;EAClD;EAEA,IAAIvC,iBAAiB,CAACqC,sBAAsB,CAACR,WAAW,CAAC,EAAE;IACzD,IAAI,CAACT,oBAAoB,CAACF,SAAS,CAACkB,IAAI,CAACG,QAAQ,CAAC;EACpD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlC,aAAa,CAACkB,SAAS,CAACmB,cAAc,GAAG,UAAUH,QAAQ,EAAEI,IAAI,EAAEhB,UAAU,EAAE;EAC7E;EACAhC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,UAAU,EAAEQ,QAAQ,CAAC;EACzC5C,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEY,IAAI,CAAC;EACjChD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEJ,UAAU,CAAC;EAC7C;EACA,IAAI,CAAChB,QAAQ,CAAC4B,QAAQ,CAAC,CAACK,QAAQ,CAACD,IAAI,EAAEhB,UAAU,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtB,aAAa,CAACkB,SAAS,CAACsB,WAAW,GAAG,UACpCC,YAAY,EACZC,SAAS,EACTlB,WAAW,EACX;EACA;EACAlC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,cAAc,EAAEe,YAAY,CAAC;EACjDnD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,WAAW,EAAEgB,SAAS,CAAC;EAC3CpD,KAAK,CAACmC,MAAM,CAACW,MAAM,CAAC,aAAa,EAAEZ,WAAW,CAAC;EAC/C;EACA,IAAI,CAACjB,UAAU,CAACkC,YAAY,CAAC,GAAG,IAAI1C,cAAc,CAAC2C,SAAS,CAAC;EAE7D,IAAI/C,iBAAiB,CAACmC,oBAAoB,CAACN,WAAW,CAAC,EAAE;IACvD,IAAI,CAAChB,kBAAkB,CAACM,WAAW,CAACiB,IAAI,CAACU,YAAY,CAAC;EACxD;EAEA,IAAI9C,iBAAiB,CAACqC,sBAAsB,CAACR,WAAW,CAAC,EAAE;IACzD,IAAI,CAACT,oBAAoB,CAACD,WAAW,CAACiB,IAAI,CAACU,YAAY,CAAC;EAC1D;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,aAAa,CAACkB,SAAS,CAACyB,gBAAgB,GAAG,UAAUF,YAAY,EAAEG,KAAK,EAAE;EACxE;EACAtD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,cAAc,EAAEe,YAAY,CAAC;EACjD,IAAI,OAAOG,KAAK,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtD,MAAM,IAAIlD,cAAc,CACtB,0EAA0EkD,KAAK,EACjF,CAAC;EACH;EACA;EACA,IAAI,CAACrC,UAAU,CAACkC,YAAY,CAAC,CAACM,QAAQ,CAACH,KAAK,CAAC;AAC/C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5C,aAAa,CAACkB,SAAS,CAAC8B,UAAU,GAAG,UAAUV,IAAI,EAAEhB,UAAU,EAAEE,WAAW,EAAE;EAC5E;EACAlC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEY,IAAI,CAAC;EACjChD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEJ,UAAU,CAAC;EAC7C;;EAEAE,WAAW,GAAG/B,YAAY,CAAC+B,WAAW,EAAE7B,iBAAiB,CAACgC,IAAI,CAAC;EAC/D,MAAMC,IAAI,GAAG,WAAWU,IAAI,IAAIhB,UAAU,GAAG;EAE7C,IAAI3B,iBAAiB,CAACmC,oBAAoB,CAACN,WAAW,CAAC,EAAE;IACvD,IAAI,CAAChB,kBAAkB,CAACE,YAAY,CAACqB,IAAI,CAACH,IAAI,CAAC;EACjD;EAEA,IAAIjC,iBAAiB,CAACqC,sBAAsB,CAACR,WAAW,CAAC,EAAE;IACzD,IAAI,CAACT,oBAAoB,CAACL,YAAY,CAACqB,IAAI,CAACH,IAAI,CAAC;EACnD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,aAAa,CAACkB,SAAS,CAAC+B,oBAAoB,GAAG,UAAUX,IAAI,EAAEhB,UAAU,EAAE;EACzE;EACAhC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEY,IAAI,CAAC;EACjChD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEJ,UAAU,CAAC;EAE7C,IAAI9B,OAAO,CAAC,IAAI,CAACS,sBAAsB,CAAC,EAAE;IACxC,MAAM,IAAIP,cAAc,CACtB,qIACF,CAAC;EACH;EACA;;EAEA,IAAI,CAACO,sBAAsB,GAAG,MAAMqC,IAAI,IAAIhB,UAAU,GAAG;;EAEzD;EACA;EACA,IAAI,CAAClB,mBAAmB,CAACkB,UAAU,CAAC,GAAG,CAAC;EACxC,OAAO,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtB,aAAa,CAACkB,SAAS,CAACgC,YAAY,GAAG,UAAUZ,IAAI,EAAEhB,UAAU,EAAE;EACjE;EACAhC,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEY,IAAI,CAAC;EACjChD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEJ,UAAU,CAAC;EAC7C;;EAEA,MAAMM,IAAI,GAAG,MAAMU,IAAI,IAAIhB,UAAU,GAAG;EACxC,IAAI,CAACjB,eAAe,CAAC0B,IAAI,CAACH,IAAI,CAAC;EAE/B,MAAMuB,QAAQ,GAAG,IAAI,CAAChD,sBAAsB;EAC5C,IAAI,CAACC,mBAAmB,CAACkB,UAAU,CAAC,GAAG6B,QAAQ;;EAE/C;EACA;EACA,IAAI,CAAChD,sBAAsB,IAAIiD,yBAAyB,CAACd,IAAI,CAAC;EAC9D,OAAOa,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnD,aAAa,CAACkB,SAAS,CAACmC,UAAU,GAAG,UAAUf,IAAI,EAAEhB,UAAU,EAAEgC,SAAS,EAAE;EAC1E;EACAhE,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEY,IAAI,CAAC;EACjChD,KAAK,CAACmC,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEJ,UAAU,CAAC;EAC7C;;EAEAgC,SAAS,GAAG9D,OAAO,CAAC8D,SAAS,CAAC,GAAG,GAAGA,SAAS,GAAG,GAAG,EAAE;EAErD,MAAM1B,IAAI,GAAG,GAAGU,IAAI,IAAIhB,UAAU,GAAG;EACrC,IAAI,CAACd,kBAAkB,CAACI,YAAY,CAACmB,IAAI,CAAC,GAAGuB,SAAS,OAAO1B,IAAI,EAAE,CAAC;EACpE,IAAI,CAACb,oBAAoB,CAACH,YAAY,CAACmB,IAAI,CAAC,GAAGuB,SAAS,MAAM1B,IAAI,EAAE,CAAC;AACvE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,aAAa,CAACkB,SAAS,CAACqC,cAAc,GAAG,UAAUX,KAAK,EAAE;EACxD;EACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtD,MAAM,IAAIlD,cAAc,CACtB,0EAA0EkD,KAAK,EACjF,CAAC;EACH;EACA;;EAEA,MAAMY,WAAW,GAAG,IAAI,CAAChD,kBAAkB,CAACG,WAAW;EACvD,IAAIkC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxBY,WAAW,CAACzB,IAAI,CAAC0B,KAAK,CAACD,WAAW,EAAEZ,KAAK,CAAC;EAC5C,CAAC,MAAM;IACL;IACAY,WAAW,CAACzB,IAAI,CAACa,KAAK,CAAC;EACzB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5C,aAAa,CAACkB,SAAS,CAACwC,gBAAgB,GAAG,UAAUd,KAAK,EAAE;EAC1D;EACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtD,MAAM,IAAIlD,cAAc,CACtB,0EAA0EkD,KAAK,EACjF,CAAC;EACH;EACA;;EAEA,MAAMe,aAAa,GAAG,IAAI,CAAC5C,oBAAoB,CAACJ,WAAW;EAC3D,IAAIkC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxBe,aAAa,CAAC5B,IAAI,CAAC0B,KAAK,CAACE,aAAa,EAAEf,KAAK,CAAC;EAChD,CAAC,MAAM;IACL;IACAe,aAAa,CAAC5B,IAAI,CAACa,KAAK,CAAC;EAC3B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5C,aAAa,CAACkB,SAAS,CAAC0C,kBAAkB,GAAG,UAAUC,OAAO,EAAE;EAC9D;EACAvE,KAAK,CAACmC,MAAM,CAACqC,MAAM,CAAC,SAAS,EAAED,OAAO,CAAC;EACvC;;EAEA,MAAME,iBAAiB,GAAGvE,OAAO,CAAC,IAAI,CAACS,sBAAsB,CAAC,GAC1D,CAAC,IAAI,CAACA,sBAAsB,CAAC,GAC7B,EAAE;EAEN,MAAM+D,WAAW,GAAGC,mBAAmB,CAAC,IAAI,CAAC;EAC7C,MAAMC,aAAa,GAAGC,qBAAqB,CAAC,IAAI,CAAC;;EAEjD;EACA;EACA,MAAMX,WAAW,GAAGO,iBAAiB,CAClCK,MAAM,CACL,IAAI,CAAC/D,eAAe,EACpB,IAAI,CAACG,kBAAkB,CAACE,YAAY,EACpC,IAAI,CAACF,kBAAkB,CAACI,YAAY,EACpCoD,WAAW,CAACR,WAAW,EACvBU,aAAa,CAACV,WAAW,EACzB,IAAI,CAAChD,kBAAkB,CAACG,WAC1B,CAAC,CACA0D,IAAI,CAAC,IAAI,CAAC;EACb,MAAMC,kBAAkB,GAAG,IAAIzE,YAAY,CAAC;IAC1C0E,OAAO,EAAE,IAAI,CAAC/D,kBAAkB,CAACC,WAAW;IAC5C+D,OAAO,EAAE,CAAChB,WAAW;EACvB,CAAC,CAAC;EAEF,MAAMG,aAAa,GAAG,IAAI,CAAC5C,oBAAoB,CAACL,YAAY,CACzD0D,MAAM,CACL,IAAI,CAACrD,oBAAoB,CAACH,YAAY,EACtCoD,WAAW,CAACL,aAAa,EACzBO,aAAa,CAACP,aAAa,EAC3B,IAAI,CAAC5C,oBAAoB,CAACJ,WAC5B,CAAC,CACA0D,IAAI,CAAC,IAAI,CAAC;EACb,MAAMI,oBAAoB,GAAG,IAAI5E,YAAY,CAAC;IAC5C0E,OAAO,EAAE,IAAI,CAACxD,oBAAoB,CAACN,WAAW;IAC9C+D,OAAO,EAAE,CAACb,aAAa;EACzB,CAAC,CAAC;EAEF,OAAO/D,aAAa,CAAC8E,SAAS,CAAC;IAC7Bb,OAAO,EAAEA,OAAO;IAChBS,kBAAkB,EAAEA,kBAAkB;IACtCG,oBAAoB,EAAEA,oBAAoB;IAC1CtD,kBAAkB,EAAE,IAAI,CAACf;EAC3B,CAAC,CAAC;AACJ,CAAC;AAEDJ,aAAa,CAACkB,SAAS,CAAC3B,KAAK,GAAG,YAAY;EAC1C,OAAOA,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;AAC1B,CAAC;AAED,SAAS0E,mBAAmBA,CAACU,aAAa,EAAE;EAC1C,MAAMnB,WAAW,GAAG,EAAE;EACtB,MAAMG,aAAa,GAAG,EAAE;EAExB,IAAIiB,CAAC;EACL,IAAI/D,SAAS,GAAG8D,aAAa,CAACnE,kBAAkB,CAACK,SAAS;EAC1D,IAAIqB,QAAQ;EACZ,IAAI2C,MAAM;EACV,IAAIb,WAAW;EACf,KAAKY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,SAAS,CAACiE,MAAM,EAAEF,CAAC,EAAE,EAAE;IACrC1C,QAAQ,GAAGrB,SAAS,CAAC+D,CAAC,CAAC;IACvBC,MAAM,GAAGF,aAAa,CAACrE,QAAQ,CAAC4B,QAAQ,CAAC;IACzC8B,WAAW,GAAGa,MAAM,CAACE,iBAAiB,CAAC,CAAC;IACxCvB,WAAW,CAACzB,IAAI,CAAC0B,KAAK,CAACD,WAAW,EAAEQ,WAAW,CAAC;EAClD;EAEAnD,SAAS,GAAG8D,aAAa,CAAC5D,oBAAoB,CAACF,SAAS;EACxD,KAAK+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,SAAS,CAACiE,MAAM,EAAEF,CAAC,EAAE,EAAE;IACrC1C,QAAQ,GAAGrB,SAAS,CAAC+D,CAAC,CAAC;IACvBC,MAAM,GAAGF,aAAa,CAACrE,QAAQ,CAAC4B,QAAQ,CAAC;IACzC8B,WAAW,GAAGa,MAAM,CAACE,iBAAiB,CAAC,CAAC;IACxCpB,aAAa,CAAC5B,IAAI,CAAC0B,KAAK,CAACE,aAAa,EAAEK,WAAW,CAAC;EACtD;EAEA,OAAO;IACLR,WAAW,EAAEA,WAAW;IACxBG,aAAa,EAAEA;EACjB,CAAC;AACH;AAEA,SAASP,yBAAyBA,CAAC4B,QAAQ,EAAE;EAC3C,QAAQA,QAAQ;IACd,KAAK,MAAM;MACT,OAAO,CAAC;IACV,KAAK,MAAM;MACT,OAAO,CAAC;IACV,KAAK,MAAM;MACT,OAAO,CAAC;IACV;MACE,OAAO,CAAC;EACZ;AACF;AAEA,SAASb,qBAAqBA,CAACQ,aAAa,EAAE;EAC5C,MAAMnB,WAAW,GAAG,EAAE;EACtB,MAAMG,aAAa,GAAG,EAAE;EAExB,IAAIiB,CAAC;EACL,IAAI9D,WAAW,GAAG6D,aAAa,CAACnE,kBAAkB,CAACM,WAAW;EAC9D,IAAImE,UAAU;EACd,IAAIC,IAAI;EACR,IAAIhB,aAAa;EACjB,KAAKU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9D,WAAW,CAACgE,MAAM,EAAEF,CAAC,EAAE,EAAE;IACvCK,UAAU,GAAGnE,WAAW,CAAC8D,CAAC,CAAC;IAC3BM,IAAI,GAAGP,aAAa,CAACpE,UAAU,CAAC0E,UAAU,CAAC;IAC3Cf,aAAa,GAAGgB,IAAI,CAACH,iBAAiB,CAAC,CAAC;IACxCvB,WAAW,CAACzB,IAAI,CAAC0B,KAAK,CAACD,WAAW,EAAEU,aAAa,CAAC;EACpD;EAEApD,WAAW,GAAG6D,aAAa,CAAC5D,oBAAoB,CAACD,WAAW;EAC5D,KAAK8D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9D,WAAW,CAACgE,MAAM,EAAEF,CAAC,EAAE,EAAE;IACvCK,UAAU,GAAGnE,WAAW,CAAC8D,CAAC,CAAC;IAC3BM,IAAI,GAAGP,aAAa,CAACpE,UAAU,CAAC0E,UAAU,CAAC;IAC3Cf,aAAa,GAAGgB,IAAI,CAACH,iBAAiB,CAAC,CAAC;IACxCpB,aAAa,CAAC5B,IAAI,CAAC0B,KAAK,CAACE,aAAa,EAAEO,aAAa,CAAC;EACxD;EAEA,OAAO;IACLV,WAAW,EAAEA,WAAW;IACxBG,aAAa,EAAEA;EACjB,CAAC;AACH;AAEA,eAAe3D,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}