{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport MetadataClassProperty from \"./MetadataClassProperty.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataType from \"./MetadataType.js\";\n\n/**\n * Utility functions for metadata picking.\n *\n * These are used by the `Picking.pickMetadata` function to decode\n * the metadata values that have been read from the frame buffer\n * into the actual metadata values, according to the structure\n * defined by the `MetadataClassProperty`.\n *\n * @private\n */\nconst MetadataPicking = {};\n\n/**\n * Returns the value at the specified index of the given data view,\n * interpreting the data to have the given component type.\n *\n * @param {MetadataComponentType} componentType The `MetadataComponentType`\n * @param {DataView} dataView The data view\n * @param {number} index The index (byte offset)\n * @returns {number|bigint|undefined} The value\n * @throws RuntimeError If the given component type is not a valid\n * `MetadataComponentType`\n * @throws RangeError If reading the data from the given data view would\n * cause an out-of-bounds access\n *\n * @private\n */\nMetadataPicking.decodeRawMetadataValue = function (componentType, dataView, index) {\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n      return dataView.getInt8(index);\n    case MetadataComponentType.UINT8:\n      return dataView.getUint8(index);\n    case MetadataComponentType.INT16:\n      return dataView.getInt16(index, true);\n    case MetadataComponentType.UINT16:\n      return dataView.getUint16(index, true);\n    case MetadataComponentType.INT32:\n      return dataView.getInt32(index, true);\n    case MetadataComponentType.UINT32:\n      return dataView.getUint32(index, true);\n    case MetadataComponentType.INT64:\n      return dataView.getBigInt64(index, true);\n    case MetadataComponentType.UINT64:\n      return dataView.getBigUint64(index, true);\n    case MetadataComponentType.FLOAT32:\n      return dataView.getFloat32(index, true);\n    case MetadataComponentType.FLOAT64:\n      return dataView.getFloat64(index, true);\n  }\n  throw new RuntimeError(`Invalid component type: ${componentType}`);\n};\n\n/**\n * Decodes one component of a metadata value with the given property type\n * from the given data view.\n *\n * This will decode one component (e.g. one entry of a SCALAR array,\n * or one component of a VEC2 element).\n *\n * This will apply normalization to the raw component value if the given\n * class property is 'normalized'.\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @param {DataView} dataView The data view containing the raw metadata values\n * @param {number} dataViewOffset The byte offset within the data view from\n * which the component should be read\n * @returns {number|bigint|undefined} The metadata value component\n * @throws RuntimeError If the component of the given property is not\n * a valid `MetadataComponentType`\n * @throws RangeError If reading the data from the given data view would\n * cause an out-of-bounds access\n */\nMetadataPicking.decodeRawMetadataValueComponent = function (classProperty, dataView, dataViewOffset) {\n  const componentType = classProperty.componentType;\n  const component = MetadataPicking.decodeRawMetadataValue(componentType, dataView, dataViewOffset);\n  if (classProperty.normalized) {\n    return MetadataComponentType.normalize(component, componentType);\n  }\n  return component;\n};\n\n/**\n * Decodes one element of a metadata value with the given property type\n * from the given data view.\n *\n * When the given class property is vector- or matrix typed, then the\n * result will be an array, with a length that corresponds to the\n * number of vector- or matrix components.\n *\n * Otherwise, it will be a single value.\n *\n * In any case, the return value will be the \"raw\" value, which does\n * take into account normalization, but does NOT take into account\n * default/noData value handling.\n *\n * @param {MetadataClassProperty} classProperty The metadata class property\n * @param {DataView} dataView The data view containing the raw metadata values\n * @param {number} elementIndex The index of the element. This is the index\n * inside the array for array-typed properties, and 0 for non-array types.\n * @returns {number|number[]|bigint|bigint[]|undefined} The decoded metadata value element\n * @throws RuntimeError If the component of the given property is not\n * a valid `MetadataComponentType`\n * @throws RangeError If reading the data from the given data view would\n * cause an out-of-bounds access\n *\n */\nMetadataPicking.decodeRawMetadataValueElement = function (classProperty, dataView, elementIndex) {\n  const componentType = classProperty.componentType;\n  const componentSizeInBytes = MetadataComponentType.getSizeInBytes(componentType);\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n  const elementSizeInBytes = componentSizeInBytes * componentCount;\n  if (componentCount > 1) {\n    const result = Array(componentCount);\n    for (let i = 0; i < componentCount; i++) {\n      const offset = elementIndex * elementSizeInBytes + i * componentSizeInBytes;\n      const component = MetadataPicking.decodeRawMetadataValueComponent(classProperty, dataView, offset);\n      result[i] = component;\n    }\n    return result;\n  }\n  const offset = elementIndex * elementSizeInBytes;\n  const result = MetadataPicking.decodeRawMetadataValueComponent(classProperty, dataView, offset);\n  return result;\n};\n\n/**\n * Decode the given raw values into the raw (array-based) form of\n * a metadata property value.\n *\n * (For decoding to types like `CartesianN`, the `decodeMetadataValues`\n * function can be used)\n *\n * The given values are a `Uint8Array` containing the RGBA\n * values that have been read from the metadata picking\n * frame buffer. They are assumed to contain the value for\n * the given class property, as encoded by the\n * `MetadataPickingPipelineStage` for metadata picking.\n *\n * When the given class property is an array, then (it has to be\n * a fixed-length array, and) the result will be an array with\n * the respective length.\n *\n * When the given class property is vector- or matrix typed,\n * then the result will be an array, with a length that corresponds\n * to the number of vector- or matrix components.\n *\n * (The case that the property is an array of vector- or matrix\n * elements is not supported on the side of the general metadata\n * shader infrastructure, but handled here nevertheless. For such\n * an input, the result would be an array of arrays, with each\n * element representing one of the vectors or matrices).\n *\n * In any case, the return value will be the \"raw\" value, which does\n * take into account normalization, but does NOT take into account\n * any offset/scale, or default/noData value handling.\n *\n * @param {MetadataClassProperty} classProperty The `MetadataClassProperty`\n * @param {Uint8Array} rawPixelValues The raw values\n * @returns {number|bigint|number[]|bigint[]|undefined} The value\n * @throws RuntimeError If the class property has an invalid component type\n *\n * @private\n */\nMetadataPicking.decodeRawMetadataValues = function (classProperty, rawPixelValues) {\n  const dataView = new DataView(rawPixelValues.buffer, rawPixelValues.byteOffset, rawPixelValues.byteLength);\n  if (classProperty.isArray) {\n    const arrayLength = classProperty.arrayLength;\n    const result = Array(arrayLength);\n    for (let i = 0; i < arrayLength; i++) {\n      const element = MetadataPicking.decodeRawMetadataValueElement(classProperty, dataView, i);\n      result[i] = element;\n    }\n    return result;\n  }\n  const result = MetadataPicking.decodeRawMetadataValueElement(classProperty, dataView, 0);\n  return result;\n};\n\n/**\n * Converts the given type into an object representation where appropriate.\n *\n * When the given type is `SCALAR`, `STRING`, `BOOLEAN`, or `ENUM`, or\n * when the given value is `undefined`, then the given value will be\n * returned.\n *\n * Otherwise, for the `VECn/MATn` types, the given value is assumed to be\n * a numeric array, and is converted into the matching `CartesianN/MatrixN`\n * value.\n *\n * @param {string} type The `ClassProperty` type\n * @param {number|bigint|number[]|bigint[]|undefined} value The input value\n * @returns {undefined|number|bigint|string|boolean|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4} The object representation\n * @throws RuntimeError If the type is not a valid `MetadataType`\n */\nMetadataPicking.convertToObjectType = function (type, value) {\n  if (!defined(value)) {\n    return value;\n  }\n  if (type === MetadataType.SCALAR || type === MetadataType.STRING || type === MetadataType.BOOLEAN || type === MetadataType.ENUM) {\n    return value;\n  }\n  const numbers = value.map(n => Number(n));\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2.unpack(numbers, 0, new Cartesian2());\n    case MetadataType.VEC3:\n      return Cartesian3.unpack(numbers, 0, new Cartesian3());\n    case MetadataType.VEC4:\n      return Cartesian4.unpack(numbers, 0, new Cartesian4());\n    case MetadataType.MAT2:\n      return Matrix2.unpack(numbers, 0, new Matrix2());\n    case MetadataType.MAT3:\n      return Matrix3.unpack(numbers, 0, new Matrix3());\n    case MetadataType.MAT4:\n      return Matrix4.unpack(numbers, 0, new Matrix4());\n  }\n  // Should never happen:\n  throw new RuntimeError(`Invalid metadata object type: ${type}`);\n};\n\n/**\n * Converts the given type into a raw value or array representation.\n *\n * For `VECn/MATn` types, the given value is converted into an array.\n * For other types, the value is returned directly\n *\n * @param {string} type The `ClassProperty` type\n * @param {undefined|number|bigint|string|boolean|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4} value The input value\n * @returns {undefined|number|bigint|string|boolean|number[]} The array representation\n * @throws RuntimeError If the type is not a valid `MetadataType`\n */\nMetadataPicking.convertFromObjectType = function (type, value) {\n  if (!defined(value)) {\n    return value;\n  }\n  if (type === MetadataType.SCALAR || type === MetadataType.STRING || type === MetadataType.BOOLEAN || type === MetadataType.ENUM) {\n    return value;\n  }\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2.pack(value, Array(2));\n    case MetadataType.VEC3:\n      return Cartesian3.pack(value, Array(3));\n    case MetadataType.VEC4:\n      return Cartesian4.pack(value, Array(4));\n    case MetadataType.MAT2:\n      return Matrix2.pack(value, Array(4));\n    case MetadataType.MAT3:\n      return Matrix3.pack(value, Array(9));\n    case MetadataType.MAT4:\n      return Matrix4.pack(value, Array(16));\n  }\n  // Should never happen:\n  throw new RuntimeError(`Invalid metadata object type: ${type}`);\n};\n\n/**\n * Decode the given raw values into a metadata property value.\n *\n * This applies the value transform (offset/scale) to the result\n * of `decodeRawMetadataValues`, and converts this from array-based\n * types into object types like `CartesianN`.\n *\n * @param {MetadataClassProperty} classProperty The `MetadataClassProperty`\n * @param {object} metadataProperty The\n * `PropertyTextureProperty` or `PropertyAttributeProperty`\n * @param {Uint8Array} rawPixelValues The raw values\n * @returns {MetadataValue} The value\n * @throws RuntimeError If the class property has an invalid type\n * or component type\n * @throws RangeError If the given pixel values do not have sufficient\n * size to contain the expected value type\n *\n * @private\n */\nMetadataPicking.decodeMetadataValues = function (classProperty, metadataProperty, rawPixelValues) {\n  let arrayBasedResult = MetadataPicking.decodeRawMetadataValues(classProperty, rawPixelValues);\n  if (metadataProperty.hasValueTransform) {\n    // In the MetadataClassProperty, these offset/scale are always in\n    // their array-based form (e.g. a number[3] for `VEC3`). But for\n    // the PropertyTextureProperty and PropertyAttributeProperty,\n    // the type of the offset/scale is defined to be\n    // number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4\n    // So these types are converted into their array-based form here, before\n    // applying them with `MetadataClassProperty.valueTransformInPlace`\n\n    const offset = MetadataPicking.convertFromObjectType(classProperty.type, metadataProperty.offset);\n    const scale = MetadataPicking.convertFromObjectType(classProperty.type, metadataProperty.scale);\n    arrayBasedResult = MetadataClassProperty.valueTransformInPlace(arrayBasedResult, offset, scale, MetadataComponentType.applyValueTransform);\n  }\n  if (classProperty.isArray) {\n    const arrayLength = classProperty.arrayLength;\n    const result = Array(arrayLength);\n    for (let i = 0; i < arrayLength; i++) {\n      const arrayBasedValue = arrayBasedResult[i];\n      const objectBasedValue = MetadataPicking.convertToObjectType(classProperty.type, arrayBasedValue);\n      result[i] = objectBasedValue;\n    }\n    return result;\n  }\n  const objectResult = MetadataPicking.convertToObjectType(classProperty.type, arrayBasedResult);\n  return objectResult;\n};\nexport default Object.freeze(MetadataPicking);","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","defined","Matrix2","Matrix3","Matrix4","RuntimeError","MetadataClassProperty","MetadataComponentType","MetadataType","MetadataPicking","decodeRawMetadataValue","componentType","dataView","index","INT8","getInt8","UINT8","getUint8","INT16","getInt16","UINT16","getUint16","INT32","getInt32","UINT32","getUint32","INT64","getBigInt64","UINT64","getBigUint64","FLOAT32","getFloat32","FLOAT64","getFloat64","decodeRawMetadataValueComponent","classProperty","dataViewOffset","component","normalized","normalize","decodeRawMetadataValueElement","elementIndex","componentSizeInBytes","getSizeInBytes","type","componentCount","getComponentCount","elementSizeInBytes","result","Array","i","offset","decodeRawMetadataValues","rawPixelValues","DataView","buffer","byteOffset","byteLength","isArray","arrayLength","element","convertToObjectType","value","SCALAR","STRING","BOOLEAN","ENUM","numbers","map","n","Number","VEC2","unpack","VEC3","VEC4","MAT2","MAT3","MAT4","convertFromObjectType","pack","decodeMetadataValues","metadataProperty","arrayBasedResult","hasValueTransform","scale","valueTransformInPlace","applyValueTransform","arrayBasedValue","objectBasedValue","objectResult","Object","freeze"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/MetadataPicking.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport MetadataClassProperty from \"./MetadataClassProperty.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataType from \"./MetadataType.js\";\n\n/**\n * Utility functions for metadata picking.\n *\n * These are used by the `Picking.pickMetadata` function to decode\n * the metadata values that have been read from the frame buffer\n * into the actual metadata values, according to the structure\n * defined by the `MetadataClassProperty`.\n *\n * @private\n */\nconst MetadataPicking = {};\n\n/**\n * Returns the value at the specified index of the given data view,\n * interpreting the data to have the given component type.\n *\n * @param {MetadataComponentType} componentType The `MetadataComponentType`\n * @param {DataView} dataView The data view\n * @param {number} index The index (byte offset)\n * @returns {number|bigint|undefined} The value\n * @throws RuntimeError If the given component type is not a valid\n * `MetadataComponentType`\n * @throws RangeError If reading the data from the given data view would\n * cause an out-of-bounds access\n *\n * @private\n */\nMetadataPicking.decodeRawMetadataValue = function (\n  componentType,\n  dataView,\n  index,\n) {\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n      return dataView.getInt8(index);\n    case MetadataComponentType.UINT8:\n      return dataView.getUint8(index);\n    case MetadataComponentType.INT16:\n      return dataView.getInt16(index, true);\n    case MetadataComponentType.UINT16:\n      return dataView.getUint16(index, true);\n    case MetadataComponentType.INT32:\n      return dataView.getInt32(index, true);\n    case MetadataComponentType.UINT32:\n      return dataView.getUint32(index, true);\n    case MetadataComponentType.INT64:\n      return dataView.getBigInt64(index, true);\n    case MetadataComponentType.UINT64:\n      return dataView.getBigUint64(index, true);\n    case MetadataComponentType.FLOAT32:\n      return dataView.getFloat32(index, true);\n    case MetadataComponentType.FLOAT64:\n      return dataView.getFloat64(index, true);\n  }\n  throw new RuntimeError(`Invalid component type: ${componentType}`);\n};\n\n/**\n * Decodes one component of a metadata value with the given property type\n * from the given data view.\n *\n * This will decode one component (e.g. one entry of a SCALAR array,\n * or one component of a VEC2 element).\n *\n * This will apply normalization to the raw component value if the given\n * class property is 'normalized'.\n *\n * @param {MetadataClassProperty} classProperty The class property\n * @param {DataView} dataView The data view containing the raw metadata values\n * @param {number} dataViewOffset The byte offset within the data view from\n * which the component should be read\n * @returns {number|bigint|undefined} The metadata value component\n * @throws RuntimeError If the component of the given property is not\n * a valid `MetadataComponentType`\n * @throws RangeError If reading the data from the given data view would\n * cause an out-of-bounds access\n */\nMetadataPicking.decodeRawMetadataValueComponent = function (\n  classProperty,\n  dataView,\n  dataViewOffset,\n) {\n  const componentType = classProperty.componentType;\n  const component = MetadataPicking.decodeRawMetadataValue(\n    componentType,\n    dataView,\n    dataViewOffset,\n  );\n  if (classProperty.normalized) {\n    return MetadataComponentType.normalize(component, componentType);\n  }\n  return component;\n};\n\n/**\n * Decodes one element of a metadata value with the given property type\n * from the given data view.\n *\n * When the given class property is vector- or matrix typed, then the\n * result will be an array, with a length that corresponds to the\n * number of vector- or matrix components.\n *\n * Otherwise, it will be a single value.\n *\n * In any case, the return value will be the \"raw\" value, which does\n * take into account normalization, but does NOT take into account\n * default/noData value handling.\n *\n * @param {MetadataClassProperty} classProperty The metadata class property\n * @param {DataView} dataView The data view containing the raw metadata values\n * @param {number} elementIndex The index of the element. This is the index\n * inside the array for array-typed properties, and 0 for non-array types.\n * @returns {number|number[]|bigint|bigint[]|undefined} The decoded metadata value element\n * @throws RuntimeError If the component of the given property is not\n * a valid `MetadataComponentType`\n * @throws RangeError If reading the data from the given data view would\n * cause an out-of-bounds access\n *\n */\nMetadataPicking.decodeRawMetadataValueElement = function (\n  classProperty,\n  dataView,\n  elementIndex,\n) {\n  const componentType = classProperty.componentType;\n  const componentSizeInBytes =\n    MetadataComponentType.getSizeInBytes(componentType);\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n  const elementSizeInBytes = componentSizeInBytes * componentCount;\n  if (componentCount > 1) {\n    const result = Array(componentCount);\n    for (let i = 0; i < componentCount; i++) {\n      const offset =\n        elementIndex * elementSizeInBytes + i * componentSizeInBytes;\n      const component = MetadataPicking.decodeRawMetadataValueComponent(\n        classProperty,\n        dataView,\n        offset,\n      );\n      result[i] = component;\n    }\n    return result;\n  }\n  const offset = elementIndex * elementSizeInBytes;\n  const result = MetadataPicking.decodeRawMetadataValueComponent(\n    classProperty,\n    dataView,\n    offset,\n  );\n  return result;\n};\n\n/**\n * Decode the given raw values into the raw (array-based) form of\n * a metadata property value.\n *\n * (For decoding to types like `CartesianN`, the `decodeMetadataValues`\n * function can be used)\n *\n * The given values are a `Uint8Array` containing the RGBA\n * values that have been read from the metadata picking\n * frame buffer. They are assumed to contain the value for\n * the given class property, as encoded by the\n * `MetadataPickingPipelineStage` for metadata picking.\n *\n * When the given class property is an array, then (it has to be\n * a fixed-length array, and) the result will be an array with\n * the respective length.\n *\n * When the given class property is vector- or matrix typed,\n * then the result will be an array, with a length that corresponds\n * to the number of vector- or matrix components.\n *\n * (The case that the property is an array of vector- or matrix\n * elements is not supported on the side of the general metadata\n * shader infrastructure, but handled here nevertheless. For such\n * an input, the result would be an array of arrays, with each\n * element representing one of the vectors or matrices).\n *\n * In any case, the return value will be the \"raw\" value, which does\n * take into account normalization, but does NOT take into account\n * any offset/scale, or default/noData value handling.\n *\n * @param {MetadataClassProperty} classProperty The `MetadataClassProperty`\n * @param {Uint8Array} rawPixelValues The raw values\n * @returns {number|bigint|number[]|bigint[]|undefined} The value\n * @throws RuntimeError If the class property has an invalid component type\n *\n * @private\n */\nMetadataPicking.decodeRawMetadataValues = function (\n  classProperty,\n  rawPixelValues,\n) {\n  const dataView = new DataView(\n    rawPixelValues.buffer,\n    rawPixelValues.byteOffset,\n    rawPixelValues.byteLength,\n  );\n  if (classProperty.isArray) {\n    const arrayLength = classProperty.arrayLength;\n    const result = Array(arrayLength);\n    for (let i = 0; i < arrayLength; i++) {\n      const element = MetadataPicking.decodeRawMetadataValueElement(\n        classProperty,\n        dataView,\n        i,\n      );\n      result[i] = element;\n    }\n    return result;\n  }\n  const result = MetadataPicking.decodeRawMetadataValueElement(\n    classProperty,\n    dataView,\n    0,\n  );\n  return result;\n};\n\n/**\n * Converts the given type into an object representation where appropriate.\n *\n * When the given type is `SCALAR`, `STRING`, `BOOLEAN`, or `ENUM`, or\n * when the given value is `undefined`, then the given value will be\n * returned.\n *\n * Otherwise, for the `VECn/MATn` types, the given value is assumed to be\n * a numeric array, and is converted into the matching `CartesianN/MatrixN`\n * value.\n *\n * @param {string} type The `ClassProperty` type\n * @param {number|bigint|number[]|bigint[]|undefined} value The input value\n * @returns {undefined|number|bigint|string|boolean|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4} The object representation\n * @throws RuntimeError If the type is not a valid `MetadataType`\n */\nMetadataPicking.convertToObjectType = function (type, value) {\n  if (!defined(value)) {\n    return value;\n  }\n  if (\n    type === MetadataType.SCALAR ||\n    type === MetadataType.STRING ||\n    type === MetadataType.BOOLEAN ||\n    type === MetadataType.ENUM\n  ) {\n    return value;\n  }\n  const numbers = value.map((n) => Number(n));\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2.unpack(numbers, 0, new Cartesian2());\n    case MetadataType.VEC3:\n      return Cartesian3.unpack(numbers, 0, new Cartesian3());\n    case MetadataType.VEC4:\n      return Cartesian4.unpack(numbers, 0, new Cartesian4());\n    case MetadataType.MAT2:\n      return Matrix2.unpack(numbers, 0, new Matrix2());\n    case MetadataType.MAT3:\n      return Matrix3.unpack(numbers, 0, new Matrix3());\n    case MetadataType.MAT4:\n      return Matrix4.unpack(numbers, 0, new Matrix4());\n  }\n  // Should never happen:\n  throw new RuntimeError(`Invalid metadata object type: ${type}`);\n};\n\n/**\n * Converts the given type into a raw value or array representation.\n *\n * For `VECn/MATn` types, the given value is converted into an array.\n * For other types, the value is returned directly\n *\n * @param {string} type The `ClassProperty` type\n * @param {undefined|number|bigint|string|boolean|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4} value The input value\n * @returns {undefined|number|bigint|string|boolean|number[]} The array representation\n * @throws RuntimeError If the type is not a valid `MetadataType`\n */\nMetadataPicking.convertFromObjectType = function (type, value) {\n  if (!defined(value)) {\n    return value;\n  }\n  if (\n    type === MetadataType.SCALAR ||\n    type === MetadataType.STRING ||\n    type === MetadataType.BOOLEAN ||\n    type === MetadataType.ENUM\n  ) {\n    return value;\n  }\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2.pack(value, Array(2));\n    case MetadataType.VEC3:\n      return Cartesian3.pack(value, Array(3));\n    case MetadataType.VEC4:\n      return Cartesian4.pack(value, Array(4));\n    case MetadataType.MAT2:\n      return Matrix2.pack(value, Array(4));\n    case MetadataType.MAT3:\n      return Matrix3.pack(value, Array(9));\n    case MetadataType.MAT4:\n      return Matrix4.pack(value, Array(16));\n  }\n  // Should never happen:\n  throw new RuntimeError(`Invalid metadata object type: ${type}`);\n};\n\n/**\n * Decode the given raw values into a metadata property value.\n *\n * This applies the value transform (offset/scale) to the result\n * of `decodeRawMetadataValues`, and converts this from array-based\n * types into object types like `CartesianN`.\n *\n * @param {MetadataClassProperty} classProperty The `MetadataClassProperty`\n * @param {object} metadataProperty The\n * `PropertyTextureProperty` or `PropertyAttributeProperty`\n * @param {Uint8Array} rawPixelValues The raw values\n * @returns {MetadataValue} The value\n * @throws RuntimeError If the class property has an invalid type\n * or component type\n * @throws RangeError If the given pixel values do not have sufficient\n * size to contain the expected value type\n *\n * @private\n */\nMetadataPicking.decodeMetadataValues = function (\n  classProperty,\n  metadataProperty,\n  rawPixelValues,\n) {\n  let arrayBasedResult = MetadataPicking.decodeRawMetadataValues(\n    classProperty,\n    rawPixelValues,\n  );\n\n  if (metadataProperty.hasValueTransform) {\n    // In the MetadataClassProperty, these offset/scale are always in\n    // their array-based form (e.g. a number[3] for `VEC3`). But for\n    // the PropertyTextureProperty and PropertyAttributeProperty,\n    // the type of the offset/scale is defined to be\n    // number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4\n    // So these types are converted into their array-based form here, before\n    // applying them with `MetadataClassProperty.valueTransformInPlace`\n\n    const offset = MetadataPicking.convertFromObjectType(\n      classProperty.type,\n      metadataProperty.offset,\n    );\n    const scale = MetadataPicking.convertFromObjectType(\n      classProperty.type,\n      metadataProperty.scale,\n    );\n    arrayBasedResult = MetadataClassProperty.valueTransformInPlace(\n      arrayBasedResult,\n      offset,\n      scale,\n      MetadataComponentType.applyValueTransform,\n    );\n  }\n\n  if (classProperty.isArray) {\n    const arrayLength = classProperty.arrayLength;\n    const result = Array(arrayLength);\n    for (let i = 0; i < arrayLength; i++) {\n      const arrayBasedValue = arrayBasedResult[i];\n      const objectBasedValue = MetadataPicking.convertToObjectType(\n        classProperty.type,\n        arrayBasedValue,\n      );\n      result[i] = objectBasedValue;\n    }\n    return result;\n  }\n  const objectResult = MetadataPicking.convertToObjectType(\n    classProperty.type,\n    arrayBasedResult,\n  );\n  return objectResult;\n};\n\nexport default Object.freeze(MetadataPicking);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}