{"ast":null,"code":"import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport InstancingStageCommon from \"../../Shaders/Model/InstancingStageCommon.js\";\nimport InstancingStageVS from \"../../Shaders/Model/InstancingStageVS.js\";\nimport LegacyInstancingStageVS from \"../../Shaders/Model/LegacyInstancingStageVS.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nconst modelViewScratch = new Matrix4();\nconst nodeTransformScratch = new Matrix4();\nconst modelView2DScratch = new Matrix4();\n\n/**\n * The instancing pipeline stage is responsible for handling GPU mesh instancing at the node\n * level.\n *\n * @namespace InstancingPipelineStage\n * @private\n */\nconst InstancingPipelineStage = {\n  name: \"InstancingPipelineStage\",\n  // Helps with debugging\n\n  // Expose some methods for testing\n  _getInstanceTransformsAsMatrices: getInstanceTransformsAsMatrices,\n  _transformsToTypedArray: transformsToTypedArray\n};\n\n/**\n * Process a node. This modifies the following parts of the render resources:\n * <ul>\n *  <li> creates buffers for the typed arrays of each attribute, if they do not yet exist\n *  <li> adds attribute declarations for the instancing vertex attributes in the vertex shader</li>\n *  <li> sets the instancing translation min and max to compute an accurate bounding volume</li>\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds additional attributes for the transformation attributes projected to 2D\n *  <li> adds a flag to the shader to use the 2D instanced attributes\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {NodeRenderResources} renderResources The render resources for this node.\n * @param {ModelComponents.Node} node The node.\n * @param {FrameState} frameState The frame state.\n */\nInstancingPipelineStage.process = function (renderResources, node, frameState) {\n  const instances = node.instances;\n  const count = instances.attributes[0].count;\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_INSTANCING\");\n  shaderBuilder.addVertexLines(InstancingStageCommon);\n  const model = renderResources.model;\n  const sceneGraph = model.sceneGraph;\n  const runtimeNode = renderResources.runtimeNode;\n  const use2D = frameState.mode !== SceneMode.SCENE3D && !frameState.scene3DOnly && model._projectTo2D;\n  const keepTypedArray = model._enablePick && !frameState.context.webgl2;\n  const instancingVertexAttributes = [];\n  processTransformAttributes(renderResources, frameState, instances, instancingVertexAttributes, use2D, keepTypedArray);\n  processFeatureIdAttributes(renderResources, frameState, instances, instancingVertexAttributes);\n  const uniformMap = {};\n  if (instances.transformInWorldSpace) {\n    shaderBuilder.addDefine(\"USE_LEGACY_INSTANCING\", undefined, ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(\"mat4\", \"u_instance_modifiedModelView\", ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(\"mat4\", \"u_instance_nodeTransform\", ShaderDestination.VERTEX);\n\n    // The i3dm format applies the instancing transforms in world space.\n    // Instancing matrices come from a vertex attribute rather than a\n    // uniform, and they are multiplied in the middle of the modelView matrix\n    // product. This means czm_modelView can't be used. Instead, we split the\n    // matrix into two parts, modifiedModelView and nodeTransform, and handle\n    // this in LegacyInstancingStageVS.glsl. Conceptually the product looks like\n    // this:\n    //\n    // modelView = u_modifiedModelView * a_instanceTransform * u_nodeTransform\n    uniformMap.u_instance_modifiedModelView = function () {\n      // Model matrix without the node hierarchy or axis correction\n      // (see u_instance_nodeTransform).\n      let modifiedModelMatrix = Matrix4.multiplyTransformation(\n      // For 3D Tiles, model.modelMatrix is the computed tile\n      // transform (which includes tileset.modelMatrix). This always applies\n      // for i3dm, since such models are always part of a tileset.\n      model.modelMatrix,\n      // For i3dm models, components.transform contains the RTC_CENTER\n      // translation.\n      sceneGraph.components.transform, modelViewScratch);\n      if (use2D) {\n        // If projectTo2D is enabled, the 2D view matrix\n        // will be accounted for in the u_modelView2D\n        // uniform.\n        //\n        // modifiedModelView = view3D * modifiedModel\n        return Matrix4.multiplyTransformation(frameState.context.uniformState.view3D, modifiedModelMatrix, modelViewScratch);\n      }\n\n      // For projection to 2D without projectTo2D enabled,\n      // project the model matrix to 2D.\n      if (frameState.mode !== SceneMode.SCENE3D) {\n        modifiedModelMatrix = Transforms.basisTo2D(frameState.mapProjection, modifiedModelMatrix, modelViewScratch);\n      }\n\n      // modifiedModelView = view * modifiedModel\n      return Matrix4.multiplyTransformation(frameState.context.uniformState.view, modifiedModelMatrix, modelViewScratch);\n    };\n    uniformMap.u_instance_nodeTransform = function () {\n      // nodeTransform = axisCorrection * nodeHierarchyTransform\n      return Matrix4.multiplyTransformation(\n      // glTF y-up to 3D Tiles z-up\n      sceneGraph.axisCorrectionMatrix,\n      // This transforms from the node's coordinate system to the root\n      // of the node hierarchy\n      runtimeNode.computedTransform, nodeTransformScratch);\n    };\n    shaderBuilder.addVertexLines(LegacyInstancingStageVS);\n  } else {\n    shaderBuilder.addVertexLines(InstancingStageVS);\n  }\n  if (use2D) {\n    shaderBuilder.addDefine(\"USE_2D_INSTANCING\", undefined, ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n    const context = frameState.context;\n    const modelMatrix2D = Matrix4.fromTranslation(runtimeNode.instancingReferencePoint2D, new Matrix4());\n    uniformMap.u_modelView2D = function () {\n      return Matrix4.multiplyTransformation(context.uniformState.view, modelMatrix2D, modelView2DScratch);\n    };\n  }\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n  renderResources.instanceCount = count;\n  renderResources.attributes.push.apply(renderResources.attributes, instancingVertexAttributes);\n};\nconst projectedTransformScratch = new Matrix4();\nconst projectedPositionScratch = new Cartesian3();\nfunction projectTransformTo2D(transform, modelMatrix, nodeTransform, frameState, result) {\n  let projectedTransform = Matrix4.multiplyTransformation(modelMatrix, transform, projectedTransformScratch);\n  projectedTransform = Matrix4.multiplyTransformation(projectedTransform, nodeTransform, projectedTransformScratch);\n  result = Transforms.basisTo2D(frameState.mapProjection, projectedTransform, result);\n  return result;\n}\nfunction projectPositionTo2D(position, modelMatrix, nodeTransform, frameState, result) {\n  const translationMatrix = Matrix4.fromTranslation(position, projectedTransformScratch);\n  let projectedTransform = Matrix4.multiplyTransformation(modelMatrix, translationMatrix, projectedTransformScratch);\n  projectedTransform = Matrix4.multiplyTransformation(projectedTransform, nodeTransform, projectedTransformScratch);\n  const finalPosition = Matrix4.getTranslation(projectedTransform, projectedPositionScratch);\n  result = SceneTransforms.computeActualEllipsoidPosition(frameState, finalPosition, result);\n  return result;\n}\nfunction getModelMatrixAndNodeTransform(renderResources, modelMatrix, nodeComputedTransform) {\n  const model = renderResources.model;\n  const sceneGraph = model.sceneGraph;\n  const instances = renderResources.runtimeNode.node.instances;\n  if (instances.transformInWorldSpace) {\n    // Replicate the multiplication order in LegacyInstancingStageVS.\n    modelMatrix = Matrix4.multiplyTransformation(model.modelMatrix, sceneGraph.components.transform, modelMatrix);\n    nodeComputedTransform = Matrix4.multiplyTransformation(sceneGraph.axisCorrectionMatrix, renderResources.runtimeNode.computedTransform, nodeComputedTransform);\n  } else {\n    // The node transform should be pre-multiplied with the instancing transform.\n    modelMatrix = Matrix4.clone(sceneGraph.computedModelMatrix, modelMatrix);\n    modelMatrix = Matrix4.multiplyTransformation(modelMatrix, renderResources.runtimeNode.computedTransform, modelMatrix);\n    nodeComputedTransform = Matrix4.clone(Matrix4.IDENTITY, nodeComputedTransform);\n  }\n}\nconst modelMatrixScratch = new Matrix4();\nconst nodeComputedTransformScratch = new Matrix4();\nconst transformScratch = new Matrix4();\nconst positionScratch = new Cartesian3();\nfunction projectTransformsTo2D(transforms, renderResources, frameState, result) {\n  const modelMatrix = modelMatrixScratch;\n  const nodeComputedTransform = nodeComputedTransformScratch;\n  getModelMatrixAndNodeTransform(renderResources, modelMatrix, nodeComputedTransform);\n  const runtimeNode = renderResources.runtimeNode;\n  const referencePoint = runtimeNode.instancingReferencePoint2D;\n  const count = transforms.length;\n  for (let i = 0; i < count; i++) {\n    const transform = transforms[i];\n    const projectedTransform = projectTransformTo2D(transform, modelMatrix, nodeComputedTransform, frameState, transformScratch);\n    const position = Matrix4.getTranslation(projectedTransform, positionScratch);\n    const finalTranslation = Cartesian3.subtract(position, referencePoint, position);\n    result[i] = Matrix4.setTranslation(projectedTransform, finalTranslation, result[i]);\n  }\n  return result;\n}\nfunction projectTranslationsTo2D(translations, renderResources, frameState, result) {\n  const modelMatrix = modelMatrixScratch;\n  const nodeComputedTransform = nodeComputedTransformScratch;\n  getModelMatrixAndNodeTransform(renderResources, modelMatrix, nodeComputedTransform);\n  const runtimeNode = renderResources.runtimeNode;\n  const referencePoint = runtimeNode.instancingReferencePoint2D;\n  const count = translations.length;\n  for (let i = 0; i < count; i++) {\n    const translation = translations[i];\n    const projectedPosition = projectPositionTo2D(translation, modelMatrix, nodeComputedTransform, frameState, translation);\n    result[i] = Cartesian3.subtract(projectedPosition, referencePoint, result[i]);\n  }\n  return result;\n}\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\nfunction computeReferencePoint2D(renderResources, frameState) {\n  // Compute the reference point by averaging the instancing translation\n  // min / max values after they are projected to 2D.\n  const runtimeNode = renderResources.runtimeNode;\n  const modelMatrix = renderResources.model.sceneGraph.computedModelMatrix;\n  const transformedPositionMin = Matrix4.multiplyByPoint(modelMatrix, runtimeNode.instancingTranslationMin, scratchProjectedMin);\n  const projectedMin = SceneTransforms.computeActualEllipsoidPosition(frameState, transformedPositionMin, transformedPositionMin);\n  const transformedPositionMax = Matrix4.multiplyByPoint(modelMatrix, runtimeNode.instancingTranslationMax, scratchProjectedMax);\n  const projectedMax = SceneTransforms.computeActualEllipsoidPosition(frameState, transformedPositionMax, transformedPositionMax);\n  runtimeNode.instancingReferencePoint2D = Cartesian3.lerp(projectedMin, projectedMax, 0.5, new Cartesian3());\n}\nfunction transformsToTypedArray(transforms) {\n  const elements = 12;\n  const count = transforms.length;\n  const transformsTypedArray = new Float32Array(count * elements);\n  for (let i = 0; i < count; i++) {\n    const transform = transforms[i];\n    const offset = elements * i;\n    transformsTypedArray[offset + 0] = transform[0];\n    transformsTypedArray[offset + 1] = transform[4];\n    transformsTypedArray[offset + 2] = transform[8];\n    transformsTypedArray[offset + 3] = transform[12];\n    transformsTypedArray[offset + 4] = transform[1];\n    transformsTypedArray[offset + 5] = transform[5];\n    transformsTypedArray[offset + 6] = transform[9];\n    transformsTypedArray[offset + 7] = transform[13];\n    transformsTypedArray[offset + 8] = transform[2];\n    transformsTypedArray[offset + 9] = transform[6];\n    transformsTypedArray[offset + 10] = transform[10];\n    transformsTypedArray[offset + 11] = transform[14];\n  }\n  return transformsTypedArray;\n}\nfunction translationsToTypedArray(translations) {\n  const elements = 3;\n  const count = translations.length;\n  const transationsTypedArray = new Float32Array(count * elements);\n  for (let i = 0; i < count; i++) {\n    const translation = translations[i];\n    const offset = elements * i;\n    transationsTypedArray[offset + 0] = translation[0];\n    transationsTypedArray[offset + 1] = translation[4];\n    transationsTypedArray[offset + 2] = translation[8];\n  }\n  return transationsTypedArray;\n}\nconst translationScratch = new Cartesian3();\nconst rotationScratch = new Quaternion();\nconst scaleScratch = new Cartesian3();\nfunction getInstanceTransformsAsMatrices(instances, count, renderResources) {\n  const transforms = new Array(count);\n  const translationAttribute = ModelUtility.getAttributeBySemantic(instances, InstanceAttributeSemantic.TRANSLATION);\n  const rotationAttribute = ModelUtility.getAttributeBySemantic(instances, InstanceAttributeSemantic.ROTATION);\n  const scaleAttribute = ModelUtility.getAttributeBySemantic(instances, InstanceAttributeSemantic.SCALE);\n  const instancingTranslationMax = new Cartesian3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  const instancingTranslationMin = new Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  const hasTranslation = defined(translationAttribute);\n  const hasRotation = defined(rotationAttribute);\n  const hasScale = defined(scaleAttribute);\n\n  // Translations get initialized to (0, 0, 0).\n  const translationTypedArray = hasTranslation ? translationAttribute.typedArray : new Float32Array(count * 3);\n\n  // Rotations get initialized to (0, 0, 0, 0).\n  // The w-component is set to 1 in the loop below.\n  let rotationTypedArray = hasRotation ? rotationAttribute.typedArray : new Float32Array(count * 4);\n\n  // The rotation attribute may be normalized\n  if (hasRotation && rotationAttribute.normalized) {\n    rotationTypedArray = AttributeCompression.dequantize(rotationTypedArray, rotationAttribute.componentDatatype, rotationAttribute.type, count);\n  }\n\n  // Scales get initialized to (1, 1, 1).\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = scaleAttribute.typedArray;\n  } else {\n    scaleTypedArray = new Float32Array(count * 3);\n    scaleTypedArray.fill(1);\n  }\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(translationTypedArray[i * 3], translationTypedArray[i * 3 + 1], translationTypedArray[i * 3 + 2], translationScratch);\n    Cartesian3.maximumByComponent(instancingTranslationMax, translation, instancingTranslationMax);\n    Cartesian3.minimumByComponent(instancingTranslationMin, translation, instancingTranslationMin);\n    const rotation = new Quaternion(rotationTypedArray[i * 4], rotationTypedArray[i * 4 + 1], rotationTypedArray[i * 4 + 2], hasRotation ? rotationTypedArray[i * 4 + 3] : 1, rotationScratch);\n    const scale = new Cartesian3(scaleTypedArray[i * 3], scaleTypedArray[i * 3 + 1], scaleTypedArray[i * 3 + 2], scaleScratch);\n    const transform = Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, new Matrix4());\n    transforms[i] = transform;\n  }\n  const runtimeNode = renderResources.runtimeNode;\n  runtimeNode.instancingTranslationMin = instancingTranslationMin;\n  runtimeNode.instancingTranslationMax = instancingTranslationMax;\n\n  // Unload the typed arrays. These are just pointers to the arrays\n  // in the vertex buffer loader.\n  if (hasTranslation) {\n    translationAttribute.typedArray = undefined;\n  }\n  if (hasRotation) {\n    rotationAttribute.typedArray = undefined;\n  }\n  if (hasScale) {\n    scaleAttribute.typedArray = undefined;\n  }\n  return transforms;\n}\nfunction getInstanceTranslationsAsCartesian3s(translationAttribute, count, renderResources) {\n  const instancingTranslations = new Array(count);\n  const translationTypedArray = translationAttribute.typedArray;\n  const instancingTranslationMin = new Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  const instancingTranslationMax = new Cartesian3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(translationTypedArray[i * 3], translationTypedArray[i * 3 + 1], translationTypedArray[i * 3 + 2]);\n    instancingTranslations[i] = translation;\n    Cartesian3.minimumByComponent(instancingTranslationMin, translation, instancingTranslationMin);\n    Cartesian3.maximumByComponent(instancingTranslationMax, translation, instancingTranslationMax);\n  }\n  const runtimeNode = renderResources.runtimeNode;\n  runtimeNode.instancingTranslationMin = instancingTranslationMin;\n  runtimeNode.instancingTranslationMax = instancingTranslationMax;\n\n  // Unload the typed array. This is just a pointer to the array\n  // in the vertex buffer loader.\n  translationAttribute.typedArray = undefined;\n  return instancingTranslations;\n}\nfunction createVertexBuffer(typedArray, frameState) {\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW\n  });\n\n  // Destruction of resources allocated by the Model\n  // is handled by Model.destroy().\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\nfunction processTransformAttributes(renderResources, frameState, instances, instancingVertexAttributes, use2D, keepTypedArray) {\n  const rotationAttribute = ModelUtility.getAttributeBySemantic(instances, InstanceAttributeSemantic.ROTATION);\n\n  // Only use matrices for the transforms if the rotation attribute is defined.\n  if (defined(rotationAttribute)) {\n    processTransformMatrixAttributes(renderResources, instances, instancingVertexAttributes, frameState, use2D, keepTypedArray);\n  } else {\n    processTransformVec3Attributes(renderResources, instances, instancingVertexAttributes, frameState, use2D);\n  }\n}\nfunction processTransformMatrixAttributes(renderResources, instances, instancingVertexAttributes, frameState, use2D, keepTypedArray) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const count = instances.attributes[0].count;\n  const model = renderResources.model;\n  const runtimeNode = renderResources.runtimeNode;\n  shaderBuilder.addDefine(\"HAS_INSTANCE_MATRICES\");\n  const attributeString = \"Transform\";\n  let transforms;\n  let buffer = runtimeNode.instancingTransformsBuffer;\n  if (!defined(buffer)) {\n    // This function computes the transforms, sets the translation min / max,\n    // and unloads the typed arrays associated with the attributes.\n    transforms = getInstanceTransformsAsMatrices(instances, count, renderResources);\n    const transformsTypedArray = transformsToTypedArray(transforms);\n    buffer = createVertexBuffer(transformsTypedArray, frameState);\n    model._modelResources.push(buffer);\n    if (keepTypedArray) {\n      runtimeNode.transformsTypedArray = transformsTypedArray;\n    }\n    runtimeNode.instancingTransformsBuffer = buffer;\n  }\n  processMatrixAttributes(renderResources, buffer, instancingVertexAttributes, attributeString);\n  if (!use2D) {\n    return;\n  }\n\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the instanced\n  // translation bounds projected to 2D.\n  computeReferencePoint2D(renderResources, frameStateCV);\n  let buffer2D = runtimeNode.instancingTransformsBuffer2D;\n  if (!defined(buffer2D)) {\n    const projectedTransforms = projectTransformsTo2D(transforms, renderResources, frameStateCV, transforms);\n    const projectedTypedArray = transformsToTypedArray(projectedTransforms);\n\n    // This memory is counted during the statistics stage at the end\n    // of the pipeline.\n    buffer2D = createVertexBuffer(projectedTypedArray, frameState);\n    model._modelResources.push(buffer2D);\n    runtimeNode.instancingTransformsBuffer2D = buffer2D;\n  }\n  const attributeString2D = \"Transform2D\";\n  processMatrixAttributes(renderResources, buffer2D, instancingVertexAttributes, attributeString2D);\n}\nfunction processTransformVec3Attributes(renderResources, instances, instancingVertexAttributes, frameState, use2D, keepTypedArray) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const runtimeNode = renderResources.runtimeNode;\n  const translationAttribute = ModelUtility.getAttributeBySemantic(instances, InstanceAttributeSemantic.TRANSLATION);\n  const scaleAttribute = ModelUtility.getAttributeBySemantic(instances, InstanceAttributeSemantic.SCALE);\n  if (defined(scaleAttribute)) {\n    shaderBuilder.addDefine(\"HAS_INSTANCE_SCALE\");\n    const attributeString = \"Scale\";\n\n    // Instanced scale attributes are loaded as buffers only.\n    processVec3Attribute(renderResources, scaleAttribute.buffer, scaleAttribute.byteOffset, scaleAttribute.byteStride, instancingVertexAttributes, attributeString);\n  }\n  if (!defined(translationAttribute)) {\n    return;\n  }\n  let instancingTranslations;\n  const typedArray = translationAttribute.typedArray;\n  if (defined(typedArray)) {\n    // This function computes and set the translation min / max, and unloads\n    // the typed array associated with the attribute.\n    // The translations are also returned in case they're used for 2D projection.\n    instancingTranslations = getInstanceTranslationsAsCartesian3s(translationAttribute, translationAttribute.count, renderResources);\n  } else if (!defined(runtimeNode.instancingTranslationMin)) {\n    runtimeNode.instancingTranslationMin = translationAttribute.min;\n    runtimeNode.instancingTranslationMax = translationAttribute.max;\n  }\n  shaderBuilder.addDefine(\"HAS_INSTANCE_TRANSLATION\");\n  const attributeString = \"Translation\";\n  processVec3Attribute(renderResources, translationAttribute.buffer, translationAttribute.byteOffset, translationAttribute.byteStride, instancingVertexAttributes, attributeString);\n  if (!use2D && !keepTypedArray) {\n    return;\n  }\n\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the instanced\n  // translation bounds projected to 2D.\n  computeReferencePoint2D(renderResources, frameStateCV);\n  let buffer2D = runtimeNode.instancingTranslationBuffer2D;\n  if (!defined(buffer2D)) {\n    const projectedTranslations = projectTranslationsTo2D(instancingTranslations, renderResources, frameStateCV, instancingTranslations);\n    const projectedTypedArray = translationsToTypedArray(projectedTranslations);\n    if (keepTypedArray) {\n      runtimeNode.transformsTypedArray = projectedTypedArray;\n    }\n\n    // This memory is counted during the statistics stage at the end\n    // of the pipeline.\n    buffer2D = createVertexBuffer(projectedTypedArray, frameState);\n    renderResources.model._modelResources.push(buffer2D);\n    runtimeNode.instancingTranslationBuffer2D = buffer2D;\n  }\n  if (!use2D) {\n    return;\n  }\n  const byteOffset = 0;\n  const byteStride = undefined;\n  const attributeString2D = \"Translation2D\";\n  processVec3Attribute(renderResources, buffer2D, byteOffset, byteStride, instancingVertexAttributes, attributeString2D);\n}\nfunction processMatrixAttributes(renderResources, buffer, instancingVertexAttributes, attributeString) {\n  const vertexSizeInFloats = 12;\n  const componentByteSize = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);\n  const strideInBytes = componentByteSize * vertexSizeInFloats;\n  const matrixAttributes = [{\n    index: renderResources.attributeIndex++,\n    vertexBuffer: buffer,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: strideInBytes,\n    instanceDivisor: 1\n  }, {\n    index: renderResources.attributeIndex++,\n    vertexBuffer: buffer,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    normalize: false,\n    offsetInBytes: componentByteSize * 4,\n    strideInBytes: strideInBytes,\n    instanceDivisor: 1\n  }, {\n    index: renderResources.attributeIndex++,\n    vertexBuffer: buffer,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    normalize: false,\n    offsetInBytes: componentByteSize * 8,\n    strideInBytes: strideInBytes,\n    instanceDivisor: 1\n  }];\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row0`);\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row1`);\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row2`);\n  instancingVertexAttributes.push.apply(instancingVertexAttributes, matrixAttributes);\n}\nfunction processVec3Attribute(renderResources, buffer, byteOffset, byteStride, instancingVertexAttributes, attributeString) {\n  instancingVertexAttributes.push({\n    index: renderResources.attributeIndex++,\n    vertexBuffer: buffer,\n    componentsPerAttribute: 3,\n    componentDatatype: ComponentDatatype.FLOAT,\n    normalize: false,\n    offsetInBytes: byteOffset,\n    strideInBytes: byteStride,\n    instanceDivisor: 1\n  });\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addAttribute(\"vec3\", `a_instance${attributeString}`);\n}\nfunction processFeatureIdAttributes(renderResources, frameState, instances, instancingVertexAttributes) {\n  const attributes = instances.attributes;\n  const shaderBuilder = renderResources.shaderBuilder;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic !== InstanceAttributeSemantic.FEATURE_ID) {\n      continue;\n    }\n    if (attribute.setIndex >= renderResources.featureIdVertexAttributeSetIndex) {\n      renderResources.featureIdVertexAttributeSetIndex = attribute.setIndex + 1;\n    }\n    instancingVertexAttributes.push({\n      index: renderResources.attributeIndex++,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: AttributeType.getNumberOfComponents(attribute.type),\n      componentDatatype: attribute.componentDatatype,\n      normalize: false,\n      offsetInBytes: attribute.byteOffset,\n      strideInBytes: attribute.byteStride,\n      instanceDivisor: 1\n    });\n    shaderBuilder.addAttribute(\"float\", `a_instanceFeatureId_${attribute.setIndex}`);\n  }\n}\nexport default InstancingPipelineStage;","map":{"version":3,"names":["AttributeCompression","Cartesian3","clone","combine","ComponentDatatype","defined","Matrix4","Quaternion","Transforms","Buffer","BufferUsage","ShaderDestination","InstancingStageCommon","InstancingStageVS","LegacyInstancingStageVS","AttributeType","InstanceAttributeSemantic","SceneMode","SceneTransforms","ModelUtility","modelViewScratch","nodeTransformScratch","modelView2DScratch","InstancingPipelineStage","name","_getInstanceTransformsAsMatrices","getInstanceTransformsAsMatrices","_transformsToTypedArray","transformsToTypedArray","process","renderResources","node","frameState","instances","count","attributes","shaderBuilder","addDefine","addVertexLines","model","sceneGraph","runtimeNode","use2D","mode","SCENE3D","scene3DOnly","_projectTo2D","keepTypedArray","_enablePick","context","webgl2","instancingVertexAttributes","processTransformAttributes","processFeatureIdAttributes","uniformMap","transformInWorldSpace","undefined","VERTEX","addUniform","u_instance_modifiedModelView","modifiedModelMatrix","multiplyTransformation","modelMatrix","components","transform","uniformState","view3D","basisTo2D","mapProjection","view","u_instance_nodeTransform","axisCorrectionMatrix","computedTransform","modelMatrix2D","fromTranslation","instancingReferencePoint2D","u_modelView2D","instanceCount","push","apply","projectedTransformScratch","projectedPositionScratch","projectTransformTo2D","nodeTransform","result","projectedTransform","projectPositionTo2D","position","translationMatrix","finalPosition","getTranslation","computeActualEllipsoidPosition","getModelMatrixAndNodeTransform","nodeComputedTransform","computedModelMatrix","IDENTITY","modelMatrixScratch","nodeComputedTransformScratch","transformScratch","positionScratch","projectTransformsTo2D","transforms","referencePoint","length","i","finalTranslation","subtract","setTranslation","projectTranslationsTo2D","translations","translation","projectedPosition","scratchProjectedMin","scratchProjectedMax","computeReferencePoint2D","transformedPositionMin","multiplyByPoint","instancingTranslationMin","projectedMin","transformedPositionMax","instancingTranslationMax","projectedMax","lerp","elements","transformsTypedArray","Float32Array","offset","translationsToTypedArray","transationsTypedArray","translationScratch","rotationScratch","scaleScratch","Array","translationAttribute","getAttributeBySemantic","TRANSLATION","rotationAttribute","ROTATION","scaleAttribute","SCALE","Number","MAX_VALUE","hasTranslation","hasRotation","hasScale","translationTypedArray","typedArray","rotationTypedArray","normalized","dequantize","componentDatatype","type","scaleTypedArray","fill","maximumByComponent","minimumByComponent","rotation","scale","fromTranslationQuaternionRotationScale","getInstanceTranslationsAsCartesian3s","instancingTranslations","createVertexBuffer","buffer","usage","STATIC_DRAW","vertexArrayDestroyable","processTransformMatrixAttributes","processTransformVec3Attributes","attributeString","instancingTransformsBuffer","_modelResources","processMatrixAttributes","frameStateCV","COLUMBUS_VIEW","buffer2D","instancingTransformsBuffer2D","projectedTransforms","projectedTypedArray","attributeString2D","processVec3Attribute","byteOffset","byteStride","min","max","instancingTranslationBuffer2D","projectedTranslations","vertexSizeInFloats","componentByteSize","getSizeInBytes","FLOAT","strideInBytes","matrixAttributes","index","attributeIndex","vertexBuffer","componentsPerAttribute","normalize","offsetInBytes","instanceDivisor","addAttribute","attribute","semantic","FEATURE_ID","setIndex","featureIdVertexAttributeSetIndex","getNumberOfComponents"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/InstancingPipelineStage.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport InstancingStageCommon from \"../../Shaders/Model/InstancingStageCommon.js\";\nimport InstancingStageVS from \"../../Shaders/Model/InstancingStageVS.js\";\nimport LegacyInstancingStageVS from \"../../Shaders/Model/LegacyInstancingStageVS.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst modelViewScratch = new Matrix4();\nconst nodeTransformScratch = new Matrix4();\nconst modelView2DScratch = new Matrix4();\n\n/**\n * The instancing pipeline stage is responsible for handling GPU mesh instancing at the node\n * level.\n *\n * @namespace InstancingPipelineStage\n * @private\n */\nconst InstancingPipelineStage = {\n  name: \"InstancingPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _getInstanceTransformsAsMatrices: getInstanceTransformsAsMatrices,\n  _transformsToTypedArray: transformsToTypedArray,\n};\n\n/**\n * Process a node. This modifies the following parts of the render resources:\n * <ul>\n *  <li> creates buffers for the typed arrays of each attribute, if they do not yet exist\n *  <li> adds attribute declarations for the instancing vertex attributes in the vertex shader</li>\n *  <li> sets the instancing translation min and max to compute an accurate bounding volume</li>\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds additional attributes for the transformation attributes projected to 2D\n *  <li> adds a flag to the shader to use the 2D instanced attributes\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {NodeRenderResources} renderResources The render resources for this node.\n * @param {ModelComponents.Node} node The node.\n * @param {FrameState} frameState The frame state.\n */\nInstancingPipelineStage.process = function (renderResources, node, frameState) {\n  const instances = node.instances;\n  const count = instances.attributes[0].count;\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_INSTANCING\");\n  shaderBuilder.addVertexLines(InstancingStageCommon);\n\n  const model = renderResources.model;\n  const sceneGraph = model.sceneGraph;\n  const runtimeNode = renderResources.runtimeNode;\n\n  const use2D =\n    frameState.mode !== SceneMode.SCENE3D &&\n    !frameState.scene3DOnly &&\n    model._projectTo2D;\n  const keepTypedArray = model._enablePick && !frameState.context.webgl2;\n\n  const instancingVertexAttributes = [];\n\n  processTransformAttributes(\n    renderResources,\n    frameState,\n    instances,\n    instancingVertexAttributes,\n    use2D,\n    keepTypedArray,\n  );\n\n  processFeatureIdAttributes(\n    renderResources,\n    frameState,\n    instances,\n    instancingVertexAttributes,\n  );\n\n  const uniformMap = {};\n\n  if (instances.transformInWorldSpace) {\n    shaderBuilder.addDefine(\n      \"USE_LEGACY_INSTANCING\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addUniform(\n      \"mat4\",\n      \"u_instance_modifiedModelView\",\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addUniform(\n      \"mat4\",\n      \"u_instance_nodeTransform\",\n      ShaderDestination.VERTEX,\n    );\n\n    // The i3dm format applies the instancing transforms in world space.\n    // Instancing matrices come from a vertex attribute rather than a\n    // uniform, and they are multiplied in the middle of the modelView matrix\n    // product. This means czm_modelView can't be used. Instead, we split the\n    // matrix into two parts, modifiedModelView and nodeTransform, and handle\n    // this in LegacyInstancingStageVS.glsl. Conceptually the product looks like\n    // this:\n    //\n    // modelView = u_modifiedModelView * a_instanceTransform * u_nodeTransform\n    uniformMap.u_instance_modifiedModelView = function () {\n      // Model matrix without the node hierarchy or axis correction\n      // (see u_instance_nodeTransform).\n      let modifiedModelMatrix = Matrix4.multiplyTransformation(\n        // For 3D Tiles, model.modelMatrix is the computed tile\n        // transform (which includes tileset.modelMatrix). This always applies\n        // for i3dm, since such models are always part of a tileset.\n        model.modelMatrix,\n        // For i3dm models, components.transform contains the RTC_CENTER\n        // translation.\n        sceneGraph.components.transform,\n        modelViewScratch,\n      );\n\n      if (use2D) {\n        // If projectTo2D is enabled, the 2D view matrix\n        // will be accounted for in the u_modelView2D\n        // uniform.\n        //\n        // modifiedModelView = view3D * modifiedModel\n        return Matrix4.multiplyTransformation(\n          frameState.context.uniformState.view3D,\n          modifiedModelMatrix,\n          modelViewScratch,\n        );\n      }\n\n      // For projection to 2D without projectTo2D enabled,\n      // project the model matrix to 2D.\n      if (frameState.mode !== SceneMode.SCENE3D) {\n        modifiedModelMatrix = Transforms.basisTo2D(\n          frameState.mapProjection,\n          modifiedModelMatrix,\n          modelViewScratch,\n        );\n      }\n\n      // modifiedModelView = view * modifiedModel\n      return Matrix4.multiplyTransformation(\n        frameState.context.uniformState.view,\n        modifiedModelMatrix,\n        modelViewScratch,\n      );\n    };\n\n    uniformMap.u_instance_nodeTransform = function () {\n      // nodeTransform = axisCorrection * nodeHierarchyTransform\n      return Matrix4.multiplyTransformation(\n        // glTF y-up to 3D Tiles z-up\n        sceneGraph.axisCorrectionMatrix,\n        // This transforms from the node's coordinate system to the root\n        // of the node hierarchy\n        runtimeNode.computedTransform,\n        nodeTransformScratch,\n      );\n    };\n\n    shaderBuilder.addVertexLines(LegacyInstancingStageVS);\n  } else {\n    shaderBuilder.addVertexLines(InstancingStageVS);\n  }\n\n  if (use2D) {\n    shaderBuilder.addDefine(\n      \"USE_2D_INSTANCING\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n\n    shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n\n    const context = frameState.context;\n    const modelMatrix2D = Matrix4.fromTranslation(\n      runtimeNode.instancingReferencePoint2D,\n      new Matrix4(),\n    );\n\n    uniformMap.u_modelView2D = function () {\n      return Matrix4.multiplyTransformation(\n        context.uniformState.view,\n        modelMatrix2D,\n        modelView2DScratch,\n      );\n    };\n  }\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n\n  renderResources.instanceCount = count;\n  renderResources.attributes.push.apply(\n    renderResources.attributes,\n    instancingVertexAttributes,\n  );\n};\n\nconst projectedTransformScratch = new Matrix4();\nconst projectedPositionScratch = new Cartesian3();\n\nfunction projectTransformTo2D(\n  transform,\n  modelMatrix,\n  nodeTransform,\n  frameState,\n  result,\n) {\n  let projectedTransform = Matrix4.multiplyTransformation(\n    modelMatrix,\n    transform,\n    projectedTransformScratch,\n  );\n\n  projectedTransform = Matrix4.multiplyTransformation(\n    projectedTransform,\n    nodeTransform,\n    projectedTransformScratch,\n  );\n\n  result = Transforms.basisTo2D(\n    frameState.mapProjection,\n    projectedTransform,\n    result,\n  );\n\n  return result;\n}\n\nfunction projectPositionTo2D(\n  position,\n  modelMatrix,\n  nodeTransform,\n  frameState,\n  result,\n) {\n  const translationMatrix = Matrix4.fromTranslation(\n    position,\n    projectedTransformScratch,\n  );\n\n  let projectedTransform = Matrix4.multiplyTransformation(\n    modelMatrix,\n    translationMatrix,\n    projectedTransformScratch,\n  );\n\n  projectedTransform = Matrix4.multiplyTransformation(\n    projectedTransform,\n    nodeTransform,\n    projectedTransformScratch,\n  );\n\n  const finalPosition = Matrix4.getTranslation(\n    projectedTransform,\n    projectedPositionScratch,\n  );\n\n  result = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    finalPosition,\n    result,\n  );\n\n  return result;\n}\n\nfunction getModelMatrixAndNodeTransform(\n  renderResources,\n  modelMatrix,\n  nodeComputedTransform,\n) {\n  const model = renderResources.model;\n  const sceneGraph = model.sceneGraph;\n\n  const instances = renderResources.runtimeNode.node.instances;\n  if (instances.transformInWorldSpace) {\n    // Replicate the multiplication order in LegacyInstancingStageVS.\n    modelMatrix = Matrix4.multiplyTransformation(\n      model.modelMatrix,\n      sceneGraph.components.transform,\n      modelMatrix,\n    );\n\n    nodeComputedTransform = Matrix4.multiplyTransformation(\n      sceneGraph.axisCorrectionMatrix,\n      renderResources.runtimeNode.computedTransform,\n      nodeComputedTransform,\n    );\n  } else {\n    // The node transform should be pre-multiplied with the instancing transform.\n    modelMatrix = Matrix4.clone(sceneGraph.computedModelMatrix, modelMatrix);\n    modelMatrix = Matrix4.multiplyTransformation(\n      modelMatrix,\n      renderResources.runtimeNode.computedTransform,\n      modelMatrix,\n    );\n\n    nodeComputedTransform = Matrix4.clone(\n      Matrix4.IDENTITY,\n      nodeComputedTransform,\n    );\n  }\n}\n\nconst modelMatrixScratch = new Matrix4();\nconst nodeComputedTransformScratch = new Matrix4();\nconst transformScratch = new Matrix4();\nconst positionScratch = new Cartesian3();\n\nfunction projectTransformsTo2D(\n  transforms,\n  renderResources,\n  frameState,\n  result,\n) {\n  const modelMatrix = modelMatrixScratch;\n  const nodeComputedTransform = nodeComputedTransformScratch;\n\n  getModelMatrixAndNodeTransform(\n    renderResources,\n    modelMatrix,\n    nodeComputedTransform,\n  );\n\n  const runtimeNode = renderResources.runtimeNode;\n  const referencePoint = runtimeNode.instancingReferencePoint2D;\n\n  const count = transforms.length;\n  for (let i = 0; i < count; i++) {\n    const transform = transforms[i];\n\n    const projectedTransform = projectTransformTo2D(\n      transform,\n      modelMatrix,\n      nodeComputedTransform,\n      frameState,\n      transformScratch,\n    );\n\n    const position = Matrix4.getTranslation(\n      projectedTransform,\n      positionScratch,\n    );\n\n    const finalTranslation = Cartesian3.subtract(\n      position,\n      referencePoint,\n      position,\n    );\n\n    result[i] = Matrix4.setTranslation(\n      projectedTransform,\n      finalTranslation,\n      result[i],\n    );\n  }\n\n  return result;\n}\n\nfunction projectTranslationsTo2D(\n  translations,\n  renderResources,\n  frameState,\n  result,\n) {\n  const modelMatrix = modelMatrixScratch;\n  const nodeComputedTransform = nodeComputedTransformScratch;\n\n  getModelMatrixAndNodeTransform(\n    renderResources,\n    modelMatrix,\n    nodeComputedTransform,\n  );\n\n  const runtimeNode = renderResources.runtimeNode;\n  const referencePoint = runtimeNode.instancingReferencePoint2D;\n  const count = translations.length;\n  for (let i = 0; i < count; i++) {\n    const translation = translations[i];\n\n    const projectedPosition = projectPositionTo2D(\n      translation,\n      modelMatrix,\n      nodeComputedTransform,\n      frameState,\n      translation,\n    );\n\n    result[i] = Cartesian3.subtract(\n      projectedPosition,\n      referencePoint,\n      result[i],\n    );\n  }\n\n  return result;\n}\n\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\n\nfunction computeReferencePoint2D(renderResources, frameState) {\n  // Compute the reference point by averaging the instancing translation\n  // min / max values after they are projected to 2D.\n  const runtimeNode = renderResources.runtimeNode;\n  const modelMatrix = renderResources.model.sceneGraph.computedModelMatrix;\n  const transformedPositionMin = Matrix4.multiplyByPoint(\n    modelMatrix,\n    runtimeNode.instancingTranslationMin,\n    scratchProjectedMin,\n  );\n\n  const projectedMin = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMin,\n    transformedPositionMin,\n  );\n\n  const transformedPositionMax = Matrix4.multiplyByPoint(\n    modelMatrix,\n    runtimeNode.instancingTranslationMax,\n    scratchProjectedMax,\n  );\n\n  const projectedMax = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    transformedPositionMax,\n    transformedPositionMax,\n  );\n\n  runtimeNode.instancingReferencePoint2D = Cartesian3.lerp(\n    projectedMin,\n    projectedMax,\n    0.5,\n    new Cartesian3(),\n  );\n}\n\nfunction transformsToTypedArray(transforms) {\n  const elements = 12;\n  const count = transforms.length;\n  const transformsTypedArray = new Float32Array(count * elements);\n\n  for (let i = 0; i < count; i++) {\n    const transform = transforms[i];\n    const offset = elements * i;\n\n    transformsTypedArray[offset + 0] = transform[0];\n    transformsTypedArray[offset + 1] = transform[4];\n    transformsTypedArray[offset + 2] = transform[8];\n    transformsTypedArray[offset + 3] = transform[12];\n    transformsTypedArray[offset + 4] = transform[1];\n    transformsTypedArray[offset + 5] = transform[5];\n    transformsTypedArray[offset + 6] = transform[9];\n    transformsTypedArray[offset + 7] = transform[13];\n    transformsTypedArray[offset + 8] = transform[2];\n    transformsTypedArray[offset + 9] = transform[6];\n    transformsTypedArray[offset + 10] = transform[10];\n    transformsTypedArray[offset + 11] = transform[14];\n  }\n\n  return transformsTypedArray;\n}\n\nfunction translationsToTypedArray(translations) {\n  const elements = 3;\n  const count = translations.length;\n  const transationsTypedArray = new Float32Array(count * elements);\n\n  for (let i = 0; i < count; i++) {\n    const translation = translations[i];\n    const offset = elements * i;\n\n    transationsTypedArray[offset + 0] = translation[0];\n    transationsTypedArray[offset + 1] = translation[4];\n    transationsTypedArray[offset + 2] = translation[8];\n  }\n\n  return transationsTypedArray;\n}\n\nconst translationScratch = new Cartesian3();\nconst rotationScratch = new Quaternion();\nconst scaleScratch = new Cartesian3();\n\nfunction getInstanceTransformsAsMatrices(instances, count, renderResources) {\n  const transforms = new Array(count);\n\n  const translationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.TRANSLATION,\n  );\n  const rotationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.ROTATION,\n  );\n  const scaleAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.SCALE,\n  );\n\n  const instancingTranslationMax = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n  );\n  const instancingTranslationMin = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n  );\n\n  const hasTranslation = defined(translationAttribute);\n  const hasRotation = defined(rotationAttribute);\n  const hasScale = defined(scaleAttribute);\n\n  // Translations get initialized to (0, 0, 0).\n  const translationTypedArray = hasTranslation\n    ? translationAttribute.typedArray\n    : new Float32Array(count * 3);\n\n  // Rotations get initialized to (0, 0, 0, 0).\n  // The w-component is set to 1 in the loop below.\n  let rotationTypedArray = hasRotation\n    ? rotationAttribute.typedArray\n    : new Float32Array(count * 4);\n\n  // The rotation attribute may be normalized\n  if (hasRotation && rotationAttribute.normalized) {\n    rotationTypedArray = AttributeCompression.dequantize(\n      rotationTypedArray,\n      rotationAttribute.componentDatatype,\n      rotationAttribute.type,\n      count,\n    );\n  }\n\n  // Scales get initialized to (1, 1, 1).\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = scaleAttribute.typedArray;\n  } else {\n    scaleTypedArray = new Float32Array(count * 3);\n    scaleTypedArray.fill(1);\n  }\n\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(\n      translationTypedArray[i * 3],\n      translationTypedArray[i * 3 + 1],\n      translationTypedArray[i * 3 + 2],\n      translationScratch,\n    );\n\n    Cartesian3.maximumByComponent(\n      instancingTranslationMax,\n      translation,\n      instancingTranslationMax,\n    );\n    Cartesian3.minimumByComponent(\n      instancingTranslationMin,\n      translation,\n      instancingTranslationMin,\n    );\n\n    const rotation = new Quaternion(\n      rotationTypedArray[i * 4],\n      rotationTypedArray[i * 4 + 1],\n      rotationTypedArray[i * 4 + 2],\n      hasRotation ? rotationTypedArray[i * 4 + 3] : 1,\n      rotationScratch,\n    );\n\n    const scale = new Cartesian3(\n      scaleTypedArray[i * 3],\n      scaleTypedArray[i * 3 + 1],\n      scaleTypedArray[i * 3 + 2],\n      scaleScratch,\n    );\n\n    const transform = Matrix4.fromTranslationQuaternionRotationScale(\n      translation,\n      rotation,\n      scale,\n      new Matrix4(),\n    );\n\n    transforms[i] = transform;\n  }\n\n  const runtimeNode = renderResources.runtimeNode;\n  runtimeNode.instancingTranslationMin = instancingTranslationMin;\n  runtimeNode.instancingTranslationMax = instancingTranslationMax;\n\n  // Unload the typed arrays. These are just pointers to the arrays\n  // in the vertex buffer loader.\n  if (hasTranslation) {\n    translationAttribute.typedArray = undefined;\n  }\n  if (hasRotation) {\n    rotationAttribute.typedArray = undefined;\n  }\n  if (hasScale) {\n    scaleAttribute.typedArray = undefined;\n  }\n\n  return transforms;\n}\n\nfunction getInstanceTranslationsAsCartesian3s(\n  translationAttribute,\n  count,\n  renderResources,\n) {\n  const instancingTranslations = new Array(count);\n  const translationTypedArray = translationAttribute.typedArray;\n\n  const instancingTranslationMin = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n  );\n  const instancingTranslationMax = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n  );\n\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(\n      translationTypedArray[i * 3],\n      translationTypedArray[i * 3 + 1],\n      translationTypedArray[i * 3 + 2],\n    );\n\n    instancingTranslations[i] = translation;\n\n    Cartesian3.minimumByComponent(\n      instancingTranslationMin,\n      translation,\n      instancingTranslationMin,\n    );\n    Cartesian3.maximumByComponent(\n      instancingTranslationMax,\n      translation,\n      instancingTranslationMax,\n    );\n  }\n\n  const runtimeNode = renderResources.runtimeNode;\n  runtimeNode.instancingTranslationMin = instancingTranslationMin;\n  runtimeNode.instancingTranslationMax = instancingTranslationMax;\n\n  // Unload the typed array. This is just a pointer to the array\n  // in the vertex buffer loader.\n  translationAttribute.typedArray = undefined;\n\n  return instancingTranslations;\n}\n\nfunction createVertexBuffer(typedArray, frameState) {\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n\n  // Destruction of resources allocated by the Model\n  // is handled by Model.destroy().\n  buffer.vertexArrayDestroyable = false;\n\n  return buffer;\n}\n\nfunction processTransformAttributes(\n  renderResources,\n  frameState,\n  instances,\n  instancingVertexAttributes,\n  use2D,\n  keepTypedArray,\n) {\n  const rotationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.ROTATION,\n  );\n\n  // Only use matrices for the transforms if the rotation attribute is defined.\n  if (defined(rotationAttribute)) {\n    processTransformMatrixAttributes(\n      renderResources,\n      instances,\n      instancingVertexAttributes,\n      frameState,\n      use2D,\n      keepTypedArray,\n    );\n  } else {\n    processTransformVec3Attributes(\n      renderResources,\n      instances,\n      instancingVertexAttributes,\n      frameState,\n      use2D,\n    );\n  }\n}\n\nfunction processTransformMatrixAttributes(\n  renderResources,\n  instances,\n  instancingVertexAttributes,\n  frameState,\n  use2D,\n  keepTypedArray,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const count = instances.attributes[0].count;\n\n  const model = renderResources.model;\n  const runtimeNode = renderResources.runtimeNode;\n\n  shaderBuilder.addDefine(\"HAS_INSTANCE_MATRICES\");\n  const attributeString = \"Transform\";\n\n  let transforms;\n  let buffer = runtimeNode.instancingTransformsBuffer;\n  if (!defined(buffer)) {\n    // This function computes the transforms, sets the translation min / max,\n    // and unloads the typed arrays associated with the attributes.\n    transforms = getInstanceTransformsAsMatrices(\n      instances,\n      count,\n      renderResources,\n    );\n\n    const transformsTypedArray = transformsToTypedArray(transforms);\n    buffer = createVertexBuffer(transformsTypedArray, frameState);\n    model._modelResources.push(buffer);\n\n    if (keepTypedArray) {\n      runtimeNode.transformsTypedArray = transformsTypedArray;\n    }\n\n    runtimeNode.instancingTransformsBuffer = buffer;\n  }\n\n  processMatrixAttributes(\n    renderResources,\n    buffer,\n    instancingVertexAttributes,\n    attributeString,\n  );\n\n  if (!use2D) {\n    return;\n  }\n\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the instanced\n  // translation bounds projected to 2D.\n  computeReferencePoint2D(renderResources, frameStateCV);\n\n  let buffer2D = runtimeNode.instancingTransformsBuffer2D;\n  if (!defined(buffer2D)) {\n    const projectedTransforms = projectTransformsTo2D(\n      transforms,\n      renderResources,\n      frameStateCV,\n      transforms,\n    );\n    const projectedTypedArray = transformsToTypedArray(projectedTransforms);\n\n    // This memory is counted during the statistics stage at the end\n    // of the pipeline.\n    buffer2D = createVertexBuffer(projectedTypedArray, frameState);\n    model._modelResources.push(buffer2D);\n\n    runtimeNode.instancingTransformsBuffer2D = buffer2D;\n  }\n\n  const attributeString2D = \"Transform2D\";\n  processMatrixAttributes(\n    renderResources,\n    buffer2D,\n    instancingVertexAttributes,\n    attributeString2D,\n  );\n}\n\nfunction processTransformVec3Attributes(\n  renderResources,\n  instances,\n  instancingVertexAttributes,\n  frameState,\n  use2D,\n  keepTypedArray,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const runtimeNode = renderResources.runtimeNode;\n  const translationAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.TRANSLATION,\n  );\n  const scaleAttribute = ModelUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.SCALE,\n  );\n\n  if (defined(scaleAttribute)) {\n    shaderBuilder.addDefine(\"HAS_INSTANCE_SCALE\");\n    const attributeString = \"Scale\";\n\n    // Instanced scale attributes are loaded as buffers only.\n    processVec3Attribute(\n      renderResources,\n      scaleAttribute.buffer,\n      scaleAttribute.byteOffset,\n      scaleAttribute.byteStride,\n      instancingVertexAttributes,\n      attributeString,\n    );\n  }\n\n  if (!defined(translationAttribute)) {\n    return;\n  }\n\n  let instancingTranslations;\n  const typedArray = translationAttribute.typedArray;\n  if (defined(typedArray)) {\n    // This function computes and set the translation min / max, and unloads\n    // the typed array associated with the attribute.\n    // The translations are also returned in case they're used for 2D projection.\n    instancingTranslations = getInstanceTranslationsAsCartesian3s(\n      translationAttribute,\n      translationAttribute.count,\n      renderResources,\n    );\n  } else if (!defined(runtimeNode.instancingTranslationMin)) {\n    runtimeNode.instancingTranslationMin = translationAttribute.min;\n    runtimeNode.instancingTranslationMax = translationAttribute.max;\n  }\n\n  shaderBuilder.addDefine(\"HAS_INSTANCE_TRANSLATION\");\n  const attributeString = \"Translation\";\n\n  processVec3Attribute(\n    renderResources,\n    translationAttribute.buffer,\n    translationAttribute.byteOffset,\n    translationAttribute.byteStride,\n    instancingVertexAttributes,\n    attributeString,\n  );\n\n  if (!use2D && !keepTypedArray) {\n    return;\n  }\n\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the instanced\n  // translation bounds projected to 2D.\n  computeReferencePoint2D(renderResources, frameStateCV);\n\n  let buffer2D = runtimeNode.instancingTranslationBuffer2D;\n\n  if (!defined(buffer2D)) {\n    const projectedTranslations = projectTranslationsTo2D(\n      instancingTranslations,\n      renderResources,\n      frameStateCV,\n      instancingTranslations,\n    );\n    const projectedTypedArray = translationsToTypedArray(projectedTranslations);\n\n    if (keepTypedArray) {\n      runtimeNode.transformsTypedArray = projectedTypedArray;\n    }\n\n    // This memory is counted during the statistics stage at the end\n    // of the pipeline.\n    buffer2D = createVertexBuffer(projectedTypedArray, frameState);\n    renderResources.model._modelResources.push(buffer2D);\n\n    runtimeNode.instancingTranslationBuffer2D = buffer2D;\n  }\n\n  if (!use2D) {\n    return;\n  }\n\n  const byteOffset = 0;\n  const byteStride = undefined;\n\n  const attributeString2D = \"Translation2D\";\n  processVec3Attribute(\n    renderResources,\n    buffer2D,\n    byteOffset,\n    byteStride,\n    instancingVertexAttributes,\n    attributeString2D,\n  );\n}\n\nfunction processMatrixAttributes(\n  renderResources,\n  buffer,\n  instancingVertexAttributes,\n  attributeString,\n) {\n  const vertexSizeInFloats = 12;\n  const componentByteSize = ComponentDatatype.getSizeInBytes(\n    ComponentDatatype.FLOAT,\n  );\n  const strideInBytes = componentByteSize * vertexSizeInFloats;\n\n  const matrixAttributes = [\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: buffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: buffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: componentByteSize * 4,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: buffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: componentByteSize * 8,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n  ];\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row0`);\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row1`);\n  shaderBuilder.addAttribute(\"vec4\", `a_instancing${attributeString}Row2`);\n\n  instancingVertexAttributes.push.apply(\n    instancingVertexAttributes,\n    matrixAttributes,\n  );\n}\n\nfunction processVec3Attribute(\n  renderResources,\n  buffer,\n  byteOffset,\n  byteStride,\n  instancingVertexAttributes,\n  attributeString,\n) {\n  instancingVertexAttributes.push({\n    index: renderResources.attributeIndex++,\n    vertexBuffer: buffer,\n    componentsPerAttribute: 3,\n    componentDatatype: ComponentDatatype.FLOAT,\n    normalize: false,\n    offsetInBytes: byteOffset,\n    strideInBytes: byteStride,\n    instanceDivisor: 1,\n  });\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addAttribute(\"vec3\", `a_instance${attributeString}`);\n}\n\nfunction processFeatureIdAttributes(\n  renderResources,\n  frameState,\n  instances,\n  instancingVertexAttributes,\n) {\n  const attributes = instances.attributes;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic !== InstanceAttributeSemantic.FEATURE_ID) {\n      continue;\n    }\n\n    if (\n      attribute.setIndex >= renderResources.featureIdVertexAttributeSetIndex\n    ) {\n      renderResources.featureIdVertexAttributeSetIndex = attribute.setIndex + 1;\n    }\n\n    instancingVertexAttributes.push({\n      index: renderResources.attributeIndex++,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: AttributeType.getNumberOfComponents(\n        attribute.type,\n      ),\n      componentDatatype: attribute.componentDatatype,\n      normalize: false,\n      offsetInBytes: attribute.byteOffset,\n      strideInBytes: attribute.byteStride,\n      instanceDivisor: 1,\n    });\n\n    shaderBuilder.addAttribute(\n      \"float\",\n      `a_instanceFeatureId_${attribute.setIndex}`,\n    );\n  }\n}\n\nexport default InstancingPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}