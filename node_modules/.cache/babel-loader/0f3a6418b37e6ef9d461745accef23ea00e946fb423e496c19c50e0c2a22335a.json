{"ast":null,"code":"import addPipelineExtras from \"./addPipelineExtras.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport getMagic from \"../../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nconst sizeOfUint32 = 4;\n\n/**\n * Convert a binary glTF to glTF.\n *\n * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n *\n * @param {Buffer} glb The glb data to parse.\n * @returns {object} A javascript object containing a glTF asset with pipeline extras included.\n *\n * @private\n */\nfunction parseGlb(glb) {\n  // Check that the magic string is present\n  const magic = getMagic(glb);\n  if (magic !== \"glTF\") {\n    throw new RuntimeError(\"File is not valid binary glTF\");\n  }\n  const header = readHeader(glb, 0, 5);\n  const version = header[1];\n  if (version !== 1 && version !== 2) {\n    throw new RuntimeError(\"Binary glTF version is not 1 or 2\");\n  }\n  if (version === 1) {\n    return parseGlbVersion1(glb, header);\n  }\n  return parseGlbVersion2(glb, header);\n}\nfunction readHeader(glb, byteOffset, count) {\n  const dataView = new DataView(glb.buffer);\n  const header = new Array(count);\n  for (let i = 0; i < count; ++i) {\n    header[i] = dataView.getUint32(glb.byteOffset + byteOffset + i * sizeOfUint32, true);\n  }\n  return header;\n}\nfunction parseGlbVersion1(glb, header) {\n  const length = header[2];\n  const contentLength = header[3];\n  const contentFormat = header[4];\n\n  // Check that the content format is 0, indicating that it is JSON\n  if (contentFormat !== 0) {\n    throw new RuntimeError(\"Binary glTF scene format is not JSON\");\n  }\n  const jsonStart = 20;\n  const binaryStart = jsonStart + contentLength;\n  const contentString = getStringFromTypedArray(glb, jsonStart, contentLength);\n  const gltf = JSON.parse(contentString);\n  addPipelineExtras(gltf);\n  const binaryBuffer = glb.subarray(binaryStart, length);\n  const buffers = gltf.buffers;\n  if (defined(buffers) && Object.keys(buffers).length > 0) {\n    // In some older models, the binary glTF buffer is named KHR_binary_glTF\n    const binaryGltfBuffer = defaultValue(buffers.binary_glTF, buffers.KHR_binary_glTF);\n    if (defined(binaryGltfBuffer)) {\n      binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n      delete binaryGltfBuffer.uri;\n    }\n  }\n  // Remove the KHR_binary_glTF extension\n  removeExtensionsUsed(gltf, \"KHR_binary_glTF\");\n  return gltf;\n}\nfunction parseGlbVersion2(glb, header) {\n  const length = header[2];\n  let byteOffset = 12;\n  let gltf;\n  let binaryBuffer;\n  while (byteOffset < length) {\n    const chunkHeader = readHeader(glb, byteOffset, 2);\n    const chunkLength = chunkHeader[0];\n    const chunkType = chunkHeader[1];\n    byteOffset += 8;\n    const chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n    byteOffset += chunkLength;\n    // Load JSON chunk\n    if (chunkType === 0x4e4f534a) {\n      const jsonString = getStringFromTypedArray(chunkBuffer);\n      gltf = JSON.parse(jsonString);\n      addPipelineExtras(gltf);\n    }\n    // Load Binary chunk\n    else if (chunkType === 0x004e4942) {\n      binaryBuffer = chunkBuffer;\n    }\n  }\n  if (defined(gltf) && defined(binaryBuffer)) {\n    const buffers = gltf.buffers;\n    if (defined(buffers) && buffers.length > 0) {\n      const buffer = buffers[0];\n      buffer.extras._pipeline.source = binaryBuffer;\n    }\n  }\n  return gltf;\n}\nexport default parseGlb;","map":{"version":3,"names":["addPipelineExtras","removeExtensionsUsed","defaultValue","defined","getMagic","getStringFromTypedArray","RuntimeError","sizeOfUint32","parseGlb","glb","magic","header","readHeader","version","parseGlbVersion1","parseGlbVersion2","byteOffset","count","dataView","DataView","buffer","Array","i","getUint32","length","contentLength","contentFormat","jsonStart","binaryStart","contentString","gltf","JSON","parse","binaryBuffer","subarray","buffers","Object","keys","binaryGltfBuffer","binary_glTF","KHR_binary_glTF","extras","_pipeline","source","uri","chunkHeader","chunkLength","chunkType","chunkBuffer","jsonString"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfPipeline/parseGlb.js"],"sourcesContent":["import addPipelineExtras from \"./addPipelineExtras.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport getMagic from \"../../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\n\nconst sizeOfUint32 = 4;\n\n/**\n * Convert a binary glTF to glTF.\n *\n * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n *\n * @param {Buffer} glb The glb data to parse.\n * @returns {object} A javascript object containing a glTF asset with pipeline extras included.\n *\n * @private\n */\nfunction parseGlb(glb) {\n  // Check that the magic string is present\n  const magic = getMagic(glb);\n  if (magic !== \"glTF\") {\n    throw new RuntimeError(\"File is not valid binary glTF\");\n  }\n\n  const header = readHeader(glb, 0, 5);\n  const version = header[1];\n  if (version !== 1 && version !== 2) {\n    throw new RuntimeError(\"Binary glTF version is not 1 or 2\");\n  }\n\n  if (version === 1) {\n    return parseGlbVersion1(glb, header);\n  }\n\n  return parseGlbVersion2(glb, header);\n}\n\nfunction readHeader(glb, byteOffset, count) {\n  const dataView = new DataView(glb.buffer);\n  const header = new Array(count);\n  for (let i = 0; i < count; ++i) {\n    header[i] = dataView.getUint32(\n      glb.byteOffset + byteOffset + i * sizeOfUint32,\n      true\n    );\n  }\n  return header;\n}\n\nfunction parseGlbVersion1(glb, header) {\n  const length = header[2];\n  const contentLength = header[3];\n  const contentFormat = header[4];\n\n  // Check that the content format is 0, indicating that it is JSON\n  if (contentFormat !== 0) {\n    throw new RuntimeError(\"Binary glTF scene format is not JSON\");\n  }\n\n  const jsonStart = 20;\n  const binaryStart = jsonStart + contentLength;\n\n  const contentString = getStringFromTypedArray(glb, jsonStart, contentLength);\n  const gltf = JSON.parse(contentString);\n  addPipelineExtras(gltf);\n\n  const binaryBuffer = glb.subarray(binaryStart, length);\n\n  const buffers = gltf.buffers;\n  if (defined(buffers) && Object.keys(buffers).length > 0) {\n    // In some older models, the binary glTF buffer is named KHR_binary_glTF\n    const binaryGltfBuffer = defaultValue(\n      buffers.binary_glTF,\n      buffers.KHR_binary_glTF\n    );\n    if (defined(binaryGltfBuffer)) {\n      binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n      delete binaryGltfBuffer.uri;\n    }\n  }\n  // Remove the KHR_binary_glTF extension\n  removeExtensionsUsed(gltf, \"KHR_binary_glTF\");\n  return gltf;\n}\n\nfunction parseGlbVersion2(glb, header) {\n  const length = header[2];\n  let byteOffset = 12;\n  let gltf;\n  let binaryBuffer;\n  while (byteOffset < length) {\n    const chunkHeader = readHeader(glb, byteOffset, 2);\n    const chunkLength = chunkHeader[0];\n    const chunkType = chunkHeader[1];\n    byteOffset += 8;\n    const chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n    byteOffset += chunkLength;\n    // Load JSON chunk\n    if (chunkType === 0x4e4f534a) {\n      const jsonString = getStringFromTypedArray(chunkBuffer);\n      gltf = JSON.parse(jsonString);\n      addPipelineExtras(gltf);\n    }\n    // Load Binary chunk\n    else if (chunkType === 0x004e4942) {\n      binaryBuffer = chunkBuffer;\n    }\n  }\n  if (defined(gltf) && defined(binaryBuffer)) {\n    const buffers = gltf.buffers;\n    if (defined(buffers) && buffers.length > 0) {\n      const buffer = buffers[0];\n      buffer.extras._pipeline.source = binaryBuffer;\n    }\n  }\n  return gltf;\n}\n\nexport default parseGlb;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}