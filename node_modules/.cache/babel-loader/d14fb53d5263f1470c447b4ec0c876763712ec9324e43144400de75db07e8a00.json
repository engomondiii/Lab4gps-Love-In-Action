{"ast":null,"code":"import clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\n\n/**\n * An appearance defines the full GLSL vertex and fragment shaders and the\n * render state used to draw a {@link Primitive}.  All appearances implement\n * this base <code>Appearance</code> interface.\n *\n * @alias Appearance\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.\n * @param {boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {string} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {string} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {object} [options.renderState] Optional render state to override the default render state.\n *\n * @see MaterialAppearance\n * @see EllipsoidSurfaceAppearance\n * @see PerInstanceColorAppearance\n * @see DebugAppearance\n * @see PolylineColorAppearance\n * @see PolylineMaterialAppearance\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n */\nfunction Appearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link Appearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = options.material;\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.translucent = defaultValue(options.translucent, true);\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._renderState = options.renderState;\n  this._closed = defaultValue(options.closed, false);\n}\nObject.defineProperties(Appearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    }\n  },\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account the {@link Appearance#material}.\n   * Use {@link Appearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    }\n  },\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    }\n  },\n  /**\n   * When <code>true</code>, the geometry is expected to be closed.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    }\n  }\n});\n\n/**\n * Procedurally creates the full GLSL fragment shader source for this appearance\n * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.\n *\n * @returns {string} The full GLSL fragment shader source.\n */\nAppearance.prototype.getFragmentShaderSource = function () {\n  const parts = [];\n  if (this.flat) {\n    parts.push(\"#define FLAT\");\n  }\n  if (this.faceForward) {\n    parts.push(\"#define FACE_FORWARD\");\n  }\n  if (defined(this.material)) {\n    parts.push(this.material.shaderSource);\n  }\n  parts.push(this.fragmentShaderSource);\n  return parts.join(\"\\n\");\n};\n\n/**\n * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.\n *\n * @returns {boolean} <code>true</code> if the appearance is translucent.\n */\nAppearance.prototype.isTranslucent = function () {\n  return defined(this.material) && this.material.isTranslucent() || !defined(this.material) && this.translucent;\n};\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @returns {object} The render state.\n */\nAppearance.prototype.getRenderState = function () {\n  const translucent = this.isTranslucent();\n  const rs = clone(this.renderState, false);\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  } else {\n    rs.depthMask = true;\n  }\n  return rs;\n};\n\n/**\n * @private\n */\nAppearance.getDefaultRenderState = function (translucent, closed, existing) {\n  let rs = {\n    depthTest: {\n      enabled: true\n    }\n  };\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  }\n  if (closed) {\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK\n    };\n  }\n  if (defined(existing)) {\n    rs = combine(existing, rs, true);\n  }\n  return rs;\n};\nexport default Appearance;","map":{"version":3,"names":["clone","combine","defaultValue","defined","BlendingState","CullFace","Appearance","options","EMPTY_OBJECT","material","translucent","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","renderState","_closed","closed","Object","defineProperties","prototype","get","getFragmentShaderSource","parts","flat","push","faceForward","shaderSource","join","isTranslucent","getRenderState","rs","depthMask","blending","ALPHA_BLEND","getDefaultRenderState","existing","depthTest","enabled","cull","face","BACK"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Appearance.js"],"sourcesContent":["import clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\n\n/**\n * An appearance defines the full GLSL vertex and fragment shaders and the\n * render state used to draw a {@link Primitive}.  All appearances implement\n * this base <code>Appearance</code> interface.\n *\n * @alias Appearance\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.\n * @param {boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {string} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {string} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {object} [options.renderState] Optional render state to override the default render state.\n *\n * @see MaterialAppearance\n * @see EllipsoidSurfaceAppearance\n * @see PerInstanceColorAppearance\n * @see DebugAppearance\n * @see PolylineColorAppearance\n * @see PolylineMaterialAppearance\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n */\nfunction Appearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link Appearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = options.material;\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.translucent = defaultValue(options.translucent, true);\n\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._renderState = options.renderState;\n  this._closed = defaultValue(options.closed, false);\n}\n\nObject.defineProperties(Appearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account the {@link Appearance#material}.\n   * Use {@link Appearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n});\n\n/**\n * Procedurally creates the full GLSL fragment shader source for this appearance\n * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.\n *\n * @returns {string} The full GLSL fragment shader source.\n */\nAppearance.prototype.getFragmentShaderSource = function () {\n  const parts = [];\n  if (this.flat) {\n    parts.push(\"#define FLAT\");\n  }\n  if (this.faceForward) {\n    parts.push(\"#define FACE_FORWARD\");\n  }\n  if (defined(this.material)) {\n    parts.push(this.material.shaderSource);\n  }\n  parts.push(this.fragmentShaderSource);\n\n  return parts.join(\"\\n\");\n};\n\n/**\n * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.\n *\n * @returns {boolean} <code>true</code> if the appearance is translucent.\n */\nAppearance.prototype.isTranslucent = function () {\n  return (\n    (defined(this.material) && this.material.isTranslucent()) ||\n    (!defined(this.material) && this.translucent)\n  );\n};\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @returns {object} The render state.\n */\nAppearance.prototype.getRenderState = function () {\n  const translucent = this.isTranslucent();\n  const rs = clone(this.renderState, false);\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  } else {\n    rs.depthMask = true;\n  }\n  return rs;\n};\n\n/**\n * @private\n */\nAppearance.getDefaultRenderState = function (translucent, closed, existing) {\n  let rs = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  if (closed) {\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n  }\n\n  if (defined(existing)) {\n    rs = combine(existing, rs, true);\n  }\n\n  return rs;\n};\nexport default Appearance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}