{"ast":null,"code":"import Matrix3 from \"../../Core/Matrix3.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MetadataStageFS from \"../../Shaders/Model/MetadataStageFS.js\";\nimport MetadataStageVS from \"../../Shaders/Model/MetadataStageVS.js\";\nimport MetadataType from \"../MetadataType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The metadata pipeline stage processes metadata properties from\n * EXT_structural_metadata and inserts them into a struct in the shader.\n * This struct will be used by {@link CustomShaderPipelineStage} to allow the\n * user to access metadata using {@link CustomShader}\n *\n * @namespace MetadataPipelineStage\n *\n * @private\n */\nconst MetadataPipelineStage = {\n  name: \"MetadataPipelineStage\",\n  STRUCT_ID_METADATA_VS: \"MetadataVS\",\n  STRUCT_ID_METADATA_FS: \"MetadataFS\",\n  STRUCT_NAME_METADATA: \"Metadata\",\n  STRUCT_ID_METADATA_CLASS_VS: \"MetadataClassVS\",\n  STRUCT_ID_METADATA_CLASS_FS: \"MetadataClassFS\",\n  STRUCT_NAME_METADATA_CLASS: \"MetadataClass\",\n  STRUCT_ID_METADATA_STATISTICS_VS: \"MetadataStatisticsVS\",\n  STRUCT_ID_METADATA_STATISTICS_FS: \"MetadataStatisticsFS\",\n  STRUCT_NAME_METADATA_STATISTICS: \"MetadataStatistics\",\n  FUNCTION_ID_INITIALIZE_METADATA_VS: \"initializeMetadataVS\",\n  FUNCTION_ID_INITIALIZE_METADATA_FS: \"initializeMetadataFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_METADATA: \"void initializeMetadata(out Metadata metadata, out MetadataClass metadataClass, out MetadataStatistics metadataStatistics, ProcessedAttributes attributes)\",\n  FUNCTION_ID_SET_METADATA_VARYINGS: \"setMetadataVaryings\",\n  FUNCTION_SIGNATURE_SET_METADATA_VARYINGS: \"void setMetadataVaryings()\",\n  // Metadata class and statistics fields:\n  // - some must be renamed to avoid reserved words\n  // - some always have float/vec values, even for integer/ivec property types\n  METADATA_CLASS_FIELDS: [{\n    specName: \"noData\",\n    shaderName: \"noData\"\n  }, {\n    specName: \"default\",\n    shaderName: \"defaultValue\"\n  }, {\n    specName: \"min\",\n    shaderName: \"minValue\"\n  }, {\n    specName: \"max\",\n    shaderName: \"maxValue\"\n  }],\n  METADATA_STATISTICS_FIELDS: [{\n    specName: \"min\",\n    shaderName: \"minValue\"\n  }, {\n    specName: \"max\",\n    shaderName: \"maxValue\"\n  }, {\n    specName: \"mean\",\n    shaderName: \"mean\",\n    type: \"float\"\n  }, {\n    specName: \"median\",\n    shaderName: \"median\"\n  }, {\n    specName: \"standardDeviation\",\n    shaderName: \"standardDeviation\",\n    type: \"float\"\n  }, {\n    specName: \"variance\",\n    shaderName: \"variance\",\n    type: \"float\"\n  }, {\n    specName: \"sum\",\n    shaderName: \"sum\"\n  }]\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Adds a Metadata struct to the shader</li>\n *   <li>If the primitive has structural metadata, properties are added to the Metadata struct</li>\n *   <li>dynamic functions are added to the shader to initialize the metadata properties</li>\n *   <li>Adds uniforms for property textures to the uniform map as needed</li>\n *   <li>Adds uniforms for offset/scale to the uniform map as needed</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state\n * @private\n */\nMetadataPipelineStage.process = function (renderResources, primitive, frameState) {\n  const {\n    shaderBuilder,\n    model\n  } = renderResources;\n  const {\n    structuralMetadata = {},\n    content\n  } = model;\n  const statistics = content?.tileset.metadataExtension?.statistics;\n  const propertyAttributesInfo = getPropertyAttributesInfo(structuralMetadata.propertyAttributes, primitive, statistics);\n  const propertyTexturesInfo = getPropertyTexturesInfo(structuralMetadata.propertyTextures, statistics);\n\n  // Declare <type>MetadataClass and <type>MetadataStatistics structs as needed\n  const allPropertyInfos = propertyAttributesInfo.concat(propertyTexturesInfo);\n  declareMetadataTypeStructs(shaderBuilder, allPropertyInfos);\n\n  // Always declare the Metadata, MetadataClass, and MetadataStatistics structs\n  // and the initializeMetadata() function, even if not used\n  declareStructsAndFunctions(shaderBuilder);\n  shaderBuilder.addVertexLines(MetadataStageVS);\n  shaderBuilder.addFragmentLines(MetadataStageFS);\n  for (let i = 0; i < propertyAttributesInfo.length; i++) {\n    const info = propertyAttributesInfo[i];\n    processPropertyAttributeProperty(renderResources, info);\n  }\n  for (let i = 0; i < propertyTexturesInfo.length; i++) {\n    const info = propertyTexturesInfo[i];\n    processPropertyTextureProperty(renderResources, info);\n  }\n};\n\n/**\n * Collect info about all properties of all propertyAttributes, and\n * return as a flattened Array\n * @param {PropertyAttribute[]} propertyAttributes The PropertyAttributes with properties to be described\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyAttributeProperty\n * @private\n */\nfunction getPropertyAttributesInfo(propertyAttributes, primitive, statistics) {\n  if (!defined(propertyAttributes)) {\n    return [];\n  }\n  return propertyAttributes.flatMap(propertyAttribute => getPropertyAttributeInfo(propertyAttribute, primitive, statistics));\n}\n\n/**\n * Collect info about the properties of a single PropertyAttribute\n * @param {PropertyAttribute} propertyAttribute The PropertyAttribute with properties to be described\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyAttributeProperty\n * @private\n */\nfunction getPropertyAttributeInfo(propertyAttribute, primitive, statistics) {\n  const {\n    getAttributeByName,\n    getAttributeInfo,\n    sanitizeGlslIdentifier\n  } = ModelUtility;\n  const classId = propertyAttribute.class.id;\n  const classStatistics = statistics?.classes[classId];\n  const propertiesArray = Object.entries(propertyAttribute.properties);\n  const infoArray = new Array(propertiesArray.length);\n  for (let i = 0; i < propertiesArray.length; i++) {\n    const [propertyId, property] = propertiesArray[i];\n    const modelAttribute = getAttributeByName(primitive, property.attribute);\n    const {\n      glslType,\n      variableName\n    } = getAttributeInfo(modelAttribute);\n    infoArray[i] = {\n      metadataVariable: sanitizeGlslIdentifier(propertyId),\n      property,\n      type: property.classProperty.type,\n      glslType,\n      variableName,\n      propertyStatistics: classStatistics?.properties[propertyId],\n      shaderDestination: ShaderDestination.BOTH\n    };\n  }\n  return infoArray;\n}\n\n/**\n * Collect info about all properties of all propertyTextures, and\n * return as a flattened Array\n * @param {PropertyTexture[]} propertyTextures The PropertyTextures with properties to be described\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyTextureProperty\n * @private\n */\nfunction getPropertyTexturesInfo(propertyTextures, statistics) {\n  if (!defined(propertyTextures)) {\n    return [];\n  }\n  return propertyTextures.flatMap(propertyTexture => getPropertyTextureInfo(propertyTexture, statistics));\n}\n\n/**\n * Collect info about the properties of a single PropertyTexture\n * @param {PropertyTexture} propertyTexture The PropertyTexture with properties to be described\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyTextureProperty\n * @private\n */\nfunction getPropertyTextureInfo(propertyTexture, statistics) {\n  const {\n    sanitizeGlslIdentifier\n  } = ModelUtility;\n  const classId = propertyTexture.class.id;\n  const classStatistics = statistics?.classes[classId];\n  const propertiesArray = Object.entries(propertyTexture.properties).filter(([id, property]) => property.isGpuCompatible());\n  const infoArray = new Array(propertiesArray.length);\n  for (let i = 0; i < propertiesArray.length; i++) {\n    const [propertyId, property] = propertiesArray[i];\n    infoArray[i] = {\n      metadataVariable: sanitizeGlslIdentifier(propertyId),\n      property,\n      type: property.classProperty.type,\n      glslType: property.getGlslType(),\n      propertyStatistics: classStatistics?.properties[propertyId],\n      shaderDestination: ShaderDestination.FRAGMENT\n    };\n  }\n  return infoArray;\n}\n\n/**\n * Declare <type>MetadataClass structs in the shader for each PropertyAttributeProperty and PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {Object[]} propertyInfos Information about the PropertyAttributeProperties and PropertyTextureProperties\n * @private\n */\nfunction declareMetadataTypeStructs(shaderBuilder, propertyInfos) {\n  const classTypes = new Set();\n  const statisticsTypes = new Set();\n  for (let i = 0; i < propertyInfos.length; i++) {\n    const {\n      type,\n      glslType,\n      propertyStatistics\n    } = propertyInfos[i];\n    classTypes.add(glslType);\n    if (!defined(propertyStatistics)) {\n      continue;\n    }\n    if (type !== MetadataType.ENUM) {\n      statisticsTypes.add(glslType);\n    }\n  }\n  const classFields = MetadataPipelineStage.METADATA_CLASS_FIELDS;\n  for (const metadataType of classTypes) {\n    const classStructName = `${metadataType}MetadataClass`;\n    declareTypeStruct(classStructName, metadataType, classFields);\n  }\n  const statisticsFields = MetadataPipelineStage.METADATA_STATISTICS_FIELDS;\n  for (const metadataType of statisticsTypes) {\n    const statisticsStructName = `${metadataType}MetadataStatistics`;\n    declareTypeStruct(statisticsStructName, metadataType, statisticsFields);\n  }\n  function declareTypeStruct(structName, type, fields) {\n    shaderBuilder.addStruct(structName, structName, ShaderDestination.BOTH);\n    for (let i = 0; i < fields.length; i++) {\n      const {\n        shaderName\n      } = fields[i];\n      const shaderType = fields[i].type === \"float\" ? convertToFloatComponents(type) : type;\n      shaderBuilder.addStructField(structName, shaderType, shaderName);\n    }\n  }\n}\nconst floatConversions = {\n  int: \"float\",\n  ivec2: \"vec2\",\n  ivec3: \"vec3\",\n  ivec4: \"vec4\"\n};\n\n/**\n * For a type with integer components, find a corresponding float-component type\n * @param {string} type The name of a GLSL type with integer components\n * @returns {string} The name of a GLSL type of the same dimension with float components, if available; otherwise the input type\n * @private\n */\nfunction convertToFloatComponents(type) {\n  const converted = floatConversions[type];\n  return defined(converted) ? converted : type;\n}\n\n/**\n * Declare the main Metadata, MetadataClass, and MetadataStatistics structs\n * and the initializeMetadata() function.\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @private\n */\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the Metadata struct.\n  shaderBuilder.addStruct(MetadataPipelineStage.STRUCT_ID_METADATA_VS, MetadataPipelineStage.STRUCT_NAME_METADATA, ShaderDestination.VERTEX);\n  shaderBuilder.addStruct(MetadataPipelineStage.STRUCT_ID_METADATA_FS, MetadataPipelineStage.STRUCT_NAME_METADATA, ShaderDestination.FRAGMENT);\n\n  // Declare the MetadataClass struct\n  shaderBuilder.addStruct(MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_VS, MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS, ShaderDestination.VERTEX);\n  shaderBuilder.addStruct(MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_FS, MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS, ShaderDestination.FRAGMENT);\n\n  // Declare the MetadataStatistics struct\n  shaderBuilder.addStruct(MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_VS, MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS, ShaderDestination.VERTEX);\n  shaderBuilder.addStruct(MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_FS, MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS, ShaderDestination.FRAGMENT);\n\n  // declare the initializeMetadata() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS, MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA, ShaderDestination.VERTEX);\n  shaderBuilder.addFunction(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS, MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA, ShaderDestination.FRAGMENT);\n\n  // declare the setMetadataVaryings() function in the vertex shader only.\n  shaderBuilder.addFunction(MetadataPipelineStage.FUNCTION_ID_SET_METADATA_VARYINGS, MetadataPipelineStage.FUNCTION_SIGNATURE_SET_METADATA_VARYINGS, ShaderDestination.VERTEX);\n}\n\n/**\n * Update the shader for a single PropertyAttributeProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty\n * @private\n */\nfunction processPropertyAttributeProperty(renderResources, propertyInfo) {\n  addPropertyAttributePropertyMetadata(renderResources, propertyInfo);\n  addPropertyMetadataClass(renderResources.shaderBuilder, propertyInfo);\n  addPropertyMetadataStatistics(renderResources.shaderBuilder, propertyInfo);\n}\n\n/**\n * Add fields to the Metadata struct, and metadata value assignments to the\n * initializeMetadata function, for a PropertyAttributeProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty\n * @private\n */\nfunction addPropertyAttributePropertyMetadata(renderResources, propertyInfo) {\n  const {\n    shaderBuilder\n  } = renderResources;\n  const {\n    metadataVariable,\n    property,\n    glslType\n  } = propertyInfo;\n  const valueExpression = addValueTransformUniforms({\n    valueExpression: `attributes.${propertyInfo.variableName}`,\n    renderResources: renderResources,\n    glslType: glslType,\n    metadataVariable: metadataVariable,\n    shaderDestination: ShaderDestination.BOTH,\n    property: property\n  });\n\n  // declare the struct field\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_VS, glslType, metadataVariable);\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_FS, glslType, metadataVariable);\n\n  // assign the result to the metadata struct property.\n  const initializationLine = `metadata.${metadataVariable} = ${valueExpression};`;\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS, [initializationLine]);\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS, [initializationLine]);\n}\n\n/**\n * Update the shader for a single PropertyTextureProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {Object[]} propertyInfo Info about the PropertyTextureProperty\n * @private\n */\nfunction processPropertyTextureProperty(renderResources, propertyInfo) {\n  addPropertyTexturePropertyMetadata(renderResources, propertyInfo);\n  addPropertyMetadataClass(renderResources.shaderBuilder, propertyInfo);\n  addPropertyMetadataStatistics(renderResources.shaderBuilder, propertyInfo);\n}\n\n/**\n * Add fields to the Metadata struct, and metadata value expressions to the\n * initializeMetadata function, for a PropertyTextureProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyTextureProperty\n * @private\n */\nfunction addPropertyTexturePropertyMetadata(renderResources, propertyInfo) {\n  const {\n    shaderBuilder,\n    uniformMap\n  } = renderResources;\n  const {\n    metadataVariable,\n    glslType,\n    property\n  } = propertyInfo;\n  const {\n    texCoord,\n    channels,\n    index,\n    texture,\n    transform\n  } = property.textureReader;\n  const textureUniformName = `u_propertyTexture_${index}`;\n\n  // Property texture properties may share the same physical texture, so only\n  // add the texture uniform the first time we encounter it.\n  if (!uniformMap.hasOwnProperty(textureUniformName)) {\n    shaderBuilder.addUniform(\"sampler2D\", textureUniformName, ShaderDestination.FRAGMENT);\n    uniformMap[textureUniformName] = () => texture;\n  }\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_FS, glslType, metadataVariable);\n\n  // Get a GLSL expression for the texture coordinates of the property.\n  // By default, this will be taken directly from the attributes.\n  const texCoordVariable = `attributes.texCoord_${texCoord}`;\n  let texCoordVariableExpression = texCoordVariable;\n\n  // Check if the texture defines a `transform` from a `KHR_texture_transform`\n  if (defined(transform) && !Matrix3.equals(transform, Matrix3.IDENTITY)) {\n    // Add a uniform for the transformation matrix\n    const transformUniformName = `${textureUniformName}Transform`;\n    shaderBuilder.addUniform(\"mat3\", transformUniformName, ShaderDestination.FRAGMENT);\n    uniformMap[transformUniformName] = function () {\n      return transform;\n    };\n\n    // Update the expression for the texture coordinates\n    // with one that transforms the texture coordinates\n    // with the transform matrix first\n    texCoordVariableExpression = `vec2(${transformUniformName} * vec3(${texCoordVariable}, 1.0))`;\n  }\n  const valueExpression = `texture(${textureUniformName}, ${texCoordVariableExpression}).${channels}`;\n\n  // Some types need an unpacking step or two. For example, since texture reads\n  // are always normalized, UINT8 (not normalized) properties need to be\n  // un-normalized in the shader.\n  const unpackedValue = property.unpackInShader(valueExpression);\n  const transformedValue = addValueTransformUniforms({\n    valueExpression: unpackedValue,\n    renderResources: renderResources,\n    glslType: glslType,\n    metadataVariable: metadataVariable,\n    shaderDestination: ShaderDestination.FRAGMENT,\n    property: property\n  });\n  const initializationLine = `metadata.${metadataVariable} = ${transformedValue};`;\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS, [initializationLine]);\n}\n\n/**\n * Add fields to the MetadataClass struct, and metadataClass value expressions\n * to the initializeMetadata function, for a PropertyAttributeProperty or\n * PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty or PropertyTextureProperty\n * @private\n */\nfunction addPropertyMetadataClass(shaderBuilder, propertyInfo) {\n  const {\n    classProperty\n  } = propertyInfo.property;\n  const {\n    metadataVariable,\n    glslType,\n    shaderDestination\n  } = propertyInfo;\n\n  // Construct assignment statements to set values in the metadataClass struct\n  const assignments = getStructAssignments(MetadataPipelineStage.METADATA_CLASS_FIELDS, classProperty, `metadataClass.${metadataVariable}`, glslType);\n\n  // Struct field: Prefix to get the appropriate <type>MetadataClass struct\n  const metadataType = `${glslType}MetadataClass`;\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_FS, metadataType, metadataVariable);\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS, assignments);\n  if (!ShaderDestination.includesVertexShader(shaderDestination)) {\n    return;\n  }\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_VS, metadataType, metadataVariable);\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS, assignments);\n}\n\n/**\n * Add fields to the MetadataStatistics struct, and metadataStatistics value\n * expressions to the initializeMetadata function, for a\n * PropertyAttributeProperty or PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty or PropertyTextureProperty\n * @private\n */\nfunction addPropertyMetadataStatistics(shaderBuilder, propertyInfo) {\n  const {\n    propertyStatistics\n  } = propertyInfo;\n  if (!defined(propertyStatistics)) {\n    return;\n  }\n  const {\n    metadataVariable,\n    type,\n    glslType\n  } = propertyInfo;\n  if (type === MetadataType.ENUM) {\n    // enums have an \"occurrences\" statistic which is not implemented yet\n    return;\n  }\n\n  // Construct assignment statements to set values in the metadataStatistics struct\n  const fields = MetadataPipelineStage.METADATA_STATISTICS_FIELDS;\n  const struct = `metadataStatistics.${metadataVariable}`;\n  const assignments = getStructAssignments(fields, propertyStatistics, struct, glslType);\n\n  // Struct field: Prefix to get the appropriate <type>MetadataStatistics struct\n  const statisticsType = `${glslType}MetadataStatistics`;\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_FS, statisticsType, metadataVariable);\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS, assignments);\n  if (!ShaderDestination.includesVertexShader(propertyInfo.shaderDestination)) {\n    return;\n  }\n  shaderBuilder.addStructField(MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_VS, statisticsType, metadataVariable);\n  shaderBuilder.addFunctionLines(MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS, assignments);\n}\n\n/**\n * Construct GLSL assignment statements to set metadata spec values in a struct\n * @param {Object[]} fieldNames An object with the following properties:\n * @param {string} fieldNames[].specName The name of the property in the spec\n * @param {string} fieldNames[].shaderName The name of the property in the shader\n * @param {object} values A source of property values, keyed on fieldNames[].specName\n * @param {string} struct The name of the struct to which values will be assigned\n * @param {string} type The type of the values to be assigned\n * @returns {Array<{name: string, value: any}>} Objects containing the property name (in the shader) and a GLSL assignment statement for the property value\n * @private\n */\nfunction getStructAssignments(fieldNames, values, struct, type) {\n  function constructAssignment(field) {\n    const value = values[field.specName];\n    if (defined(value)) {\n      return `${struct}.${field.shaderName} = ${type}(${value});`;\n    }\n  }\n  return defined(values) ? fieldNames.map(constructAssignment).filter(defined) : [];\n}\n\n/**\n * Handle offset/scale transform for a property value\n * This wraps the GLSL value expression with a czm_valueTransform() call\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.valueExpression The GLSL value expression without the transform\n * @param {string} options.metadataVariable The name of the GLSL variable that will contain the property value\n * @param {string} options.glslType The GLSL type of the variable\n * @param {ShaderDestination} options.shaderDestination Which shader(s) use this variable\n * @param {PrimitiveRenderResources} options.renderResources The render resources for this primitive\n * @param {(PropertyAttributeProperty|PropertyTextureProperty)} options.property The property from which the value is derived\n * @returns {string} A wrapped GLSL value expression\n * @private\n */\nfunction addValueTransformUniforms(options) {\n  const {\n    valueExpression,\n    property\n  } = options;\n  if (!property.hasValueTransform) {\n    return valueExpression;\n  }\n  const metadataVariable = options.metadataVariable;\n  const offsetUniformName = `u_${metadataVariable}_offset`;\n  const scaleUniformName = `u_${metadataVariable}_scale`;\n  const {\n    shaderBuilder,\n    uniformMap\n  } = options.renderResources;\n  const {\n    glslType,\n    shaderDestination\n  } = options;\n  shaderBuilder.addUniform(glslType, offsetUniformName, shaderDestination);\n  shaderBuilder.addUniform(glslType, scaleUniformName, shaderDestination);\n  const {\n    offset,\n    scale\n  } = property;\n  uniformMap[offsetUniformName] = () => offset;\n  uniformMap[scaleUniformName] = () => scale;\n  return `czm_valueTransform(${offsetUniformName}, ${scaleUniformName}, ${valueExpression})`;\n}\nexport default MetadataPipelineStage;","map":{"version":3,"names":["Matrix3","defined","ShaderDestination","MetadataStageFS","MetadataStageVS","MetadataType","ModelUtility","MetadataPipelineStage","name","STRUCT_ID_METADATA_VS","STRUCT_ID_METADATA_FS","STRUCT_NAME_METADATA","STRUCT_ID_METADATA_CLASS_VS","STRUCT_ID_METADATA_CLASS_FS","STRUCT_NAME_METADATA_CLASS","STRUCT_ID_METADATA_STATISTICS_VS","STRUCT_ID_METADATA_STATISTICS_FS","STRUCT_NAME_METADATA_STATISTICS","FUNCTION_ID_INITIALIZE_METADATA_VS","FUNCTION_ID_INITIALIZE_METADATA_FS","FUNCTION_SIGNATURE_INITIALIZE_METADATA","FUNCTION_ID_SET_METADATA_VARYINGS","FUNCTION_SIGNATURE_SET_METADATA_VARYINGS","METADATA_CLASS_FIELDS","specName","shaderName","METADATA_STATISTICS_FIELDS","type","process","renderResources","primitive","frameState","shaderBuilder","model","structuralMetadata","content","statistics","tileset","metadataExtension","propertyAttributesInfo","getPropertyAttributesInfo","propertyAttributes","propertyTexturesInfo","getPropertyTexturesInfo","propertyTextures","allPropertyInfos","concat","declareMetadataTypeStructs","declareStructsAndFunctions","addVertexLines","addFragmentLines","i","length","info","processPropertyAttributeProperty","processPropertyTextureProperty","flatMap","propertyAttribute","getPropertyAttributeInfo","getAttributeByName","getAttributeInfo","sanitizeGlslIdentifier","classId","class","id","classStatistics","classes","propertiesArray","Object","entries","properties","infoArray","Array","propertyId","property","modelAttribute","attribute","glslType","variableName","metadataVariable","classProperty","propertyStatistics","shaderDestination","BOTH","propertyTexture","getPropertyTextureInfo","filter","isGpuCompatible","getGlslType","FRAGMENT","propertyInfos","classTypes","Set","statisticsTypes","add","ENUM","classFields","metadataType","classStructName","declareTypeStruct","statisticsFields","statisticsStructName","structName","fields","addStruct","shaderType","convertToFloatComponents","addStructField","floatConversions","int","ivec2","ivec3","ivec4","converted","VERTEX","addFunction","propertyInfo","addPropertyAttributePropertyMetadata","addPropertyMetadataClass","addPropertyMetadataStatistics","valueExpression","addValueTransformUniforms","initializationLine","addFunctionLines","addPropertyTexturePropertyMetadata","uniformMap","texCoord","channels","index","texture","transform","textureReader","textureUniformName","hasOwnProperty","addUniform","texCoordVariable","texCoordVariableExpression","equals","IDENTITY","transformUniformName","unpackedValue","unpackInShader","transformedValue","assignments","getStructAssignments","includesVertexShader","struct","statisticsType","fieldNames","values","constructAssignment","field","value","map","options","hasValueTransform","offsetUniformName","scaleUniformName","offset","scale"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/MetadataPipelineStage.js"],"sourcesContent":["import Matrix3 from \"../../Core/Matrix3.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MetadataStageFS from \"../../Shaders/Model/MetadataStageFS.js\";\nimport MetadataStageVS from \"../../Shaders/Model/MetadataStageVS.js\";\nimport MetadataType from \"../MetadataType.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The metadata pipeline stage processes metadata properties from\n * EXT_structural_metadata and inserts them into a struct in the shader.\n * This struct will be used by {@link CustomShaderPipelineStage} to allow the\n * user to access metadata using {@link CustomShader}\n *\n * @namespace MetadataPipelineStage\n *\n * @private\n */\nconst MetadataPipelineStage = {\n  name: \"MetadataPipelineStage\",\n\n  STRUCT_ID_METADATA_VS: \"MetadataVS\",\n  STRUCT_ID_METADATA_FS: \"MetadataFS\",\n  STRUCT_NAME_METADATA: \"Metadata\",\n\n  STRUCT_ID_METADATA_CLASS_VS: \"MetadataClassVS\",\n  STRUCT_ID_METADATA_CLASS_FS: \"MetadataClassFS\",\n  STRUCT_NAME_METADATA_CLASS: \"MetadataClass\",\n\n  STRUCT_ID_METADATA_STATISTICS_VS: \"MetadataStatisticsVS\",\n  STRUCT_ID_METADATA_STATISTICS_FS: \"MetadataStatisticsFS\",\n  STRUCT_NAME_METADATA_STATISTICS: \"MetadataStatistics\",\n\n  FUNCTION_ID_INITIALIZE_METADATA_VS: \"initializeMetadataVS\",\n  FUNCTION_ID_INITIALIZE_METADATA_FS: \"initializeMetadataFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_METADATA:\n    \"void initializeMetadata(out Metadata metadata, out MetadataClass metadataClass, out MetadataStatistics metadataStatistics, ProcessedAttributes attributes)\",\n  FUNCTION_ID_SET_METADATA_VARYINGS: \"setMetadataVaryings\",\n  FUNCTION_SIGNATURE_SET_METADATA_VARYINGS: \"void setMetadataVaryings()\",\n\n  // Metadata class and statistics fields:\n  // - some must be renamed to avoid reserved words\n  // - some always have float/vec values, even for integer/ivec property types\n  METADATA_CLASS_FIELDS: [\n    { specName: \"noData\", shaderName: \"noData\" },\n    { specName: \"default\", shaderName: \"defaultValue\" },\n    { specName: \"min\", shaderName: \"minValue\" },\n    { specName: \"max\", shaderName: \"maxValue\" },\n  ],\n  METADATA_STATISTICS_FIELDS: [\n    { specName: \"min\", shaderName: \"minValue\" },\n    { specName: \"max\", shaderName: \"maxValue\" },\n    { specName: \"mean\", shaderName: \"mean\", type: \"float\" },\n    { specName: \"median\", shaderName: \"median\" },\n    {\n      specName: \"standardDeviation\",\n      shaderName: \"standardDeviation\",\n      type: \"float\",\n    },\n    { specName: \"variance\", shaderName: \"variance\", type: \"float\" },\n    { specName: \"sum\", shaderName: \"sum\" },\n  ],\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Adds a Metadata struct to the shader</li>\n *   <li>If the primitive has structural metadata, properties are added to the Metadata struct</li>\n *   <li>dynamic functions are added to the shader to initialize the metadata properties</li>\n *   <li>Adds uniforms for property textures to the uniform map as needed</li>\n *   <li>Adds uniforms for offset/scale to the uniform map as needed</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state\n * @private\n */\nMetadataPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, model } = renderResources;\n  const { structuralMetadata = {}, content } = model;\n  const statistics = content?.tileset.metadataExtension?.statistics;\n\n  const propertyAttributesInfo = getPropertyAttributesInfo(\n    structuralMetadata.propertyAttributes,\n    primitive,\n    statistics,\n  );\n  const propertyTexturesInfo = getPropertyTexturesInfo(\n    structuralMetadata.propertyTextures,\n    statistics,\n  );\n\n  // Declare <type>MetadataClass and <type>MetadataStatistics structs as needed\n  const allPropertyInfos = propertyAttributesInfo.concat(propertyTexturesInfo);\n  declareMetadataTypeStructs(shaderBuilder, allPropertyInfos);\n\n  // Always declare the Metadata, MetadataClass, and MetadataStatistics structs\n  // and the initializeMetadata() function, even if not used\n  declareStructsAndFunctions(shaderBuilder);\n  shaderBuilder.addVertexLines(MetadataStageVS);\n  shaderBuilder.addFragmentLines(MetadataStageFS);\n\n  for (let i = 0; i < propertyAttributesInfo.length; i++) {\n    const info = propertyAttributesInfo[i];\n    processPropertyAttributeProperty(renderResources, info);\n  }\n  for (let i = 0; i < propertyTexturesInfo.length; i++) {\n    const info = propertyTexturesInfo[i];\n    processPropertyTextureProperty(renderResources, info);\n  }\n};\n\n/**\n * Collect info about all properties of all propertyAttributes, and\n * return as a flattened Array\n * @param {PropertyAttribute[]} propertyAttributes The PropertyAttributes with properties to be described\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyAttributeProperty\n * @private\n */\nfunction getPropertyAttributesInfo(propertyAttributes, primitive, statistics) {\n  if (!defined(propertyAttributes)) {\n    return [];\n  }\n  return propertyAttributes.flatMap((propertyAttribute) =>\n    getPropertyAttributeInfo(propertyAttribute, primitive, statistics),\n  );\n}\n\n/**\n * Collect info about the properties of a single PropertyAttribute\n * @param {PropertyAttribute} propertyAttribute The PropertyAttribute with properties to be described\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyAttributeProperty\n * @private\n */\nfunction getPropertyAttributeInfo(propertyAttribute, primitive, statistics) {\n  const { getAttributeByName, getAttributeInfo, sanitizeGlslIdentifier } =\n    ModelUtility;\n\n  const classId = propertyAttribute.class.id;\n  const classStatistics = statistics?.classes[classId];\n\n  const propertiesArray = Object.entries(propertyAttribute.properties);\n  const infoArray = new Array(propertiesArray.length);\n\n  for (let i = 0; i < propertiesArray.length; i++) {\n    const [propertyId, property] = propertiesArray[i];\n    const modelAttribute = getAttributeByName(primitive, property.attribute);\n    const { glslType, variableName } = getAttributeInfo(modelAttribute);\n\n    infoArray[i] = {\n      metadataVariable: sanitizeGlslIdentifier(propertyId),\n      property,\n      type: property.classProperty.type,\n      glslType,\n      variableName,\n      propertyStatistics: classStatistics?.properties[propertyId],\n      shaderDestination: ShaderDestination.BOTH,\n    };\n  }\n\n  return infoArray;\n}\n\n/**\n * Collect info about all properties of all propertyTextures, and\n * return as a flattened Array\n * @param {PropertyTexture[]} propertyTextures The PropertyTextures with properties to be described\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyTextureProperty\n * @private\n */\nfunction getPropertyTexturesInfo(propertyTextures, statistics) {\n  if (!defined(propertyTextures)) {\n    return [];\n  }\n  return propertyTextures.flatMap((propertyTexture) =>\n    getPropertyTextureInfo(propertyTexture, statistics),\n  );\n}\n\n/**\n * Collect info about the properties of a single PropertyTexture\n * @param {PropertyTexture} propertyTexture The PropertyTexture with properties to be described\n * @param {object} [statistics] Statistics about the properties (if the model is from a 3DTiles tileset)\n * @returns {Object[]} An array of objects containing information about each PropertyTextureProperty\n * @private\n */\nfunction getPropertyTextureInfo(propertyTexture, statistics) {\n  const { sanitizeGlslIdentifier } = ModelUtility;\n\n  const classId = propertyTexture.class.id;\n  const classStatistics = statistics?.classes[classId];\n\n  const propertiesArray = Object.entries(propertyTexture.properties).filter(\n    ([id, property]) => property.isGpuCompatible(),\n  );\n  const infoArray = new Array(propertiesArray.length);\n\n  for (let i = 0; i < propertiesArray.length; i++) {\n    const [propertyId, property] = propertiesArray[i];\n\n    infoArray[i] = {\n      metadataVariable: sanitizeGlslIdentifier(propertyId),\n      property,\n      type: property.classProperty.type,\n      glslType: property.getGlslType(),\n      propertyStatistics: classStatistics?.properties[propertyId],\n      shaderDestination: ShaderDestination.FRAGMENT,\n    };\n  }\n\n  return infoArray;\n}\n\n/**\n * Declare <type>MetadataClass structs in the shader for each PropertyAttributeProperty and PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {Object[]} propertyInfos Information about the PropertyAttributeProperties and PropertyTextureProperties\n * @private\n */\nfunction declareMetadataTypeStructs(shaderBuilder, propertyInfos) {\n  const classTypes = new Set();\n  const statisticsTypes = new Set();\n\n  for (let i = 0; i < propertyInfos.length; i++) {\n    const { type, glslType, propertyStatistics } = propertyInfos[i];\n    classTypes.add(glslType);\n    if (!defined(propertyStatistics)) {\n      continue;\n    }\n    if (type !== MetadataType.ENUM) {\n      statisticsTypes.add(glslType);\n    }\n  }\n\n  const classFields = MetadataPipelineStage.METADATA_CLASS_FIELDS;\n  for (const metadataType of classTypes) {\n    const classStructName = `${metadataType}MetadataClass`;\n    declareTypeStruct(classStructName, metadataType, classFields);\n  }\n\n  const statisticsFields = MetadataPipelineStage.METADATA_STATISTICS_FIELDS;\n  for (const metadataType of statisticsTypes) {\n    const statisticsStructName = `${metadataType}MetadataStatistics`;\n    declareTypeStruct(statisticsStructName, metadataType, statisticsFields);\n  }\n\n  function declareTypeStruct(structName, type, fields) {\n    shaderBuilder.addStruct(structName, structName, ShaderDestination.BOTH);\n\n    for (let i = 0; i < fields.length; i++) {\n      const { shaderName } = fields[i];\n      const shaderType =\n        fields[i].type === \"float\" ? convertToFloatComponents(type) : type;\n      shaderBuilder.addStructField(structName, shaderType, shaderName);\n    }\n  }\n}\n\nconst floatConversions = {\n  int: \"float\",\n  ivec2: \"vec2\",\n  ivec3: \"vec3\",\n  ivec4: \"vec4\",\n};\n\n/**\n * For a type with integer components, find a corresponding float-component type\n * @param {string} type The name of a GLSL type with integer components\n * @returns {string} The name of a GLSL type of the same dimension with float components, if available; otherwise the input type\n * @private\n */\nfunction convertToFloatComponents(type) {\n  const converted = floatConversions[type];\n  return defined(converted) ? converted : type;\n}\n\n/**\n * Declare the main Metadata, MetadataClass, and MetadataStatistics structs\n * and the initializeMetadata() function.\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @private\n */\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the Metadata struct.\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Declare the MetadataClass struct\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Declare the MetadataStatistics struct\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the initializeMetadata() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // declare the setMetadataVaryings() function in the vertex shader only.\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_SET_METADATA_VARYINGS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_SET_METADATA_VARYINGS,\n    ShaderDestination.VERTEX,\n  );\n}\n\n/**\n * Update the shader for a single PropertyAttributeProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty\n * @private\n */\nfunction processPropertyAttributeProperty(renderResources, propertyInfo) {\n  addPropertyAttributePropertyMetadata(renderResources, propertyInfo);\n  addPropertyMetadataClass(renderResources.shaderBuilder, propertyInfo);\n  addPropertyMetadataStatistics(renderResources.shaderBuilder, propertyInfo);\n}\n\n/**\n * Add fields to the Metadata struct, and metadata value assignments to the\n * initializeMetadata function, for a PropertyAttributeProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty\n * @private\n */\nfunction addPropertyAttributePropertyMetadata(renderResources, propertyInfo) {\n  const { shaderBuilder } = renderResources;\n  const { metadataVariable, property, glslType } = propertyInfo;\n\n  const valueExpression = addValueTransformUniforms({\n    valueExpression: `attributes.${propertyInfo.variableName}`,\n    renderResources: renderResources,\n    glslType: glslType,\n    metadataVariable: metadataVariable,\n    shaderDestination: ShaderDestination.BOTH,\n    property: property,\n  });\n\n  // declare the struct field\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_VS,\n    glslType,\n    metadataVariable,\n  );\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    glslType,\n    metadataVariable,\n  );\n\n  // assign the result to the metadata struct property.\n  const initializationLine = `metadata.${metadataVariable} = ${valueExpression};`;\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    [initializationLine],\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    [initializationLine],\n  );\n}\n\n/**\n * Update the shader for a single PropertyTextureProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {Object[]} propertyInfo Info about the PropertyTextureProperty\n * @private\n */\nfunction processPropertyTextureProperty(renderResources, propertyInfo) {\n  addPropertyTexturePropertyMetadata(renderResources, propertyInfo);\n  addPropertyMetadataClass(renderResources.shaderBuilder, propertyInfo);\n  addPropertyMetadataStatistics(renderResources.shaderBuilder, propertyInfo);\n}\n\n/**\n * Add fields to the Metadata struct, and metadata value expressions to the\n * initializeMetadata function, for a PropertyTextureProperty\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {object} propertyInfo Info about the PropertyTextureProperty\n * @private\n */\nfunction addPropertyTexturePropertyMetadata(renderResources, propertyInfo) {\n  const { shaderBuilder, uniformMap } = renderResources;\n  const { metadataVariable, glslType, property } = propertyInfo;\n\n  const { texCoord, channels, index, texture, transform } =\n    property.textureReader;\n  const textureUniformName = `u_propertyTexture_${index}`;\n\n  // Property texture properties may share the same physical texture, so only\n  // add the texture uniform the first time we encounter it.\n  if (!uniformMap.hasOwnProperty(textureUniformName)) {\n    shaderBuilder.addUniform(\n      \"sampler2D\",\n      textureUniformName,\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap[textureUniformName] = () => texture;\n  }\n\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    glslType,\n    metadataVariable,\n  );\n\n  // Get a GLSL expression for the texture coordinates of the property.\n  // By default, this will be taken directly from the attributes.\n  const texCoordVariable = `attributes.texCoord_${texCoord}`;\n  let texCoordVariableExpression = texCoordVariable;\n\n  // Check if the texture defines a `transform` from a `KHR_texture_transform`\n  if (defined(transform) && !Matrix3.equals(transform, Matrix3.IDENTITY)) {\n    // Add a uniform for the transformation matrix\n    const transformUniformName = `${textureUniformName}Transform`;\n    shaderBuilder.addUniform(\n      \"mat3\",\n      transformUniformName,\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap[transformUniformName] = function () {\n      return transform;\n    };\n\n    // Update the expression for the texture coordinates\n    // with one that transforms the texture coordinates\n    // with the transform matrix first\n    texCoordVariableExpression = `vec2(${transformUniformName} * vec3(${texCoordVariable}, 1.0))`;\n  }\n  const valueExpression = `texture(${textureUniformName}, ${texCoordVariableExpression}).${channels}`;\n\n  // Some types need an unpacking step or two. For example, since texture reads\n  // are always normalized, UINT8 (not normalized) properties need to be\n  // un-normalized in the shader.\n  const unpackedValue = property.unpackInShader(valueExpression);\n\n  const transformedValue = addValueTransformUniforms({\n    valueExpression: unpackedValue,\n    renderResources: renderResources,\n    glslType: glslType,\n    metadataVariable: metadataVariable,\n    shaderDestination: ShaderDestination.FRAGMENT,\n    property: property,\n  });\n\n  const initializationLine = `metadata.${metadataVariable} = ${transformedValue};`;\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    [initializationLine],\n  );\n}\n\n/**\n * Add fields to the MetadataClass struct, and metadataClass value expressions\n * to the initializeMetadata function, for a PropertyAttributeProperty or\n * PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty or PropertyTextureProperty\n * @private\n */\nfunction addPropertyMetadataClass(shaderBuilder, propertyInfo) {\n  const { classProperty } = propertyInfo.property;\n  const { metadataVariable, glslType, shaderDestination } = propertyInfo;\n\n  // Construct assignment statements to set values in the metadataClass struct\n  const assignments = getStructAssignments(\n    MetadataPipelineStage.METADATA_CLASS_FIELDS,\n    classProperty,\n    `metadataClass.${metadataVariable}`,\n    glslType,\n  );\n\n  // Struct field: Prefix to get the appropriate <type>MetadataClass struct\n  const metadataType = `${glslType}MetadataClass`;\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_FS,\n    metadataType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    assignments,\n  );\n  if (!ShaderDestination.includesVertexShader(shaderDestination)) {\n    return;\n  }\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_CLASS_VS,\n    metadataType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    assignments,\n  );\n}\n\n/**\n * Add fields to the MetadataStatistics struct, and metadataStatistics value\n * expressions to the initializeMetadata function, for a\n * PropertyAttributeProperty or PropertyTextureProperty\n * @param {ShaderBuilder} shaderBuilder The shader builder for the primitive\n * @param {object} propertyInfo Info about the PropertyAttributeProperty or PropertyTextureProperty\n * @private\n */\nfunction addPropertyMetadataStatistics(shaderBuilder, propertyInfo) {\n  const { propertyStatistics } = propertyInfo;\n  if (!defined(propertyStatistics)) {\n    return;\n  }\n  const { metadataVariable, type, glslType } = propertyInfo;\n  if (type === MetadataType.ENUM) {\n    // enums have an \"occurrences\" statistic which is not implemented yet\n    return;\n  }\n\n  // Construct assignment statements to set values in the metadataStatistics struct\n  const fields = MetadataPipelineStage.METADATA_STATISTICS_FIELDS;\n  const struct = `metadataStatistics.${metadataVariable}`;\n  const assignments = getStructAssignments(\n    fields,\n    propertyStatistics,\n    struct,\n    glslType,\n  );\n\n  // Struct field: Prefix to get the appropriate <type>MetadataStatistics struct\n  const statisticsType = `${glslType}MetadataStatistics`;\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_FS,\n    statisticsType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    assignments,\n  );\n  if (!ShaderDestination.includesVertexShader(propertyInfo.shaderDestination)) {\n    return;\n  }\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_STATISTICS_VS,\n    statisticsType,\n    metadataVariable,\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    assignments,\n  );\n}\n\n/**\n * Construct GLSL assignment statements to set metadata spec values in a struct\n * @param {Object[]} fieldNames An object with the following properties:\n * @param {string} fieldNames[].specName The name of the property in the spec\n * @param {string} fieldNames[].shaderName The name of the property in the shader\n * @param {object} values A source of property values, keyed on fieldNames[].specName\n * @param {string} struct The name of the struct to which values will be assigned\n * @param {string} type The type of the values to be assigned\n * @returns {Array<{name: string, value: any}>} Objects containing the property name (in the shader) and a GLSL assignment statement for the property value\n * @private\n */\nfunction getStructAssignments(fieldNames, values, struct, type) {\n  function constructAssignment(field) {\n    const value = values[field.specName];\n    if (defined(value)) {\n      return `${struct}.${field.shaderName} = ${type}(${value});`;\n    }\n  }\n  return defined(values)\n    ? fieldNames.map(constructAssignment).filter(defined)\n    : [];\n}\n\n/**\n * Handle offset/scale transform for a property value\n * This wraps the GLSL value expression with a czm_valueTransform() call\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.valueExpression The GLSL value expression without the transform\n * @param {string} options.metadataVariable The name of the GLSL variable that will contain the property value\n * @param {string} options.glslType The GLSL type of the variable\n * @param {ShaderDestination} options.shaderDestination Which shader(s) use this variable\n * @param {PrimitiveRenderResources} options.renderResources The render resources for this primitive\n * @param {(PropertyAttributeProperty|PropertyTextureProperty)} options.property The property from which the value is derived\n * @returns {string} A wrapped GLSL value expression\n * @private\n */\nfunction addValueTransformUniforms(options) {\n  const { valueExpression, property } = options;\n\n  if (!property.hasValueTransform) {\n    return valueExpression;\n  }\n\n  const metadataVariable = options.metadataVariable;\n  const offsetUniformName = `u_${metadataVariable}_offset`;\n  const scaleUniformName = `u_${metadataVariable}_scale`;\n\n  const { shaderBuilder, uniformMap } = options.renderResources;\n  const { glslType, shaderDestination } = options;\n  shaderBuilder.addUniform(glslType, offsetUniformName, shaderDestination);\n  shaderBuilder.addUniform(glslType, scaleUniformName, shaderDestination);\n\n  const { offset, scale } = property;\n  uniformMap[offsetUniformName] = () => offset;\n  uniformMap[scaleUniformName] = () => scale;\n\n  return `czm_valueTransform(${offsetUniformName}, ${scaleUniformName}, ${valueExpression})`;\n}\n\nexport default MetadataPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}