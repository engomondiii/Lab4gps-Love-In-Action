{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EllipsoidOutlineGeometry from \"./EllipsoidOutlineGeometry.js\";\n\n/**\n * A description of the outline of a sphere.\n *\n * @alias SphereOutlineGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.radius=1.0] The radius of the sphere.\n * @param {number} [options.stackPartitions=10] The count of stacks for the sphere (1 greater than the number of parallel lines).\n * @param {number} [options.slicePartitions=8] The count of slices for the sphere (Equal to the number of radial lines).\n * @param {number} [options.subdivisions=200] The number of points per line, determining the granularity of the curvature .\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const sphere = new Cesium.SphereOutlineGeometry({\n *   radius : 100.0,\n *   stackPartitions : 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);\n */\nfunction SphereOutlineGeometry(options) {\n  const radius = defaultValue(options.radius, 1.0);\n  const radii = new Cartesian3(radius, radius, radius);\n  const ellipsoidOptions = {\n    radii: radii,\n    stackPartitions: options.stackPartitions,\n    slicePartitions: options.slicePartitions,\n    subdivisions: options.subdivisions\n  };\n  this._ellipsoidGeometry = new EllipsoidOutlineGeometry(ellipsoidOptions);\n  this._workerName = \"createSphereOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nSphereOutlineGeometry.packedLength = EllipsoidOutlineGeometry.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SphereOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nSphereOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  //>>includeEnd('debug');\n\n  return EllipsoidOutlineGeometry.pack(value._ellipsoidGeometry, array, startingIndex);\n};\nconst scratchEllipsoidGeometry = new EllipsoidOutlineGeometry();\nconst scratchOptions = {\n  radius: undefined,\n  radii: new Cartesian3(),\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SphereOutlineGeometry} [result] The object into which to store the result.\n * @returns {SphereOutlineGeometry} The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.\n */\nSphereOutlineGeometry.unpack = function (array, startingIndex, result) {\n  const ellipsoidGeometry = EllipsoidOutlineGeometry.unpack(array, startingIndex, scratchEllipsoidGeometry);\n  scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;\n  scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;\n  scratchOptions.subdivisions = ellipsoidGeometry._subdivisions;\n  if (!defined(result)) {\n    scratchOptions.radius = ellipsoidGeometry._radii.x;\n    return new SphereOutlineGeometry(scratchOptions);\n  }\n  Cartesian3.clone(ellipsoidGeometry._radii, scratchOptions.radii);\n  result._ellipsoidGeometry = new EllipsoidOutlineGeometry(scratchOptions);\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.\n *\n * @param {SphereOutlineGeometry} sphereGeometry A description of the sphere outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSphereOutlineGeometry.createGeometry = function (sphereGeometry) {\n  return EllipsoidOutlineGeometry.createGeometry(sphereGeometry._ellipsoidGeometry);\n};\nexport default SphereOutlineGeometry;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","EllipsoidOutlineGeometry","SphereOutlineGeometry","options","radius","radii","ellipsoidOptions","stackPartitions","slicePartitions","subdivisions","_ellipsoidGeometry","_workerName","packedLength","pack","value","array","startingIndex","typeOf","object","scratchEllipsoidGeometry","scratchOptions","undefined","unpack","result","ellipsoidGeometry","_stackPartitions","_slicePartitions","_subdivisions","_radii","x","clone","createGeometry","sphereGeometry"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/SphereOutlineGeometry.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EllipsoidOutlineGeometry from \"./EllipsoidOutlineGeometry.js\";\n\n/**\n * A description of the outline of a sphere.\n *\n * @alias SphereOutlineGeometry\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.radius=1.0] The radius of the sphere.\n * @param {number} [options.stackPartitions=10] The count of stacks for the sphere (1 greater than the number of parallel lines).\n * @param {number} [options.slicePartitions=8] The count of slices for the sphere (Equal to the number of radial lines).\n * @param {number} [options.subdivisions=200] The number of points per line, determining the granularity of the curvature .\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const sphere = new Cesium.SphereOutlineGeometry({\n *   radius : 100.0,\n *   stackPartitions : 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);\n */\nfunction SphereOutlineGeometry(options) {\n  const radius = defaultValue(options.radius, 1.0);\n  const radii = new Cartesian3(radius, radius, radius);\n  const ellipsoidOptions = {\n    radii: radii,\n    stackPartitions: options.stackPartitions,\n    slicePartitions: options.slicePartitions,\n    subdivisions: options.subdivisions,\n  };\n\n  this._ellipsoidGeometry = new EllipsoidOutlineGeometry(ellipsoidOptions);\n  this._workerName = \"createSphereOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nSphereOutlineGeometry.packedLength = EllipsoidOutlineGeometry.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SphereOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nSphereOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  //>>includeEnd('debug');\n\n  return EllipsoidOutlineGeometry.pack(\n    value._ellipsoidGeometry,\n    array,\n    startingIndex,\n  );\n};\n\nconst scratchEllipsoidGeometry = new EllipsoidOutlineGeometry();\nconst scratchOptions = {\n  radius: undefined,\n  radii: new Cartesian3(),\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SphereOutlineGeometry} [result] The object into which to store the result.\n * @returns {SphereOutlineGeometry} The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.\n */\nSphereOutlineGeometry.unpack = function (array, startingIndex, result) {\n  const ellipsoidGeometry = EllipsoidOutlineGeometry.unpack(\n    array,\n    startingIndex,\n    scratchEllipsoidGeometry,\n  );\n  scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;\n  scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;\n  scratchOptions.subdivisions = ellipsoidGeometry._subdivisions;\n\n  if (!defined(result)) {\n    scratchOptions.radius = ellipsoidGeometry._radii.x;\n    return new SphereOutlineGeometry(scratchOptions);\n  }\n\n  Cartesian3.clone(ellipsoidGeometry._radii, scratchOptions.radii);\n  result._ellipsoidGeometry = new EllipsoidOutlineGeometry(scratchOptions);\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.\n *\n * @param {SphereOutlineGeometry} sphereGeometry A description of the sphere outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSphereOutlineGeometry.createGeometry = function (sphereGeometry) {\n  return EllipsoidOutlineGeometry.createGeometry(\n    sphereGeometry._ellipsoidGeometry,\n  );\n};\nexport default SphereOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}