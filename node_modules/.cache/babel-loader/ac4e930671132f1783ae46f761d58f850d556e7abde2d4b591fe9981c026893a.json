{"ast":null,"code":"import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addToArray from \"./addToArray.js\";\nimport findAccessorMinMax from \"./findAccessorMinMax.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport moveTechniqueRenderStates from \"./moveTechniqueRenderStates.js\";\nimport moveTechniquesToExtension from \"./moveTechniquesToExtension.js\";\nimport removeUnusedElements from \"./removeUnusedElements.js\";\nimport updateAccessorComponentTypes from \"./updateAccessorComponentTypes.js\";\nimport removeExtension from \"./removeExtension.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nconst updateFunctions = {\n  0.8: glTF08to10,\n  \"1.0\": glTF10to20,\n  \"2.0\": undefined\n};\n\n/**\n * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n * Applies changes made to the glTF spec between revisions so that the core library\n * only has to handle the latest version.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} [options] Options for updating the glTF.\n * @param {string} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n * @param {string[]} [options.baseColorTextureNames] Names of uniforms that indicate base color textures.\n * @param {string[]} [options.baseColorFactorNames] Names of uniforms that indicate base color factors.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction updateVersion(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const targetVersion = options.targetVersion;\n  let version = gltf.version;\n  gltf.asset = defaultValue(gltf.asset, {\n    version: \"1.0\"\n  });\n  gltf.asset.version = defaultValue(gltf.asset.version, \"1.0\");\n  version = defaultValue(version, gltf.asset.version).toString();\n\n  // Invalid version\n  if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n    // Try truncating trailing version numbers, could be a number as well if it is 0.8\n    if (defined(version)) {\n      version = version.substring(0, 3);\n    }\n    // Default to 1.0 if it cannot be determined\n    if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n      version = \"1.0\";\n    }\n  }\n  let updateFunction = updateFunctions[version];\n  while (defined(updateFunction)) {\n    if (version === targetVersion) {\n      break;\n    }\n    updateFunction(gltf, options);\n    version = gltf.asset.version;\n    updateFunction = updateFunctions[version];\n  }\n  if (!options.keepLegacyExtensions) {\n    convertTechniquesToPbr(gltf, options);\n    convertMaterialsCommonToPbr(gltf);\n  }\n  return gltf;\n}\nfunction updateInstanceTechniques(gltf) {\n  const materials = gltf.materials;\n  for (const materialId in materials) {\n    if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n      const material = materials[materialId];\n      const instanceTechnique = material.instanceTechnique;\n      if (defined(instanceTechnique)) {\n        material.technique = instanceTechnique.technique;\n        material.values = instanceTechnique.values;\n        delete material.instanceTechnique;\n      }\n    }\n  }\n}\nfunction setPrimitiveModes(gltf) {\n  const meshes = gltf.meshes;\n  for (const meshId in meshes) {\n    if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n      const mesh = meshes[meshId];\n      const primitives = mesh.primitives;\n      if (defined(primitives)) {\n        const primitivesLength = primitives.length;\n        for (let i = 0; i < primitivesLength; ++i) {\n          const primitive = primitives[i];\n          const defaultMode = defaultValue(primitive.primitive, WebGLConstants.TRIANGLES);\n          primitive.mode = defaultValue(primitive.mode, defaultMode);\n          delete primitive.primitive;\n        }\n      }\n    }\n  }\n}\nfunction updateNodes(gltf) {\n  const nodes = gltf.nodes;\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      const node = nodes[nodeId];\n      if (defined(node.rotation)) {\n        const rotation = node.rotation;\n        Cartesian3.fromArray(rotation, 0, axis);\n        Quaternion.fromAxisAngle(axis, rotation[3], quat);\n        node.rotation = [quat.x, quat.y, quat.z, quat.w];\n      }\n      const instanceSkin = node.instanceSkin;\n      if (defined(instanceSkin)) {\n        node.skeletons = instanceSkin.skeletons;\n        node.skin = instanceSkin.skin;\n        node.meshes = instanceSkin.meshes;\n        delete node.instanceSkin;\n      }\n    }\n  }\n}\nfunction updateAnimations(gltf) {\n  const animations = gltf.animations;\n  const accessors = gltf.accessors;\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const updatedAccessors = {};\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const channels = animation.channels;\n      const parameters = animation.parameters;\n      const samplers = animation.samplers;\n      if (defined(channels)) {\n        const channelsLength = channels.length;\n        for (let i = 0; i < channelsLength; ++i) {\n          const channel = channels[i];\n          if (channel.target.path === \"rotation\") {\n            const accessorId = parameters[samplers[channel.sampler].output];\n            if (defined(updatedAccessors[accessorId])) {\n              continue;\n            }\n            updatedAccessors[accessorId] = true;\n            const accessor = accessors[accessorId];\n            const bufferView = bufferViews[accessor.bufferView];\n            const buffer = buffers[bufferView.buffer];\n            const source = buffer.extras._pipeline.source;\n            const byteOffset = source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n            const componentType = accessor.componentType;\n            const count = accessor.count;\n            const componentsLength = numberOfComponentsForType(accessor.type);\n            const length = accessor.count * componentsLength;\n            const typedArray = ComponentDatatype.createArrayBufferView(componentType, source.buffer, byteOffset, length);\n            for (let j = 0; j < count; j++) {\n              const offset = j * componentsLength;\n              Cartesian3.unpack(typedArray, offset, axis);\n              const angle = typedArray[offset + 3];\n              Quaternion.fromAxisAngle(axis, angle, quat);\n              Quaternion.pack(quat, typedArray, offset);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nfunction removeTechniquePasses(gltf) {\n  const techniques = gltf.techniques;\n  for (const techniqueId in techniques) {\n    if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n      const technique = techniques[techniqueId];\n      const passes = technique.passes;\n      if (defined(passes)) {\n        const passName = defaultValue(technique.pass, \"defaultPass\");\n        if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n          const pass = passes[passName];\n          const instanceProgram = pass.instanceProgram;\n          technique.attributes = defaultValue(technique.attributes, instanceProgram.attributes);\n          technique.program = defaultValue(technique.program, instanceProgram.program);\n          technique.uniforms = defaultValue(technique.uniforms, instanceProgram.uniforms);\n          technique.states = defaultValue(technique.states, pass.states);\n        }\n        delete technique.passes;\n        delete technique.pass;\n      }\n    }\n  }\n}\nfunction glTF08to10(gltf) {\n  if (!defined(gltf.asset)) {\n    gltf.asset = {};\n  }\n  const asset = gltf.asset;\n  asset.version = \"1.0\";\n  // Profile should be an object, not a string\n  if (typeof asset.profile === \"string\") {\n    const split = asset.profile.split(\" \");\n    asset.profile = {\n      api: split[0],\n      version: split[1]\n    };\n  } else {\n    asset.profile = {};\n  }\n\n  // Version property should be in asset, not on the root element\n  if (defined(gltf.version)) {\n    delete gltf.version;\n  }\n  // material.instanceTechnique properties should be directly on the material\n  updateInstanceTechniques(gltf);\n  // primitive.primitive should be primitive.mode\n  setPrimitiveModes(gltf);\n  // Node rotation should be quaternion, not axis-angle\n  // node.instanceSkin is deprecated\n  updateNodes(gltf);\n  // Animations that target rotations should be quaternion, not axis-angle\n  updateAnimations(gltf);\n  // technique.pass and techniques.passes are deprecated\n  removeTechniquePasses(gltf);\n  // gltf.allExtensions -> extensionsUsed\n  if (defined(gltf.allExtensions)) {\n    gltf.extensionsUsed = gltf.allExtensions;\n    delete gltf.allExtensions;\n  }\n  // gltf.lights -> khrMaterialsCommon.lights\n  if (defined(gltf.lights)) {\n    const extensions = defaultValue(gltf.extensions, {});\n    gltf.extensions = extensions;\n    const materialsCommon = defaultValue(extensions.KHR_materials_common, {});\n    extensions.KHR_materials_common = materialsCommon;\n    materialsCommon.lights = gltf.lights;\n    delete gltf.lights;\n    addExtensionsUsed(gltf, \"KHR_materials_common\");\n  }\n}\nfunction removeAnimationSamplersIndirection(gltf) {\n  const animations = gltf.animations;\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const parameters = animation.parameters;\n      if (defined(parameters)) {\n        const samplers = animation.samplers;\n        for (const samplerId in samplers) {\n          if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n            const sampler = samplers[samplerId];\n            sampler.input = parameters[sampler.input];\n            sampler.output = parameters[sampler.output];\n          }\n        }\n        delete animation.parameters;\n      }\n    }\n  }\n}\nfunction objectToArray(object, mapping) {\n  const array = [];\n  for (const id in object) {\n    if (Object.prototype.hasOwnProperty.call(object, id)) {\n      const value = object[id];\n      mapping[id] = array.length;\n      array.push(value);\n      if (!defined(value.name)) {\n        value.name = id;\n      }\n    }\n  }\n  return array;\n}\nfunction objectsToArrays(gltf) {\n  let i;\n  const globalMapping = {\n    accessors: {},\n    animations: {},\n    buffers: {},\n    bufferViews: {},\n    cameras: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    programs: {},\n    samplers: {},\n    scenes: {},\n    shaders: {},\n    skins: {},\n    textures: {},\n    techniques: {}\n  };\n\n  // Map joint names to id names\n  let jointName;\n  const jointNameToId = {};\n  const nodes = gltf.nodes;\n  for (const id in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n      jointName = nodes[id].jointName;\n      if (defined(jointName)) {\n        jointNameToId[jointName] = id;\n      }\n    }\n  }\n\n  // Convert top level objects to arrays\n  for (const topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId) && defined(globalMapping[topLevelId])) {\n      const objectMapping = {};\n      const object = gltf[topLevelId];\n      gltf[topLevelId] = objectToArray(object, objectMapping);\n      globalMapping[topLevelId] = objectMapping;\n    }\n  }\n\n  // Remap joint names to array indexes\n  for (jointName in jointNameToId) {\n    if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n      jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n    }\n  }\n\n  // Fix references\n  if (defined(gltf.scene)) {\n    gltf.scene = globalMapping.scenes[gltf.scene];\n  }\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    const extensions = shader.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete shader.extensions;\n      }\n    }\n  });\n  ForEach.program(gltf, function (program) {\n    if (defined(program.vertexShader)) {\n      program.vertexShader = globalMapping.shaders[program.vertexShader];\n    }\n    if (defined(program.fragmentShader)) {\n      program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n    }\n  });\n  ForEach.technique(gltf, function (technique) {\n    if (defined(technique.program)) {\n      technique.program = globalMapping.programs[technique.program];\n    }\n    ForEach.techniqueParameter(technique, function (parameter) {\n      if (defined(parameter.node)) {\n        parameter.node = globalMapping.nodes[parameter.node];\n      }\n      const value = parameter.value;\n      if (typeof value === \"string\") {\n        parameter.value = {\n          index: globalMapping.textures[value]\n        };\n      }\n    });\n  });\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.indices)) {\n        primitive.indices = globalMapping.accessors[primitive.indices];\n      }\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, semantic) {\n        primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n      });\n      if (defined(primitive.material)) {\n        primitive.material = globalMapping.materials[primitive.material];\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    let children = node.children;\n    if (defined(children)) {\n      const childrenLength = children.length;\n      for (i = 0; i < childrenLength; ++i) {\n        children[i] = globalMapping.nodes[children[i]];\n      }\n    }\n    if (defined(node.meshes)) {\n      // Split out meshes on nodes\n      const meshes = node.meshes;\n      const meshesLength = meshes.length;\n      if (meshesLength > 0) {\n        node.mesh = globalMapping.meshes[meshes[0]];\n        for (i = 1; i < meshesLength; ++i) {\n          const meshNode = {\n            mesh: globalMapping.meshes[meshes[i]]\n          };\n          const meshNodeId = addToArray(gltf.nodes, meshNode);\n          if (!defined(children)) {\n            children = [];\n            node.children = children;\n          }\n          children.push(meshNodeId);\n        }\n      }\n      delete node.meshes;\n    }\n    if (defined(node.camera)) {\n      node.camera = globalMapping.cameras[node.camera];\n    }\n    if (defined(node.skin)) {\n      node.skin = globalMapping.skins[node.skin];\n    }\n    if (defined(node.skeletons)) {\n      // Assign skeletons to skins\n      const skeletons = node.skeletons;\n      const skeletonsLength = skeletons.length;\n      if (skeletonsLength > 0 && defined(node.skin)) {\n        const skin = gltf.skins[node.skin];\n        skin.skeleton = globalMapping.nodes[skeletons[0]];\n      }\n      delete node.skeletons;\n    }\n    if (defined(node.jointName)) {\n      delete node.jointName;\n    }\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      skin.inverseBindMatrices = globalMapping.accessors[skin.inverseBindMatrices];\n    }\n    const jointNames = skin.jointNames;\n    if (defined(jointNames)) {\n      const joints = [];\n      const jointNamesLength = jointNames.length;\n      for (i = 0; i < jointNamesLength; ++i) {\n        joints[i] = jointNameToId[jointNames[i]];\n      }\n      skin.joints = joints;\n      delete skin.jointNames;\n    }\n  });\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (i = 0; i < sceneNodesLength; ++i) {\n        sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n      }\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    const samplerMapping = {};\n    animation.samplers = objectToArray(animation.samplers, samplerMapping);\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.input = globalMapping.accessors[sampler.input];\n      sampler.output = globalMapping.accessors[sampler.output];\n    });\n    ForEach.animationChannel(animation, function (channel) {\n      channel.sampler = samplerMapping[channel.sampler];\n      const target = channel.target;\n      if (defined(target)) {\n        target.node = globalMapping.nodes[target.id];\n        delete target.id;\n      }\n    });\n  });\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      material.technique = globalMapping.techniques[material.technique];\n    }\n    ForEach.materialValue(material, function (value, name) {\n      if (typeof value === \"string\") {\n        material.values[name] = {\n          index: globalMapping.textures[value]\n        };\n      }\n    });\n    const extensions = material.extensions;\n    if (defined(extensions)) {\n      const materialsCommon = extensions.KHR_materials_common;\n      if (defined(materialsCommon) && defined(materialsCommon.values)) {\n        ForEach.materialValue(materialsCommon, function (value, name) {\n          if (typeof value === \"string\") {\n            materialsCommon.values[name] = {\n              index: globalMapping.textures[value]\n            };\n          }\n        });\n      }\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    const extensions = image.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        image.mimeType = binaryGltf.mimeType;\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete image.extensions;\n      }\n    }\n  });\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      texture.sampler = globalMapping.samplers[texture.sampler];\n    }\n    if (defined(texture.source)) {\n      texture.source = globalMapping.images[texture.source];\n    }\n  });\n}\nfunction removeAnimationSamplerNames(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      delete sampler.name;\n    });\n  });\n}\nfunction removeEmptyArrays(gltf) {\n  for (const topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n      const array = gltf[topLevelId];\n      if (Array.isArray(array) && array.length === 0) {\n        delete gltf[topLevelId];\n      }\n    }\n  }\n  ForEach.node(gltf, function (node) {\n    if (defined(node.children) && node.children.length === 0) {\n      delete node.children;\n    }\n  });\n}\nfunction stripAsset(gltf) {\n  const asset = gltf.asset;\n  delete asset.profile;\n  delete asset.premultipliedAlpha;\n}\nconst knownExtensions = {\n  CESIUM_RTC: true,\n  KHR_materials_common: true,\n  WEB3D_quantized_attributes: true\n};\nfunction requireKnownExtensions(gltf) {\n  const extensionsUsed = gltf.extensionsUsed;\n  gltf.extensionsRequired = defaultValue(gltf.extensionsRequired, []);\n  if (defined(extensionsUsed)) {\n    const extensionsUsedLength = extensionsUsed.length;\n    for (let i = 0; i < extensionsUsedLength; ++i) {\n      const extension = extensionsUsed[i];\n      if (defined(knownExtensions[extension])) {\n        gltf.extensionsRequired.push(extension);\n      }\n    }\n  }\n}\nfunction removeBufferType(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    delete buffer.type;\n  });\n}\nfunction removeTextureProperties(gltf) {\n  ForEach.texture(gltf, function (texture) {\n    delete texture.format;\n    delete texture.internalFormat;\n    delete texture.target;\n    delete texture.type;\n  });\n}\nfunction requireAttributeSetIndex(gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, semantic) {\n        if (semantic === \"TEXCOORD\") {\n          primitive.attributes.TEXCOORD_0 = accessorId;\n        } else if (semantic === \"COLOR\") {\n          primitive.attributes.COLOR_0 = accessorId;\n        }\n      });\n      delete primitive.attributes.TEXCOORD;\n      delete primitive.attributes.COLOR;\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const semantic = parameter.semantic;\n      if (defined(semantic)) {\n        if (semantic === \"TEXCOORD\") {\n          parameter.semantic = \"TEXCOORD_0\";\n        } else if (semantic === \"COLOR\") {\n          parameter.semantic = \"COLOR_0\";\n        }\n      }\n    });\n  });\n}\nconst knownSemantics = {\n  POSITION: true,\n  NORMAL: true,\n  TANGENT: true\n};\nconst indexedSemantics = {\n  COLOR: \"COLOR\",\n  JOINT: \"JOINTS\",\n  JOINTS: \"JOINTS\",\n  TEXCOORD: \"TEXCOORD\",\n  WEIGHT: \"WEIGHTS\",\n  WEIGHTS: \"WEIGHTS\"\n};\nfunction underscoreApplicationSpecificSemantics(gltf) {\n  const mappedSemantics = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      /*eslint-disable no-unused-vars*/\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, semantic) {\n        if (semantic.charAt(0) !== \"_\") {\n          const setIndex = semantic.search(/_[0-9]+/g);\n          let strippedSemantic = semantic;\n          let suffix = \"_0\";\n          if (setIndex >= 0) {\n            strippedSemantic = semantic.substring(0, setIndex);\n            suffix = semantic.substring(setIndex);\n          }\n          let newSemantic;\n          const indexedSemantic = indexedSemantics[strippedSemantic];\n          if (defined(indexedSemantic)) {\n            newSemantic = indexedSemantic + suffix;\n            mappedSemantics[semantic] = newSemantic;\n          } else if (!defined(knownSemantics[strippedSemantic])) {\n            newSemantic = `_${semantic}`;\n            mappedSemantics[semantic] = newSemantic;\n          }\n        }\n      });\n      for (const semantic in mappedSemantics) {\n        if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n          const mappedSemantic = mappedSemantics[semantic];\n          const accessorId = primitive.attributes[semantic];\n          if (defined(accessorId)) {\n            delete primitive.attributes[semantic];\n            primitive.attributes[mappedSemantic] = accessorId;\n          }\n        }\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const mappedSemantic = mappedSemantics[parameter.semantic];\n      if (defined(mappedSemantic)) {\n        parameter.semantic = mappedSemantic;\n      }\n    });\n  });\n}\nfunction clampCameraParameters(gltf) {\n  ForEach.camera(gltf, function (camera) {\n    const perspective = camera.perspective;\n    if (defined(perspective)) {\n      const aspectRatio = perspective.aspectRatio;\n      if (defined(aspectRatio) && aspectRatio === 0.0) {\n        delete perspective.aspectRatio;\n      }\n      const yfov = perspective.yfov;\n      if (defined(yfov) && yfov === 0.0) {\n        perspective.yfov = 1.0;\n      }\n    }\n  });\n}\nfunction computeAccessorByteStride(gltf, accessor) {\n  return defined(accessor.byteStride) && accessor.byteStride !== 0 ? accessor.byteStride : getAccessorByteStride(gltf, accessor);\n}\nfunction requireByteLength(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.byteLength)) {\n      buffer.byteLength = buffer.extras._pipeline.source.length;\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n      const accessorByteEnd = accessor.byteOffset + accessor.count * accessorByteStride;\n      bufferView.byteLength = Math.max(defaultValue(bufferView.byteLength, 0), accessorByteEnd);\n    }\n  });\n}\nfunction moveByteStrideToBufferView(gltf) {\n  let i;\n  let j;\n  let bufferView;\n  const bufferViews = gltf.bufferViews;\n  const bufferViewHasVertexAttributes = {};\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (defined(accessor.bufferView)) {\n      bufferViewHasVertexAttributes[accessor.bufferView] = true;\n    }\n  });\n\n  // Map buffer views to a list of accessors\n  const bufferViewMap = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      bufferViewMap[accessor.bufferView] = defaultValue(bufferViewMap[accessor.bufferView], []);\n      bufferViewMap[accessor.bufferView].push(accessor);\n    }\n  });\n\n  // Split accessors with different byte strides\n  for (const bufferViewId in bufferViewMap) {\n    if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n      bufferView = bufferViews[bufferViewId];\n      const accessors = bufferViewMap[bufferViewId];\n      accessors.sort(function (a, b) {\n        return a.byteOffset - b.byteOffset;\n      });\n      let currentByteOffset = 0;\n      let currentIndex = 0;\n      const accessorsLength = accessors.length;\n      for (i = 0; i < accessorsLength; ++i) {\n        let accessor = accessors[i];\n        const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n        const accessorByteOffset = accessor.byteOffset;\n        const accessorByteLength = accessor.count * accessorByteStride;\n        delete accessor.byteStride;\n        const hasNextAccessor = i < accessorsLength - 1;\n        const nextAccessorByteStride = hasNextAccessor ? computeAccessorByteStride(gltf, accessors[i + 1]) : undefined;\n        if (accessorByteStride !== nextAccessorByteStride) {\n          const newBufferView = clone(bufferView, true);\n          if (bufferViewHasVertexAttributes[bufferViewId]) {\n            newBufferView.byteStride = accessorByteStride;\n          }\n          newBufferView.byteOffset += currentByteOffset;\n          newBufferView.byteLength = accessorByteOffset + accessorByteLength - currentByteOffset;\n          const newBufferViewId = addToArray(bufferViews, newBufferView);\n          for (j = currentIndex; j <= i; ++j) {\n            accessor = accessors[j];\n            accessor.bufferView = newBufferViewId;\n            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n          }\n          // Set current byte offset to next accessor's byte offset\n          currentByteOffset = hasNextAccessor ? accessors[i + 1].byteOffset : undefined;\n          currentIndex = i + 1;\n        }\n      }\n    }\n  }\n\n  // Remove unused buffer views\n  removeUnusedElements(gltf, [\"accessor\", \"bufferView\", \"buffer\"]);\n}\nfunction requirePositionAccessorMinMax(gltf) {\n  ForEach.accessorWithSemantic(gltf, \"POSITION\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (!defined(accessor.min) || !defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      accessor.min = minMax.min;\n      accessor.max = minMax.max;\n    }\n  });\n}\nfunction isNodeEmpty(node) {\n  return (!defined(node.children) || node.children.length === 0) && (!defined(node.meshes) || node.meshes.length === 0) && !defined(node.camera) && !defined(node.skin) && !defined(node.skeletons) && !defined(node.jointName) && (!defined(node.translation) || Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) && (!defined(node.scale) || Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) && (!defined(node.rotation) || Cartesian4.fromArray(node.rotation).equals(new Cartesian4(0.0, 0.0, 0.0, 1.0))) && (!defined(node.matrix) || Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) && !defined(node.extensions) && !defined(node.extras);\n}\nfunction deleteNode(gltf, nodeId) {\n  // Remove from list of nodes in scene\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (let i = sceneNodesLength; i >= 0; --i) {\n        if (sceneNodes[i] === nodeId) {\n          sceneNodes.splice(i, 1);\n          return;\n        }\n      }\n    }\n  });\n\n  // Remove parent node's reference to this node, and delete the parent if also empty\n  ForEach.node(gltf, function (parentNode, parentNodeId) {\n    if (defined(parentNode.children)) {\n      const index = parentNode.children.indexOf(nodeId);\n      if (index > -1) {\n        parentNode.children.splice(index, 1);\n        if (isNodeEmpty(parentNode)) {\n          deleteNode(gltf, parentNodeId);\n        }\n      }\n    }\n  });\n  delete gltf.nodes[nodeId];\n}\nfunction removeEmptyNodes(gltf) {\n  ForEach.node(gltf, function (node, nodeId) {\n    if (isNodeEmpty(node)) {\n      deleteNode(gltf, nodeId);\n    }\n  });\n  return gltf;\n}\nfunction requireAnimationAccessorMinMax(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      const accessor = gltf.accessors[sampler.input];\n      if (!defined(accessor.min) || !defined(accessor.max)) {\n        const minMax = findAccessorMinMax(gltf, accessor);\n        accessor.min = minMax.min;\n        accessor.max = minMax.max;\n      }\n    });\n  });\n}\nfunction validatePresentAccessorMinMax(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.min) || defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      if (defined(accessor.min)) {\n        accessor.min = minMax.min;\n      }\n      if (defined(accessor.max)) {\n        accessor.max = minMax.max;\n      }\n    }\n  });\n}\nfunction glTF10to20(gltf) {\n  gltf.asset = defaultValue(gltf.asset, {});\n  gltf.asset.version = \"2.0\";\n  // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n  updateInstanceTechniques(gltf);\n  // animation.samplers now refers directly to accessors and animation.parameters should be removed\n  removeAnimationSamplersIndirection(gltf);\n  // Remove empty nodes and re-assign referencing indices\n  removeEmptyNodes(gltf);\n  // Top-level objects are now arrays referenced by index instead of id\n  objectsToArrays(gltf);\n  // Animation.sampler objects cannot have names\n  removeAnimationSamplerNames(gltf);\n  // asset.profile no longer exists\n  stripAsset(gltf);\n  // Move known extensions from extensionsUsed to extensionsRequired\n  requireKnownExtensions(gltf);\n  // bufferView.byteLength and buffer.byteLength are required\n  requireByteLength(gltf);\n  // byteStride moved from accessor to bufferView\n  moveByteStrideToBufferView(gltf);\n  // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n  requirePositionAccessorMinMax(gltf);\n  // An animation sampler's input accessor must have min and max properties defined\n  requireAnimationAccessorMinMax(gltf);\n  // When an acccessor has a min- or max, then it is recomputed, to capture the actual\n  // value, and not use the (possibly imprecise) value from the input\n  validatePresentAccessorMinMax(gltf);\n  // buffer.type is unnecessary and should be removed\n  removeBufferType(gltf);\n  // Remove format, internalFormat, target, and type\n  removeTextureProperties(gltf);\n  // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n  requireAttributeSetIndex(gltf);\n  // Add underscores to application-specific parameters\n  underscoreApplicationSpecificSemantics(gltf);\n  // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n  updateAccessorComponentTypes(gltf);\n  // Clamp camera parameters\n  clampCameraParameters(gltf);\n  // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n  moveTechniqueRenderStates(gltf);\n  // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n  moveTechniquesToExtension(gltf);\n  // Remove empty arrays\n  removeEmptyArrays(gltf);\n}\n\n// It's not possible to upgrade glTF 1.0 shaders to 2.0 PBR materials in a generic way,\n// but we can look for certain uniform names that are commonly found in glTF 1.0 assets\n// and create PBR materials out of those.\nconst defaultBaseColorTextureNames = [\"u_tex\", \"u_diffuse\", \"u_emission\", \"u_diffuse_tex\"];\nconst defaultBaseColorFactorNames = [\"u_diffuse\", \"u_diffuse_mat\"];\nfunction initializePbrMaterial(material) {\n  material.pbrMetallicRoughness = defined(material.pbrMetallicRoughness) ? material.pbrMetallicRoughness : {};\n  material.pbrMetallicRoughness.roughnessFactor = 1.0;\n  material.pbrMetallicRoughness.metallicFactor = 0.0;\n}\nfunction isTexture(value) {\n  return defined(value.index);\n}\nfunction isVec4(value) {\n  return Array.isArray(value) && value.length === 4;\n}\nfunction srgbToLinear(srgb) {\n  const linear = new Array(4);\n  linear[3] = srgb[3];\n  for (let i = 0; i < 3; i++) {\n    const c = srgb[i];\n    if (c <= 0.04045) {\n      // eslint-disable-next-line no-loss-of-precision\n      linear[i] = srgb[i] * 0.07739938080495356037151702786378;\n    } else {\n      linear[i] = Math.pow(\n      // eslint-disable-next-line no-loss-of-precision\n      (c + 0.055) * 0.94786729857819905213270142180095, 2.4);\n    }\n  }\n  return linear;\n}\nfunction convertTechniquesToPbr(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const baseColorTextureNames = defaultValue(options.baseColorTextureNames, defaultBaseColorTextureNames);\n  const baseColorFactorNames = defaultValue(options.baseColorFactorNames, defaultBaseColorFactorNames);\n\n  // Future work: convert other values like emissive, specular, etc. Only handling diffuse right now.\n  ForEach.material(gltf, function (material) {\n    ForEach.materialValue(material, function (value, name) {\n      if (baseColorTextureNames.indexOf(name) !== -1 && isTexture(value)) {\n        initializePbrMaterial(material);\n        material.pbrMetallicRoughness.baseColorTexture = value;\n      } else if (baseColorFactorNames.indexOf(name) !== -1 && isVec4(value)) {\n        initializePbrMaterial(material);\n        material.pbrMetallicRoughness.baseColorFactor = srgbToLinear(value);\n      }\n    });\n  });\n  removeExtension(gltf, \"KHR_techniques_webgl\");\n  removeExtension(gltf, \"KHR_blend\");\n}\nfunction assignAsBaseColor(material, baseColor) {\n  if (defined(baseColor)) {\n    if (isVec4(baseColor)) {\n      material.pbrMetallicRoughness.baseColorFactor = srgbToLinear(baseColor);\n    } else if (isTexture(baseColor)) {\n      material.pbrMetallicRoughness.baseColorTexture = baseColor;\n    }\n  }\n}\nfunction assignAsEmissive(material, emissive) {\n  if (defined(emissive)) {\n    if (isVec4(emissive)) {\n      material.emissiveFactor = emissive.slice(0, 3);\n    } else if (isTexture(emissive)) {\n      material.emissiveTexture = emissive;\n    }\n  }\n}\nfunction convertMaterialsCommonToPbr(gltf) {\n  // Future work: convert KHR_materials_common lights to KHR_lights_punctual\n  ForEach.material(gltf, function (material) {\n    const materialsCommon = defaultValue(material.extensions, defaultValue.EMPTY_OBJECT).KHR_materials_common;\n    if (!defined(materialsCommon)) {\n      // Nothing to do\n      return;\n    }\n    const values = defaultValue(materialsCommon.values, {});\n    const ambient = values.ambient;\n    const diffuse = values.diffuse;\n    const emission = values.emission;\n    const transparency = values.transparency;\n\n    // These actually exist on the extension object, not the values object despite what's shown in the spec\n    const doubleSided = materialsCommon.doubleSided;\n    const transparent = materialsCommon.transparent;\n\n    // Ignore specular and shininess for now because the conversion to PBR\n    // isn't straightforward and depends on the technique\n    initializePbrMaterial(material);\n    const technique = materialsCommon.technique;\n    if (technique === \"CONSTANT\") {\n      // Add the KHR_materials_unlit extension\n      addExtensionsUsed(gltf, \"KHR_materials_unlit\");\n      material.extensions = defined(material.extensions) ? material.extensions : {};\n      material.extensions[\"KHR_materials_unlit\"] = {};\n\n      // The CONSTANT technique does not support 'diffuse', so\n      // assign either the 'emission' or the 'ambient' as the\n      // base color\n      assignAsBaseColor(material, emission);\n      assignAsBaseColor(material, ambient);\n    } else {\n      // Assign the 'diffuse' as the base color, and\n      // the 'ambient' or 'emissive' as the emissive\n      // part if they are present.\n      assignAsBaseColor(material, diffuse);\n      assignAsEmissive(material, ambient);\n      assignAsEmissive(material, emission);\n    }\n    if (defined(doubleSided)) {\n      material.doubleSided = doubleSided;\n    }\n    if (defined(transparency)) {\n      if (defined(material.pbrMetallicRoughness.baseColorFactor)) {\n        material.pbrMetallicRoughness.baseColorFactor[3] *= transparency;\n      } else {\n        material.pbrMetallicRoughness.baseColorFactor = [1, 1, 1, transparency];\n      }\n    }\n    if (defined(transparent)) {\n      material.alphaMode = transparent ? \"BLEND\" : \"OPAQUE\";\n    }\n  });\n  removeExtension(gltf, \"KHR_materials_common\");\n}\nexport default updateVersion;","map":{"version":3,"names":["addExtensionsUsed","addToArray","findAccessorMinMax","ForEach","getAccessorByteStride","numberOfComponentsForType","moveTechniqueRenderStates","moveTechniquesToExtension","removeUnusedElements","updateAccessorComponentTypes","removeExtension","Cartesian3","Cartesian4","clone","ComponentDatatype","defaultValue","defined","Matrix4","Quaternion","WebGLConstants","updateFunctions","glTF08to10","glTF10to20","undefined","updateVersion","gltf","options","EMPTY_OBJECT","targetVersion","version","asset","toString","Object","prototype","hasOwnProperty","call","substring","updateFunction","keepLegacyExtensions","convertTechniquesToPbr","convertMaterialsCommonToPbr","updateInstanceTechniques","materials","materialId","material","instanceTechnique","technique","values","setPrimitiveModes","meshes","meshId","mesh","primitives","primitivesLength","length","i","primitive","defaultMode","TRIANGLES","mode","updateNodes","nodes","axis","quat","nodeId","node","rotation","fromArray","fromAxisAngle","x","y","z","w","instanceSkin","skeletons","skin","updateAnimations","animations","accessors","bufferViews","buffers","updatedAccessors","animationId","animation","channels","parameters","samplers","channelsLength","channel","target","path","accessorId","sampler","output","accessor","bufferView","buffer","source","extras","_pipeline","byteOffset","componentType","count","componentsLength","type","typedArray","createArrayBufferView","j","offset","unpack","angle","pack","removeTechniquePasses","techniques","techniqueId","passes","passName","pass","instanceProgram","attributes","program","uniforms","states","profile","split","api","allExtensions","extensionsUsed","lights","extensions","materialsCommon","KHR_materials_common","removeAnimationSamplersIndirection","samplerId","input","objectToArray","object","mapping","array","id","value","push","name","objectsToArrays","globalMapping","cameras","images","programs","scenes","shaders","skins","textures","jointName","jointNameToId","topLevelId","objectMapping","scene","shader","binaryGltf","KHR_binary_glTF","keys","vertexShader","fragmentShader","techniqueParameter","parameter","index","meshPrimitive","indices","meshPrimitiveAttribute","semantic","children","childrenLength","meshesLength","meshNode","meshNodeId","camera","skeletonsLength","skeleton","inverseBindMatrices","jointNames","joints","jointNamesLength","sceneNodes","sceneNodesLength","samplerMapping","animationSampler","animationChannel","materialValue","image","mimeType","texture","removeAnimationSamplerNames","removeEmptyArrays","Array","isArray","stripAsset","premultipliedAlpha","knownExtensions","CESIUM_RTC","WEB3D_quantized_attributes","requireKnownExtensions","extensionsRequired","extensionsUsedLength","extension","removeBufferType","removeTextureProperties","format","internalFormat","requireAttributeSetIndex","TEXCOORD_0","COLOR_0","TEXCOORD","COLOR","knownSemantics","POSITION","NORMAL","TANGENT","indexedSemantics","JOINT","JOINTS","WEIGHT","WEIGHTS","underscoreApplicationSpecificSemantics","mappedSemantics","charAt","setIndex","search","strippedSemantic","suffix","newSemantic","indexedSemantic","mappedSemantic","clampCameraParameters","perspective","aspectRatio","yfov","computeAccessorByteStride","byteStride","requireByteLength","byteLength","bufferViewId","accessorByteStride","accessorByteEnd","Math","max","moveByteStrideToBufferView","bufferViewHasVertexAttributes","accessorContainingVertexAttributeData","bufferViewMap","sort","a","b","currentByteOffset","currentIndex","accessorsLength","accessorByteOffset","accessorByteLength","hasNextAccessor","nextAccessorByteStride","newBufferView","newBufferViewId","requirePositionAccessorMinMax","accessorWithSemantic","min","minMax","isNodeEmpty","translation","equals","ZERO","scale","matrix","fromColumnMajorArray","IDENTITY","deleteNode","splice","parentNode","parentNodeId","indexOf","removeEmptyNodes","requireAnimationAccessorMinMax","validatePresentAccessorMinMax","defaultBaseColorTextureNames","defaultBaseColorFactorNames","initializePbrMaterial","pbrMetallicRoughness","roughnessFactor","metallicFactor","isTexture","isVec4","srgbToLinear","srgb","linear","c","pow","baseColorTextureNames","baseColorFactorNames","baseColorTexture","baseColorFactor","assignAsBaseColor","baseColor","assignAsEmissive","emissive","emissiveFactor","slice","emissiveTexture","ambient","diffuse","emission","transparency","doubleSided","transparent","alphaMode"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfPipeline/updateVersion.js"],"sourcesContent":["import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addToArray from \"./addToArray.js\";\nimport findAccessorMinMax from \"./findAccessorMinMax.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport moveTechniqueRenderStates from \"./moveTechniqueRenderStates.js\";\nimport moveTechniquesToExtension from \"./moveTechniquesToExtension.js\";\nimport removeUnusedElements from \"./removeUnusedElements.js\";\nimport updateAccessorComponentTypes from \"./updateAccessorComponentTypes.js\";\nimport removeExtension from \"./removeExtension.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\nconst updateFunctions = {\n  0.8: glTF08to10,\n  \"1.0\": glTF10to20,\n  \"2.0\": undefined,\n};\n\n/**\n * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n * Applies changes made to the glTF spec between revisions so that the core library\n * only has to handle the latest version.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} [options] Options for updating the glTF.\n * @param {string} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n * @param {string[]} [options.baseColorTextureNames] Names of uniforms that indicate base color textures.\n * @param {string[]} [options.baseColorFactorNames] Names of uniforms that indicate base color factors.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction updateVersion(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const targetVersion = options.targetVersion;\n  let version = gltf.version;\n\n  gltf.asset = defaultValue(gltf.asset, {\n    version: \"1.0\",\n  });\n\n  gltf.asset.version = defaultValue(gltf.asset.version, \"1.0\");\n  version = defaultValue(version, gltf.asset.version).toString();\n\n  // Invalid version\n  if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n    // Try truncating trailing version numbers, could be a number as well if it is 0.8\n    if (defined(version)) {\n      version = version.substring(0, 3);\n    }\n    // Default to 1.0 if it cannot be determined\n    if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n      version = \"1.0\";\n    }\n  }\n\n  let updateFunction = updateFunctions[version];\n\n  while (defined(updateFunction)) {\n    if (version === targetVersion) {\n      break;\n    }\n    updateFunction(gltf, options);\n    version = gltf.asset.version;\n    updateFunction = updateFunctions[version];\n  }\n\n  if (!options.keepLegacyExtensions) {\n    convertTechniquesToPbr(gltf, options);\n    convertMaterialsCommonToPbr(gltf);\n  }\n\n  return gltf;\n}\n\nfunction updateInstanceTechniques(gltf) {\n  const materials = gltf.materials;\n  for (const materialId in materials) {\n    if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n      const material = materials[materialId];\n      const instanceTechnique = material.instanceTechnique;\n      if (defined(instanceTechnique)) {\n        material.technique = instanceTechnique.technique;\n        material.values = instanceTechnique.values;\n        delete material.instanceTechnique;\n      }\n    }\n  }\n}\n\nfunction setPrimitiveModes(gltf) {\n  const meshes = gltf.meshes;\n  for (const meshId in meshes) {\n    if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n      const mesh = meshes[meshId];\n      const primitives = mesh.primitives;\n      if (defined(primitives)) {\n        const primitivesLength = primitives.length;\n        for (let i = 0; i < primitivesLength; ++i) {\n          const primitive = primitives[i];\n          const defaultMode = defaultValue(\n            primitive.primitive,\n            WebGLConstants.TRIANGLES\n          );\n          primitive.mode = defaultValue(primitive.mode, defaultMode);\n          delete primitive.primitive;\n        }\n      }\n    }\n  }\n}\n\nfunction updateNodes(gltf) {\n  const nodes = gltf.nodes;\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      const node = nodes[nodeId];\n      if (defined(node.rotation)) {\n        const rotation = node.rotation;\n        Cartesian3.fromArray(rotation, 0, axis);\n        Quaternion.fromAxisAngle(axis, rotation[3], quat);\n        node.rotation = [quat.x, quat.y, quat.z, quat.w];\n      }\n      const instanceSkin = node.instanceSkin;\n      if (defined(instanceSkin)) {\n        node.skeletons = instanceSkin.skeletons;\n        node.skin = instanceSkin.skin;\n        node.meshes = instanceSkin.meshes;\n        delete node.instanceSkin;\n      }\n    }\n  }\n}\n\nfunction updateAnimations(gltf) {\n  const animations = gltf.animations;\n  const accessors = gltf.accessors;\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const updatedAccessors = {};\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const channels = animation.channels;\n      const parameters = animation.parameters;\n      const samplers = animation.samplers;\n      if (defined(channels)) {\n        const channelsLength = channels.length;\n        for (let i = 0; i < channelsLength; ++i) {\n          const channel = channels[i];\n          if (channel.target.path === \"rotation\") {\n            const accessorId = parameters[samplers[channel.sampler].output];\n            if (defined(updatedAccessors[accessorId])) {\n              continue;\n            }\n            updatedAccessors[accessorId] = true;\n            const accessor = accessors[accessorId];\n            const bufferView = bufferViews[accessor.bufferView];\n            const buffer = buffers[bufferView.buffer];\n            const source = buffer.extras._pipeline.source;\n            const byteOffset =\n              source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n            const componentType = accessor.componentType;\n            const count = accessor.count;\n            const componentsLength = numberOfComponentsForType(accessor.type);\n            const length = accessor.count * componentsLength;\n            const typedArray = ComponentDatatype.createArrayBufferView(\n              componentType,\n              source.buffer,\n              byteOffset,\n              length\n            );\n\n            for (let j = 0; j < count; j++) {\n              const offset = j * componentsLength;\n              Cartesian3.unpack(typedArray, offset, axis);\n              const angle = typedArray[offset + 3];\n              Quaternion.fromAxisAngle(axis, angle, quat);\n              Quaternion.pack(quat, typedArray, offset);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction removeTechniquePasses(gltf) {\n  const techniques = gltf.techniques;\n  for (const techniqueId in techniques) {\n    if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n      const technique = techniques[techniqueId];\n      const passes = technique.passes;\n      if (defined(passes)) {\n        const passName = defaultValue(technique.pass, \"defaultPass\");\n        if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n          const pass = passes[passName];\n          const instanceProgram = pass.instanceProgram;\n          technique.attributes = defaultValue(\n            technique.attributes,\n            instanceProgram.attributes\n          );\n          technique.program = defaultValue(\n            technique.program,\n            instanceProgram.program\n          );\n          technique.uniforms = defaultValue(\n            technique.uniforms,\n            instanceProgram.uniforms\n          );\n          technique.states = defaultValue(technique.states, pass.states);\n        }\n        delete technique.passes;\n        delete technique.pass;\n      }\n    }\n  }\n}\n\nfunction glTF08to10(gltf) {\n  if (!defined(gltf.asset)) {\n    gltf.asset = {};\n  }\n  const asset = gltf.asset;\n  asset.version = \"1.0\";\n  // Profile should be an object, not a string\n  if (typeof asset.profile === \"string\") {\n    const split = asset.profile.split(\" \");\n    asset.profile = {\n      api: split[0],\n      version: split[1],\n    };\n  } else {\n    asset.profile = {};\n  }\n\n  // Version property should be in asset, not on the root element\n  if (defined(gltf.version)) {\n    delete gltf.version;\n  }\n  // material.instanceTechnique properties should be directly on the material\n  updateInstanceTechniques(gltf);\n  // primitive.primitive should be primitive.mode\n  setPrimitiveModes(gltf);\n  // Node rotation should be quaternion, not axis-angle\n  // node.instanceSkin is deprecated\n  updateNodes(gltf);\n  // Animations that target rotations should be quaternion, not axis-angle\n  updateAnimations(gltf);\n  // technique.pass and techniques.passes are deprecated\n  removeTechniquePasses(gltf);\n  // gltf.allExtensions -> extensionsUsed\n  if (defined(gltf.allExtensions)) {\n    gltf.extensionsUsed = gltf.allExtensions;\n    delete gltf.allExtensions;\n  }\n  // gltf.lights -> khrMaterialsCommon.lights\n  if (defined(gltf.lights)) {\n    const extensions = defaultValue(gltf.extensions, {});\n    gltf.extensions = extensions;\n    const materialsCommon = defaultValue(extensions.KHR_materials_common, {});\n    extensions.KHR_materials_common = materialsCommon;\n    materialsCommon.lights = gltf.lights;\n    delete gltf.lights;\n    addExtensionsUsed(gltf, \"KHR_materials_common\");\n  }\n}\n\nfunction removeAnimationSamplersIndirection(gltf) {\n  const animations = gltf.animations;\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const parameters = animation.parameters;\n      if (defined(parameters)) {\n        const samplers = animation.samplers;\n        for (const samplerId in samplers) {\n          if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n            const sampler = samplers[samplerId];\n            sampler.input = parameters[sampler.input];\n            sampler.output = parameters[sampler.output];\n          }\n        }\n        delete animation.parameters;\n      }\n    }\n  }\n}\n\nfunction objectToArray(object, mapping) {\n  const array = [];\n  for (const id in object) {\n    if (Object.prototype.hasOwnProperty.call(object, id)) {\n      const value = object[id];\n      mapping[id] = array.length;\n      array.push(value);\n      if (!defined(value.name)) {\n        value.name = id;\n      }\n    }\n  }\n  return array;\n}\n\nfunction objectsToArrays(gltf) {\n  let i;\n  const globalMapping = {\n    accessors: {},\n    animations: {},\n    buffers: {},\n    bufferViews: {},\n    cameras: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    programs: {},\n    samplers: {},\n    scenes: {},\n    shaders: {},\n    skins: {},\n    textures: {},\n    techniques: {},\n  };\n\n  // Map joint names to id names\n  let jointName;\n  const jointNameToId = {};\n  const nodes = gltf.nodes;\n  for (const id in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n      jointName = nodes[id].jointName;\n      if (defined(jointName)) {\n        jointNameToId[jointName] = id;\n      }\n    }\n  }\n\n  // Convert top level objects to arrays\n  for (const topLevelId in gltf) {\n    if (\n      Object.prototype.hasOwnProperty.call(gltf, topLevelId) &&\n      defined(globalMapping[topLevelId])\n    ) {\n      const objectMapping = {};\n      const object = gltf[topLevelId];\n      gltf[topLevelId] = objectToArray(object, objectMapping);\n      globalMapping[topLevelId] = objectMapping;\n    }\n  }\n\n  // Remap joint names to array indexes\n  for (jointName in jointNameToId) {\n    if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n      jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n    }\n  }\n\n  // Fix references\n  if (defined(gltf.scene)) {\n    gltf.scene = globalMapping.scenes[gltf.scene];\n  }\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    const extensions = shader.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete shader.extensions;\n      }\n    }\n  });\n  ForEach.program(gltf, function (program) {\n    if (defined(program.vertexShader)) {\n      program.vertexShader = globalMapping.shaders[program.vertexShader];\n    }\n    if (defined(program.fragmentShader)) {\n      program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n    }\n  });\n  ForEach.technique(gltf, function (technique) {\n    if (defined(technique.program)) {\n      technique.program = globalMapping.programs[technique.program];\n    }\n    ForEach.techniqueParameter(technique, function (parameter) {\n      if (defined(parameter.node)) {\n        parameter.node = globalMapping.nodes[parameter.node];\n      }\n      const value = parameter.value;\n      if (typeof value === \"string\") {\n        parameter.value = {\n          index: globalMapping.textures[value],\n        };\n      }\n    });\n  });\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.indices)) {\n        primitive.indices = globalMapping.accessors[primitive.indices];\n      }\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n        }\n      );\n      if (defined(primitive.material)) {\n        primitive.material = globalMapping.materials[primitive.material];\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    let children = node.children;\n    if (defined(children)) {\n      const childrenLength = children.length;\n      for (i = 0; i < childrenLength; ++i) {\n        children[i] = globalMapping.nodes[children[i]];\n      }\n    }\n    if (defined(node.meshes)) {\n      // Split out meshes on nodes\n      const meshes = node.meshes;\n      const meshesLength = meshes.length;\n      if (meshesLength > 0) {\n        node.mesh = globalMapping.meshes[meshes[0]];\n        for (i = 1; i < meshesLength; ++i) {\n          const meshNode = {\n            mesh: globalMapping.meshes[meshes[i]],\n          };\n          const meshNodeId = addToArray(gltf.nodes, meshNode);\n          if (!defined(children)) {\n            children = [];\n            node.children = children;\n          }\n          children.push(meshNodeId);\n        }\n      }\n      delete node.meshes;\n    }\n    if (defined(node.camera)) {\n      node.camera = globalMapping.cameras[node.camera];\n    }\n    if (defined(node.skin)) {\n      node.skin = globalMapping.skins[node.skin];\n    }\n    if (defined(node.skeletons)) {\n      // Assign skeletons to skins\n      const skeletons = node.skeletons;\n      const skeletonsLength = skeletons.length;\n      if (skeletonsLength > 0 && defined(node.skin)) {\n        const skin = gltf.skins[node.skin];\n        skin.skeleton = globalMapping.nodes[skeletons[0]];\n      }\n      delete node.skeletons;\n    }\n    if (defined(node.jointName)) {\n      delete node.jointName;\n    }\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      skin.inverseBindMatrices =\n        globalMapping.accessors[skin.inverseBindMatrices];\n    }\n    const jointNames = skin.jointNames;\n    if (defined(jointNames)) {\n      const joints = [];\n      const jointNamesLength = jointNames.length;\n      for (i = 0; i < jointNamesLength; ++i) {\n        joints[i] = jointNameToId[jointNames[i]];\n      }\n      skin.joints = joints;\n      delete skin.jointNames;\n    }\n  });\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (i = 0; i < sceneNodesLength; ++i) {\n        sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n      }\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    const samplerMapping = {};\n    animation.samplers = objectToArray(animation.samplers, samplerMapping);\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.input = globalMapping.accessors[sampler.input];\n      sampler.output = globalMapping.accessors[sampler.output];\n    });\n    ForEach.animationChannel(animation, function (channel) {\n      channel.sampler = samplerMapping[channel.sampler];\n      const target = channel.target;\n      if (defined(target)) {\n        target.node = globalMapping.nodes[target.id];\n        delete target.id;\n      }\n    });\n  });\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      material.technique = globalMapping.techniques[material.technique];\n    }\n    ForEach.materialValue(material, function (value, name) {\n      if (typeof value === \"string\") {\n        material.values[name] = {\n          index: globalMapping.textures[value],\n        };\n      }\n    });\n    const extensions = material.extensions;\n    if (defined(extensions)) {\n      const materialsCommon = extensions.KHR_materials_common;\n      if (defined(materialsCommon) && defined(materialsCommon.values)) {\n        ForEach.materialValue(materialsCommon, function (value, name) {\n          if (typeof value === \"string\") {\n            materialsCommon.values[name] = {\n              index: globalMapping.textures[value],\n            };\n          }\n        });\n      }\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    const extensions = image.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        image.mimeType = binaryGltf.mimeType;\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete image.extensions;\n      }\n    }\n  });\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      texture.sampler = globalMapping.samplers[texture.sampler];\n    }\n    if (defined(texture.source)) {\n      texture.source = globalMapping.images[texture.source];\n    }\n  });\n}\n\nfunction removeAnimationSamplerNames(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      delete sampler.name;\n    });\n  });\n}\n\nfunction removeEmptyArrays(gltf) {\n  for (const topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n      const array = gltf[topLevelId];\n      if (Array.isArray(array) && array.length === 0) {\n        delete gltf[topLevelId];\n      }\n    }\n  }\n  ForEach.node(gltf, function (node) {\n    if (defined(node.children) && node.children.length === 0) {\n      delete node.children;\n    }\n  });\n}\n\nfunction stripAsset(gltf) {\n  const asset = gltf.asset;\n  delete asset.profile;\n  delete asset.premultipliedAlpha;\n}\n\nconst knownExtensions = {\n  CESIUM_RTC: true,\n  KHR_materials_common: true,\n  WEB3D_quantized_attributes: true,\n};\nfunction requireKnownExtensions(gltf) {\n  const extensionsUsed = gltf.extensionsUsed;\n  gltf.extensionsRequired = defaultValue(gltf.extensionsRequired, []);\n  if (defined(extensionsUsed)) {\n    const extensionsUsedLength = extensionsUsed.length;\n    for (let i = 0; i < extensionsUsedLength; ++i) {\n      const extension = extensionsUsed[i];\n      if (defined(knownExtensions[extension])) {\n        gltf.extensionsRequired.push(extension);\n      }\n    }\n  }\n}\n\nfunction removeBufferType(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    delete buffer.type;\n  });\n}\n\nfunction removeTextureProperties(gltf) {\n  ForEach.texture(gltf, function (texture) {\n    delete texture.format;\n    delete texture.internalFormat;\n    delete texture.target;\n    delete texture.type;\n  });\n}\n\nfunction requireAttributeSetIndex(gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          if (semantic === \"TEXCOORD\") {\n            primitive.attributes.TEXCOORD_0 = accessorId;\n          } else if (semantic === \"COLOR\") {\n            primitive.attributes.COLOR_0 = accessorId;\n          }\n        }\n      );\n      delete primitive.attributes.TEXCOORD;\n      delete primitive.attributes.COLOR;\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const semantic = parameter.semantic;\n      if (defined(semantic)) {\n        if (semantic === \"TEXCOORD\") {\n          parameter.semantic = \"TEXCOORD_0\";\n        } else if (semantic === \"COLOR\") {\n          parameter.semantic = \"COLOR_0\";\n        }\n      }\n    });\n  });\n}\n\nconst knownSemantics = {\n  POSITION: true,\n  NORMAL: true,\n  TANGENT: true,\n};\nconst indexedSemantics = {\n  COLOR: \"COLOR\",\n  JOINT: \"JOINTS\",\n  JOINTS: \"JOINTS\",\n  TEXCOORD: \"TEXCOORD\",\n  WEIGHT: \"WEIGHTS\",\n  WEIGHTS: \"WEIGHTS\",\n};\nfunction underscoreApplicationSpecificSemantics(gltf) {\n  const mappedSemantics = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      /*eslint-disable no-unused-vars*/\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          if (semantic.charAt(0) !== \"_\") {\n            const setIndex = semantic.search(/_[0-9]+/g);\n            let strippedSemantic = semantic;\n            let suffix = \"_0\";\n            if (setIndex >= 0) {\n              strippedSemantic = semantic.substring(0, setIndex);\n              suffix = semantic.substring(setIndex);\n            }\n            let newSemantic;\n            const indexedSemantic = indexedSemantics[strippedSemantic];\n            if (defined(indexedSemantic)) {\n              newSemantic = indexedSemantic + suffix;\n              mappedSemantics[semantic] = newSemantic;\n            } else if (!defined(knownSemantics[strippedSemantic])) {\n              newSemantic = `_${semantic}`;\n              mappedSemantics[semantic] = newSemantic;\n            }\n          }\n        }\n      );\n      for (const semantic in mappedSemantics) {\n        if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n          const mappedSemantic = mappedSemantics[semantic];\n          const accessorId = primitive.attributes[semantic];\n          if (defined(accessorId)) {\n            delete primitive.attributes[semantic];\n            primitive.attributes[mappedSemantic] = accessorId;\n          }\n        }\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const mappedSemantic = mappedSemantics[parameter.semantic];\n      if (defined(mappedSemantic)) {\n        parameter.semantic = mappedSemantic;\n      }\n    });\n  });\n}\n\nfunction clampCameraParameters(gltf) {\n  ForEach.camera(gltf, function (camera) {\n    const perspective = camera.perspective;\n    if (defined(perspective)) {\n      const aspectRatio = perspective.aspectRatio;\n      if (defined(aspectRatio) && aspectRatio === 0.0) {\n        delete perspective.aspectRatio;\n      }\n      const yfov = perspective.yfov;\n      if (defined(yfov) && yfov === 0.0) {\n        perspective.yfov = 1.0;\n      }\n    }\n  });\n}\n\nfunction computeAccessorByteStride(gltf, accessor) {\n  return defined(accessor.byteStride) && accessor.byteStride !== 0\n    ? accessor.byteStride\n    : getAccessorByteStride(gltf, accessor);\n}\n\nfunction requireByteLength(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.byteLength)) {\n      buffer.byteLength = buffer.extras._pipeline.source.length;\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n      const accessorByteEnd =\n        accessor.byteOffset + accessor.count * accessorByteStride;\n      bufferView.byteLength = Math.max(\n        defaultValue(bufferView.byteLength, 0),\n        accessorByteEnd\n      );\n    }\n  });\n}\n\nfunction moveByteStrideToBufferView(gltf) {\n  let i;\n  let j;\n  let bufferView;\n  const bufferViews = gltf.bufferViews;\n\n  const bufferViewHasVertexAttributes = {};\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (defined(accessor.bufferView)) {\n      bufferViewHasVertexAttributes[accessor.bufferView] = true;\n    }\n  });\n\n  // Map buffer views to a list of accessors\n  const bufferViewMap = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      bufferViewMap[accessor.bufferView] = defaultValue(\n        bufferViewMap[accessor.bufferView],\n        []\n      );\n      bufferViewMap[accessor.bufferView].push(accessor);\n    }\n  });\n\n  // Split accessors with different byte strides\n  for (const bufferViewId in bufferViewMap) {\n    if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n      bufferView = bufferViews[bufferViewId];\n      const accessors = bufferViewMap[bufferViewId];\n      accessors.sort(function (a, b) {\n        return a.byteOffset - b.byteOffset;\n      });\n      let currentByteOffset = 0;\n      let currentIndex = 0;\n      const accessorsLength = accessors.length;\n      for (i = 0; i < accessorsLength; ++i) {\n        let accessor = accessors[i];\n        const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n        const accessorByteOffset = accessor.byteOffset;\n        const accessorByteLength = accessor.count * accessorByteStride;\n        delete accessor.byteStride;\n\n        const hasNextAccessor = i < accessorsLength - 1;\n        const nextAccessorByteStride = hasNextAccessor\n          ? computeAccessorByteStride(gltf, accessors[i + 1])\n          : undefined;\n        if (accessorByteStride !== nextAccessorByteStride) {\n          const newBufferView = clone(bufferView, true);\n          if (bufferViewHasVertexAttributes[bufferViewId]) {\n            newBufferView.byteStride = accessorByteStride;\n          }\n          newBufferView.byteOffset += currentByteOffset;\n          newBufferView.byteLength =\n            accessorByteOffset + accessorByteLength - currentByteOffset;\n          const newBufferViewId = addToArray(bufferViews, newBufferView);\n          for (j = currentIndex; j <= i; ++j) {\n            accessor = accessors[j];\n            accessor.bufferView = newBufferViewId;\n            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n          }\n          // Set current byte offset to next accessor's byte offset\n          currentByteOffset = hasNextAccessor\n            ? accessors[i + 1].byteOffset\n            : undefined;\n          currentIndex = i + 1;\n        }\n      }\n    }\n  }\n\n  // Remove unused buffer views\n  removeUnusedElements(gltf, [\"accessor\", \"bufferView\", \"buffer\"]);\n}\n\nfunction requirePositionAccessorMinMax(gltf) {\n  ForEach.accessorWithSemantic(gltf, \"POSITION\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (!defined(accessor.min) || !defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      accessor.min = minMax.min;\n      accessor.max = minMax.max;\n    }\n  });\n}\n\nfunction isNodeEmpty(node) {\n  return (\n    (!defined(node.children) || node.children.length === 0) &&\n    (!defined(node.meshes) || node.meshes.length === 0) &&\n    !defined(node.camera) &&\n    !defined(node.skin) &&\n    !defined(node.skeletons) &&\n    !defined(node.jointName) &&\n    (!defined(node.translation) ||\n      Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) &&\n    (!defined(node.scale) ||\n      Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) &&\n    (!defined(node.rotation) ||\n      Cartesian4.fromArray(node.rotation).equals(\n        new Cartesian4(0.0, 0.0, 0.0, 1.0)\n      )) &&\n    (!defined(node.matrix) ||\n      Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) &&\n    !defined(node.extensions) &&\n    !defined(node.extras)\n  );\n}\n\nfunction deleteNode(gltf, nodeId) {\n  // Remove from list of nodes in scene\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (let i = sceneNodesLength; i >= 0; --i) {\n        if (sceneNodes[i] === nodeId) {\n          sceneNodes.splice(i, 1);\n          return;\n        }\n      }\n    }\n  });\n\n  // Remove parent node's reference to this node, and delete the parent if also empty\n  ForEach.node(gltf, function (parentNode, parentNodeId) {\n    if (defined(parentNode.children)) {\n      const index = parentNode.children.indexOf(nodeId);\n      if (index > -1) {\n        parentNode.children.splice(index, 1);\n\n        if (isNodeEmpty(parentNode)) {\n          deleteNode(gltf, parentNodeId);\n        }\n      }\n    }\n  });\n\n  delete gltf.nodes[nodeId];\n}\n\nfunction removeEmptyNodes(gltf) {\n  ForEach.node(gltf, function (node, nodeId) {\n    if (isNodeEmpty(node)) {\n      deleteNode(gltf, nodeId);\n    }\n  });\n\n  return gltf;\n}\n\nfunction requireAnimationAccessorMinMax(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      const accessor = gltf.accessors[sampler.input];\n      if (!defined(accessor.min) || !defined(accessor.max)) {\n        const minMax = findAccessorMinMax(gltf, accessor);\n        accessor.min = minMax.min;\n        accessor.max = minMax.max;\n      }\n    });\n  });\n}\n\nfunction validatePresentAccessorMinMax(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.min) || defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      if (defined(accessor.min)) {\n        accessor.min = minMax.min;\n      }\n      if (defined(accessor.max)) {\n        accessor.max = minMax.max;\n      }\n    }\n  });\n}\n\nfunction glTF10to20(gltf) {\n  gltf.asset = defaultValue(gltf.asset, {});\n  gltf.asset.version = \"2.0\";\n  // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n  updateInstanceTechniques(gltf);\n  // animation.samplers now refers directly to accessors and animation.parameters should be removed\n  removeAnimationSamplersIndirection(gltf);\n  // Remove empty nodes and re-assign referencing indices\n  removeEmptyNodes(gltf);\n  // Top-level objects are now arrays referenced by index instead of id\n  objectsToArrays(gltf);\n  // Animation.sampler objects cannot have names\n  removeAnimationSamplerNames(gltf);\n  // asset.profile no longer exists\n  stripAsset(gltf);\n  // Move known extensions from extensionsUsed to extensionsRequired\n  requireKnownExtensions(gltf);\n  // bufferView.byteLength and buffer.byteLength are required\n  requireByteLength(gltf);\n  // byteStride moved from accessor to bufferView\n  moveByteStrideToBufferView(gltf);\n  // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n  requirePositionAccessorMinMax(gltf);\n  // An animation sampler's input accessor must have min and max properties defined\n  requireAnimationAccessorMinMax(gltf);\n  // When an acccessor has a min- or max, then it is recomputed, to capture the actual\n  // value, and not use the (possibly imprecise) value from the input\n  validatePresentAccessorMinMax(gltf);\n  // buffer.type is unnecessary and should be removed\n  removeBufferType(gltf);\n  // Remove format, internalFormat, target, and type\n  removeTextureProperties(gltf);\n  // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n  requireAttributeSetIndex(gltf);\n  // Add underscores to application-specific parameters\n  underscoreApplicationSpecificSemantics(gltf);\n  // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n  updateAccessorComponentTypes(gltf);\n  // Clamp camera parameters\n  clampCameraParameters(gltf);\n  // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n  moveTechniqueRenderStates(gltf);\n  // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n  moveTechniquesToExtension(gltf);\n  // Remove empty arrays\n  removeEmptyArrays(gltf);\n}\n\n// It's not possible to upgrade glTF 1.0 shaders to 2.0 PBR materials in a generic way,\n// but we can look for certain uniform names that are commonly found in glTF 1.0 assets\n// and create PBR materials out of those.\nconst defaultBaseColorTextureNames = [\n  \"u_tex\",\n  \"u_diffuse\",\n  \"u_emission\",\n  \"u_diffuse_tex\",\n];\nconst defaultBaseColorFactorNames = [\"u_diffuse\", \"u_diffuse_mat\"];\n\nfunction initializePbrMaterial(material) {\n  material.pbrMetallicRoughness = defined(material.pbrMetallicRoughness)\n    ? material.pbrMetallicRoughness\n    : {};\n\n  material.pbrMetallicRoughness.roughnessFactor = 1.0;\n  material.pbrMetallicRoughness.metallicFactor = 0.0;\n}\n\nfunction isTexture(value) {\n  return defined(value.index);\n}\n\nfunction isVec4(value) {\n  return Array.isArray(value) && value.length === 4;\n}\n\nfunction srgbToLinear(srgb) {\n  const linear = new Array(4);\n  linear[3] = srgb[3];\n\n  for (let i = 0; i < 3; i++) {\n    const c = srgb[i];\n    if (c <= 0.04045) {\n      // eslint-disable-next-line no-loss-of-precision\n      linear[i] = srgb[i] * 0.07739938080495356037151702786378;\n    } else {\n      linear[i] = Math.pow(\n        // eslint-disable-next-line no-loss-of-precision\n        (c + 0.055) * 0.94786729857819905213270142180095,\n        2.4\n      );\n    }\n  }\n\n  return linear;\n}\n\nfunction convertTechniquesToPbr(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const baseColorTextureNames = defaultValue(\n    options.baseColorTextureNames,\n    defaultBaseColorTextureNames\n  );\n  const baseColorFactorNames = defaultValue(\n    options.baseColorFactorNames,\n    defaultBaseColorFactorNames\n  );\n\n  // Future work: convert other values like emissive, specular, etc. Only handling diffuse right now.\n  ForEach.material(gltf, function (material) {\n    ForEach.materialValue(material, function (value, name) {\n      if (baseColorTextureNames.indexOf(name) !== -1 && isTexture(value)) {\n        initializePbrMaterial(material);\n        material.pbrMetallicRoughness.baseColorTexture = value;\n      } else if (baseColorFactorNames.indexOf(name) !== -1 && isVec4(value)) {\n        initializePbrMaterial(material);\n        material.pbrMetallicRoughness.baseColorFactor = srgbToLinear(value);\n      }\n    });\n  });\n\n  removeExtension(gltf, \"KHR_techniques_webgl\");\n  removeExtension(gltf, \"KHR_blend\");\n}\n\nfunction assignAsBaseColor(material, baseColor) {\n  if (defined(baseColor)) {\n    if (isVec4(baseColor)) {\n      material.pbrMetallicRoughness.baseColorFactor = srgbToLinear(baseColor);\n    } else if (isTexture(baseColor)) {\n      material.pbrMetallicRoughness.baseColorTexture = baseColor;\n    }\n  }\n}\n\nfunction assignAsEmissive(material, emissive) {\n  if (defined(emissive)) {\n    if (isVec4(emissive)) {\n      material.emissiveFactor = emissive.slice(0, 3);\n    } else if (isTexture(emissive)) {\n      material.emissiveTexture = emissive;\n    }\n  }\n}\n\nfunction convertMaterialsCommonToPbr(gltf) {\n  // Future work: convert KHR_materials_common lights to KHR_lights_punctual\n  ForEach.material(gltf, function (material) {\n    const materialsCommon = defaultValue(\n      material.extensions,\n      defaultValue.EMPTY_OBJECT\n    ).KHR_materials_common;\n    if (!defined(materialsCommon)) {\n      // Nothing to do\n      return;\n    }\n\n    const values = defaultValue(materialsCommon.values, {});\n    const ambient = values.ambient;\n    const diffuse = values.diffuse;\n    const emission = values.emission;\n    const transparency = values.transparency;\n\n    // These actually exist on the extension object, not the values object despite what's shown in the spec\n    const doubleSided = materialsCommon.doubleSided;\n    const transparent = materialsCommon.transparent;\n\n    // Ignore specular and shininess for now because the conversion to PBR\n    // isn't straightforward and depends on the technique\n    initializePbrMaterial(material);\n\n    const technique = materialsCommon.technique;\n    if (technique === \"CONSTANT\") {\n      // Add the KHR_materials_unlit extension\n      addExtensionsUsed(gltf, \"KHR_materials_unlit\");\n      material.extensions = defined(material.extensions)\n        ? material.extensions\n        : {};\n      material.extensions[\"KHR_materials_unlit\"] = {};\n\n      // The CONSTANT technique does not support 'diffuse', so\n      // assign either the 'emission' or the 'ambient' as the\n      // base color\n      assignAsBaseColor(material, emission);\n      assignAsBaseColor(material, ambient);\n    } else {\n      // Assign the 'diffuse' as the base color, and\n      // the 'ambient' or 'emissive' as the emissive\n      // part if they are present.\n      assignAsBaseColor(material, diffuse);\n      assignAsEmissive(material, ambient);\n      assignAsEmissive(material, emission);\n    }\n\n    if (defined(doubleSided)) {\n      material.doubleSided = doubleSided;\n    }\n    if (defined(transparency)) {\n      if (defined(material.pbrMetallicRoughness.baseColorFactor)) {\n        material.pbrMetallicRoughness.baseColorFactor[3] *= transparency;\n      } else {\n        material.pbrMetallicRoughness.baseColorFactor = [1, 1, 1, transparency];\n      }\n    }\n    if (defined(transparent)) {\n      material.alphaMode = transparent ? \"BLEND\" : \"OPAQUE\";\n    }\n  });\n\n  removeExtension(gltf, \"KHR_materials_common\");\n}\n\nexport default updateVersion;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}