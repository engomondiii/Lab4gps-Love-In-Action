{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec2 v_textureCoordinates;\\n\\\nconst float M_PI = 3.141592653589793;\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\nvec3 importanceSampleGGX(vec2 xi, float alphaRoughness, vec3 N)\\n\\\n{\\n\\\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\\n\\\n    float phi = 2.0 * M_PI * xi.x;\\n\\\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (alphaRoughnessSquared - 1.0) * xi.y));\\n\\\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\\n\\\n    vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n\\\n    vec3 tangentX = normalize(cross(upVector, N));\\n\\\n    vec3 tangentY = cross(N, tangentX);\\n\\\n    return tangentX * H.x + tangentY * H.y + N * H.z;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Estimate the geometric self-shadowing of the microfacets in a surface,\\n\\\n * using the Smith Joint GGX visibility function.\\n\\\n * Note: Vis = G / (4 * NdotL * NdotV)\\n\\\n * see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\\n\\\n * see Real-Time Rendering. Page 331 to 336.\\n\\\n * see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\\n\\\n *\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @param {float} NdotL The cosine of the angle between the surface normal and the direction to the light source.\\n\\\n * @param {float} NdotV The cosine of the angle between the surface normal and the direction to the camera.\\n\\\n */\\n\\\nfloat smithVisibilityGGX(float alphaRoughness, float NdotL, float NdotV)\\n\\\n{\\n\\\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\\n\\\n\\n\\\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n\\n\\\n    float GGX = GGXV + GGXL; // 2.0 if NdotL = NdotV = 1.0\\n\\\n    if (GGX > 0.0)\\n\\\n    {\\n\\\n        return 0.5 / GGX; // 1/4 if NdotL = NdotV = 1.0\\n\\\n    }\\n\\\n    return 0.0;\\n\\\n}\\n\\\n\\n\\\nvec2 integrateBrdf(float roughness, float NdotV)\\n\\\n{\\n\\\n    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);\\n\\\n    float A = 0.0;\\n\\\n    float B = 0.0;\\n\\\n    const int NumSamples = 1024;\\n\\\n    float alphaRoughness = roughness * roughness;\\n\\\n    for (int i = 0; i < NumSamples; i++)\\n\\\n    {\\n\\\n        vec2 xi = hammersley2D(i, NumSamples);\\n\\\n        vec3 H = importanceSampleGGX(xi, alphaRoughness, vec3(0.0, 0.0, 1.0));\\n\\\n        vec3 L = 2.0 * dot(V, H) * H - V;\\n\\\n        float NdotL = clamp(L.z, 0.0, 1.0);\\n\\\n        float NdotH = clamp(H.z, 0.0, 1.0);\\n\\\n        float VdotH = clamp(dot(V, H), 0.0, 1.0);\\n\\\n        if (NdotL > 0.0)\\n\\\n        {\\n\\\n            float G = smithVisibilityGGX(alphaRoughness, NdotL, NdotV);\\n\\\n            float G_Vis = 4.0 * G * VdotH * NdotL / NdotH;\\n\\\n            float Fc = pow(1.0 - VdotH, 5.0);\\n\\\n            A += (1.0 - Fc) * G_Vis;\\n\\\n            B += Fc * G_Vis;\\n\\\n        }\\n\\\n    }\\n\\\n    return vec2(A, B) / float(NumSamples);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    out_FragColor = vec4(integrateBrdf(v_textureCoordinates.y, v_textureCoordinates.x), 0.0, 1.0);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/BrdfLutGeneratorFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec2 v_textureCoordinates;\\n\\\nconst float M_PI = 3.141592653589793;\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\nvec3 importanceSampleGGX(vec2 xi, float alphaRoughness, vec3 N)\\n\\\n{\\n\\\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\\n\\\n    float phi = 2.0 * M_PI * xi.x;\\n\\\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (alphaRoughnessSquared - 1.0) * xi.y));\\n\\\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\\n\\\n    vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n\\\n    vec3 tangentX = normalize(cross(upVector, N));\\n\\\n    vec3 tangentY = cross(N, tangentX);\\n\\\n    return tangentX * H.x + tangentY * H.y + N * H.z;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Estimate the geometric self-shadowing of the microfacets in a surface,\\n\\\n * using the Smith Joint GGX visibility function.\\n\\\n * Note: Vis = G / (4 * NdotL * NdotV)\\n\\\n * see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\\n\\\n * see Real-Time Rendering. Page 331 to 336.\\n\\\n * see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\\n\\\n *\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @param {float} NdotL The cosine of the angle between the surface normal and the direction to the light source.\\n\\\n * @param {float} NdotV The cosine of the angle between the surface normal and the direction to the camera.\\n\\\n */\\n\\\nfloat smithVisibilityGGX(float alphaRoughness, float NdotL, float NdotV)\\n\\\n{\\n\\\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\\n\\\n\\n\\\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n\\n\\\n    float GGX = GGXV + GGXL; // 2.0 if NdotL = NdotV = 1.0\\n\\\n    if (GGX > 0.0)\\n\\\n    {\\n\\\n        return 0.5 / GGX; // 1/4 if NdotL = NdotV = 1.0\\n\\\n    }\\n\\\n    return 0.0;\\n\\\n}\\n\\\n\\n\\\nvec2 integrateBrdf(float roughness, float NdotV)\\n\\\n{\\n\\\n    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);\\n\\\n    float A = 0.0;\\n\\\n    float B = 0.0;\\n\\\n    const int NumSamples = 1024;\\n\\\n    float alphaRoughness = roughness * roughness;\\n\\\n    for (int i = 0; i < NumSamples; i++)\\n\\\n    {\\n\\\n        vec2 xi = hammersley2D(i, NumSamples);\\n\\\n        vec3 H = importanceSampleGGX(xi, alphaRoughness, vec3(0.0, 0.0, 1.0));\\n\\\n        vec3 L = 2.0 * dot(V, H) * H - V;\\n\\\n        float NdotL = clamp(L.z, 0.0, 1.0);\\n\\\n        float NdotH = clamp(H.z, 0.0, 1.0);\\n\\\n        float VdotH = clamp(dot(V, H), 0.0, 1.0);\\n\\\n        if (NdotL > 0.0)\\n\\\n        {\\n\\\n            float G = smithVisibilityGGX(alphaRoughness, NdotL, NdotV);\\n\\\n            float G_Vis = 4.0 * G * VdotH * NdotL / NdotH;\\n\\\n            float Fc = pow(1.0 - VdotH, 5.0);\\n\\\n            A += (1.0 - Fc) * G_Vis;\\n\\\n            B += Fc * G_Vis;\\n\\\n        }\\n\\\n    }\\n\\\n    return vec2(A, B) / float(NumSamples);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    out_FragColor = vec4(integrateBrdf(v_textureCoordinates.y, v_textureCoordinates.x), 0.0, 1.0);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}