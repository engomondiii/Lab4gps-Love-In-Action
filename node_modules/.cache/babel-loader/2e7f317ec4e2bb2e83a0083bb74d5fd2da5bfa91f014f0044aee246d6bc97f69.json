{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"bitmap-sdf\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"grapheme-splitter\";\n\n// A glyph represents a single character in a particular label.  It may or may\n// not have a billboard, depending on whether the texture info has an index into\n// the the label collection's texture atlas.  Invisible characters have no texture, and\n// no billboard.  However, it always has a valid dimensions object.\nfunction Glyph() {\n  this.textureInfo = undefined;\n  this.dimensions = undefined;\n  this.billboard = undefined;\n}\n\n// GlyphTextureInfo represents a single character, drawn in a particular style,\n// shared and reference counted across all labels.  It may or may not have an\n// index into the label collection's texture atlas, depending on whether the character\n// has both width and height, but it always has a valid dimensions object.\nfunction GlyphTextureInfo(labelCollection, index, dimensions) {\n  this.labelCollection = labelCollection;\n  this.index = index;\n  this.dimensions = dimensions;\n}\n\n// Traditionally, leading is %20 of the font size.\nconst defaultLineSpacingPercent = 1.2;\nconst whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nconst whitePixelSize = new Cartesian2(4, 4);\nconst whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\nfunction addWhitePixelCanvas(textureAtlas) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = whitePixelSize.x;\n  canvas.height = whitePixelSize.y;\n  const context2D = canvas.getContext(\"2d\");\n  context2D.fillStyle = \"#fff\";\n  context2D.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Canvas operations take a frame to draw. Use the asynchronous add function which resolves a promise and allows the draw to complete,\n  // but there's no need to wait on the promise before operation can continue\n  return textureAtlas.addImage(whitePixelCanvasId, canvas);\n}\n\n// reusable object for calling writeTextToCanvas\nconst writeTextToCanvasParameters = {};\nfunction createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style, verticalOrigin) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth;\n  // Setting the padding to something bigger is necessary to get enough space for the outlining.\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n  if (verticalOrigin === VerticalOrigin.CENTER) {\n    writeTextToCanvasParameters.textBaseline = \"middle\";\n  } else if (verticalOrigin === VerticalOrigin.TOP) {\n    writeTextToCanvasParameters.textBaseline = \"top\";\n  } else {\n    // VerticalOrigin.BOTTOM and VerticalOrigin.BASELINE\n    writeTextToCanvasParameters.textBaseline = \"bottom\";\n  }\n  writeTextToCanvasParameters.fill = style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke = style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\nfunction unbindGlyph(labelCollection, glyph) {\n  glyph.textureInfo = undefined;\n  glyph.dimensions = undefined;\n  const billboard = glyph.billboard;\n  if (defined(billboard)) {\n    billboard.show = false;\n    billboard.image = undefined;\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n      billboard._removeCallbackFunc = undefined;\n    }\n    labelCollection._spareBillboards.push(billboard);\n    glyph.billboard = undefined;\n  }\n}\nfunction addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {\n  glyphTextureInfo.index = textureAtlas.addImageSync(id, canvas);\n}\nconst splitter = new GraphemeSplitter();\nfunction rebindAllGlyphs(labelCollection, label) {\n  const text = label._renderedText;\n  const graphemes = splitter.splitGraphemes(text);\n  const textLength = graphemes.length;\n  const glyphs = label._glyphs;\n  const glyphsLength = glyphs.length;\n  let glyph;\n  let glyphIndex;\n  let textIndex;\n\n  // Compute a font size scale relative to the sdf font generated size.\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE;\n\n  // if we have more glyphs than needed, unbind the extras.\n  if (textLength < glyphsLength) {\n    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyph(labelCollection, glyphs[glyphIndex]);\n    }\n  }\n\n  // presize glyphs to match the new text length\n  glyphs.length = textLength;\n  const showBackground = label.show && label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  let backgroundBillboard = label._backgroundBillboard;\n  const backgroundBillboardCollection = labelCollection._backgroundBillboardCollection;\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = backgroundBillboardCollection.add({\n        collection: labelCollection,\n        image: whitePixelCanvasId,\n        imageSubRegion: whitePixelBoundingRegion\n      });\n      label._backgroundBillboard = backgroundBillboard;\n    }\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition = label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance = label._disableDepthTestDistance;\n    backgroundBillboard.clusterShow = label.clusterShow;\n  }\n  const glyphTextureCache = labelCollection._glyphTextureCache;\n\n  // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n  for (textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = graphemes[textIndex];\n    const verticalOrigin = label._verticalOrigin;\n    const id = JSON.stringify([character, label._fontFamily, label._fontStyle, label._fontWeight, +verticalOrigin]);\n    let glyphTextureInfo = glyphTextureCache[id];\n    if (!defined(glyphTextureInfo)) {\n      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings.FONT_SIZE}px ${label._fontFamily}`;\n      const canvas = createGlyphCanvas(character, glyphFont, Color.WHITE, Color.WHITE, 0.0, LabelStyle.FILL, verticalOrigin);\n      glyphTextureInfo = new GlyphTextureInfo(labelCollection, -1, canvas.dimensions);\n      glyphTextureCache[id] = glyphTextureInfo;\n      if (canvas.width > 0 && canvas.height > 0) {\n        const sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS\n        });\n\n        // Context is originally created in writeTextToCanvas()\n        const ctx = canvas.getContext(\"2d\");\n        const canvasWidth = canvas.width;\n        const canvasHeight = canvas.height;\n        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        for (let i = 0; i < canvasWidth; i++) {\n          for (let j = 0; j < canvasHeight; j++) {\n            const baseIndex = j * canvasWidth + i;\n            const alpha = sdfValues[baseIndex] * 255;\n            const imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        if (character !== \" \") {\n          addGlyphToTextureAtlas(labelCollection._textureAtlas, id, canvas, glyphTextureInfo);\n        }\n      }\n    }\n    glyph = glyphs[textIndex];\n    if (defined(glyph)) {\n      // clean up leftover information from the previous glyph\n      if (glyphTextureInfo.index === -1) {\n        // no texture, and therefore no billboard, for this glyph.\n        // so, completely unbind glyph.\n        unbindGlyph(labelCollection, glyph);\n      } else if (defined(glyph.textureInfo)) {\n        // we have a texture and billboard.  If we had one before, release\n        // our reference to that texture info, but reuse the billboard.\n        glyph.textureInfo = undefined;\n      }\n    } else {\n      // create a glyph object\n      glyph = new Glyph();\n      glyphs[textIndex] = glyph;\n    }\n    glyph.textureInfo = glyphTextureInfo;\n    glyph.dimensions = glyphTextureInfo.dimensions;\n\n    // if we have a texture, configure the existing billboard, or obtain one\n    if (glyphTextureInfo.index !== -1) {\n      let billboard = glyph.billboard;\n      const spareBillboards = labelCollection._spareBillboards;\n      if (!defined(billboard)) {\n        if (spareBillboards.length > 0) {\n          billboard = spareBillboards.pop();\n        } else {\n          billboard = labelCollection._billboardCollection.add({\n            collection: labelCollection\n          });\n          billboard._labelDimensions = new Cartesian2();\n          billboard._labelTranslate = new Cartesian2();\n        }\n        glyph.billboard = billboard;\n      }\n      billboard.show = label._show;\n      billboard.position = label._position;\n      billboard.eyeOffset = label._eyeOffset;\n      billboard.pixelOffset = label._pixelOffset;\n      billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n      billboard.verticalOrigin = label._verticalOrigin;\n      billboard.heightReference = label._heightReference;\n      billboard.scale = label.totalScale;\n      billboard.pickPrimitive = label;\n      billboard.id = label._id;\n      billboard.image = id;\n      billboard.translucencyByDistance = label._translucencyByDistance;\n      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n      billboard.scaleByDistance = label._scaleByDistance;\n      billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n      billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n      billboard._batchIndex = label._batchIndex;\n      billboard.outlineColor = label.outlineColor;\n      if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = label.outlineWidth;\n      } else if (label.style === LabelStyle.FILL) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = 0.0;\n      } else if (label.style === LabelStyle.OUTLINE) {\n        billboard.color = Color.TRANSPARENT;\n        billboard.outlineWidth = label.outlineWidth;\n      }\n    }\n  }\n\n  // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n  label._repositionAllGlyphs = true;\n}\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n  return backgroundPadding.x;\n}\n\n// reusable Cartesian2 instances\nconst glyphPixelOffset = new Cartesian2();\nconst scratchBackgroundPadding = new Cartesian2();\nfunction repositionAllGlyphs(label) {\n  const glyphs = label._glyphs;\n  const text = label._renderedText;\n  let glyph;\n  let dimensions;\n  let lastLineWidth = 0;\n  let maxLineWidth = 0;\n  const lineWidths = [];\n  let maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  let maxGlyphY = 0;\n  let numberOfLines = 1;\n  let glyphIndex;\n  const glyphLength = glyphs.length;\n  const backgroundBillboard = label._backgroundBillboard;\n  const backgroundPadding = Cartesian2.clone(defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO, scratchBackgroundPadding);\n\n  // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);\n\n      //Computing the line width must also account for the kerning that occurs between letters.\n      lastLineWidth += dimensions.width - dimensions.minx;\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;\n      }\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n  lineWidths.push(lastLineWidth);\n  const maxLineHeight = maxGlyphY + maxGlyphDescent;\n  const scale = label.totalScale;\n  const horizontalOrigin = label._horizontalOrigin;\n  const verticalOrigin = label._verticalOrigin;\n  let lineIndex = 0;\n  let lineWidth = lineWidths[lineIndex];\n  let widthOffset = calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding);\n  const lineSpacing = (defined(label._lineHeight) ? label._lineHeight : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;\n  const otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  let totalLineWidth = maxLineWidth;\n  let totalLineHeight = maxLineHeight + otherLinesHeight;\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n  let firstCharOfLine = true;\n  let lineOffsetY = 0;\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding);\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y = dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y = (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y = otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n      glyphPixelOffset.y = (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;\n\n      // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      }\n\n      //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n      if (glyphIndex < glyphLength - 1) {\n        const nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x += (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) * scale;\n      }\n    }\n  }\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n    glyphPixelOffset.x = widthOffset * scale;\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n    backgroundBillboard._labelTranslate = Cartesian2.clone(glyphPixelOffset, backgroundBillboard._labelTranslate);\n  }\n  if (isHeightReferenceClamp(label.heightReference)) {\n    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      glyph = glyphs[glyphIndex];\n      const billboard = glyph.billboard;\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(glyphPixelOffset, billboard._labelTranslate);\n      }\n    }\n  }\n}\nfunction destroyLabel(labelCollection, label) {\n  const glyphs = label._glyphs;\n  for (let i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyph(labelCollection, glyphs[i]);\n  }\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(label._backgroundBillboard);\n    label._backgroundBillboard = undefined;\n  }\n  label._labelCollection = undefined;\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n  destroyObject(label);\n}\n\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the labels in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\nfunction LabelCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n  this._textureAtlas = undefined;\n  this._backgroundTextureAtlas = undefined;\n  this._backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene\n  });\n  this._backgroundBillboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable\n  });\n  this._billboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection._sdf = true;\n  this._spareBillboards = [];\n  this._glyphTextureCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * Determines if labels in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(options.blendOption, BlendOption.OPAQUE_AND_TRANSLUCENT);\n}\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    }\n  }\n});\n\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Label.ConstructorOptions} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * const l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\nLabelCollection.prototype.add = function (options) {\n  const label = new Label(options, this);\n  this._labels.push(label);\n  this._labelsToUpdate.push(label);\n  return label;\n};\n\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    const index = this._labels.indexOf(label);\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\nLabelCollection.prototype.removeAll = function () {\n  const labels = this._labels;\n  for (let i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n  labels.length = 0;\n};\n\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._labels[index];\n};\n\n/**\n * @private\n *\n */\nLabelCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n  const billboardCollection = this._billboardCollection;\n  const backgroundBillboardCollection = this._backgroundBillboardCollection;\n  billboardCollection.modelMatrix = this.modelMatrix;\n  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  const context = frameState.context;\n  if (!defined(this._textureAtlas)) {\n    this._textureAtlas = new TextureAtlas({\n      context: context\n    });\n    billboardCollection.textureAtlas = this._textureAtlas;\n  }\n  if (!defined(this._backgroundTextureAtlas)) {\n    this._backgroundTextureAtlas = new TextureAtlas({\n      context: context,\n      initialSize: whitePixelSize\n    });\n    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;\n\n    // Request a new render in request render mode after the next frame renders\n    addWhitePixelCanvas(this._backgroundTextureAtlas);\n  }\n  const len = this._labelsToUpdate.length;\n  for (let i = 0; i < len; ++i) {\n    const label = this._labelsToUpdate[i];\n    if (label.isDestroyed()) {\n      continue;\n    }\n    const preUpdateGlyphCount = label._glyphs.length;\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n  const blendOption = backgroundBillboardCollection.length > 0 ? BlendOption.TRANSLUCENT : this.blendOption;\n  billboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n  billboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  billboardCollection.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._billboardCollection = this._billboardCollection.destroy();\n  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();\n  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();\n  this._backgroundTextureAtlas = this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();\n  return destroyObject(this);\n};\nexport default LabelCollection;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Color","defaultValue","defined","destroyObject","DeveloperError","Matrix4","writeTextToCanvas","bitmapSDF","BillboardCollection","BlendOption","isHeightReferenceClamp","HorizontalOrigin","Label","LabelStyle","SDFSettings","TextureAtlas","VerticalOrigin","GraphemeSplitter","Glyph","textureInfo","undefined","dimensions","billboard","GlyphTextureInfo","labelCollection","index","defaultLineSpacingPercent","whitePixelCanvasId","whitePixelSize","whitePixelBoundingRegion","addWhitePixelCanvas","textureAtlas","canvas","document","createElement","width","x","height","y","context2D","getContext","fillStyle","fillRect","addImage","writeTextToCanvasParameters","createGlyphCanvas","character","font","fillColor","outlineColor","outlineWidth","style","verticalOrigin","strokeColor","strokeWidth","padding","PADDING","CENTER","textBaseline","TOP","fill","FILL","FILL_AND_OUTLINE","stroke","OUTLINE","backgroundColor","BLACK","unbindGlyph","glyph","show","image","_removeCallbackFunc","_spareBillboards","push","addGlyphToTextureAtlas","id","glyphTextureInfo","addImageSync","splitter","rebindAllGlyphs","label","text","_renderedText","graphemes","splitGraphemes","textLength","length","glyphs","_glyphs","glyphsLength","glyphIndex","textIndex","_relativeSize","_fontSize","FONT_SIZE","showBackground","_showBackground","split","join","backgroundBillboard","_backgroundBillboard","backgroundBillboardCollection","_backgroundBillboardCollection","remove","add","collection","imageSubRegion","color","_backgroundColor","_show","position","_position","eyeOffset","_eyeOffset","pixelOffset","_pixelOffset","horizontalOrigin","LEFT","_verticalOrigin","heightReference","_heightReference","scale","totalScale","pickPrimitive","_id","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","scaleByDistance","_scaleByDistance","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","clusterShow","glyphTextureCache","_glyphTextureCache","JSON","stringify","_fontFamily","_fontStyle","_fontWeight","glyphFont","WHITE","sdfValues","cutoff","CUTOFF","radius","RADIUS","ctx","canvasWidth","canvasHeight","imgData","getImageData","i","j","baseIndex","alpha","imageIndex","data","putImageData","_textureAtlas","spareBillboards","pop","_billboardCollection","_labelDimensions","_labelTranslate","_batchIndex","_fillColor","TRANSPARENT","_repositionAllGlyphs","calculateWidthOffset","lineWidth","backgroundPadding","RIGHT","glyphPixelOffset","scratchBackgroundPadding","repositionAllGlyphs","lastLineWidth","maxLineWidth","lineWidths","maxGlyphDescent","Number","NEGATIVE_INFINITY","maxGlyphY","numberOfLines","glyphLength","clone","_backgroundPadding","ZERO","charAt","Math","max","descent","minx","maxLineHeight","_horizontalOrigin","lineIndex","widthOffset","lineSpacing","_lineHeight","otherLinesHeight","totalLineWidth","totalLineHeight","_labelHorizontalOrigin","firstCharOfLine","lineOffsetY","BASELINE","_setTranslate","nextGlyph","destroyLabel","len","_labelCollection","LabelCollection","options","EMPTY_OBJECT","_scene","scene","_batchTable","batchTable","_backgroundTextureAtlas","destroyTextureAtlas","_sdf","_labels","_labelsToUpdate","_totalGlyphCount","_highlightColor","modelMatrix","IDENTITY","debugShowBoundingVolume","blendOption","OPAQUE_AND_TRANSLUCENT","Object","defineProperties","prototype","get","indexOf","splice","removeAll","labels","contains","update","frameState","billboardCollection","context","initialSize","isDestroyed","preUpdateGlyphCount","_rebindAllGlyphs","glyphCountDifference","TRANSLUCENT","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/LabelCollection.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"bitmap-sdf\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"grapheme-splitter\";\n\n// A glyph represents a single character in a particular label.  It may or may\n// not have a billboard, depending on whether the texture info has an index into\n// the the label collection's texture atlas.  Invisible characters have no texture, and\n// no billboard.  However, it always has a valid dimensions object.\nfunction Glyph() {\n  this.textureInfo = undefined;\n  this.dimensions = undefined;\n  this.billboard = undefined;\n}\n\n// GlyphTextureInfo represents a single character, drawn in a particular style,\n// shared and reference counted across all labels.  It may or may not have an\n// index into the label collection's texture atlas, depending on whether the character\n// has both width and height, but it always has a valid dimensions object.\nfunction GlyphTextureInfo(labelCollection, index, dimensions) {\n  this.labelCollection = labelCollection;\n  this.index = index;\n  this.dimensions = dimensions;\n}\n\n// Traditionally, leading is %20 of the font size.\nconst defaultLineSpacingPercent = 1.2;\nconst whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nconst whitePixelSize = new Cartesian2(4, 4);\nconst whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\n\nfunction addWhitePixelCanvas(textureAtlas) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = whitePixelSize.x;\n  canvas.height = whitePixelSize.y;\n\n  const context2D = canvas.getContext(\"2d\");\n  context2D.fillStyle = \"#fff\";\n  context2D.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Canvas operations take a frame to draw. Use the asynchronous add function which resolves a promise and allows the draw to complete,\n  // but there's no need to wait on the promise before operation can continue\n  return textureAtlas.addImage(whitePixelCanvasId, canvas);\n}\n\n// reusable object for calling writeTextToCanvas\nconst writeTextToCanvasParameters = {};\nfunction createGlyphCanvas(\n  character,\n  font,\n  fillColor,\n  outlineColor,\n  outlineWidth,\n  style,\n  verticalOrigin,\n) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth;\n  // Setting the padding to something bigger is necessary to get enough space for the outlining.\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n\n  if (verticalOrigin === VerticalOrigin.CENTER) {\n    writeTextToCanvasParameters.textBaseline = \"middle\";\n  } else if (verticalOrigin === VerticalOrigin.TOP) {\n    writeTextToCanvasParameters.textBaseline = \"top\";\n  } else {\n    // VerticalOrigin.BOTTOM and VerticalOrigin.BASELINE\n    writeTextToCanvasParameters.textBaseline = \"bottom\";\n  }\n\n  writeTextToCanvasParameters.fill =\n    style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke =\n    style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\n\nfunction unbindGlyph(labelCollection, glyph) {\n  glyph.textureInfo = undefined;\n  glyph.dimensions = undefined;\n\n  const billboard = glyph.billboard;\n  if (defined(billboard)) {\n    billboard.show = false;\n    billboard.image = undefined;\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n      billboard._removeCallbackFunc = undefined;\n    }\n    labelCollection._spareBillboards.push(billboard);\n    glyph.billboard = undefined;\n  }\n}\n\nfunction addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {\n  glyphTextureInfo.index = textureAtlas.addImageSync(id, canvas);\n}\n\nconst splitter = new GraphemeSplitter();\n\nfunction rebindAllGlyphs(labelCollection, label) {\n  const text = label._renderedText;\n  const graphemes = splitter.splitGraphemes(text);\n  const textLength = graphemes.length;\n  const glyphs = label._glyphs;\n  const glyphsLength = glyphs.length;\n\n  let glyph;\n  let glyphIndex;\n  let textIndex;\n\n  // Compute a font size scale relative to the sdf font generated size.\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE;\n\n  // if we have more glyphs than needed, unbind the extras.\n  if (textLength < glyphsLength) {\n    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyph(labelCollection, glyphs[glyphIndex]);\n    }\n  }\n\n  // presize glyphs to match the new text length\n  glyphs.length = textLength;\n\n  const showBackground =\n    label.show && label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  let backgroundBillboard = label._backgroundBillboard;\n  const backgroundBillboardCollection =\n    labelCollection._backgroundBillboardCollection;\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = backgroundBillboardCollection.add({\n        collection: labelCollection,\n        image: whitePixelCanvasId,\n        imageSubRegion: whitePixelBoundingRegion,\n      });\n      label._backgroundBillboard = backgroundBillboard;\n    }\n\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance =\n      label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition =\n      label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance =\n      label._disableDepthTestDistance;\n    backgroundBillboard.clusterShow = label.clusterShow;\n  }\n\n  const glyphTextureCache = labelCollection._glyphTextureCache;\n\n  // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n  for (textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = graphemes[textIndex];\n    const verticalOrigin = label._verticalOrigin;\n\n    const id = JSON.stringify([\n      character,\n      label._fontFamily,\n      label._fontStyle,\n      label._fontWeight,\n      +verticalOrigin,\n    ]);\n\n    let glyphTextureInfo = glyphTextureCache[id];\n    if (!defined(glyphTextureInfo)) {\n      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings.FONT_SIZE}px ${label._fontFamily}`;\n\n      const canvas = createGlyphCanvas(\n        character,\n        glyphFont,\n        Color.WHITE,\n        Color.WHITE,\n        0.0,\n        LabelStyle.FILL,\n        verticalOrigin,\n      );\n\n      glyphTextureInfo = new GlyphTextureInfo(\n        labelCollection,\n        -1,\n        canvas.dimensions,\n      );\n      glyphTextureCache[id] = glyphTextureInfo;\n\n      if (canvas.width > 0 && canvas.height > 0) {\n        const sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS,\n        });\n\n        // Context is originally created in writeTextToCanvas()\n        const ctx = canvas.getContext(\"2d\");\n        const canvasWidth = canvas.width;\n        const canvasHeight = canvas.height;\n        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        for (let i = 0; i < canvasWidth; i++) {\n          for (let j = 0; j < canvasHeight; j++) {\n            const baseIndex = j * canvasWidth + i;\n            const alpha = sdfValues[baseIndex] * 255;\n            const imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        if (character !== \" \") {\n          addGlyphToTextureAtlas(\n            labelCollection._textureAtlas,\n            id,\n            canvas,\n            glyphTextureInfo,\n          );\n        }\n      }\n    }\n\n    glyph = glyphs[textIndex];\n\n    if (defined(glyph)) {\n      // clean up leftover information from the previous glyph\n      if (glyphTextureInfo.index === -1) {\n        // no texture, and therefore no billboard, for this glyph.\n        // so, completely unbind glyph.\n        unbindGlyph(labelCollection, glyph);\n      } else if (defined(glyph.textureInfo)) {\n        // we have a texture and billboard.  If we had one before, release\n        // our reference to that texture info, but reuse the billboard.\n        glyph.textureInfo = undefined;\n      }\n    } else {\n      // create a glyph object\n      glyph = new Glyph();\n      glyphs[textIndex] = glyph;\n    }\n\n    glyph.textureInfo = glyphTextureInfo;\n    glyph.dimensions = glyphTextureInfo.dimensions;\n\n    // if we have a texture, configure the existing billboard, or obtain one\n    if (glyphTextureInfo.index !== -1) {\n      let billboard = glyph.billboard;\n      const spareBillboards = labelCollection._spareBillboards;\n      if (!defined(billboard)) {\n        if (spareBillboards.length > 0) {\n          billboard = spareBillboards.pop();\n        } else {\n          billboard = labelCollection._billboardCollection.add({\n            collection: labelCollection,\n          });\n          billboard._labelDimensions = new Cartesian2();\n          billboard._labelTranslate = new Cartesian2();\n        }\n        glyph.billboard = billboard;\n      }\n\n      billboard.show = label._show;\n      billboard.position = label._position;\n      billboard.eyeOffset = label._eyeOffset;\n      billboard.pixelOffset = label._pixelOffset;\n      billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n      billboard.verticalOrigin = label._verticalOrigin;\n      billboard.heightReference = label._heightReference;\n      billboard.scale = label.totalScale;\n      billboard.pickPrimitive = label;\n      billboard.id = label._id;\n      billboard.image = id;\n      billboard.translucencyByDistance = label._translucencyByDistance;\n      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n      billboard.scaleByDistance = label._scaleByDistance;\n      billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n      billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n      billboard._batchIndex = label._batchIndex;\n      billboard.outlineColor = label.outlineColor;\n      if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = label.outlineWidth;\n      } else if (label.style === LabelStyle.FILL) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = 0.0;\n      } else if (label.style === LabelStyle.OUTLINE) {\n        billboard.color = Color.TRANSPARENT;\n        billboard.outlineWidth = label.outlineWidth;\n      }\n    }\n  }\n\n  // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n  label._repositionAllGlyphs = true;\n}\n\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n  return backgroundPadding.x;\n}\n\n// reusable Cartesian2 instances\nconst glyphPixelOffset = new Cartesian2();\nconst scratchBackgroundPadding = new Cartesian2();\n\nfunction repositionAllGlyphs(label) {\n  const glyphs = label._glyphs;\n  const text = label._renderedText;\n  let glyph;\n  let dimensions;\n  let lastLineWidth = 0;\n  let maxLineWidth = 0;\n  const lineWidths = [];\n  let maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  let maxGlyphY = 0;\n  let numberOfLines = 1;\n  let glyphIndex;\n  const glyphLength = glyphs.length;\n\n  const backgroundBillboard = label._backgroundBillboard;\n  const backgroundPadding = Cartesian2.clone(\n    defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO,\n    scratchBackgroundPadding,\n  );\n\n  // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);\n\n      //Computing the line width must also account for the kerning that occurs between letters.\n      lastLineWidth += dimensions.width - dimensions.minx;\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;\n      }\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n  lineWidths.push(lastLineWidth);\n  const maxLineHeight = maxGlyphY + maxGlyphDescent;\n\n  const scale = label.totalScale;\n  const horizontalOrigin = label._horizontalOrigin;\n  const verticalOrigin = label._verticalOrigin;\n  let lineIndex = 0;\n  let lineWidth = lineWidths[lineIndex];\n  let widthOffset = calculateWidthOffset(\n    lineWidth,\n    horizontalOrigin,\n    backgroundPadding,\n  );\n  const lineSpacing =\n    (defined(label._lineHeight)\n      ? label._lineHeight\n      : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;\n  const otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  let totalLineWidth = maxLineWidth;\n  let totalLineHeight = maxLineHeight + otherLinesHeight;\n\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n\n  let firstCharOfLine = true;\n\n  let lineOffsetY = 0;\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(\n        lineWidth,\n        horizontalOrigin,\n        backgroundPadding,\n      );\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y =\n          dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y =\n          (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y =\n          otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n      glyphPixelOffset.y =\n        (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;\n\n      // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      }\n\n      //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n      if (glyphIndex < glyphLength - 1) {\n        const nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x +=\n          (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) *\n          scale;\n      }\n    }\n  }\n\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n    glyphPixelOffset.x = widthOffset * scale;\n\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n    backgroundBillboard._labelTranslate = Cartesian2.clone(\n      glyphPixelOffset,\n      backgroundBillboard._labelTranslate,\n    );\n  }\n\n  if (isHeightReferenceClamp(label.heightReference)) {\n    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      glyph = glyphs[glyphIndex];\n      const billboard = glyph.billboard;\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(\n          glyphPixelOffset,\n          billboard._labelTranslate,\n        );\n      }\n    }\n  }\n}\n\nfunction destroyLabel(labelCollection, label) {\n  const glyphs = label._glyphs;\n  for (let i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyph(labelCollection, glyphs[i]);\n  }\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(\n      label._backgroundBillboard,\n    );\n    label._backgroundBillboard = undefined;\n  }\n  label._labelCollection = undefined;\n\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n\n  destroyObject(label);\n}\n\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the labels in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\nfunction LabelCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  this._textureAtlas = undefined;\n  this._backgroundTextureAtlas = undefined;\n\n  this._backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n  });\n  this._backgroundBillboardCollection.destroyTextureAtlas = false;\n\n  this._billboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable,\n  });\n  this._billboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection._sdf = true;\n\n  this._spareBillboards = [];\n  this._glyphTextureCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * Determines if labels in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false,\n  );\n\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT,\n  );\n}\n\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    },\n  },\n});\n\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Label.ConstructorOptions} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * const l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\nLabelCollection.prototype.add = function (options) {\n  const label = new Label(options, this);\n\n  this._labels.push(label);\n  this._labelsToUpdate.push(label);\n\n  return label;\n};\n\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    const index = this._labels.indexOf(label);\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\nLabelCollection.prototype.removeAll = function () {\n  const labels = this._labels;\n\n  for (let i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n\n  labels.length = 0;\n};\n\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._labels[index];\n};\n\n/**\n * @private\n *\n */\nLabelCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  const billboardCollection = this._billboardCollection;\n  const backgroundBillboardCollection = this._backgroundBillboardCollection;\n\n  billboardCollection.modelMatrix = this.modelMatrix;\n  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume =\n    this.debugShowBoundingVolume;\n\n  const context = frameState.context;\n\n  if (!defined(this._textureAtlas)) {\n    this._textureAtlas = new TextureAtlas({\n      context: context,\n    });\n    billboardCollection.textureAtlas = this._textureAtlas;\n  }\n\n  if (!defined(this._backgroundTextureAtlas)) {\n    this._backgroundTextureAtlas = new TextureAtlas({\n      context: context,\n      initialSize: whitePixelSize,\n    });\n    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;\n\n    // Request a new render in request render mode after the next frame renders\n    addWhitePixelCanvas(this._backgroundTextureAtlas);\n  }\n\n  const len = this._labelsToUpdate.length;\n  for (let i = 0; i < len; ++i) {\n    const label = this._labelsToUpdate[i];\n    if (label.isDestroyed()) {\n      continue;\n    }\n\n    const preUpdateGlyphCount = label._glyphs.length;\n\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n\n    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n\n  const blendOption =\n    backgroundBillboardCollection.length > 0\n      ? BlendOption.TRANSLUCENT\n      : this.blendOption;\n  billboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n\n  billboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  billboardCollection.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._billboardCollection = this._billboardCollection.destroy();\n  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();\n  this._backgroundBillboardCollection =\n    this._backgroundBillboardCollection.destroy();\n  this._backgroundTextureAtlas =\n    this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();\n\n  return destroyObject(this);\n};\nexport default LabelCollection;\n"],"mappings":"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AC9B3L,YAAY,CAACsN,OAAO,CAACa,WAAW,EAAE/N,OAAO,CAACgO,QAAQ,CACpD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,uBAAuB,GAAGrO,YAAY,CACzCsN,OAAO,CAACe,uBAAuB,EAC/B,KACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAGtO,YAAY,CAC7BsN,OAAO,CAACgB,WAAW,EACnB9N,WAAW,CAAC+N,sBACd,CAAC;AACH;AAEAC,MAAM,CAACC,gBAAgB,CAACpB,eAAe,CAACqB,SAAS,EAAE;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;EACErJ,MAAM,EAAE;IACNsJ,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACZ,OAAO,CAAC1I,MAAM;IAC5B;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAgI,eAAe,CAACqB,SAAS,CAACnI,GAAG,GAAG,UAAU+G,OAAO,EAAE;EACjD,MAAMvI,KAAK,GAAG,IAAIpE,KAAK,CAAC2M,OAAO,EAAE,IAAI,CAAC;EAEtC,IAAI,CAACS,OAAO,CAACvJ,IAAI,CAACO,KAAK,CAAC;EACxB,IAAI,CAACiJ,eAAe,CAACxJ,IAAI,CAACO,KAAK,CAAC;EAEhC,OAAOA,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAsI,eAAe,CAACqB,SAAS,CAACpI,MAAM,GAAG,UAAUvB,KAAK,EAAE;EAClD,IAAI9E,OAAO,CAAC8E,KAAK,CAAC,IAAIA,KAAK,CAACqI,gBAAgB,KAAK,IAAI,EAAE;IACrD,MAAM5L,KAAK,GAAG,IAAI,CAACuM,OAAO,CAACa,OAAO,CAAC7J,KAAK,CAAC;IACzC,IAAIvD,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB,IAAI,CAACuM,OAAO,CAACc,MAAM,CAACrN,KAAK,EAAE,CAAC,CAAC;MAC7B0L,YAAY,CAAC,IAAI,EAAEnI,KAAK,CAAC;MACzB,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAsI,eAAe,CAACqB,SAAS,CAACI,SAAS,GAAG,YAAY;EAChD,MAAMC,MAAM,GAAG,IAAI,CAAChB,OAAO;EAE3B,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEyD,GAAG,GAAG4B,MAAM,CAAC1J,MAAM,EAAEqE,CAAC,GAAGyD,GAAG,EAAE,EAAEzD,CAAC,EAAE;IACjDwD,YAAY,CAAC,IAAI,EAAE6B,MAAM,CAACrF,CAAC,CAAC,CAAC;EAC/B;EAEAqF,MAAM,CAAC1J,MAAM,GAAG,CAAC;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAgI,eAAe,CAACqB,SAAS,CAACM,QAAQ,GAAG,UAAUjK,KAAK,EAAE;EACpD,OAAO9E,OAAO,CAAC8E,KAAK,CAAC,IAAIA,KAAK,CAACqI,gBAAgB,KAAK,IAAI;AAC1D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,eAAe,CAACqB,SAAS,CAACC,GAAG,GAAG,UAAUnN,KAAK,EAAE;EAC/C;EACA,IAAI,CAACvB,OAAO,CAACuB,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIrB,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA,OAAO,IAAI,CAAC4N,OAAO,CAACvM,KAAK,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA6L,eAAe,CAACqB,SAAS,CAACO,MAAM,GAAG,UAAUC,UAAU,EAAE;EACvD,IAAI,CAAC,IAAI,CAAC9K,IAAI,EAAE;IACd;EACF;EAEA,MAAM+K,mBAAmB,GAAG,IAAI,CAAC/E,oBAAoB;EACrD,MAAMhE,6BAA6B,GAAG,IAAI,CAACC,8BAA8B;EAEzE8I,mBAAmB,CAAChB,WAAW,GAAG,IAAI,CAACA,WAAW;EAClDgB,mBAAmB,CAACd,uBAAuB,GAAG,IAAI,CAACA,uBAAuB;EAC1EjI,6BAA6B,CAAC+H,WAAW,GAAG,IAAI,CAACA,WAAW;EAC5D/H,6BAA6B,CAACiI,uBAAuB,GACnD,IAAI,CAACA,uBAAuB;EAE9B,MAAMe,OAAO,GAAGF,UAAU,CAACE,OAAO;EAElC,IAAI,CAACnP,OAAO,CAAC,IAAI,CAACgK,aAAa,CAAC,EAAE;IAChC,IAAI,CAACA,aAAa,GAAG,IAAInJ,YAAY,CAAC;MACpCsO,OAAO,EAAEA;IACX,CAAC,CAAC;IACFD,mBAAmB,CAACrN,YAAY,GAAG,IAAI,CAACmI,aAAa;EACvD;EAEA,IAAI,CAAChK,OAAO,CAAC,IAAI,CAAC2N,uBAAuB,CAAC,EAAE;IAC1C,IAAI,CAACA,uBAAuB,GAAG,IAAI9M,YAAY,CAAC;MAC9CsO,OAAO,EAAEA,OAAO;MAChBC,WAAW,EAAE1N;IACf,CAAC,CAAC;IACFyE,6BAA6B,CAACtE,YAAY,GAAG,IAAI,CAAC8L,uBAAuB;;IAEzE;IACA/L,mBAAmB,CAAC,IAAI,CAAC+L,uBAAuB,CAAC;EACnD;EAEA,MAAMT,GAAG,GAAG,IAAI,CAACa,eAAe,CAAC3I,MAAM;EACvC,KAAK,IAAIqE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,GAAG,EAAE,EAAEzD,CAAC,EAAE;IAC5B,MAAM3E,KAAK,GAAG,IAAI,CAACiJ,eAAe,CAACtE,CAAC,CAAC;IACrC,IAAI3E,KAAK,CAACuK,WAAW,CAAC,CAAC,EAAE;MACvB;IACF;IAEA,MAAMC,mBAAmB,GAAGxK,KAAK,CAACQ,OAAO,CAACF,MAAM;IAEhD,IAAIN,KAAK,CAACyK,gBAAgB,EAAE;MAC1B1K,eAAe,CAAC,IAAI,EAAEC,KAAK,CAAC;MAC5BA,KAAK,CAACyK,gBAAgB,GAAG,KAAK;IAChC;IAEA,IAAIzK,KAAK,CAAC2F,oBAAoB,EAAE;MAC9BO,mBAAmB,CAAClG,KAAK,CAAC;MAC1BA,KAAK,CAAC2F,oBAAoB,GAAG,KAAK;IACpC;IAEA,MAAM+E,oBAAoB,GAAG1K,KAAK,CAACQ,OAAO,CAACF,MAAM,GAAGkK,mBAAmB;IACvE,IAAI,CAACtB,gBAAgB,IAAIwB,oBAAoB;EAC/C;EAEA,MAAMnB,WAAW,GACflI,6BAA6B,CAACf,MAAM,GAAG,CAAC,GACpC7E,WAAW,CAACkP,WAAW,GACvB,IAAI,CAACpB,WAAW;EACtBa,mBAAmB,CAACb,WAAW,GAAGA,WAAW;EAC7ClI,6BAA6B,CAACkI,WAAW,GAAGA,WAAW;EAEvDa,mBAAmB,CAACjB,eAAe,GAAG,IAAI,CAACA,eAAe;EAC1D9H,6BAA6B,CAAC8H,eAAe,GAAG,IAAI,CAACA,eAAe;EAEpE,IAAI,CAACF,eAAe,CAAC3I,MAAM,GAAG,CAAC;EAC/Be,6BAA6B,CAAC6I,MAAM,CAACC,UAAU,CAAC;EAChDC,mBAAmB,CAACF,MAAM,CAACC,UAAU,CAAC;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,eAAe,CAACqB,SAAS,CAACY,WAAW,GAAG,YAAY;EAClD,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjC,eAAe,CAACqB,SAAS,CAACiB,OAAO,GAAG,YAAY;EAC9C,IAAI,CAACb,SAAS,CAAC,CAAC;EAChB,IAAI,CAAC1E,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACuF,OAAO,CAAC,CAAC;EAC/D,IAAI,CAAC1F,aAAa,GAAG,IAAI,CAACA,aAAa,IAAI,IAAI,CAACA,aAAa,CAAC0F,OAAO,CAAC,CAAC;EACvE,IAAI,CAACtJ,8BAA8B,GACjC,IAAI,CAACA,8BAA8B,CAACsJ,OAAO,CAAC,CAAC;EAC/C,IAAI,CAAC/B,uBAAuB,GAC1B,IAAI,CAACA,uBAAuB,IAAI,IAAI,CAACA,uBAAuB,CAAC+B,OAAO,CAAC,CAAC;EAExE,OAAOzP,aAAa,CAAC,IAAI,CAAC;AAC5B,CAAC;AACD,eAAemN,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}