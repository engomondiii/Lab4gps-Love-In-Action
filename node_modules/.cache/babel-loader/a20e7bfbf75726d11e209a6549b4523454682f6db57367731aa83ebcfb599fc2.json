{"ast":null,"code":"import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  const normals = attr.normals;\n  const tangents = attr.tangents;\n  const bitangents = attr.bitangents;\n  const forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const computedLefts = computedPositions.lefts;\n  const computedNormals = computedPositions.normals;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n  const attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents\n  };\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let normal = cartesian1;\n  let left = cartesian2;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  let index = 0;\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n  }\n  let posIndex = 0;\n  let compIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  let rightNormal;\n  let leftNormal;\n  length = leftEdge.length - 3;\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\n    leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\n    normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n    addNormals(attr, normal, left, front, back, vertexFormat);\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n    front += 3;\n    back -= 3;\n  }\n  rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\n  leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\n  normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n  compIndex += 3;\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let pivot;\n    let start;\n    let outsidePoint = cartesian6;\n    let previousPoint = cartesian3;\n    let nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n        previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n      outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n      previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, previousPoint), outsidePoint, previousPoint);\n      nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\n      left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n        previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\n        nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\n        left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n      outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n      previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\n      nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\n      left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\n      leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\n      normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n  }\n  normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\n  addNormals(attr, normal, left, front, back, vertexFormat);\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n  }\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions\n  });\n  if (vertexFormat.st) {\n    const st = new Float32Array(size / 3 * 2);\n    let rightSt;\n    let leftSt;\n    let stIndex = 0;\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      const theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      let a;\n      const halfEndPos = endPositionLength / 2;\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st\n    });\n  }\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals\n    });\n  }\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents\n    });\n  }\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents\n    });\n  }\n  return {\n    attributes: attributes,\n    indices: indices\n  };\n}\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\n    return attributes;\n  }\n  const positions = attributes.position.values;\n  let topNormals;\n  let topBitangents;\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n  const size = attributes.position.values.length / 18;\n  const threeSize = size * 3;\n  const twoSize = size * 2;\n  const sixSize = threeSize * 2;\n  let i;\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    const normals = vertexFormat.normal ? new Float32Array(threeSize * 6) : undefined;\n    const tangents = vertexFormat.tangent ? new Float32Array(threeSize * 6) : undefined;\n    const bitangents = vertexFormat.bitangent ? new Float32Array(threeSize * 6) : undefined;\n    let topPosition = cartesian1;\n    let bottomPosition = cartesian2;\n    let previousPosition = cartesian3;\n    let normal = cartesian4;\n    let tangent = cartesian5;\n    let bitangent = cartesian6;\n    let attrIndex = sixSize;\n    for (i = 0; i < threeSize; i += 3) {\n      const attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\n      previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\n      bottomPosition = Cartesian3.subtract(bottomPosition, topPosition, bottomPosition);\n      previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\n      normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\n        }\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\n        }\n      }\n      attrIndex += 6;\n    }\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n      bitangents.set(topBitangents, threeSize); //bottom\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n    if (vertexFormat.tangent) {\n      const topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n      tangents.set(topTangents, threeSize); //bottom\n      attributes.tangent.values = tangents;\n    }\n  }\n  if (vertexFormat.st) {\n    const topSt = attributes.st.values;\n    const st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n    st.set(topSt, twoSize); //bottom\n    let index = twoSize * 2;\n    for (let j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n      for (i = 2; i < twoSize; i += 2) {\n        const s = topSt[i];\n        const t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n    attributes.st.values = st;\n  }\n  return attributes;\n}\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  for (let i = 3; i < positions.length; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  return wallPositions;\n}\nfunction computePositionsExtruded(params, vertexFormat) {\n  const topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal: vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st\n  });\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  let attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  const newPositions = new Float64Array(length * 6);\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  let wallPositions = new Float64Array(length * 4);\n  positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n  wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  let i;\n  const size = length / 3;\n  if (params.shadowVolume) {\n    const topNormals = attributes.normal.values;\n    length = topNormals.length;\n    let extrudeNormals = new Float32Array(length * 6);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    //only get normals for bottom layer that's going to be pushed down\n    extrudeNormals.set(topNormals, length); //bottom face\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(size * 6);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, size) // top face\n      .fill(1, size * 2, size * 4); // top wall\n    } else {\n      const applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n  const iLength = indices.length;\n  const twoSize = size + size;\n  const newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    const v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n  let UL, LL, UR, LR;\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n  return {\n    attributes: attributes,\n    indices: newIndices\n  };\n}\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nfunction computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\n  // Compute direction of offset the point\n  const direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n  Cartesian3.normalize(direction, direction);\n  const normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  const offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n  let minLat = min.latitude;\n  let minLon = min.longitude;\n  let maxLat = max.latitude;\n  let maxLon = max.longitude;\n\n  // Compute 2 offset points\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n  let lat = scratchCartographic.latitude;\n  let lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\nconst scratchCartesianOffset = new Cartesian3();\nconst scratchCartesianEnds = new Cartesian3();\nconst scratchCartographicMin = new Cartographic();\nconst scratchCartographicMax = new Cartographic();\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n  const length = cleanPositions.length;\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n  const halfWidth = width * 0.5;\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n  let lat, lon;\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    const first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n    ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n    scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n    scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n    scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n  }\n\n  // Compute the rest\n  for (let i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(cleanPositions[i], cleanPositions[i + 1], ellipsoid, halfWidth, scratchCartographicMin, scratchCartographicMax);\n  }\n\n  // Compute ending point\n  const last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth, scratchCartographicMin, scratchCartographicMax);\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n    scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n    scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n    scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n  }\n  const rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n  return rectangle;\n}\n\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * const corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.default));\n  this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorGeometry(scratchOptions);\n  }\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  let positions = corridorGeometry._positions;\n  const width = corridorGeometry._width;\n  const ellipsoid = corridorGeometry._ellipsoid;\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n  const height = corridorGeometry._height;\n  const extrudedHeight = corridorGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  const vertexFormat = corridorGeometry._vertexFormat;\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n    if (defined(corridorGeometry._offsetAttribute)) {\n      const applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      const length = attr.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3).fill(applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute\n  });\n};\n\n/**\n * @private\n */\nCorridorGeometry.createShadowVolume = function (corridorGeometry, minHeightFunc, maxHeightFunc) {\n  const granularity = corridorGeometry._granularity;\n  const ellipsoid = corridorGeometry._ellipsoid;\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true\n  });\n};\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\n      }\n      return this._rectangle;\n    }\n  },\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    }\n  }\n});\nexport default CorridorGeometry;","map":{"version":3,"names":["arrayRemoveDuplicates","BoundingSphere","Cartesian3","Cartographic","Check","ComponentDatatype","CornerType","CorridorGeometryLibrary","defaultValue","defined","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PolygonPipeline","PrimitiveType","Rectangle","VertexFormat","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","normalize","cross","addAttribute","tangent","bitangent","combine","computedPositions","corners","endPositions","computedLefts","lefts","computedNormals","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","Float32Array","undefined","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","createTypedArray","index","firstEndPositions","fromArray","posIndex","compIndex","rightEdge","leftEdge","set","rightNormal","leftNormal","geodeticSurfaceNormal","add","j","l","r","pivot","start","outsidePoint","previousPoint","nextPoint","subtract","negate","splice","lastEndPositions","position","componentDatatype","DOUBLE","componentsPerAttribute","values","st","rightSt","leftSt","stIndex","theta","Math","PI","a","halfEndPos","PI_OVER_TWO","cos","sin","FLOAT","extrudedAttributes","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","shadowVolume","computePositions","height","extrudedHeight","newPositions","extrudedPositions","scaleToGeodeticHeight","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","TOP","fill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","multiplyByScalar","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","equalsEpsilon","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","ROUNDED","first","last","rectangle","north","south","east","west","CorridorGeometry","options","EMPTY_OBJECT","_positions","_ellipsoid","clone","default","_vertexFormat","DEFAULT","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","EPSILON2","saveAttributes","boundingSphere","fromVertices","primitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","get","textureCoordinateRotationPoints"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CorridorGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  const normals = attr.normals;\n  const tangents = attr.tangents;\n  const bitangents = attr.bitangents;\n  const forward = Cartesian3.normalize(\n    Cartesian3.cross(left, normal, scratch1),\n    scratch1,\n  );\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\n\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const computedLefts = computedPositions.lefts;\n  const computedNormals = computedPositions.normals;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size)\n    : undefined;\n  const attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  };\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let normal = cartesian1;\n  let left = cartesian2;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  let index = 0;\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  let posIndex = 0;\n  let compIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  let rightNormal;\n  let leftNormal;\n  length = leftEdge.length - 3;\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(rightEdge, i, scratch1),\n      scratch1,\n    );\n    leftNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(leftEdge, length - i, scratch2),\n      scratch2,\n    );\n    normal = Cartesian3.normalize(\n      Cartesian3.add(rightNormal, leftNormal, normal),\n      normal,\n    );\n    addNormals(attr, normal, left, front, back, vertexFormat);\n\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  rightNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(rightEdge, length, scratch1),\n    scratch1,\n  );\n  leftNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(leftEdge, length, scratch2),\n    scratch2,\n  );\n  normal = Cartesian3.normalize(\n    Cartesian3.add(rightNormal, leftNormal, normal),\n    normal,\n  );\n  compIndex += 3;\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let pivot;\n    let start;\n    let outsidePoint = cartesian6;\n    let previousPoint = cartesian3;\n    let nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back,\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start - j - 1) * 3,\n          previousPoint,\n        );\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left,\n        );\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint,\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, previousPoint),\n        outsidePoint,\n        previousPoint,\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint),\n        outsidePoint,\n        nextPoint,\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.add(previousPoint, nextPoint, left),\n        left,\n      );\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front,\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          pivot * 3,\n          previousPoint,\n        );\n        nextPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start + j) * 3,\n          nextPoint,\n        );\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left,\n        );\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint,\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint),\n        outsidePoint,\n        previousPoint,\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, nextPoint),\n        outsidePoint,\n        nextPoint,\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left),\n        left,\n      );\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(rightEdge, j, scratch1),\n        scratch1,\n      );\n      leftNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(leftEdge, length - j, scratch2),\n        scratch2,\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.add(rightNormal, leftNormal, normal),\n        normal,\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n  }\n  normal = Cartesian3.fromArray(\n    computedNormals,\n    computedNormals.length - 3,\n    normal,\n  );\n  addNormals(attr, normal, left, front, back, vertexFormat);\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  if (vertexFormat.st) {\n    const st = new Float32Array((size / 3) * 2);\n    let rightSt;\n    let leftSt;\n    let stIndex = 0;\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      const theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      let a;\n      const halfEndPos = endPositionLength / 2;\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents,\n    });\n  }\n\n  return {\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (\n    !vertexFormat.normal &&\n    !vertexFormat.tangent &&\n    !vertexFormat.bitangent &&\n    !vertexFormat.st\n  ) {\n    return attributes;\n  }\n  const positions = attributes.position.values;\n  let topNormals;\n  let topBitangents;\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n  const size = attributes.position.values.length / 18;\n  const threeSize = size * 3;\n  const twoSize = size * 2;\n  const sixSize = threeSize * 2;\n  let i;\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    const normals = vertexFormat.normal\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    const tangents = vertexFormat.tangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    const bitangents = vertexFormat.bitangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    let topPosition = cartesian1;\n    let bottomPosition = cartesian2;\n    let previousPosition = cartesian3;\n    let normal = cartesian4;\n    let tangent = cartesian5;\n    let bitangent = cartesian6;\n    let attrIndex = sixSize;\n    for (i = 0; i < threeSize; i += 3) {\n      const attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(\n        positions,\n        i + threeSize,\n        bottomPosition,\n      );\n      previousPosition = Cartesian3.fromArray(\n        positions,\n        (i + 3) % threeSize,\n        previousPosition,\n      );\n      bottomPosition = Cartesian3.subtract(\n        bottomPosition,\n        topPosition,\n        bottomPosition,\n      );\n      previousPosition = Cartesian3.subtract(\n        previousPosition,\n        topPosition,\n        previousPosition,\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottomPosition, previousPosition, normal),\n        normal,\n      );\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(\n          normals,\n          normal,\n          attrIndexOffset + 3,\n        );\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset + 3,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex + 3,\n          );\n        }\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset,\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset + 3,\n          );\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndex + 3,\n          );\n        }\n      }\n      attrIndex += 6;\n    }\n\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n      bitangents.set(topBitangents, threeSize); //bottom\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n\n    if (vertexFormat.tangent) {\n      const topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n      tangents.set(topTangents, threeSize); //bottom\n      attributes.tangent.values = tangents;\n    }\n  }\n  if (vertexFormat.st) {\n    const topSt = attributes.st.values;\n    const st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n    st.set(topSt, twoSize); //bottom\n    let index = twoSize * 2;\n\n    for (let j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n      for (i = 2; i < twoSize; i += 2) {\n        const s = topSt[i];\n        const t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n    attributes.st.values = st;\n  }\n\n  return attributes;\n}\n\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  for (let i = 3; i < positions.length; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n\n  return wallPositions;\n}\n\nfunction computePositionsExtruded(params, vertexFormat) {\n  const topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal:\n      vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st,\n  });\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  let attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  const newPositions = new Float64Array(length * 6);\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  let wallPositions = new Float64Array(length * 4);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid,\n  );\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid,\n  );\n  wallPositions = addWallPositions(\n    extrudedPositions,\n    length * 2,\n    wallPositions,\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  let i;\n  const size = length / 3;\n  if (params.shadowVolume) {\n    const topNormals = attributes.normal.values;\n    length = topNormals.length;\n\n    let extrudeNormals = new Float32Array(length * 6);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    //only get normals for bottom layer that's going to be pushed down\n    extrudeNormals.set(topNormals, length); //bottom face\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(size * 6);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset\n        .fill(1, 0, size) // top face\n        .fill(1, size * 2, size * 4); // top wall\n    } else {\n      const applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  const iLength = indices.length;\n  const twoSize = size + size;\n  const newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    iLength * 2 + twoSize * 3,\n  );\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    const v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n\n  let UL, LL, UR, LR;\n\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nfunction computeOffsetPoints(\n  position1,\n  position2,\n  ellipsoid,\n  halfWidth,\n  min,\n  max,\n) {\n  // Compute direction of offset the point\n  const direction = Cartesian3.subtract(\n    position2,\n    position1,\n    scratchCartesian1,\n  );\n  Cartesian3.normalize(direction, direction);\n  const normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  const offsetDirection = Cartesian3.cross(\n    direction,\n    normal,\n    scratchCartesian1,\n  );\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n  let minLat = min.latitude;\n  let minLon = min.longitude;\n  let maxLat = max.latitude;\n  let maxLon = max.longitude;\n\n  // Compute 2 offset points\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  let lat = scratchCartographic.latitude;\n  let lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\n\nconst scratchCartesianOffset = new Cartesian3();\nconst scratchCartesianEnds = new Cartesian3();\nconst scratchCartographicMin = new Cartographic();\nconst scratchCartographicMax = new Cartographic();\n\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n  const length = cleanPositions.length;\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n  const halfWidth = width * 0.5;\n\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n  let lat, lon;\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    const first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(\n      scratchCartesianOffset,\n      halfWidth,\n      scratchCartesianOffset,\n    );\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic,\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat,\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon,\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat,\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon,\n    );\n  }\n\n  // Compute the rest\n  for (let i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(\n      cleanPositions[i],\n      cleanPositions[i + 1],\n      ellipsoid,\n      halfWidth,\n      scratchCartographicMin,\n      scratchCartographicMax,\n    );\n  }\n\n  // Compute ending point\n  const last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(\n    scratchCartesianOffset,\n    halfWidth,\n    scratchCartesianOffset,\n  );\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(\n    last,\n    scratchCartesianEnds,\n    ellipsoid,\n    halfWidth,\n    scratchCartographicMin,\n    scratchCartographicMax,\n  );\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic,\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat,\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon,\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat,\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon,\n    );\n  }\n\n  const rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n\n  return rectangle;\n}\n\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * const corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.default),\n  );\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT),\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    1 +\n    positions.length * Cartesian3.packedLength +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    7;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new CorridorGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  let positions = corridorGeometry._positions;\n  const width = corridorGeometry._width;\n  const ellipsoid = corridorGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  const height = corridorGeometry._height;\n  const extrudedHeight = corridorGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  const vertexFormat = corridorGeometry._vertexFormat;\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true,\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid,\n    );\n\n    if (defined(corridorGeometry._offsetAttribute)) {\n      const applyOffsetValue =\n        corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const length = attr.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3).fill(applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3,\n  );\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nCorridorGeometry.createShadowVolume = function (\n  corridorGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = corridorGeometry._granularity;\n  const ellipsoid = corridorGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._positions,\n          this._ellipsoid,\n          this._width,\n          this._cornerType,\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    },\n  },\n});\nexport default CorridorGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}