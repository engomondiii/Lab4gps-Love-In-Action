{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * An ellipsoid {@link VoxelShape}.\n *\n * @alias VoxelEllipsoidShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelEllipsoidShape() {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  this.orientedBoundingBox = new OrientedBoundingBox();\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  this.boundingSphere = new BoundingSphere();\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.boundTransform = new Matrix4();\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.shapeTransform = new Matrix4();\n\n  /**\n   * @type {Rectangle}\n   */\n  this._rectangle = new Rectangle();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumHeight = VoxelEllipsoidShape.DefaultMinBounds.z;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumHeight = VoxelEllipsoidShape.DefaultMaxBounds.z;\n\n  /**\n   * @type {Ellipsoid}\n   * @private\n   */\n  this._ellipsoid = new Ellipsoid();\n\n  /**\n   * @type {Cartesian3}\n   */\n  this._translation = new Cartesian3();\n\n  /**\n   * @type {Matrix3}\n   */\n  this._rotation = new Matrix3();\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderUniforms = {\n    ellipsoidRadiiUv: new Cartesian3(),\n    eccentricitySquared: 0.0,\n    evoluteScale: new Cartesian2(),\n    ellipsoidInverseRadiiSquaredUv: new Cartesian3(),\n    ellipsoidRenderLongitudeMinMax: new Cartesian2(),\n    ellipsoidShapeUvLongitudeMinMaxMid: new Cartesian3(),\n    ellipsoidUvToShapeUvLongitude: new Cartesian2(),\n    ellipsoidUvToShapeUvLatitude: new Cartesian2(),\n    ellipsoidRenderLatitudeSinMinMax: new Cartesian2(),\n    ellipsoidInverseHeightDifferenceUv: 0.0,\n    clipMinMaxHeight: new Cartesian2()\n  };\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderDefines = {\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LONGITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN: undefined\n  };\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @type {number}\n   * @readonly\n   */\n  this.shaderMaximumIntersectionsLength = 0; // not known until update\n}\nconst scratchActualMinBounds = new Cartesian3();\nconst scratchShapeMinBounds = new Cartesian3();\nconst scratchShapeMaxBounds = new Cartesian3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchRotationScale = new Matrix3();\nconst scratchShapeOuterExtent = new Cartesian3();\nconst scratchRenderOuterExtent = new Cartesian3();\nconst scratchRenderRectangle = new Rectangle();\n\n/**\n * Update the shape's state.\n *\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelEllipsoidShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelEllipsoidShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelEllipsoidShape.prototype.update = function (modelMatrix, minBounds, maxBounds, clipMinBounds, clipMaxBounds) {\n  const {\n    DefaultMinBounds,\n    DefaultMaxBounds\n  } = VoxelEllipsoidShape;\n  clipMinBounds = defaultValue(clipMinBounds, DefaultMinBounds);\n  clipMaxBounds = defaultValue(clipMaxBounds, DefaultMaxBounds);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonLongitudeDiscontinuity = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n  const epsilonLongitude = CesiumMath.EPSILON10;\n  const epsilonLatitude = CesiumMath.EPSILON10;\n  const epsilonLatitudeFlat = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n\n  // Don't let the height go below the center of the ellipsoid.\n  const radii = Matrix4.getScale(modelMatrix, scratchScale);\n  const actualMinBounds = Cartesian3.clone(DefaultMinBounds, scratchActualMinBounds);\n  actualMinBounds.z = -Cartesian3.minimumComponent(radii);\n  const shapeMinBounds = Cartesian3.clamp(minBounds, actualMinBounds, DefaultMaxBounds, scratchShapeMinBounds);\n  const shapeMaxBounds = Cartesian3.clamp(maxBounds, actualMinBounds, DefaultMaxBounds, scratchShapeMaxBounds);\n  const clampedClipMinBounds = Cartesian3.clamp(clipMinBounds, actualMinBounds, DefaultMaxBounds, scratchClipMinBounds);\n  const clampedClipMaxBounds = Cartesian3.clamp(clipMaxBounds, actualMinBounds, DefaultMaxBounds, scratchClipMaxBounds);\n  const renderMinBounds = Cartesian3.maximumByComponent(shapeMinBounds, clampedClipMinBounds, scratchRenderMinBounds);\n  const renderMaxBounds = Cartesian3.minimumByComponent(shapeMaxBounds, clampedClipMaxBounds, scratchRenderMaxBounds);\n\n  // Compute the farthest a point can be from the center of the ellipsoid.\n  const shapeOuterExtent = Cartesian3.add(radii, Cartesian3.fromElements(shapeMaxBounds.z, shapeMaxBounds.z, shapeMaxBounds.z, scratchShapeOuterExtent), scratchShapeOuterExtent);\n  const shapeMaxExtent = Cartesian3.maximumComponent(shapeOuterExtent);\n  const renderOuterExtent = Cartesian3.add(radii, Cartesian3.fromElements(renderMaxBounds.z, renderMaxBounds.z, renderMaxBounds.z, scratchRenderOuterExtent), scratchRenderOuterExtent);\n\n  // Exit early if the shape is not visible.\n  // Note that minLongitude may be greater than maxLongitude when crossing the 180th meridian.\n  if (renderMinBounds.y > renderMaxBounds.y || renderMinBounds.y === DefaultMaxBounds.y || renderMaxBounds.y === DefaultMinBounds.y || renderMinBounds.z > renderMaxBounds.z || CesiumMath.equalsEpsilon(renderOuterExtent, Cartesian3.ZERO, undefined, epsilonZeroScale)) {\n    return false;\n  }\n  this._rectangle = Rectangle.fromRadians(shapeMinBounds.x, shapeMinBounds.y, shapeMaxBounds.x, shapeMaxBounds.y);\n  this._translation = Matrix4.getTranslation(modelMatrix, this._translation);\n  this._rotation = Matrix4.getRotation(modelMatrix, this._rotation);\n  this._ellipsoid = Ellipsoid.fromCartesian3(radii, this._ellipsoid);\n  this._minimumHeight = shapeMinBounds.z;\n  this._maximumHeight = shapeMaxBounds.z;\n  const renderRectangle = Rectangle.fromRadians(renderMinBounds.x, renderMinBounds.y, renderMaxBounds.x, renderMaxBounds.y, scratchRenderRectangle);\n  this.orientedBoundingBox = getEllipsoidChunkObb(renderRectangle, renderMinBounds.z, renderMaxBounds.z, this._ellipsoid, this._translation, this._rotation, this.orientedBoundingBox);\n  this.shapeTransform = Matrix4.fromRotationTranslation(Matrix3.setScale(this._rotation, shapeOuterExtent, scratchRotationScale), this._translation, this.shapeTransform);\n  this.boundTransform = Matrix4.fromRotationTranslation(this.orientedBoundingBox.halfAxes, this.orientedBoundingBox.center, this.boundTransform);\n  this.boundingSphere = BoundingSphere.fromOrientedBoundingBox(this.orientedBoundingBox, this.boundingSphere);\n\n  // Longitude\n  const defaultLongitudeRange = DefaultMaxBounds.x - DefaultMinBounds.x;\n  const defaultLongitudeRangeHalf = 0.5 * defaultLongitudeRange;\n  const renderIsLongitudeReversed = renderMaxBounds.x < renderMinBounds.x;\n  const renderLongitudeRange = renderMaxBounds.x - renderMinBounds.x + renderIsLongitudeReversed * defaultLongitudeRange;\n  const renderIsLongitudeRangeZero = renderLongitudeRange <= epsilonLongitude;\n  const renderIsLongitudeRangeUnderHalf = renderLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude && renderLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const renderIsLongitudeRangeOverHalf = renderLongitudeRange > epsilonLongitude && renderLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const renderHasLongitude = renderIsLongitudeRangeZero || renderIsLongitudeRangeUnderHalf || renderIsLongitudeRangeOverHalf;\n  const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n  const shapeLongitudeRange = shapeMaxBounds.x - shapeMinBounds.x + shapeIsLongitudeReversed * defaultLongitudeRange;\n  const shapeIsLongitudeRangeUnderHalf = shapeLongitudeRange > defaultLongitudeRangeHalf + epsilonLongitude && shapeLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const shapeIsLongitudeRangeHalf = shapeLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude && shapeLongitudeRange <= defaultLongitudeRangeHalf + epsilonLongitude;\n  const shapeIsLongitudeRangeOverHalf = shapeLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const shapeHasLongitude = shapeIsLongitudeRangeUnderHalf || shapeIsLongitudeRangeHalf || shapeIsLongitudeRangeOverHalf;\n\n  // Latitude\n  const renderIsLatitudeMaxUnderHalf = renderMaxBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMaxHalf = renderMaxBounds.y >= -epsilonLatitudeFlat && renderMaxBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMaxOverHalf = renderMaxBounds.y > +epsilonLatitudeFlat && renderMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const renderHasLatitudeMax = renderIsLatitudeMaxUnderHalf || renderIsLatitudeMaxHalf || renderIsLatitudeMaxOverHalf;\n  const renderIsLatitudeMinUnderHalf = renderMinBounds.y > DefaultMinBounds.y + epsilonLatitude && renderMinBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMinHalf = renderMinBounds.y >= -epsilonLatitudeFlat && renderMinBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMinOverHalf = renderMinBounds.y > +epsilonLatitudeFlat;\n  const renderHasLatitudeMin = renderIsLatitudeMinUnderHalf || renderIsLatitudeMinHalf || renderIsLatitudeMinOverHalf;\n  const renderHasLatitude = renderHasLatitudeMax || renderHasLatitudeMin;\n  const shapeLatitudeRange = shapeMaxBounds.y - shapeMinBounds.y;\n  const shapeIsLatitudeMaxUnderHalf = shapeMaxBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxHalf = shapeMaxBounds.y >= -epsilonLatitudeFlat && shapeMaxBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxOverHalf = shapeMaxBounds.y > +epsilonLatitudeFlat && shapeMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const shapeHasLatitudeMax = shapeIsLatitudeMaxUnderHalf || shapeIsLatitudeMaxHalf || shapeIsLatitudeMaxOverHalf;\n  const shapeIsLatitudeMinUnderHalf = shapeMinBounds.y > DefaultMinBounds.y + epsilonLatitude && shapeMinBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMinHalf = shapeMinBounds.y >= -epsilonLatitudeFlat && shapeMinBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMinOverHalf = shapeMinBounds.y > +epsilonLatitudeFlat;\n  const shapeHasLatitudeMin = shapeIsLatitudeMinUnderHalf || shapeIsLatitudeMinHalf || shapeIsLatitudeMinOverHalf;\n  const shapeHasLatitude = shapeHasLatitudeMax || shapeHasLatitudeMin;\n  const {\n    shaderUniforms,\n    shaderDefines\n  } = this;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // The ellipsoid radii scaled to [0,1]. The max ellipsoid radius will be 1.0 and others will be less.\n  shaderUniforms.ellipsoidRadiiUv = Cartesian3.divideByScalar(shapeOuterExtent, shapeMaxExtent, shaderUniforms.ellipsoidRadiiUv);\n  const {\n    x: radiiUvX,\n    z: radiiUvZ\n  } = shaderUniforms.ellipsoidRadiiUv;\n  const axisRatio = radiiUvZ / radiiUvX;\n  shaderUniforms.eccentricitySquared = 1.0 - axisRatio * axisRatio;\n  shaderUniforms.evoluteScale = Cartesian2.fromElements((radiiUvX * radiiUvX - radiiUvZ * radiiUvZ) / radiiUvX, (radiiUvZ * radiiUvZ - radiiUvX * radiiUvX) / radiiUvZ, shaderUniforms.evoluteScale);\n\n  // Used to compute geodetic surface normal.\n  shaderUniforms.ellipsoidInverseRadiiSquaredUv = Cartesian3.divideComponents(Cartesian3.ONE, Cartesian3.multiplyComponents(shaderUniforms.ellipsoidRadiiUv, shaderUniforms.ellipsoidRadiiUv, shaderUniforms.ellipsoidInverseRadiiSquaredUv), shaderUniforms.ellipsoidInverseRadiiSquaredUv);\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  // Intersects outer and inner ellipsoid for the max and min height.\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderUniforms.clipMinMaxHeight = Cartesian2.fromElements((renderMinBounds.z - shapeMaxBounds.z) / shapeMaxExtent, (renderMaxBounds.z - shapeMaxBounds.z) / shapeMaxExtent, shaderUniforms.clipMinMaxHeight);\n\n  // The percent of space that is between the inner and outer ellipsoid.\n  const thickness = (shapeMaxBounds.z - shapeMinBounds.z) / shapeMaxExtent;\n  shaderUniforms.ellipsoidInverseHeightDifferenceUv = 1.0 / thickness;\n  if (shapeMinBounds.z === shapeMaxBounds.z) {\n    shaderUniforms.ellipsoidInverseHeightDifferenceUv = 0.0;\n  }\n\n  // Intersects a wedge for the min and max longitude.\n  if (renderHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE\"] = true;\n    shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LONGITUDE\"] = intersectionCount;\n    if (renderIsLongitudeRangeUnderHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF\"] = true;\n      intersectionCount += 1;\n    } else if (renderIsLongitudeRangeOverHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF\"] = true;\n      intersectionCount += 2;\n    } else if (renderIsLongitudeRangeZero) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO\"] = true;\n      intersectionCount += 2;\n    }\n    shaderUniforms.ellipsoidRenderLongitudeMinMax = Cartesian2.fromElements(renderMinBounds.x, renderMaxBounds.x, shaderUniforms.ellipsoidRenderLongitudeMinMax);\n  }\n  if (shapeHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\"] = true;\n    const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n    if (shapeIsLongitudeReversed) {\n      shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\"] = true;\n    }\n\n    // delerp(longitudeUv, minLongitudeUv, maxLongitudeUv)\n    // (longitudeUv - minLongitudeUv) / (maxLongitudeUv - minLongitudeUv)\n    // longitudeUv / (maxLongitudeUv - minLongitudeUv) - minLongitudeUv / (maxLongitudeUv - minLongitudeUv)\n    // scale = 1.0 / (maxLongitudeUv - minLongitudeUv)\n    // scale = 1.0 / (((maxLongitude - pi) / (2.0 * pi)) - ((minLongitude - pi) / (2.0 * pi)))\n    // scale = 2.0 * pi / (maxLongitude - minLongitude)\n    // offset = -minLongitudeUv / (maxLongitudeUv - minLongitudeUv)\n    // offset = -((minLongitude - pi) / (2.0 * pi)) / (((maxLongitude - pi) / (2.0 * pi)) - ((minLongitude - pi) / (2.0 * pi)))\n    // offset = -(minLongitude - pi) / (maxLongitude - minLongitude)\n    if (shapeLongitudeRange <= epsilonLongitude) {\n      shaderUniforms.ellipsoidUvToShapeUvLongitude = Cartesian2.fromElements(0.0, 1.0, shaderUniforms.ellipsoidUvToShapeUvLongitude);\n    } else {\n      const scale = defaultLongitudeRange / shapeLongitudeRange;\n      const offset = -(shapeMinBounds.x - DefaultMinBounds.x) / shapeLongitudeRange;\n      shaderUniforms.ellipsoidUvToShapeUvLongitude = Cartesian2.fromElements(scale, offset, shaderUniforms.ellipsoidUvToShapeUvLongitude);\n    }\n  }\n  if (renderHasLongitude) {\n    const renderIsMinLongitudeDiscontinuity = CesiumMath.equalsEpsilon(renderMinBounds.x, DefaultMinBounds.x, undefined, epsilonLongitudeDiscontinuity);\n    const renderIsMaxLongitudeDiscontinuity = CesiumMath.equalsEpsilon(renderMaxBounds.x, DefaultMaxBounds.x, undefined, epsilonLongitudeDiscontinuity);\n    if (renderIsMinLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\"] = true;\n    }\n    if (renderIsMaxLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\"] = true;\n    }\n    const uvShapeMinLongitude = (shapeMinBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvShapeMaxLongitude = (shapeMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvRenderMaxLongitude = (renderMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZero = 1.0 - renderLongitudeRange / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZeroMid = (uvRenderMaxLongitude + 0.5 * uvRenderLongitudeRangeZero) % 1.0;\n    shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid = Cartesian3.fromElements(uvShapeMinLongitude, uvShapeMaxLongitude, uvRenderLongitudeRangeZeroMid, shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid);\n  }\n  if (renderHasLatitude) {\n    // Intersects a cone for min latitude\n    if (renderHasLatitudeMin) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN\"] = intersectionCount;\n      if (renderIsLatitudeMinUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF\"] = true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF\"] = true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF\"] = true;\n        intersectionCount += 2;\n      }\n    }\n\n    // Intersects a cone for max latitude\n    if (renderHasLatitudeMax) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX\"] = intersectionCount;\n      if (renderIsLatitudeMaxUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF\"] = true;\n        intersectionCount += 2;\n      } else if (renderIsLatitudeMaxHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF\"] = true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMaxOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF\"] = true;\n        intersectionCount += 1;\n      }\n    }\n    shaderUniforms.ellipsoidRenderLatitudeSinMinMax = Cartesian2.fromElements(Math.sin(renderMinBounds.y), Math.sin(renderMaxBounds.y), shaderUniforms.ellipsoidRenderLatitudeSinMinMax);\n  }\n  if (shapeHasLatitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\"] = true;\n\n    // delerp(latitudeUv, minLatitudeUv, maxLatitudeUv)\n    // (latitudeUv - minLatitudeUv) / (maxLatitudeUv - minLatitudeUv)\n    // latitudeUv / (maxLatitudeUv - minLatitudeUv) - minLatitudeUv / (maxLatitudeUv - minLatitudeUv)\n    // scale = 1.0 / (maxLatitudeUv - minLatitudeUv)\n    // scale = 1.0 / (((maxLatitude - pi) / (2.0 * pi)) - ((minLatitude - pi) / (2.0 * pi)))\n    // scale = 2.0 * pi / (maxLatitude - minLatitude)\n    // offset = -minLatitudeUv / (maxLatitudeUv - minLatitudeUv)\n    // offset = -((minLatitude - -pi) / (2.0 * pi)) / (((maxLatitude - pi) / (2.0 * pi)) - ((minLatitude - pi) / (2.0 * pi)))\n    // offset = -(minLatitude - -pi) / (maxLatitude - minLatitude)\n    // offset = (-pi - minLatitude) / (maxLatitude - minLatitude)\n    if (shapeLatitudeRange < epsilonLatitude) {\n      shaderUniforms.ellipsoidUvToShapeUvLatitude = Cartesian2.fromElements(0.0, 1.0, shaderUniforms.ellipsoidUvToShapeUvLatitude);\n    } else {\n      const defaultLatitudeRange = DefaultMaxBounds.y - DefaultMinBounds.y;\n      const scale = defaultLatitudeRange / shapeLatitudeRange;\n      const offset = (DefaultMinBounds.y - shapeMinBounds.y) / shapeLatitudeRange;\n      shaderUniforms.ellipsoidUvToShapeUvLatitude = Cartesian2.fromElements(scale, offset, shaderUniforms.ellipsoidUvToShapeUvLatitude);\n    }\n  }\n  this.shaderMaximumIntersectionsLength = intersectionCount;\n  return true;\n};\nconst scratchRectangle = new Rectangle();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForTile = function (tileLevel, tileX, tileY, tileZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n  const minLongitudeLerp = tileX * sizeAtLevel;\n  const maxLongitudeLerp = (tileX + 1) * sizeAtLevel;\n  const minLatitudeLerp = tileY * sizeAtLevel;\n  const maxLatitudeLerp = (tileY + 1) * sizeAtLevel;\n  const minHeightLerp = tileZ * sizeAtLevel;\n  const maxHeightLerp = (tileZ + 1) * sizeAtLevel;\n  const rectangle = Rectangle.subsection(this._rectangle, minLongitudeLerp, minLatitudeLerp, maxLongitudeLerp, maxLatitudeLerp, scratchRectangle);\n  const minHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, minHeightLerp);\n  const maxHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, maxHeightLerp);\n  return getEllipsoidChunkObb(rectangle, minHeight, maxHeight, this._ellipsoid, this._translation, this._rotation, result);\n};\nconst sampleSizeScratch = new Cartesian3();\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForSample = function (spatialNode, tileDimensions, tileUv, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(Cartesian3.ONE, tileDimensions, sampleSizeScratch);\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(sampleSize, tileSizeAtLevel, sampleSizeScratch);\n  const minLerp = Cartesian3.multiplyByScalar(Cartesian3.fromElements(spatialNode.x + tileUv.x, spatialNode.y + tileUv.y, spatialNode.z + tileUv.z, scratchTileMinBounds), tileSizeAtLevel, scratchTileMinBounds);\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchTileMaxBounds);\n  const rectangle = Rectangle.subsection(this._rectangle, minLerp.x, minLerp.y, maxLerp.x, maxLerp.y, scratchRectangle);\n  const minHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, minLerp.z);\n  const maxHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, maxLerp.z);\n  return getEllipsoidChunkObb(rectangle, minHeight, maxHeight, this._ellipsoid, this._translation, this._rotation, result);\n};\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Rectangle} rectangle The rectangle.\n * @param {number} minHeight The minimumZ.\n * @param {number} maxHeight The maximumZ.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} translation The translation applied to the shape\n * @param {Matrix3} rotation The rotation applied to the shape\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getEllipsoidChunkObb(rectangle, minHeight, maxHeight, ellipsoid, translation, rotation, result) {\n  result = OrientedBoundingBox.fromRectangle(rectangle, minHeight, maxHeight, ellipsoid, result);\n  result.center = Cartesian3.add(result.center, translation, result.center);\n  result.halfAxes = Matrix3.multiply(result.halfAxes, rotation, result.halfAxes);\n  return result;\n}\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum longitude, latitude, height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMinBounds = Object.freeze(new Cartesian3(-CesiumMath.PI, -CesiumMath.PI_OVER_TWO, -Ellipsoid.WGS84.minimumRadius));\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum longitude, latitude, height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMaxBounds = Object.freeze(new Cartesian3(CesiumMath.PI, CesiumMath.PI_OVER_TWO, 10.0 * Ellipsoid.WGS84.maximumRadius));\nexport default VoxelEllipsoidShape;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Check","Ellipsoid","CesiumMath","Matrix3","Matrix4","OrientedBoundingBox","Rectangle","defaultValue","VoxelEllipsoidShape","orientedBoundingBox","boundingSphere","boundTransform","shapeTransform","_rectangle","_minimumHeight","DefaultMinBounds","z","_maximumHeight","DefaultMaxBounds","_ellipsoid","_translation","_rotation","shaderUniforms","ellipsoidRadiiUv","eccentricitySquared","evoluteScale","ellipsoidInverseRadiiSquaredUv","ellipsoidRenderLongitudeMinMax","ellipsoidShapeUvLongitudeMinMaxMid","ellipsoidUvToShapeUvLongitude","ellipsoidUvToShapeUvLatitude","ellipsoidRenderLatitudeSinMinMax","ellipsoidInverseHeightDifferenceUv","clipMinMaxHeight","shaderDefines","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE","undefined","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY","ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE","ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF","ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE","ELLIPSOID_INTERSECTION_INDEX_LONGITUDE","ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX","ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN","ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX","ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN","shaderMaximumIntersectionsLength","scratchActualMinBounds","scratchShapeMinBounds","scratchShapeMaxBounds","scratchClipMinBounds","scratchClipMaxBounds","scratchRenderMinBounds","scratchRenderMaxBounds","scratchScale","scratchRotationScale","scratchShapeOuterExtent","scratchRenderOuterExtent","scratchRenderRectangle","prototype","update","modelMatrix","minBounds","maxBounds","clipMinBounds","clipMaxBounds","typeOf","object","epsilonZeroScale","EPSILON10","epsilonLongitudeDiscontinuity","EPSILON3","epsilonLongitude","epsilonLatitude","epsilonLatitudeFlat","radii","getScale","actualMinBounds","clone","minimumComponent","shapeMinBounds","clamp","shapeMaxBounds","clampedClipMinBounds","clampedClipMaxBounds","renderMinBounds","maximumByComponent","renderMaxBounds","minimumByComponent","shapeOuterExtent","add","fromElements","shapeMaxExtent","maximumComponent","renderOuterExtent","y","equalsEpsilon","ZERO","fromRadians","x","getTranslation","getRotation","fromCartesian3","renderRectangle","getEllipsoidChunkObb","fromRotationTranslation","setScale","halfAxes","center","fromOrientedBoundingBox","defaultLongitudeRange","defaultLongitudeRangeHalf","renderIsLongitudeReversed","renderLongitudeRange","renderIsLongitudeRangeZero","renderIsLongitudeRangeUnderHalf","renderIsLongitudeRangeOverHalf","renderHasLongitude","shapeIsLongitudeReversed","shapeLongitudeRange","shapeIsLongitudeRangeUnderHalf","shapeIsLongitudeRangeHalf","shapeIsLongitudeRangeOverHalf","shapeHasLongitude","renderIsLatitudeMaxUnderHalf","renderIsLatitudeMaxHalf","renderIsLatitudeMaxOverHalf","renderHasLatitudeMax","renderIsLatitudeMinUnderHalf","renderIsLatitudeMinHalf","renderIsLatitudeMinOverHalf","renderHasLatitudeMin","renderHasLatitude","shapeLatitudeRange","shapeIsLatitudeMaxUnderHalf","shapeIsLatitudeMaxHalf","shapeIsLatitudeMaxOverHalf","shapeHasLatitudeMax","shapeIsLatitudeMinUnderHalf","shapeIsLatitudeMinHalf","shapeIsLatitudeMinOverHalf","shapeHasLatitudeMin","shapeHasLatitude","key","hasOwnProperty","divideByScalar","radiiUvX","radiiUvZ","axisRatio","divideComponents","ONE","multiplyComponents","intersectionCount","thickness","scale","offset","renderIsMinLongitudeDiscontinuity","renderIsMaxLongitudeDiscontinuity","uvShapeMinLongitude","uvShapeMaxLongitude","uvRenderMaxLongitude","uvRenderLongitudeRangeZero","uvRenderLongitudeRangeZeroMid","Math","sin","defaultLatitudeRange","scratchRectangle","computeOrientedBoundingBoxForTile","tileLevel","tileX","tileY","tileZ","result","number","sizeAtLevel","pow","minLongitudeLerp","maxLongitudeLerp","minLatitudeLerp","maxLatitudeLerp","minHeightLerp","maxHeightLerp","rectangle","subsection","minHeight","lerp","maxHeight","sampleSizeScratch","scratchTileMinBounds","scratchTileMaxBounds","computeOrientedBoundingBoxForSample","spatialNode","tileDimensions","tileUv","tileSizeAtLevel","level","sampleSize","sampleSizeAtLevel","multiplyByScalar","minLerp","maxLerp","ellipsoid","translation","rotation","fromRectangle","multiply","Object","freeze","PI","PI_OVER_TWO","WGS84","minimumRadius","maximumRadius"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelEllipsoidShape.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * An ellipsoid {@link VoxelShape}.\n *\n * @alias VoxelEllipsoidShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelEllipsoidShape() {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  this.orientedBoundingBox = new OrientedBoundingBox();\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  this.boundingSphere = new BoundingSphere();\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.boundTransform = new Matrix4();\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   * The update function must be called before accessing this value.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.shapeTransform = new Matrix4();\n\n  /**\n   * @type {Rectangle}\n   */\n  this._rectangle = new Rectangle();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumHeight = VoxelEllipsoidShape.DefaultMinBounds.z;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumHeight = VoxelEllipsoidShape.DefaultMaxBounds.z;\n\n  /**\n   * @type {Ellipsoid}\n   * @private\n   */\n  this._ellipsoid = new Ellipsoid();\n\n  /**\n   * @type {Cartesian3}\n   */\n  this._translation = new Cartesian3();\n\n  /**\n   * @type {Matrix3}\n   */\n  this._rotation = new Matrix3();\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderUniforms = {\n    ellipsoidRadiiUv: new Cartesian3(),\n    eccentricitySquared: 0.0,\n    evoluteScale: new Cartesian2(),\n    ellipsoidInverseRadiiSquaredUv: new Cartesian3(),\n    ellipsoidRenderLongitudeMinMax: new Cartesian2(),\n    ellipsoidShapeUvLongitudeMinMaxMid: new Cartesian3(),\n    ellipsoidUvToShapeUvLongitude: new Cartesian2(),\n    ellipsoidUvToShapeUvLatitude: new Cartesian2(),\n    ellipsoidRenderLatitudeSinMinMax: new Cartesian2(),\n    ellipsoidInverseHeightDifferenceUv: 0.0,\n    clipMinMaxHeight: new Cartesian2(),\n  };\n\n  /**\n   * @type {Object<string, any>}\n   * @readonly\n   */\n  this.shaderDefines = {\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LONGITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN: undefined,\n  };\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @type {number}\n   * @readonly\n   */\n  this.shaderMaximumIntersectionsLength = 0; // not known until update\n}\n\nconst scratchActualMinBounds = new Cartesian3();\nconst scratchShapeMinBounds = new Cartesian3();\nconst scratchShapeMaxBounds = new Cartesian3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchRotationScale = new Matrix3();\nconst scratchShapeOuterExtent = new Cartesian3();\nconst scratchRenderOuterExtent = new Cartesian3();\nconst scratchRenderRectangle = new Rectangle();\n\n/**\n * Update the shape's state.\n *\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelEllipsoidShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelEllipsoidShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelEllipsoidShape.prototype.update = function (\n  modelMatrix,\n  minBounds,\n  maxBounds,\n  clipMinBounds,\n  clipMaxBounds,\n) {\n  const { DefaultMinBounds, DefaultMaxBounds } = VoxelEllipsoidShape;\n  clipMinBounds = defaultValue(clipMinBounds, DefaultMinBounds);\n  clipMaxBounds = defaultValue(clipMaxBounds, DefaultMaxBounds);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonLongitudeDiscontinuity = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n  const epsilonLongitude = CesiumMath.EPSILON10;\n  const epsilonLatitude = CesiumMath.EPSILON10;\n  const epsilonLatitudeFlat = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n\n  // Don't let the height go below the center of the ellipsoid.\n  const radii = Matrix4.getScale(modelMatrix, scratchScale);\n  const actualMinBounds = Cartesian3.clone(\n    DefaultMinBounds,\n    scratchActualMinBounds,\n  );\n  actualMinBounds.z = -Cartesian3.minimumComponent(radii);\n\n  const shapeMinBounds = Cartesian3.clamp(\n    minBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchShapeMinBounds,\n  );\n  const shapeMaxBounds = Cartesian3.clamp(\n    maxBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchShapeMaxBounds,\n  );\n  const clampedClipMinBounds = Cartesian3.clamp(\n    clipMinBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchClipMinBounds,\n  );\n  const clampedClipMaxBounds = Cartesian3.clamp(\n    clipMaxBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchClipMaxBounds,\n  );\n  const renderMinBounds = Cartesian3.maximumByComponent(\n    shapeMinBounds,\n    clampedClipMinBounds,\n    scratchRenderMinBounds,\n  );\n  const renderMaxBounds = Cartesian3.minimumByComponent(\n    shapeMaxBounds,\n    clampedClipMaxBounds,\n    scratchRenderMaxBounds,\n  );\n\n  // Compute the farthest a point can be from the center of the ellipsoid.\n  const shapeOuterExtent = Cartesian3.add(\n    radii,\n    Cartesian3.fromElements(\n      shapeMaxBounds.z,\n      shapeMaxBounds.z,\n      shapeMaxBounds.z,\n      scratchShapeOuterExtent,\n    ),\n    scratchShapeOuterExtent,\n  );\n  const shapeMaxExtent = Cartesian3.maximumComponent(shapeOuterExtent);\n\n  const renderOuterExtent = Cartesian3.add(\n    radii,\n    Cartesian3.fromElements(\n      renderMaxBounds.z,\n      renderMaxBounds.z,\n      renderMaxBounds.z,\n      scratchRenderOuterExtent,\n    ),\n    scratchRenderOuterExtent,\n  );\n\n  // Exit early if the shape is not visible.\n  // Note that minLongitude may be greater than maxLongitude when crossing the 180th meridian.\n  if (\n    renderMinBounds.y > renderMaxBounds.y ||\n    renderMinBounds.y === DefaultMaxBounds.y ||\n    renderMaxBounds.y === DefaultMinBounds.y ||\n    renderMinBounds.z > renderMaxBounds.z ||\n    CesiumMath.equalsEpsilon(\n      renderOuterExtent,\n      Cartesian3.ZERO,\n      undefined,\n      epsilonZeroScale,\n    )\n  ) {\n    return false;\n  }\n\n  this._rectangle = Rectangle.fromRadians(\n    shapeMinBounds.x,\n    shapeMinBounds.y,\n    shapeMaxBounds.x,\n    shapeMaxBounds.y,\n  );\n  this._translation = Matrix4.getTranslation(modelMatrix, this._translation);\n  this._rotation = Matrix4.getRotation(modelMatrix, this._rotation);\n  this._ellipsoid = Ellipsoid.fromCartesian3(radii, this._ellipsoid);\n  this._minimumHeight = shapeMinBounds.z;\n  this._maximumHeight = shapeMaxBounds.z;\n\n  const renderRectangle = Rectangle.fromRadians(\n    renderMinBounds.x,\n    renderMinBounds.y,\n    renderMaxBounds.x,\n    renderMaxBounds.y,\n    scratchRenderRectangle,\n  );\n\n  this.orientedBoundingBox = getEllipsoidChunkObb(\n    renderRectangle,\n    renderMinBounds.z,\n    renderMaxBounds.z,\n    this._ellipsoid,\n    this._translation,\n    this._rotation,\n    this.orientedBoundingBox,\n  );\n\n  this.shapeTransform = Matrix4.fromRotationTranslation(\n    Matrix3.setScale(this._rotation, shapeOuterExtent, scratchRotationScale),\n    this._translation,\n    this.shapeTransform,\n  );\n\n  this.boundTransform = Matrix4.fromRotationTranslation(\n    this.orientedBoundingBox.halfAxes,\n    this.orientedBoundingBox.center,\n    this.boundTransform,\n  );\n\n  this.boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this.orientedBoundingBox,\n    this.boundingSphere,\n  );\n\n  // Longitude\n  const defaultLongitudeRange = DefaultMaxBounds.x - DefaultMinBounds.x;\n  const defaultLongitudeRangeHalf = 0.5 * defaultLongitudeRange;\n  const renderIsLongitudeReversed = renderMaxBounds.x < renderMinBounds.x;\n  const renderLongitudeRange =\n    renderMaxBounds.x -\n    renderMinBounds.x +\n    renderIsLongitudeReversed * defaultLongitudeRange;\n  const renderIsLongitudeRangeZero = renderLongitudeRange <= epsilonLongitude;\n  const renderIsLongitudeRangeUnderHalf =\n    renderLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude &&\n    renderLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const renderIsLongitudeRangeOverHalf =\n    renderLongitudeRange > epsilonLongitude &&\n    renderLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const renderHasLongitude =\n    renderIsLongitudeRangeZero ||\n    renderIsLongitudeRangeUnderHalf ||\n    renderIsLongitudeRangeOverHalf;\n\n  const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n  const shapeLongitudeRange =\n    shapeMaxBounds.x -\n    shapeMinBounds.x +\n    shapeIsLongitudeReversed * defaultLongitudeRange;\n  const shapeIsLongitudeRangeUnderHalf =\n    shapeLongitudeRange > defaultLongitudeRangeHalf + epsilonLongitude &&\n    shapeLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const shapeIsLongitudeRangeHalf =\n    shapeLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude &&\n    shapeLongitudeRange <= defaultLongitudeRangeHalf + epsilonLongitude;\n  const shapeIsLongitudeRangeOverHalf =\n    shapeLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const shapeHasLongitude =\n    shapeIsLongitudeRangeUnderHalf ||\n    shapeIsLongitudeRangeHalf ||\n    shapeIsLongitudeRangeOverHalf;\n\n  // Latitude\n  const renderIsLatitudeMaxUnderHalf = renderMaxBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMaxHalf =\n    renderMaxBounds.y >= -epsilonLatitudeFlat &&\n    renderMaxBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMaxOverHalf =\n    renderMaxBounds.y > +epsilonLatitudeFlat &&\n    renderMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const renderHasLatitudeMax =\n    renderIsLatitudeMaxUnderHalf ||\n    renderIsLatitudeMaxHalf ||\n    renderIsLatitudeMaxOverHalf;\n  const renderIsLatitudeMinUnderHalf =\n    renderMinBounds.y > DefaultMinBounds.y + epsilonLatitude &&\n    renderMinBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMinHalf =\n    renderMinBounds.y >= -epsilonLatitudeFlat &&\n    renderMinBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMinOverHalf = renderMinBounds.y > +epsilonLatitudeFlat;\n  const renderHasLatitudeMin =\n    renderIsLatitudeMinUnderHalf ||\n    renderIsLatitudeMinHalf ||\n    renderIsLatitudeMinOverHalf;\n  const renderHasLatitude = renderHasLatitudeMax || renderHasLatitudeMin;\n\n  const shapeLatitudeRange = shapeMaxBounds.y - shapeMinBounds.y;\n  const shapeIsLatitudeMaxUnderHalf = shapeMaxBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxHalf =\n    shapeMaxBounds.y >= -epsilonLatitudeFlat &&\n    shapeMaxBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxOverHalf =\n    shapeMaxBounds.y > +epsilonLatitudeFlat &&\n    shapeMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const shapeHasLatitudeMax =\n    shapeIsLatitudeMaxUnderHalf ||\n    shapeIsLatitudeMaxHalf ||\n    shapeIsLatitudeMaxOverHalf;\n  const shapeIsLatitudeMinUnderHalf =\n    shapeMinBounds.y > DefaultMinBounds.y + epsilonLatitude &&\n    shapeMinBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMinHalf =\n    shapeMinBounds.y >= -epsilonLatitudeFlat &&\n    shapeMinBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMinOverHalf = shapeMinBounds.y > +epsilonLatitudeFlat;\n  const shapeHasLatitudeMin =\n    shapeIsLatitudeMinUnderHalf ||\n    shapeIsLatitudeMinHalf ||\n    shapeIsLatitudeMinOverHalf;\n  const shapeHasLatitude = shapeHasLatitudeMax || shapeHasLatitudeMin;\n\n  const { shaderUniforms, shaderDefines } = this;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // The ellipsoid radii scaled to [0,1]. The max ellipsoid radius will be 1.0 and others will be less.\n  shaderUniforms.ellipsoidRadiiUv = Cartesian3.divideByScalar(\n    shapeOuterExtent,\n    shapeMaxExtent,\n    shaderUniforms.ellipsoidRadiiUv,\n  );\n  const { x: radiiUvX, z: radiiUvZ } = shaderUniforms.ellipsoidRadiiUv;\n  const axisRatio = radiiUvZ / radiiUvX;\n  shaderUniforms.eccentricitySquared = 1.0 - axisRatio * axisRatio;\n  shaderUniforms.evoluteScale = Cartesian2.fromElements(\n    (radiiUvX * radiiUvX - radiiUvZ * radiiUvZ) / radiiUvX,\n    (radiiUvZ * radiiUvZ - radiiUvX * radiiUvX) / radiiUvZ,\n    shaderUniforms.evoluteScale,\n  );\n\n  // Used to compute geodetic surface normal.\n  shaderUniforms.ellipsoidInverseRadiiSquaredUv = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    Cartesian3.multiplyComponents(\n      shaderUniforms.ellipsoidRadiiUv,\n      shaderUniforms.ellipsoidRadiiUv,\n      shaderUniforms.ellipsoidInverseRadiiSquaredUv,\n    ),\n    shaderUniforms.ellipsoidInverseRadiiSquaredUv,\n  );\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  // Intersects outer and inner ellipsoid for the max and min height.\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN\"] = intersectionCount;\n  intersectionCount += 1;\n\n  shaderUniforms.clipMinMaxHeight = Cartesian2.fromElements(\n    (renderMinBounds.z - shapeMaxBounds.z) / shapeMaxExtent,\n    (renderMaxBounds.z - shapeMaxBounds.z) / shapeMaxExtent,\n    shaderUniforms.clipMinMaxHeight,\n  );\n\n  // The percent of space that is between the inner and outer ellipsoid.\n  const thickness = (shapeMaxBounds.z - shapeMinBounds.z) / shapeMaxExtent;\n  shaderUniforms.ellipsoidInverseHeightDifferenceUv = 1.0 / thickness;\n  if (shapeMinBounds.z === shapeMaxBounds.z) {\n    shaderUniforms.ellipsoidInverseHeightDifferenceUv = 0.0;\n  }\n\n  // Intersects a wedge for the min and max longitude.\n  if (renderHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE\"] = true;\n    shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LONGITUDE\"] = intersectionCount;\n\n    if (renderIsLongitudeRangeUnderHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF\"] =\n        true;\n      intersectionCount += 1;\n    } else if (renderIsLongitudeRangeOverHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF\"] =\n        true;\n      intersectionCount += 2;\n    } else if (renderIsLongitudeRangeZero) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO\"] =\n        true;\n      intersectionCount += 2;\n    }\n\n    shaderUniforms.ellipsoidRenderLongitudeMinMax = Cartesian2.fromElements(\n      renderMinBounds.x,\n      renderMaxBounds.x,\n      shaderUniforms.ellipsoidRenderLongitudeMinMax,\n    );\n  }\n\n  if (shapeHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\"] = true;\n\n    const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n\n    if (shapeIsLongitudeReversed) {\n      shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\"] =\n        true;\n    }\n\n    // delerp(longitudeUv, minLongitudeUv, maxLongitudeUv)\n    // (longitudeUv - minLongitudeUv) / (maxLongitudeUv - minLongitudeUv)\n    // longitudeUv / (maxLongitudeUv - minLongitudeUv) - minLongitudeUv / (maxLongitudeUv - minLongitudeUv)\n    // scale = 1.0 / (maxLongitudeUv - minLongitudeUv)\n    // scale = 1.0 / (((maxLongitude - pi) / (2.0 * pi)) - ((minLongitude - pi) / (2.0 * pi)))\n    // scale = 2.0 * pi / (maxLongitude - minLongitude)\n    // offset = -minLongitudeUv / (maxLongitudeUv - minLongitudeUv)\n    // offset = -((minLongitude - pi) / (2.0 * pi)) / (((maxLongitude - pi) / (2.0 * pi)) - ((minLongitude - pi) / (2.0 * pi)))\n    // offset = -(minLongitude - pi) / (maxLongitude - minLongitude)\n    if (shapeLongitudeRange <= epsilonLongitude) {\n      shaderUniforms.ellipsoidUvToShapeUvLongitude = Cartesian2.fromElements(\n        0.0,\n        1.0,\n        shaderUniforms.ellipsoidUvToShapeUvLongitude,\n      );\n    } else {\n      const scale = defaultLongitudeRange / shapeLongitudeRange;\n      const offset =\n        -(shapeMinBounds.x - DefaultMinBounds.x) / shapeLongitudeRange;\n      shaderUniforms.ellipsoidUvToShapeUvLongitude = Cartesian2.fromElements(\n        scale,\n        offset,\n        shaderUniforms.ellipsoidUvToShapeUvLongitude,\n      );\n    }\n  }\n\n  if (renderHasLongitude) {\n    const renderIsMinLongitudeDiscontinuity = CesiumMath.equalsEpsilon(\n      renderMinBounds.x,\n      DefaultMinBounds.x,\n      undefined,\n      epsilonLongitudeDiscontinuity,\n    );\n    const renderIsMaxLongitudeDiscontinuity = CesiumMath.equalsEpsilon(\n      renderMaxBounds.x,\n      DefaultMaxBounds.x,\n      undefined,\n      epsilonLongitudeDiscontinuity,\n    );\n\n    if (renderIsMinLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\"] =\n        true;\n    }\n    if (renderIsMaxLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\"] =\n        true;\n    }\n    const uvShapeMinLongitude =\n      (shapeMinBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvShapeMaxLongitude =\n      (shapeMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n\n    const uvRenderMaxLongitude =\n      (renderMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZero =\n      1.0 - renderLongitudeRange / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZeroMid =\n      (uvRenderMaxLongitude + 0.5 * uvRenderLongitudeRangeZero) % 1.0;\n\n    shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid = Cartesian3.fromElements(\n      uvShapeMinLongitude,\n      uvShapeMaxLongitude,\n      uvRenderLongitudeRangeZeroMid,\n      shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid,\n    );\n  }\n\n  if (renderHasLatitude) {\n    // Intersects a cone for min latitude\n    if (renderHasLatitudeMin) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN\"] =\n        intersectionCount;\n\n      if (renderIsLatitudeMinUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF\"] =\n          true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF\"] =\n          true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF\"] =\n          true;\n        intersectionCount += 2;\n      }\n    }\n\n    // Intersects a cone for max latitude\n    if (renderHasLatitudeMax) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX\"] =\n        intersectionCount;\n\n      if (renderIsLatitudeMaxUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF\"] =\n          true;\n        intersectionCount += 2;\n      } else if (renderIsLatitudeMaxHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF\"] =\n          true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMaxOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF\"] =\n          true;\n        intersectionCount += 1;\n      }\n    }\n\n    shaderUniforms.ellipsoidRenderLatitudeSinMinMax = Cartesian2.fromElements(\n      Math.sin(renderMinBounds.y),\n      Math.sin(renderMaxBounds.y),\n      shaderUniforms.ellipsoidRenderLatitudeSinMinMax,\n    );\n  }\n\n  if (shapeHasLatitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\"] = true;\n\n    // delerp(latitudeUv, minLatitudeUv, maxLatitudeUv)\n    // (latitudeUv - minLatitudeUv) / (maxLatitudeUv - minLatitudeUv)\n    // latitudeUv / (maxLatitudeUv - minLatitudeUv) - minLatitudeUv / (maxLatitudeUv - minLatitudeUv)\n    // scale = 1.0 / (maxLatitudeUv - minLatitudeUv)\n    // scale = 1.0 / (((maxLatitude - pi) / (2.0 * pi)) - ((minLatitude - pi) / (2.0 * pi)))\n    // scale = 2.0 * pi / (maxLatitude - minLatitude)\n    // offset = -minLatitudeUv / (maxLatitudeUv - minLatitudeUv)\n    // offset = -((minLatitude - -pi) / (2.0 * pi)) / (((maxLatitude - pi) / (2.0 * pi)) - ((minLatitude - pi) / (2.0 * pi)))\n    // offset = -(minLatitude - -pi) / (maxLatitude - minLatitude)\n    // offset = (-pi - minLatitude) / (maxLatitude - minLatitude)\n    if (shapeLatitudeRange < epsilonLatitude) {\n      shaderUniforms.ellipsoidUvToShapeUvLatitude = Cartesian2.fromElements(\n        0.0,\n        1.0,\n        shaderUniforms.ellipsoidUvToShapeUvLatitude,\n      );\n    } else {\n      const defaultLatitudeRange = DefaultMaxBounds.y - DefaultMinBounds.y;\n      const scale = defaultLatitudeRange / shapeLatitudeRange;\n      const offset =\n        (DefaultMinBounds.y - shapeMinBounds.y) / shapeLatitudeRange;\n      shaderUniforms.ellipsoidUvToShapeUvLatitude = Cartesian2.fromElements(\n        scale,\n        offset,\n        shaderUniforms.ellipsoidUvToShapeUvLatitude,\n      );\n    }\n  }\n\n  this.shaderMaximumIntersectionsLength = intersectionCount;\n\n  return true;\n};\n\nconst scratchRectangle = new Rectangle();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForTile = function (\n  tileLevel,\n  tileX,\n  tileY,\n  tileZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n  const minLongitudeLerp = tileX * sizeAtLevel;\n  const maxLongitudeLerp = (tileX + 1) * sizeAtLevel;\n  const minLatitudeLerp = tileY * sizeAtLevel;\n  const maxLatitudeLerp = (tileY + 1) * sizeAtLevel;\n  const minHeightLerp = tileZ * sizeAtLevel;\n  const maxHeightLerp = (tileZ + 1) * sizeAtLevel;\n\n  const rectangle = Rectangle.subsection(\n    this._rectangle,\n    minLongitudeLerp,\n    minLatitudeLerp,\n    maxLongitudeLerp,\n    maxLatitudeLerp,\n    scratchRectangle,\n  );\n\n  const minHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    minHeightLerp,\n  );\n\n  const maxHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    maxHeightLerp,\n  );\n\n  return getEllipsoidChunkObb(\n    rectangle,\n    minHeight,\n    maxHeight,\n    this._ellipsoid,\n    this._translation,\n    this._rotation,\n    result,\n  );\n};\n\nconst sampleSizeScratch = new Cartesian3();\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * The update function must be called before calling this function.\n *\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForSample = function (\n  spatialNode,\n  tileDimensions,\n  tileUv,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    tileDimensions,\n    sampleSizeScratch,\n  );\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(\n    sampleSize,\n    tileSizeAtLevel,\n    sampleSizeScratch,\n  );\n\n  const minLerp = Cartesian3.multiplyByScalar(\n    Cartesian3.fromElements(\n      spatialNode.x + tileUv.x,\n      spatialNode.y + tileUv.y,\n      spatialNode.z + tileUv.z,\n      scratchTileMinBounds,\n    ),\n    tileSizeAtLevel,\n    scratchTileMinBounds,\n  );\n  const maxLerp = Cartesian3.add(\n    minLerp,\n    sampleSizeAtLevel,\n    scratchTileMaxBounds,\n  );\n\n  const rectangle = Rectangle.subsection(\n    this._rectangle,\n    minLerp.x,\n    minLerp.y,\n    maxLerp.x,\n    maxLerp.y,\n    scratchRectangle,\n  );\n  const minHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    minLerp.z,\n  );\n  const maxHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    maxLerp.z,\n  );\n\n  return getEllipsoidChunkObb(\n    rectangle,\n    minHeight,\n    maxHeight,\n    this._ellipsoid,\n    this._translation,\n    this._rotation,\n    result,\n  );\n};\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Rectangle} rectangle The rectangle.\n * @param {number} minHeight The minimumZ.\n * @param {number} maxHeight The maximumZ.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} translation The translation applied to the shape\n * @param {Matrix3} rotation The rotation applied to the shape\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getEllipsoidChunkObb(\n  rectangle,\n  minHeight,\n  maxHeight,\n  ellipsoid,\n  translation,\n  rotation,\n  result,\n) {\n  result = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minHeight,\n    maxHeight,\n    ellipsoid,\n    result,\n  );\n  result.center = Cartesian3.add(result.center, translation, result.center);\n  result.halfAxes = Matrix3.multiply(\n    result.halfAxes,\n    rotation,\n    result.halfAxes,\n  );\n  return result;\n}\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum longitude, latitude, height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMinBounds = Object.freeze(\n  new Cartesian3(\n    -CesiumMath.PI,\n    -CesiumMath.PI_OVER_TWO,\n    -Ellipsoid.WGS84.minimumRadius,\n  ),\n);\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum longitude, latitude, height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMaxBounds = Object.freeze(\n  new Cartesian3(\n    CesiumMath.PI,\n    CesiumMath.PI_OVER_TWO,\n    10.0 * Ellipsoid.WGS84.maximumRadius,\n  ),\n);\n\nexport default VoxelEllipsoidShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}