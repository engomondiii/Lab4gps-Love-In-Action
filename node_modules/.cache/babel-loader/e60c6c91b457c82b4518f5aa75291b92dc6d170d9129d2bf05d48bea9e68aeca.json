{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Creates tweens for camera flights.\n * <br /><br />\n * Mouse interaction is disabled during flights.\n *\n * @private\n */\nconst CameraFlightPath = {};\nfunction getAltitude(frustum, dx, dy) {\n  let near;\n  let top;\n  let right;\n  if (frustum instanceof PerspectiveFrustum) {\n    const tanTheta = Math.tan(0.5 * frustum.fovy);\n    near = frustum.near;\n    top = frustum.near * tanTheta;\n    right = frustum.aspectRatio * top;\n    return Math.max(dx * near / right, dy * near / top);\n  } else if (frustum instanceof PerspectiveOffCenterFrustum) {\n    near = frustum.near;\n    top = frustum.top;\n    right = frustum.right;\n    return Math.max(dx * near / right, dy * near / top);\n  }\n  return Math.max(dx, dy);\n}\nconst scratchCart = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\nfunction createPitchFunction(startPitch, endPitch, heightFunction, pitchAdjustHeight) {\n  if (defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {\n    const startHeight = heightFunction(0.0);\n    const endHeight = heightFunction(1.0);\n    const middleHeight = heightFunction(0.5);\n    const d1 = middleHeight - startHeight;\n    const d2 = middleHeight - endHeight;\n    return function (time) {\n      const altitude = heightFunction(time);\n      if (time <= 0.5) {\n        const t1 = (altitude - startHeight) / d1;\n        return CesiumMath.lerp(startPitch, -CesiumMath.PI_OVER_TWO, t1);\n      }\n      const t2 = (altitude - endHeight) / d2;\n      return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO, endPitch, 1 - t2);\n    };\n  }\n  return function (time) {\n    return CesiumMath.lerp(startPitch, endPitch, time);\n  };\n}\nfunction createHeightFunction(camera, destination, startHeight, endHeight, optionAltitude) {\n  let altitude = optionAltitude;\n  const maxHeight = Math.max(startHeight, endHeight);\n  if (!defined(altitude)) {\n    const start = camera.position;\n    const end = destination;\n    const up = camera.up;\n    const right = camera.right;\n    const frustum = camera.frustum;\n    const diff = Cartesian3.subtract(start, end, scratchCart);\n    const verticalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2));\n    const horizontalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(right, Cartesian3.dot(diff, right), scratchCart2));\n    altitude = Math.min(getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2, 1000000000.0);\n  }\n  if (maxHeight < altitude) {\n    const power = 8.0;\n    const factor = 1000000.0;\n    const s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);\n    const e = Math.pow((altitude - endHeight) * factor, 1.0 / power);\n    return function (t) {\n      const x = t * (e - s) + s;\n      return -Math.pow(x, power) / factor + altitude;\n    };\n  }\n  return function (t) {\n    return CesiumMath.lerp(startHeight, endHeight, t);\n  };\n}\nfunction adjustAngleForLERP(startAngle, endAngle) {\n  if (CesiumMath.equalsEpsilon(startAngle, CesiumMath.TWO_PI, CesiumMath.EPSILON11)) {\n    startAngle = 0.0;\n  }\n  if (endAngle > startAngle + Math.PI) {\n    startAngle += CesiumMath.TWO_PI;\n  } else if (endAngle < startAngle - Math.PI) {\n    startAngle -= CesiumMath.TWO_PI;\n  }\n  return startAngle;\n}\nconst scratchStart = new Cartesian3();\nfunction createUpdateCV(scene, duration, destination, heading, pitch, roll, optionAltitude, optionPitchAdjustHeight) {\n  const camera = scene.camera;\n  const start = Cartesian3.clone(camera.position, scratchStart);\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n  const heightFunction = createHeightFunction(camera, destination, start.z, destination.z, optionAltitude);\n  const pitchFunction = createPitchFunction(startPitch, pitch, heightFunction, optionPitchAdjustHeight);\n  function update(value) {\n    const time = value.time / duration;\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n        pitch: pitchFunction(time),\n        roll: CesiumMath.lerp(startRoll, roll, time)\n      }\n    });\n    Cartesian2.lerp(start, destination, time, camera.position);\n    camera.position.z = heightFunction(time);\n  }\n  return update;\n}\nfunction useLongestFlight(startCart, destCart) {\n  if (startCart.longitude < destCart.longitude) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\nfunction useShortestFlight(startCart, destCart) {\n  const diff = startCart.longitude - destCart.longitude;\n  if (diff < -CesiumMath.PI) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else if (diff > CesiumMath.PI) {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\nconst scratchStartCart = new Cartographic();\nconst scratchEndCart = new Cartographic();\nfunction createUpdate3D(scene, duration, destination, heading, pitch, roll, optionAltitude, optionFlyOverLongitude, optionFlyOverLongitudeWeight, optionPitchAdjustHeight) {\n  const camera = scene.camera;\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const startCart = Cartographic.clone(camera.positionCartographic, scratchStartCart);\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n  const destCart = ellipsoid.cartesianToCartographic(destination, scratchEndCart);\n  startCart.longitude = CesiumMath.zeroToTwoPi(startCart.longitude);\n  destCart.longitude = CesiumMath.zeroToTwoPi(destCart.longitude);\n  let useLongFlight = false;\n  if (defined(optionFlyOverLongitude)) {\n    const hitLon = CesiumMath.zeroToTwoPi(optionFlyOverLongitude);\n    const lonMin = Math.min(startCart.longitude, destCart.longitude);\n    const lonMax = Math.max(startCart.longitude, destCart.longitude);\n    const hitInside = hitLon >= lonMin && hitLon <= lonMax;\n    if (defined(optionFlyOverLongitudeWeight)) {\n      // Distance inside  (0...2Pi)\n      const din = Math.abs(startCart.longitude - destCart.longitude);\n      // Distance outside (0...2Pi)\n      const dot = CesiumMath.TWO_PI - din;\n      const hitDistance = hitInside ? din : dot;\n      const offDistance = hitInside ? dot : din;\n      if (hitDistance < offDistance * optionFlyOverLongitudeWeight && !hitInside) {\n        useLongFlight = true;\n      }\n    } else if (!hitInside) {\n      useLongFlight = true;\n    }\n  }\n  if (useLongFlight) {\n    useLongestFlight(startCart, destCart);\n  } else {\n    useShortestFlight(startCart, destCart);\n  }\n  const heightFunction = createHeightFunction(camera, destination, startCart.height, destCart.height, optionAltitude);\n  const pitchFunction = createPitchFunction(startPitch, pitch, heightFunction, optionPitchAdjustHeight);\n\n  // Isolate scope for update function.\n  // to have local copies of vars used in lerp\n  // Othervise, if you call nex\n  // createUpdate3D (createAnimationTween)\n  // before you played animation, variables will be overwriten.\n  function isolateUpdateFunction() {\n    const startLongitude = startCart.longitude;\n    const destLongitude = destCart.longitude;\n    const startLatitude = startCart.latitude;\n    const destLatitude = destCart.latitude;\n    return function update(value) {\n      const time = value.time / duration;\n      const position = Cartesian3.fromRadians(CesiumMath.lerp(startLongitude, destLongitude, time), CesiumMath.lerp(startLatitude, destLatitude, time), heightFunction(time), ellipsoid);\n      camera.setView({\n        destination: position,\n        orientation: {\n          heading: CesiumMath.lerp(startHeading, heading, time),\n          pitch: pitchFunction(time),\n          roll: CesiumMath.lerp(startRoll, roll, time)\n        }\n      });\n    };\n  }\n  return isolateUpdateFunction();\n}\nfunction createUpdate2D(scene, duration, destination, heading, pitch, roll, optionAltitude) {\n  const camera = scene.camera;\n  const start = Cartesian3.clone(camera.position, scratchStart);\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startHeight = camera.frustum.right - camera.frustum.left;\n  const heightFunction = createHeightFunction(camera, destination, startHeight, destination.z, optionAltitude);\n  function update(value) {\n    const time = value.time / duration;\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time)\n      }\n    });\n    Cartesian2.lerp(start, destination, time, camera.position);\n    const zoom = heightFunction(time);\n    const frustum = camera.frustum;\n    const ratio = frustum.top / frustum.right;\n    const incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;\n    frustum.right += incrementAmount;\n    frustum.left -= incrementAmount;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n  return update;\n}\nconst scratchCartographic = new Cartographic();\nconst scratchDestination = new Cartesian3();\nfunction emptyFlight(complete, cancel) {\n  return {\n    startObject: {},\n    stopObject: {},\n    duration: 0.0,\n    complete: complete,\n    cancel: cancel\n  };\n}\nfunction wrapCallback(controller, cb) {\n  function wrapped() {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n    controller.enableInputs = true;\n  }\n  return wrapped;\n}\nCameraFlightPath.createTween = function (scene, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n  const mode = scene.mode;\n  if (mode === SceneMode.MORPHING) {\n    return emptyFlight();\n  }\n  const convert = defaultValue(options.convert, true);\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const maximumHeight = options.maximumHeight;\n  const flyOverLongitude = options.flyOverLongitude;\n  const flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  const pitchAdjustHeight = options.pitchAdjustHeight;\n  let easingFunction = options.easingFunction;\n  if (convert && mode !== SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(destination, scratchCartographic);\n    destination = projection.project(scratchCartographic, scratchDestination);\n  }\n  const camera = scene.camera;\n  const transform = options.endTransform;\n  if (defined(transform)) {\n    camera._setTransform(transform);\n  }\n  let duration = options.duration;\n  if (!defined(duration)) {\n    duration = Math.ceil(Cartesian3.distance(camera.position, destination) / 1000000.0) + 2.0;\n    duration = Math.min(duration, 3.0);\n  }\n  const heading = defaultValue(options.heading, 0.0);\n  const pitch = defaultValue(options.pitch, -CesiumMath.PI_OVER_TWO);\n  const roll = defaultValue(options.roll, 0.0);\n  const controller = scene.screenSpaceCameraController;\n  controller.enableInputs = false;\n  const complete = wrapCallback(controller, options.complete);\n  const cancel = wrapCallback(controller, options.cancel);\n  const frustum = camera.frustum;\n  let empty = scene.mode === SceneMode.SCENE2D;\n  empty = empty && Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6);\n  empty = empty && CesiumMath.equalsEpsilon(Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom), destination.z, CesiumMath.EPSILON6);\n  empty = empty || scene.mode !== SceneMode.SCENE2D && Cartesian3.equalsEpsilon(destination, camera.position, CesiumMath.EPSILON10);\n  empty = empty && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(heading), CesiumMath.negativePiToPi(camera.heading), CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(pitch), CesiumMath.negativePiToPi(camera.pitch), CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(roll), CesiumMath.negativePiToPi(camera.roll), CesiumMath.EPSILON10);\n  if (empty) {\n    return emptyFlight(complete, cancel);\n  }\n  const updateFunctions = new Array(4);\n  updateFunctions[SceneMode.SCENE2D] = createUpdate2D;\n  updateFunctions[SceneMode.SCENE3D] = createUpdate3D;\n  updateFunctions[SceneMode.COLUMBUS_VIEW] = createUpdateCV;\n  if (duration <= 0.0) {\n    const newOnComplete = function () {\n      const update = updateFunctions[mode](scene, 1.0, destination, heading, pitch, roll, maximumHeight, flyOverLongitude, flyOverLongitudeWeight, pitchAdjustHeight);\n      update({\n        time: 1.0\n      });\n      if (typeof complete === \"function\") {\n        complete();\n      }\n    };\n    return emptyFlight(newOnComplete, cancel);\n  }\n  const update = updateFunctions[mode](scene, duration, destination, heading, pitch, roll, maximumHeight, flyOverLongitude, flyOverLongitudeWeight, pitchAdjustHeight);\n  if (!defined(easingFunction)) {\n    const startHeight = camera.positionCartographic.height;\n    const endHeight = mode === SceneMode.SCENE3D ? ellipsoid.cartesianToCartographic(destination).height : destination.z;\n    if (startHeight > endHeight && startHeight > 11500.0) {\n      easingFunction = EasingFunction.CUBIC_OUT;\n    } else {\n      easingFunction = EasingFunction.QUINTIC_IN_OUT;\n    }\n  }\n  return {\n    duration: duration,\n    easingFunction: easingFunction,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: duration\n    },\n    update: update,\n    complete: complete,\n    cancel: cancel\n  };\n};\nexport default CameraFlightPath;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartographic","defaultValue","defined","DeveloperError","EasingFunction","CesiumMath","PerspectiveFrustum","PerspectiveOffCenterFrustum","SceneMode","CameraFlightPath","getAltitude","frustum","dx","dy","near","top","right","tanTheta","Math","tan","fovy","aspectRatio","max","scratchCart","scratchCart2","createPitchFunction","startPitch","endPitch","heightFunction","pitchAdjustHeight","startHeight","endHeight","middleHeight","d1","d2","time","altitude","t1","lerp","PI_OVER_TWO","t2","createHeightFunction","camera","destination","optionAltitude","maxHeight","start","position","end","up","diff","subtract","verticalDistance","magnitude","multiplyByScalar","dot","horizontalDistance","min","power","factor","s","pow","e","t","x","adjustAngleForLERP","startAngle","endAngle","equalsEpsilon","TWO_PI","EPSILON11","PI","scratchStart","createUpdateCV","scene","duration","heading","pitch","roll","optionPitchAdjustHeight","clone","startHeading","startRoll","z","pitchFunction","update","value","setView","orientation","useLongestFlight","startCart","destCart","longitude","useShortestFlight","scratchStartCart","scratchEndCart","createUpdate3D","optionFlyOverLongitude","optionFlyOverLongitudeWeight","projection","mapProjection","ellipsoid","positionCartographic","cartesianToCartographic","zeroToTwoPi","useLongFlight","hitLon","lonMin","lonMax","hitInside","din","abs","hitDistance","offDistance","height","isolateUpdateFunction","startLongitude","destLongitude","startLatitude","latitude","destLatitude","fromRadians","createUpdate2D","left","zoom","ratio","incrementAmount","bottom","scratchCartographic","scratchDestination","emptyFlight","complete","cancel","startObject","stopObject","wrapCallback","controller","cb","wrapped","enableInputs","createTween","options","EMPTY_OBJECT","mode","MORPHING","convert","maximumHeight","flyOverLongitude","flyOverLongitudeWeight","easingFunction","SCENE3D","project","transform","endTransform","_setTransform","ceil","distance","screenSpaceCameraController","empty","SCENE2D","EPSILON6","EPSILON10","negativePiToPi","updateFunctions","Array","COLUMBUS_VIEW","newOnComplete","CUBIC_OUT","QUINTIC_IN_OUT"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/CameraFlightPath.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Creates tweens for camera flights.\n * <br /><br />\n * Mouse interaction is disabled during flights.\n *\n * @private\n */\nconst CameraFlightPath = {};\n\nfunction getAltitude(frustum, dx, dy) {\n  let near;\n  let top;\n  let right;\n  if (frustum instanceof PerspectiveFrustum) {\n    const tanTheta = Math.tan(0.5 * frustum.fovy);\n    near = frustum.near;\n    top = frustum.near * tanTheta;\n    right = frustum.aspectRatio * top;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  } else if (frustum instanceof PerspectiveOffCenterFrustum) {\n    near = frustum.near;\n    top = frustum.top;\n    right = frustum.right;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  }\n\n  return Math.max(dx, dy);\n}\n\nconst scratchCart = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\n\nfunction createPitchFunction(\n  startPitch,\n  endPitch,\n  heightFunction,\n  pitchAdjustHeight,\n) {\n  if (defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {\n    const startHeight = heightFunction(0.0);\n    const endHeight = heightFunction(1.0);\n    const middleHeight = heightFunction(0.5);\n\n    const d1 = middleHeight - startHeight;\n    const d2 = middleHeight - endHeight;\n\n    return function (time) {\n      const altitude = heightFunction(time);\n      if (time <= 0.5) {\n        const t1 = (altitude - startHeight) / d1;\n        return CesiumMath.lerp(startPitch, -CesiumMath.PI_OVER_TWO, t1);\n      }\n\n      const t2 = (altitude - endHeight) / d2;\n      return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO, endPitch, 1 - t2);\n    };\n  }\n  return function (time) {\n    return CesiumMath.lerp(startPitch, endPitch, time);\n  };\n}\n\nfunction createHeightFunction(\n  camera,\n  destination,\n  startHeight,\n  endHeight,\n  optionAltitude,\n) {\n  let altitude = optionAltitude;\n  const maxHeight = Math.max(startHeight, endHeight);\n\n  if (!defined(altitude)) {\n    const start = camera.position;\n    const end = destination;\n    const up = camera.up;\n    const right = camera.right;\n    const frustum = camera.frustum;\n\n    const diff = Cartesian3.subtract(start, end, scratchCart);\n    const verticalDistance = Cartesian3.magnitude(\n      Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2),\n    );\n    const horizontalDistance = Cartesian3.magnitude(\n      Cartesian3.multiplyByScalar(\n        right,\n        Cartesian3.dot(diff, right),\n        scratchCart2,\n      ),\n    );\n\n    altitude = Math.min(\n      getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2,\n      1000000000.0,\n    );\n  }\n\n  if (maxHeight < altitude) {\n    const power = 8.0;\n    const factor = 1000000.0;\n\n    const s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);\n    const e = Math.pow((altitude - endHeight) * factor, 1.0 / power);\n\n    return function (t) {\n      const x = t * (e - s) + s;\n      return -Math.pow(x, power) / factor + altitude;\n    };\n  }\n\n  return function (t) {\n    return CesiumMath.lerp(startHeight, endHeight, t);\n  };\n}\n\nfunction adjustAngleForLERP(startAngle, endAngle) {\n  if (\n    CesiumMath.equalsEpsilon(\n      startAngle,\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON11,\n    )\n  ) {\n    startAngle = 0.0;\n  }\n\n  if (endAngle > startAngle + Math.PI) {\n    startAngle += CesiumMath.TWO_PI;\n  } else if (endAngle < startAngle - Math.PI) {\n    startAngle -= CesiumMath.TWO_PI;\n  }\n\n  return startAngle;\n}\n\nconst scratchStart = new Cartesian3();\n\nfunction createUpdateCV(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionPitchAdjustHeight,\n) {\n  const camera = scene.camera;\n\n  const start = Cartesian3.clone(camera.position, scratchStart);\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    start.z,\n    destination.z,\n    optionAltitude,\n  );\n\n  const pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight,\n  );\n\n  function update(value) {\n    const time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n        pitch: pitchFunction(time),\n        roll: CesiumMath.lerp(startRoll, roll, time),\n      },\n    });\n\n    Cartesian2.lerp(start, destination, time, camera.position);\n    camera.position.z = heightFunction(time);\n  }\n  return update;\n}\n\nfunction useLongestFlight(startCart, destCart) {\n  if (startCart.longitude < destCart.longitude) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nfunction useShortestFlight(startCart, destCart) {\n  const diff = startCart.longitude - destCart.longitude;\n  if (diff < -CesiumMath.PI) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else if (diff > CesiumMath.PI) {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nconst scratchStartCart = new Cartographic();\nconst scratchEndCart = new Cartographic();\n\nfunction createUpdate3D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionFlyOverLongitude,\n  optionFlyOverLongitudeWeight,\n  optionPitchAdjustHeight,\n) {\n  const camera = scene.camera;\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const startCart = Cartographic.clone(\n    camera.positionCartographic,\n    scratchStartCart,\n  );\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  const destCart = ellipsoid.cartesianToCartographic(\n    destination,\n    scratchEndCart,\n  );\n  startCart.longitude = CesiumMath.zeroToTwoPi(startCart.longitude);\n  destCart.longitude = CesiumMath.zeroToTwoPi(destCart.longitude);\n\n  let useLongFlight = false;\n\n  if (defined(optionFlyOverLongitude)) {\n    const hitLon = CesiumMath.zeroToTwoPi(optionFlyOverLongitude);\n\n    const lonMin = Math.min(startCart.longitude, destCart.longitude);\n    const lonMax = Math.max(startCart.longitude, destCart.longitude);\n\n    const hitInside = hitLon >= lonMin && hitLon <= lonMax;\n\n    if (defined(optionFlyOverLongitudeWeight)) {\n      // Distance inside  (0...2Pi)\n      const din = Math.abs(startCart.longitude - destCart.longitude);\n      // Distance outside (0...2Pi)\n      const dot = CesiumMath.TWO_PI - din;\n\n      const hitDistance = hitInside ? din : dot;\n      const offDistance = hitInside ? dot : din;\n\n      if (\n        hitDistance < offDistance * optionFlyOverLongitudeWeight &&\n        !hitInside\n      ) {\n        useLongFlight = true;\n      }\n    } else if (!hitInside) {\n      useLongFlight = true;\n    }\n  }\n\n  if (useLongFlight) {\n    useLongestFlight(startCart, destCart);\n  } else {\n    useShortestFlight(startCart, destCart);\n  }\n\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startCart.height,\n    destCart.height,\n    optionAltitude,\n  );\n  const pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight,\n  );\n\n  // Isolate scope for update function.\n  // to have local copies of vars used in lerp\n  // Othervise, if you call nex\n  // createUpdate3D (createAnimationTween)\n  // before you played animation, variables will be overwriten.\n  function isolateUpdateFunction() {\n    const startLongitude = startCart.longitude;\n    const destLongitude = destCart.longitude;\n    const startLatitude = startCart.latitude;\n    const destLatitude = destCart.latitude;\n\n    return function update(value) {\n      const time = value.time / duration;\n\n      const position = Cartesian3.fromRadians(\n        CesiumMath.lerp(startLongitude, destLongitude, time),\n        CesiumMath.lerp(startLatitude, destLatitude, time),\n        heightFunction(time),\n        ellipsoid,\n      );\n\n      camera.setView({\n        destination: position,\n        orientation: {\n          heading: CesiumMath.lerp(startHeading, heading, time),\n          pitch: pitchFunction(time),\n          roll: CesiumMath.lerp(startRoll, roll, time),\n        },\n      });\n    };\n  }\n  return isolateUpdateFunction();\n}\n\nfunction createUpdate2D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n) {\n  const camera = scene.camera;\n\n  const start = Cartesian3.clone(camera.position, scratchStart);\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n\n  const startHeight = camera.frustum.right - camera.frustum.left;\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startHeight,\n    destination.z,\n    optionAltitude,\n  );\n\n  function update(value) {\n    const time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n      },\n    });\n\n    Cartesian2.lerp(start, destination, time, camera.position);\n\n    const zoom = heightFunction(time);\n\n    const frustum = camera.frustum;\n    const ratio = frustum.top / frustum.right;\n\n    const incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;\n    frustum.right += incrementAmount;\n    frustum.left -= incrementAmount;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n  return update;\n}\n\nconst scratchCartographic = new Cartographic();\nconst scratchDestination = new Cartesian3();\n\nfunction emptyFlight(complete, cancel) {\n  return {\n    startObject: {},\n    stopObject: {},\n    duration: 0.0,\n    complete: complete,\n    cancel: cancel,\n  };\n}\n\nfunction wrapCallback(controller, cb) {\n  function wrapped() {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n\n    controller.enableInputs = true;\n  }\n  return wrapped;\n}\n\nCameraFlightPath.createTween = function (scene, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n  const mode = scene.mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return emptyFlight();\n  }\n\n  const convert = defaultValue(options.convert, true);\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const maximumHeight = options.maximumHeight;\n  const flyOverLongitude = options.flyOverLongitude;\n  const flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  const pitchAdjustHeight = options.pitchAdjustHeight;\n  let easingFunction = options.easingFunction;\n\n  if (convert && mode !== SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(destination, scratchCartographic);\n    destination = projection.project(scratchCartographic, scratchDestination);\n  }\n\n  const camera = scene.camera;\n  const transform = options.endTransform;\n  if (defined(transform)) {\n    camera._setTransform(transform);\n  }\n\n  let duration = options.duration;\n  if (!defined(duration)) {\n    duration =\n      Math.ceil(Cartesian3.distance(camera.position, destination) / 1000000.0) +\n      2.0;\n    duration = Math.min(duration, 3.0);\n  }\n\n  const heading = defaultValue(options.heading, 0.0);\n  const pitch = defaultValue(options.pitch, -CesiumMath.PI_OVER_TWO);\n  const roll = defaultValue(options.roll, 0.0);\n\n  const controller = scene.screenSpaceCameraController;\n  controller.enableInputs = false;\n\n  const complete = wrapCallback(controller, options.complete);\n  const cancel = wrapCallback(controller, options.cancel);\n\n  const frustum = camera.frustum;\n\n  let empty = scene.mode === SceneMode.SCENE2D;\n  empty =\n    empty &&\n    Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6);\n  empty =\n    empty &&\n    CesiumMath.equalsEpsilon(\n      Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom),\n      destination.z,\n      CesiumMath.EPSILON6,\n    );\n\n  empty =\n    empty ||\n    (scene.mode !== SceneMode.SCENE2D &&\n      Cartesian3.equalsEpsilon(\n        destination,\n        camera.position,\n        CesiumMath.EPSILON10,\n      ));\n\n  empty =\n    empty &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(heading),\n      CesiumMath.negativePiToPi(camera.heading),\n      CesiumMath.EPSILON10,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(pitch),\n      CesiumMath.negativePiToPi(camera.pitch),\n      CesiumMath.EPSILON10,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(roll),\n      CesiumMath.negativePiToPi(camera.roll),\n      CesiumMath.EPSILON10,\n    );\n\n  if (empty) {\n    return emptyFlight(complete, cancel);\n  }\n\n  const updateFunctions = new Array(4);\n  updateFunctions[SceneMode.SCENE2D] = createUpdate2D;\n  updateFunctions[SceneMode.SCENE3D] = createUpdate3D;\n  updateFunctions[SceneMode.COLUMBUS_VIEW] = createUpdateCV;\n\n  if (duration <= 0.0) {\n    const newOnComplete = function () {\n      const update = updateFunctions[mode](\n        scene,\n        1.0,\n        destination,\n        heading,\n        pitch,\n        roll,\n        maximumHeight,\n        flyOverLongitude,\n        flyOverLongitudeWeight,\n        pitchAdjustHeight,\n      );\n      update({ time: 1.0 });\n\n      if (typeof complete === \"function\") {\n        complete();\n      }\n    };\n    return emptyFlight(newOnComplete, cancel);\n  }\n\n  const update = updateFunctions[mode](\n    scene,\n    duration,\n    destination,\n    heading,\n    pitch,\n    roll,\n    maximumHeight,\n    flyOverLongitude,\n    flyOverLongitudeWeight,\n    pitchAdjustHeight,\n  );\n\n  if (!defined(easingFunction)) {\n    const startHeight = camera.positionCartographic.height;\n    const endHeight =\n      mode === SceneMode.SCENE3D\n        ? ellipsoid.cartesianToCartographic(destination).height\n        : destination.z;\n\n    if (startHeight > endHeight && startHeight > 11500.0) {\n      easingFunction = EasingFunction.CUBIC_OUT;\n    } else {\n      easingFunction = EasingFunction.QUINTIC_IN_OUT;\n    }\n  }\n\n  return {\n    duration: duration,\n    easingFunction: easingFunction,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: duration,\n    },\n    update: update,\n    complete: complete,\n    cancel: cancel,\n  };\n};\nexport default CameraFlightPath;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,kBAAkB,MAAM,+BAA+B;AAC9D,OAAOC,2BAA2B,MAAM,wCAAwC;AAChF,OAAOC,SAAS,MAAM,gBAAgB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC,CAAC;AAE3B,SAASC,WAAWA,CAACC,OAAO,EAAEC,EAAE,EAAEC,EAAE,EAAE;EACpC,IAAIC,IAAI;EACR,IAAIC,GAAG;EACP,IAAIC,KAAK;EACT,IAAIL,OAAO,YAAYL,kBAAkB,EAAE;IACzC,MAAMW,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAG,GAAGR,OAAO,CAACS,IAAI,CAAC;IAC7CN,IAAI,GAAGH,OAAO,CAACG,IAAI;IACnBC,GAAG,GAAGJ,OAAO,CAACG,IAAI,GAAGG,QAAQ;IAC7BD,KAAK,GAAGL,OAAO,CAACU,WAAW,GAAGN,GAAG;IACjC,OAAOG,IAAI,CAACI,GAAG,CAAEV,EAAE,GAAGE,IAAI,GAAIE,KAAK,EAAGH,EAAE,GAAGC,IAAI,GAAIC,GAAG,CAAC;EACzD,CAAC,MAAM,IAAIJ,OAAO,YAAYJ,2BAA2B,EAAE;IACzDO,IAAI,GAAGH,OAAO,CAACG,IAAI;IACnBC,GAAG,GAAGJ,OAAO,CAACI,GAAG;IACjBC,KAAK,GAAGL,OAAO,CAACK,KAAK;IACrB,OAAOE,IAAI,CAACI,GAAG,CAAEV,EAAE,GAAGE,IAAI,GAAIE,KAAK,EAAGH,EAAE,GAAGC,IAAI,GAAIC,GAAG,CAAC;EACzD;EAEA,OAAOG,IAAI,CAACI,GAAG,CAACV,EAAE,EAAEC,EAAE,CAAC;AACzB;AAEA,MAAMU,WAAW,GAAG,IAAIxB,UAAU,CAAC,CAAC;AACpC,MAAMyB,YAAY,GAAG,IAAIzB,UAAU,CAAC,CAAC;AAErC,SAAS0B,mBAAmBA,CAC1BC,UAAU,EACVC,QAAQ,EACRC,cAAc,EACdC,iBAAiB,EACjB;EACA,IAAI3B,OAAO,CAAC2B,iBAAiB,CAAC,IAAID,cAAc,CAAC,GAAG,CAAC,GAAGC,iBAAiB,EAAE;IACzE,MAAMC,WAAW,GAAGF,cAAc,CAAC,GAAG,CAAC;IACvC,MAAMG,SAAS,GAAGH,cAAc,CAAC,GAAG,CAAC;IACrC,MAAMI,YAAY,GAAGJ,cAAc,CAAC,GAAG,CAAC;IAExC,MAAMK,EAAE,GAAGD,YAAY,GAAGF,WAAW;IACrC,MAAMI,EAAE,GAAGF,YAAY,GAAGD,SAAS;IAEnC,OAAO,UAAUI,IAAI,EAAE;MACrB,MAAMC,QAAQ,GAAGR,cAAc,CAACO,IAAI,CAAC;MACrC,IAAIA,IAAI,IAAI,GAAG,EAAE;QACf,MAAME,EAAE,GAAG,CAACD,QAAQ,GAAGN,WAAW,IAAIG,EAAE;QACxC,OAAO5B,UAAU,CAACiC,IAAI,CAACZ,UAAU,EAAE,CAACrB,UAAU,CAACkC,WAAW,EAAEF,EAAE,CAAC;MACjE;MAEA,MAAMG,EAAE,GAAG,CAACJ,QAAQ,GAAGL,SAAS,IAAIG,EAAE;MACtC,OAAO7B,UAAU,CAACiC,IAAI,CAAC,CAACjC,UAAU,CAACkC,WAAW,EAAEZ,QAAQ,EAAE,CAAC,GAAGa,EAAE,CAAC;IACnE,CAAC;EACH;EACA,OAAO,UAAUL,IAAI,EAAE;IACrB,OAAO9B,UAAU,CAACiC,IAAI,CAACZ,UAAU,EAAEC,QAAQ,EAAEQ,IAAI,CAAC;EACpD,CAAC;AACH;AAEA,SAASM,oBAAoBA,CAC3BC,MAAM,EACNC,WAAW,EACXb,WAAW,EACXC,SAAS,EACTa,cAAc,EACd;EACA,IAAIR,QAAQ,GAAGQ,cAAc;EAC7B,MAAMC,SAAS,GAAG3B,IAAI,CAACI,GAAG,CAACQ,WAAW,EAAEC,SAAS,CAAC;EAElD,IAAI,CAAC7B,OAAO,CAACkC,QAAQ,CAAC,EAAE;IACtB,MAAMU,KAAK,GAAGJ,MAAM,CAACK,QAAQ;IAC7B,MAAMC,GAAG,GAAGL,WAAW;IACvB,MAAMM,EAAE,GAAGP,MAAM,CAACO,EAAE;IACpB,MAAMjC,KAAK,GAAG0B,MAAM,CAAC1B,KAAK;IAC1B,MAAML,OAAO,GAAG+B,MAAM,CAAC/B,OAAO;IAE9B,MAAMuC,IAAI,GAAGnD,UAAU,CAACoD,QAAQ,CAACL,KAAK,EAAEE,GAAG,EAAEzB,WAAW,CAAC;IACzD,MAAM6B,gBAAgB,GAAGrD,UAAU,CAACsD,SAAS,CAC3CtD,UAAU,CAACuD,gBAAgB,CAACL,EAAE,EAAElD,UAAU,CAACwD,GAAG,CAACL,IAAI,EAAED,EAAE,CAAC,EAAEzB,YAAY,CACxE,CAAC;IACD,MAAMgC,kBAAkB,GAAGzD,UAAU,CAACsD,SAAS,CAC7CtD,UAAU,CAACuD,gBAAgB,CACzBtC,KAAK,EACLjB,UAAU,CAACwD,GAAG,CAACL,IAAI,EAAElC,KAAK,CAAC,EAC3BQ,YACF,CACF,CAAC;IAEDY,QAAQ,GAAGlB,IAAI,CAACuC,GAAG,CACjB/C,WAAW,CAACC,OAAO,EAAEyC,gBAAgB,EAAEI,kBAAkB,CAAC,GAAG,GAAG,EAChE,YACF,CAAC;EACH;EAEA,IAAIX,SAAS,GAAGT,QAAQ,EAAE;IACxB,MAAMsB,KAAK,GAAG,GAAG;IACjB,MAAMC,MAAM,GAAG,SAAS;IAExB,MAAMC,CAAC,GAAG,CAAC1C,IAAI,CAAC2C,GAAG,CAAC,CAACzB,QAAQ,GAAGN,WAAW,IAAI6B,MAAM,EAAE,GAAG,GAAGD,KAAK,CAAC;IACnE,MAAMI,CAAC,GAAG5C,IAAI,CAAC2C,GAAG,CAAC,CAACzB,QAAQ,GAAGL,SAAS,IAAI4B,MAAM,EAAE,GAAG,GAAGD,KAAK,CAAC;IAEhE,OAAO,UAAUK,CAAC,EAAE;MAClB,MAAMC,CAAC,GAAGD,CAAC,IAAID,CAAC,GAAGF,CAAC,CAAC,GAAGA,CAAC;MACzB,OAAO,CAAC1C,IAAI,CAAC2C,GAAG,CAACG,CAAC,EAAEN,KAAK,CAAC,GAAGC,MAAM,GAAGvB,QAAQ;IAChD,CAAC;EACH;EAEA,OAAO,UAAU2B,CAAC,EAAE;IAClB,OAAO1D,UAAU,CAACiC,IAAI,CAACR,WAAW,EAAEC,SAAS,EAAEgC,CAAC,CAAC;EACnD,CAAC;AACH;AAEA,SAASE,kBAAkBA,CAACC,UAAU,EAAEC,QAAQ,EAAE;EAChD,IACE9D,UAAU,CAAC+D,aAAa,CACtBF,UAAU,EACV7D,UAAU,CAACgE,MAAM,EACjBhE,UAAU,CAACiE,SACb,CAAC,EACD;IACAJ,UAAU,GAAG,GAAG;EAClB;EAEA,IAAIC,QAAQ,GAAGD,UAAU,GAAGhD,IAAI,CAACqD,EAAE,EAAE;IACnCL,UAAU,IAAI7D,UAAU,CAACgE,MAAM;EACjC,CAAC,MAAM,IAAIF,QAAQ,GAAGD,UAAU,GAAGhD,IAAI,CAACqD,EAAE,EAAE;IAC1CL,UAAU,IAAI7D,UAAU,CAACgE,MAAM;EACjC;EAEA,OAAOH,UAAU;AACnB;AAEA,MAAMM,YAAY,GAAG,IAAIzE,UAAU,CAAC,CAAC;AAErC,SAAS0E,cAAcA,CACrBC,KAAK,EACLC,QAAQ,EACRhC,WAAW,EACXiC,OAAO,EACPC,KAAK,EACLC,IAAI,EACJlC,cAAc,EACdmC,uBAAuB,EACvB;EACA,MAAMrC,MAAM,GAAGgC,KAAK,CAAChC,MAAM;EAE3B,MAAMI,KAAK,GAAG/C,UAAU,CAACiF,KAAK,CAACtC,MAAM,CAACK,QAAQ,EAAEyB,YAAY,CAAC;EAC7D,MAAM9C,UAAU,GAAGgB,MAAM,CAACmC,KAAK;EAC/B,MAAMI,YAAY,GAAGhB,kBAAkB,CAACvB,MAAM,CAACkC,OAAO,EAAEA,OAAO,CAAC;EAChE,MAAMM,SAAS,GAAGjB,kBAAkB,CAACvB,MAAM,CAACoC,IAAI,EAAEA,IAAI,CAAC;EAEvD,MAAMlD,cAAc,GAAGa,oBAAoB,CACzCC,MAAM,EACNC,WAAW,EACXG,KAAK,CAACqC,CAAC,EACPxC,WAAW,CAACwC,CAAC,EACbvC,cACF,CAAC;EAED,MAAMwC,aAAa,GAAG3D,mBAAmB,CACvCC,UAAU,EACVmD,KAAK,EACLjD,cAAc,EACdmD,uBACF,CAAC;EAED,SAASM,MAAMA,CAACC,KAAK,EAAE;IACrB,MAAMnD,IAAI,GAAGmD,KAAK,CAACnD,IAAI,GAAGwC,QAAQ;IAElCjC,MAAM,CAAC6C,OAAO,CAAC;MACbC,WAAW,EAAE;QACXZ,OAAO,EAAEvE,UAAU,CAACiC,IAAI,CAAC2C,YAAY,EAAEL,OAAO,EAAEzC,IAAI,CAAC;QACrD0C,KAAK,EAAEO,aAAa,CAACjD,IAAI,CAAC;QAC1B2C,IAAI,EAAEzE,UAAU,CAACiC,IAAI,CAAC4C,SAAS,EAAEJ,IAAI,EAAE3C,IAAI;MAC7C;IACF,CAAC,CAAC;IAEFrC,UAAU,CAACwC,IAAI,CAACQ,KAAK,EAAEH,WAAW,EAAER,IAAI,EAAEO,MAAM,CAACK,QAAQ,CAAC;IAC1DL,MAAM,CAACK,QAAQ,CAACoC,CAAC,GAAGvD,cAAc,CAACO,IAAI,CAAC;EAC1C;EACA,OAAOkD,MAAM;AACf;AAEA,SAASI,gBAAgBA,CAACC,SAAS,EAAEC,QAAQ,EAAE;EAC7C,IAAID,SAAS,CAACE,SAAS,GAAGD,QAAQ,CAACC,SAAS,EAAE;IAC5CF,SAAS,CAACE,SAAS,IAAIvF,UAAU,CAACgE,MAAM;EAC1C,CAAC,MAAM;IACLsB,QAAQ,CAACC,SAAS,IAAIvF,UAAU,CAACgE,MAAM;EACzC;AACF;AAEA,SAASwB,iBAAiBA,CAACH,SAAS,EAAEC,QAAQ,EAAE;EAC9C,MAAMzC,IAAI,GAAGwC,SAAS,CAACE,SAAS,GAAGD,QAAQ,CAACC,SAAS;EACrD,IAAI1C,IAAI,GAAG,CAAC7C,UAAU,CAACkE,EAAE,EAAE;IACzBmB,SAAS,CAACE,SAAS,IAAIvF,UAAU,CAACgE,MAAM;EAC1C,CAAC,MAAM,IAAInB,IAAI,GAAG7C,UAAU,CAACkE,EAAE,EAAE;IAC/BoB,QAAQ,CAACC,SAAS,IAAIvF,UAAU,CAACgE,MAAM;EACzC;AACF;AAEA,MAAMyB,gBAAgB,GAAG,IAAI9F,YAAY,CAAC,CAAC;AAC3C,MAAM+F,cAAc,GAAG,IAAI/F,YAAY,CAAC,CAAC;AAEzC,SAASgG,cAAcA,CACrBtB,KAAK,EACLC,QAAQ,EACRhC,WAAW,EACXiC,OAAO,EACPC,KAAK,EACLC,IAAI,EACJlC,cAAc,EACdqD,sBAAsB,EACtBC,4BAA4B,EAC5BnB,uBAAuB,EACvB;EACA,MAAMrC,MAAM,GAAGgC,KAAK,CAAChC,MAAM;EAC3B,MAAMyD,UAAU,GAAGzB,KAAK,CAAC0B,aAAa;EACtC,MAAMC,SAAS,GAAGF,UAAU,CAACE,SAAS;EAEtC,MAAMX,SAAS,GAAG1F,YAAY,CAACgF,KAAK,CAClCtC,MAAM,CAAC4D,oBAAoB,EAC3BR,gBACF,CAAC;EACD,MAAMpE,UAAU,GAAGgB,MAAM,CAACmC,KAAK;EAC/B,MAAMI,YAAY,GAAGhB,kBAAkB,CAACvB,MAAM,CAACkC,OAAO,EAAEA,OAAO,CAAC;EAChE,MAAMM,SAAS,GAAGjB,kBAAkB,CAACvB,MAAM,CAACoC,IAAI,EAAEA,IAAI,CAAC;EAEvD,MAAMa,QAAQ,GAAGU,SAAS,CAACE,uBAAuB,CAChD5D,WAAW,EACXoD,cACF,CAAC;EACDL,SAAS,CAACE,SAAS,GAAGvF,UAAU,CAACmG,WAAW,CAACd,SAAS,CAACE,SAAS,CAAC;EACjED,QAAQ,CAACC,SAAS,GAAGvF,UAAU,CAACmG,WAAW,CAACb,QAAQ,CAACC,SAAS,CAAC;EAE/D,IAAIa,aAAa,GAAG,KAAK;EAEzB,IAAIvG,OAAO,CAAC+F,sBAAsB,CAAC,EAAE;IACnC,MAAMS,MAAM,GAAGrG,UAAU,CAACmG,WAAW,CAACP,sBAAsB,CAAC;IAE7D,MAAMU,MAAM,GAAGzF,IAAI,CAACuC,GAAG,CAACiC,SAAS,CAACE,SAAS,EAAED,QAAQ,CAACC,SAAS,CAAC;IAChE,MAAMgB,MAAM,GAAG1F,IAAI,CAACI,GAAG,CAACoE,SAAS,CAACE,SAAS,EAAED,QAAQ,CAACC,SAAS,CAAC;IAEhE,MAAMiB,SAAS,GAAGH,MAAM,IAAIC,MAAM,IAAID,MAAM,IAAIE,MAAM;IAEtD,IAAI1G,OAAO,CAACgG,4BAA4B,CAAC,EAAE;MACzC;MACA,MAAMY,GAAG,GAAG5F,IAAI,CAAC6F,GAAG,CAACrB,SAAS,CAACE,SAAS,GAAGD,QAAQ,CAACC,SAAS,CAAC;MAC9D;MACA,MAAMrC,GAAG,GAAGlD,UAAU,CAACgE,MAAM,GAAGyC,GAAG;MAEnC,MAAME,WAAW,GAAGH,SAAS,GAAGC,GAAG,GAAGvD,GAAG;MACzC,MAAM0D,WAAW,GAAGJ,SAAS,GAAGtD,GAAG,GAAGuD,GAAG;MAEzC,IACEE,WAAW,GAAGC,WAAW,GAAGf,4BAA4B,IACxD,CAACW,SAAS,EACV;QACAJ,aAAa,GAAG,IAAI;MACtB;IACF,CAAC,MAAM,IAAI,CAACI,SAAS,EAAE;MACrBJ,aAAa,GAAG,IAAI;IACtB;EACF;EAEA,IAAIA,aAAa,EAAE;IACjBhB,gBAAgB,CAACC,SAAS,EAAEC,QAAQ,CAAC;EACvC,CAAC,MAAM;IACLE,iBAAiB,CAACH,SAAS,EAAEC,QAAQ,CAAC;EACxC;EAEA,MAAM/D,cAAc,GAAGa,oBAAoB,CACzCC,MAAM,EACNC,WAAW,EACX+C,SAAS,CAACwB,MAAM,EAChBvB,QAAQ,CAACuB,MAAM,EACftE,cACF,CAAC;EACD,MAAMwC,aAAa,GAAG3D,mBAAmB,CACvCC,UAAU,EACVmD,KAAK,EACLjD,cAAc,EACdmD,uBACF,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA,SAASoC,qBAAqBA,CAAA,EAAG;IAC/B,MAAMC,cAAc,GAAG1B,SAAS,CAACE,SAAS;IAC1C,MAAMyB,aAAa,GAAG1B,QAAQ,CAACC,SAAS;IACxC,MAAM0B,aAAa,GAAG5B,SAAS,CAAC6B,QAAQ;IACxC,MAAMC,YAAY,GAAG7B,QAAQ,CAAC4B,QAAQ;IAEtC,OAAO,SAASlC,MAAMA,CAACC,KAAK,EAAE;MAC5B,MAAMnD,IAAI,GAAGmD,KAAK,CAACnD,IAAI,GAAGwC,QAAQ;MAElC,MAAM5B,QAAQ,GAAGhD,UAAU,CAAC0H,WAAW,CACrCpH,UAAU,CAACiC,IAAI,CAAC8E,cAAc,EAAEC,aAAa,EAAElF,IAAI,CAAC,EACpD9B,UAAU,CAACiC,IAAI,CAACgF,aAAa,EAAEE,YAAY,EAAErF,IAAI,CAAC,EAClDP,cAAc,CAACO,IAAI,CAAC,EACpBkE,SACF,CAAC;MAED3D,MAAM,CAAC6C,OAAO,CAAC;QACb5C,WAAW,EAAEI,QAAQ;QACrByC,WAAW,EAAE;UACXZ,OAAO,EAAEvE,UAAU,CAACiC,IAAI,CAAC2C,YAAY,EAAEL,OAAO,EAAEzC,IAAI,CAAC;UACrD0C,KAAK,EAAEO,aAAa,CAACjD,IAAI,CAAC;UAC1B2C,IAAI,EAAEzE,UAAU,CAACiC,IAAI,CAAC4C,SAAS,EAAEJ,IAAI,EAAE3C,IAAI;QAC7C;MACF,CAAC,CAAC;IACJ,CAAC;EACH;EACA,OAAOgF,qBAAqB,CAAC,CAAC;AAChC;AAEA,SAASO,cAAcA,CACrBhD,KAAK,EACLC,QAAQ,EACRhC,WAAW,EACXiC,OAAO,EACPC,KAAK,EACLC,IAAI,EACJlC,cAAc,EACd;EACA,MAAMF,MAAM,GAAGgC,KAAK,CAAChC,MAAM;EAE3B,MAAMI,KAAK,GAAG/C,UAAU,CAACiF,KAAK,CAACtC,MAAM,CAACK,QAAQ,EAAEyB,YAAY,CAAC;EAC7D,MAAMS,YAAY,GAAGhB,kBAAkB,CAACvB,MAAM,CAACkC,OAAO,EAAEA,OAAO,CAAC;EAEhE,MAAM9C,WAAW,GAAGY,MAAM,CAAC/B,OAAO,CAACK,KAAK,GAAG0B,MAAM,CAAC/B,OAAO,CAACgH,IAAI;EAC9D,MAAM/F,cAAc,GAAGa,oBAAoB,CACzCC,MAAM,EACNC,WAAW,EACXb,WAAW,EACXa,WAAW,CAACwC,CAAC,EACbvC,cACF,CAAC;EAED,SAASyC,MAAMA,CAACC,KAAK,EAAE;IACrB,MAAMnD,IAAI,GAAGmD,KAAK,CAACnD,IAAI,GAAGwC,QAAQ;IAElCjC,MAAM,CAAC6C,OAAO,CAAC;MACbC,WAAW,EAAE;QACXZ,OAAO,EAAEvE,UAAU,CAACiC,IAAI,CAAC2C,YAAY,EAAEL,OAAO,EAAEzC,IAAI;MACtD;IACF,CAAC,CAAC;IAEFrC,UAAU,CAACwC,IAAI,CAACQ,KAAK,EAAEH,WAAW,EAAER,IAAI,EAAEO,MAAM,CAACK,QAAQ,CAAC;IAE1D,MAAM6E,IAAI,GAAGhG,cAAc,CAACO,IAAI,CAAC;IAEjC,MAAMxB,OAAO,GAAG+B,MAAM,CAAC/B,OAAO;IAC9B,MAAMkH,KAAK,GAAGlH,OAAO,CAACI,GAAG,GAAGJ,OAAO,CAACK,KAAK;IAEzC,MAAM8G,eAAe,GAAG,CAACF,IAAI,IAAIjH,OAAO,CAACK,KAAK,GAAGL,OAAO,CAACgH,IAAI,CAAC,IAAI,GAAG;IACrEhH,OAAO,CAACK,KAAK,IAAI8G,eAAe;IAChCnH,OAAO,CAACgH,IAAI,IAAIG,eAAe;IAC/BnH,OAAO,CAACI,GAAG,GAAG8G,KAAK,GAAGlH,OAAO,CAACK,KAAK;IACnCL,OAAO,CAACoH,MAAM,GAAG,CAACpH,OAAO,CAACI,GAAG;EAC/B;EACA,OAAOsE,MAAM;AACf;AAEA,MAAM2C,mBAAmB,GAAG,IAAIhI,YAAY,CAAC,CAAC;AAC9C,MAAMiI,kBAAkB,GAAG,IAAIlI,UAAU,CAAC,CAAC;AAE3C,SAASmI,WAAWA,CAACC,QAAQ,EAAEC,MAAM,EAAE;EACrC,OAAO;IACLC,WAAW,EAAE,CAAC,CAAC;IACfC,UAAU,EAAE,CAAC,CAAC;IACd3D,QAAQ,EAAE,GAAG;IACbwD,QAAQ,EAAEA,QAAQ;IAClBC,MAAM,EAAEA;EACV,CAAC;AACH;AAEA,SAASG,YAAYA,CAACC,UAAU,EAAEC,EAAE,EAAE;EACpC,SAASC,OAAOA,CAAA,EAAG;IACjB,IAAI,OAAOD,EAAE,KAAK,UAAU,EAAE;MAC5BA,EAAE,CAAC,CAAC;IACN;IAEAD,UAAU,CAACG,YAAY,GAAG,IAAI;EAChC;EACA,OAAOD,OAAO;AAChB;AAEAjI,gBAAgB,CAACmI,WAAW,GAAG,UAAUlE,KAAK,EAAEmE,OAAO,EAAE;EACvDA,OAAO,GAAG5I,YAAY,CAAC4I,OAAO,EAAE5I,YAAY,CAAC6I,YAAY,CAAC;EAC1D,IAAInG,WAAW,GAAGkG,OAAO,CAAClG,WAAW;;EAErC;EACA,IAAI,CAACzC,OAAO,CAACwE,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIvE,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA,IAAI,CAACD,OAAO,CAACyC,WAAW,CAAC,EAAE;IACzB,MAAM,IAAIxC,cAAc,CAAC,0BAA0B,CAAC;EACtD;EACA;EACA,MAAM4I,IAAI,GAAGrE,KAAK,CAACqE,IAAI;EAEvB,IAAIA,IAAI,KAAKvI,SAAS,CAACwI,QAAQ,EAAE;IAC/B,OAAOd,WAAW,CAAC,CAAC;EACtB;EAEA,MAAMe,OAAO,GAAGhJ,YAAY,CAAC4I,OAAO,CAACI,OAAO,EAAE,IAAI,CAAC;EACnD,MAAM9C,UAAU,GAAGzB,KAAK,CAAC0B,aAAa;EACtC,MAAMC,SAAS,GAAGF,UAAU,CAACE,SAAS;EACtC,MAAM6C,aAAa,GAAGL,OAAO,CAACK,aAAa;EAC3C,MAAMC,gBAAgB,GAAGN,OAAO,CAACM,gBAAgB;EACjD,MAAMC,sBAAsB,GAAGP,OAAO,CAACO,sBAAsB;EAC7D,MAAMvH,iBAAiB,GAAGgH,OAAO,CAAChH,iBAAiB;EACnD,IAAIwH,cAAc,GAAGR,OAAO,CAACQ,cAAc;EAE3C,IAAIJ,OAAO,IAAIF,IAAI,KAAKvI,SAAS,CAAC8I,OAAO,EAAE;IACzCjD,SAAS,CAACE,uBAAuB,CAAC5D,WAAW,EAAEqF,mBAAmB,CAAC;IACnErF,WAAW,GAAGwD,UAAU,CAACoD,OAAO,CAACvB,mBAAmB,EAAEC,kBAAkB,CAAC;EAC3E;EAEA,MAAMvF,MAAM,GAAGgC,KAAK,CAAChC,MAAM;EAC3B,MAAM8G,SAAS,GAAGX,OAAO,CAACY,YAAY;EACtC,IAAIvJ,OAAO,CAACsJ,SAAS,CAAC,EAAE;IACtB9G,MAAM,CAACgH,aAAa,CAACF,SAAS,CAAC;EACjC;EAEA,IAAI7E,QAAQ,GAAGkE,OAAO,CAAClE,QAAQ;EAC/B,IAAI,CAACzE,OAAO,CAACyE,QAAQ,CAAC,EAAE;IACtBA,QAAQ,GACNzD,IAAI,CAACyI,IAAI,CAAC5J,UAAU,CAAC6J,QAAQ,CAAClH,MAAM,CAACK,QAAQ,EAAEJ,WAAW,CAAC,GAAG,SAAS,CAAC,GACxE,GAAG;IACLgC,QAAQ,GAAGzD,IAAI,CAACuC,GAAG,CAACkB,QAAQ,EAAE,GAAG,CAAC;EACpC;EAEA,MAAMC,OAAO,GAAG3E,YAAY,CAAC4I,OAAO,CAACjE,OAAO,EAAE,GAAG,CAAC;EAClD,MAAMC,KAAK,GAAG5E,YAAY,CAAC4I,OAAO,CAAChE,KAAK,EAAE,CAACxE,UAAU,CAACkC,WAAW,CAAC;EAClE,MAAMuC,IAAI,GAAG7E,YAAY,CAAC4I,OAAO,CAAC/D,IAAI,EAAE,GAAG,CAAC;EAE5C,MAAM0D,UAAU,GAAG9D,KAAK,CAACmF,2BAA2B;EACpDrB,UAAU,CAACG,YAAY,GAAG,KAAK;EAE/B,MAAMR,QAAQ,GAAGI,YAAY,CAACC,UAAU,EAAEK,OAAO,CAACV,QAAQ,CAAC;EAC3D,MAAMC,MAAM,GAAGG,YAAY,CAACC,UAAU,EAAEK,OAAO,CAACT,MAAM,CAAC;EAEvD,MAAMzH,OAAO,GAAG+B,MAAM,CAAC/B,OAAO;EAE9B,IAAImJ,KAAK,GAAGpF,KAAK,CAACqE,IAAI,KAAKvI,SAAS,CAACuJ,OAAO;EAC5CD,KAAK,GACHA,KAAK,IACLhK,UAAU,CAACsE,aAAa,CAAC1B,MAAM,CAACK,QAAQ,EAAEJ,WAAW,EAAEtC,UAAU,CAAC2J,QAAQ,CAAC;EAC7EF,KAAK,GACHA,KAAK,IACLzJ,UAAU,CAAC+D,aAAa,CACtBlD,IAAI,CAACI,GAAG,CAACX,OAAO,CAACK,KAAK,GAAGL,OAAO,CAACgH,IAAI,EAAEhH,OAAO,CAACI,GAAG,GAAGJ,OAAO,CAACoH,MAAM,CAAC,EACpEpF,WAAW,CAACwC,CAAC,EACb9E,UAAU,CAAC2J,QACb,CAAC;EAEHF,KAAK,GACHA,KAAK,IACJpF,KAAK,CAACqE,IAAI,KAAKvI,SAAS,CAACuJ,OAAO,IAC/BhK,UAAU,CAACqE,aAAa,CACtBzB,WAAW,EACXD,MAAM,CAACK,QAAQ,EACf1C,UAAU,CAAC4J,SACb,CAAE;EAENH,KAAK,GACHA,KAAK,IACLzJ,UAAU,CAAC+D,aAAa,CACtB/D,UAAU,CAAC6J,cAAc,CAACtF,OAAO,CAAC,EAClCvE,UAAU,CAAC6J,cAAc,CAACxH,MAAM,CAACkC,OAAO,CAAC,EACzCvE,UAAU,CAAC4J,SACb,CAAC,IACD5J,UAAU,CAAC+D,aAAa,CACtB/D,UAAU,CAAC6J,cAAc,CAACrF,KAAK,CAAC,EAChCxE,UAAU,CAAC6J,cAAc,CAACxH,MAAM,CAACmC,KAAK,CAAC,EACvCxE,UAAU,CAAC4J,SACb,CAAC,IACD5J,UAAU,CAAC+D,aAAa,CACtB/D,UAAU,CAAC6J,cAAc,CAACpF,IAAI,CAAC,EAC/BzE,UAAU,CAAC6J,cAAc,CAACxH,MAAM,CAACoC,IAAI,CAAC,EACtCzE,UAAU,CAAC4J,SACb,CAAC;EAEH,IAAIH,KAAK,EAAE;IACT,OAAO5B,WAAW,CAACC,QAAQ,EAAEC,MAAM,CAAC;EACtC;EAEA,MAAM+B,eAAe,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC;EACpCD,eAAe,CAAC3J,SAAS,CAACuJ,OAAO,CAAC,GAAGrC,cAAc;EACnDyC,eAAe,CAAC3J,SAAS,CAAC8I,OAAO,CAAC,GAAGtD,cAAc;EACnDmE,eAAe,CAAC3J,SAAS,CAAC6J,aAAa,CAAC,GAAG5F,cAAc;EAEzD,IAAIE,QAAQ,IAAI,GAAG,EAAE;IACnB,MAAM2F,aAAa,GAAG,SAAAA,CAAA,EAAY;MAChC,MAAMjF,MAAM,GAAG8E,eAAe,CAACpB,IAAI,CAAC,CAClCrE,KAAK,EACL,GAAG,EACH/B,WAAW,EACXiC,OAAO,EACPC,KAAK,EACLC,IAAI,EACJoE,aAAa,EACbC,gBAAgB,EAChBC,sBAAsB,EACtBvH,iBACF,CAAC;MACDwD,MAAM,CAAC;QAAElD,IAAI,EAAE;MAAI,CAAC,CAAC;MAErB,IAAI,OAAOgG,QAAQ,KAAK,UAAU,EAAE;QAClCA,QAAQ,CAAC,CAAC;MACZ;IACF,CAAC;IACD,OAAOD,WAAW,CAACoC,aAAa,EAAElC,MAAM,CAAC;EAC3C;EAEA,MAAM/C,MAAM,GAAG8E,eAAe,CAACpB,IAAI,CAAC,CAClCrE,KAAK,EACLC,QAAQ,EACRhC,WAAW,EACXiC,OAAO,EACPC,KAAK,EACLC,IAAI,EACJoE,aAAa,EACbC,gBAAgB,EAChBC,sBAAsB,EACtBvH,iBACF,CAAC;EAED,IAAI,CAAC3B,OAAO,CAACmJ,cAAc,CAAC,EAAE;IAC5B,MAAMvH,WAAW,GAAGY,MAAM,CAAC4D,oBAAoB,CAACY,MAAM;IACtD,MAAMnF,SAAS,GACbgH,IAAI,KAAKvI,SAAS,CAAC8I,OAAO,GACtBjD,SAAS,CAACE,uBAAuB,CAAC5D,WAAW,CAAC,CAACuE,MAAM,GACrDvE,WAAW,CAACwC,CAAC;IAEnB,IAAIrD,WAAW,GAAGC,SAAS,IAAID,WAAW,GAAG,OAAO,EAAE;MACpDuH,cAAc,GAAGjJ,cAAc,CAACmK,SAAS;IAC3C,CAAC,MAAM;MACLlB,cAAc,GAAGjJ,cAAc,CAACoK,cAAc;IAChD;EACF;EAEA,OAAO;IACL7F,QAAQ,EAAEA,QAAQ;IAClB0E,cAAc,EAAEA,cAAc;IAC9BhB,WAAW,EAAE;MACXlG,IAAI,EAAE;IACR,CAAC;IACDmG,UAAU,EAAE;MACVnG,IAAI,EAAEwC;IACR,CAAC;IACDU,MAAM,EAAEA,MAAM;IACd8C,QAAQ,EAAEA,QAAQ;IAClBC,MAAM,EAAEA;EACV,CAAC;AACH,CAAC;AACD,eAAe3H,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}