{"ast":null,"code":"import Check from \"./Check.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nconst compressedMagic = 0x7468dead;\nconst compressedMagicSwap = 0xadde6874;\n\n/**\n * Decodes data that is received from the Google Earth Enterprise server.\n *\n * @param {ArrayBuffer} key The key used during decoding.\n * @param {ArrayBuffer} data The data to be decoded.\n *\n * @private\n */\nfunction decodeGoogleEarthEnterpriseData(key, data) {\n  if (decodeGoogleEarthEnterpriseData.passThroughDataForTesting) {\n    return data;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"key\", key);\n  Check.typeOf.object(\"data\", data);\n  //>>includeEnd('debug');\n\n  const keyLength = key.byteLength;\n  if (keyLength === 0 || keyLength % 4 !== 0) {\n    throw new RuntimeError(\"The length of key must be greater than 0 and a multiple of 4.\");\n  }\n  const dataView = new DataView(data);\n  const magic = dataView.getUint32(0, true);\n  if (magic === compressedMagic || magic === compressedMagicSwap) {\n    // Occasionally packets don't come back encoded, so just return\n    return data;\n  }\n  const keyView = new DataView(key);\n  let dp = 0;\n  const dpend = data.byteLength;\n  const dpend64 = dpend - dpend % 8;\n  const kpend = keyLength;\n  let kp;\n  let off = 8;\n\n  // This algorithm is intentionally asymmetric to make it more difficult to\n  // guess. Security through obscurity. :-(\n\n  // while we have a full uint64 (8 bytes) left to do\n  // assumes buffer is 64bit aligned (or processor doesn't care)\n  while (dp < dpend64) {\n    // rotate the key each time through by using the offsets 16,0,8,16,0,8,...\n    off = (off + 8) % 24;\n    kp = off;\n\n    // run through one key length xor'ing one uint64 at a time\n    // then drop out to rotate the key for the next bit\n    while (dp < dpend64 && kp < kpend) {\n      dataView.setUint32(dp, dataView.getUint32(dp, true) ^ keyView.getUint32(kp, true), true);\n      dataView.setUint32(dp + 4, dataView.getUint32(dp + 4, true) ^ keyView.getUint32(kp + 4, true), true);\n      dp += 8;\n      kp += 24;\n    }\n  }\n\n  // now the remaining 1 to 7 bytes\n  if (dp < dpend) {\n    if (kp >= kpend) {\n      // rotate the key one last time (if necessary)\n      off = (off + 8) % 24;\n      kp = off;\n    }\n    while (dp < dpend) {\n      dataView.setUint8(dp, dataView.getUint8(dp) ^ keyView.getUint8(kp));\n      dp++;\n      kp++;\n    }\n  }\n}\ndecodeGoogleEarthEnterpriseData.passThroughDataForTesting = false;\nexport default decodeGoogleEarthEnterpriseData;","map":{"version":3,"names":["Check","RuntimeError","compressedMagic","compressedMagicSwap","decodeGoogleEarthEnterpriseData","key","data","passThroughDataForTesting","typeOf","object","keyLength","byteLength","dataView","DataView","magic","getUint32","keyView","dp","dpend","dpend64","kpend","kp","off","setUint32","setUint8","getUint8"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/decodeGoogleEarthEnterpriseData.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\nconst compressedMagic = 0x7468dead;\nconst compressedMagicSwap = 0xadde6874;\n\n/**\n * Decodes data that is received from the Google Earth Enterprise server.\n *\n * @param {ArrayBuffer} key The key used during decoding.\n * @param {ArrayBuffer} data The data to be decoded.\n *\n * @private\n */\nfunction decodeGoogleEarthEnterpriseData(key, data) {\n  if (decodeGoogleEarthEnterpriseData.passThroughDataForTesting) {\n    return data;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"key\", key);\n  Check.typeOf.object(\"data\", data);\n  //>>includeEnd('debug');\n\n  const keyLength = key.byteLength;\n  if (keyLength === 0 || keyLength % 4 !== 0) {\n    throw new RuntimeError(\n      \"The length of key must be greater than 0 and a multiple of 4.\",\n    );\n  }\n\n  const dataView = new DataView(data);\n  const magic = dataView.getUint32(0, true);\n  if (magic === compressedMagic || magic === compressedMagicSwap) {\n    // Occasionally packets don't come back encoded, so just return\n    return data;\n  }\n\n  const keyView = new DataView(key);\n\n  let dp = 0;\n  const dpend = data.byteLength;\n  const dpend64 = dpend - (dpend % 8);\n  const kpend = keyLength;\n  let kp;\n  let off = 8;\n\n  // This algorithm is intentionally asymmetric to make it more difficult to\n  // guess. Security through obscurity. :-(\n\n  // while we have a full uint64 (8 bytes) left to do\n  // assumes buffer is 64bit aligned (or processor doesn't care)\n  while (dp < dpend64) {\n    // rotate the key each time through by using the offsets 16,0,8,16,0,8,...\n    off = (off + 8) % 24;\n    kp = off;\n\n    // run through one key length xor'ing one uint64 at a time\n    // then drop out to rotate the key for the next bit\n    while (dp < dpend64 && kp < kpend) {\n      dataView.setUint32(\n        dp,\n        dataView.getUint32(dp, true) ^ keyView.getUint32(kp, true),\n        true,\n      );\n      dataView.setUint32(\n        dp + 4,\n        dataView.getUint32(dp + 4, true) ^ keyView.getUint32(kp + 4, true),\n        true,\n      );\n      dp += 8;\n      kp += 24;\n    }\n  }\n\n  // now the remaining 1 to 7 bytes\n  if (dp < dpend) {\n    if (kp >= kpend) {\n      // rotate the key one last time (if necessary)\n      off = (off + 8) % 24;\n      kp = off;\n    }\n\n    while (dp < dpend) {\n      dataView.setUint8(dp, dataView.getUint8(dp) ^ keyView.getUint8(kp));\n      dp++;\n      kp++;\n    }\n  }\n}\n\ndecodeGoogleEarthEnterpriseData.passThroughDataForTesting = false;\nexport default decodeGoogleEarthEnterpriseData;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,YAAY;AAC9B,OAAOC,YAAY,MAAM,mBAAmB;AAE5C,MAAMC,eAAe,GAAG,UAAU;AAClC,MAAMC,mBAAmB,GAAG,UAAU;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,+BAA+BA,CAACC,GAAG,EAAEC,IAAI,EAAE;EAClD,IAAIF,+BAA+B,CAACG,yBAAyB,EAAE;IAC7D,OAAOD,IAAI;EACb;;EAEA;EACAN,KAAK,CAACQ,MAAM,CAACC,MAAM,CAAC,KAAK,EAAEJ,GAAG,CAAC;EAC/BL,KAAK,CAACQ,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEH,IAAI,CAAC;EACjC;;EAEA,MAAMI,SAAS,GAAGL,GAAG,CAACM,UAAU;EAChC,IAAID,SAAS,KAAK,CAAC,IAAIA,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;IAC1C,MAAM,IAAIT,YAAY,CACpB,+DACF,CAAC;EACH;EAEA,MAAMW,QAAQ,GAAG,IAAIC,QAAQ,CAACP,IAAI,CAAC;EACnC,MAAMQ,KAAK,GAAGF,QAAQ,CAACG,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC;EACzC,IAAID,KAAK,KAAKZ,eAAe,IAAIY,KAAK,KAAKX,mBAAmB,EAAE;IAC9D;IACA,OAAOG,IAAI;EACb;EAEA,MAAMU,OAAO,GAAG,IAAIH,QAAQ,CAACR,GAAG,CAAC;EAEjC,IAAIY,EAAE,GAAG,CAAC;EACV,MAAMC,KAAK,GAAGZ,IAAI,CAACK,UAAU;EAC7B,MAAMQ,OAAO,GAAGD,KAAK,GAAIA,KAAK,GAAG,CAAE;EACnC,MAAME,KAAK,GAAGV,SAAS;EACvB,IAAIW,EAAE;EACN,IAAIC,GAAG,GAAG,CAAC;;EAEX;EACA;;EAEA;EACA;EACA,OAAOL,EAAE,GAAGE,OAAO,EAAE;IACnB;IACAG,GAAG,GAAG,CAACA,GAAG,GAAG,CAAC,IAAI,EAAE;IACpBD,EAAE,GAAGC,GAAG;;IAER;IACA;IACA,OAAOL,EAAE,GAAGE,OAAO,IAAIE,EAAE,GAAGD,KAAK,EAAE;MACjCR,QAAQ,CAACW,SAAS,CAChBN,EAAE,EACFL,QAAQ,CAACG,SAAS,CAACE,EAAE,EAAE,IAAI,CAAC,GAAGD,OAAO,CAACD,SAAS,CAACM,EAAE,EAAE,IAAI,CAAC,EAC1D,IACF,CAAC;MACDT,QAAQ,CAACW,SAAS,CAChBN,EAAE,GAAG,CAAC,EACNL,QAAQ,CAACG,SAAS,CAACE,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,GAAGD,OAAO,CAACD,SAAS,CAACM,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAClE,IACF,CAAC;MACDJ,EAAE,IAAI,CAAC;MACPI,EAAE,IAAI,EAAE;IACV;EACF;;EAEA;EACA,IAAIJ,EAAE,GAAGC,KAAK,EAAE;IACd,IAAIG,EAAE,IAAID,KAAK,EAAE;MACf;MACAE,GAAG,GAAG,CAACA,GAAG,GAAG,CAAC,IAAI,EAAE;MACpBD,EAAE,GAAGC,GAAG;IACV;IAEA,OAAOL,EAAE,GAAGC,KAAK,EAAE;MACjBN,QAAQ,CAACY,QAAQ,CAACP,EAAE,EAAEL,QAAQ,CAACa,QAAQ,CAACR,EAAE,CAAC,GAAGD,OAAO,CAACS,QAAQ,CAACJ,EAAE,CAAC,CAAC;MACnEJ,EAAE,EAAE;MACJI,EAAE,EAAE;IACN;EACF;AACF;AAEAjB,+BAA+B,CAACG,yBAAyB,GAAG,KAAK;AACjE,eAAeH,+BAA+B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}