{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport JobType from \"./JobType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads a vertex buffer from a glTF buffer view.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfVertexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor id.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n *\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @private\n */\nfunction GltfVertexBufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const accessorId = options.accessorId;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\"One of options.bufferViewId and options.draco must be defined.\");\n  }\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\"When options.draco is defined options.attributeSemantic must also be defined.\");\n  }\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\"When options.draco is defined options.accessorId must also be defined.\");\n  }\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._bufferViewId = bufferViewId;\n  this._draco = draco;\n  this._attributeSemantic = attributeSemantic;\n  this._accessorId = accessorId;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._quantization = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfVertexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfVertexBufferLoader.prototype.constructor = GltfVertexBufferLoader;\n}\nObject.defineProperties(GltfVertexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The vertex buffer. This is only defined when <code>loadAsTypedArray</code> is false.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    }\n  },\n  /**\n   * The typed array containing vertex buffer data. This is only defined when <code>loadAsTypedArray</code> is true.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    }\n  },\n  /**\n   * Information about the quantized vertex attribute after Draco decode.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {ModelComponents.Quantization}\n   * @readonly\n   * @private\n   */\n  quantization: {\n    get: function () {\n      return this._quantization;\n    }\n  }\n});\nfunction hasDracoCompression(draco, semantic) {\n  return defined(draco) && defined(draco.attributes) && defined(draco.attributes[semantic]);\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfVertexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfVertexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  if (hasDracoCompression(this._draco, this._attributeSemantic)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\nfunction getQuantizationInformation(dracoQuantization, componentDatatype, componentCount, type) {\n  const quantizationBits = dracoQuantization.quantizationBits;\n  const normalizationRange = (1 << quantizationBits) - 1;\n  const normalizationDivisor = 1.0 / normalizationRange;\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = componentDatatype;\n  quantization.octEncoded = dracoQuantization.octEncoded;\n  quantization.octEncodedZXY = true;\n  quantization.type = type;\n  if (quantization.octEncoded) {\n    quantization.type = AttributeType.VEC2;\n    quantization.normalizationRange = normalizationRange;\n  } else {\n    const MathType = AttributeType.getMathType(type);\n    if (MathType === Number) {\n      const dimensions = dracoQuantization.range;\n      quantization.quantizedVolumeOffset = dracoQuantization.minValues[0];\n      quantization.quantizedVolumeDimensions = dimensions;\n      quantization.normalizationRange = normalizationRange;\n      quantization.quantizedVolumeStepSize = dimensions * normalizationDivisor;\n    } else {\n      quantization.quantizedVolumeOffset = MathType.unpack(dracoQuantization.minValues);\n      quantization.normalizationRange = MathType.unpack(new Array(componentCount).fill(normalizationRange));\n      const packedDimensions = new Array(componentCount).fill(dracoQuantization.range);\n      quantization.quantizedVolumeDimensions = MathType.unpack(packedDimensions);\n\n      // Computing the step size\n      const packedSteps = packedDimensions.map(function (dimension) {\n        return dimension * normalizationDivisor;\n      });\n      quantization.quantizedVolumeStepSize = MathType.unpack(packedSteps);\n    }\n  }\n  return quantization;\n}\nasync function loadFromDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: vertexBufferLoader._gltf,\n      draco: vertexBufferLoader._draco,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource\n    });\n    vertexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    vertexBufferLoader._state = ResourceLoaderState.LOADED;\n    return vertexBufferLoader;\n  } catch {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(vertexBufferLoader);\n  }\n}\nfunction processDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n  const dracoLoader = vertexBufferLoader._dracoLoader;\n\n  // Get the typed array and quantization information\n  const decodedVertexAttributes = dracoLoader.decodedData.vertexAttributes;\n  const attributeSemantic = vertexBufferLoader._attributeSemantic;\n  const dracoAttribute = decodedVertexAttributes[attributeSemantic];\n  const accessorId = vertexBufferLoader._accessorId;\n  const accessor = vertexBufferLoader._gltf.accessors[accessorId];\n  const type = accessor.type;\n  const typedArray = dracoAttribute.array;\n  const dracoQuantization = dracoAttribute.data.quantization;\n  if (defined(dracoQuantization)) {\n    vertexBufferLoader._quantization = getQuantizationInformation(dracoQuantization, dracoAttribute.data.componentDatatype, dracoAttribute.data.componentsPerAttribute, type);\n  }\n  vertexBufferLoader._typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n}\nasync function loadFromBufferView(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: vertexBufferLoader._gltf,\n      bufferViewId: vertexBufferLoader._bufferViewId,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource\n    });\n    vertexBufferLoader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    vertexBufferLoader._typedArray = bufferViewLoader.typedArray;\n    vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return vertexBufferLoader;\n  } catch (error) {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(vertexBufferLoader, error);\n  }\n}\nfunction handleError(vertexBufferLoader, error) {\n  vertexBufferLoader.unload();\n  vertexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load vertex buffer\";\n  throw vertexBufferLoader.getError(errorMessage, error);\n}\nfunction CreateVertexBufferJob() {\n  this.typedArray = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\nCreateVertexBufferJob.prototype.set = function (typedArray, context) {\n  this.typedArray = typedArray;\n  this.context = context;\n};\nCreateVertexBufferJob.prototype.execute = function () {\n  this.buffer = createVertexBuffer(this.typedArray, this.context);\n};\nfunction createVertexBuffer(typedArray, context) {\n  const buffer = Buffer.createVertexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\nconst scratchVertexBufferJob = new CreateVertexBufferJob();\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfVertexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED && this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (!ready) {\n        return false;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n    processDraco(this);\n  }\n  let buffer;\n  const typedArray = this._typedArray;\n  if (this._loadBuffer && this._asynchronous) {\n    const vertexBufferJob = scratchVertexBufferJob;\n    vertexBufferJob.set(typedArray, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(vertexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = vertexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createVertexBuffer(typedArray, frameState.context);\n  }\n\n  // Unload everything except the vertex buffer\n  this.unload();\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfVertexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n  const resourceCache = this._resourceCache;\n  if (defined(this._bufferViewLoader) && !this._bufferViewLoader.isDestroyed()) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n};\nexport default GltfVertexBufferLoader;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","Buffer","BufferUsage","AttributeType","JobType","ModelComponents","ResourceLoader","ResourceLoaderState","GltfVertexBufferLoader","options","EMPTY_OBJECT","resourceCache","gltf","gltfResource","baseResource","bufferViewId","draco","attributeSemantic","accessorId","cacheKey","asynchronous","loadBuffer","loadTypedArray","typeOf","func","object","hasBufferViewId","hasDraco","hasDracoCompression","hasAttributeSemantic","hasAccessorId","string","number","_resourceCache","_gltfResource","_baseResource","_gltf","_bufferViewId","_draco","_attributeSemantic","_accessorId","_cacheKey","_asynchronous","_loadBuffer","_loadTypedArray","_bufferViewLoader","undefined","_dracoLoader","_quantization","_typedArray","_buffer","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","buffer","typedArray","quantization","semantic","attributes","load","loadFromDraco","loadFromBufferView","getQuantizationInformation","dracoQuantization","componentDatatype","componentCount","type","quantizationBits","normalizationRange","normalizationDivisor","Quantization","octEncoded","octEncodedZXY","VEC2","MathType","getMathType","Number","dimensions","range","quantizedVolumeOffset","minValues","quantizedVolumeDimensions","quantizedVolumeStepSize","unpack","Array","fill","packedDimensions","packedSteps","map","dimension","vertexBufferLoader","LOADING","dracoLoader","getDracoLoader","isDestroyed","LOADED","handleError","processDraco","PROCESSING","decodedVertexAttributes","decodedData","vertexAttributes","dracoAttribute","accessor","accessors","array","data","componentsPerAttribute","Uint8Array","byteOffset","byteLength","bufferViewLoader","getBufferViewLoader","error","unload","FAILED","errorMessage","getError","CreateVertexBufferJob","context","set","execute","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","scratchVertexBufferJob","process","frameState","READY","ready","vertexBufferJob","jobScheduler","BUFFER","statistics","addGeometryLoader","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfVertexBufferLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport JobType from \"./JobType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads a vertex buffer from a glTF buffer view.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfVertexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor id.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n *\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @private\n */\nfunction GltfVertexBufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const accessorId = options.accessorId;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId and options.draco must be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.accessorId must also be defined.\",\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._bufferViewId = bufferViewId;\n  this._draco = draco;\n  this._attributeSemantic = attributeSemantic;\n  this._accessorId = accessorId;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._quantization = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfVertexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfVertexBufferLoader.prototype.constructor = GltfVertexBufferLoader;\n}\n\nObject.defineProperties(GltfVertexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The vertex buffer. This is only defined when <code>loadAsTypedArray</code> is false.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The typed array containing vertex buffer data. This is only defined when <code>loadAsTypedArray</code> is true.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n  /**\n   * Information about the quantized vertex attribute after Draco decode.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {ModelComponents.Quantization}\n   * @readonly\n   * @private\n   */\n  quantization: {\n    get: function () {\n      return this._quantization;\n    },\n  },\n});\n\nfunction hasDracoCompression(draco, semantic) {\n  return (\n    defined(draco) &&\n    defined(draco.attributes) &&\n    defined(draco.attributes[semantic])\n  );\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfVertexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfVertexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  if (hasDracoCompression(this._draco, this._attributeSemantic)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\n\nfunction getQuantizationInformation(\n  dracoQuantization,\n  componentDatatype,\n  componentCount,\n  type,\n) {\n  const quantizationBits = dracoQuantization.quantizationBits;\n  const normalizationRange = (1 << quantizationBits) - 1;\n  const normalizationDivisor = 1.0 / normalizationRange;\n\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = componentDatatype;\n  quantization.octEncoded = dracoQuantization.octEncoded;\n  quantization.octEncodedZXY = true;\n  quantization.type = type;\n\n  if (quantization.octEncoded) {\n    quantization.type = AttributeType.VEC2;\n    quantization.normalizationRange = normalizationRange;\n  } else {\n    const MathType = AttributeType.getMathType(type);\n    if (MathType === Number) {\n      const dimensions = dracoQuantization.range;\n      quantization.quantizedVolumeOffset = dracoQuantization.minValues[0];\n      quantization.quantizedVolumeDimensions = dimensions;\n      quantization.normalizationRange = normalizationRange;\n      quantization.quantizedVolumeStepSize = dimensions * normalizationDivisor;\n    } else {\n      quantization.quantizedVolumeOffset = MathType.unpack(\n        dracoQuantization.minValues,\n      );\n      quantization.normalizationRange = MathType.unpack(\n        new Array(componentCount).fill(normalizationRange),\n      );\n      const packedDimensions = new Array(componentCount).fill(\n        dracoQuantization.range,\n      );\n      quantization.quantizedVolumeDimensions =\n        MathType.unpack(packedDimensions);\n\n      // Computing the step size\n      const packedSteps = packedDimensions.map(function (dimension) {\n        return dimension * normalizationDivisor;\n      });\n      quantization.quantizedVolumeStepSize = MathType.unpack(packedSteps);\n    }\n  }\n\n  return quantization;\n}\n\nasync function loadFromDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: vertexBufferLoader._gltf,\n      draco: vertexBufferLoader._draco,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource,\n    });\n    vertexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    vertexBufferLoader._state = ResourceLoaderState.LOADED;\n    return vertexBufferLoader;\n  } catch {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(vertexBufferLoader);\n  }\n}\n\nfunction processDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n  const dracoLoader = vertexBufferLoader._dracoLoader;\n\n  // Get the typed array and quantization information\n  const decodedVertexAttributes = dracoLoader.decodedData.vertexAttributes;\n  const attributeSemantic = vertexBufferLoader._attributeSemantic;\n  const dracoAttribute = decodedVertexAttributes[attributeSemantic];\n  const accessorId = vertexBufferLoader._accessorId;\n  const accessor = vertexBufferLoader._gltf.accessors[accessorId];\n  const type = accessor.type;\n  const typedArray = dracoAttribute.array;\n  const dracoQuantization = dracoAttribute.data.quantization;\n  if (defined(dracoQuantization)) {\n    vertexBufferLoader._quantization = getQuantizationInformation(\n      dracoQuantization,\n      dracoAttribute.data.componentDatatype,\n      dracoAttribute.data.componentsPerAttribute,\n      type,\n    );\n  }\n\n  vertexBufferLoader._typedArray = new Uint8Array(\n    typedArray.buffer,\n    typedArray.byteOffset,\n    typedArray.byteLength,\n  );\n}\n\nasync function loadFromBufferView(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: vertexBufferLoader._gltf,\n      bufferViewId: vertexBufferLoader._bufferViewId,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource,\n    });\n    vertexBufferLoader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    vertexBufferLoader._typedArray = bufferViewLoader.typedArray;\n    vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return vertexBufferLoader;\n  } catch (error) {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(vertexBufferLoader, error);\n  }\n}\n\nfunction handleError(vertexBufferLoader, error) {\n  vertexBufferLoader.unload();\n  vertexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load vertex buffer\";\n  throw vertexBufferLoader.getError(errorMessage, error);\n}\n\nfunction CreateVertexBufferJob() {\n  this.typedArray = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\n\nCreateVertexBufferJob.prototype.set = function (typedArray, context) {\n  this.typedArray = typedArray;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  this.buffer = createVertexBuffer(this.typedArray, this.context);\n};\n\nfunction createVertexBuffer(typedArray, context) {\n  const buffer = Buffer.createVertexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\nconst scratchVertexBufferJob = new CreateVertexBufferJob();\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfVertexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (\n    this._state !== ResourceLoaderState.LOADED &&\n    this._state !== ResourceLoaderState.PROCESSING\n  ) {\n    return false;\n  }\n\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (!ready) {\n        return false;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n\n    processDraco(this);\n  }\n\n  let buffer;\n  const typedArray = this._typedArray;\n  if (this._loadBuffer && this._asynchronous) {\n    const vertexBufferJob = scratchVertexBufferJob;\n    vertexBufferJob.set(typedArray, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(vertexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = vertexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createVertexBuffer(typedArray, frameState.context);\n  }\n\n  // Unload everything except the vertex buffer\n  this.unload();\n\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfVertexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n\n  const resourceCache = this._resourceCache;\n\n  if (\n    defined(this._bufferViewLoader) &&\n    !this._bufferViewLoader.isDestroyed()\n  ) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n};\n\nexport default GltfVertexBufferLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}