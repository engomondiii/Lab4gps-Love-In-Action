{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"precision highp float;\\n\\\n\\n\\\nin vec3 v_textureCoordinates;\\n\\\n\\n\\\nuniform float u_roughness;\\n\\\nuniform samplerCube u_radianceTexture;\\n\\\nuniform vec3 u_faceDirection;\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\nvec3 importanceSampleGGX(vec2 xi, float alphaRoughness, vec3 N)\\n\\\n{\\n\\\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\\n\\\n    float phi = czm_twoPi * xi.x;\\n\\\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (alphaRoughnessSquared - 1.0) * xi.y));\\n\\\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\\n\\\n    vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n\\\n    vec3 tangentX = normalize(cross(upVector, N));\\n\\\n    vec3 tangentY = cross(N, tangentX);\\n\\\n    return tangentX * H.x + tangentY * H.y + N * H.z;\\n\\\n}\\n\\\n\\n\\\n// Sample count is relatively low for the sake of performance, but should still be enough to prevent artifacting in lower roughnesses\\n\\\nconst int samples = 128;\\n\\\n\\n\\\nvoid main() {\\n\\\n    vec3 normal = u_faceDirection;\\n\\\n    vec3 V = normalize(v_textureCoordinates);\\n\\\n    float roughness = u_roughness;\\n\\\n\\n\\\n    vec4 color = vec4(0.0);\\n\\\n    float weight = 0.0;\\n\\\n    for (int i = 0; i < samples; ++i) {\\n\\\n            vec2 xi = hammersley2D(i, samples);\\n\\\n            vec3 H = importanceSampleGGX(xi, roughness, V);\\n\\\n            vec3 L = 2.0 * dot(V, H) * H - V; // reflected vector\\n\\\n\\n\\\n            float NdotL = max(dot(V, L), 0.0);\\n\\\n            if (NdotL > 0.0) {\\n\\\n                color += vec4(czm_textureCube(u_radianceTexture, L).rgb, 1.0) * NdotL;\\n\\\n                weight += NdotL;\\n\\\n            }\\n\\\n        }\\n\\\n    out_FragColor = color / weight;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/ConvolveSpecularMapFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"precision highp float;\\n\\\n\\n\\\nin vec3 v_textureCoordinates;\\n\\\n\\n\\\nuniform float u_roughness;\\n\\\nuniform samplerCube u_radianceTexture;\\n\\\nuniform vec3 u_faceDirection;\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\nvec3 importanceSampleGGX(vec2 xi, float alphaRoughness, vec3 N)\\n\\\n{\\n\\\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\\n\\\n    float phi = czm_twoPi * xi.x;\\n\\\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (alphaRoughnessSquared - 1.0) * xi.y));\\n\\\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\\n\\\n    vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n\\\n    vec3 tangentX = normalize(cross(upVector, N));\\n\\\n    vec3 tangentY = cross(N, tangentX);\\n\\\n    return tangentX * H.x + tangentY * H.y + N * H.z;\\n\\\n}\\n\\\n\\n\\\n// Sample count is relatively low for the sake of performance, but should still be enough to prevent artifacting in lower roughnesses\\n\\\nconst int samples = 128;\\n\\\n\\n\\\nvoid main() {\\n\\\n    vec3 normal = u_faceDirection;\\n\\\n    vec3 V = normalize(v_textureCoordinates);\\n\\\n    float roughness = u_roughness;\\n\\\n\\n\\\n    vec4 color = vec4(0.0);\\n\\\n    float weight = 0.0;\\n\\\n    for (int i = 0; i < samples; ++i) {\\n\\\n            vec2 xi = hammersley2D(i, samples);\\n\\\n            vec3 H = importanceSampleGGX(xi, roughness, V);\\n\\\n            vec3 L = 2.0 * dot(V, H) * H - V; // reflected vector\\n\\\n\\n\\\n            float NdotL = max(dot(V, L), 0.0);\\n\\\n            if (NdotL > 0.0) {\\n\\\n                color += vec4(czm_textureCube(u_radianceTexture, L).rgb, 1.0) * NdotL;\\n\\\n                weight += NdotL;\\n\\\n            }\\n\\\n        }\\n\\\n    out_FragColor = color / weight;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}