{"ast":null,"code":"import binarySearch from \"./binarySearch.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n * This object is normally not instantiated directly, use {@link EarthOrientationParameters.fromUrl}.\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @private\n */\nfunction EarthOrientationParameters(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._dates = undefined;\n  this._samples = undefined;\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n  this._columnCount = 0;\n  this._lastIndex = -1;\n  this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);\n  if (defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\"dateIso8601\", \"modifiedJulianDateUtc\", \"xPoleWanderRadians\", \"yPoleWanderRadians\", \"ut1MinusUtcSeconds\", \"lengthOfDayCorrectionSeconds\", \"xCelestialPoleOffsetRadians\", \"yCelestialPoleOffsetRadians\", \"taiMinusUtcSeconds\"],\n      samples: []\n    });\n  }\n}\n\n/**\n *\n * @param {Resource|string} [url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * const eop = await Cesium.EarthOrientationParameters.fromUrl('Data/EOP.json');\n * Cesium.Transforms.earthOrientationParameters = eop;\n */\nEarthOrientationParameters.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resource = Resource.createIfNeeded(url);\n\n  // Download EOP data.\n  let eopData;\n  try {\n    eopData = await resource.fetchJson();\n  } catch (e) {\n    throw new RuntimeError(`An error occurred while retrieving the EOP data from the URL ${resource.url}.`);\n  }\n  return new EarthOrientationParameters({\n    addNewLeapSeconds: options.addNewLeapSeconds,\n    data: eopData\n  });\n};\n\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\nEarthOrientationParameters.NONE = Object.freeze({\n  compute: function (date, result) {\n    if (!defined(result)) {\n      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n    return result;\n  }\n});\n\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#fromUrl\n */\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!defined(this._samples)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n  const dates = this._dates;\n  const lastIndex = this._lastIndex;\n  let before = 0;\n  let after = 0;\n  if (defined(lastIndex)) {\n    const previousIndexDate = dates[lastIndex];\n    const nextIndexDate = dates[lastIndex + 1];\n    const isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);\n    const isAfterLastSample = !defined(nextIndexDate);\n    const isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n      after = before + 1;\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n  let index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1;\n\n    // Use the first entry if the date requested is before the beginning of the data.\n    if (before < 0) {\n      before = 0;\n    }\n  }\n  this._lastIndex = before;\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\nfunction onDataReady(eop, eopData) {\n  if (!defined(eopData.columnNames)) {\n    throw new RuntimeError(\"Error in loaded EOP data: The columnNames property is required.\");\n  }\n  if (!defined(eopData.samples)) {\n    throw new RuntimeError(\"Error in loaded EOP data: The samples property is required.\");\n  }\n  const dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  const xPoleWanderRadiansColumn = eopData.columnNames.indexOf(\"xPoleWanderRadians\");\n  const yPoleWanderRadiansColumn = eopData.columnNames.indexOf(\"yPoleWanderRadians\");\n  const ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf(\"ut1MinusUtcSeconds\");\n  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\"xCelestialPoleOffsetRadians\");\n  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\"yCelestialPoleOffsetRadians\");\n  const taiMinusUtcSecondsColumn = eopData.columnNames.indexOf(\"taiMinusUtcSeconds\");\n  if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {\n    throw new RuntimeError(\"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\");\n  }\n  const samples = eop._samples = eopData.samples;\n  const dates = eop._dates = [];\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n  let lastTaiMinusUtc;\n  const addNewLeapSeconds = eop._addNewLeapSeconds;\n\n  // Convert the ISO8601 dates to JulianDates.\n  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    const mjd = samples[i + dateColumn];\n    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    const day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    const date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n    dates.push(date);\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        const leapSeconds = JulianDate.leapSeconds;\n        const leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);\n        if (leapSecondIndex < 0) {\n          const leapSecond = new LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  const start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  const columnCount = eop._columnCount;\n\n  // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n  const beforeDate = dates[before];\n  const afterDate = dates[after];\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n  const factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);\n  const startBefore = before * columnCount;\n  const startAfter = after * columnCount;\n\n  // Handle UT1 leap second edge case\n  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    const beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    const afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n  result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);\n  result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);\n  result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);\n  result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);\n  result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);\n  return result;\n}\nexport default EarthOrientationParameters;","map":{"version":3,"names":["binarySearch","Check","defaultValue","defined","EarthOrientationParametersSample","JulianDate","LeapSecond","Resource","RuntimeError","TimeConstants","TimeStandard","EarthOrientationParameters","options","EMPTY_OBJECT","_dates","undefined","_samples","_dateColumn","_xPoleWanderRadiansColumn","_yPoleWanderRadiansColumn","_ut1MinusUtcSecondsColumn","_xCelestialPoleOffsetRadiansColumn","_yCelestialPoleOffsetRadiansColumn","_taiMinusUtcSecondsColumn","_columnCount","_lastIndex","_addNewLeapSeconds","addNewLeapSeconds","data","onDataReady","columnNames","samples","fromUrl","url","resource","createIfNeeded","eopData","fetchJson","e","NONE","Object","freeze","compute","date","result","xPoleWander","yPoleWander","xPoleOffset","yPoleOffset","ut1MinusUtc","prototype","length","dates","lastIndex","before","after","previousIndexDate","nextIndexDate","isAfterPrevious","lessThanOrEquals","isAfterLastSample","isBeforeNext","greaterThanOrEquals","equals","interpolate","index","compare","compareLeapSecondDates","leapSecond","dateToFind","julianDate","eop","dateColumn","indexOf","xPoleWanderRadiansColumn","yPoleWanderRadiansColumn","ut1MinusUtcSecondsColumn","xCelestialPoleOffsetRadiansColumn","yCelestialPoleOffsetRadiansColumn","taiMinusUtcSecondsColumn","lastTaiMinusUtc","i","len","mjd","taiMinusUtc","day","MODIFIED_JULIAN_DATE_DIFFERENCE","TAI","push","leapSeconds","leapSecondIndex","splice","fillResultFromIndex","columnCount","start","linearInterp","dx","y1","y2","beforeDate","afterDate","factor","secondsDifference","startBefore","startAfter","beforeUt1MinusUtc","afterUt1MinusUtc","offsetDifference","beforeTaiMinusUtc","afterTaiMinusUtc"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/EarthOrientationParameters.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n * This object is normally not instantiated directly, use {@link EarthOrientationParameters.fromUrl}.\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @private\n */\nfunction EarthOrientationParameters(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._dates = undefined;\n  this._samples = undefined;\n\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n\n  this._columnCount = 0;\n  this._lastIndex = -1;\n\n  this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);\n\n  if (defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\n        \"dateIso8601\",\n        \"modifiedJulianDateUtc\",\n        \"xPoleWanderRadians\",\n        \"yPoleWanderRadians\",\n        \"ut1MinusUtcSeconds\",\n        \"lengthOfDayCorrectionSeconds\",\n        \"xCelestialPoleOffsetRadians\",\n        \"yCelestialPoleOffsetRadians\",\n        \"taiMinusUtcSeconds\",\n      ],\n      samples: [],\n    });\n  }\n}\n\n/**\n *\n * @param {Resource|string} [url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * const eop = await Cesium.EarthOrientationParameters.fromUrl('Data/EOP.json');\n * Cesium.Transforms.earthOrientationParameters = eop;\n */\nEarthOrientationParameters.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const resource = Resource.createIfNeeded(url);\n\n  // Download EOP data.\n  let eopData;\n  try {\n    eopData = await resource.fetchJson();\n  } catch (e) {\n    throw new RuntimeError(\n      `An error occurred while retrieving the EOP data from the URL ${resource.url}.`,\n    );\n  }\n\n  return new EarthOrientationParameters({\n    addNewLeapSeconds: options.addNewLeapSeconds,\n    data: eopData,\n  });\n};\n\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\nEarthOrientationParameters.NONE = Object.freeze({\n  compute: function (date, result) {\n    if (!defined(result)) {\n      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n    return result;\n  },\n});\n\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#fromUrl\n */\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!defined(this._samples)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n\n  const dates = this._dates;\n  const lastIndex = this._lastIndex;\n\n  let before = 0;\n  let after = 0;\n  if (defined(lastIndex)) {\n    const previousIndexDate = dates[lastIndex];\n    const nextIndexDate = dates[lastIndex + 1];\n    const isAfterPrevious = JulianDate.lessThanOrEquals(\n      previousIndexDate,\n      date,\n    );\n    const isAfterLastSample = !defined(nextIndexDate);\n    const isBeforeNext =\n      isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n      after = before + 1;\n\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n\n  let index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1;\n\n    // Use the first entry if the date requested is before the beginning of the data.\n    if (before < 0) {\n      before = 0;\n    }\n  }\n\n  this._lastIndex = before;\n\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\n\nfunction onDataReady(eop, eopData) {\n  if (!defined(eopData.columnNames)) {\n    throw new RuntimeError(\n      \"Error in loaded EOP data: The columnNames property is required.\",\n    );\n  }\n\n  if (!defined(eopData.samples)) {\n    throw new RuntimeError(\n      \"Error in loaded EOP data: The samples property is required.\",\n    );\n  }\n\n  const dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  const xPoleWanderRadiansColumn =\n    eopData.columnNames.indexOf(\"xPoleWanderRadians\");\n  const yPoleWanderRadiansColumn =\n    eopData.columnNames.indexOf(\"yPoleWanderRadians\");\n  const ut1MinusUtcSecondsColumn =\n    eopData.columnNames.indexOf(\"ut1MinusUtcSeconds\");\n  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"xCelestialPoleOffsetRadians\",\n  );\n  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"yCelestialPoleOffsetRadians\",\n  );\n  const taiMinusUtcSecondsColumn =\n    eopData.columnNames.indexOf(\"taiMinusUtcSeconds\");\n\n  if (\n    dateColumn < 0 ||\n    xPoleWanderRadiansColumn < 0 ||\n    yPoleWanderRadiansColumn < 0 ||\n    ut1MinusUtcSecondsColumn < 0 ||\n    xCelestialPoleOffsetRadiansColumn < 0 ||\n    yCelestialPoleOffsetRadiansColumn < 0 ||\n    taiMinusUtcSecondsColumn < 0\n  ) {\n    throw new RuntimeError(\n      \"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\",\n    );\n  }\n\n  const samples = (eop._samples = eopData.samples);\n  const dates = (eop._dates = []);\n\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n\n  let lastTaiMinusUtc;\n\n  const addNewLeapSeconds = eop._addNewLeapSeconds;\n\n  // Convert the ISO8601 dates to JulianDates.\n  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    const mjd = samples[i + dateColumn];\n    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    const day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    const date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n    dates.push(date);\n\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        const leapSeconds = JulianDate.leapSeconds;\n        const leapSecondIndex = binarySearch(\n          leapSeconds,\n          date,\n          compareLeapSecondDates,\n        );\n        if (leapSecondIndex < 0) {\n          const leapSecond = new LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\n\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  const start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\n\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\n\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  const columnCount = eop._columnCount;\n\n  // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n\n  const beforeDate = dates[before];\n  const afterDate = dates[after];\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n\n  const factor =\n    JulianDate.secondsDifference(date, beforeDate) /\n    JulianDate.secondsDifference(afterDate, beforeDate);\n\n  const startBefore = before * columnCount;\n  const startAfter = after * columnCount;\n\n  // Handle UT1 leap second edge case\n  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n\n  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    const beforeTaiMinusUtc =\n      samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    const afterTaiMinusUtc =\n      samples[startAfter + eop._taiMinusUtcSecondsColumn];\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n\n  result.xPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._xPoleWanderRadiansColumn],\n    samples[startAfter + eop._xPoleWanderRadiansColumn],\n  );\n  result.yPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._yPoleWanderRadiansColumn],\n    samples[startAfter + eop._yPoleWanderRadiansColumn],\n  );\n  result.xPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn],\n  );\n  result.yPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn],\n  );\n  result.ut1MinusUtc = linearInterp(\n    factor,\n    beforeUt1MinusUtc,\n    afterUt1MinusUtc,\n  );\n  return result;\n}\n\nexport default EarthOrientationParameters;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}