{"ast":null,"code":"import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport TranslationRotationScale from \"../../Core/TranslationRotationScale.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport InstancingPipelineStage from \"./InstancingPipelineStage.js\";\nimport ModelMatrixUpdateStage from \"./ModelMatrixUpdateStage.js\";\nimport NodeStatisticsPipelineStage from \"./NodeStatisticsPipelineStage.js\";\n\n/**\n * An in-memory representation of a node as part of the {@link ModelSceneGraph}.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.Node} options.node The corresponding node components from the 3D model.\n * @param {Matrix4} options.transform The transform of this node, excluding transforms from the node's ancestors or children.\n * @param {Matrix4} options.transformToRoot The product of the transforms of all the node's ancestors, excluding the node's own transform.\n * @param {ModelSceneGraph} options.sceneGraph The scene graph this node belongs to.\n * @param {number[]} options.children The indices of the children of this node in the runtime nodes array of the scene graph.\n *\n * @alias ModelRuntimeNode\n * @constructor\n *\n * @private\n */\nfunction ModelRuntimeNode(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const node = options.node;\n  const transform = options.transform;\n  const transformToRoot = options.transformToRoot;\n  const sceneGraph = options.sceneGraph;\n  const children = options.children;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.node\", node);\n  Check.typeOf.object(\"options.transform\", transform);\n  Check.typeOf.object(\"options.transformToRoot\", transformToRoot);\n  Check.typeOf.object(\"options.sceneGraph\", sceneGraph);\n  Check.typeOf.object(\"options.children\", children);\n  //>>includeEnd('debug');\n\n  this._node = node;\n  this._name = node.name;\n  this._id = node.index;\n  this._sceneGraph = sceneGraph;\n  this._children = children;\n  this._originalTransform = Matrix4.clone(transform, this._originalTransform);\n  this._transform = Matrix4.clone(transform, this._transform);\n  this._transformToRoot = Matrix4.clone(transformToRoot, this._transformToRoot);\n  this._computedTransform = new Matrix4(); // Computed in initialize()\n  this._transformDirty = false;\n\n  // Used for animation\n  this._transformParameters = undefined;\n  this._morphWeights = [];\n\n  // Will be set by the scene graph after the skins have been created\n  this._runtimeSkin = undefined;\n  this._computedJointMatrices = [];\n\n  /**\n   * Whether or not to show this node and its children. This can be toggled\n   * by the user through {@link ModelNode}.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   *\n   * @private\n   */\n  this.show = true;\n\n  /**\n   * Whether or not this node is animated by the user. This is set by the\n   * corresponding {@link ModelNode} when the user supplies their\n   * own transform. If this is true, the node will ignore animations in the\n   * model's asset.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.userAnimated = false;\n\n  /**\n   * Pipeline stages to apply across all the mesh primitives of this node.\n   * This is an array of classes, each with a static method called\n   * <code>process()</code>.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.pipelineStages = [];\n\n  /**\n   * The mesh primitives that belong to this node.\n   *\n   * @type {ModelRuntimePrimitive[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimePrimitives = [];\n\n  /**\n   * Update stages to apply to this node.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.updateStages = [];\n\n  /**\n   * The component-wise minimum value of the translations of the instances.\n   * This value is set by InstancingPipelineStage.\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingTranslationMin = undefined;\n\n  /**\n   * The component-wise maximum value of the translations of the instances.\n   * This value is set by InstancingPipelineStage.\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingTranslationMax = undefined;\n\n  /**\n   * A buffer containing the instanced transforms. The memory is managed\n   * by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTransformsBuffer = undefined;\n\n  /**\n   * A buffer containing the instanced transforms projected to 2D world\n   * coordinates. Used for rendering in 2D / CV mode. The memory is managed\n   * by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTransformsBuffer2D = undefined;\n\n  /**\n   * A buffer containing the instanced translation values for the node if\n   * it is instanced. Used for rendering in 2D / CV mode. The memory is\n   * managed by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTranslationBuffer2D = undefined;\n\n  /**\n   * If the model is instanced and projected to 2D, the reference point is the\n   * average of the instancing translation max and min. The 2D translations are\n   * defined relative to this point to avoid precision issues on the GPU.\n   * <p>\n   * This value is set by InstancingPipelineStage.\n   * </p>\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingReferencePoint2D = undefined;\n  initialize(this);\n}\nObject.defineProperties(ModelRuntimeNode.prototype, {\n  /**\n   * The internal node this runtime node represents.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelComponents.Node}\n   * @readonly\n   *\n   * @private\n   */\n  node: {\n    get: function () {\n      return this._node;\n    }\n  },\n  /**\n   * The scene graph this node belongs to.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    }\n  },\n  /**\n   * The indices of the children of this node in the scene graph.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  children: {\n    get: function () {\n      return this._children;\n    }\n  },\n  /**\n   * The node's local space transform. This can be changed externally via\n   * the corresponding {@link ModelNode}, such that animation can be\n   * driven by another source, not just an animation in the model's asset.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   *\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n    set: function (value) {\n      this._transformDirty = true;\n      this._transform = Matrix4.clone(value, this._transform);\n    }\n  },\n  /**\n   * The transforms of all the node's ancestors, not including this node's\n   * transform.\n   *\n   * @see ModelRuntimeNode#computedTransform\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  transformToRoot: {\n    get: function () {\n      return this._transformToRoot;\n    }\n  },\n  /**\n   * A transform from the node's local space to the model's scene graph space.\n   * This is the product of transformToRoot * transform.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedTransform: {\n    get: function () {\n      return this._computedTransform;\n    }\n  },\n  /**\n   * The node's original transform, as specified in the model.\n   * Does not include transformations from the node's ancestors.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  originalTransform: {\n    get: function () {\n      return this._originalTransform;\n    }\n  },\n  /**\n   * The node's local space translation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The translation of a node cannot be set if it was defined using a matrix in the model's asset.\n   *\n   * @private\n   */\n  translation: {\n    get: function () {\n      return defined(this._transformParameters) ? this._transformParameters.translation : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\"The translation of a node cannot be set if it was defined using a matrix in the model.\");\n      }\n      //>>includeEnd('debug');\n\n      const currentTranslation = transformParameters.translation;\n      if (Cartesian3.equals(currentTranslation, value)) {\n        return;\n      }\n      transformParameters.translation = Cartesian3.clone(value, transformParameters.translation);\n      updateTransformFromParameters(this, transformParameters);\n    }\n  },\n  /**\n   * The node's local space rotation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Quaternion}\n   *\n   * @exception {DeveloperError} The rotation of a node cannot be set if it was defined using a matrix in the model's asset.\n   *\n   * @private\n   */\n  rotation: {\n    get: function () {\n      return defined(this._transformParameters) ? this._transformParameters.rotation : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\"The rotation of a node cannot be set if it was defined using a matrix in the model.\");\n      }\n      //>>includeEnd('debug');\n\n      const currentRotation = transformParameters.rotation;\n      if (Quaternion.equals(currentRotation, value)) {\n        return;\n      }\n      transformParameters.rotation = Quaternion.clone(value, transformParameters.rotation);\n      updateTransformFromParameters(this, transformParameters);\n    }\n  },\n  /**\n   * The node's local space scale. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The scale of a node cannot be set if it was defined using a matrix in the model's asset.\n   * @private\n   */\n  scale: {\n    get: function () {\n      return defined(this._transformParameters) ? this._transformParameters.scale : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\"The scale of a node cannot be set if it was defined using a matrix in the model.\");\n      }\n      //>>includeEnd('debug');\n      const currentScale = transformParameters.scale;\n      if (Cartesian3.equals(currentScale, value)) {\n        return;\n      }\n      transformParameters.scale = Cartesian3.clone(value, transformParameters.scale);\n      updateTransformFromParameters(this, transformParameters);\n    }\n  },\n  /**\n   * The node's morph weights. This is used internally to allow animations\n   * in the model's asset to affect the node's properties.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {number[]}\n   *\n   * @private\n   */\n  morphWeights: {\n    get: function () {\n      return this._morphWeights;\n    },\n    set: function (value) {\n      const valueLength = value.length;\n      //>>includeStart('debug', pragmas.debug);\n      if (this._morphWeights.length !== valueLength) {\n        throw new DeveloperError(\"value must have the same length as the original weights array.\");\n      }\n      //>>includeEnd('debug');\n      for (let i = 0; i < valueLength; i++) {\n        this._morphWeights[i] = value[i];\n      }\n    }\n  },\n  /**\n   * The skin applied to this node, if it exists.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelSkin}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeSkin: {\n    get: function () {\n      return this._runtimeSkin;\n    }\n  },\n  /**\n   * The computed joint matrices of this node, derived from its skin.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  computedJointMatrices: {\n    get: function () {\n      return this._computedJointMatrices;\n    }\n  }\n});\nfunction initialize(runtimeNode) {\n  const transform = runtimeNode.transform;\n  const transformToRoot = runtimeNode.transformToRoot;\n  const computedTransform = runtimeNode._computedTransform;\n  runtimeNode._computedTransform = Matrix4.multiply(transformToRoot, transform, computedTransform);\n  const node = runtimeNode.node;\n  if (!defined(node.matrix)) {\n    runtimeNode._transformParameters = new TranslationRotationScale(node.translation, node.rotation, node.scale);\n  }\n  if (defined(node.morphWeights)) {\n    runtimeNode._morphWeights = node.morphWeights.slice();\n  }\n\n  // If this node is affected by an articulation from the AGI_articulations\n  // extension, add this node to its list of affected nodes.\n  const articulationName = node.articulationName;\n  if (defined(articulationName)) {\n    const sceneGraph = runtimeNode.sceneGraph;\n    const runtimeArticulations = sceneGraph._runtimeArticulations;\n    const runtimeArticulation = runtimeArticulations[articulationName];\n    if (defined(runtimeArticulation)) {\n      runtimeArticulation.runtimeNodes.push(runtimeNode);\n    }\n  }\n}\nfunction updateTransformFromParameters(runtimeNode, transformParameters) {\n  runtimeNode._transformDirty = true;\n  runtimeNode._transform = Matrix4.fromTranslationRotationScale(transformParameters, runtimeNode._transform);\n}\n\n/**\n * Returns the child with the given index.\n *\n * @param {number} index The index of the child.\n *\n * @returns {ModelRuntimeNode}\n *\n * @example\n * // Iterate through all children of a runtime node.\n * for (let i = 0; i < runtimeNode.children.length; i++)\n * {\n *   const childNode = runtimeNode.getChild(i);\n * }\n *\n * @private\n */\nModelRuntimeNode.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index >= this.children.length) {\n    throw new DeveloperError(\"index must be greater than or equal to 0 and less than the number of children.\");\n  }\n  //>>includeEnd('debug');\n\n  return this.sceneGraph._runtimeNodes[this.children[index]];\n};\n\n/**\n * Configure the node pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @private\n */\nModelRuntimeNode.prototype.configurePipeline = function () {\n  const node = this.node;\n  const pipelineStages = this.pipelineStages;\n  pipelineStages.length = 0;\n  const updateStages = this.updateStages;\n  updateStages.length = 0;\n  if (defined(node.instances)) {\n    pipelineStages.push(InstancingPipelineStage);\n  }\n  pipelineStages.push(NodeStatisticsPipelineStage);\n  updateStages.push(ModelMatrixUpdateStage);\n};\n\n/**\n * Updates the computed transform used for rendering and instancing.\n *\n * @private\n */\nModelRuntimeNode.prototype.updateComputedTransform = function () {\n  this._computedTransform = Matrix4.multiply(this._transformToRoot, this._transform, this._computedTransform);\n};\n\n/**\n * Updates the joint matrices for this node, where each matrix is computed as\n * computedJointMatrix = nodeWorldTransform^(-1) * skinJointMatrix.\n *\n * @private\n */\nModelRuntimeNode.prototype.updateJointMatrices = function () {\n  const runtimeSkin = this._runtimeSkin;\n  if (!defined(runtimeSkin)) {\n    return;\n  }\n  runtimeSkin.updateJointMatrices();\n  const computedJointMatrices = this._computedJointMatrices;\n  const skinJointMatrices = runtimeSkin.jointMatrices;\n  const length = skinJointMatrices.length;\n  for (let i = 0; i < length; i++) {\n    if (!defined(computedJointMatrices[i])) {\n      computedJointMatrices[i] = new Matrix4();\n    }\n    const nodeWorldTransform = Matrix4.multiplyTransformation(this.transformToRoot, this.transform, computedJointMatrices[i]);\n    const inverseNodeWorldTransform = Matrix4.inverseTransformation(nodeWorldTransform, computedJointMatrices[i]);\n    computedJointMatrices[i] = Matrix4.multiplyTransformation(inverseNodeWorldTransform, skinJointMatrices[i], computedJointMatrices[i]);\n  }\n};\nexport default ModelRuntimeNode;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","DeveloperError","Matrix4","TranslationRotationScale","Quaternion","InstancingPipelineStage","ModelMatrixUpdateStage","NodeStatisticsPipelineStage","ModelRuntimeNode","options","EMPTY_OBJECT","node","transform","transformToRoot","sceneGraph","children","typeOf","object","_node","_name","name","_id","index","_sceneGraph","_children","_originalTransform","clone","_transform","_transformToRoot","_computedTransform","_transformDirty","_transformParameters","undefined","_morphWeights","_runtimeSkin","_computedJointMatrices","show","userAnimated","pipelineStages","runtimePrimitives","updateStages","instancingTranslationMin","instancingTranslationMax","instancingTransformsBuffer","instancingTransformsBuffer2D","instancingTranslationBuffer2D","instancingReferencePoint2D","initialize","Object","defineProperties","prototype","get","set","value","computedTransform","originalTransform","translation","transformParameters","currentTranslation","equals","updateTransformFromParameters","rotation","currentRotation","scale","currentScale","morphWeights","valueLength","length","i","runtimeSkin","computedJointMatrices","runtimeNode","multiply","matrix","slice","articulationName","runtimeArticulations","_runtimeArticulations","runtimeArticulation","runtimeNodes","push","fromTranslationRotationScale","getChild","number","_runtimeNodes","configurePipeline","instances","updateComputedTransform","updateJointMatrices","skinJointMatrices","jointMatrices","nodeWorldTransform","multiplyTransformation","inverseNodeWorldTransform","inverseTransformation"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelRuntimeNode.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport TranslationRotationScale from \"../../Core/TranslationRotationScale.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport InstancingPipelineStage from \"./InstancingPipelineStage.js\";\nimport ModelMatrixUpdateStage from \"./ModelMatrixUpdateStage.js\";\nimport NodeStatisticsPipelineStage from \"./NodeStatisticsPipelineStage.js\";\n\n/**\n * An in-memory representation of a node as part of the {@link ModelSceneGraph}.\n *\n * @param {object} options An object containing the following options:\n * @param {ModelComponents.Node} options.node The corresponding node components from the 3D model.\n * @param {Matrix4} options.transform The transform of this node, excluding transforms from the node's ancestors or children.\n * @param {Matrix4} options.transformToRoot The product of the transforms of all the node's ancestors, excluding the node's own transform.\n * @param {ModelSceneGraph} options.sceneGraph The scene graph this node belongs to.\n * @param {number[]} options.children The indices of the children of this node in the runtime nodes array of the scene graph.\n *\n * @alias ModelRuntimeNode\n * @constructor\n *\n * @private\n */\nfunction ModelRuntimeNode(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const node = options.node;\n  const transform = options.transform;\n  const transformToRoot = options.transformToRoot;\n  const sceneGraph = options.sceneGraph;\n  const children = options.children;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.node\", node);\n  Check.typeOf.object(\"options.transform\", transform);\n  Check.typeOf.object(\"options.transformToRoot\", transformToRoot);\n  Check.typeOf.object(\"options.sceneGraph\", sceneGraph);\n  Check.typeOf.object(\"options.children\", children);\n  //>>includeEnd('debug');\n\n  this._node = node;\n  this._name = node.name;\n  this._id = node.index;\n  this._sceneGraph = sceneGraph;\n  this._children = children;\n\n  this._originalTransform = Matrix4.clone(transform, this._originalTransform);\n  this._transform = Matrix4.clone(transform, this._transform);\n  this._transformToRoot = Matrix4.clone(transformToRoot, this._transformToRoot);\n\n  this._computedTransform = new Matrix4(); // Computed in initialize()\n  this._transformDirty = false;\n\n  // Used for animation\n  this._transformParameters = undefined;\n  this._morphWeights = [];\n\n  // Will be set by the scene graph after the skins have been created\n  this._runtimeSkin = undefined;\n  this._computedJointMatrices = [];\n\n  /**\n   * Whether or not to show this node and its children. This can be toggled\n   * by the user through {@link ModelNode}.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   *\n   * @private\n   */\n  this.show = true;\n\n  /**\n   * Whether or not this node is animated by the user. This is set by the\n   * corresponding {@link ModelNode} when the user supplies their\n   * own transform. If this is true, the node will ignore animations in the\n   * model's asset.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.userAnimated = false;\n\n  /**\n   * Pipeline stages to apply across all the mesh primitives of this node.\n   * This is an array of classes, each with a static method called\n   * <code>process()</code>.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.pipelineStages = [];\n\n  /**\n   * The mesh primitives that belong to this node.\n   *\n   * @type {ModelRuntimePrimitive[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimePrimitives = [];\n\n  /**\n   * Update stages to apply to this node.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.updateStages = [];\n\n  /**\n   * The component-wise minimum value of the translations of the instances.\n   * This value is set by InstancingPipelineStage.\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingTranslationMin = undefined;\n\n  /**\n   * The component-wise maximum value of the translations of the instances.\n   * This value is set by InstancingPipelineStage.\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingTranslationMax = undefined;\n\n  /**\n   * A buffer containing the instanced transforms. The memory is managed\n   * by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTransformsBuffer = undefined;\n\n  /**\n   * A buffer containing the instanced transforms projected to 2D world\n   * coordinates. Used for rendering in 2D / CV mode. The memory is managed\n   * by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTransformsBuffer2D = undefined;\n\n  /**\n   * A buffer containing the instanced translation values for the node if\n   * it is instanced. Used for rendering in 2D / CV mode. The memory is\n   * managed by Model; this is just a reference.\n   *\n   * @type {Buffer}\n   *\n   * @private\n   */\n  this.instancingTranslationBuffer2D = undefined;\n\n  /**\n   * If the model is instanced and projected to 2D, the reference point is the\n   * average of the instancing translation max and min. The 2D translations are\n   * defined relative to this point to avoid precision issues on the GPU.\n   * <p>\n   * This value is set by InstancingPipelineStage.\n   * </p>\n   *\n   * @type {Cartesian3}\n   *\n   * @private\n   */\n  this.instancingReferencePoint2D = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelRuntimeNode.prototype, {\n  /**\n   * The internal node this runtime node represents.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelComponents.Node}\n   * @readonly\n   *\n   * @private\n   */\n  node: {\n    get: function () {\n      return this._node;\n    },\n  },\n  /**\n   * The scene graph this node belongs to.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The indices of the children of this node in the scene graph.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  children: {\n    get: function () {\n      return this._children;\n    },\n  },\n\n  /**\n   * The node's local space transform. This can be changed externally via\n   * the corresponding {@link ModelNode}, such that animation can be\n   * driven by another source, not just an animation in the model's asset.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   *\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n    set: function (value) {\n      this._transformDirty = true;\n      this._transform = Matrix4.clone(value, this._transform);\n    },\n  },\n\n  /**\n   * The transforms of all the node's ancestors, not including this node's\n   * transform.\n   *\n   * @see ModelRuntimeNode#computedTransform\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  transformToRoot: {\n    get: function () {\n      return this._transformToRoot;\n    },\n  },\n\n  /**\n   * A transform from the node's local space to the model's scene graph space.\n   * This is the product of transformToRoot * transform.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedTransform: {\n    get: function () {\n      return this._computedTransform;\n    },\n  },\n\n  /**\n   * The node's original transform, as specified in the model.\n   * Does not include transformations from the node's ancestors.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  originalTransform: {\n    get: function () {\n      return this._originalTransform;\n    },\n  },\n\n  /**\n   * The node's local space translation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The translation of a node cannot be set if it was defined using a matrix in the model's asset.\n   *\n   * @private\n   */\n  translation: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.translation\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The translation of a node cannot be set if it was defined using a matrix in the model.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const currentTranslation = transformParameters.translation;\n      if (Cartesian3.equals(currentTranslation, value)) {\n        return;\n      }\n\n      transformParameters.translation = Cartesian3.clone(\n        value,\n        transformParameters.translation,\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's local space rotation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Quaternion}\n   *\n   * @exception {DeveloperError} The rotation of a node cannot be set if it was defined using a matrix in the model's asset.\n   *\n   * @private\n   */\n  rotation: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.rotation\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The rotation of a node cannot be set if it was defined using a matrix in the model.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const currentRotation = transformParameters.rotation;\n      if (Quaternion.equals(currentRotation, value)) {\n        return;\n      }\n\n      transformParameters.rotation = Quaternion.clone(\n        value,\n        transformParameters.rotation,\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's local space scale. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The scale of a node cannot be set if it was defined using a matrix in the model's asset.\n   * @private\n   */\n  scale: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.scale\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The scale of a node cannot be set if it was defined using a matrix in the model.\",\n        );\n      }\n      //>>includeEnd('debug');\n      const currentScale = transformParameters.scale;\n      if (Cartesian3.equals(currentScale, value)) {\n        return;\n      }\n\n      transformParameters.scale = Cartesian3.clone(\n        value,\n        transformParameters.scale,\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's morph weights. This is used internally to allow animations\n   * in the model's asset to affect the node's properties.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {number[]}\n   *\n   * @private\n   */\n  morphWeights: {\n    get: function () {\n      return this._morphWeights;\n    },\n    set: function (value) {\n      const valueLength = value.length;\n      //>>includeStart('debug', pragmas.debug);\n      if (this._morphWeights.length !== valueLength) {\n        throw new DeveloperError(\n          \"value must have the same length as the original weights array.\",\n        );\n      }\n      //>>includeEnd('debug');\n      for (let i = 0; i < valueLength; i++) {\n        this._morphWeights[i] = value[i];\n      }\n    },\n  },\n\n  /**\n   * The skin applied to this node, if it exists.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {ModelSkin}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeSkin: {\n    get: function () {\n      return this._runtimeSkin;\n    },\n  },\n\n  /**\n   * The computed joint matrices of this node, derived from its skin.\n   *\n   * @memberof ModelRuntimeNode.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  computedJointMatrices: {\n    get: function () {\n      return this._computedJointMatrices;\n    },\n  },\n});\n\nfunction initialize(runtimeNode) {\n  const transform = runtimeNode.transform;\n  const transformToRoot = runtimeNode.transformToRoot;\n  const computedTransform = runtimeNode._computedTransform;\n  runtimeNode._computedTransform = Matrix4.multiply(\n    transformToRoot,\n    transform,\n    computedTransform,\n  );\n\n  const node = runtimeNode.node;\n  if (!defined(node.matrix)) {\n    runtimeNode._transformParameters = new TranslationRotationScale(\n      node.translation,\n      node.rotation,\n      node.scale,\n    );\n  }\n\n  if (defined(node.morphWeights)) {\n    runtimeNode._morphWeights = node.morphWeights.slice();\n  }\n\n  // If this node is affected by an articulation from the AGI_articulations\n  // extension, add this node to its list of affected nodes.\n  const articulationName = node.articulationName;\n  if (defined(articulationName)) {\n    const sceneGraph = runtimeNode.sceneGraph;\n    const runtimeArticulations = sceneGraph._runtimeArticulations;\n\n    const runtimeArticulation = runtimeArticulations[articulationName];\n    if (defined(runtimeArticulation)) {\n      runtimeArticulation.runtimeNodes.push(runtimeNode);\n    }\n  }\n}\n\nfunction updateTransformFromParameters(runtimeNode, transformParameters) {\n  runtimeNode._transformDirty = true;\n\n  runtimeNode._transform = Matrix4.fromTranslationRotationScale(\n    transformParameters,\n    runtimeNode._transform,\n  );\n}\n\n/**\n * Returns the child with the given index.\n *\n * @param {number} index The index of the child.\n *\n * @returns {ModelRuntimeNode}\n *\n * @example\n * // Iterate through all children of a runtime node.\n * for (let i = 0; i < runtimeNode.children.length; i++)\n * {\n *   const childNode = runtimeNode.getChild(i);\n * }\n *\n * @private\n */\nModelRuntimeNode.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index >= this.children.length) {\n    throw new DeveloperError(\n      \"index must be greater than or equal to 0 and less than the number of children.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this.sceneGraph._runtimeNodes[this.children[index]];\n};\n\n/**\n * Configure the node pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @private\n */\nModelRuntimeNode.prototype.configurePipeline = function () {\n  const node = this.node;\n  const pipelineStages = this.pipelineStages;\n  pipelineStages.length = 0;\n  const updateStages = this.updateStages;\n  updateStages.length = 0;\n\n  if (defined(node.instances)) {\n    pipelineStages.push(InstancingPipelineStage);\n  }\n\n  pipelineStages.push(NodeStatisticsPipelineStage);\n\n  updateStages.push(ModelMatrixUpdateStage);\n};\n\n/**\n * Updates the computed transform used for rendering and instancing.\n *\n * @private\n */\nModelRuntimeNode.prototype.updateComputedTransform = function () {\n  this._computedTransform = Matrix4.multiply(\n    this._transformToRoot,\n    this._transform,\n    this._computedTransform,\n  );\n};\n\n/**\n * Updates the joint matrices for this node, where each matrix is computed as\n * computedJointMatrix = nodeWorldTransform^(-1) * skinJointMatrix.\n *\n * @private\n */\nModelRuntimeNode.prototype.updateJointMatrices = function () {\n  const runtimeSkin = this._runtimeSkin;\n  if (!defined(runtimeSkin)) {\n    return;\n  }\n\n  runtimeSkin.updateJointMatrices();\n\n  const computedJointMatrices = this._computedJointMatrices;\n  const skinJointMatrices = runtimeSkin.jointMatrices;\n  const length = skinJointMatrices.length;\n\n  for (let i = 0; i < length; i++) {\n    if (!defined(computedJointMatrices[i])) {\n      computedJointMatrices[i] = new Matrix4();\n    }\n\n    const nodeWorldTransform = Matrix4.multiplyTransformation(\n      this.transformToRoot,\n      this.transform,\n      computedJointMatrices[i],\n    );\n\n    const inverseNodeWorldTransform = Matrix4.inverseTransformation(\n      nodeWorldTransform,\n      computedJointMatrices[i],\n    );\n\n    computedJointMatrices[i] = Matrix4.multiplyTransformation(\n      inverseNodeWorldTransform,\n      skinJointMatrices[i],\n      computedJointMatrices[i],\n    );\n  }\n};\n\nexport default ModelRuntimeNode;\n"],"mappings":"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GAAGZ,SAAS;;EAE7C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACa,6BAA6B,GAAGb,SAAS;;EAE9C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACc,0BAA0B,GAAGd,SAAS;EAE3Ce,UAAU,CAAC,IAAI,CAAC;AAClB;AAEAC,MAAM,CAACC,gBAAgB,CAACzC,gBAAgB,CAAC0C,SAAS,EAAE;EAClD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEvC,IAAI,EAAE;IACJwC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjC,KAAK;IACnB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEJ,UAAU,EAAE;IACVqC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC5B,WAAW;IACzB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACER,QAAQ,EAAE;IACRoC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC3B,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEZ,SAAS,EAAE;IACTuC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxB,UAAU;IACxB,CAAC;IACDyB,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MACpB,IAAI,CAACvB,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACH,UAAU,GAAGzB,OAAO,CAACwB,KAAK,CAAC2B,KAAK,EAAE,IAAI,CAAC1B,UAAU,CAAC;IACzD;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEd,eAAe,EAAE;IACfsC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACvB,gBAAgB;IAC9B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}