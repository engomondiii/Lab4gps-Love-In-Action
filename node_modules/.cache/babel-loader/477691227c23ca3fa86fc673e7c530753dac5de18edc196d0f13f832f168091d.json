{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n\n  /**\n   * The radius of the sphere.\n   * @type {number}\n   * @default 0.0\n   */\n  this.radius = defaultValue(radius, 0.0);\n}\nconst fromPointsXMin = new Cartesian3();\nconst fromPointsYMin = new Cartesian3();\nconst fromPointsZMin = new Cartesian3();\nconst fromPointsXMax = new Cartesian3();\nconst fromPointsYMax = new Cartesian3();\nconst fromPointsZMax = new Cartesian3();\nconst fromPointsCurrentPos = new Cartesian3();\nconst fromPointsScratch = new Cartesian3();\nconst fromPointsRitterCenter = new Cartesian3();\nconst fromPointsMinBoxPt = new Cartesian3();\nconst fromPointsMaxBoxPt = new Cartesian3();\nconst fromPointsNaiveCenterScratch = new Cartesian3();\nconst volumeConstant = 4.0 / 3.0 * CesiumMath.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n  const currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n  const numPositions = positions.length;\n  let i;\n  for (i = 1; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n  const ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n  const zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n  return result;\n};\nconst defaultProjection = new GeographicProjection();\nconst fromRectangle2DLowerLeft = new Cartesian3();\nconst fromRectangle2DUpperRight = new Cartesian3();\nconst fromRectangle2DSouthwest = new Cartographic();\nconst fromRectangle2DNortheast = new Cartographic();\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0.0, 0.0, result);\n};\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangleWithHeights2D = function (rectangle, projection, minimumHeight, maximumHeight, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n  defaultProjection._ellipsoid = Ellipsoid.default;\n  projection = defaultValue(projection, defaultProjection);\n  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n  const lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);\n  const upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);\n  const width = upperRight.x - lowerLeft.x;\n  const height = upperRight.y - lowerLeft.y;\n  const elevation = upperRight.z - lowerLeft.z;\n  result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  const center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\nconst fromRectangle3DScratch = [];\n\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.\n * @param {number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle3D = function (rectangle, ellipsoid, surfaceHeight, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n  const positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);\n  return BoundingSphere.fromPoints(positions, result);\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n  center = defaultValue(center, Cartesian3.ZERO);\n  stride = defaultValue(stride, 3);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n  //>>includeEnd('debug');\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n  const numElements = positions.length;\n  let i;\n  for (i = 0; i < numElements; i += stride) {\n    const x = positions[i] + center.x;\n    const y = positions[i + 1] + center.y;\n    const z = positions[i + 2] + center.z;\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n  const ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n  const zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z;\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n  return result;\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromEncodedCartesianVertices = function (positionsHigh, positionsLow, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  if (!defined(positionsHigh) || !defined(positionsLow) || positionsHigh.length !== positionsLow.length || positionsHigh.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n  const numElements = positionsHigh.length;\n  let i;\n  for (i = 0; i < numElements; i += 3) {\n    const x = positionsHigh[i] + positionsLow[i];\n    const y = positionsHigh[i + 1] + positionsLow[i + 1];\n    const z = positionsHigh[i + 2] + positionsLow[i + 2];\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n  const ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n  const zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = Cartesian3.midpoint(minBoxPt, maxBoxPt, fromPointsNaiveCenterScratch);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n  return result;\n};\n\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tightly and fully encompasses the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"corner\", corner);\n  Check.typeOf.object(\"oppositeCorner\", oppositeCorner);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  const center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  Cartesian3.clone(Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\nconst fromBoundingSpheresScratch = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n  const length = boundingSpheres.length;\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n  const positions = [];\n  let i;\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n  result = BoundingSphere.fromPoints(positions, result);\n  const center = result.center;\n  let radius = result.radius;\n  for (i = 0; i < length; i++) {\n    const tmp = boundingSpheres[i];\n    radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);\n  }\n  result.radius = radius;\n  return result;\n};\nconst fromOrientedBoundingBoxScratchU = new Cartesian3();\nconst fromOrientedBoundingBoxScratchV = new Cartesian3();\nconst fromOrientedBoundingBoxScratchW = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromOrientedBoundingBox = function (orientedBoundingBox, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"orientedBoundingBox\", orientedBoundingBox);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  const halfAxes = orientedBoundingBox.halfAxes;\n  const u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  const v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  const w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n  Cartesian3.add(u, v, u);\n  Cartesian3.add(u, w, u);\n  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Cartesian3.magnitude(u);\n  return result;\n};\nconst scratchFromTransformationCenter = new Cartesian3();\nconst scratchFromTransformationScale = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  const center = Matrix4.getTranslation(transformation, scratchFromTransformationCenter);\n  const scale = Matrix4.getScale(transformation, scratchFromTransformationScale);\n  const radius = 0.5 * Cartesian3.magnitude(scale);\n  result.center = Cartesian3.clone(center, result.center);\n  result.radius = radius;\n  return result;\n};\n\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\nBoundingSphere.clone = function (sphere, result) {\n  if (!defined(sphere)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n  result.center = Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoundingSphere.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  const center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\nconst unionScratch = new Cartesian3();\nconst unionScratchCenter = new Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  const leftCenter = left.center;\n  const leftRadius = left.radius;\n  const rightCenter = right.center;\n  const rightRadius = right.radius;\n  const toRightCenter = Cartesian3.subtract(rightCenter, leftCenter, unionScratch);\n  const centerSeparation = Cartesian3.magnitude(toRightCenter);\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  }\n\n  // There are two tangent points, one on far side of each sphere.\n  const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n  // Compute the center point halfway between the two tangent points.\n  const center = Cartesian3.multiplyByScalar(toRightCenter, (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation, unionScratchCenter);\n  Cartesian3.add(center, leftCenter, center);\n  Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n  return result;\n};\nconst expandScratch = new Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n  const radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n  return result;\n};\n\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  const center = sphere.center;\n  const radius = sphere.radius;\n  const normal = plane.normal;\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Intersect.INTERSECTING;\n  }\n  return Intersect.INSIDE;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n  return result;\n};\nconst distanceSquaredToScratch = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {number} The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);\n  const distance = Cartesian3.magnitude(diff) - sphere.radius;\n  if (distance <= 0.0) {\n    return 0.0;\n  }\n  return distance * distance;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * const boundingSphere = new Cesium.BoundingSphere();\n * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n  result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\nconst scratchCartesian3 = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.computePlaneDistances = function (sphere, position, direction, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n  const toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);\n  const mag = Cartesian3.dot(direction, toCenter);\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\nconst projectTo2DNormalScratch = new Cartesian3();\nconst projectTo2DEastScratch = new Cartesian3();\nconst projectTo2DNorthScratch = new Cartesian3();\nconst projectTo2DWestScratch = new Cartesian3();\nconst projectTo2DSouthScratch = new Cartesian3();\nconst projectTo2DCartographicScratch = new Cartographic();\nconst projectTo2DPositionsScratch = new Array(8);\nfor (let n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Cartesian3();\n}\nconst projectTo2DProjection = new GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  //>>includeEnd('debug');\n\n  projectTo2DProjection._ellipsoid = Ellipsoid.default;\n  projection = defaultValue(projection, projectTo2DProjection);\n  const ellipsoid = projection.ellipsoid;\n  let center = sphere.center;\n  const radius = sphere.radius;\n  let normal;\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n  const east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);\n  Cartesian3.normalize(east, east);\n  const north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Cartesian3.normalize(north, north);\n  Cartesian3.multiplyByScalar(normal, radius, normal);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n  const south = Cartesian3.negate(north, projectTo2DSouthScratch);\n  const west = Cartesian3.negate(east, projectTo2DWestScratch);\n  const positions = projectTo2DPositionsScratch;\n\n  // top NE corner\n  let corner = positions[0];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // top NW corner\n  corner = positions[1];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SW corner\n  corner = positions[2];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SE corner\n  corner = positions[3];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n  Cartesian3.negate(normal, normal);\n\n  // bottom NE corner\n  corner = positions[4];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // bottom NW corner\n  corner = positions[5];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SW corner\n  corner = positions[6];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SE corner\n  corner = positions[7];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const position = positions[i];\n    Cartesian3.add(center, position, position);\n    const cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);\n    projection.project(cartographic, position);\n  }\n  result = BoundingSphere.fromPoints(positions, result);\n\n  // swizzle center components\n  center = result.center;\n  const x = center.x;\n  const y = center.y;\n  const z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n  return result;\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occluded object.\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"occluder\", occluder);\n  //>>includeEnd('debug');\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingSphere.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && left.radius === right.radius;\n};\n\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.prototype.computePlaneDistances = function (position, direction, result) {\n  return BoundingSphere.computePlaneDistances(this, position, direction, result);\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {number} The radius of the BoundingSphere.\n */\nBoundingSphere.prototype.volume = function () {\n  const radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\nexport default BoundingSphere;","map":{"version":3,"names":["Cartesian3","Cartographic","Check","defaultValue","defined","Ellipsoid","GeographicProjection","Intersect","Interval","CesiumMath","Matrix3","Matrix4","Rectangle","BoundingSphere","center","radius","clone","ZERO","fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","PI","fromPoints","positions","result","length","currentPos","xMin","yMin","zMin","xMax","yMax","zMax","numPositions","i","x","y","z","xSpan","magnitudeSquared","subtract","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","Math","sqrt","minBoxPt","maxBoxPt","naiveCenter","midpoint","naiveRadius","r","magnitude","oldCenterToPointSquared","oldCenterToPoint","oldToNew","defaultProjection","fromRectangle2DLowerLeft","fromRectangle2DUpperRight","fromRectangle2DSouthwest","fromRectangle2DNortheast","fromRectangle2D","rectangle","projection","fromRectangleWithHeights2D","minimumHeight","maximumHeight","_ellipsoid","default","southwest","height","northeast","lowerLeft","project","upperRight","width","elevation","fromRectangle3DScratch","fromRectangle3D","ellipsoid","surfaceHeight","subsample","fromVertices","stride","typeOf","number","greaterThanOrEquals","numElements","fromEncodedCartesianVertices","positionsHigh","positionsLow","fromCornerPoints","corner","oppositeCorner","object","distance","fromEllipsoid","maximumRadius","fromBoundingSpheresScratch","fromBoundingSpheres","boundingSpheres","union","push","tmp","max","fromOrientedBoundingBoxScratchU","fromOrientedBoundingBoxScratchV","fromOrientedBoundingBoxScratchW","fromOrientedBoundingBox","orientedBoundingBox","halfAxes","u","getColumn","v","w","add","scratchFromTransformationCenter","scratchFromTransformationScale","fromTransformation","transformation","getTranslation","scale","getScale","sphere","undefined","packedLength","pack","value","array","startingIndex","unpack","unionScratch","unionScratchCenter","left","right","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","centerSeparation","halfDistanceBetweenTangentPoints","multiplyByScalar","expandScratch","expand","point","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE","transform","multiplyByPoint","getMaximumScale","distanceSquaredToScratch","distanceSquaredTo","cartesian","diff","transformWithoutScale","scratchCartesian3","computePlaneDistances","position","direction","toCenter","mag","start","stop","projectTo2DNormalScratch","projectTo2DEastScratch","projectTo2DNorthScratch","projectTo2DWestScratch","projectTo2DSouthScratch","projectTo2DCartographicScratch","projectTo2DPositionsScratch","Array","n","projectTo2DProjection","projectTo2D","equals","UNIT_X","geodeticSurfaceNormal","east","cross","UNIT_Z","normalize","north","south","negate","west","cartographic","cartesianToCartographic","isOccluded","occluder","isBoundingSphereVisible","prototype","volume"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/BoundingSphere.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n\n  /**\n   * The radius of the sphere.\n   * @type {number}\n   * @default 0.0\n   */\n  this.radius = defaultValue(radius, 0.0);\n}\n\nconst fromPointsXMin = new Cartesian3();\nconst fromPointsYMin = new Cartesian3();\nconst fromPointsZMin = new Cartesian3();\nconst fromPointsXMax = new Cartesian3();\nconst fromPointsYMax = new Cartesian3();\nconst fromPointsZMax = new Cartesian3();\nconst fromPointsCurrentPos = new Cartesian3();\nconst fromPointsScratch = new Cartesian3();\nconst fromPointsRitterCenter = new Cartesian3();\nconst fromPointsMinBoxPt = new Cartesian3();\nconst fromPointsMaxBoxPt = new Cartesian3();\nconst fromPointsNaiveCenterScratch = new Cartesian3();\nconst volumeConstant = (4.0 / 3.0) * CesiumMath.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numPositions = positions.length;\n  let i;\n  for (i = 1; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch),\n  );\n  const ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch),\n  );\n  const zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch),\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch,\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\nconst defaultProjection = new GeographicProjection();\nconst fromRectangle2DLowerLeft = new Cartesian3();\nconst fromRectangle2DUpperRight = new Cartesian3();\nconst fromRectangle2DSouthwest = new Cartographic();\nconst fromRectangle2DNortheast = new Cartographic();\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(\n    rectangle,\n    projection,\n    0.0,\n    0.0,\n    result,\n  );\n};\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangleWithHeights2D = function (\n  rectangle,\n  projection,\n  minimumHeight,\n  maximumHeight,\n  result,\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  defaultProjection._ellipsoid = Ellipsoid.default;\n  projection = defaultValue(projection, defaultProjection);\n\n  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n\n  const lowerLeft = projection.project(\n    fromRectangle2DSouthwest,\n    fromRectangle2DLowerLeft,\n  );\n  const upperRight = projection.project(\n    fromRectangle2DNortheast,\n    fromRectangle2DUpperRight,\n  );\n\n  const width = upperRight.x - lowerLeft.x;\n  const height = upperRight.y - lowerLeft.y;\n  const elevation = upperRight.z - lowerLeft.z;\n\n  result.radius =\n    Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  const center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\n\nconst fromRectangle3DScratch = [];\n\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid used to determine positions of the rectangle.\n * @param {number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle3D = function (\n  rectangle,\n  ellipsoid,\n  surfaceHeight,\n  result,\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    surfaceHeight,\n    fromRectangle3DScratch,\n  );\n  return BoundingSphere.fromPoints(positions, result);\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  center = defaultValue(center, Cartesian3.ZERO);\n\n  stride = defaultValue(stride, 3);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n  //>>includeEnd('debug');\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numElements = positions.length;\n  let i;\n  for (i = 0; i < numElements; i += stride) {\n    const x = positions[i] + center.x;\n    const y = positions[i + 1] + center.y;\n    const z = positions[i + 2] + center.z;\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch),\n  );\n  const ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch),\n  );\n  const zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch),\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch,\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z;\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromEncodedCartesianVertices = function (\n  positionsHigh,\n  positionsLow,\n  result,\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (\n    !defined(positionsHigh) ||\n    !defined(positionsLow) ||\n    positionsHigh.length !== positionsLow.length ||\n    positionsHigh.length === 0\n  ) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n\n  const xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  const yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  const zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  const xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  const yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  const zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  const numElements = positionsHigh.length;\n  let i;\n  for (i = 0; i < numElements; i += 3) {\n    const x = positionsHigh[i] + positionsLow[i];\n    const y = positionsHigh[i + 1] + positionsLow[i + 1];\n    const z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch),\n  );\n  const ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch),\n  );\n  const zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch),\n  );\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch),\n  );\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch,\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch),\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch),\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tightly and fully encompasses the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"corner\", corner);\n  Check.typeOf.object(\"oppositeCorner\", oppositeCorner);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  Cartesian3.clone(Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\n\nconst fromBoundingSpheresScratch = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  const length = boundingSpheres.length;\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n\n  const positions = [];\n  let i;\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  const center = result.center;\n  let radius = result.radius;\n  for (i = 0; i < length; i++) {\n    const tmp = boundingSpheres[i];\n    radius = Math.max(\n      radius,\n      Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) +\n        tmp.radius,\n    );\n  }\n  result.radius = radius;\n\n  return result;\n};\n\nconst fromOrientedBoundingBoxScratchU = new Cartesian3();\nconst fromOrientedBoundingBoxScratchV = new Cartesian3();\nconst fromOrientedBoundingBoxScratchW = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromOrientedBoundingBox = function (\n  orientedBoundingBox,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"orientedBoundingBox\", orientedBoundingBox);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const halfAxes = orientedBoundingBox.halfAxes;\n  const u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  const v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  const w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n\n  Cartesian3.add(u, v, u);\n  Cartesian3.add(u, w, u);\n\n  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Cartesian3.magnitude(u);\n\n  return result;\n};\n\nconst scratchFromTransformationCenter = new Cartesian3();\nconst scratchFromTransformationScale = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = Matrix4.getTranslation(\n    transformation,\n    scratchFromTransformationCenter,\n  );\n  const scale = Matrix4.getScale(\n    transformation,\n    scratchFromTransformationScale,\n  );\n  const radius = 0.5 * Cartesian3.magnitude(scale);\n  result.center = Cartesian3.clone(center, result.center);\n  result.radius = radius;\n\n  return result;\n};\n\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\nBoundingSphere.clone = function (sphere, result) {\n  if (!defined(sphere)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n\n  result.center = Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nBoundingSphere.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\n\nconst unionScratch = new Cartesian3();\nconst unionScratchCenter = new Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  const leftCenter = left.center;\n  const leftRadius = left.radius;\n  const rightCenter = right.center;\n  const rightRadius = right.radius;\n\n  const toRightCenter = Cartesian3.subtract(\n    rightCenter,\n    leftCenter,\n    unionScratch,\n  );\n  const centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  }\n\n  // There are two tangent points, one on far side of each sphere.\n  const halfDistanceBetweenTangentPoints =\n    (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n  // Compute the center point halfway between the two tangent points.\n  const center = Cartesian3.multiplyByScalar(\n    toRightCenter,\n    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,\n    unionScratchCenter,\n  );\n  Cartesian3.add(center, leftCenter, center);\n  Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n\n  return result;\n};\n\nconst expandScratch = new Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n\n  const radius = Cartesian3.magnitude(\n    Cartesian3.subtract(point, result.center, expandScratch),\n  );\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n\n  return result;\n};\n\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  const center = sphere.center;\n  const radius = sphere.radius;\n  const normal = plane.normal;\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Intersect.INTERSECTING;\n  }\n  return Intersect.INSIDE;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center,\n  );\n  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n\n  return result;\n};\n\nconst distanceSquaredToScratch = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {number} The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const diff = Cartesian3.subtract(\n    sphere.center,\n    cartesian,\n    distanceSquaredToScratch,\n  );\n\n  const distance = Cartesian3.magnitude(diff) - sphere.radius;\n  if (distance <= 0.0) {\n    return 0.0;\n  }\n\n  return distance * distance;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * const boundingSphere = new Cesium.BoundingSphere();\n * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center,\n  );\n  result.radius = sphere.radius;\n\n  return result;\n};\n\nconst scratchCartesian3 = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.computePlaneDistances = function (\n  sphere,\n  position,\n  direction,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  const toCenter = Cartesian3.subtract(\n    sphere.center,\n    position,\n    scratchCartesian3,\n  );\n  const mag = Cartesian3.dot(direction, toCenter);\n\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\n\nconst projectTo2DNormalScratch = new Cartesian3();\nconst projectTo2DEastScratch = new Cartesian3();\nconst projectTo2DNorthScratch = new Cartesian3();\nconst projectTo2DWestScratch = new Cartesian3();\nconst projectTo2DSouthScratch = new Cartesian3();\nconst projectTo2DCartographicScratch = new Cartographic();\nconst projectTo2DPositionsScratch = new Array(8);\nfor (let n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Cartesian3();\n}\n\nconst projectTo2DProjection = new GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  //>>includeEnd('debug');\n\n  projectTo2DProjection._ellipsoid = Ellipsoid.default;\n  projection = defaultValue(projection, projectTo2DProjection);\n\n  const ellipsoid = projection.ellipsoid;\n  let center = sphere.center;\n  const radius = sphere.radius;\n\n  let normal;\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n  const east = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    normal,\n    projectTo2DEastScratch,\n  );\n  Cartesian3.normalize(east, east);\n  const north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Cartesian3.normalize(north, north);\n\n  Cartesian3.multiplyByScalar(normal, radius, normal);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n\n  const south = Cartesian3.negate(north, projectTo2DSouthScratch);\n  const west = Cartesian3.negate(east, projectTo2DWestScratch);\n\n  const positions = projectTo2DPositionsScratch;\n\n  // top NE corner\n  let corner = positions[0];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // top NW corner\n  corner = positions[1];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SW corner\n  corner = positions[2];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SE corner\n  corner = positions[3];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  Cartesian3.negate(normal, normal);\n\n  // bottom NE corner\n  corner = positions[4];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // bottom NW corner\n  corner = positions[5];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SW corner\n  corner = positions[6];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SE corner\n  corner = positions[7];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const position = positions[i];\n    Cartesian3.add(center, position, position);\n    const cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      projectTo2DCartographicScratch,\n    );\n    projection.project(cartographic, position);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  // swizzle center components\n  center = result.center;\n  const x = center.x;\n  const y = center.y;\n  const z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n\n  return result;\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occluded object.\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"occluder\", occluder);\n  //>>includeEnd('debug');\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingSphere.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      left.radius === right.radius)\n  );\n};\n\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result,\n) {\n  return BoundingSphere.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result,\n  );\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {number} The radius of the BoundingSphere.\n */\nBoundingSphere.prototype.volume = function () {\n  const radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\nexport default BoundingSphere;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}