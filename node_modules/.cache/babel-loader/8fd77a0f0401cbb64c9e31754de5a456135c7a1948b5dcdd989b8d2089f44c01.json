{"ast":null,"code":"/*\n Copyright (c) 2022 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global crypto, TransformStream */\n// deno-lint-ignore-file no-this-alias\n\nimport { UNDEFINED_VALUE, UNDEFINED_TYPE, FUNCTION_TYPE } from \"../constants.js\";\nimport { encodeText } from \"./../util/encode-text.js\";\nimport { cipher, codec, misc, mode } from \"./codecs/sjcl.js\";\nimport { ERR_INVALID_PASSWORD, ERR_INVALID_SIGNATURE, ERR_ABORT_CHECK_PASSWORD, getRandomValues } from \"./common-crypto.js\";\nconst BLOCK_LENGTH = 16;\nconst RAW_FORMAT = \"raw\";\nconst PBKDF2_ALGORITHM = {\n  name: \"PBKDF2\"\n};\nconst HASH_ALGORITHM = {\n  name: \"HMAC\"\n};\nconst HASH_FUNCTION = \"SHA-1\";\nconst BASE_KEY_ALGORITHM = Object.assign({\n  hash: HASH_ALGORITHM\n}, PBKDF2_ALGORITHM);\nconst DERIVED_BITS_ALGORITHM = Object.assign({\n  iterations: 1000,\n  hash: {\n    name: HASH_FUNCTION\n  }\n}, PBKDF2_ALGORITHM);\nconst DERIVED_BITS_USAGE = [\"deriveBits\"];\nconst SALT_LENGTH = [8, 12, 16];\nconst KEY_LENGTH = [16, 24, 32];\nconst SIGNATURE_LENGTH = 10;\nconst COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];\n// deno-lint-ignore valid-typeof\nconst CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;\nconst subtle = CRYPTO_API_SUPPORTED && crypto.subtle;\nconst SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;\nconst codecBytes = codec.bytes;\nconst Aes = cipher.aes;\nconst CtrGladman = mode.ctrGladman;\nconst HmacSha1 = misc.hmacSha1;\nlet IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;\nlet DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;\nclass AESDecryptionStream extends TransformStream {\n  constructor({\n    password,\n    rawPassword,\n    signed,\n    encryptionStrength,\n    checkPasswordOnly\n  }) {\n    super({\n      start() {\n        Object.assign(this, {\n          ready: new Promise(resolve => this.resolveReady = resolve),\n          password: encodePassword(password, rawPassword),\n          signed,\n          strength: encryptionStrength - 1,\n          pending: new Uint8Array()\n        });\n      },\n      async transform(chunk, controller) {\n        const aesCrypto = this;\n        const {\n          password,\n          strength,\n          resolveReady,\n          ready\n        } = aesCrypto;\n        if (password) {\n          await createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));\n          chunk = subarray(chunk, SALT_LENGTH[strength] + 2);\n          if (checkPasswordOnly) {\n            controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));\n          } else {\n            resolveReady();\n          }\n        } else {\n          await ready;\n        }\n        const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - (chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH);\n        controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));\n      },\n      async flush(controller) {\n        const {\n          signed,\n          ctr,\n          hmac,\n          pending,\n          ready\n        } = this;\n        if (hmac && ctr) {\n          await ready;\n          const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);\n          const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);\n          let decryptedChunkArray = new Uint8Array();\n          if (chunkToDecrypt.length) {\n            const encryptedChunk = toBits(codecBytes, chunkToDecrypt);\n            hmac.update(encryptedChunk);\n            const decryptedChunk = ctr.update(encryptedChunk);\n            decryptedChunkArray = fromBits(codecBytes, decryptedChunk);\n          }\n          if (signed) {\n            const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);\n            for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {\n              if (signature[indexSignature] != originalSignature[indexSignature]) {\n                throw new Error(ERR_INVALID_SIGNATURE);\n              }\n            }\n          }\n          controller.enqueue(decryptedChunkArray);\n        }\n      }\n    });\n  }\n}\nclass AESEncryptionStream extends TransformStream {\n  constructor({\n    password,\n    rawPassword,\n    encryptionStrength\n  }) {\n    // deno-lint-ignore prefer-const\n    let stream;\n    super({\n      start() {\n        Object.assign(this, {\n          ready: new Promise(resolve => this.resolveReady = resolve),\n          password: encodePassword(password, rawPassword),\n          strength: encryptionStrength - 1,\n          pending: new Uint8Array()\n        });\n      },\n      async transform(chunk, controller) {\n        const aesCrypto = this;\n        const {\n          password,\n          strength,\n          resolveReady,\n          ready\n        } = aesCrypto;\n        let preamble = new Uint8Array();\n        if (password) {\n          preamble = await createEncryptionKeys(aesCrypto, strength, password);\n          resolveReady();\n        } else {\n          await ready;\n        }\n        const output = new Uint8Array(preamble.length + chunk.length - chunk.length % BLOCK_LENGTH);\n        output.set(preamble, 0);\n        controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));\n      },\n      async flush(controller) {\n        const {\n          ctr,\n          hmac,\n          pending,\n          ready\n        } = this;\n        if (hmac && ctr) {\n          await ready;\n          let encryptedChunkArray = new Uint8Array();\n          if (pending.length) {\n            const encryptedChunk = ctr.update(toBits(codecBytes, pending));\n            hmac.update(encryptedChunk);\n            encryptedChunkArray = fromBits(codecBytes, encryptedChunk);\n          }\n          stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);\n          controller.enqueue(concat(encryptedChunkArray, stream.signature));\n        }\n      }\n    });\n    stream = this;\n  }\n}\nexport { AESDecryptionStream, AESEncryptionStream, ERR_INVALID_PASSWORD };\nfunction append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {\n  const {\n    ctr,\n    hmac,\n    pending\n  } = aesCrypto;\n  const inputLength = input.length - paddingEnd;\n  if (pending.length) {\n    input = concat(pending, input);\n    output = expand(output, inputLength - inputLength % BLOCK_LENGTH);\n  }\n  let offset;\n  for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {\n    const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));\n    if (verifySignature) {\n      hmac.update(inputChunk);\n    }\n    const outputChunk = ctr.update(inputChunk);\n    if (!verifySignature) {\n      hmac.update(outputChunk);\n    }\n    output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);\n  }\n  aesCrypto.pending = subarray(input, offset);\n  return output;\n}\nasync function createDecryptionKeys(decrypt, strength, password, preamble) {\n  const passwordVerificationKey = await createKeys(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));\n  const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);\n  if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {\n    throw new Error(ERR_INVALID_PASSWORD);\n  }\n}\nasync function createEncryptionKeys(encrypt, strength, password) {\n  const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));\n  const passwordVerification = await createKeys(encrypt, strength, password, salt);\n  return concat(salt, passwordVerification);\n}\nasync function createKeys(aesCrypto, strength, password, salt) {\n  aesCrypto.password = null;\n  const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);\n  const derivedBits = await deriveBits(Object.assign({\n    salt\n  }, DERIVED_BITS_ALGORITHM), baseKey, 8 * (KEY_LENGTH[strength] * 2 + 2));\n  const compositeKey = new Uint8Array(derivedBits);\n  const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));\n  const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));\n  const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);\n  Object.assign(aesCrypto, {\n    keys: {\n      key,\n      authentication,\n      passwordVerification\n    },\n    ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),\n    hmac: new HmacSha1(authentication)\n  });\n  return passwordVerification;\n}\nasync function importKey(format, password, algorithm, extractable, keyUsages) {\n  if (IMPORT_KEY_SUPPORTED) {\n    try {\n      return await subtle.importKey(format, password, algorithm, extractable, keyUsages);\n    } catch (_error) {\n      IMPORT_KEY_SUPPORTED = false;\n      return misc.importKey(password);\n    }\n  } else {\n    return misc.importKey(password);\n  }\n}\nasync function deriveBits(algorithm, baseKey, length) {\n  if (DERIVE_BITS_SUPPORTED) {\n    try {\n      return await subtle.deriveBits(algorithm, baseKey, length);\n    } catch (_error) {\n      DERIVE_BITS_SUPPORTED = false;\n      return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);\n    }\n  } else {\n    return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);\n  }\n}\nfunction encodePassword(password, rawPassword) {\n  if (rawPassword === UNDEFINED_VALUE) {\n    return encodeText(password);\n  } else {\n    return rawPassword;\n  }\n}\nfunction concat(leftArray, rightArray) {\n  let array = leftArray;\n  if (leftArray.length + rightArray.length) {\n    array = new Uint8Array(leftArray.length + rightArray.length);\n    array.set(leftArray, 0);\n    array.set(rightArray, leftArray.length);\n  }\n  return array;\n}\nfunction expand(inputArray, length) {\n  if (length && length > inputArray.length) {\n    const array = inputArray;\n    inputArray = new Uint8Array(length);\n    inputArray.set(array, 0);\n  }\n  return inputArray;\n}\nfunction subarray(array, begin, end) {\n  return array.subarray(begin, end);\n}\nfunction fromBits(codecBytes, chunk) {\n  return codecBytes.fromBits(chunk);\n}\nfunction toBits(codecBytes, chunk) {\n  return codecBytes.toBits(chunk);\n}","map":{"version":3,"names":["UNDEFINED_VALUE","UNDEFINED_TYPE","FUNCTION_TYPE","encodeText","cipher","codec","misc","mode","ERR_INVALID_PASSWORD","ERR_INVALID_SIGNATURE","ERR_ABORT_CHECK_PASSWORD","getRandomValues","BLOCK_LENGTH","RAW_FORMAT","PBKDF2_ALGORITHM","name","HASH_ALGORITHM","HASH_FUNCTION","BASE_KEY_ALGORITHM","Object","assign","hash","DERIVED_BITS_ALGORITHM","iterations","DERIVED_BITS_USAGE","SALT_LENGTH","KEY_LENGTH","SIGNATURE_LENGTH","COUNTER_DEFAULT_VALUE","CRYPTO_API_SUPPORTED","crypto","subtle","SUBTLE_API_SUPPORTED","codecBytes","bytes","Aes","aes","CtrGladman","ctrGladman","HmacSha1","hmacSha1","IMPORT_KEY_SUPPORTED","importKey","DERIVE_BITS_SUPPORTED","deriveBits","AESDecryptionStream","TransformStream","constructor","password","rawPassword","signed","encryptionStrength","checkPasswordOnly","start","ready","Promise","resolve","resolveReady","encodePassword","strength","pending","Uint8Array","transform","chunk","controller","aesCrypto","createDecryptionKeys","subarray","error","Error","output","length","enqueue","append","flush","ctr","hmac","chunkToDecrypt","originalSignature","decryptedChunkArray","encryptedChunk","toBits","update","decryptedChunk","fromBits","signature","digest","indexSignature","AESEncryptionStream","stream","preamble","createEncryptionKeys","set","encryptedChunkArray","slice","concat","input","paddingStart","paddingEnd","verifySignature","inputLength","expand","offset","inputChunk","outputChunk","decrypt","passwordVerificationKey","createKeys","passwordVerification","encrypt","salt","baseKey","derivedBits","compositeKey","key","authentication","keys","Array","from","format","algorithm","extractable","keyUsages","_error","pbkdf2","leftArray","rightArray","array","inputArray","begin","end"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@zip.js/zip.js/lib/core/streams/aes-crypto-stream.js"],"sourcesContent":["/*\n Copyright (c) 2022 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global crypto, TransformStream */\n// deno-lint-ignore-file no-this-alias\n\nimport { UNDEFINED_VALUE, UNDEFINED_TYPE, FUNCTION_TYPE } from \"../constants.js\";\nimport { encodeText } from \"./../util/encode-text.js\";\nimport {\n\tcipher,\n\tcodec,\n\tmisc,\n\tmode\n} from \"./codecs/sjcl.js\";\nimport {\n\tERR_INVALID_PASSWORD,\n\tERR_INVALID_SIGNATURE,\n\tERR_ABORT_CHECK_PASSWORD,\n\tgetRandomValues\n} from \"./common-crypto.js\";\n\nconst BLOCK_LENGTH = 16;\nconst RAW_FORMAT = \"raw\";\nconst PBKDF2_ALGORITHM = { name: \"PBKDF2\" };\nconst HASH_ALGORITHM = { name: \"HMAC\" };\nconst HASH_FUNCTION = \"SHA-1\";\nconst BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);\nconst DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1000, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);\nconst DERIVED_BITS_USAGE = [\"deriveBits\"];\nconst SALT_LENGTH = [8, 12, 16];\nconst KEY_LENGTH = [16, 24, 32];\nconst SIGNATURE_LENGTH = 10;\nconst COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];\n// deno-lint-ignore valid-typeof\nconst CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;\nconst subtle = CRYPTO_API_SUPPORTED && crypto.subtle;\nconst SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;\nconst codecBytes = codec.bytes;\nconst Aes = cipher.aes;\nconst CtrGladman = mode.ctrGladman;\nconst HmacSha1 = misc.hmacSha1;\n\nlet IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;\nlet DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;\n\nclass AESDecryptionStream extends TransformStream {\n\n\tconstructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }) {\n\t\tsuper({\n\t\t\tstart() {\n\t\t\t\tObject.assign(this, {\n\t\t\t\t\tready: new Promise(resolve => this.resolveReady = resolve),\n\t\t\t\t\tpassword: encodePassword(password, rawPassword),\n\t\t\t\t\tsigned,\n\t\t\t\t\tstrength: encryptionStrength - 1,\n\t\t\t\t\tpending: new Uint8Array()\n\t\t\t\t});\n\t\t\t},\n\t\t\tasync transform(chunk, controller) {\n\t\t\t\tconst aesCrypto = this;\n\t\t\t\tconst {\n\t\t\t\t\tpassword,\n\t\t\t\t\tstrength,\n\t\t\t\t\tresolveReady,\n\t\t\t\t\tready\n\t\t\t\t} = aesCrypto;\n\t\t\t\tif (password) {\n\t\t\t\t\tawait createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));\n\t\t\t\t\tchunk = subarray(chunk, SALT_LENGTH[strength] + 2);\n\t\t\t\t\tif (checkPasswordOnly) {\n\t\t\t\t\t\tcontroller.error(new Error(ERR_ABORT_CHECK_PASSWORD));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolveReady();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait ready;\n\t\t\t\t}\n\t\t\t\tconst output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - ((chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH));\n\t\t\t\tcontroller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));\n\t\t\t},\n\t\t\tasync flush(controller) {\n\t\t\t\tconst {\n\t\t\t\t\tsigned,\n\t\t\t\t\tctr,\n\t\t\t\t\thmac,\n\t\t\t\t\tpending,\n\t\t\t\t\tready\n\t\t\t\t} = this;\n\t\t\t\tif (hmac && ctr) {\n\t\t\t\t\tawait ready;\n\t\t\t\t\tconst chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);\n\t\t\t\t\tconst originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);\n\t\t\t\t\tlet decryptedChunkArray = new Uint8Array();\n\t\t\t\t\tif (chunkToDecrypt.length) {\n\t\t\t\t\t\tconst encryptedChunk = toBits(codecBytes, chunkToDecrypt);\n\t\t\t\t\t\thmac.update(encryptedChunk);\n\t\t\t\t\t\tconst decryptedChunk = ctr.update(encryptedChunk);\n\t\t\t\t\t\tdecryptedChunkArray = fromBits(codecBytes, decryptedChunk);\n\t\t\t\t\t}\n\t\t\t\t\tif (signed) {\n\t\t\t\t\t\tconst signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);\n\t\t\t\t\t\tfor (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {\n\t\t\t\t\t\t\tif (signature[indexSignature] != originalSignature[indexSignature]) {\n\t\t\t\t\t\t\t\tthrow new Error(ERR_INVALID_SIGNATURE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontroller.enqueue(decryptedChunkArray);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nclass AESEncryptionStream extends TransformStream {\n\n\tconstructor({ password, rawPassword, encryptionStrength }) {\n\t\t// deno-lint-ignore prefer-const\n\t\tlet stream;\n\t\tsuper({\n\t\t\tstart() {\n\t\t\t\tObject.assign(this, {\n\t\t\t\t\tready: new Promise(resolve => this.resolveReady = resolve),\n\t\t\t\t\tpassword: encodePassword(password, rawPassword),\n\t\t\t\t\tstrength: encryptionStrength - 1,\n\t\t\t\t\tpending: new Uint8Array()\n\t\t\t\t});\n\t\t\t},\n\t\t\tasync transform(chunk, controller) {\n\t\t\t\tconst aesCrypto = this;\n\t\t\t\tconst {\n\t\t\t\t\tpassword,\n\t\t\t\t\tstrength,\n\t\t\t\t\tresolveReady,\n\t\t\t\t\tready\n\t\t\t\t} = aesCrypto;\n\t\t\t\tlet preamble = new Uint8Array();\n\t\t\t\tif (password) {\n\t\t\t\t\tpreamble = await createEncryptionKeys(aesCrypto, strength, password);\n\t\t\t\t\tresolveReady();\n\t\t\t\t} else {\n\t\t\t\t\tawait ready;\n\t\t\t\t}\n\t\t\t\tconst output = new Uint8Array(preamble.length + chunk.length - (chunk.length % BLOCK_LENGTH));\n\t\t\t\toutput.set(preamble, 0);\n\t\t\t\tcontroller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));\n\t\t\t},\n\t\t\tasync flush(controller) {\n\t\t\t\tconst {\n\t\t\t\t\tctr,\n\t\t\t\t\thmac,\n\t\t\t\t\tpending,\n\t\t\t\t\tready\n\t\t\t\t} = this;\n\t\t\t\tif (hmac && ctr) {\n\t\t\t\t\tawait ready;\n\t\t\t\t\tlet encryptedChunkArray = new Uint8Array();\n\t\t\t\t\tif (pending.length) {\n\t\t\t\t\t\tconst encryptedChunk = ctr.update(toBits(codecBytes, pending));\n\t\t\t\t\t\thmac.update(encryptedChunk);\n\t\t\t\t\t\tencryptedChunkArray = fromBits(codecBytes, encryptedChunk);\n\t\t\t\t\t}\n\t\t\t\t\tstream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);\n\t\t\t\t\tcontroller.enqueue(concat(encryptedChunkArray, stream.signature));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tstream = this;\n\t}\n}\n\nexport {\n\tAESDecryptionStream,\n\tAESEncryptionStream,\n\tERR_INVALID_PASSWORD\n};\n\nfunction append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {\n\tconst {\n\t\tctr,\n\t\thmac,\n\t\tpending\n\t} = aesCrypto;\n\tconst inputLength = input.length - paddingEnd;\n\tif (pending.length) {\n\t\tinput = concat(pending, input);\n\t\toutput = expand(output, inputLength - (inputLength % BLOCK_LENGTH));\n\t}\n\tlet offset;\n\tfor (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {\n\t\tconst inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));\n\t\tif (verifySignature) {\n\t\t\thmac.update(inputChunk);\n\t\t}\n\t\tconst outputChunk = ctr.update(inputChunk);\n\t\tif (!verifySignature) {\n\t\t\thmac.update(outputChunk);\n\t\t}\n\t\toutput.set(fromBits(codecBytes, outputChunk), offset + paddingStart);\n\t}\n\taesCrypto.pending = subarray(input, offset);\n\treturn output;\n}\n\nasync function createDecryptionKeys(decrypt, strength, password, preamble) {\n\tconst passwordVerificationKey = await createKeys(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));\n\tconst passwordVerification = subarray(preamble, SALT_LENGTH[strength]);\n\tif (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {\n\t\tthrow new Error(ERR_INVALID_PASSWORD);\n\t}\n}\n\nasync function createEncryptionKeys(encrypt, strength, password) {\n\tconst salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));\n\tconst passwordVerification = await createKeys(encrypt, strength, password, salt);\n\treturn concat(salt, passwordVerification);\n}\n\nasync function createKeys(aesCrypto, strength, password, salt) {\n\taesCrypto.password = null;\n\tconst baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);\n\tconst derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * ((KEY_LENGTH[strength] * 2) + 2));\n\tconst compositeKey = new Uint8Array(derivedBits);\n\tconst key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));\n\tconst authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));\n\tconst passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);\n\tObject.assign(aesCrypto, {\n\t\tkeys: {\n\t\t\tkey,\n\t\t\tauthentication,\n\t\t\tpasswordVerification\n\t\t},\n\t\tctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),\n\t\thmac: new HmacSha1(authentication)\n\t});\n\treturn passwordVerification;\n}\n\nasync function importKey(format, password, algorithm, extractable, keyUsages) {\n\tif (IMPORT_KEY_SUPPORTED) {\n\t\ttry {\n\t\t\treturn await subtle.importKey(format, password, algorithm, extractable, keyUsages);\n\t\t} catch (_error) {\n\t\t\tIMPORT_KEY_SUPPORTED = false;\n\t\t\treturn misc.importKey(password);\n\t\t}\n\t} else {\n\t\treturn misc.importKey(password);\n\t}\n}\n\nasync function deriveBits(algorithm, baseKey, length) {\n\tif (DERIVE_BITS_SUPPORTED) {\n\t\ttry {\n\t\t\treturn await subtle.deriveBits(algorithm, baseKey, length);\n\t\t} catch (_error) {\n\t\t\tDERIVE_BITS_SUPPORTED = false;\n\t\t\treturn misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);\n\t\t}\n\t} else {\n\t\treturn misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);\n\t}\n}\n\nfunction encodePassword(password, rawPassword) {\n\tif (rawPassword === UNDEFINED_VALUE) {\n\t\treturn encodeText(password);\n\t} else {\n\t\treturn rawPassword;\n\t}\n}\n\nfunction concat(leftArray, rightArray) {\n\tlet array = leftArray;\n\tif (leftArray.length + rightArray.length) {\n\t\tarray = new Uint8Array(leftArray.length + rightArray.length);\n\t\tarray.set(leftArray, 0);\n\t\tarray.set(rightArray, leftArray.length);\n\t}\n\treturn array;\n}\n\nfunction expand(inputArray, length) {\n\tif (length && length > inputArray.length) {\n\t\tconst array = inputArray;\n\t\tinputArray = new Uint8Array(length);\n\t\tinputArray.set(array, 0);\n\t}\n\treturn inputArray;\n}\n\nfunction subarray(array, begin, end) {\n\treturn array.subarray(begin, end);\n}\n\nfunction fromBits(codecBytes, chunk) {\n\treturn codecBytes.fromBits(chunk);\n}\nfunction toBits(codecBytes, chunk) {\n\treturn codecBytes.toBits(chunk);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}