{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * A Plane in Hessian Normal form to be used with {@link ClippingPlaneCollection}.\n * Compatible with mathematics functions in {@link Plane}\n *\n * @alias ClippingPlane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n */\nfunction ClippingPlane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  this._distance = distance;\n  this._normal = new UpdateChangedCartesian3(normal, this);\n  this.onChangeCallback = undefined;\n  this.index = -1; // to be set by ClippingPlaneCollection\n}\nObject.defineProperties(ClippingPlane.prototype, {\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {number}\n   * @memberof ClippingPlane.prototype\n   */\n  distance: {\n    get: function () {\n      return this._distance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (defined(this.onChangeCallback) && value !== this._distance) {\n        this.onChangeCallback(this.index);\n      }\n      this._distance = value;\n    }\n  },\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   * @memberof ClippingPlane.prototype\n   */\n  normal: {\n    get: function () {\n      return this._normal;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n      if (defined(this.onChangeCallback) && !Cartesian3.equals(this._normal._cartesian3, value)) {\n        this.onChangeCallback(this.index);\n      }\n      // Set without firing callback again\n      Cartesian3.clone(value, this._normal._cartesian3);\n    }\n  }\n});\n\n/**\n * Create a ClippingPlane from a Plane object.\n *\n * @param {Plane} plane The plane containing parameters to copy\n * @param {ClippingPlane} [result] The object on which to store the result\n * @returns {ClippingPlane} The ClippingPlane generated from the plane's parameters.\n */\nClippingPlane.fromPlane = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new ClippingPlane(plane.normal, plane.distance);\n  } else {\n    result.normal = plane.normal;\n    result.distance = plane.distance;\n  }\n  return result;\n};\n\n/**\n * Clones the ClippingPlane without setting its ownership.\n * @param {ClippingPlane} clippingPlane The ClippingPlane to be cloned\n * @param {ClippingPlane} [result] The object on which to store the cloned parameters.\n * @returns {ClippingPlane} a clone of the input ClippingPlane\n */\nClippingPlane.clone = function (clippingPlane, result) {\n  if (!defined(result)) {\n    return new ClippingPlane(clippingPlane.normal, clippingPlane.distance);\n  }\n  result.normal = clippingPlane.normal;\n  result.distance = clippingPlane.distance;\n  return result;\n};\n\n/**\n * Wrapper on Cartesian3 that allows detection of Plane changes from \"members of members,\" for example:\n *\n * const clippingPlane = new ClippingPlane(...);\n * clippingPlane.normal.z = -1.0;\n *\n * @private\n */\nfunction UpdateChangedCartesian3(normal, clippingPlane) {\n  this._clippingPlane = clippingPlane;\n  this._cartesian3 = Cartesian3.clone(normal);\n}\nObject.defineProperties(UpdateChangedCartesian3.prototype, {\n  x: {\n    get: function () {\n      return this._cartesian3.x;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (defined(this._clippingPlane.onChangeCallback) && value !== this._cartesian3.x) {\n        this._clippingPlane.onChangeCallback(this._clippingPlane.index);\n      }\n      this._cartesian3.x = value;\n    }\n  },\n  y: {\n    get: function () {\n      return this._cartesian3.y;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (defined(this._clippingPlane.onChangeCallback) && value !== this._cartesian3.y) {\n        this._clippingPlane.onChangeCallback(this._clippingPlane.index);\n      }\n      this._cartesian3.y = value;\n    }\n  },\n  z: {\n    get: function () {\n      return this._cartesian3.z;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (defined(this._clippingPlane.onChangeCallback) && value !== this._cartesian3.z) {\n        this._clippingPlane.onChangeCallback(this._clippingPlane.index);\n      }\n      this._cartesian3.z = value;\n    }\n  }\n});\nexport default ClippingPlane;","map":{"version":3,"names":["Cartesian3","Check","defined","ClippingPlane","normal","distance","typeOf","object","number","_distance","_normal","UpdateChangedCartesian3","onChangeCallback","undefined","index","Object","defineProperties","prototype","get","set","value","equals","_cartesian3","clone","fromPlane","plane","result","clippingPlane","_clippingPlane","x","y","z"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ClippingPlane.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * A Plane in Hessian Normal form to be used with {@link ClippingPlaneCollection}.\n * Compatible with mathematics functions in {@link Plane}\n *\n * @alias ClippingPlane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n */\nfunction ClippingPlane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  this._distance = distance;\n  this._normal = new UpdateChangedCartesian3(normal, this);\n  this.onChangeCallback = undefined;\n  this.index = -1; // to be set by ClippingPlaneCollection\n}\n\nObject.defineProperties(ClippingPlane.prototype, {\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {number}\n   * @memberof ClippingPlane.prototype\n   */\n  distance: {\n    get: function () {\n      return this._distance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (defined(this.onChangeCallback) && value !== this._distance) {\n        this.onChangeCallback(this.index);\n      }\n      this._distance = value;\n    },\n  },\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   * @memberof ClippingPlane.prototype\n   */\n  normal: {\n    get: function () {\n      return this._normal;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n      if (\n        defined(this.onChangeCallback) &&\n        !Cartesian3.equals(this._normal._cartesian3, value)\n      ) {\n        this.onChangeCallback(this.index);\n      }\n      // Set without firing callback again\n      Cartesian3.clone(value, this._normal._cartesian3);\n    },\n  },\n});\n\n/**\n * Create a ClippingPlane from a Plane object.\n *\n * @param {Plane} plane The plane containing parameters to copy\n * @param {ClippingPlane} [result] The object on which to store the result\n * @returns {ClippingPlane} The ClippingPlane generated from the plane's parameters.\n */\nClippingPlane.fromPlane = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new ClippingPlane(plane.normal, plane.distance);\n  } else {\n    result.normal = plane.normal;\n    result.distance = plane.distance;\n  }\n  return result;\n};\n\n/**\n * Clones the ClippingPlane without setting its ownership.\n * @param {ClippingPlane} clippingPlane The ClippingPlane to be cloned\n * @param {ClippingPlane} [result] The object on which to store the cloned parameters.\n * @returns {ClippingPlane} a clone of the input ClippingPlane\n */\nClippingPlane.clone = function (clippingPlane, result) {\n  if (!defined(result)) {\n    return new ClippingPlane(clippingPlane.normal, clippingPlane.distance);\n  }\n  result.normal = clippingPlane.normal;\n  result.distance = clippingPlane.distance;\n  return result;\n};\n\n/**\n * Wrapper on Cartesian3 that allows detection of Plane changes from \"members of members,\" for example:\n *\n * const clippingPlane = new ClippingPlane(...);\n * clippingPlane.normal.z = -1.0;\n *\n * @private\n */\nfunction UpdateChangedCartesian3(normal, clippingPlane) {\n  this._clippingPlane = clippingPlane;\n  this._cartesian3 = Cartesian3.clone(normal);\n}\n\nObject.defineProperties(UpdateChangedCartesian3.prototype, {\n  x: {\n    get: function () {\n      return this._cartesian3.x;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (\n        defined(this._clippingPlane.onChangeCallback) &&\n        value !== this._cartesian3.x\n      ) {\n        this._clippingPlane.onChangeCallback(this._clippingPlane.index);\n      }\n      this._cartesian3.x = value;\n    },\n  },\n  y: {\n    get: function () {\n      return this._cartesian3.y;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (\n        defined(this._clippingPlane.onChangeCallback) &&\n        value !== this._cartesian3.y\n      ) {\n        this._clippingPlane.onChangeCallback(this._clippingPlane.index);\n      }\n      this._cartesian3.y = value;\n    },\n  },\n  z: {\n    get: function () {\n      return this._cartesian3.z;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n      if (\n        defined(this._clippingPlane.onChangeCallback) &&\n        value !== this._cartesian3.z\n      ) {\n        this._clippingPlane.onChangeCallback(this._clippingPlane.index);\n      }\n      this._cartesian3.z = value;\n    },\n  },\n});\nexport default ClippingPlane;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}