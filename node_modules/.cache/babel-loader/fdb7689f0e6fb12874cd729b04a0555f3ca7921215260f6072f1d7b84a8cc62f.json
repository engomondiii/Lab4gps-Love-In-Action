{"ast":null,"code":"import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {number}\n */\nconst IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {number} The size in bytes.\n *\n * @example\n * // Returns 2\n * const size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\"indexDatatype is required and must be a valid IndexDatatype constant.\");\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"Size in bytes cannot be mapped to an IndexDatatype\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return defined(indexDatatype) && (indexDatatype === IndexDatatype.UNSIGNED_BYTE || indexDatatype === IndexDatatype.UNSIGNED_SHORT || indexDatatype === IndexDatatype.UNSIGNED_INT);\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {number} numberOfVertices Number of vertices that the indices will reference.\n * @param {number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (numberOfVertices, indicesLengthOrArray) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {number} byteOffset Passed through to the typed array constructor.\n * @param {number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (numberOfVertices, sourceArray, byteOffset, length) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\n\n/**\n * Gets the {@link IndexDatatype} for the provided TypedArray instance.\n *\n * @param {Uint8Array|Uint16Array|Uint32Array} array The typed array.\n * @returns {IndexDatatype} The IndexDatatype for the provided array, or undefined if the array is not a Uint8Array, Uint16Array, or Uint32Array.\n */\nIndexDatatype.fromTypedArray = function (array) {\n  if (array instanceof Uint8Array) {\n    return IndexDatatype.UNSIGNED_BYTE;\n  }\n  if (array instanceof Uint16Array) {\n    return IndexDatatype.UNSIGNED_SHORT;\n  }\n  if (array instanceof Uint32Array) {\n    return IndexDatatype.UNSIGNED_INT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\"array must be a Uint8Array, Uint16Array, or Uint32Array.\");\n  //>>includeEnd('debug');\n};\nexport default Object.freeze(IndexDatatype);","map":{"version":3,"names":["defined","DeveloperError","CesiumMath","WebGLConstants","IndexDatatype","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","getSizeInBytes","indexDatatype","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","fromSizeInBytes","sizeInBytes","validate","createTypedArray","numberOfVertices","indicesLengthOrArray","SIXTY_FOUR_KILOBYTES","createTypedArrayFromArrayBuffer","sourceArray","byteOffset","length","fromTypedArray","array","Object","freeze"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/IndexDatatype.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {number}\n */\nconst IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {number} The size in bytes.\n *\n * @example\n * // Returns 2\n * const size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"indexDatatype is required and must be a valid IndexDatatype constant.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"Size in bytes cannot be mapped to an IndexDatatype\",\n      );\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    defined(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {number} numberOfVertices Number of vertices that the indices will reference.\n * @param {number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {number} byteOffset Passed through to the typed array constructor.\n * @param {number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\n\n/**\n * Gets the {@link IndexDatatype} for the provided TypedArray instance.\n *\n * @param {Uint8Array|Uint16Array|Uint32Array} array The typed array.\n * @returns {IndexDatatype} The IndexDatatype for the provided array, or undefined if the array is not a Uint8Array, Uint16Array, or Uint32Array.\n */\nIndexDatatype.fromTypedArray = function (array) {\n  if (array instanceof Uint8Array) {\n    return IndexDatatype.UNSIGNED_BYTE;\n  }\n  if (array instanceof Uint16Array) {\n    return IndexDatatype.UNSIGNED_SHORT;\n  }\n  if (array instanceof Uint32Array) {\n    return IndexDatatype.UNSIGNED_INT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"array must be a Uint8Array, Uint16Array, or Uint32Array.\",\n  );\n  //>>includeEnd('debug');\n};\n\nexport default Object.freeze(IndexDatatype);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}