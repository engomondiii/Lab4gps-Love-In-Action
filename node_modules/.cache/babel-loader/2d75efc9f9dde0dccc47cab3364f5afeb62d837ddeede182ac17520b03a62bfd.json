{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that linearly interpolates over an array of weight values used by morph targets.\n *\n * @alias MorphWeightSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {number[]} options.weights The array of floating-point control weights given. The weights are ordered such\n *                that all weights for the targets are given in chronological order and order in which they appear in\n *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]\n *                where i and j in w(i,j) are the time indices and target indices, respectively.\n *\n * @exception {DeveloperError} weights.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be a factor of weights.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * const spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n */\nfunction MorphWeightSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const weights = options.weights;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"weights\", weights);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"weights.length\", weights.length, 3);\n  if (weights.length % times.length !== 0) {\n    throw new DeveloperError(\"times.length must be a factor of weights.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._weights = weights;\n  this._count = weights.length / times.length;\n  this._lastTimeIndex = 0;\n}\nObject.defineProperties(MorphWeightSpline.prototype, {\n  /**\n   * An array of times for the control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n  /**\n   * An array of floating-point array control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  weights: {\n    get: function () {\n      return this._weights;\n    }\n  }\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nMorphWeightSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nMorphWeightSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nMorphWeightSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {number[]} [result] The object onto which to store the result.\n * @returns {number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nMorphWeightSpline.prototype.evaluate = function (time, result) {\n  const weights = this.weights;\n  const times = this.times;\n  const i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n  if (!defined(result)) {\n    result = new Array(this._count);\n  }\n  for (let j = 0; j < this._count; j++) {\n    const index = i * this._count + j;\n    result[j] = weights[index] * (1.0 - u) + weights[index + this._count] * u;\n  }\n  return result;\n};\nexport default MorphWeightSpline;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","Spline","MorphWeightSpline","options","EMPTY_OBJECT","weights","times","typeOf","number","greaterThanOrEquals","length","_times","_weights","_count","_lastTimeIndex","Object","defineProperties","prototype","get","findTimeInterval","wrapTime","clampTime","evaluate","time","result","i","u","Array","j","index"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/MorphWeightSpline.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that linearly interpolates over an array of weight values used by morph targets.\n *\n * @alias MorphWeightSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {number[]} options.weights The array of floating-point control weights given. The weights are ordered such\n *                that all weights for the targets are given in chronological order and order in which they appear in\n *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]\n *                where i and j in w(i,j) are the time indices and target indices, respectively.\n *\n * @exception {DeveloperError} weights.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be a factor of weights.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * const spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n */\nfunction MorphWeightSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const weights = options.weights;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"weights\", weights);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"weights.length\", weights.length, 3);\n  if (weights.length % times.length !== 0) {\n    throw new DeveloperError(\n      \"times.length must be a factor of weights.length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._weights = weights;\n  this._count = weights.length / times.length;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(MorphWeightSpline.prototype, {\n  /**\n   * An array of times for the control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of floating-point array control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  weights: {\n    get: function () {\n      return this._weights;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nMorphWeightSpline.prototype.findTimeInterval =\n  Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nMorphWeightSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nMorphWeightSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {number[]} [result] The object onto which to store the result.\n * @returns {number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nMorphWeightSpline.prototype.evaluate = function (time, result) {\n  const weights = this.weights;\n  const times = this.times;\n\n  const i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex,\n  ));\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  if (!defined(result)) {\n    result = new Array(this._count);\n  }\n\n  for (let j = 0; j < this._count; j++) {\n    const index = i * this._count + j;\n    result[j] = weights[index] * (1.0 - u) + weights[index + this._count] * u;\n  }\n\n  return result;\n};\nexport default MorphWeightSpline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}