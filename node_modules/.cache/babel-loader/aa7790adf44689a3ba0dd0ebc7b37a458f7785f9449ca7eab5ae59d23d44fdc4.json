{"ast":null,"code":"import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Plane from \"../Core/Plane.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\n\n/**\n * Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the\n * outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.\n * <p>\n * In general the clipping planes' coordinates are relative to the object they're attached to, so a plane with distance set to 0 will clip\n * through the center of the object.\n * </p>\n * <p>\n * For 3D Tiles, the root tile's transform is used to position the clipping planes. If a transform is not defined, the root tile's {@link Cesium3DTile#boundingSphere} is used instead.\n * </p>\n *\n * @alias ClippingPlaneCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.\n * @param {boolean} [options.enabled=true] Determines whether the clipping planes are active.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.\n * @param {boolean} [options.unionClippingRegions=false] If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.\n * @param {Color} [options.edgeColor=Color.WHITE] The color applied to highlight the edge along which an object is clipped.\n * @param {number} [options.edgeWidth=0.0] The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n *\n * @demo {@link https://sandcastle.cesium.com/?src=3D%20Tiles%20Clipping%20Planes.html|Clipping 3D Tiles and glTF models.}\n * @demo {@link https://sandcastle.cesium.com/?src=Terrain%20Clipping%20Planes.html|Clipping the Globe.}\n *\n * @example\n * // This clipping plane's distance is positive, which means its normal\n * // is facing the origin. This will clip everything that is behind\n * // the plane, which is anything with y coordinate < -5.\n * const clippingPlanes = new Cesium.ClippingPlaneCollection({\n *     planes : [\n *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)\n *     ],\n * });\n * // Create an entity and attach the ClippingPlaneCollection to the model.\n * const entity = viewer.entities.add({\n *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),\n *     model : {\n *         uri : 'model.gltf',\n *         minimumPixelSize : 128,\n *         maximumScale : 20000,\n *         clippingPlanes : clippingPlanes\n *     }\n * });\n * viewer.zoomTo(entity);\n */\nfunction ClippingPlaneCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._planes = [];\n\n  // Do partial texture updates if just one plane is dirty.\n  // If many planes are dirty, refresh the entire texture.\n  this._dirtyIndex = -1;\n  this._multipleDirtyPlanes = false;\n  this._enabled = defaultValue(options.enabled, true);\n\n  /**\n   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes\n   * original coordinate system.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n\n  /**\n   * The color applied to highlight the edge along which an object is clipped.\n   *\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.edgeColor = Color.clone(defaultValue(options.edgeColor, Color.WHITE));\n\n  /**\n   * The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.edgeWidth = defaultValue(options.edgeWidth, 0.0);\n\n  /**\n   * An event triggered when a new clipping plane is added to the collection.  Event handlers\n   * are passed the new plane and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.planeAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping plane is removed from the collection.  Event handlers\n   * are passed the new plane and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.planeRemoved = new Event();\n\n  // If this ClippingPlaneCollection has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference the tileset's ClippingPlaneCollection.\n  this._owner = undefined;\n  const unionClippingRegions = defaultValue(options.unionClippingRegions, false);\n  this._unionClippingRegions = unionClippingRegions;\n  this._testIntersection = unionClippingRegions ? unionIntersectFunction : defaultIntersectFunction;\n  this._uint8View = undefined;\n  this._float32View = undefined;\n  this._clippingPlanesTexture = undefined;\n\n  // Add each ClippingPlane object.\n  const planes = options.planes;\n  if (defined(planes)) {\n    const planesLength = planes.length;\n    for (let i = 0; i < planesLength; ++i) {\n      this.add(planes[i]);\n    }\n  }\n}\nfunction unionIntersectFunction(value) {\n  return value === Intersect.OUTSIDE;\n}\nfunction defaultIntersectFunction(value) {\n  return value === Intersect.INSIDE;\n}\nObject.defineProperties(ClippingPlaneCollection.prototype, {\n  /**\n   * Returns the number of planes in this collection.  This is commonly used with\n   * {@link ClippingPlaneCollection#get} to iterate over all the planes\n   * in the collection.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._planes.length;\n    }\n  },\n  /**\n   * If true, a region will be clipped if it is on the outside of any plane in the\n   * collection. Otherwise, a region will only be clipped if it is on the\n   * outside of every plane.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {boolean}\n   * @default false\n   */\n  unionClippingRegions: {\n    get: function () {\n      return this._unionClippingRegions;\n    },\n    set: function (value) {\n      if (this._unionClippingRegions === value) {\n        return;\n      }\n      this._unionClippingRegions = value;\n      this._testIntersection = value ? unionIntersectFunction : defaultIntersectFunction;\n    }\n  },\n  /**\n   * If true, clipping will be enabled.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      if (this._enabled === value) {\n        return;\n      }\n      this._enabled = value;\n    }\n  },\n  /**\n   * Returns a texture containing packed, untransformed clipping planes.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._clippingPlanesTexture;\n    }\n  },\n  /**\n   * A reference to the ClippingPlaneCollection's owner, if any.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  },\n  /**\n   * Returns a Number encapsulating the state for this ClippingPlaneCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the plane count.\n   * If this value changes, then shader regeneration is necessary.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @returns {number} A Number that describes the ClippingPlaneCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPlanesState: {\n    get: function () {\n      return this._unionClippingRegions ? this._planes.length : -this._planes.length;\n    }\n  }\n});\nfunction setIndexDirty(collection, index) {\n  // If there's already a different _dirtyIndex set, more than one plane has changed since update.\n  // Entire texture must be reloaded\n  collection._multipleDirtyPlanes = collection._multipleDirtyPlanes || collection._dirtyIndex !== -1 && collection._dirtyIndex !== index;\n  collection._dirtyIndex = index;\n}\n\n/**\n * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering\n * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple planes.\n *\n * @param {ClippingPlane} plane The ClippingPlane to add to the collection.\n *\n * @see ClippingPlaneCollection#unionClippingRegions\n * @see ClippingPlaneCollection#remove\n * @see ClippingPlaneCollection#removeAll\n */\nClippingPlaneCollection.prototype.add = function (plane) {\n  const newPlaneIndex = this._planes.length;\n  const that = this;\n  plane.onChangeCallback = function (index) {\n    setIndexDirty(that, index);\n  };\n  plane.index = newPlaneIndex;\n  setIndexDirty(this, newPlaneIndex);\n  this._planes.push(plane);\n  this.planeAdded.raiseEvent(plane, newPlaneIndex);\n};\n\n/**\n * Returns the plane in the collection at the specified index.  Indices are zero-based\n * and increase as planes are added.  Removing a plane shifts all planes after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link ClippingPlaneCollection#length} to iterate over all the planes\n * in the collection.\n *\n * @param {number} index The zero-based index of the plane.\n * @returns {ClippingPlane} The ClippingPlane at the specified index.\n *\n * @see ClippingPlaneCollection#length\n */\nClippingPlaneCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._planes[index];\n};\nfunction indexOf(planes, plane) {\n  const length = planes.length;\n  for (let i = 0; i < length; ++i) {\n    if (Plane.equals(planes[i], plane)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.\n *\n * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.\n * @returns {boolean} true if this collection contains the ClippingPlane, false otherwise.\n *\n * @see ClippingPlaneCollection#get\n */\nClippingPlaneCollection.prototype.contains = function (clippingPlane) {\n  return indexOf(this._planes, clippingPlane) !== -1;\n};\n\n/**\n * Removes the first occurrence of the given ClippingPlane from the collection.\n *\n * @param {ClippingPlane} clippingPlane\n * @returns {boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#contains\n * @see ClippingPlaneCollection#removeAll\n */\nClippingPlaneCollection.prototype.remove = function (clippingPlane) {\n  const planes = this._planes;\n  const index = indexOf(planes, clippingPlane);\n  if (index === -1) {\n    return false;\n  }\n\n  // Unlink this ClippingPlaneCollection from the ClippingPlane\n  if (clippingPlane instanceof ClippingPlane) {\n    clippingPlane.onChangeCallback = undefined;\n    clippingPlane.index = -1;\n  }\n\n  // Shift and update indices\n  const length = planes.length - 1;\n  for (let i = index; i < length; ++i) {\n    const planeToKeep = planes[i + 1];\n    planes[i] = planeToKeep;\n    if (planeToKeep instanceof ClippingPlane) {\n      planeToKeep.index = i;\n    }\n  }\n\n  // Indicate planes texture is dirty\n  this._multipleDirtyPlanes = true;\n  planes.length = length;\n  this.planeRemoved.raiseEvent(clippingPlane, index);\n  return true;\n};\n\n/**\n * Removes all planes from the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#remove\n */\nClippingPlaneCollection.prototype.removeAll = function () {\n  // Dereference this ClippingPlaneCollection from all ClippingPlanes\n  const planes = this._planes;\n  const planesCount = planes.length;\n  for (let i = 0; i < planesCount; ++i) {\n    const plane = planes[i];\n    if (plane instanceof ClippingPlane) {\n      plane.onChangeCallback = undefined;\n      plane.index = -1;\n    }\n    this.planeRemoved.raiseEvent(plane, i);\n  }\n  this._multipleDirtyPlanes = true;\n  this._planes = [];\n};\nconst distanceEncodeScratch = new Cartesian4();\nconst oct32EncodeScratch = new Cartesian4();\nfunction packPlanesAsUint8(clippingPlaneCollection, startIndex, endIndex) {\n  const uint8View = clippingPlaneCollection._uint8View;\n  const planes = clippingPlaneCollection._planes;\n  let byteIndex = 0;\n  for (let i = startIndex; i < endIndex; ++i) {\n    const plane = planes[i];\n    const oct32Normal = AttributeCompression.octEncodeToCartesian4(plane.normal, oct32EncodeScratch);\n    uint8View[byteIndex] = oct32Normal.x;\n    uint8View[byteIndex + 1] = oct32Normal.y;\n    uint8View[byteIndex + 2] = oct32Normal.z;\n    uint8View[byteIndex + 3] = oct32Normal.w;\n    const encodedDistance = Cartesian4.packFloat(plane.distance, distanceEncodeScratch);\n    uint8View[byteIndex + 4] = encodedDistance.x;\n    uint8View[byteIndex + 5] = encodedDistance.y;\n    uint8View[byteIndex + 6] = encodedDistance.z;\n    uint8View[byteIndex + 7] = encodedDistance.w;\n    byteIndex += 8;\n  }\n}\n\n// Pack starting at the beginning of the buffer to allow partial update\nfunction packPlanesAsFloats(clippingPlaneCollection, startIndex, endIndex) {\n  const float32View = clippingPlaneCollection._float32View;\n  const planes = clippingPlaneCollection._planes;\n  let floatIndex = 0;\n  for (let i = startIndex; i < endIndex; ++i) {\n    const plane = planes[i];\n    const normal = plane.normal;\n    float32View[floatIndex] = normal.x;\n    float32View[floatIndex + 1] = normal.y;\n    float32View[floatIndex + 2] = normal.z;\n    float32View[floatIndex + 3] = plane.distance;\n    floatIndex += 4; // each plane is 4 floats\n  }\n}\nfunction computeTextureResolution(pixelsNeeded, result) {\n  const maxSize = ContextLimits.maximumTextureSize;\n  result.x = Math.min(pixelsNeeded, maxSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n  return result;\n}\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping planes.\n * <p>\n * Do not call this function directly.\n * </p>\n */\nClippingPlaneCollection.prototype.update = function (frameState) {\n  let clippingPlanesTexture = this._clippingPlanesTexture;\n  const context = frameState.context;\n  const useFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n\n  // Compute texture requirements for current planes\n  // In RGBA FLOAT, A plane is 4 floats packed to a RGBA.\n  // In RGBA UNSIGNED_BYTE, A plane is a float in [0, 1) packed to RGBA and an Oct32 quantized normal,\n  // so 8 bits or 2 pixels in RGBA.\n  const pixelsNeeded = useFloatTexture ? this.length : this.length * 2;\n  if (defined(clippingPlanesTexture)) {\n    const currentPixelCount = clippingPlanesTexture.width * clippingPlanesTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (currentPixelCount < pixelsNeeded || pixelsNeeded < 0.25 * currentPixelCount) {\n      clippingPlanesTexture.destroy();\n      clippingPlanesTexture = undefined;\n      this._clippingPlanesTexture = undefined;\n    }\n  }\n\n  // If there are no clipping planes, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n  if (!defined(clippingPlanesTexture)) {\n    const requiredResolution = computeTextureResolution(pixelsNeeded, textureResolutionScratch);\n    // Allocate twice as much space as needed to avoid frequent texture reallocation.\n    // Allocate in the Y direction, since texture may be as wide as context texture support.\n    requiredResolution.y *= 2;\n    if (useFloatTexture) {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.FLOAT,\n        sampler: Sampler.NEAREST,\n        flipY: false\n      });\n      this._float32View = new Float32Array(requiredResolution.x * requiredResolution.y * 4);\n    } else {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        sampler: Sampler.NEAREST,\n        flipY: false\n      });\n      this._uint8View = new Uint8Array(requiredResolution.x * requiredResolution.y * 4);\n    }\n    this._clippingPlanesTexture = clippingPlanesTexture;\n    this._multipleDirtyPlanes = true;\n  }\n  const dirtyIndex = this._dirtyIndex;\n  if (!this._multipleDirtyPlanes && dirtyIndex === -1) {\n    return;\n  }\n  if (!this._multipleDirtyPlanes) {\n    // partial updates possible\n    let offsetX = 0;\n    let offsetY = 0;\n    if (useFloatTexture) {\n      offsetY = Math.floor(dirtyIndex / clippingPlanesTexture.width);\n      offsetX = Math.floor(dirtyIndex - offsetY * clippingPlanesTexture.width);\n      packPlanesAsFloats(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom({\n        source: {\n          width: 1,\n          height: 1,\n          arrayBufferView: this._float32View\n        },\n        xOffset: offsetX,\n        yOffset: offsetY\n      });\n    } else {\n      offsetY = Math.floor(dirtyIndex * 2 / clippingPlanesTexture.width);\n      offsetX = Math.floor(dirtyIndex * 2 - offsetY * clippingPlanesTexture.width);\n      packPlanesAsUint8(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom({\n        source: {\n          width: 2,\n          height: 1,\n          arrayBufferView: this._uint8View\n        },\n        xOffset: offsetX,\n        yOffset: offsetY\n      });\n    }\n  } else if (useFloatTexture) {\n    packPlanesAsFloats(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      source: {\n        width: clippingPlanesTexture.width,\n        height: clippingPlanesTexture.height,\n        arrayBufferView: this._float32View\n      }\n    });\n  } else {\n    packPlanesAsUint8(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      source: {\n        width: clippingPlanesTexture.width,\n        height: clippingPlanesTexture.height,\n        arrayBufferView: this._uint8View\n      }\n    });\n  }\n  this._multipleDirtyPlanes = false;\n  this._dirtyIndex = -1;\n};\nconst scratchMatrix = new Matrix4();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Determines the type intersection with the planes of this ClippingPlaneCollection instance and the specified {@link TileBoundingVolume}.\n * @private\n *\n * @param {object} tileBoundingVolume The volume to determine the intersection with the planes.\n * @param {Matrix4} [transform] An optional, additional matrix to transform the plane to world coordinates.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the planes\n *                      the normal is pointing and should be entirely rendered, {@link Intersect.OUTSIDE}\n *                      if the entire volume is on the opposite side and should be clipped, and\n *                      {@link Intersect.INTERSECTING} if the volume intersects the planes.\n */\nClippingPlaneCollection.prototype.computeIntersectionWithBoundingVolume = function (tileBoundingVolume, transform) {\n  const planes = this._planes;\n  const length = planes.length;\n  let modelMatrix = this.modelMatrix;\n  if (defined(transform)) {\n    modelMatrix = Matrix4.multiply(transform, modelMatrix, scratchMatrix);\n  }\n\n  // If the collection is not set to union the clipping regions, the volume must be outside of all planes to be\n  // considered completely clipped. If the collection is set to union the clipping regions, if the volume can be\n  // outside any the planes, it is considered completely clipped.\n  // Lastly, if not completely clipped, if any plane is intersecting, more calculations must be performed.\n  let intersection = Intersect.INSIDE;\n  if (!this.unionClippingRegions && length > 0) {\n    intersection = Intersect.OUTSIDE;\n  }\n  for (let i = 0; i < length; ++i) {\n    const plane = planes[i];\n    Plane.transform(plane, modelMatrix, scratchPlane); // ClippingPlane can be used for Plane math\n\n    const value = tileBoundingVolume.intersectPlane(scratchPlane);\n    if (value === Intersect.INTERSECTING) {\n      intersection = value;\n    } else if (this._testIntersection(value)) {\n      return value;\n    }\n  }\n  return intersection;\n};\n\n/**\n * Sets the owner for the input ClippingPlaneCollection if there wasn't another owner.\n * Destroys the owner's previous ClippingPlaneCollection if setting is successful.\n *\n * @param {ClippingPlaneCollection} [clippingPlaneCollection] A ClippingPlaneCollection (or undefined) being attached to an object\n * @param {object} owner An Object that should receive the new ClippingPlaneCollection\n * @param {string} key The Key for the Object to reference the ClippingPlaneCollection\n * @private\n */\nClippingPlaneCollection.setOwner = function (clippingPlaneCollection, owner, key) {\n  // Don't destroy the ClippingPlaneCollection if it is already owned by newOwner\n  if (clippingPlaneCollection === owner[key]) {\n    return;\n  }\n  // Destroy the existing ClippingPlaneCollection, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(clippingPlaneCollection)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(clippingPlaneCollection._owner)) {\n      throw new DeveloperError(\"ClippingPlaneCollection should only be assigned to one object\");\n    }\n    //>>includeEnd('debug');\n    clippingPlaneCollection._owner = owner;\n    owner[key] = clippingPlaneCollection;\n  }\n};\n\n/**\n * Function for checking if the context will allow clipping planes with floating point textures.\n *\n * @param {Context} context The Context that will contain clipped objects and clipping textures.\n * @returns {boolean} <code>true</code> if floating point textures can be used for clipping planes.\n * @private\n */\nClippingPlaneCollection.useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n\n/**\n * Function for getting the clipping plane collection's texture resolution.\n * If the ClippingPlaneCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current plane count.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection The clipping plane collection\n * @param {Context} context The rendering context\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPlaneCollection.getTextureResolution = function (clippingPlaneCollection, context, result) {\n  const texture = clippingPlaneCollection.texture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n  const pixelsNeeded = ClippingPlaneCollection.useFloatTexture(context) ? clippingPlaneCollection.length : clippingPlaneCollection.length * 2;\n  const requiredResolution = computeTextureResolution(pixelsNeeded, result);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  requiredResolution.y *= 2;\n  return requiredResolution;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClippingPlaneCollection#destroy\n */\nClippingPlaneCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * clippingPlanes = clippingPlanes && clippingPlanes.destroy();\n *\n * @see ClippingPlaneCollection#isDestroyed\n */\nClippingPlaneCollection.prototype.destroy = function () {\n  this._clippingPlanesTexture = this._clippingPlanesTexture && this._clippingPlanesTexture.destroy();\n  return destroyObject(this);\n};\nexport default ClippingPlaneCollection;","map":{"version":3,"names":["AttributeCompression","Cartesian2","Cartesian3","Cartesian4","Check","Color","defaultValue","defined","destroyObject","DeveloperError","Event","Intersect","Matrix4","PixelFormat","Plane","ContextLimits","PixelDatatype","Sampler","Texture","ClippingPlane","ClippingPlaneCollection","options","EMPTY_OBJECT","_planes","_dirtyIndex","_multipleDirtyPlanes","_enabled","enabled","modelMatrix","clone","IDENTITY","edgeColor","WHITE","edgeWidth","planeAdded","planeRemoved","_owner","undefined","unionClippingRegions","_unionClippingRegions","_testIntersection","unionIntersectFunction","defaultIntersectFunction","_uint8View","_float32View","_clippingPlanesTexture","planes","planesLength","length","i","add","value","OUTSIDE","INSIDE","Object","defineProperties","prototype","get","set","texture","owner","clippingPlanesState","setIndexDirty","collection","index","plane","newPlaneIndex","that","onChangeCallback","push","raiseEvent","typeOf","number","indexOf","equals","contains","clippingPlane","remove","planeToKeep","removeAll","planesCount","distanceEncodeScratch","oct32EncodeScratch","packPlanesAsUint8","clippingPlaneCollection","startIndex","endIndex","uint8View","byteIndex","oct32Normal","octEncodeToCartesian4","normal","x","y","z","w","encodedDistance","packFloat","distance","packPlanesAsFloats","float32View","floatIndex","computeTextureResolution","pixelsNeeded","result","maxSize","maximumTextureSize","Math","min","ceil","textureResolutionScratch","update","frameState","clippingPlanesTexture","context","useFloatTexture","currentPixelCount","width","height","destroy","requiredResolution","pixelFormat","RGBA","pixelDatatype","FLOAT","sampler","NEAREST","flipY","Float32Array","UNSIGNED_BYTE","Uint8Array","dirtyIndex","offsetX","offsetY","floor","copyFrom","source","arrayBufferView","xOffset","yOffset","scratchMatrix","scratchPlane","UNIT_X","computeIntersectionWithBoundingVolume","tileBoundingVolume","transform","multiply","intersection","intersectPlane","INTERSECTING","setOwner","key","floatingPointTexture","getTextureResolution","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ClippingPlaneCollection.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Plane from \"../Core/Plane.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\n\n/**\n * Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the\n * outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.\n * <p>\n * In general the clipping planes' coordinates are relative to the object they're attached to, so a plane with distance set to 0 will clip\n * through the center of the object.\n * </p>\n * <p>\n * For 3D Tiles, the root tile's transform is used to position the clipping planes. If a transform is not defined, the root tile's {@link Cesium3DTile#boundingSphere} is used instead.\n * </p>\n *\n * @alias ClippingPlaneCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.\n * @param {boolean} [options.enabled=true] Determines whether the clipping planes are active.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.\n * @param {boolean} [options.unionClippingRegions=false] If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.\n * @param {Color} [options.edgeColor=Color.WHITE] The color applied to highlight the edge along which an object is clipped.\n * @param {number} [options.edgeWidth=0.0] The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n *\n * @demo {@link https://sandcastle.cesium.com/?src=3D%20Tiles%20Clipping%20Planes.html|Clipping 3D Tiles and glTF models.}\n * @demo {@link https://sandcastle.cesium.com/?src=Terrain%20Clipping%20Planes.html|Clipping the Globe.}\n *\n * @example\n * // This clipping plane's distance is positive, which means its normal\n * // is facing the origin. This will clip everything that is behind\n * // the plane, which is anything with y coordinate < -5.\n * const clippingPlanes = new Cesium.ClippingPlaneCollection({\n *     planes : [\n *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)\n *     ],\n * });\n * // Create an entity and attach the ClippingPlaneCollection to the model.\n * const entity = viewer.entities.add({\n *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),\n *     model : {\n *         uri : 'model.gltf',\n *         minimumPixelSize : 128,\n *         maximumScale : 20000,\n *         clippingPlanes : clippingPlanes\n *     }\n * });\n * viewer.zoomTo(entity);\n */\nfunction ClippingPlaneCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._planes = [];\n\n  // Do partial texture updates if just one plane is dirty.\n  // If many planes are dirty, refresh the entire texture.\n  this._dirtyIndex = -1;\n  this._multipleDirtyPlanes = false;\n\n  this._enabled = defaultValue(options.enabled, true);\n\n  /**\n   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes\n   * original coordinate system.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n\n  /**\n   * The color applied to highlight the edge along which an object is clipped.\n   *\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.edgeColor = Color.clone(defaultValue(options.edgeColor, Color.WHITE));\n\n  /**\n   * The width, in pixels, of the highlight applied to the edge along which an object is clipped.\n   *\n   * @type {number}\n   * @default 0.0\n   */\n  this.edgeWidth = defaultValue(options.edgeWidth, 0.0);\n\n  /**\n   * An event triggered when a new clipping plane is added to the collection.  Event handlers\n   * are passed the new plane and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.planeAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping plane is removed from the collection.  Event handlers\n   * are passed the new plane and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.planeRemoved = new Event();\n\n  // If this ClippingPlaneCollection has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference the tileset's ClippingPlaneCollection.\n  this._owner = undefined;\n\n  const unionClippingRegions = defaultValue(\n    options.unionClippingRegions,\n    false,\n  );\n  this._unionClippingRegions = unionClippingRegions;\n  this._testIntersection = unionClippingRegions\n    ? unionIntersectFunction\n    : defaultIntersectFunction;\n\n  this._uint8View = undefined;\n  this._float32View = undefined;\n\n  this._clippingPlanesTexture = undefined;\n\n  // Add each ClippingPlane object.\n  const planes = options.planes;\n  if (defined(planes)) {\n    const planesLength = planes.length;\n    for (let i = 0; i < planesLength; ++i) {\n      this.add(planes[i]);\n    }\n  }\n}\n\nfunction unionIntersectFunction(value) {\n  return value === Intersect.OUTSIDE;\n}\n\nfunction defaultIntersectFunction(value) {\n  return value === Intersect.INSIDE;\n}\n\nObject.defineProperties(ClippingPlaneCollection.prototype, {\n  /**\n   * Returns the number of planes in this collection.  This is commonly used with\n   * {@link ClippingPlaneCollection#get} to iterate over all the planes\n   * in the collection.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._planes.length;\n    },\n  },\n\n  /**\n   * If true, a region will be clipped if it is on the outside of any plane in the\n   * collection. Otherwise, a region will only be clipped if it is on the\n   * outside of every plane.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {boolean}\n   * @default false\n   */\n  unionClippingRegions: {\n    get: function () {\n      return this._unionClippingRegions;\n    },\n    set: function (value) {\n      if (this._unionClippingRegions === value) {\n        return;\n      }\n      this._unionClippingRegions = value;\n      this._testIntersection = value\n        ? unionIntersectFunction\n        : defaultIntersectFunction;\n    },\n  },\n\n  /**\n   * If true, clipping will be enabled.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      if (this._enabled === value) {\n        return;\n      }\n      this._enabled = value;\n    },\n  },\n\n  /**\n   * Returns a texture containing packed, untransformed clipping planes.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._clippingPlanesTexture;\n    },\n  },\n\n  /**\n   * A reference to the ClippingPlaneCollection's owner, if any.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n\n  /**\n   * Returns a Number encapsulating the state for this ClippingPlaneCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the plane count.\n   * If this value changes, then shader regeneration is necessary.\n   *\n   * @memberof ClippingPlaneCollection.prototype\n   * @returns {number} A Number that describes the ClippingPlaneCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPlanesState: {\n    get: function () {\n      return this._unionClippingRegions\n        ? this._planes.length\n        : -this._planes.length;\n    },\n  },\n});\n\nfunction setIndexDirty(collection, index) {\n  // If there's already a different _dirtyIndex set, more than one plane has changed since update.\n  // Entire texture must be reloaded\n  collection._multipleDirtyPlanes =\n    collection._multipleDirtyPlanes ||\n    (collection._dirtyIndex !== -1 && collection._dirtyIndex !== index);\n  collection._dirtyIndex = index;\n}\n\n/**\n * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering\n * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple planes.\n *\n * @param {ClippingPlane} plane The ClippingPlane to add to the collection.\n *\n * @see ClippingPlaneCollection#unionClippingRegions\n * @see ClippingPlaneCollection#remove\n * @see ClippingPlaneCollection#removeAll\n */\nClippingPlaneCollection.prototype.add = function (plane) {\n  const newPlaneIndex = this._planes.length;\n\n  const that = this;\n  plane.onChangeCallback = function (index) {\n    setIndexDirty(that, index);\n  };\n  plane.index = newPlaneIndex;\n\n  setIndexDirty(this, newPlaneIndex);\n  this._planes.push(plane);\n  this.planeAdded.raiseEvent(plane, newPlaneIndex);\n};\n\n/**\n * Returns the plane in the collection at the specified index.  Indices are zero-based\n * and increase as planes are added.  Removing a plane shifts all planes after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link ClippingPlaneCollection#length} to iterate over all the planes\n * in the collection.\n *\n * @param {number} index The zero-based index of the plane.\n * @returns {ClippingPlane} The ClippingPlane at the specified index.\n *\n * @see ClippingPlaneCollection#length\n */\nClippingPlaneCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._planes[index];\n};\n\nfunction indexOf(planes, plane) {\n  const length = planes.length;\n  for (let i = 0; i < length; ++i) {\n    if (Plane.equals(planes[i], plane)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.\n *\n * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.\n * @returns {boolean} true if this collection contains the ClippingPlane, false otherwise.\n *\n * @see ClippingPlaneCollection#get\n */\nClippingPlaneCollection.prototype.contains = function (clippingPlane) {\n  return indexOf(this._planes, clippingPlane) !== -1;\n};\n\n/**\n * Removes the first occurrence of the given ClippingPlane from the collection.\n *\n * @param {ClippingPlane} clippingPlane\n * @returns {boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#contains\n * @see ClippingPlaneCollection#removeAll\n */\nClippingPlaneCollection.prototype.remove = function (clippingPlane) {\n  const planes = this._planes;\n  const index = indexOf(planes, clippingPlane);\n\n  if (index === -1) {\n    return false;\n  }\n\n  // Unlink this ClippingPlaneCollection from the ClippingPlane\n  if (clippingPlane instanceof ClippingPlane) {\n    clippingPlane.onChangeCallback = undefined;\n    clippingPlane.index = -1;\n  }\n\n  // Shift and update indices\n  const length = planes.length - 1;\n  for (let i = index; i < length; ++i) {\n    const planeToKeep = planes[i + 1];\n    planes[i] = planeToKeep;\n    if (planeToKeep instanceof ClippingPlane) {\n      planeToKeep.index = i;\n    }\n  }\n\n  // Indicate planes texture is dirty\n  this._multipleDirtyPlanes = true;\n  planes.length = length;\n\n  this.planeRemoved.raiseEvent(clippingPlane, index);\n\n  return true;\n};\n\n/**\n * Removes all planes from the collection.\n *\n * @see ClippingPlaneCollection#add\n * @see ClippingPlaneCollection#remove\n */\nClippingPlaneCollection.prototype.removeAll = function () {\n  // Dereference this ClippingPlaneCollection from all ClippingPlanes\n  const planes = this._planes;\n  const planesCount = planes.length;\n  for (let i = 0; i < planesCount; ++i) {\n    const plane = planes[i];\n    if (plane instanceof ClippingPlane) {\n      plane.onChangeCallback = undefined;\n      plane.index = -1;\n    }\n    this.planeRemoved.raiseEvent(plane, i);\n  }\n  this._multipleDirtyPlanes = true;\n  this._planes = [];\n};\n\nconst distanceEncodeScratch = new Cartesian4();\nconst oct32EncodeScratch = new Cartesian4();\nfunction packPlanesAsUint8(clippingPlaneCollection, startIndex, endIndex) {\n  const uint8View = clippingPlaneCollection._uint8View;\n  const planes = clippingPlaneCollection._planes;\n  let byteIndex = 0;\n  for (let i = startIndex; i < endIndex; ++i) {\n    const plane = planes[i];\n\n    const oct32Normal = AttributeCompression.octEncodeToCartesian4(\n      plane.normal,\n      oct32EncodeScratch,\n    );\n    uint8View[byteIndex] = oct32Normal.x;\n    uint8View[byteIndex + 1] = oct32Normal.y;\n    uint8View[byteIndex + 2] = oct32Normal.z;\n    uint8View[byteIndex + 3] = oct32Normal.w;\n\n    const encodedDistance = Cartesian4.packFloat(\n      plane.distance,\n      distanceEncodeScratch,\n    );\n    uint8View[byteIndex + 4] = encodedDistance.x;\n    uint8View[byteIndex + 5] = encodedDistance.y;\n    uint8View[byteIndex + 6] = encodedDistance.z;\n    uint8View[byteIndex + 7] = encodedDistance.w;\n\n    byteIndex += 8;\n  }\n}\n\n// Pack starting at the beginning of the buffer to allow partial update\nfunction packPlanesAsFloats(clippingPlaneCollection, startIndex, endIndex) {\n  const float32View = clippingPlaneCollection._float32View;\n  const planes = clippingPlaneCollection._planes;\n\n  let floatIndex = 0;\n  for (let i = startIndex; i < endIndex; ++i) {\n    const plane = planes[i];\n    const normal = plane.normal;\n\n    float32View[floatIndex] = normal.x;\n    float32View[floatIndex + 1] = normal.y;\n    float32View[floatIndex + 2] = normal.z;\n    float32View[floatIndex + 3] = plane.distance;\n\n    floatIndex += 4; // each plane is 4 floats\n  }\n}\n\nfunction computeTextureResolution(pixelsNeeded, result) {\n  const maxSize = ContextLimits.maximumTextureSize;\n  result.x = Math.min(pixelsNeeded, maxSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n  return result;\n}\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping planes.\n * <p>\n * Do not call this function directly.\n * </p>\n */\nClippingPlaneCollection.prototype.update = function (frameState) {\n  let clippingPlanesTexture = this._clippingPlanesTexture;\n  const context = frameState.context;\n  const useFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n\n  // Compute texture requirements for current planes\n  // In RGBA FLOAT, A plane is 4 floats packed to a RGBA.\n  // In RGBA UNSIGNED_BYTE, A plane is a float in [0, 1) packed to RGBA and an Oct32 quantized normal,\n  // so 8 bits or 2 pixels in RGBA.\n  const pixelsNeeded = useFloatTexture ? this.length : this.length * 2;\n\n  if (defined(clippingPlanesTexture)) {\n    const currentPixelCount =\n      clippingPlanesTexture.width * clippingPlanesTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (\n      currentPixelCount < pixelsNeeded ||\n      pixelsNeeded < 0.25 * currentPixelCount\n    ) {\n      clippingPlanesTexture.destroy();\n      clippingPlanesTexture = undefined;\n      this._clippingPlanesTexture = undefined;\n    }\n  }\n\n  // If there are no clipping planes, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n\n  if (!defined(clippingPlanesTexture)) {\n    const requiredResolution = computeTextureResolution(\n      pixelsNeeded,\n      textureResolutionScratch,\n    );\n    // Allocate twice as much space as needed to avoid frequent texture reallocation.\n    // Allocate in the Y direction, since texture may be as wide as context texture support.\n    requiredResolution.y *= 2;\n\n    if (useFloatTexture) {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.FLOAT,\n        sampler: Sampler.NEAREST,\n        flipY: false,\n      });\n      this._float32View = new Float32Array(\n        requiredResolution.x * requiredResolution.y * 4,\n      );\n    } else {\n      clippingPlanesTexture = new Texture({\n        context: context,\n        width: requiredResolution.x,\n        height: requiredResolution.y,\n        pixelFormat: PixelFormat.RGBA,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        sampler: Sampler.NEAREST,\n        flipY: false,\n      });\n      this._uint8View = new Uint8Array(\n        requiredResolution.x * requiredResolution.y * 4,\n      );\n    }\n\n    this._clippingPlanesTexture = clippingPlanesTexture;\n    this._multipleDirtyPlanes = true;\n  }\n\n  const dirtyIndex = this._dirtyIndex;\n  if (!this._multipleDirtyPlanes && dirtyIndex === -1) {\n    return;\n  }\n  if (!this._multipleDirtyPlanes) {\n    // partial updates possible\n    let offsetX = 0;\n    let offsetY = 0;\n    if (useFloatTexture) {\n      offsetY = Math.floor(dirtyIndex / clippingPlanesTexture.width);\n      offsetX = Math.floor(dirtyIndex - offsetY * clippingPlanesTexture.width);\n\n      packPlanesAsFloats(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom({\n        source: {\n          width: 1,\n          height: 1,\n          arrayBufferView: this._float32View,\n        },\n        xOffset: offsetX,\n        yOffset: offsetY,\n      });\n    } else {\n      offsetY = Math.floor((dirtyIndex * 2) / clippingPlanesTexture.width);\n      offsetX = Math.floor(\n        dirtyIndex * 2 - offsetY * clippingPlanesTexture.width,\n      );\n      packPlanesAsUint8(this, dirtyIndex, dirtyIndex + 1);\n      clippingPlanesTexture.copyFrom({\n        source: {\n          width: 2,\n          height: 1,\n          arrayBufferView: this._uint8View,\n        },\n        xOffset: offsetX,\n        yOffset: offsetY,\n      });\n    }\n  } else if (useFloatTexture) {\n    packPlanesAsFloats(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      source: {\n        width: clippingPlanesTexture.width,\n        height: clippingPlanesTexture.height,\n        arrayBufferView: this._float32View,\n      },\n    });\n  } else {\n    packPlanesAsUint8(this, 0, this._planes.length);\n    clippingPlanesTexture.copyFrom({\n      source: {\n        width: clippingPlanesTexture.width,\n        height: clippingPlanesTexture.height,\n        arrayBufferView: this._uint8View,\n      },\n    });\n  }\n\n  this._multipleDirtyPlanes = false;\n  this._dirtyIndex = -1;\n};\n\nconst scratchMatrix = new Matrix4();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Determines the type intersection with the planes of this ClippingPlaneCollection instance and the specified {@link TileBoundingVolume}.\n * @private\n *\n * @param {object} tileBoundingVolume The volume to determine the intersection with the planes.\n * @param {Matrix4} [transform] An optional, additional matrix to transform the plane to world coordinates.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the planes\n *                      the normal is pointing and should be entirely rendered, {@link Intersect.OUTSIDE}\n *                      if the entire volume is on the opposite side and should be clipped, and\n *                      {@link Intersect.INTERSECTING} if the volume intersects the planes.\n */\nClippingPlaneCollection.prototype.computeIntersectionWithBoundingVolume =\n  function (tileBoundingVolume, transform) {\n    const planes = this._planes;\n    const length = planes.length;\n\n    let modelMatrix = this.modelMatrix;\n    if (defined(transform)) {\n      modelMatrix = Matrix4.multiply(transform, modelMatrix, scratchMatrix);\n    }\n\n    // If the collection is not set to union the clipping regions, the volume must be outside of all planes to be\n    // considered completely clipped. If the collection is set to union the clipping regions, if the volume can be\n    // outside any the planes, it is considered completely clipped.\n    // Lastly, if not completely clipped, if any plane is intersecting, more calculations must be performed.\n    let intersection = Intersect.INSIDE;\n    if (!this.unionClippingRegions && length > 0) {\n      intersection = Intersect.OUTSIDE;\n    }\n\n    for (let i = 0; i < length; ++i) {\n      const plane = planes[i];\n\n      Plane.transform(plane, modelMatrix, scratchPlane); // ClippingPlane can be used for Plane math\n\n      const value = tileBoundingVolume.intersectPlane(scratchPlane);\n      if (value === Intersect.INTERSECTING) {\n        intersection = value;\n      } else if (this._testIntersection(value)) {\n        return value;\n      }\n    }\n\n    return intersection;\n  };\n\n/**\n * Sets the owner for the input ClippingPlaneCollection if there wasn't another owner.\n * Destroys the owner's previous ClippingPlaneCollection if setting is successful.\n *\n * @param {ClippingPlaneCollection} [clippingPlaneCollection] A ClippingPlaneCollection (or undefined) being attached to an object\n * @param {object} owner An Object that should receive the new ClippingPlaneCollection\n * @param {string} key The Key for the Object to reference the ClippingPlaneCollection\n * @private\n */\nClippingPlaneCollection.setOwner = function (\n  clippingPlaneCollection,\n  owner,\n  key,\n) {\n  // Don't destroy the ClippingPlaneCollection if it is already owned by newOwner\n  if (clippingPlaneCollection === owner[key]) {\n    return;\n  }\n  // Destroy the existing ClippingPlaneCollection, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(clippingPlaneCollection)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(clippingPlaneCollection._owner)) {\n      throw new DeveloperError(\n        \"ClippingPlaneCollection should only be assigned to one object\",\n      );\n    }\n    //>>includeEnd('debug');\n    clippingPlaneCollection._owner = owner;\n    owner[key] = clippingPlaneCollection;\n  }\n};\n\n/**\n * Function for checking if the context will allow clipping planes with floating point textures.\n *\n * @param {Context} context The Context that will contain clipped objects and clipping textures.\n * @returns {boolean} <code>true</code> if floating point textures can be used for clipping planes.\n * @private\n */\nClippingPlaneCollection.useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n\n/**\n * Function for getting the clipping plane collection's texture resolution.\n * If the ClippingPlaneCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current plane count.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection The clipping plane collection\n * @param {Context} context The rendering context\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPlaneCollection.getTextureResolution = function (\n  clippingPlaneCollection,\n  context,\n  result,\n) {\n  const texture = clippingPlaneCollection.texture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  const pixelsNeeded = ClippingPlaneCollection.useFloatTexture(context)\n    ? clippingPlaneCollection.length\n    : clippingPlaneCollection.length * 2;\n  const requiredResolution = computeTextureResolution(pixelsNeeded, result);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  requiredResolution.y *= 2;\n  return requiredResolution;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClippingPlaneCollection#destroy\n */\nClippingPlaneCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * clippingPlanes = clippingPlanes && clippingPlanes.destroy();\n *\n * @see ClippingPlaneCollection#isDestroyed\n */\nClippingPlaneCollection.prototype.destroy = function () {\n  this._clippingPlanesTexture =\n    this._clippingPlanesTexture && this._clippingPlanesTexture.destroy();\n  return destroyObject(this);\n};\nexport default ClippingPlaneCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}