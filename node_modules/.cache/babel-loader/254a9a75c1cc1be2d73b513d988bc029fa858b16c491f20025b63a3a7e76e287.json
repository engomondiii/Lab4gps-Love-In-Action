{"ast":null,"code":"import clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Expression from \"./Expression.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates a conditions expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias ConditionsExpression\n * @constructor\n *\n * @param {object} [conditionsExpression] The conditions expression defined using the 3D Tiles Styling language.\n * @param {object} [defines] Defines in the style.\n *\n * @example\n * const expression = new Cesium.ConditionsExpression({\n *     conditions : [\n *         ['${Area} > 10, 'color(\"#FF0000\")'],\n *         ['${id} !== \"1\"', 'color(\"#00FF00\")'],\n *         ['true', 'color(\"#FFFFFF\")']\n *     ]\n * });\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\nfunction ConditionsExpression(conditionsExpression, defines) {\n  this._conditionsExpression = clone(conditionsExpression, true);\n  this._conditions = conditionsExpression.conditions;\n  this._runtimeConditions = undefined;\n  setRuntime(this, defines);\n}\nObject.defineProperties(ConditionsExpression.prototype, {\n  /**\n   * Gets the conditions expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof ConditionsExpression.prototype\n   *\n   * @type {object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  conditionsExpression: {\n    get: function () {\n      return this._conditionsExpression;\n    }\n  }\n});\nfunction Statement(condition, expression) {\n  this.condition = condition;\n  this.expression = expression;\n}\nfunction setRuntime(expression, defines) {\n  const runtimeConditions = [];\n  const conditions = expression._conditions;\n  if (!defined(conditions)) {\n    return;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    const cond = String(statement[0]);\n    const condExpression = String(statement[1]);\n    runtimeConditions.push(new Statement(new Expression(cond, defines), new Expression(condExpression, defines)));\n  }\n  expression._runtimeConditions = runtimeConditions;\n}\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {object} [result] The object onto which to store the result.\n * @returns {boolean|number|string|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nConditionsExpression.prototype.evaluate = function (feature, result) {\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions)) {\n    return undefined;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    if (statement.condition.evaluate(feature)) {\n      return statement.expression.evaluate(feature, result);\n    }\n  }\n};\n\n/**\n * Evaluates the result of a Color expression, using the values defined by a feature.\n * <p>\n * This is equivalent to {@link ConditionsExpression#evaluate} but always returns a {@link Color} object.\n * </p>\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nConditionsExpression.prototype.evaluateColor = function (feature, result) {\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions)) {\n    return undefined;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    if (statement.condition.evaluate(feature)) {\n      return statement.expression.evaluateColor(feature, result);\n    }\n  }\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {string} functionSignature Signature of the generated function.\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {string} returnType The return type of the generated function.\n *\n * @returns {string} The shader function.\n *\n * @private\n */\nConditionsExpression.prototype.getShaderFunction = function (functionSignature, variableSubstitutionMap, shaderState, returnType) {\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions) || conditions.length === 0) {\n    return undefined;\n  }\n  let shaderFunction = \"\";\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    const condition = statement.condition.getShaderExpression(variableSubstitutionMap, shaderState);\n    const expression = statement.expression.getShaderExpression(variableSubstitutionMap, shaderState);\n\n    // Build the if/else chain from the list of conditions\n    shaderFunction += `    ${i === 0 ? \"if\" : \"else if\"} (${condition})\\n` + `    {\\n` + `        return ${expression};\\n` + `    }\\n`;\n  }\n  shaderFunction = `${returnType} ${functionSignature}\\n` + `{\\n${shaderFunction}    return ${returnType}(1.0);\\n` +\n  // Return a default value if no conditions are met\n  `}\\n`;\n  return shaderFunction;\n};\n\n/**\n * Gets the variables used by the expression.\n *\n * @returns {string[]} The variables used by the expression.\n *\n * @private\n */\nConditionsExpression.prototype.getVariables = function () {\n  let variables = [];\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions) || conditions.length === 0) {\n    return variables;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    variables.push.apply(variables, statement.condition.getVariables());\n    variables.push.apply(variables, statement.expression.getVariables());\n  }\n\n  // Remove duplicates\n  variables = variables.filter(function (variable, index, variables) {\n    return variables.indexOf(variable) === index;\n  });\n  return variables;\n};\nexport default ConditionsExpression;","map":{"version":3,"names":["clone","defined","Expression","ConditionsExpression","conditionsExpression","defines","_conditionsExpression","_conditions","conditions","_runtimeConditions","undefined","setRuntime","Object","defineProperties","prototype","get","Statement","condition","expression","runtimeConditions","length","i","statement","cond","String","condExpression","push","evaluate","feature","result","evaluateColor","getShaderFunction","functionSignature","variableSubstitutionMap","shaderState","returnType","shaderFunction","getShaderExpression","getVariables","variables","apply","filter","variable","index","indexOf"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ConditionsExpression.js"],"sourcesContent":["import clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Expression from \"./Expression.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates a conditions expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias ConditionsExpression\n * @constructor\n *\n * @param {object} [conditionsExpression] The conditions expression defined using the 3D Tiles Styling language.\n * @param {object} [defines] Defines in the style.\n *\n * @example\n * const expression = new Cesium.ConditionsExpression({\n *     conditions : [\n *         ['${Area} > 10, 'color(\"#FF0000\")'],\n *         ['${id} !== \"1\"', 'color(\"#00FF00\")'],\n *         ['true', 'color(\"#FFFFFF\")']\n *     ]\n * });\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\nfunction ConditionsExpression(conditionsExpression, defines) {\n  this._conditionsExpression = clone(conditionsExpression, true);\n  this._conditions = conditionsExpression.conditions;\n  this._runtimeConditions = undefined;\n\n  setRuntime(this, defines);\n}\n\nObject.defineProperties(ConditionsExpression.prototype, {\n  /**\n   * Gets the conditions expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof ConditionsExpression.prototype\n   *\n   * @type {object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  conditionsExpression: {\n    get: function () {\n      return this._conditionsExpression;\n    },\n  },\n});\n\nfunction Statement(condition, expression) {\n  this.condition = condition;\n  this.expression = expression;\n}\n\nfunction setRuntime(expression, defines) {\n  const runtimeConditions = [];\n  const conditions = expression._conditions;\n  if (!defined(conditions)) {\n    return;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    const cond = String(statement[0]);\n    const condExpression = String(statement[1]);\n    runtimeConditions.push(\n      new Statement(\n        new Expression(cond, defines),\n        new Expression(condExpression, defines),\n      ),\n    );\n  }\n  expression._runtimeConditions = runtimeConditions;\n}\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {object} [result] The object onto which to store the result.\n * @returns {boolean|number|string|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nConditionsExpression.prototype.evaluate = function (feature, result) {\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions)) {\n    return undefined;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    if (statement.condition.evaluate(feature)) {\n      return statement.expression.evaluate(feature, result);\n    }\n  }\n};\n\n/**\n * Evaluates the result of a Color expression, using the values defined by a feature.\n * <p>\n * This is equivalent to {@link ConditionsExpression#evaluate} but always returns a {@link Color} object.\n * </p>\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nConditionsExpression.prototype.evaluateColor = function (feature, result) {\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions)) {\n    return undefined;\n  }\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    if (statement.condition.evaluate(feature)) {\n      return statement.expression.evaluateColor(feature, result);\n    }\n  }\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {string} functionSignature Signature of the generated function.\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {string} returnType The return type of the generated function.\n *\n * @returns {string} The shader function.\n *\n * @private\n */\nConditionsExpression.prototype.getShaderFunction = function (\n  functionSignature,\n  variableSubstitutionMap,\n  shaderState,\n  returnType,\n) {\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions) || conditions.length === 0) {\n    return undefined;\n  }\n\n  let shaderFunction = \"\";\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n\n    const condition = statement.condition.getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n    );\n    const expression = statement.expression.getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n    );\n\n    // Build the if/else chain from the list of conditions\n    shaderFunction +=\n      `    ${i === 0 ? \"if\" : \"else if\"} (${condition})\\n` +\n      `    {\\n` +\n      `        return ${expression};\\n` +\n      `    }\\n`;\n  }\n\n  shaderFunction =\n    `${returnType} ${functionSignature}\\n` +\n    `{\\n${shaderFunction}    return ${returnType}(1.0);\\n` + // Return a default value if no conditions are met\n    `}\\n`;\n\n  return shaderFunction;\n};\n\n/**\n * Gets the variables used by the expression.\n *\n * @returns {string[]} The variables used by the expression.\n *\n * @private\n */\nConditionsExpression.prototype.getVariables = function () {\n  let variables = [];\n\n  const conditions = this._runtimeConditions;\n  if (!defined(conditions) || conditions.length === 0) {\n    return variables;\n  }\n\n  const length = conditions.length;\n  for (let i = 0; i < length; ++i) {\n    const statement = conditions[i];\n    variables.push.apply(variables, statement.condition.getVariables());\n    variables.push.apply(variables, statement.expression.getVariables());\n  }\n\n  // Remove duplicates\n  variables = variables.filter(function (variable, index, variables) {\n    return variables.indexOf(variable) === index;\n  });\n\n  return variables;\n};\n\nexport default ConditionsExpression;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}