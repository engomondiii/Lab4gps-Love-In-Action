{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nconst positionScratch = new Cartesian3();\nconst normalScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\nconst stScratch = new Cartesian2();\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\nfunction createAttributes(vertexFormat, attributes) {\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: attributes.positions\n  });\n  if (vertexFormat.normal) {\n    geo.attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.normals\n    });\n  }\n  if (vertexFormat.tangent) {\n    geo.attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.tangents\n    });\n  }\n  if (vertexFormat.bitangent) {\n    geo.attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.bitangents\n    });\n  }\n  return geo;\n}\nfunction calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\n  const length = positions.length;\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n  let attrIndex = 0;\n  const bitangent = bitangentScratch;\n  const tangent = tangentScratch;\n  let normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (let i = 0; i < length; i += 3) {\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\n      const attrIndex1 = attrIndex + 1;\n      const attrIndex2 = attrIndex + 2;\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n        Cartesian3.normalize(tangent, tangent);\n        if (vertexFormat.bitangent) {\n          Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n        }\n      }\n      if (vertexFormat.normal) {\n        normals[attrIndex] = normal.x;\n        normals[attrIndex1] = normal.y;\n        normals[attrIndex2] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[attrIndex] = tangent.x;\n        tangents[attrIndex1] = tangent.y;\n        tangents[attrIndex2] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[attrIndex] = bitangent.x;\n        bitangents[attrIndex1] = bitangent.y;\n        bitangents[attrIndex2] = bitangent.z;\n      }\n      attrIndex += 3;\n    }\n  }\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents\n  });\n}\nconst v1Scratch = new Cartesian3();\nconst v2Scratch = new Cartesian3();\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n  const length = positions.length;\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n  let normalIndex = 0;\n  let tangentIndex = 0;\n  let bitangentIndex = 0;\n  let recomputeNormal = true;\n  let bitangent = bitangentScratch;\n  let tangent = tangentScratch;\n  let normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (let i = 0; i < length; i += 6) {\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\n      const p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n      if (recomputeNormal) {\n        const p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n        Cartesian3.subtract(p1, p, p1);\n        Cartesian3.subtract(p2, p, p2);\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n        recomputeNormal = false;\n      }\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\n        // if we've reached a corner\n        recomputeNormal = true;\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n        }\n      }\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents\n  });\n}\nfunction constructRectangle(rectangleGeometry, computedOptions) {\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let rowStart = 0;\n  let rowEnd = height;\n  let rowHeight = height;\n  let size = 0;\n  if (northCap) {\n    rowStart = 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  if (southCap) {\n    rowEnd -= 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  size += width * rowHeight;\n  const positions = vertexFormat.position ? new Float64Array(size * 3) : undefined;\n  const textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  let posIndex = 0;\n  let stIndex = 0;\n  const position = positionScratch;\n  const st = stScratch;\n  let minX = Number.MAX_VALUE;\n  let minY = Number.MAX_VALUE;\n  let maxX = -Number.MAX_VALUE;\n  let maxY = -Number.MAX_VALUE;\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = 0; col < width; ++col) {\n      RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, row, col, position, st);\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n      if (vertexFormat.st) {\n        textureCoordinates[stIndex++] = st.x;\n        textureCoordinates[stIndex++] = st.y;\n        minX = Math.min(minX, st.x);\n        minY = Math.min(minY, st.y);\n        maxX = Math.max(maxX, st.x);\n        maxY = Math.max(maxY, st.y);\n      }\n    }\n  }\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, 0, 0, position, st);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex++] = st.y;\n      minX = st.x;\n      minY = st.y;\n      maxX = st.x;\n      maxY = st.y;\n    }\n  }\n  if (southCap) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, height - 1, 0, position, st);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex] = position.z;\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex] = st.y;\n      minX = Math.min(minX, st.x);\n      minY = Math.min(minY, st.y);\n      maxX = Math.max(maxX, st.x);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n  if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\n    for (let k = 0; k < textureCoordinates.length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n      textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\n    }\n  }\n  const geo = calculateAttributes(positions, vertexFormat, ellipsoid, computedOptions.tangentRotationMatrix);\n  let indicesSize = 6 * (width - 1) * (rowHeight - 1);\n  if (northCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  if (southCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  const indices = IndexDatatype.createTypedArray(size, indicesSize);\n  let index = 0;\n  let indicesIndex = 0;\n  let i;\n  for (i = 0; i < rowHeight - 1; ++i) {\n    for (let j = 0; j < width - 1; ++j) {\n      const upperLeft = index;\n      const lowerLeft = upperLeft + width;\n      const lowerRight = lowerLeft + 1;\n      const upperRight = upperLeft + 1;\n      indices[indicesIndex++] = upperLeft;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = lowerRight;\n      ++index;\n    }\n    ++index;\n  }\n  if (northCap || southCap) {\n    let northIndex = size - 1;\n    const southIndex = size - 1;\n    if (northCap && southCap) {\n      northIndex = size - 2;\n    }\n    let p1;\n    let p2;\n    index = 0;\n    if (northCap) {\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = northIndex;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n    if (southCap) {\n      index = (rowHeight - 1) * width;\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = southIndex;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n  }\n  geo.indices = indices;\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates\n    });\n  }\n  return geo;\n}\nfunction addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\n  wallPositions[posIndex++] = topPositions[i];\n  wallPositions[posIndex++] = topPositions[i + 1];\n  wallPositions[posIndex++] = topPositions[i + 2];\n  wallPositions[posIndex++] = bottomPositions[i];\n  wallPositions[posIndex++] = bottomPositions[i + 1];\n  wallPositions[posIndex] = bottomPositions[i + 2];\n  return wallPositions;\n}\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex++] = st[i + 1];\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex] = st[i + 1];\n  return wallTextures;\n}\nconst scratchVertexFormat = new VertexFormat();\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const shadowVolume = rectangleGeometry._shadowVolume;\n  const offsetAttributeValue = rectangleGeometry._offsetAttribute;\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const minHeight = rectangleGeometry._extrudedHeight;\n  const maxHeight = rectangleGeometry._surfaceHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  let i;\n  if (shadowVolume) {\n    const newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n    newVertexFormat.normal = true;\n    rectangleGeometry._vertexFormat = newVertexFormat;\n  }\n  const topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n  if (shadowVolume) {\n    rectangleGeometry._vertexFormat = vertexFormat;\n  }\n  let topPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, maxHeight, ellipsoid, false);\n  topPositions = new Float64Array(topPositions);\n  let length = topPositions.length;\n  const newLength = length * 2;\n  const positions = new Float64Array(newLength);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, minHeight, ellipsoid);\n  positions.set(bottomPositions, length);\n  topBottomGeo.attributes.position.values = positions;\n  const normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(newLength) : undefined;\n  const bitangents = vertexFormat.bitangent ? new Float32Array(newLength) : undefined;\n  const textures = vertexFormat.st ? new Float32Array(newLength / 3 * 2) : undefined;\n  let topSt;\n  let topNormals;\n  if (vertexFormat.normal) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    normals.set(topNormals);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    normals.set(topNormals, length);\n    topBottomGeo.attributes.normal.values = normals;\n  }\n  if (shadowVolume) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    if (!vertexFormat.normal) {\n      topBottomGeo.attributes.normal = undefined;\n    }\n    const extrudeNormals = new Float32Array(newLength);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals\n    });\n  }\n  let offsetValue;\n  const hasOffsets = defined(offsetAttributeValue);\n  if (hasOffsets) {\n    const size = length / 3 * 2;\n    let offsetAttribute = new Uint8Array(size);\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      offsetValue = offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute\n    });\n  }\n  if (vertexFormat.tangent) {\n    const topTangents = topBottomGeo.attributes.tangent.values;\n    tangents.set(topTangents);\n    for (i = 0; i < length; i++) {\n      topTangents[i] = -topTangents[i];\n    }\n    tangents.set(topTangents, length);\n    topBottomGeo.attributes.tangent.values = tangents;\n  }\n  if (vertexFormat.bitangent) {\n    const topBitangents = topBottomGeo.attributes.bitangent.values;\n    bitangents.set(topBitangents);\n    bitangents.set(topBitangents, length);\n    topBottomGeo.attributes.bitangent.values = bitangents;\n  }\n  if (vertexFormat.st) {\n    topSt = topBottomGeo.attributes.st.values;\n    textures.set(topSt);\n    textures.set(topSt, length / 3 * 2);\n    topBottomGeo.attributes.st.values = textures;\n  }\n  const indices = topBottomGeo.indices;\n  const indicesLength = indices.length;\n  const posLength = length / 3;\n  const newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);\n  newIndices.set(indices);\n  for (i = 0; i < indicesLength; i += 3) {\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n  }\n  topBottomGeo.indices = newIndices;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let perimeterPositions = 0;\n  let corners = 4;\n  let dupliateCorners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\n  const wallCount = (perimeterPositions + dupliateCorners) * 2;\n  let wallPositions = new Float64Array(wallCount * 3);\n  const wallExtrudeNormals = shadowVolume ? new Float32Array(wallCount * 3) : undefined;\n  let wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n  let wallTextures = vertexFormat.st ? new Float32Array(wallCount * 2) : undefined;\n  const computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n  if (hasOffsets && !computeTopOffsets) {\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n    wallOffsetAttribute = wallOffsetAttribute.fill(offsetValue);\n  }\n  let posIndex = 0;\n  let stIndex = 0;\n  let extrudeNormalIndex = 0;\n  let wallOffsetIndex = 0;\n  const area = width * rowHeight;\n  let threeI;\n  for (i = 0; i < area; i += width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n  if (!southCap) {\n    for (i = area - width; i < area; i++) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    const southIndex = northCap ? area + 1 : area;\n    threeI = southIndex * 3;\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, southIndex * 2, topSt);\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n  for (i = area - 1; i > 0; i -= width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n  if (!northCap) {\n    for (i = width - 1; i >= 0; i--) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    const northIndex = area;\n    threeI = northIndex * 3;\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(wallTextures, stIndex, northIndex * 2, topSt);\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n  let geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: wallTextures\n    });\n  }\n  if (shadowVolume) {\n    geo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: wallExtrudeNormals\n    });\n  }\n  if (hasOffsets) {\n    geo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: wallOffsetAttribute\n    });\n  }\n  const wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\n  let upperLeft;\n  let lowerLeft;\n  let lowerRight;\n  let upperRight;\n  length = wallPositions.length / 3;\n  let index = 0;\n  for (i = 0; i < length - 1; i += 2) {\n    upperLeft = i;\n    upperRight = (upperLeft + 2) % length;\n    const p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n    const p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    lowerLeft = (upperLeft + 1) % length;\n    lowerRight = (lowerLeft + 2) % length;\n    wallIndices[index++] = upperLeft;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = lowerRight;\n  }\n  geo.indices = wallIndices;\n  geo = GeometryPipeline.combineInstances([new GeometryInstance({\n    geometry: topBottomGeo\n  }), new GeometryInstance({\n    geometry: geo\n  })]);\n  return geo[0];\n}\nconst scratchRectanglePoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\nconst nwScratch = new Cartographic();\nconst stNwScratch = new Cartographic();\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n  if (rotation === 0.0) {\n    return Rectangle.clone(rectangle, result);\n  }\n  const computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const positions = scratchRectanglePoints;\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, positions[0]);\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, width - 1, positions[1]);\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, 0, positions[2]);\n  RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, width - 1, positions[3]);\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n}\n\n/**\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias RectangleGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n *\n * @see RectangleGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n *\n * @example\n * // 1. create a rectangle\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n */\nfunction RectangleGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\"options.rectangle.north must be greater than or equal to options.rectangle.south\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.default));\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createRectangleGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rotatedRectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangleGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleGeometry} [result] The object into which to store the result.\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n */\nRectangleGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const granularity = array[startingIndex++];\n  const surfaceHeight = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = surfaceHeight;\n    scratchOptions.rotation = rotation;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new RectangleGeometry(scratchOptions);\n  }\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  result._surfaceHeight = surfaceHeight;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nRectangleGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\"options.rectangle.north must be greater than or equal to options.rectangle.south\");\n  }\n  //>>includeEnd('debug');\n\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const rotation = defaultValue(options.rotation, 0.0);\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n};\nconst tangentRotationMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nconst centerScratch = new Cartographic();\n/**\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\n  if (CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.north, rectangleGeometry._rectangle.south, CesiumMath.EPSILON10) || CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.east, rectangleGeometry._rectangle.west, CesiumMath.EPSILON10)) {\n    return undefined;\n  }\n  let rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const rotation = rectangleGeometry._rotation;\n  const stRotation = rectangleGeometry._stRotation;\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rotation, stRotation, rectangleScratch, nwScratch, stNwScratch);\n  const tangentRotationMatrix = tangentRotationMatrixScratch;\n  if (stRotation !== 0 || rotation !== 0) {\n    const center = Rectangle.center(rectangle, centerScratch);\n    const axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n  } else {\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n  }\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n  let geometry;\n  let boundingSphere;\n  rectangle = rectangleGeometry._rectangle;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    const topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n    const bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n    boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n  }\n  if (!vertexFormat.position) {\n    delete geometry.attributes.position;\n  }\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute\n  });\n};\n\n/**\n * @private\n */\nRectangleGeometry.createShadowVolume = function (rectangleGeometry, minHeightFunc, maxHeightFunc) {\n  const granularity = rectangleGeometry._granularity;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n  return new RectangleGeometry({\n    rectangle: rectangleGeometry._rectangle,\n    rotation: rectangleGeometry._rotation,\n    ellipsoid: ellipsoid,\n    stRotation: rectangleGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: maxHeight,\n    height: minHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true\n  });\n};\nconst unrotatedTextureRectangleScratch = new Rectangle();\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nconst rotation2DScratch = new Matrix2();\nconst rectangleCenterScratch = new Cartographic();\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\n  if (rectangleGeometry._stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  const rectangle = Rectangle.clone(rectangleGeometry._rectangle, unrotatedTextureRectangleScratch);\n  const granularity = rectangleGeometry._granularity;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  // Rotate to align the texture coordinates with ENU\n  const rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n  const unrotatedTextureRectangle = computeRectangle(rectangle, granularity, rotation, ellipsoid, unrotatedTextureRectangleScratch);\n\n  // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n  const points2D = points2DScratch;\n  points2D[0].x = unrotatedTextureRectangle.west;\n  points2D[0].y = unrotatedTextureRectangle.south;\n  points2D[1].x = unrotatedTextureRectangle.west;\n  points2D[1].y = unrotatedTextureRectangle.north;\n  points2D[2].x = unrotatedTextureRectangle.east;\n  points2D[2].y = unrotatedTextureRectangle.south;\n  const boundingRectangle = rectangleGeometry.rectangle;\n  const toDesiredInComputed = Matrix2.fromRotation(rectangleGeometry._stRotation, rotation2DScratch);\n  const boundingRectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\n  for (let i = 0; i < 3; ++i) {\n    const point2D = points2D[i];\n    point2D.x -= boundingRectangleCenter.longitude;\n    point2D.y -= boundingRectangleCenter.latitude;\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n    point2D.x += boundingRectangleCenter.longitude;\n    point2D.y += boundingRectangleCenter.latitude;\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n    point2D.y = (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n  }\n  const minXYCorner = points2D[0];\n  const maxYCorner = points2D[1];\n  const maxXCorner = points2D[2];\n  const result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n}\nObject.defineProperties(RectangleGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rotatedRectangle)) {\n        this._rotatedRectangle = computeRectangle(this._rectangle, this._granularity, this._rotation, this._ellipsoid);\n      }\n      return this._rotatedRectangle;\n    }\n  },\n  /**\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n   * This version permits skew in textures by computing offsets directly in cartographic space and\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n   * @see Geometry#_textureCoordinateRotationPoints\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    }\n  }\n});\nexport default RectangleGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryInstance","GeometryOffsetAttribute","GeometryPipeline","IndexDatatype","CesiumMath","Matrix2","Matrix3","PolygonPipeline","PrimitiveType","Quaternion","Rectangle","RectangleGeometryLibrary","VertexFormat","positionScratch","normalScratch","tangentScratch","bitangentScratch","rectangleScratch","stScratch","bottomBoundingSphere","topBoundingSphere","createAttributes","vertexFormat","attributes","geo","primitiveType","TRIANGLES","position","componentDatatype","DOUBLE","componentsPerAttribute","values","positions","normal","FLOAT","normals","tangent","tangents","bitangent","bitangents","calculateAttributes","ellipsoid","tangentRotationMatrix","length","Float32Array","undefined","attrIndex","i","p","fromArray","attrIndex1","attrIndex2","geodeticSurfaceNormal","cross","UNIT_Z","multiplyByVector","normalize","x","y","z","v1Scratch","v2Scratch","calculateAttributesWall","normalIndex","tangentIndex","bitangentIndex","recomputeNormal","p1","p2","subtract","equalsEpsilon","EPSILON10","constructRectangle","rectangleGeometry","computedOptions","_vertexFormat","_ellipsoid","height","width","northCap","southCap","rowStart","rowEnd","rowHeight","size","Float64Array","textureCoordinates","st","posIndex","stIndex","minX","Number","MAX_VALUE","minY","maxX","maxY","row","col","computePosition","Math","min","max","k","indicesSize","indices","createTypedArray","index","indicesIndex","j","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","addWallPositions","wallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","scratchVertexFormat","constructExtrudedRectangle","shadowVolume","_shadowVolume","offsetAttributeValue","_offsetAttribute","minHeight","_extrudedHeight","maxHeight","_surfaceHeight","newVertexFormat","clone","topBottomGeo","scaleToGeodeticHeight","newLength","set","textures","topSt","topNormals","extrudeNormals","extrudeDirection","offsetValue","hasOffsets","offsetAttribute","Uint8Array","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","topTangents","topBitangents","indicesLength","posLength","newIndices","widthMultiplier","perimeterPositions","corners","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","ALL","extrudeNormalIndex","wallOffsetIndex","area","threeI","wallIndices","combineInstances","geometry","scratchRectanglePoints","nwScratch","stNwScratch","computeRectangle","rectangle","granularity","rotation","result","computeOptions","fromCartesianArray","RectangleGeometry","options","EMPTY_OBJECT","typeOf","object","_validate","north","south","extrudedHeight","_rectangle","_granularity","RADIANS_PER_DEGREE","default","_rotation","_stRotation","stRotation","DEFAULT","_workerName","_rotatedRectangle","_textureCoordinateRotationPoints","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","surfaceHeight","tangentRotationMatrixScratch","quaternionScratch","centerScratch","createGeometry","east","west","center","axis","geodeticSurfaceNormalCartographic","fromAxisAngle","fromQuaternion","IDENTITY","extrude","EPSILON2","lonScalar","latScalar","boundingSphere","topBS","fromRectangle3D","bottomBS","union","createShadowVolume","minHeightFunc","maxHeightFunc","POSITION_ONLY","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","rectangleCenterScratch","textureCoordinateRotationPoints","unrotatedTextureRectangle","points2D","boundingRectangle","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","longitude","latitude","minXYCorner","maxYCorner","maxXCorner","Array","Object","defineProperties","prototype","get"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/RectangleGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst positionScratch = new Cartesian3();\nconst normalScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\nconst stScratch = new Cartesian2();\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\n\nfunction createAttributes(vertexFormat, attributes) {\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: attributes.positions,\n  });\n  if (vertexFormat.normal) {\n    geo.attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.normals,\n    });\n  }\n  if (vertexFormat.tangent) {\n    geo.attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.tangents,\n    });\n  }\n  if (vertexFormat.bitangent) {\n    geo.attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attributes.bitangents,\n    });\n  }\n  return geo;\n}\n\nfunction calculateAttributes(\n  positions,\n  vertexFormat,\n  ellipsoid,\n  tangentRotationMatrix,\n) {\n  const length = positions.length;\n\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  let attrIndex = 0;\n  const bitangent = bitangentScratch;\n  const tangent = tangentScratch;\n  let normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (let i = 0; i < length; i += 3) {\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\n      const attrIndex1 = attrIndex + 1;\n      const attrIndex2 = attrIndex + 2;\n\n      normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n        Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.bitangent) {\n          Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent,\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[attrIndex] = normal.x;\n        normals[attrIndex1] = normal.y;\n        normals[attrIndex2] = normal.z;\n      }\n      if (vertexFormat.tangent) {\n        tangents[attrIndex] = tangent.x;\n        tangents[attrIndex1] = tangent.y;\n        tangents[attrIndex2] = tangent.z;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[attrIndex] = bitangent.x;\n        bitangents[attrIndex1] = bitangent.y;\n        bitangents[attrIndex2] = bitangent.z;\n      }\n      attrIndex += 3;\n    }\n  }\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nconst v1Scratch = new Cartesian3();\nconst v2Scratch = new Cartesian3();\n\nfunction calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n  const length = positions.length;\n\n  const normals = vertexFormat.normal ? new Float32Array(length) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(length)\n    : undefined;\n\n  let normalIndex = 0;\n  let tangentIndex = 0;\n  let bitangentIndex = 0;\n  let recomputeNormal = true;\n\n  let bitangent = bitangentScratch;\n  let tangent = tangentScratch;\n  let normal = normalScratch;\n  if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n    for (let i = 0; i < length; i += 6) {\n      const p = Cartesian3.fromArray(positions, i, positionScratch);\n      const p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n      if (recomputeNormal) {\n        const p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n        Cartesian3.subtract(p1, p, p1);\n        Cartesian3.subtract(p2, p, p2);\n        normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n        recomputeNormal = false;\n      }\n\n      if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {\n        // if we've reached a corner\n        recomputeNormal = true;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent,\n          );\n        }\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n        tangents[tangentIndex++] = tangent.x;\n        tangents[tangentIndex++] = tangent.y;\n        tangents[tangentIndex++] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n        bitangents[bitangentIndex++] = bitangent.x;\n        bitangents[bitangentIndex++] = bitangent.y;\n        bitangents[bitangentIndex++] = bitangent.z;\n      }\n    }\n  }\n\n  return createAttributes(vertexFormat, {\n    positions: positions,\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  });\n}\n\nfunction constructRectangle(rectangleGeometry, computedOptions) {\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowStart = 0;\n  let rowEnd = height;\n  let rowHeight = height;\n  let size = 0;\n  if (northCap) {\n    rowStart = 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  if (southCap) {\n    rowEnd -= 1;\n    rowHeight -= 1;\n    size += 1;\n  }\n  size += width * rowHeight;\n\n  const positions = vertexFormat.position\n    ? new Float64Array(size * 3)\n    : undefined;\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n\n  let posIndex = 0;\n  let stIndex = 0;\n\n  const position = positionScratch;\n  const st = stScratch;\n\n  let minX = Number.MAX_VALUE;\n  let minY = Number.MAX_VALUE;\n  let maxX = -Number.MAX_VALUE;\n  let maxY = -Number.MAX_VALUE;\n\n  for (let row = rowStart; row < rowEnd; ++row) {\n    for (let col = 0; col < width; ++col) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        vertexFormat.st,\n        row,\n        col,\n        position,\n        st,\n      );\n\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n\n      if (vertexFormat.st) {\n        textureCoordinates[stIndex++] = st.x;\n        textureCoordinates[stIndex++] = st.y;\n\n        minX = Math.min(minX, st.x);\n        minY = Math.min(minY, st.y);\n        maxX = Math.max(maxX, st.x);\n        maxY = Math.max(maxY, st.y);\n      }\n    }\n  }\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      0,\n      0,\n      position,\n      st,\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex++] = st.y;\n\n      minX = st.x;\n      minY = st.y;\n      maxX = st.x;\n      maxY = st.y;\n    }\n  }\n  if (southCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      vertexFormat.st,\n      height - 1,\n      0,\n      position,\n      st,\n    );\n\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex] = position.z;\n\n    if (vertexFormat.st) {\n      textureCoordinates[stIndex++] = st.x;\n      textureCoordinates[stIndex] = st.y;\n\n      minX = Math.min(minX, st.x);\n      minY = Math.min(minY, st.y);\n      maxX = Math.max(maxX, st.x);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  if (\n    vertexFormat.st &&\n    (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)\n  ) {\n    for (let k = 0; k < textureCoordinates.length; k += 2) {\n      textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minY) / (maxY - minY);\n    }\n  }\n\n  const geo = calculateAttributes(\n    positions,\n    vertexFormat,\n    ellipsoid,\n    computedOptions.tangentRotationMatrix,\n  );\n\n  let indicesSize = 6 * (width - 1) * (rowHeight - 1);\n  if (northCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  if (southCap) {\n    indicesSize += 3 * (width - 1);\n  }\n  const indices = IndexDatatype.createTypedArray(size, indicesSize);\n  let index = 0;\n  let indicesIndex = 0;\n  let i;\n  for (i = 0; i < rowHeight - 1; ++i) {\n    for (let j = 0; j < width - 1; ++j) {\n      const upperLeft = index;\n      const lowerLeft = upperLeft + width;\n      const lowerRight = lowerLeft + 1;\n      const upperRight = upperLeft + 1;\n      indices[indicesIndex++] = upperLeft;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = upperRight;\n      indices[indicesIndex++] = lowerLeft;\n      indices[indicesIndex++] = lowerRight;\n      ++index;\n    }\n    ++index;\n  }\n  if (northCap || southCap) {\n    let northIndex = size - 1;\n    const southIndex = size - 1;\n    if (northCap && southCap) {\n      northIndex = size - 2;\n    }\n\n    let p1;\n    let p2;\n    index = 0;\n\n    if (northCap) {\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = northIndex;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n    if (southCap) {\n      index = (rowHeight - 1) * width;\n      for (i = 0; i < width - 1; i++) {\n        p1 = index;\n        p2 = p1 + 1;\n        indices[indicesIndex++] = p1;\n        indices[indicesIndex++] = southIndex;\n        indices[indicesIndex++] = p2;\n        ++index;\n      }\n    }\n  }\n\n  geo.indices = indices;\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  return geo;\n}\n\nfunction addWallPositions(\n  wallPositions,\n  posIndex,\n  i,\n  topPositions,\n  bottomPositions,\n) {\n  wallPositions[posIndex++] = topPositions[i];\n  wallPositions[posIndex++] = topPositions[i + 1];\n  wallPositions[posIndex++] = topPositions[i + 2];\n  wallPositions[posIndex++] = bottomPositions[i];\n  wallPositions[posIndex++] = bottomPositions[i + 1];\n  wallPositions[posIndex] = bottomPositions[i + 2];\n  return wallPositions;\n}\n\nfunction addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex++] = st[i + 1];\n  wallTextures[stIndex++] = st[i];\n  wallTextures[stIndex] = st[i + 1];\n  return wallTextures;\n}\n\nconst scratchVertexFormat = new VertexFormat();\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const shadowVolume = rectangleGeometry._shadowVolume;\n  const offsetAttributeValue = rectangleGeometry._offsetAttribute;\n  const vertexFormat = rectangleGeometry._vertexFormat;\n  const minHeight = rectangleGeometry._extrudedHeight;\n  const maxHeight = rectangleGeometry._surfaceHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  let i;\n\n  if (shadowVolume) {\n    const newVertexFormat = VertexFormat.clone(\n      vertexFormat,\n      scratchVertexFormat,\n    );\n    newVertexFormat.normal = true;\n    rectangleGeometry._vertexFormat = newVertexFormat;\n  }\n\n  const topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n  if (shadowVolume) {\n    rectangleGeometry._vertexFormat = vertexFormat;\n  }\n\n  let topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false,\n  );\n  topPositions = new Float64Array(topPositions);\n  let length = topPositions.length;\n  const newLength = length * 2;\n  const positions = new Float64Array(newLength);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    topBottomGeo.attributes.position.values,\n    minHeight,\n    ellipsoid,\n  );\n  positions.set(bottomPositions, length);\n  topBottomGeo.attributes.position.values = positions;\n\n  const normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(newLength)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(newLength)\n    : undefined;\n  const textures = vertexFormat.st\n    ? new Float32Array((newLength / 3) * 2)\n    : undefined;\n  let topSt;\n  let topNormals;\n  if (vertexFormat.normal) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    normals.set(topNormals);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    normals.set(topNormals, length);\n    topBottomGeo.attributes.normal.values = normals;\n  }\n  if (shadowVolume) {\n    topNormals = topBottomGeo.attributes.normal.values;\n    if (!vertexFormat.normal) {\n      topBottomGeo.attributes.normal = undefined;\n    }\n    const extrudeNormals = new Float32Array(newLength);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n    topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  let offsetValue;\n  const hasOffsets = defined(offsetAttributeValue);\n  if (hasOffsets) {\n    const size = (length / 3) * 2;\n    let offsetAttribute = new Uint8Array(size);\n    if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n    } else {\n      offsetValue =\n        offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = offsetAttribute.fill(offsetValue);\n    }\n\n    topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    const topTangents = topBottomGeo.attributes.tangent.values;\n    tangents.set(topTangents);\n    for (i = 0; i < length; i++) {\n      topTangents[i] = -topTangents[i];\n    }\n    tangents.set(topTangents, length);\n    topBottomGeo.attributes.tangent.values = tangents;\n  }\n  if (vertexFormat.bitangent) {\n    const topBitangents = topBottomGeo.attributes.bitangent.values;\n    bitangents.set(topBitangents);\n    bitangents.set(topBitangents, length);\n    topBottomGeo.attributes.bitangent.values = bitangents;\n  }\n  if (vertexFormat.st) {\n    topSt = topBottomGeo.attributes.st.values;\n    textures.set(topSt);\n    textures.set(topSt, (length / 3) * 2);\n    topBottomGeo.attributes.st.values = textures;\n  }\n\n  const indices = topBottomGeo.indices;\n  const indicesLength = indices.length;\n  const posLength = length / 3;\n  const newIndices = IndexDatatype.createTypedArray(\n    newLength / 3,\n    indicesLength * 2,\n  );\n  newIndices.set(indices);\n  for (i = 0; i < indicesLength; i += 3) {\n    newIndices[i + indicesLength] = indices[i + 2] + posLength;\n    newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n    newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n  }\n  topBottomGeo.indices = newIndices;\n\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let perimeterPositions = 0;\n  let corners = 4;\n  let dupliateCorners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    perimeterPositions += 1;\n    corners -= 2;\n    dupliateCorners -= 1;\n  }\n  perimeterPositions += widthMultiplier * width + 2 * rowHeight - corners;\n\n  const wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n  let wallPositions = new Float64Array(wallCount * 3);\n  const wallExtrudeNormals = shadowVolume\n    ? new Float32Array(wallCount * 3)\n    : undefined;\n  let wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n  let wallTextures = vertexFormat.st\n    ? new Float32Array(wallCount * 2)\n    : undefined;\n\n  const computeTopOffsets =\n    offsetAttributeValue === GeometryOffsetAttribute.TOP;\n  if (hasOffsets && !computeTopOffsets) {\n    offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n    wallOffsetAttribute = wallOffsetAttribute.fill(offsetValue);\n  }\n\n  let posIndex = 0;\n  let stIndex = 0;\n  let extrudeNormalIndex = 0;\n  let wallOffsetIndex = 0;\n  const area = width * rowHeight;\n  let threeI;\n  for (i = 0; i < area; i += width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions,\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt,\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!southCap) {\n    for (i = area - width; i < area; i++) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    const southIndex = northCap ? area + 1 : area;\n    threeI = southIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          southIndex * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  for (i = area - 1; i > 0; i -= width) {\n    threeI = i * 3;\n    wallPositions = addWallPositions(\n      wallPositions,\n      posIndex,\n      threeI,\n      topPositions,\n      bottomPositions,\n    );\n    posIndex += 6;\n    if (vertexFormat.st) {\n      wallTextures = addWallTextureCoordinates(\n        wallTextures,\n        stIndex,\n        i * 2,\n        topSt,\n      );\n      stIndex += 4;\n    }\n    if (shadowVolume) {\n      extrudeNormalIndex += 3;\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n      wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n    }\n    if (computeTopOffsets) {\n      wallOffsetAttribute[wallOffsetIndex++] = 1;\n      wallOffsetIndex += 1;\n    }\n  }\n\n  if (!northCap) {\n    for (i = width - 1; i >= 0; i--) {\n      threeI = i * 3;\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          i * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  } else {\n    const northIndex = area;\n    threeI = northIndex * 3;\n\n    for (i = 0; i < 2; i++) {\n      // duplicate corner points\n      wallPositions = addWallPositions(\n        wallPositions,\n        posIndex,\n        threeI,\n        topPositions,\n        bottomPositions,\n      );\n      posIndex += 6;\n      if (vertexFormat.st) {\n        wallTextures = addWallTextureCoordinates(\n          wallTextures,\n          stIndex,\n          northIndex * 2,\n          topSt,\n        );\n        stIndex += 4;\n      }\n      if (shadowVolume) {\n        extrudeNormalIndex += 3;\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n        wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n      }\n      if (computeTopOffsets) {\n        wallOffsetAttribute[wallOffsetIndex++] = 1;\n        wallOffsetIndex += 1;\n      }\n    }\n  }\n\n  let geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n  if (vertexFormat.st) {\n    geo.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: wallTextures,\n    });\n  }\n  if (shadowVolume) {\n    geo.attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: wallExtrudeNormals,\n    });\n  }\n  if (hasOffsets) {\n    geo.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: wallOffsetAttribute,\n    });\n  }\n\n  const wallIndices = IndexDatatype.createTypedArray(\n    wallCount,\n    perimeterPositions * 6,\n  );\n\n  let upperLeft;\n  let lowerLeft;\n  let lowerRight;\n  let upperRight;\n  length = wallPositions.length / 3;\n  let index = 0;\n  for (i = 0; i < length - 1; i += 2) {\n    upperLeft = i;\n    upperRight = (upperLeft + 2) % length;\n    const p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n    const p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n    if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n      continue;\n    }\n    lowerLeft = (upperLeft + 1) % length;\n    lowerRight = (lowerLeft + 2) % length;\n    wallIndices[index++] = upperLeft;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = upperRight;\n    wallIndices[index++] = lowerLeft;\n    wallIndices[index++] = lowerRight;\n  }\n\n  geo.indices = wallIndices;\n\n  geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: geo,\n    }),\n  ]);\n\n  return geo[0];\n}\n\nconst scratchRectanglePoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\nconst nwScratch = new Cartographic();\nconst stNwScratch = new Cartographic();\nfunction computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n  if (rotation === 0.0) {\n    return Rectangle.clone(rectangle, result);\n  }\n\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    granularity,\n    rotation,\n    0,\n    rectangleScratch,\n    nwScratch,\n  );\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  const positions = scratchRectanglePoints;\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    0,\n    positions[0],\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    0,\n    width - 1,\n    positions[1],\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    0,\n    positions[2],\n  );\n  RectangleGeometryLibrary.computePosition(\n    computedOptions,\n    ellipsoid,\n    false,\n    height - 1,\n    width - 1,\n    positions[3],\n  );\n\n  return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n}\n\n/**\n * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias RectangleGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n *\n * @see RectangleGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n *\n * @example\n * // 1. create a rectangle\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n *\n * // 2. create an extruded rectangle without a top\n * const rectangle = new Cesium.RectangleGeometry({\n *   ellipsoid : Cesium.Ellipsoid.default,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0,\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n */\nfunction RectangleGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.default),\n  );\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT),\n  );\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createRectangleGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rotatedRectangle = undefined;\n\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangleGeometry.packedLength =\n  Rectangle.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangleGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleGeometry} [result] The object into which to store the result.\n * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n */\nRectangleGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const granularity = array[startingIndex++];\n  const surfaceHeight = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = surfaceHeight;\n    scratchOptions.rotation = rotation;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._granularity = granularity;\n  result._surfaceHeight = surfaceHeight;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nRectangleGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const rectangle = options.rectangle;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than or equal to options.rectangle.south\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n};\n\nconst tangentRotationMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nconst centerScratch = new Cartographic();\n/**\n * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleGeometry.createGeometry = function (rectangleGeometry) {\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.north,\n      rectangleGeometry._rectangle.south,\n      CesiumMath.EPSILON10,\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangleGeometry._rectangle.east,\n      rectangleGeometry._rectangle.west,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    return undefined;\n  }\n\n  let rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const rotation = rectangleGeometry._rotation;\n  const stRotation = rectangleGeometry._stRotation;\n  const vertexFormat = rectangleGeometry._vertexFormat;\n\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rotation,\n    stRotation,\n    rectangleScratch,\n    nwScratch,\n    stNwScratch,\n  );\n\n  const tangentRotationMatrix = tangentRotationMatrixScratch;\n  if (stRotation !== 0 || rotation !== 0) {\n    const center = Rectangle.center(rectangle, centerScratch);\n    const axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n    Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n    Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n  } else {\n    Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n  }\n\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n  computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n  computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n  let geometry;\n  let boundingSphere;\n  rectangle = rectangleGeometry._rectangle;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    const topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere,\n    );\n    const bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere,\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false,\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n    );\n  }\n\n  if (!vertexFormat.position) {\n    delete geometry.attributes.position;\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nRectangleGeometry.createShadowVolume = function (\n  rectangleGeometry,\n  minHeightFunc,\n  maxHeightFunc,\n) {\n  const granularity = rectangleGeometry._granularity;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new RectangleGeometry({\n    rectangle: rectangleGeometry._rectangle,\n    rotation: rectangleGeometry._rotation,\n    ellipsoid: ellipsoid,\n    stRotation: rectangleGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: maxHeight,\n    height: minHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nconst unrotatedTextureRectangleScratch = new Rectangle();\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nconst rotation2DScratch = new Matrix2();\nconst rectangleCenterScratch = new Cartographic();\n\nfunction textureCoordinateRotationPoints(rectangleGeometry) {\n  if (rectangleGeometry._stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  const rectangle = Rectangle.clone(\n    rectangleGeometry._rectangle,\n    unrotatedTextureRectangleScratch,\n  );\n  const granularity = rectangleGeometry._granularity;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n\n  // Rotate to align the texture coordinates with ENU\n  const rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n  const unrotatedTextureRectangle = computeRectangle(\n    rectangle,\n    granularity,\n    rotation,\n    ellipsoid,\n    unrotatedTextureRectangleScratch,\n  );\n\n  // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n  // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n  // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n  // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n  // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n  // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n  // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n  const points2D = points2DScratch;\n  points2D[0].x = unrotatedTextureRectangle.west;\n  points2D[0].y = unrotatedTextureRectangle.south;\n\n  points2D[1].x = unrotatedTextureRectangle.west;\n  points2D[1].y = unrotatedTextureRectangle.north;\n\n  points2D[2].x = unrotatedTextureRectangle.east;\n  points2D[2].y = unrotatedTextureRectangle.south;\n\n  const boundingRectangle = rectangleGeometry.rectangle;\n  const toDesiredInComputed = Matrix2.fromRotation(\n    rectangleGeometry._stRotation,\n    rotation2DScratch,\n  );\n  const boundingRectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch,\n  );\n\n  for (let i = 0; i < 3; ++i) {\n    const point2D = points2D[i];\n    point2D.x -= boundingRectangleCenter.longitude;\n    point2D.y -= boundingRectangleCenter.latitude;\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n    point2D.x += boundingRectangleCenter.longitude;\n    point2D.y += boundingRectangleCenter.latitude;\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n    point2D.y =\n      (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n  }\n\n  const minXYCorner = points2D[0];\n  const maxYCorner = points2D[1];\n  const maxXCorner = points2D[2];\n  const result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n}\n\nObject.defineProperties(RectangleGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rotatedRectangle)) {\n        this._rotatedRectangle = computeRectangle(\n          this._rectangle,\n          this._granularity,\n          this._rotation,\n          this._ellipsoid,\n        );\n      }\n      return this._rotatedRectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n   * This version permits skew in textures by computing offsets directly in cartographic space and\n   * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n   * @see Geometry#_textureCoordinateRotationPoints\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints =\n          textureCoordinateRotationPoints(this);\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default RectangleGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}