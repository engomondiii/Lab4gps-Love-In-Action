{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\n\n/**\n * Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.\n *\n * @alias PostProcessStage\n * @constructor\n *\n * @param {object} options An object with the following properties:\n * @param {string} options.fragmentShader The fragment shader to use. The default <code>sampler2D</code> uniforms are <code>colorTexture</code> and <code>depthTexture</code>. The color texture is the output of rendering the scene or the previous stage. The depth texture is the output from rendering the scene. The shader should contain one or both uniforms. There is also a <code>vec2</code> varying named <code>v_textureCoordinates</code> that can be used to sample the textures.\n * @param {object} [options.uniforms] An object whose properties will be used to set the shaders uniforms. The properties can be constant values or a function. A constant value can also be a URI, data URI, or HTML element to use as a texture.\n * @param {number} [options.textureScale=1.0] A number in the range (0.0, 1.0] used to scale the texture dimensions. A scale of 1.0 will render this post-process stage  to a texture the size of the viewport.\n * @param {boolean} [options.forcePowerOfTwo=false] Whether or not to force the texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.\n * @param {PostProcessStageSampleMode} [options.sampleMode=PostProcessStageSampleMode.NEAREST] How to sample the input color texture.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The color pixel format of the output texture.\n * @param {PixelDatatype} [options.pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The pixel data type of the output texture.\n * @param {Color} [options.clearColor=Color.BLACK] The color to clear the output texture to.\n * @param {BoundingRectangle} [options.scissorRectangle] The rectangle to use for the scissor test.\n * @param {string} [options.name=createGuid()] The unique name of this post-process stage for reference by other stages in a composite. If a name is not supplied, a GUID will be generated.\n *\n * @exception {DeveloperError} options.textureScale must be greater than 0.0 and less than or equal to 1.0.\n * @exception {DeveloperError} options.pixelFormat must be a color format.\n * @exception {DeveloperError} When options.pixelDatatype is FLOAT, this WebGL implementation must support floating point textures. Check context.floatingPointTexture.\n *\n * @see PostProcessStageComposite\n *\n * @example\n * // Simple stage to change the color\n * const fs =`\n *     uniform sampler2D colorTexture;\n *     in vec2 v_textureCoordinates;\n *     uniform float scale;\n *     uniform vec3 offset;\n *     void main() {\n *         vec4 color = texture(colorTexture, v_textureCoordinates);\n *         out_FragColor = vec4(color.rgb * scale + offset, 1.0);\n *     }`;\n * scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         scale : 1.1,\n *         offset : function() {\n *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);\n *         }\n *     }\n * }));\n *\n * @example\n * // Simple stage to change the color of what is selected.\n * // If czm_selected returns true, the current fragment belongs to geometry in the selected array.\n * const fs =`\n *     uniform sampler2D colorTexture;\n *     in vec2 v_textureCoordinates;\n *     uniform vec4 highlight;\n *     void main() {\n *         vec4 color = texture(colorTexture, v_textureCoordinates);\n *         if (czm_selected()) {\n *             vec3 highlighted = highlight.a * highlight.rgb + (1.0 - highlight.a) * color.rgb;\n *             out_FragColor = vec4(highlighted, 1.0);\n *         } else {\n *             out_FragColor = color;\n *         }\n *     }`;\n * const stage = scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         highlight : function() {\n *             return new Cesium.Color(1.0, 0.0, 0.0, 0.5);\n *         }\n *     }\n * }));\n * stage.selected = [cesium3DTileFeature];\n */\nfunction PostProcessStage(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    name = createGuid(),\n    fragmentShader,\n    uniforms,\n    textureScale = 1.0,\n    forcePowerOfTwo = false,\n    sampleMode = PostProcessStageSampleMode.NEAREST,\n    pixelFormat = PixelFormat.RGBA,\n    pixelDatatype = PixelDatatype.UNSIGNED_BYTE,\n    clearColor = Color.BLACK,\n    scissorRectangle\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.fragmentShader\", fragmentShader);\n  Check.typeOf.number.greaterThan(\"options.textureScale\", textureScale, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\"options.textureScale\", textureScale, 1.0);\n  if (!PixelFormat.isColorFormat(pixelFormat)) {\n    throw new DeveloperError(\"options.pixelFormat must be a color format.\");\n  }\n  //>>includeEnd('debug');\n\n  this._fragmentShader = fragmentShader;\n  this._uniforms = uniforms;\n  this._textureScale = textureScale;\n  this._forcePowerOfTwo = forcePowerOfTwo;\n  this._sampleMode = sampleMode;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._clearColor = clearColor;\n  this._uniformMap = undefined;\n  this._command = undefined;\n  this._colorTexture = undefined;\n  this._depthTexture = undefined;\n  this._idTexture = undefined;\n  this._actualUniforms = {};\n  this._dirtyUniforms = [];\n  this._texturesToRelease = [];\n  this._texturesToCreate = [];\n  this._texturePromise = undefined;\n  const passState = new PassState();\n  passState.scissorTest = {\n    enabled: true,\n    rectangle: defined(scissorRectangle) ? BoundingRectangle.clone(scissorRectangle) : new BoundingRectangle()\n  };\n  this._passState = passState;\n  this._ready = false;\n  this._name = name;\n  this._logDepthChanged = undefined;\n  this._useLogDepth = undefined;\n  this._selectedIdTexture = undefined;\n  this._selected = undefined;\n  this._selectedShadow = undefined;\n  this._parentSelected = undefined;\n  this._parentSelectedShadow = undefined;\n  this._combinedSelected = undefined;\n  this._combinedSelectedShadow = undefined;\n  this._selectedLength = 0;\n  this._parentSelectedLength = 0;\n  this._selectedDirty = true;\n\n  // set by PostProcessStageCollection\n  this._textureCache = undefined;\n  this._index = undefined;\n\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @type {boolean}\n   */\n  this.enabled = true;\n  this._enabled = true;\n}\nObject.defineProperties(PostProcessStage.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>\n   * and {@link PostProcessStage#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures\n   * to load.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages in a {@link PostProcessStageComposite}.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * The fragment shader to use when execute this post-process stage.\n   * <p>\n   * The shader must contain a sampler uniform declaration for <code>colorTexture</code>, <code>depthTexture</code>,\n   * or both.\n   * </p>\n   * <p>\n   * The shader must contain a <code>vec2</code> varying declaration for <code>v_textureCoordinates</code> for sampling\n   * the texture uniforms.\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {string}\n   * @readonly\n   */\n  fragmentShader: {\n    get: function () {\n      return this._fragmentShader;\n    }\n  },\n  /**\n   * An object whose properties are used to set the uniforms of the fragment shader.\n   * <p>\n   * The object property values can be either a constant or a function. The function will be called\n   * each frame before the post-process stage is executed.\n   * </p>\n   * <p>\n   * A constant value can also be a URI to an image, a data URI, or an HTML element that can be used as a texture, such as HTMLImageElement or HTMLCanvasElement.\n   * </p>\n   * <p>\n   * If this post-process stage is part of a {@link PostProcessStageComposite} that does not execute in series, the constant value can also be\n   * the name of another stage in a composite. This will set the uniform to the output texture the stage with that name.\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {object}\n   * @readonly\n   */\n  uniforms: {\n    get: function () {\n      return this._uniforms;\n    }\n  },\n  /**\n   * A number in the range (0.0, 1.0] used to scale the output texture dimensions. A scale of 1.0 will render this post-process stage to a texture the size of the viewport.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {number}\n   * @readonly\n   */\n  textureScale: {\n    get: function () {\n      return this._textureScale;\n    }\n  },\n  /**\n   * Whether or not to force the output texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {number}\n   * @readonly\n   */\n  forcePowerOfTwo: {\n    get: function () {\n      return this._forcePowerOfTwo;\n    }\n  },\n  /**\n   * How to sample the input color texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PostProcessStageSampleMode}\n   * @readonly\n   */\n  sampleMode: {\n    get: function () {\n      return this._sampleMode;\n    }\n  },\n  /**\n   * The color pixel format of the output texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PixelFormat}\n   * @readonly\n   */\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    }\n  },\n  /**\n   * The pixel data type of the output texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PixelDatatype}\n   * @readonly\n   */\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    }\n  },\n  /**\n   * The color to clear the output texture to.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Color}\n   * @readonly\n   */\n  clearColor: {\n    get: function () {\n      return this._clearColor;\n    }\n  },\n  /**\n   * The {@link BoundingRectangle} to use for the scissor test. A default bounding rectangle will disable the scissor test.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {BoundingRectangle}\n   * @readonly\n   */\n  scissorRectangle: {\n    get: function () {\n      return this._passState.scissorTest.rectangle;\n    }\n  },\n  /**\n   * A reference to the texture written to when executing this post process stage.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      if (defined(this._textureCache)) {\n        const framebuffer = this._textureCache.getFramebuffer(this._name);\n        if (defined(framebuffer)) {\n          return framebuffer.getColorTexture(0);\n        }\n      }\n      return undefined;\n    }\n  },\n  /**\n   * The features selected for applying the post-process.\n   * <p>\n   * In the fragment shader, use <code>czm_selected</code> to determine whether or not to apply the post-process\n   * stage to that fragment. For example:\n   * <code>\n   * if (czm_selected(v_textureCoordinates)) {\n   *     // apply post-process stage\n   * } else {\n   *     out_FragColor = texture(colorTexture, v_textureCoordinates);\n   * }\n   * </code>\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Array}\n   */\n  selected: {\n    get: function () {\n      return this._selected;\n    },\n    set: function (value) {\n      this._selected = value;\n    }\n  },\n  /**\n   * @private\n   */\n  parentSelected: {\n    get: function () {\n      return this._parentSelected;\n    },\n    set: function (value) {\n      this._parentSelected = value;\n    }\n  }\n});\nconst depthTextureRegex = /uniform\\s+sampler2D\\s+depthTexture/g;\n\n/**\n * @private\n */\nPostProcessStage.prototype._isSupported = function (context) {\n  return !depthTextureRegex.test(this._fragmentShader) || context.depthTexture;\n};\nfunction getUniformValueGetterAndSetter(stage, uniforms, name) {\n  const currentValue = uniforms[name];\n  if (typeof currentValue === \"string\" || currentValue instanceof HTMLCanvasElement || currentValue instanceof HTMLImageElement || currentValue instanceof HTMLVideoElement || currentValue instanceof ImageData) {\n    stage._dirtyUniforms.push(name);\n  }\n  return {\n    get: function () {\n      return uniforms[name];\n    },\n    set: function (value) {\n      const currentValue = uniforms[name];\n      uniforms[name] = value;\n      const actualUniforms = stage._actualUniforms;\n      const actualValue = actualUniforms[name];\n      if (defined(actualValue) && actualValue !== currentValue && actualValue instanceof Texture && !defined(stage._textureCache.getStageByName(name))) {\n        stage._texturesToRelease.push(actualValue);\n        delete actualUniforms[name];\n        delete actualUniforms[`${name}Dimensions`];\n      }\n      if (currentValue instanceof Texture) {\n        stage._texturesToRelease.push(currentValue);\n      }\n      if (typeof value === \"string\" || value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof HTMLVideoElement || value instanceof ImageData) {\n        stage._dirtyUniforms.push(name);\n      } else {\n        actualUniforms[name] = value;\n      }\n    }\n  };\n}\nfunction getUniformMapFunction(stage, name) {\n  return function () {\n    const value = stage._actualUniforms[name];\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  };\n}\nfunction getUniformMapDimensionsFunction(uniformMap, name) {\n  return function () {\n    const texture = uniformMap[name]();\n    if (defined(texture)) {\n      return texture.dimensions;\n    }\n    return undefined;\n  };\n}\nfunction createUniformMap(stage) {\n  if (defined(stage._uniformMap)) {\n    return;\n  }\n  const uniformMap = {};\n  const newUniforms = {};\n  const uniforms = stage._uniforms;\n  const actualUniforms = stage._actualUniforms;\n  for (const name in uniforms) {\n    if (!uniforms.hasOwnProperty(name)) {\n      continue;\n    }\n    if (typeof uniforms[name] !== \"function\") {\n      uniformMap[name] = getUniformMapFunction(stage, name);\n      newUniforms[name] = getUniformValueGetterAndSetter(stage, uniforms, name);\n    } else {\n      uniformMap[name] = uniforms[name];\n      newUniforms[name] = uniforms[name];\n    }\n    actualUniforms[name] = uniforms[name];\n    const value = uniformMap[name]();\n    if (typeof value === \"string\" || value instanceof Texture || value instanceof HTMLImageElement || value instanceof HTMLCanvasElement || value instanceof HTMLVideoElement) {\n      uniformMap[`${name}Dimensions`] = getUniformMapDimensionsFunction(uniformMap, name);\n    }\n  }\n  stage._uniforms = {};\n  Object.defineProperties(stage._uniforms, newUniforms);\n  stage._uniformMap = combine(uniformMap, {\n    colorTexture: function () {\n      return stage._colorTexture;\n    },\n    colorTextureDimensions: function () {\n      return stage._colorTexture.dimensions;\n    },\n    depthTexture: function () {\n      return stage._depthTexture;\n    },\n    depthTextureDimensions: function () {\n      return stage._depthTexture.dimensions;\n    },\n    czm_idTexture: function () {\n      return stage._idTexture;\n    },\n    czm_selectedIdTexture: function () {\n      return stage._selectedIdTexture;\n    },\n    czm_selectedIdTextureStep: function () {\n      return 1.0 / stage._selectedIdTexture.width;\n    }\n  });\n}\nfunction addSelectedIdToShader(shaderSource, idTextureWidth) {\n  shaderSource = shaderSource.replace(/in\\s+vec2\\s+v_textureCoordinates;/g, \"\");\n  return `#define CZM_SELECTED_FEATURE\nuniform sampler2D czm_idTexture;\nuniform sampler2D czm_selectedIdTexture;\nuniform float czm_selectedIdTextureStep;\nin vec2 v_textureCoordinates;\nbool czm_selected(vec2 offset)\n{\n    bool selected = false;\n    vec4 id = texture(czm_idTexture, v_textureCoordinates + offset);\n    for (int i = 0; i < ${idTextureWidth}; ++i)\n    {\n        vec4 selectedId = texture(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5));\n        if (all(equal(id, selectedId)))\n        {\n            return true;\n        }\n    }\n    return false;\n}\nbool czm_selected()\n{\n    return czm_selected(vec2(0.0));\n}\n\n${shaderSource}`;\n}\nfunction createDrawCommand(stage, context) {\n  if (defined(stage._command) && !stage._logDepthChanged && !stage._selectedDirty) {\n    return;\n  }\n  let fragmentShaderSource = stage._fragmentShader;\n  if (defined(stage._selectedIdTexture)) {\n    const width = stage._selectedIdTexture.width;\n    fragmentShaderSource = addSelectedIdToShader(fragmentShaderSource, width);\n  }\n  const fragmentShader = new ShaderSource({\n    defines: [stage._useLogDepth ? \"LOG_DEPTH\" : \"\"],\n    sources: [fragmentShaderSource]\n  });\n  stage._command = context.createViewportQuadCommand(fragmentShader, {\n    uniformMap: stage._uniformMap,\n    owner: stage\n  });\n}\nfunction createSampler(stage) {\n  const mode = stage._sampleMode;\n  let minFilter;\n  let magFilter;\n  if (mode === PostProcessStageSampleMode.LINEAR) {\n    minFilter = TextureMinificationFilter.LINEAR;\n    magFilter = TextureMagnificationFilter.LINEAR;\n  } else {\n    minFilter = TextureMinificationFilter.NEAREST;\n    magFilter = TextureMagnificationFilter.NEAREST;\n  }\n  const sampler = stage._sampler;\n  if (!defined(sampler) || sampler.minificationFilter !== minFilter || sampler.magnificationFilter !== magFilter) {\n    stage._sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: minFilter,\n      magnificationFilter: magFilter\n    });\n  }\n}\nfunction createLoadImageFunction(stage, name) {\n  return function (image) {\n    stage._texturesToCreate.push({\n      name: name,\n      source: image\n    });\n  };\n}\nfunction createStageOutputTextureFunction(stage, name) {\n  return function () {\n    return stage._textureCache.getOutputTexture(name);\n  };\n}\nfunction updateUniformTextures(stage, context) {\n  const texturesToRelease = stage._texturesToRelease;\n  for (let i = 0; i < texturesToRelease.length; ++i) {\n    let texture = texturesToRelease[i];\n    texture = texture && texture.destroy();\n  }\n  texturesToRelease.length = 0;\n  const texturesToCreate = stage._texturesToCreate;\n  for (let i = 0; i < texturesToCreate.length; ++i) {\n    const {\n      name,\n      source\n    } = texturesToCreate[i];\n    stage._actualUniforms[name] = new Texture({\n      context: context,\n      source: source\n    });\n  }\n  texturesToCreate.length = 0;\n  const dirtyUniforms = stage._dirtyUniforms;\n  if (dirtyUniforms.length === 0 && !defined(stage._texturePromise)) {\n    stage._ready = true;\n    return;\n  }\n  if (dirtyUniforms.length === 0 || defined(stage._texturePromise)) {\n    return;\n  }\n  const uniforms = stage._uniforms;\n  const promises = [];\n  for (let i = 0; i < dirtyUniforms.length; ++i) {\n    const name = dirtyUniforms[i];\n    const stageNameUrlOrImage = uniforms[name];\n    const stageWithName = stage._textureCache.getStageByName(stageNameUrlOrImage);\n    if (defined(stageWithName)) {\n      stage._actualUniforms[name] = createStageOutputTextureFunction(stage, stageNameUrlOrImage);\n    } else if (typeof stageNameUrlOrImage === \"string\") {\n      const resource = new Resource({\n        url: stageNameUrlOrImage\n      });\n      promises.push(resource.fetchImage().then(createLoadImageFunction(stage, name)));\n    } else {\n      stage._texturesToCreate.push({\n        name: name,\n        source: stageNameUrlOrImage\n      });\n    }\n  }\n  dirtyUniforms.length = 0;\n  if (promises.length > 0) {\n    stage._ready = false;\n    stage._texturePromise = Promise.all(promises).then(function () {\n      stage._ready = true;\n      stage._texturePromise = undefined;\n    });\n  } else {\n    stage._ready = true;\n  }\n}\nfunction releaseResources(stage) {\n  if (defined(stage._command)) {\n    stage._command.shaderProgram = stage._command.shaderProgram && stage._command.shaderProgram.destroy();\n    stage._command = undefined;\n  }\n  stage._selectedIdTexture = stage._selectedIdTexture && stage._selectedIdTexture.destroy();\n  const textureCache = stage._textureCache;\n  if (!defined(textureCache)) {\n    return;\n  }\n  const uniforms = stage._uniforms;\n  const actualUniforms = stage._actualUniforms;\n  for (const name in actualUniforms) {\n    if (!actualUniforms.hasOwnProperty(name)) {\n      continue;\n    }\n    const actualUniform = actualUniforms[name];\n    if (actualUniform instanceof Texture) {\n      if (!defined(textureCache.getStageByName(uniforms[name]))) {\n        actualUniform.destroy();\n      }\n      stage._dirtyUniforms.push(name);\n    }\n  }\n}\nfunction isSelectedTextureDirty(stage) {\n  const length = defined(stage._selected) ? stage._selected.length : 0;\n  const parentLength = defined(stage._parentSelected) ? stage._parentSelected : 0;\n  const dirty = stage._selected !== stage._selectedShadow || length !== stage._selectedLength || stage._parentSelected !== stage._parentSelectedShadow || parentLength !== stage._parentSelectedLength;\n  if (defined(stage._selected) && defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._selected.concat(stage._parentSelected);\n  } else if (defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._parentSelected;\n  } else {\n    stage._combinedSelected = stage._selected;\n  }\n  if (!dirty && defined(stage._combinedSelected)) {\n    if (!defined(stage._combinedSelectedShadow)) {\n      return true;\n    }\n    for (let i = 0; i < stage._combinedSelected.length; ++i) {\n      if (stage._combinedSelected[i] !== stage._combinedSelectedShadow[i]) {\n        return true;\n      }\n    }\n  }\n  return dirty;\n}\nfunction createSelectedTexture(stage, context) {\n  if (!stage._selectedDirty) {\n    return;\n  }\n  stage._selectedIdTexture = stage._selectedIdTexture && stage._selectedIdTexture.destroy();\n  stage._selectedIdTexture = undefined;\n  const features = stage._combinedSelected;\n  if (!defined(features)) {\n    return;\n  }\n  let textureLength = 0;\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    if (defined(feature.pickIds)) {\n      textureLength += feature.pickIds.length;\n    } else if (defined(feature.pickId)) {\n      ++textureLength;\n    }\n  }\n  if (features.length === 0 || textureLength === 0) {\n    // max pick id is reserved\n    const empty = new Uint8Array([255, 255, 255, 255]);\n    stage._selectedIdTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: empty,\n        width: 1,\n        height: 1\n      },\n      sampler: Sampler.NEAREST\n    });\n    return;\n  }\n  let offset = 0;\n  const ids = new Uint8Array(textureLength * 4);\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    if (defined(feature.pickIds)) {\n      const pickIds = feature.pickIds;\n      const pickIdsLength = pickIds.length;\n      for (let j = 0; j < pickIdsLength; ++j) {\n        const pickColor = pickIds[j].color;\n        ids[offset] = Color.floatToByte(pickColor.red);\n        ids[offset + 1] = Color.floatToByte(pickColor.green);\n        ids[offset + 2] = Color.floatToByte(pickColor.blue);\n        ids[offset + 3] = Color.floatToByte(pickColor.alpha);\n        offset += 4;\n      }\n    } else if (defined(feature.pickId)) {\n      const pickColor = feature.pickId.color;\n      ids[offset] = Color.floatToByte(pickColor.red);\n      ids[offset + 1] = Color.floatToByte(pickColor.green);\n      ids[offset + 2] = Color.floatToByte(pickColor.blue);\n      ids[offset + 3] = Color.floatToByte(pickColor.alpha);\n      offset += 4;\n    }\n  }\n  stage._selectedIdTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: ids,\n      width: textureLength,\n      height: 1\n    },\n    sampler: Sampler.NEAREST\n  });\n}\n\n/**\n * A function that will be called before execute. Used to create WebGL resources and load any textures.\n * @param {Context} context The context.\n * @param {boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n * @private\n */\nPostProcessStage.prototype.update = function (context, useLogDepth) {\n  if (this.enabled !== this._enabled && !this.enabled) {\n    releaseResources(this);\n  }\n  this._enabled = this.enabled;\n  if (!this._enabled) {\n    return;\n  }\n  this._logDepthChanged = useLogDepth !== this._useLogDepth;\n  this._useLogDepth = useLogDepth;\n  this._selectedDirty = isSelectedTextureDirty(this);\n  this._selectedShadow = this._selected;\n  this._parentSelectedShadow = this._parentSelected;\n  this._combinedSelectedShadow = this._combinedSelected;\n  this._selectedLength = defined(this._selected) ? this._selected.length : 0;\n  this._parentSelectedLength = defined(this._parentSelected) ? this._parentSelected.length : 0;\n  createSelectedTexture(this, context);\n  createUniformMap(this);\n  updateUniformTextures(this, context);\n  createDrawCommand(this, context);\n  createSampler(this);\n  this._selectedDirty = false;\n  if (!this._ready) {\n    return;\n  }\n  const framebuffer = this._textureCache.getFramebuffer(this._name);\n  this._command.framebuffer = framebuffer;\n  if (!defined(framebuffer)) {\n    return;\n  }\n  const colorTexture = framebuffer.getColorTexture(0);\n  let renderState;\n  if (colorTexture.width !== context.drawingBufferWidth || colorTexture.height !== context.drawingBufferHeight) {\n    renderState = this._renderState;\n    if (!defined(renderState) || colorTexture.width !== renderState.viewport.width || colorTexture.height !== renderState.viewport.height) {\n      this._renderState = RenderState.fromCache({\n        viewport: new BoundingRectangle(0, 0, colorTexture.width, colorTexture.height)\n      });\n    }\n  }\n  this._command.renderState = renderState;\n};\n\n/**\n * Executes the post-process stage. The color texture is the texture rendered to by the scene or from the previous stage.\n * @param {Context} context The context.\n * @param {Texture} colorTexture The input color texture.\n * @param {Texture} depthTexture The input depth texture.\n * @param {Texture} idTexture The id texture.\n * @private\n */\nPostProcessStage.prototype.execute = function (context, colorTexture, depthTexture, idTexture) {\n  if (!defined(this._command) || !defined(this._command.framebuffer) || !this._ready || !this._enabled) {\n    return;\n  }\n  this._colorTexture = colorTexture;\n  this._depthTexture = depthTexture;\n  this._idTexture = idTexture;\n  if (!Sampler.equals(this._colorTexture.sampler, this._sampler)) {\n    this._colorTexture.sampler = this._sampler;\n  }\n  const passState = this.scissorRectangle.width > 0 && this.scissorRectangle.height > 0 ? this._passState : undefined;\n  if (defined(passState)) {\n    passState.context = context;\n  }\n  this._command.execute(context, passState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStage#destroy\n */\nPostProcessStage.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStage#isDestroyed\n */\nPostProcessStage.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStage;","map":{"version":3,"names":["BoundingRectangle","Check","Color","combine","createGuid","defaultValue","defined","destroyObject","DeveloperError","PixelFormat","Resource","PassState","PixelDatatype","RenderState","Sampler","ShaderSource","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","PostProcessStageSampleMode","PostProcessStage","options","EMPTY_OBJECT","name","fragmentShader","uniforms","textureScale","forcePowerOfTwo","sampleMode","NEAREST","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","clearColor","BLACK","scissorRectangle","typeOf","string","number","greaterThan","lessThanOrEquals","isColorFormat","_fragmentShader","_uniforms","_textureScale","_forcePowerOfTwo","_sampleMode","_pixelFormat","_pixelDatatype","_clearColor","_uniformMap","undefined","_command","_colorTexture","_depthTexture","_idTexture","_actualUniforms","_dirtyUniforms","_texturesToRelease","_texturesToCreate","_texturePromise","passState","scissorTest","enabled","rectangle","clone","_passState","_ready","_name","_logDepthChanged","_useLogDepth","_selectedIdTexture","_selected","_selectedShadow","_parentSelected","_parentSelectedShadow","_combinedSelected","_combinedSelectedShadow","_selectedLength","_parentSelectedLength","_selectedDirty","_textureCache","_index","_enabled","Object","defineProperties","prototype","ready","get","outputTexture","framebuffer","getFramebuffer","getColorTexture","selected","set","value","parentSelected","depthTextureRegex","_isSupported","context","test","depthTexture","getUniformValueGetterAndSetter","stage","currentValue","HTMLCanvasElement","HTMLImageElement","HTMLVideoElement","ImageData","push","actualUniforms","actualValue","getStageByName","getUniformMapFunction","getUniformMapDimensionsFunction","uniformMap","texture","dimensions","createUniformMap","newUniforms","hasOwnProperty","colorTexture","colorTextureDimensions","depthTextureDimensions","czm_idTexture","czm_selectedIdTexture","czm_selectedIdTextureStep","width","addSelectedIdToShader","shaderSource","idTextureWidth","replace","createDrawCommand","fragmentShaderSource","defines","sources","createViewportQuadCommand","owner","createSampler","mode","minFilter","magFilter","LINEAR","sampler","_sampler","minificationFilter","magnificationFilter","wrapS","CLAMP_TO_EDGE","wrapT","createLoadImageFunction","image","source","createStageOutputTextureFunction","getOutputTexture","updateUniformTextures","texturesToRelease","i","length","destroy","texturesToCreate","dirtyUniforms","promises","stageNameUrlOrImage","stageWithName","resource","url","fetchImage","then","Promise","all","releaseResources","shaderProgram","textureCache","actualUniform","isSelectedTextureDirty","parentLength","dirty","concat","createSelectedTexture","features","textureLength","feature","pickIds","pickId","empty","Uint8Array","arrayBufferView","height","offset","ids","pickIdsLength","j","pickColor","color","floatToByte","red","green","blue","alpha","update","useLogDepth","renderState","drawingBufferWidth","drawingBufferHeight","_renderState","viewport","fromCache","execute","idTexture","equals","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PostProcessStage.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\n\n/**\n * Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.\n *\n * @alias PostProcessStage\n * @constructor\n *\n * @param {object} options An object with the following properties:\n * @param {string} options.fragmentShader The fragment shader to use. The default <code>sampler2D</code> uniforms are <code>colorTexture</code> and <code>depthTexture</code>. The color texture is the output of rendering the scene or the previous stage. The depth texture is the output from rendering the scene. The shader should contain one or both uniforms. There is also a <code>vec2</code> varying named <code>v_textureCoordinates</code> that can be used to sample the textures.\n * @param {object} [options.uniforms] An object whose properties will be used to set the shaders uniforms. The properties can be constant values or a function. A constant value can also be a URI, data URI, or HTML element to use as a texture.\n * @param {number} [options.textureScale=1.0] A number in the range (0.0, 1.0] used to scale the texture dimensions. A scale of 1.0 will render this post-process stage  to a texture the size of the viewport.\n * @param {boolean} [options.forcePowerOfTwo=false] Whether or not to force the texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.\n * @param {PostProcessStageSampleMode} [options.sampleMode=PostProcessStageSampleMode.NEAREST] How to sample the input color texture.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The color pixel format of the output texture.\n * @param {PixelDatatype} [options.pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The pixel data type of the output texture.\n * @param {Color} [options.clearColor=Color.BLACK] The color to clear the output texture to.\n * @param {BoundingRectangle} [options.scissorRectangle] The rectangle to use for the scissor test.\n * @param {string} [options.name=createGuid()] The unique name of this post-process stage for reference by other stages in a composite. If a name is not supplied, a GUID will be generated.\n *\n * @exception {DeveloperError} options.textureScale must be greater than 0.0 and less than or equal to 1.0.\n * @exception {DeveloperError} options.pixelFormat must be a color format.\n * @exception {DeveloperError} When options.pixelDatatype is FLOAT, this WebGL implementation must support floating point textures. Check context.floatingPointTexture.\n *\n * @see PostProcessStageComposite\n *\n * @example\n * // Simple stage to change the color\n * const fs =`\n *     uniform sampler2D colorTexture;\n *     in vec2 v_textureCoordinates;\n *     uniform float scale;\n *     uniform vec3 offset;\n *     void main() {\n *         vec4 color = texture(colorTexture, v_textureCoordinates);\n *         out_FragColor = vec4(color.rgb * scale + offset, 1.0);\n *     }`;\n * scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         scale : 1.1,\n *         offset : function() {\n *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);\n *         }\n *     }\n * }));\n *\n * @example\n * // Simple stage to change the color of what is selected.\n * // If czm_selected returns true, the current fragment belongs to geometry in the selected array.\n * const fs =`\n *     uniform sampler2D colorTexture;\n *     in vec2 v_textureCoordinates;\n *     uniform vec4 highlight;\n *     void main() {\n *         vec4 color = texture(colorTexture, v_textureCoordinates);\n *         if (czm_selected()) {\n *             vec3 highlighted = highlight.a * highlight.rgb + (1.0 - highlight.a) * color.rgb;\n *             out_FragColor = vec4(highlighted, 1.0);\n *         } else {\n *             out_FragColor = color;\n *         }\n *     }`;\n * const stage = scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         highlight : function() {\n *             return new Cesium.Color(1.0, 0.0, 0.0, 0.5);\n *         }\n *     }\n * }));\n * stage.selected = [cesium3DTileFeature];\n */\nfunction PostProcessStage(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    name = createGuid(),\n    fragmentShader,\n    uniforms,\n    textureScale = 1.0,\n    forcePowerOfTwo = false,\n    sampleMode = PostProcessStageSampleMode.NEAREST,\n    pixelFormat = PixelFormat.RGBA,\n    pixelDatatype = PixelDatatype.UNSIGNED_BYTE,\n    clearColor = Color.BLACK,\n    scissorRectangle,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.fragmentShader\", fragmentShader);\n  Check.typeOf.number.greaterThan(\"options.textureScale\", textureScale, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\n    \"options.textureScale\",\n    textureScale,\n    1.0,\n  );\n  if (!PixelFormat.isColorFormat(pixelFormat)) {\n    throw new DeveloperError(\"options.pixelFormat must be a color format.\");\n  }\n  //>>includeEnd('debug');\n\n  this._fragmentShader = fragmentShader;\n  this._uniforms = uniforms;\n  this._textureScale = textureScale;\n  this._forcePowerOfTwo = forcePowerOfTwo;\n  this._sampleMode = sampleMode;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._clearColor = clearColor;\n\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._colorTexture = undefined;\n  this._depthTexture = undefined;\n  this._idTexture = undefined;\n\n  this._actualUniforms = {};\n  this._dirtyUniforms = [];\n  this._texturesToRelease = [];\n  this._texturesToCreate = [];\n  this._texturePromise = undefined;\n\n  const passState = new PassState();\n  passState.scissorTest = {\n    enabled: true,\n    rectangle: defined(scissorRectangle)\n      ? BoundingRectangle.clone(scissorRectangle)\n      : new BoundingRectangle(),\n  };\n  this._passState = passState;\n\n  this._ready = false;\n\n  this._name = name;\n\n  this._logDepthChanged = undefined;\n  this._useLogDepth = undefined;\n\n  this._selectedIdTexture = undefined;\n  this._selected = undefined;\n  this._selectedShadow = undefined;\n  this._parentSelected = undefined;\n  this._parentSelectedShadow = undefined;\n  this._combinedSelected = undefined;\n  this._combinedSelectedShadow = undefined;\n  this._selectedLength = 0;\n  this._parentSelectedLength = 0;\n  this._selectedDirty = true;\n\n  // set by PostProcessStageCollection\n  this._textureCache = undefined;\n  this._index = undefined;\n\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @type {boolean}\n   */\n  this.enabled = true;\n  this._enabled = true;\n}\n\nObject.defineProperties(PostProcessStage.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>\n   * and {@link PostProcessStage#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures\n   * to load.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages in a {@link PostProcessStageComposite}.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * The fragment shader to use when execute this post-process stage.\n   * <p>\n   * The shader must contain a sampler uniform declaration for <code>colorTexture</code>, <code>depthTexture</code>,\n   * or both.\n   * </p>\n   * <p>\n   * The shader must contain a <code>vec2</code> varying declaration for <code>v_textureCoordinates</code> for sampling\n   * the texture uniforms.\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {string}\n   * @readonly\n   */\n  fragmentShader: {\n    get: function () {\n      return this._fragmentShader;\n    },\n  },\n  /**\n   * An object whose properties are used to set the uniforms of the fragment shader.\n   * <p>\n   * The object property values can be either a constant or a function. The function will be called\n   * each frame before the post-process stage is executed.\n   * </p>\n   * <p>\n   * A constant value can also be a URI to an image, a data URI, or an HTML element that can be used as a texture, such as HTMLImageElement or HTMLCanvasElement.\n   * </p>\n   * <p>\n   * If this post-process stage is part of a {@link PostProcessStageComposite} that does not execute in series, the constant value can also be\n   * the name of another stage in a composite. This will set the uniform to the output texture the stage with that name.\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {object}\n   * @readonly\n   */\n  uniforms: {\n    get: function () {\n      return this._uniforms;\n    },\n  },\n  /**\n   * A number in the range (0.0, 1.0] used to scale the output texture dimensions. A scale of 1.0 will render this post-process stage to a texture the size of the viewport.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {number}\n   * @readonly\n   */\n  textureScale: {\n    get: function () {\n      return this._textureScale;\n    },\n  },\n  /**\n   * Whether or not to force the output texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {number}\n   * @readonly\n   */\n  forcePowerOfTwo: {\n    get: function () {\n      return this._forcePowerOfTwo;\n    },\n  },\n  /**\n   * How to sample the input color texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PostProcessStageSampleMode}\n   * @readonly\n   */\n  sampleMode: {\n    get: function () {\n      return this._sampleMode;\n    },\n  },\n  /**\n   * The color pixel format of the output texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PixelFormat}\n   * @readonly\n   */\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  /**\n   * The pixel data type of the output texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PixelDatatype}\n   * @readonly\n   */\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  /**\n   * The color to clear the output texture to.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Color}\n   * @readonly\n   */\n  clearColor: {\n    get: function () {\n      return this._clearColor;\n    },\n  },\n  /**\n   * The {@link BoundingRectangle} to use for the scissor test. A default bounding rectangle will disable the scissor test.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {BoundingRectangle}\n   * @readonly\n   */\n  scissorRectangle: {\n    get: function () {\n      return this._passState.scissorTest.rectangle;\n    },\n  },\n  /**\n   * A reference to the texture written to when executing this post process stage.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      if (defined(this._textureCache)) {\n        const framebuffer = this._textureCache.getFramebuffer(this._name);\n        if (defined(framebuffer)) {\n          return framebuffer.getColorTexture(0);\n        }\n      }\n      return undefined;\n    },\n  },\n  /**\n   * The features selected for applying the post-process.\n   * <p>\n   * In the fragment shader, use <code>czm_selected</code> to determine whether or not to apply the post-process\n   * stage to that fragment. For example:\n   * <code>\n   * if (czm_selected(v_textureCoordinates)) {\n   *     // apply post-process stage\n   * } else {\n   *     out_FragColor = texture(colorTexture, v_textureCoordinates);\n   * }\n   * </code>\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Array}\n   */\n  selected: {\n    get: function () {\n      return this._selected;\n    },\n    set: function (value) {\n      this._selected = value;\n    },\n  },\n  /**\n   * @private\n   */\n  parentSelected: {\n    get: function () {\n      return this._parentSelected;\n    },\n    set: function (value) {\n      this._parentSelected = value;\n    },\n  },\n});\n\nconst depthTextureRegex = /uniform\\s+sampler2D\\s+depthTexture/g;\n\n/**\n * @private\n */\nPostProcessStage.prototype._isSupported = function (context) {\n  return !depthTextureRegex.test(this._fragmentShader) || context.depthTexture;\n};\n\nfunction getUniformValueGetterAndSetter(stage, uniforms, name) {\n  const currentValue = uniforms[name];\n  if (\n    typeof currentValue === \"string\" ||\n    currentValue instanceof HTMLCanvasElement ||\n    currentValue instanceof HTMLImageElement ||\n    currentValue instanceof HTMLVideoElement ||\n    currentValue instanceof ImageData\n  ) {\n    stage._dirtyUniforms.push(name);\n  }\n\n  return {\n    get: function () {\n      return uniforms[name];\n    },\n    set: function (value) {\n      const currentValue = uniforms[name];\n      uniforms[name] = value;\n\n      const actualUniforms = stage._actualUniforms;\n      const actualValue = actualUniforms[name];\n      if (\n        defined(actualValue) &&\n        actualValue !== currentValue &&\n        actualValue instanceof Texture &&\n        !defined(stage._textureCache.getStageByName(name))\n      ) {\n        stage._texturesToRelease.push(actualValue);\n        delete actualUniforms[name];\n        delete actualUniforms[`${name}Dimensions`];\n      }\n\n      if (currentValue instanceof Texture) {\n        stage._texturesToRelease.push(currentValue);\n      }\n\n      if (\n        typeof value === \"string\" ||\n        value instanceof HTMLCanvasElement ||\n        value instanceof HTMLImageElement ||\n        value instanceof HTMLVideoElement ||\n        value instanceof ImageData\n      ) {\n        stage._dirtyUniforms.push(name);\n      } else {\n        actualUniforms[name] = value;\n      }\n    },\n  };\n}\n\nfunction getUniformMapFunction(stage, name) {\n  return function () {\n    const value = stage._actualUniforms[name];\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  };\n}\n\nfunction getUniformMapDimensionsFunction(uniformMap, name) {\n  return function () {\n    const texture = uniformMap[name]();\n    if (defined(texture)) {\n      return texture.dimensions;\n    }\n    return undefined;\n  };\n}\n\nfunction createUniformMap(stage) {\n  if (defined(stage._uniformMap)) {\n    return;\n  }\n\n  const uniformMap = {};\n  const newUniforms = {};\n  const uniforms = stage._uniforms;\n  const actualUniforms = stage._actualUniforms;\n  for (const name in uniforms) {\n    if (!uniforms.hasOwnProperty(name)) {\n      continue;\n    }\n    if (typeof uniforms[name] !== \"function\") {\n      uniformMap[name] = getUniformMapFunction(stage, name);\n      newUniforms[name] = getUniformValueGetterAndSetter(stage, uniforms, name);\n    } else {\n      uniformMap[name] = uniforms[name];\n      newUniforms[name] = uniforms[name];\n    }\n\n    actualUniforms[name] = uniforms[name];\n\n    const value = uniformMap[name]();\n    if (\n      typeof value === \"string\" ||\n      value instanceof Texture ||\n      value instanceof HTMLImageElement ||\n      value instanceof HTMLCanvasElement ||\n      value instanceof HTMLVideoElement\n    ) {\n      uniformMap[`${name}Dimensions`] = getUniformMapDimensionsFunction(\n        uniformMap,\n        name,\n      );\n    }\n  }\n\n  stage._uniforms = {};\n  Object.defineProperties(stage._uniforms, newUniforms);\n\n  stage._uniformMap = combine(uniformMap, {\n    colorTexture: function () {\n      return stage._colorTexture;\n    },\n    colorTextureDimensions: function () {\n      return stage._colorTexture.dimensions;\n    },\n    depthTexture: function () {\n      return stage._depthTexture;\n    },\n    depthTextureDimensions: function () {\n      return stage._depthTexture.dimensions;\n    },\n    czm_idTexture: function () {\n      return stage._idTexture;\n    },\n    czm_selectedIdTexture: function () {\n      return stage._selectedIdTexture;\n    },\n    czm_selectedIdTextureStep: function () {\n      return 1.0 / stage._selectedIdTexture.width;\n    },\n  });\n}\n\nfunction addSelectedIdToShader(shaderSource, idTextureWidth) {\n  shaderSource = shaderSource.replace(/in\\s+vec2\\s+v_textureCoordinates;/g, \"\");\n  return `#define CZM_SELECTED_FEATURE\nuniform sampler2D czm_idTexture;\nuniform sampler2D czm_selectedIdTexture;\nuniform float czm_selectedIdTextureStep;\nin vec2 v_textureCoordinates;\nbool czm_selected(vec2 offset)\n{\n    bool selected = false;\n    vec4 id = texture(czm_idTexture, v_textureCoordinates + offset);\n    for (int i = 0; i < ${idTextureWidth}; ++i)\n    {\n        vec4 selectedId = texture(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5));\n        if (all(equal(id, selectedId)))\n        {\n            return true;\n        }\n    }\n    return false;\n}\nbool czm_selected()\n{\n    return czm_selected(vec2(0.0));\n}\n\n${shaderSource}`;\n}\n\nfunction createDrawCommand(stage, context) {\n  if (\n    defined(stage._command) &&\n    !stage._logDepthChanged &&\n    !stage._selectedDirty\n  ) {\n    return;\n  }\n\n  let fragmentShaderSource = stage._fragmentShader;\n  if (defined(stage._selectedIdTexture)) {\n    const width = stage._selectedIdTexture.width;\n    fragmentShaderSource = addSelectedIdToShader(fragmentShaderSource, width);\n  }\n\n  const fragmentShader = new ShaderSource({\n    defines: [stage._useLogDepth ? \"LOG_DEPTH\" : \"\"],\n    sources: [fragmentShaderSource],\n  });\n  stage._command = context.createViewportQuadCommand(fragmentShader, {\n    uniformMap: stage._uniformMap,\n    owner: stage,\n  });\n}\n\nfunction createSampler(stage) {\n  const mode = stage._sampleMode;\n\n  let minFilter;\n  let magFilter;\n\n  if (mode === PostProcessStageSampleMode.LINEAR) {\n    minFilter = TextureMinificationFilter.LINEAR;\n    magFilter = TextureMagnificationFilter.LINEAR;\n  } else {\n    minFilter = TextureMinificationFilter.NEAREST;\n    magFilter = TextureMagnificationFilter.NEAREST;\n  }\n\n  const sampler = stage._sampler;\n  if (\n    !defined(sampler) ||\n    sampler.minificationFilter !== minFilter ||\n    sampler.magnificationFilter !== magFilter\n  ) {\n    stage._sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: minFilter,\n      magnificationFilter: magFilter,\n    });\n  }\n}\n\nfunction createLoadImageFunction(stage, name) {\n  return function (image) {\n    stage._texturesToCreate.push({\n      name: name,\n      source: image,\n    });\n  };\n}\n\nfunction createStageOutputTextureFunction(stage, name) {\n  return function () {\n    return stage._textureCache.getOutputTexture(name);\n  };\n}\n\nfunction updateUniformTextures(stage, context) {\n  const texturesToRelease = stage._texturesToRelease;\n  for (let i = 0; i < texturesToRelease.length; ++i) {\n    let texture = texturesToRelease[i];\n    texture = texture && texture.destroy();\n  }\n  texturesToRelease.length = 0;\n\n  const texturesToCreate = stage._texturesToCreate;\n  for (let i = 0; i < texturesToCreate.length; ++i) {\n    const { name, source } = texturesToCreate[i];\n    stage._actualUniforms[name] = new Texture({\n      context: context,\n      source: source,\n    });\n  }\n  texturesToCreate.length = 0;\n\n  const dirtyUniforms = stage._dirtyUniforms;\n  if (dirtyUniforms.length === 0 && !defined(stage._texturePromise)) {\n    stage._ready = true;\n    return;\n  }\n\n  if (dirtyUniforms.length === 0 || defined(stage._texturePromise)) {\n    return;\n  }\n\n  const uniforms = stage._uniforms;\n  const promises = [];\n  for (let i = 0; i < dirtyUniforms.length; ++i) {\n    const name = dirtyUniforms[i];\n    const stageNameUrlOrImage = uniforms[name];\n    const stageWithName =\n      stage._textureCache.getStageByName(stageNameUrlOrImage);\n    if (defined(stageWithName)) {\n      stage._actualUniforms[name] = createStageOutputTextureFunction(\n        stage,\n        stageNameUrlOrImage,\n      );\n    } else if (typeof stageNameUrlOrImage === \"string\") {\n      const resource = new Resource({\n        url: stageNameUrlOrImage,\n      });\n\n      promises.push(\n        resource.fetchImage().then(createLoadImageFunction(stage, name)),\n      );\n    } else {\n      stage._texturesToCreate.push({\n        name: name,\n        source: stageNameUrlOrImage,\n      });\n    }\n  }\n\n  dirtyUniforms.length = 0;\n\n  if (promises.length > 0) {\n    stage._ready = false;\n    stage._texturePromise = Promise.all(promises).then(function () {\n      stage._ready = true;\n      stage._texturePromise = undefined;\n    });\n  } else {\n    stage._ready = true;\n  }\n}\n\nfunction releaseResources(stage) {\n  if (defined(stage._command)) {\n    stage._command.shaderProgram =\n      stage._command.shaderProgram && stage._command.shaderProgram.destroy();\n    stage._command = undefined;\n  }\n\n  stage._selectedIdTexture =\n    stage._selectedIdTexture && stage._selectedIdTexture.destroy();\n\n  const textureCache = stage._textureCache;\n  if (!defined(textureCache)) {\n    return;\n  }\n\n  const uniforms = stage._uniforms;\n  const actualUniforms = stage._actualUniforms;\n  for (const name in actualUniforms) {\n    if (!actualUniforms.hasOwnProperty(name)) {\n      continue;\n    }\n    const actualUniform = actualUniforms[name];\n    if (actualUniform instanceof Texture) {\n      if (!defined(textureCache.getStageByName(uniforms[name]))) {\n        actualUniform.destroy();\n      }\n      stage._dirtyUniforms.push(name);\n    }\n  }\n}\n\nfunction isSelectedTextureDirty(stage) {\n  const length = defined(stage._selected) ? stage._selected.length : 0;\n  const parentLength = defined(stage._parentSelected)\n    ? stage._parentSelected\n    : 0;\n  const dirty =\n    stage._selected !== stage._selectedShadow ||\n    length !== stage._selectedLength ||\n    stage._parentSelected !== stage._parentSelectedShadow ||\n    parentLength !== stage._parentSelectedLength;\n\n  if (defined(stage._selected) && defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._selected.concat(stage._parentSelected);\n  } else if (defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._parentSelected;\n  } else {\n    stage._combinedSelected = stage._selected;\n  }\n\n  if (!dirty && defined(stage._combinedSelected)) {\n    if (!defined(stage._combinedSelectedShadow)) {\n      return true;\n    }\n\n    for (let i = 0; i < stage._combinedSelected.length; ++i) {\n      if (stage._combinedSelected[i] !== stage._combinedSelectedShadow[i]) {\n        return true;\n      }\n    }\n  }\n  return dirty;\n}\n\nfunction createSelectedTexture(stage, context) {\n  if (!stage._selectedDirty) {\n    return;\n  }\n\n  stage._selectedIdTexture =\n    stage._selectedIdTexture && stage._selectedIdTexture.destroy();\n  stage._selectedIdTexture = undefined;\n\n  const features = stage._combinedSelected;\n  if (!defined(features)) {\n    return;\n  }\n\n  let textureLength = 0;\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    if (defined(feature.pickIds)) {\n      textureLength += feature.pickIds.length;\n    } else if (defined(feature.pickId)) {\n      ++textureLength;\n    }\n  }\n\n  if (features.length === 0 || textureLength === 0) {\n    // max pick id is reserved\n    const empty = new Uint8Array([255, 255, 255, 255]);\n    stage._selectedIdTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: empty,\n        width: 1,\n        height: 1,\n      },\n      sampler: Sampler.NEAREST,\n    });\n    return;\n  }\n\n  let offset = 0;\n  const ids = new Uint8Array(textureLength * 4);\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    if (defined(feature.pickIds)) {\n      const pickIds = feature.pickIds;\n      const pickIdsLength = pickIds.length;\n      for (let j = 0; j < pickIdsLength; ++j) {\n        const pickColor = pickIds[j].color;\n        ids[offset] = Color.floatToByte(pickColor.red);\n        ids[offset + 1] = Color.floatToByte(pickColor.green);\n        ids[offset + 2] = Color.floatToByte(pickColor.blue);\n        ids[offset + 3] = Color.floatToByte(pickColor.alpha);\n        offset += 4;\n      }\n    } else if (defined(feature.pickId)) {\n      const pickColor = feature.pickId.color;\n      ids[offset] = Color.floatToByte(pickColor.red);\n      ids[offset + 1] = Color.floatToByte(pickColor.green);\n      ids[offset + 2] = Color.floatToByte(pickColor.blue);\n      ids[offset + 3] = Color.floatToByte(pickColor.alpha);\n      offset += 4;\n    }\n  }\n\n  stage._selectedIdTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: ids,\n      width: textureLength,\n      height: 1,\n    },\n    sampler: Sampler.NEAREST,\n  });\n}\n\n/**\n * A function that will be called before execute. Used to create WebGL resources and load any textures.\n * @param {Context} context The context.\n * @param {boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n * @private\n */\nPostProcessStage.prototype.update = function (context, useLogDepth) {\n  if (this.enabled !== this._enabled && !this.enabled) {\n    releaseResources(this);\n  }\n\n  this._enabled = this.enabled;\n  if (!this._enabled) {\n    return;\n  }\n\n  this._logDepthChanged = useLogDepth !== this._useLogDepth;\n  this._useLogDepth = useLogDepth;\n\n  this._selectedDirty = isSelectedTextureDirty(this);\n\n  this._selectedShadow = this._selected;\n  this._parentSelectedShadow = this._parentSelected;\n  this._combinedSelectedShadow = this._combinedSelected;\n  this._selectedLength = defined(this._selected) ? this._selected.length : 0;\n  this._parentSelectedLength = defined(this._parentSelected)\n    ? this._parentSelected.length\n    : 0;\n\n  createSelectedTexture(this, context);\n  createUniformMap(this);\n  updateUniformTextures(this, context);\n  createDrawCommand(this, context);\n  createSampler(this);\n\n  this._selectedDirty = false;\n\n  if (!this._ready) {\n    return;\n  }\n\n  const framebuffer = this._textureCache.getFramebuffer(this._name);\n  this._command.framebuffer = framebuffer;\n\n  if (!defined(framebuffer)) {\n    return;\n  }\n\n  const colorTexture = framebuffer.getColorTexture(0);\n  let renderState;\n  if (\n    colorTexture.width !== context.drawingBufferWidth ||\n    colorTexture.height !== context.drawingBufferHeight\n  ) {\n    renderState = this._renderState;\n    if (\n      !defined(renderState) ||\n      colorTexture.width !== renderState.viewport.width ||\n      colorTexture.height !== renderState.viewport.height\n    ) {\n      this._renderState = RenderState.fromCache({\n        viewport: new BoundingRectangle(\n          0,\n          0,\n          colorTexture.width,\n          colorTexture.height,\n        ),\n      });\n    }\n  }\n\n  this._command.renderState = renderState;\n};\n\n/**\n * Executes the post-process stage. The color texture is the texture rendered to by the scene or from the previous stage.\n * @param {Context} context The context.\n * @param {Texture} colorTexture The input color texture.\n * @param {Texture} depthTexture The input depth texture.\n * @param {Texture} idTexture The id texture.\n * @private\n */\nPostProcessStage.prototype.execute = function (\n  context,\n  colorTexture,\n  depthTexture,\n  idTexture,\n) {\n  if (\n    !defined(this._command) ||\n    !defined(this._command.framebuffer) ||\n    !this._ready ||\n    !this._enabled\n  ) {\n    return;\n  }\n\n  this._colorTexture = colorTexture;\n  this._depthTexture = depthTexture;\n  this._idTexture = idTexture;\n\n  if (!Sampler.equals(this._colorTexture.sampler, this._sampler)) {\n    this._colorTexture.sampler = this._sampler;\n  }\n\n  const passState =\n    this.scissorRectangle.width > 0 && this.scissorRectangle.height > 0\n      ? this._passState\n      : undefined;\n  if (defined(passState)) {\n    passState.context = context;\n  }\n\n  this._command.execute(context, passState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStage#destroy\n */\nPostProcessStage.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStage#isDestroyed\n */\nPostProcessStage.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStage;\n"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;EACE7C,cAAc,EAAE;IACdiE,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC9C,eAAe;IAC7B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACElB,QAAQ,EAAE;IACRgE,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC7C,SAAS;IACvB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACElB,YAAY,EAAE;IACZ+D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC5C,aAAa;IAC3B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACElB,eAAe,EAAE;IACf8D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC3C,gBAAgB;IAC9B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACElB,UAAU,EAAE;IACV6D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC1C,WAAW;IACzB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEjB,WAAW,EAAE;IACX2D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACzC,YAAY;IAC1B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEhB,aAAa,EAAE;IACbyD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxC,cAAc;IAC5B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEf,UAAU,EAAE;IACVuD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACvC,WAAW;IACzB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACEd,gBAAgB,EAAE;IAChBqD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACtB,UAAU,CAACJ,WAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}