{"ast":null,"code":"import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\n\n/**\n * Creates a minimal amount of textures and framebuffers.\n *\n * @alias PostProcessStageTextureCache\n * @constructor\n *\n * @param {PostProcessStageCollection} postProcessStageCollection The post process collection.\n *\n * @private\n */\nfunction PostProcessStageTextureCache(postProcessStageCollection) {\n  this._collection = postProcessStageCollection;\n  this._framebuffers = [];\n  this._stageNameToFramebuffer = {};\n  this._width = undefined;\n  this._height = undefined;\n  this._updateDependencies = false;\n}\nfunction getLastStageName(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.name;\n}\nfunction getStageDependencies(collection, context, dependencies, stage, previousName) {\n  if (!stage.enabled || !stage._isSupported(context)) {\n    return previousName;\n  }\n  const stageDependencies = dependencies[stage.name] = {};\n  if (defined(previousName)) {\n    const previous = collection.getStageByName(previousName);\n    stageDependencies[getLastStageName(previous)] = true;\n  }\n  const uniforms = stage.uniforms;\n  if (defined(uniforms)) {\n    const uniformNames = Object.getOwnPropertyNames(uniforms);\n    const uniformNamesLength = uniformNames.length;\n    for (let i = 0; i < uniformNamesLength; ++i) {\n      const value = uniforms[uniformNames[i]];\n      if (typeof value === \"string\") {\n        const dependent = collection.getStageByName(value);\n        if (defined(dependent)) {\n          stageDependencies[getLastStageName(dependent)] = true;\n        }\n      }\n    }\n  }\n  return stage.name;\n}\nfunction getCompositeDependencies(collection, context, dependencies, composite, previousName) {\n  if (defined(composite.enabled) && !composite.enabled || defined(composite._isSupported) && !composite._isSupported(context)) {\n    return previousName;\n  }\n  const originalDependency = previousName;\n  const inSeries = !defined(composite.inputPreviousStageTexture) || composite.inputPreviousStageTexture;\n  let currentName = previousName;\n  const length = composite.length;\n  for (let i = 0; i < length; ++i) {\n    const stage = composite.get(i);\n    if (defined(stage.length)) {\n      currentName = getCompositeDependencies(collection, context, dependencies, stage, previousName);\n    } else {\n      currentName = getStageDependencies(collection, context, dependencies, stage, previousName);\n    }\n    // Stages in a series only depend on the previous stage\n    if (inSeries) {\n      previousName = currentName;\n    }\n  }\n\n  // Stages not in a series depend on every stage executed before it since it could reference it as a uniform.\n  // This prevents looking at the dependencies of each stage in the composite, but might create more framebuffers than necessary.\n  // In practice, there are only 2-3 stages in these composites.\n  let j;\n  let name;\n  if (!inSeries) {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      const currentDependencies = dependencies[name];\n      for (let k = 0; k < j; ++k) {\n        currentDependencies[getLastStageName(composite.get(k))] = true;\n      }\n    }\n  } else {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      if (!defined(dependencies[name])) {\n        dependencies[name] = {};\n      }\n      dependencies[name][originalDependency] = true;\n    }\n  }\n  return currentName;\n}\nfunction getDependencies(collection, context) {\n  const dependencies = {};\n  if (defined(collection.ambientOcclusion)) {\n    const ao = collection.ambientOcclusion;\n    const bloom = collection.bloom;\n    const tonemapping = collection._tonemapping;\n    const fxaa = collection.fxaa;\n    let previousName = getCompositeDependencies(collection, context, dependencies, ao, undefined);\n    previousName = getCompositeDependencies(collection, context, dependencies, bloom, previousName);\n    previousName = getStageDependencies(collection, context, dependencies, tonemapping, previousName);\n    previousName = getCompositeDependencies(collection, context, dependencies, collection, previousName);\n    getStageDependencies(collection, context, dependencies, fxaa, previousName);\n  } else {\n    getCompositeDependencies(collection, context, dependencies, collection, undefined);\n  }\n  return dependencies;\n}\nfunction getFramebuffer(cache, stageName, dependencies) {\n  const collection = cache._collection;\n  const stage = collection.getStageByName(stageName);\n  const textureScale = stage._textureScale;\n  const forcePowerOfTwo = stage._forcePowerOfTwo;\n  const pixelFormat = stage._pixelFormat;\n  const pixelDatatype = stage._pixelDatatype;\n  const clearColor = stage._clearColor;\n  let i;\n  let framebuffer;\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (i = 0; i < length; ++i) {\n    framebuffer = framebuffers[i];\n    if (textureScale !== framebuffer.textureScale || forcePowerOfTwo !== framebuffer.forcePowerOfTwo || pixelFormat !== framebuffer.pixelFormat || pixelDatatype !== framebuffer.pixelDatatype || !Color.equals(clearColor, framebuffer.clearColor)) {\n      continue;\n    }\n    const stageNames = framebuffer.stages;\n    const stagesLength = stageNames.length;\n    let foundConflict = false;\n    for (let j = 0; j < stagesLength; ++j) {\n      if (dependencies[stageNames[j]]) {\n        foundConflict = true;\n        break;\n      }\n    }\n    if (!foundConflict) {\n      break;\n    }\n  }\n  if (defined(framebuffer) && i < length) {\n    framebuffer.stages.push(stageName);\n    return framebuffer;\n  }\n  framebuffer = {\n    textureScale: textureScale,\n    forcePowerOfTwo: forcePowerOfTwo,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDatatype,\n    clearColor: clearColor,\n    stages: [stageName],\n    buffer: new FramebufferManager({\n      pixelFormat: pixelFormat,\n      pixelDatatype: pixelDatatype\n    }),\n    clear: undefined\n  };\n  framebuffers.push(framebuffer);\n  return framebuffer;\n}\nfunction createFramebuffers(cache, context) {\n  const dependencies = getDependencies(cache._collection, context);\n  for (const stageName in dependencies) {\n    if (dependencies.hasOwnProperty(stageName)) {\n      cache._stageNameToFramebuffer[stageName] = getFramebuffer(cache, stageName, dependencies[stageName]);\n    }\n  }\n}\nfunction releaseResources(cache) {\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    const framebuffer = framebuffers[i];\n    framebuffer.buffer.destroy();\n  }\n}\nfunction updateFramebuffers(cache, context) {\n  const width = cache._width;\n  const height = cache._height;\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    const framebuffer = framebuffers[i];\n    const scale = framebuffer.textureScale;\n    let textureWidth = Math.ceil(width * scale);\n    let textureHeight = Math.ceil(height * scale);\n    let size = Math.min(textureWidth, textureHeight);\n    if (framebuffer.forcePowerOfTwo) {\n      if (!CesiumMath.isPowerOfTwo(size)) {\n        size = CesiumMath.nextPowerOfTwo(size);\n      }\n      textureWidth = size;\n      textureHeight = size;\n    }\n    framebuffer.buffer.update(context, textureWidth, textureHeight);\n    framebuffer.clear = new ClearCommand({\n      color: framebuffer.clearColor,\n      framebuffer: framebuffer.buffer.framebuffer\n    });\n  }\n}\nPostProcessStageTextureCache.prototype.updateDependencies = function () {\n  this._updateDependencies = true;\n};\n\n/**\n * Called before the stages in the collection are executed. Creates the minimum amount of framebuffers for a post-process collection.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.update = function (context) {\n  const collection = this._collection;\n  const updateDependencies = this._updateDependencies;\n  const aoEnabled = defined(collection.ambientOcclusion) && collection.ambientOcclusion.enabled && collection.ambientOcclusion._isSupported(context);\n  const bloomEnabled = defined(collection.bloom) && collection.bloom.enabled && collection.bloom._isSupported(context);\n  const tonemappingEnabled = defined(collection._tonemapping) && collection._tonemapping.enabled && collection._tonemapping._isSupported(context);\n  const fxaaEnabled = defined(collection.fxaa) && collection.fxaa.enabled && collection.fxaa._isSupported(context);\n  const needsCheckDimensionsUpdate = !defined(collection._activeStages) || collection._activeStages.length > 0 || aoEnabled || bloomEnabled || tonemappingEnabled || fxaaEnabled;\n  if (updateDependencies || !needsCheckDimensionsUpdate && this._framebuffers.length > 0) {\n    releaseResources(this);\n    this._framebuffers.length = 0;\n    this._stageNameToFramebuffer = {};\n    this._width = undefined;\n    this._height = undefined;\n  }\n  if (!updateDependencies && !needsCheckDimensionsUpdate) {\n    return;\n  }\n  if (this._framebuffers.length === 0) {\n    createFramebuffers(this, context);\n  }\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  const dimensionsChanged = this._width !== width || this._height !== height;\n  if (!updateDependencies && !dimensionsChanged) {\n    return;\n  }\n  this._width = width;\n  this._height = height;\n  this._updateDependencies = false;\n  releaseResources(this);\n  updateFramebuffers(this, context);\n};\n\n/**\n * Clears all of the framebuffers.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.clear = function (context) {\n  const framebuffers = this._framebuffers;\n  for (let i = 0; i < framebuffers.length; ++i) {\n    framebuffers[i].clear.execute(context);\n  }\n};\n\n/**\n * Gets the stage with the given name.\n * @param {string} name The name of the stage.\n * @return {PostProcessStage|PostProcessStageComposite}\n */\nPostProcessStageTextureCache.prototype.getStageByName = function (name) {\n  return this._collection.getStageByName(name);\n};\n\n/**\n * Gets the output texture for a stage with the given name.\n * @param {string} name The name of the stage.\n * @return {Texture|undefined} The output texture of the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getOutputTexture = function (name) {\n  return this._collection.getOutputTexture(name);\n};\n\n/**\n * Gets the framebuffer for a stage with the given name.\n *\n * @param {string} name The name of the stage.\n * @return {Framebuffer|undefined} The framebuffer for the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getFramebuffer = function (name) {\n  const framebuffer = this._stageNameToFramebuffer[name];\n  if (!defined(framebuffer)) {\n    return undefined;\n  }\n  return framebuffer.buffer.framebuffer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageTextureCache#destroy\n */\nPostProcessStageTextureCache.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageTextureCache#isDestroyed\n */\nPostProcessStageTextureCache.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStageTextureCache;","map":{"version":3,"names":["Color","defined","destroyObject","CesiumMath","ClearCommand","FramebufferManager","PostProcessStageTextureCache","postProcessStageCollection","_collection","_framebuffers","_stageNameToFramebuffer","_width","undefined","_height","_updateDependencies","getLastStageName","stage","length","get","name","getStageDependencies","collection","context","dependencies","previousName","enabled","_isSupported","stageDependencies","previous","getStageByName","uniforms","uniformNames","Object","getOwnPropertyNames","uniformNamesLength","i","value","dependent","getCompositeDependencies","composite","originalDependency","inSeries","inputPreviousStageTexture","currentName","j","currentDependencies","k","getDependencies","ambientOcclusion","ao","bloom","tonemapping","_tonemapping","fxaa","getFramebuffer","cache","stageName","textureScale","_textureScale","forcePowerOfTwo","_forcePowerOfTwo","pixelFormat","_pixelFormat","pixelDatatype","_pixelDatatype","clearColor","_clearColor","framebuffer","framebuffers","equals","stageNames","stages","stagesLength","foundConflict","push","buffer","clear","createFramebuffers","hasOwnProperty","releaseResources","destroy","updateFramebuffers","width","height","scale","textureWidth","Math","ceil","textureHeight","size","min","isPowerOfTwo","nextPowerOfTwo","update","color","prototype","updateDependencies","aoEnabled","bloomEnabled","tonemappingEnabled","fxaaEnabled","needsCheckDimensionsUpdate","_activeStages","drawingBufferWidth","drawingBufferHeight","dimensionsChanged","execute","getOutputTexture","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PostProcessStageTextureCache.js"],"sourcesContent":["import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\n\n/**\n * Creates a minimal amount of textures and framebuffers.\n *\n * @alias PostProcessStageTextureCache\n * @constructor\n *\n * @param {PostProcessStageCollection} postProcessStageCollection The post process collection.\n *\n * @private\n */\nfunction PostProcessStageTextureCache(postProcessStageCollection) {\n  this._collection = postProcessStageCollection;\n\n  this._framebuffers = [];\n  this._stageNameToFramebuffer = {};\n\n  this._width = undefined;\n  this._height = undefined;\n  this._updateDependencies = false;\n}\n\nfunction getLastStageName(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.name;\n}\n\nfunction getStageDependencies(\n  collection,\n  context,\n  dependencies,\n  stage,\n  previousName,\n) {\n  if (!stage.enabled || !stage._isSupported(context)) {\n    return previousName;\n  }\n\n  const stageDependencies = (dependencies[stage.name] = {});\n  if (defined(previousName)) {\n    const previous = collection.getStageByName(previousName);\n    stageDependencies[getLastStageName(previous)] = true;\n  }\n  const uniforms = stage.uniforms;\n  if (defined(uniforms)) {\n    const uniformNames = Object.getOwnPropertyNames(uniforms);\n    const uniformNamesLength = uniformNames.length;\n    for (let i = 0; i < uniformNamesLength; ++i) {\n      const value = uniforms[uniformNames[i]];\n      if (typeof value === \"string\") {\n        const dependent = collection.getStageByName(value);\n        if (defined(dependent)) {\n          stageDependencies[getLastStageName(dependent)] = true;\n        }\n      }\n    }\n  }\n\n  return stage.name;\n}\n\nfunction getCompositeDependencies(\n  collection,\n  context,\n  dependencies,\n  composite,\n  previousName,\n) {\n  if (\n    (defined(composite.enabled) && !composite.enabled) ||\n    (defined(composite._isSupported) && !composite._isSupported(context))\n  ) {\n    return previousName;\n  }\n\n  const originalDependency = previousName;\n\n  const inSeries =\n    !defined(composite.inputPreviousStageTexture) ||\n    composite.inputPreviousStageTexture;\n  let currentName = previousName;\n  const length = composite.length;\n  for (let i = 0; i < length; ++i) {\n    const stage = composite.get(i);\n    if (defined(stage.length)) {\n      currentName = getCompositeDependencies(\n        collection,\n        context,\n        dependencies,\n        stage,\n        previousName,\n      );\n    } else {\n      currentName = getStageDependencies(\n        collection,\n        context,\n        dependencies,\n        stage,\n        previousName,\n      );\n    }\n    // Stages in a series only depend on the previous stage\n    if (inSeries) {\n      previousName = currentName;\n    }\n  }\n\n  // Stages not in a series depend on every stage executed before it since it could reference it as a uniform.\n  // This prevents looking at the dependencies of each stage in the composite, but might create more framebuffers than necessary.\n  // In practice, there are only 2-3 stages in these composites.\n  let j;\n  let name;\n  if (!inSeries) {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      const currentDependencies = dependencies[name];\n      for (let k = 0; k < j; ++k) {\n        currentDependencies[getLastStageName(composite.get(k))] = true;\n      }\n    }\n  } else {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      if (!defined(dependencies[name])) {\n        dependencies[name] = {};\n      }\n      dependencies[name][originalDependency] = true;\n    }\n  }\n\n  return currentName;\n}\n\nfunction getDependencies(collection, context) {\n  const dependencies = {};\n\n  if (defined(collection.ambientOcclusion)) {\n    const ao = collection.ambientOcclusion;\n    const bloom = collection.bloom;\n    const tonemapping = collection._tonemapping;\n    const fxaa = collection.fxaa;\n\n    let previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      ao,\n      undefined,\n    );\n    previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      bloom,\n      previousName,\n    );\n    previousName = getStageDependencies(\n      collection,\n      context,\n      dependencies,\n      tonemapping,\n      previousName,\n    );\n    previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      collection,\n      previousName,\n    );\n    getStageDependencies(collection, context, dependencies, fxaa, previousName);\n  } else {\n    getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      collection,\n      undefined,\n    );\n  }\n\n  return dependencies;\n}\n\nfunction getFramebuffer(cache, stageName, dependencies) {\n  const collection = cache._collection;\n  const stage = collection.getStageByName(stageName);\n\n  const textureScale = stage._textureScale;\n  const forcePowerOfTwo = stage._forcePowerOfTwo;\n  const pixelFormat = stage._pixelFormat;\n  const pixelDatatype = stage._pixelDatatype;\n  const clearColor = stage._clearColor;\n\n  let i;\n  let framebuffer;\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (i = 0; i < length; ++i) {\n    framebuffer = framebuffers[i];\n\n    if (\n      textureScale !== framebuffer.textureScale ||\n      forcePowerOfTwo !== framebuffer.forcePowerOfTwo ||\n      pixelFormat !== framebuffer.pixelFormat ||\n      pixelDatatype !== framebuffer.pixelDatatype ||\n      !Color.equals(clearColor, framebuffer.clearColor)\n    ) {\n      continue;\n    }\n\n    const stageNames = framebuffer.stages;\n    const stagesLength = stageNames.length;\n    let foundConflict = false;\n    for (let j = 0; j < stagesLength; ++j) {\n      if (dependencies[stageNames[j]]) {\n        foundConflict = true;\n        break;\n      }\n    }\n\n    if (!foundConflict) {\n      break;\n    }\n  }\n\n  if (defined(framebuffer) && i < length) {\n    framebuffer.stages.push(stageName);\n    return framebuffer;\n  }\n\n  framebuffer = {\n    textureScale: textureScale,\n    forcePowerOfTwo: forcePowerOfTwo,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDatatype,\n    clearColor: clearColor,\n    stages: [stageName],\n    buffer: new FramebufferManager({\n      pixelFormat: pixelFormat,\n      pixelDatatype: pixelDatatype,\n    }),\n    clear: undefined,\n  };\n\n  framebuffers.push(framebuffer);\n  return framebuffer;\n}\n\nfunction createFramebuffers(cache, context) {\n  const dependencies = getDependencies(cache._collection, context);\n  for (const stageName in dependencies) {\n    if (dependencies.hasOwnProperty(stageName)) {\n      cache._stageNameToFramebuffer[stageName] = getFramebuffer(\n        cache,\n        stageName,\n        dependencies[stageName],\n      );\n    }\n  }\n}\n\nfunction releaseResources(cache) {\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    const framebuffer = framebuffers[i];\n    framebuffer.buffer.destroy();\n  }\n}\n\nfunction updateFramebuffers(cache, context) {\n  const width = cache._width;\n  const height = cache._height;\n\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    const framebuffer = framebuffers[i];\n\n    const scale = framebuffer.textureScale;\n    let textureWidth = Math.ceil(width * scale);\n    let textureHeight = Math.ceil(height * scale);\n\n    let size = Math.min(textureWidth, textureHeight);\n    if (framebuffer.forcePowerOfTwo) {\n      if (!CesiumMath.isPowerOfTwo(size)) {\n        size = CesiumMath.nextPowerOfTwo(size);\n      }\n      textureWidth = size;\n      textureHeight = size;\n    }\n\n    framebuffer.buffer.update(context, textureWidth, textureHeight);\n    framebuffer.clear = new ClearCommand({\n      color: framebuffer.clearColor,\n      framebuffer: framebuffer.buffer.framebuffer,\n    });\n  }\n}\n\nPostProcessStageTextureCache.prototype.updateDependencies = function () {\n  this._updateDependencies = true;\n};\n\n/**\n * Called before the stages in the collection are executed. Creates the minimum amount of framebuffers for a post-process collection.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.update = function (context) {\n  const collection = this._collection;\n  const updateDependencies = this._updateDependencies;\n  const aoEnabled =\n    defined(collection.ambientOcclusion) &&\n    collection.ambientOcclusion.enabled &&\n    collection.ambientOcclusion._isSupported(context);\n  const bloomEnabled =\n    defined(collection.bloom) &&\n    collection.bloom.enabled &&\n    collection.bloom._isSupported(context);\n  const tonemappingEnabled =\n    defined(collection._tonemapping) &&\n    collection._tonemapping.enabled &&\n    collection._tonemapping._isSupported(context);\n  const fxaaEnabled =\n    defined(collection.fxaa) &&\n    collection.fxaa.enabled &&\n    collection.fxaa._isSupported(context);\n  const needsCheckDimensionsUpdate =\n    !defined(collection._activeStages) ||\n    collection._activeStages.length > 0 ||\n    aoEnabled ||\n    bloomEnabled ||\n    tonemappingEnabled ||\n    fxaaEnabled;\n  if (\n    updateDependencies ||\n    (!needsCheckDimensionsUpdate && this._framebuffers.length > 0)\n  ) {\n    releaseResources(this);\n    this._framebuffers.length = 0;\n    this._stageNameToFramebuffer = {};\n    this._width = undefined;\n    this._height = undefined;\n  }\n\n  if (!updateDependencies && !needsCheckDimensionsUpdate) {\n    return;\n  }\n\n  if (this._framebuffers.length === 0) {\n    createFramebuffers(this, context);\n  }\n\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  const dimensionsChanged = this._width !== width || this._height !== height;\n  if (!updateDependencies && !dimensionsChanged) {\n    return;\n  }\n\n  this._width = width;\n  this._height = height;\n  this._updateDependencies = false;\n  releaseResources(this);\n  updateFramebuffers(this, context);\n};\n\n/**\n * Clears all of the framebuffers.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.clear = function (context) {\n  const framebuffers = this._framebuffers;\n  for (let i = 0; i < framebuffers.length; ++i) {\n    framebuffers[i].clear.execute(context);\n  }\n};\n\n/**\n * Gets the stage with the given name.\n * @param {string} name The name of the stage.\n * @return {PostProcessStage|PostProcessStageComposite}\n */\nPostProcessStageTextureCache.prototype.getStageByName = function (name) {\n  return this._collection.getStageByName(name);\n};\n\n/**\n * Gets the output texture for a stage with the given name.\n * @param {string} name The name of the stage.\n * @return {Texture|undefined} The output texture of the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getOutputTexture = function (name) {\n  return this._collection.getOutputTexture(name);\n};\n\n/**\n * Gets the framebuffer for a stage with the given name.\n *\n * @param {string} name The name of the stage.\n * @return {Framebuffer|undefined} The framebuffer for the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getFramebuffer = function (name) {\n  const framebuffer = this._stageNameToFramebuffer[name];\n  if (!defined(framebuffer)) {\n    return undefined;\n  }\n  return framebuffer.buffer.framebuffer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageTextureCache#destroy\n */\nPostProcessStageTextureCache.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageTextureCache#isDestroyed\n */\nPostProcessStageTextureCache.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStageTextureCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}