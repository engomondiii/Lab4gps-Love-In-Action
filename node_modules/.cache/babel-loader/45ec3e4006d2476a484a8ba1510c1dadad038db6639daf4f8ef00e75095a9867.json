{"ast":null,"code":"import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nconst PROJECTION_COUNT = PROJECTIONS.length;\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {number} [options.width=1.0] The screen space width in pixels.\n * @param {number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {number}\n   */\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {boolean}\n   * @default 9999.0\n   */\n  this.granularity = defaultValue(options.granularity, 9999.0);\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {boolean}\n   * @default false\n   */\n  this.loop = defaultValue(options.loop, false);\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._ellipsoid = Ellipsoid.default;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return 1.0 + this._positions.length * 3 + 1.0 + 1.0 + 1.0 + Ellipsoid.packedLength + 1.0 + 1.0;\n    }\n  }\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (groundPolylineGeometry, mapProjection) {\n  let projectionIndex = 0;\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\nconst cart3Scratch1 = new Cartesian3();\nconst cart3Scratch2 = new Cartesian3();\nconst cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n  const up = direction(startTop, startBottom, cart3Scratch2);\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\nconst interpolatedCartographicScratch = new Cartographic();\nconst interpolatedBottomScratch = new Cartesian3();\nconst interpolatedTopScratch = new Cartesian3();\nconst interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {\n  if (granularity === 0.0) {\n    return;\n  }\n  let ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  const interpolatedNormal = computeRightNormal(start, end, maxHeight, ellipsoid, interpolatedNormalScratch);\n  const segments = Math.ceil(surfaceDistance / granularity);\n  const interpointDistance = surfaceDistance / segments;\n  let distanceFromStart = interpointDistance;\n  const pointsToAdd = segments - 1;\n  let packIndex = normalsArray.length;\n  for (let i = 0; i < pointsToAdd; i++) {\n    const interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(distanceFromStart, interpolatedCartographicScratch);\n    const interpolatedBottom = getPosition(ellipsoid, interpolatedCartographic, minHeight, interpolatedBottomScratch);\n    const interpolatedTop = getPosition(ellipsoid, interpolatedCartographic, maxHeight, interpolatedTopScratch);\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\nconst heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(heightlessCartographicScratch, ellipsoid, result);\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n  const positions = value._positions;\n  const positionsLength = positions.length;\n  array[index++] = positionsLength;\n  for (let i = 0; i < positionsLength; ++i) {\n    const cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n  const positionsLength = array[index++];\n  const positions = new Array(positionsLength);\n  for (let i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n  const granularity = array[index++];\n  const loop = array[index++] === 1.0;\n  const arcType = array[index++];\n  const ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n  const projectionIndex = array[index++];\n  const scene3DOnly = array[index++] === 1.0;\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions\n    });\n  }\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n  return result;\n};\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\nconst toPreviousScratch = new Cartesian3();\nconst toNextScratch = new Cartesian3();\nconst forwardScratch = new Cartesian3();\nconst vertexUpScratch = new Cartesian3();\nconst cosine90 = 0.0;\nconst cosine180 = -1.0;\nfunction computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  const toPrevious = tangentDirection(previousBottom, vertexBottom, up, toPreviousScratch);\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (CesiumMath.equalsEpsilon(Cartesian3.dot(toPrevious, toNext), cosine180, CesiumMath.EPSILON5)) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  const forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n  return result;\n}\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\nconst previousBottomScratch = new Cartesian3();\nconst vertexBottomScratch = new Cartesian3();\nconst vertexTopScratch = new Cartesian3();\nconst nextBottomScratch = new Cartesian3();\nconst vertexNormalScratch = new Cartesian3();\nconst intersectionScratch = new Cartesian3();\nconst cartographicScratch0 = new Cartographic();\nconst cartographicScratch1 = new Cartographic();\nconst cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  let loop = groundPolylineGeometry.loop;\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\n  const granularity = groundPolylineGeometry.granularity;\n  const arcType = groundPolylineGeometry.arcType;\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](ellipsoid);\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\n  let index;\n  let i;\n  const positions = groundPolylineGeometry._positions;\n  const positionsLength = positions.length;\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  let p0;\n  let p1;\n  let c0;\n  let c1;\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  let intersection;\n  let intersectionCartographic;\n  let intersectionLongitude;\n  const splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\n    if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\n        intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\n        if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\n    if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\n        intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\n        if (defined(intersection) && !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) && !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  let cartographicsLength = splitPositions.length;\n  let cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    const cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n  cartographics = arrayRemoveDuplicates(cartographics, Cartographic.equalsEpsilon);\n  cartographicsLength = cartographics.length;\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  const cartographicsArray = [];\n  const normalsArray = [];\n  const bottomPositionsArray = [];\n  const topPositionsArray = [];\n  let previousBottom = previousBottomScratch;\n  let vertexBottom = vertexBottomScratch;\n  let vertexTop = vertexTopScratch;\n  let nextBottom = nextBottomScratch;\n  let vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  const startCartographic = cartographics[0];\n  const nextCartographic = cartographics[1];\n  const prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(ellipsoid, prestartCartographic, minHeight, previousBottom);\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(ellipsoid, startCartographic, minHeight, vertexBottom);\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n  } else {\n    vertexNormal = computeRightNormal(startCartographic, nextCartographic, maxHeight, ellipsoid, vertexNormal);\n  }\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n  interpolateSegment(startCartographic, nextCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    const vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n    computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n    interpolateSegment(cartographics[i], cartographics[i + 1], minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  const endCartographic = cartographics[cartographicsLength - 1];\n  const preEndCartographic = cartographics[cartographicsLength - 2];\n  vertexBottom = getPosition(ellipsoid, endCartographic, minHeight, vertexBottom);\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n  if (loop) {\n    const postEndCartographic = cartographics[0];\n    previousBottom = getPosition(ellipsoid, preEndCartographic, minHeight, previousBottom);\n    nextBottom = getPosition(ellipsoid, postEndCartographic, minHeight, nextBottom);\n    vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\n  } else {\n    vertexNormal = computeRightNormal(preEndCartographic, endCartographic, maxHeight, ellipsoid, vertexNormal);\n  }\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n  if (loop) {\n    interpolateSegment(endCartographic, startCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n  return generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes);\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nconst lineDirectionScratch = new Cartesian3();\nconst matrix3Scratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    const angle = dot < MITER_BREAK_LARGE ? CesiumMath.PI_OVER_TWO : -CesiumMath.PI_OVER_TWO;\n    const quaternion = Quaternion.fromAxisAngle(vertexUp, angle, quaternionScratch);\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(rotationMatrix, endGeometryNormal, endGeometryNormal);\n    return true;\n  }\n  return false;\n}\nconst endPosCartographicScratch = new Cartographic();\nconst normalStartpointScratch = new Cartesian3();\nconst normalEndpointScratch = new Cartesian3();\nfunction projectNormal(projection, cartographic, normal, projectedPosition, result) {\n  const position = Cartographic.toCartesian(cartographic, projection._ellipsoid, normalStartpointScratch);\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  let flipNormal = false;\n  const ellipsoid = projection._ellipsoid;\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > CesiumMath.PI_OVER_TWO) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(position, normal, normalEndpointScratch);\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\n  }\n  normalEndpointCartographic.height = 0.0;\n  const normalEndpointProjected = projection.project(normalEndpointCartographic, result);\n  result = Cartesian3.subtract(normalEndpointProjected, projectedPosition, result);\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\nconst adjustHeightNormalScratch = new Cartesian3();\nconst adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  const adjustHeightNormal = Cartesian3.subtract(top, bottom, adjustHeightNormalScratch);\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForBottom, adjustHeightOffsetScratch);\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForTop, adjustHeightOffsetScratch);\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\nconst nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  let offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  const absStartLon = Math.abs(start.longitude);\n  const absEndLon = Math.abs(end.longitude);\n  if (CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\n    const endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\n    const startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\nconst startCartographicScratch = new Cartographic();\nconst endCartographicScratch = new Cartographic();\nconst segmentStartTopScratch = new Cartesian3();\nconst segmentEndTopScratch = new Cartesian3();\nconst segmentStartBottomScratch = new Cartesian3();\nconst segmentEndBottomScratch = new Cartesian3();\nconst segmentStartNormalScratch = new Cartesian3();\nconst segmentEndNormalScratch = new Cartesian3();\nconst getHeightCartographics = [startCartographicScratch, endCartographicScratch];\nconst getHeightRectangleScratch = new Rectangle();\nconst adjustHeightStartTopScratch = new Cartesian3();\nconst adjustHeightEndTopScratch = new Cartesian3();\nconst adjustHeightStartBottomScratch = new Cartesian3();\nconst adjustHeightEndBottomScratch = new Cartesian3();\nconst segmentStart2DScratch = new Cartesian3();\nconst segmentEnd2DScratch = new Cartesian3();\nconst segmentStartNormal2DScratch = new Cartesian3();\nconst segmentEndNormal2DScratch = new Cartesian3();\nconst offsetScratch = new Cartesian3();\nconst startUpScratch = new Cartesian3();\nconst endUpScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst startPlaneNormalScratch = new Cartesian3();\nconst endPlaneNormalScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\nconst encodeScratch2D = new EncodedCartesian3();\nconst forwardOffset2DScratch = new Cartesian3();\nconst right2DScratch = new Cartesian3();\nconst normalNudgeScratch = new Cartesian3();\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nconst REFERENCE_INDICES = [0, 2, 1, 0, 3, 2,\n// right\n0, 7, 3, 0, 4, 7,\n// start\n0, 5, 4, 0, 1, 5,\n// bottom\n5, 7, 4, 5, 6, 7,\n// left\n5, 2, 6, 5, 1, 2,\n// end\n3, 6, 2, 3, 7, 6 // top\n];\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {\n  let i;\n  let index;\n  const ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\n  const vertexCount = segmentCount * 8;\n  const arraySizeVec4 = vertexCount * 4;\n  const indexCount = segmentCount * 36;\n  const indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);\n  const positionsArray = new Float64Array(vertexCount * 3);\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(arraySizeVec4);\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(arraySizeVec4);\n  let startHiLo2D;\n  let offsetAndRight2D;\n  let startEndNormals2D;\n  let texcoordNormalization2D;\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  const cartographicsLength = cartographicsArray.length / 2;\n  let length2D = 0.0;\n  const startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  const endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n  let segmentStartCartesian = segmentStartTopScratch;\n  let segmentEndCartesian = segmentEndTopScratch;\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n      segmentStartCartesian = projection.project(startCartographic, segmentStartCartesian);\n      segmentEndCartesian = projection.project(endCartographic, segmentEndCartesian);\n      length2D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n      index += 2;\n    }\n  }\n\n  // 3D\n  const positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(topPositionsArray, 0, segmentEndCartesian);\n  let length3D = 0.0;\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(segmentEndCartesian, segmentStartCartesian);\n    segmentEndCartesian = Cartesian3.unpack(topPositionsArray, index, segmentEndCartesian);\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  let j;\n  index = 3;\n  let cartographicsIndex = 0;\n  let vec2sWriteIndex = 0;\n  let vec3sWriteIndex = 0;\n  let vec4sWriteIndex = 0;\n  let miterBroken = false;\n  let endBottom = Cartesian3.unpack(bottomPositionsArray, 0, segmentEndBottomScratch);\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  let endGeometryNormal = Cartesian3.unpack(normalsArray, 0, segmentEndNormalScratch);\n  if (loop) {\n    const preEndBottom = Cartesian3.unpack(bottomPositionsArray, bottomPositionsArray.length - 6, segmentStartBottomScratch);\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(endGeometryNormal, endGeometryNormal);\n    }\n  }\n  let lengthSoFar3D = 0.0;\n  let lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  let sumHeights = 0.0;\n  for (i = 0; i < segmentCount; i++) {\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    let startGeometryNormal = Cartesian3.clone(endGeometryNormal, segmentStartNormalScratch);\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(startGeometryNormal, startGeometryNormal);\n    }\n    endBottom = Cartesian3.unpack(bottomPositionsArray, index, segmentEndBottomScratch);\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(normalsArray, index, segmentEndNormalScratch);\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    let start2D;\n    let end2D;\n    let startGeometryNormal2D;\n    let endGeometryNormal2D;\n    if (compute2dAttributes) {\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (nudgeResult === 0 || Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\n        endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - Math.abs(endCartographic.longitude));\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - endCartographic.longitude);\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /* 3D */\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\n    const encodedStart = EncodedCartesian3.fromCartesian(startBottom, encodeScratch);\n    const forwardOffset = Cartesian3.subtract(endBottom, startBottom, offsetScratch);\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n    let startPlaneNormal = Cartesian3.cross(startUp, startGeometryNormal, startPlaneNormalScratch);\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    let endPlaneNormal = Cartesian3.cross(endGeometryNormal, endUp, endPlaneNormalScratch);\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n    const texcoordNormalization3DX = segmentLength3D / length3D;\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /* 2D */\n    let segmentLength2D = 0.0;\n    let encodedStart2D;\n    let forwardOffset2D;\n    let right2D;\n    let texcoordNormalization2DX = 0.0;\n    let texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n      encodedStart2D = EncodedCartesian3.fromCartesian(start2D, encodeScratch2D);\n      forwardOffset2D = Cartesian3.subtract(end2D, start2D, forwardOffset2DScratch);\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      const swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      const vec4Index = vec4sWriteIndex + j * 4;\n      const vec2Index = vec2sWriteIndex + j * 2;\n      const wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      const topBottomSide = j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n      Cartesian3.pack(startPlaneNormal, startNormalAndForwardOffsetZ, vec4Index);\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n      Cartesian3.pack(endPlaneNormal, endNormalAndTextureCoordinateNormalizationX, vec4Index);\n      endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;\n      Cartesian3.pack(rightNormal, rightNormalAndTextureCoordinateNormalizationY, vec4Index);\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n        texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\n    const getHeightsRectangle = Rectangle.fromCartographicArray(getHeightCartographics, getHeightRectangleScratch);\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(getHeightsRectangle, ellipsoid);\n    const minHeight = minMaxHeights.minimumTerrainHeight;\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    // Sum using abs() to properly account for negative eleavtions in calculating bounding sphere radius\n    sumHeights += Math.abs(minHeight);\n    sumHeights += Math.abs(maxHeight);\n    adjustHeights(startBottom, startTop, minHeight, maxHeight, adjustHeightStartBottom, adjustHeightStartTop);\n    adjustHeights(endBottom, endTop, minHeight, maxHeight, adjustHeightEndBottom, adjustHeightEndTop);\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    let normalNudge = Cartesian3.multiplyByScalar(rightNormal, CesiumMath.EPSILON5, normalNudgeScratch);\n    Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n    normalNudge = Cartesian3.multiplyByScalar(rightNormal, -2.0 * CesiumMath.EPSILON5, normalNudgeScratch);\n    Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex + 12);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 15);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n    cartographicsIndex += 2;\n    index += 3;\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n  index = 0;\n  let indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n  const boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(bottomPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[0]);\n  BoundingSphere.fromVertices(topPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[1]);\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n  const attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(startHiAndForwardOffsetX),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(startLoAndForwardOffsetY),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(startNormalAndForwardOffsetZ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(endNormalAndTextureCoordinateNormalizationX),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(rightNormalAndTextureCoordinateNormalizationY)\n  };\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D\n    });\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere\n  });\n}\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;","map":{"version":3,"names":["ApproximateTerrainHeights","ArcType","arrayRemoveDuplicates","BoundingSphere","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidGeodesic","EllipsoidRhumbLine","EncodedCartesian3","GeographicProjection","Geometry","GeometryAttribute","IntersectionTests","CesiumMath","Matrix3","Plane","Quaternion","Rectangle","WebMercatorProjection","PROJECTIONS","PROJECTION_COUNT","length","MITER_BREAK_SMALL","Math","cos","toRadians","MITER_BREAK_LARGE","WALL_INITIAL_MIN_HEIGHT","WALL_INITIAL_MAX_HEIGHT","GroundPolylineGeometry","options","EMPTY_OBJECT","positions","arcType","GEODESIC","RHUMB","width","_positions","granularity","loop","_ellipsoid","default","_projectionIndex","_workerName","_scene3DOnly","Object","defineProperties","prototype","packedLength","get","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","i","ellipsoid","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","end","maxHeight","result","startBottom","getPosition","startTop","endBottom","up","direction","forward","cross","normalize","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","pack","push","latitude","longitude","heightlessCartographicScratch","cartographic","height","clone","toCartesian","value","array","startingIndex","typeOf","object","index","positionsLength","cartesian","unpack","Array","scene3DOnly","target","origin","subtract","tangentDirection","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","cosine90","cosine180","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","equalsEpsilon","dot","EPSILON5","add","negate","XZ_PLANE","fromPointNormal","ZERO","UNIT_Y","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","compute2dAttributes","projection","p0","p1","c0","c1","rhumbLine","undefined","intersection","intersectionCartographic","intersectionLongitude","splitPositions","lineSegmentPlane","EPSILON7","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicToCartesian","cartographicsLength","cartographics","fromCartesian","vertexNormal","startCartographic","nextCartographic","prestartCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","quaternionScratch","breakMiter","endGeometryNormal","endTop","lineDirection","vertexUp","angle","PI_OVER_TWO","quaternion","fromAxisAngle","rotationMatrix","fromQuaternion","multiplyByVector","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","projectNormal","normal","projectedPosition","position","normalEndpoint","flipNormal","normalEndpointCartographic","abs","normalEndpointProjected","project","z","adjustHeightNormalScratch","adjustHeightOffsetScratch","adjustHeights","bottom","top","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","multiplyByScalar","distanceForTop","nudgeDirectionScratch","nudgeXZ","startToXZdistance","getPointDistance","endToXZdistance","offset","EPSILON2","nudgeCartographic","absStartLon","absEndLon","PI","EPSILON11","endSign","sign","startSign","startCartographicScratch","endCartographicScratch","segmentStartTopScratch","segmentEndTopScratch","segmentStartBottomScratch","segmentEndBottomScratch","segmentStartNormalScratch","segmentEndNormalScratch","getHeightCartographics","getHeightRectangleScratch","adjustHeightStartTopScratch","adjustHeightEndTopScratch","adjustHeightStartBottomScratch","adjustHeightEndBottomScratch","segmentStart2DScratch","segmentEnd2DScratch","segmentStartNormal2DScratch","segmentEndNormal2DScratch","offsetScratch","startUpScratch","endUpScratch","rightScratch","startPlaneNormalScratch","endPlaneNormalScratch","encodeScratch","encodeScratch2D","forwardOffset2DScratch","right2DScratch","normalNudgeScratch","scratchBoundingSpheres","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","segmentCount","vertexCount","arraySizeVec4","indexCount","indices","Uint32Array","Uint16Array","positionsArray","Float64Array","startHiAndForwardOffsetX","Float32Array","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","length2D","segmentStartCartesian","segmentEndCartesian","distance","length3D","j","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","preEndBottom","lengthSoFar3D","lengthSoFar2D","sumHeights","startGeometryNormal","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","nudgeResult","direction2D","y","x","segmentLength3D","encodedStart","forwardOffset","startUp","rightNormal","startPlaneNormal","endUp","endPlaneNormal","texcoordNormalization3DX","texcoordNormalization3DY","segmentLength2D","encodedStart2D","forwardOffset2D","right2D","texcoordNormalization2DX","texcoordNormalization2DY","swap","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightEndBottom","adjustHeightStartTop","adjustHeightEndTop","getHeightsRectangle","fromCartographicArray","minMaxHeights","getMinimumMaximumHeights","minimumTerrainHeight","maximumTerrainHeight","normalNudge","indexOffset","boundingSpheres","fromVertices","boundingSphere","fromBoundingSpheres","radius","attributes","componentDatatype","DOUBLE","componentsPerAttribute","values","getVec4GeometryAttribute","FLOAT","typedArray","_projectNormal"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/GroundPolylineGeometry.js"],"sourcesContent":["import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nconst PROJECTION_COUNT = PROJECTIONS.length;\n\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {number} [options.width=1.0] The screen space width in pixels.\n * @param {number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {number}\n   */\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {boolean}\n   * @default 9999.0\n   */\n  this.granularity = defaultValue(options.granularity, 9999.0);\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {boolean}\n   * @default false\n   */\n  this.loop = defaultValue(options.loop, false);\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._ellipsoid = Ellipsoid.default;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return (\n        1.0 +\n        this._positions.length * 3 +\n        1.0 +\n        1.0 +\n        1.0 +\n        Ellipsoid.packedLength +\n        1.0 +\n        1.0\n      );\n    },\n  },\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\n  groundPolylineGeometry,\n  mapProjection,\n) {\n  let projectionIndex = 0;\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nconst cart3Scratch1 = new Cartesian3();\nconst cart3Scratch2 = new Cartesian3();\nconst cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n  const up = direction(startTop, startBottom, cart3Scratch2);\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\n\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nconst interpolatedCartographicScratch = new Cartographic();\nconst interpolatedBottomScratch = new Cartesian3();\nconst interpolatedTopScratch = new Cartesian3();\nconst interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(\n  start,\n  end,\n  minHeight,\n  maxHeight,\n  granularity,\n  arcType,\n  ellipsoid,\n  normalsArray,\n  bottomPositionsArray,\n  topPositionsArray,\n  cartographicsArray,\n) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  let ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  const interpolatedNormal = computeRightNormal(\n    start,\n    end,\n    maxHeight,\n    ellipsoid,\n    interpolatedNormalScratch,\n  );\n\n  const segments = Math.ceil(surfaceDistance / granularity);\n  const interpointDistance = surfaceDistance / segments;\n  let distanceFromStart = interpointDistance;\n  const pointsToAdd = segments - 1;\n  let packIndex = normalsArray.length;\n  for (let i = 0; i < pointsToAdd; i++) {\n    const interpolatedCartographic =\n      ellipsoidLine.interpolateUsingSurfaceDistance(\n        distanceFromStart,\n        interpolatedCartographicScratch,\n      );\n    const interpolatedBottom = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      minHeight,\n      interpolatedBottomScratch,\n    );\n    const interpolatedTop = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      maxHeight,\n      interpolatedTopScratch,\n    );\n\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nconst heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(\n    heightlessCartographicScratch,\n    ellipsoid,\n    result,\n  );\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const positionsLength = positions.length;\n\n  array[index++] = positionsLength;\n\n  for (let i = 0; i < positionsLength; ++i) {\n    const cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n  const positionsLength = array[index++];\n  const positions = new Array(positionsLength);\n\n  for (let i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  const granularity = array[index++];\n  const loop = array[index++] === 1.0;\n  const arcType = array[index++];\n\n  const ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n\n  const projectionIndex = array[index++];\n  const scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions,\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nconst toPreviousScratch = new Cartesian3();\nconst toNextScratch = new Cartesian3();\nconst forwardScratch = new Cartesian3();\nconst vertexUpScratch = new Cartesian3();\nconst cosine90 = 0.0;\nconst cosine180 = -1.0;\nfunction computeVertexMiterNormal(\n  previousBottom,\n  vertexBottom,\n  vertexTop,\n  nextBottom,\n  result,\n) {\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  const toPrevious = tangentDirection(\n    previousBottom,\n    vertexBottom,\n    up,\n    toPreviousScratch,\n  );\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (\n    CesiumMath.equalsEpsilon(\n      Cartesian3.dot(toPrevious, toNext),\n      cosine180,\n      CesiumMath.EPSILON5,\n    )\n  ) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  const forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst previousBottomScratch = new Cartesian3();\nconst vertexBottomScratch = new Cartesian3();\nconst vertexTopScratch = new Cartesian3();\nconst nextBottomScratch = new Cartesian3();\nconst vertexNormalScratch = new Cartesian3();\nconst intersectionScratch = new Cartesian3();\nconst cartographicScratch0 = new Cartographic();\nconst cartographicScratch1 = new Cartographic();\nconst cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  let loop = groundPolylineGeometry.loop;\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\n  const granularity = groundPolylineGeometry.granularity;\n  const arcType = groundPolylineGeometry.arcType;\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\n    ellipsoid,\n  );\n\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n  let index;\n  let i;\n\n  const positions = groundPolylineGeometry._positions;\n  const positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  let p0;\n  let p1;\n  let c0;\n  let c1;\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  let intersection;\n  let intersectionCartographic;\n  let intersectionLongitude;\n  const splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch,\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0,\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch,\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch,\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch,\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0,\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch,\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch,\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  let cartographicsLength = splitPositions.length;\n\n  let cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    const cartographic = Cartographic.fromCartesian(\n      splitPositions[i],\n      ellipsoid,\n    );\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(\n    cartographics,\n    Cartographic.equalsEpsilon,\n  );\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  const cartographicsArray = [];\n  const normalsArray = [];\n  const bottomPositionsArray = [];\n  const topPositionsArray = [];\n\n  let previousBottom = previousBottomScratch;\n  let vertexBottom = vertexBottomScratch;\n  let vertexTop = vertexTopScratch;\n  let nextBottom = nextBottomScratch;\n  let vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  const startCartographic = cartographics[0];\n  const nextCartographic = cartographics[1];\n\n  const prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(\n    ellipsoid,\n    prestartCartographic,\n    minHeight,\n    previousBottom,\n  );\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(\n    ellipsoid,\n    startCartographic,\n    minHeight,\n    vertexBottom,\n  );\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal,\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      startCartographic,\n      nextCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal,\n    );\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n\n  interpolateSegment(\n    startCartographic,\n    nextCartographic,\n    minHeight,\n    maxHeight,\n    granularity,\n    arcType,\n    ellipsoid,\n    normalsArray,\n    bottomPositionsArray,\n    topPositionsArray,\n    cartographicsArray,\n  );\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    const vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n    computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal,\n    );\n\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n\n    interpolateSegment(\n      cartographics[i],\n      cartographics[i + 1],\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray,\n    );\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  const endCartographic = cartographics[cartographicsLength - 1];\n  const preEndCartographic = cartographics[cartographicsLength - 2];\n\n  vertexBottom = getPosition(\n    ellipsoid,\n    endCartographic,\n    minHeight,\n    vertexBottom,\n  );\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    const postEndCartographic = cartographics[0];\n    previousBottom = getPosition(\n      ellipsoid,\n      preEndCartographic,\n      minHeight,\n      previousBottom,\n    );\n    nextBottom = getPosition(\n      ellipsoid,\n      postEndCartographic,\n      minHeight,\n      nextBottom,\n    );\n\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal,\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      preEndCartographic,\n      endCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal,\n    );\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(\n      endCartographic,\n      startCartographic,\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray,\n    );\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(\n    loop,\n    projection,\n    bottomPositionsArray,\n    topPositionsArray,\n    normalsArray,\n    cartographicsArray,\n    compute2dAttributes,\n  );\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nconst lineDirectionScratch = new Cartesian3();\nconst matrix3Scratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    const angle =\n      dot < MITER_BREAK_LARGE\n        ? CesiumMath.PI_OVER_TWO\n        : -CesiumMath.PI_OVER_TWO;\n    const quaternion = Quaternion.fromAxisAngle(\n      vertexUp,\n      angle,\n      quaternionScratch,\n    );\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(\n      rotationMatrix,\n      endGeometryNormal,\n      endGeometryNormal,\n    );\n    return true;\n  }\n  return false;\n}\n\nconst endPosCartographicScratch = new Cartographic();\nconst normalStartpointScratch = new Cartesian3();\nconst normalEndpointScratch = new Cartesian3();\nfunction projectNormal(\n  projection,\n  cartographic,\n  normal,\n  projectedPosition,\n  result,\n) {\n  const position = Cartographic.toCartesian(\n    cartographic,\n    projection._ellipsoid,\n    normalStartpointScratch,\n  );\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  let flipNormal = false;\n\n  const ellipsoid = projection._ellipsoid;\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n    normalEndpoint,\n    endPosCartographicScratch,\n  );\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\n    CesiumMath.PI_OVER_TWO\n  ) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(\n      position,\n      normal,\n      normalEndpointScratch,\n    );\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n      normalEndpoint,\n      endPosCartographicScratch,\n    );\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  const normalEndpointProjected = projection.project(\n    normalEndpointCartographic,\n    result,\n  );\n  result = Cartesian3.subtract(\n    normalEndpointProjected,\n    projectedPosition,\n    result,\n  );\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\n\nconst adjustHeightNormalScratch = new Cartesian3();\nconst adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(\n  bottom,\n  top,\n  minHeight,\n  maxHeight,\n  adjustHeightBottom,\n  adjustHeightTop,\n) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  const adjustHeightNormal = Cartesian3.subtract(\n    top,\n    bottom,\n    adjustHeightNormalScratch,\n  );\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForBottom,\n    adjustHeightOffsetScratch,\n  );\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForTop,\n    adjustHeightOffsetScratch,\n  );\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nconst nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  let offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\n  ) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  const absStartLon = Math.abs(start.longitude);\n  const absEndLon = Math.abs(end.longitude);\n  if (\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\n\nconst startCartographicScratch = new Cartographic();\nconst endCartographicScratch = new Cartographic();\n\nconst segmentStartTopScratch = new Cartesian3();\nconst segmentEndTopScratch = new Cartesian3();\nconst segmentStartBottomScratch = new Cartesian3();\nconst segmentEndBottomScratch = new Cartesian3();\nconst segmentStartNormalScratch = new Cartesian3();\nconst segmentEndNormalScratch = new Cartesian3();\n\nconst getHeightCartographics = [\n  startCartographicScratch,\n  endCartographicScratch,\n];\nconst getHeightRectangleScratch = new Rectangle();\n\nconst adjustHeightStartTopScratch = new Cartesian3();\nconst adjustHeightEndTopScratch = new Cartesian3();\nconst adjustHeightStartBottomScratch = new Cartesian3();\nconst adjustHeightEndBottomScratch = new Cartesian3();\n\nconst segmentStart2DScratch = new Cartesian3();\nconst segmentEnd2DScratch = new Cartesian3();\nconst segmentStartNormal2DScratch = new Cartesian3();\nconst segmentEndNormal2DScratch = new Cartesian3();\n\nconst offsetScratch = new Cartesian3();\nconst startUpScratch = new Cartesian3();\nconst endUpScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst startPlaneNormalScratch = new Cartesian3();\nconst endPlaneNormalScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n\nconst encodeScratch2D = new EncodedCartesian3();\nconst forwardOffset2DScratch = new Cartesian3();\nconst right2DScratch = new Cartesian3();\n\nconst normalNudgeScratch = new Cartesian3();\n\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nconst REFERENCE_INDICES = [\n  0,\n  2,\n  1,\n  0,\n  3,\n  2, // right\n  0,\n  7,\n  3,\n  0,\n  4,\n  7, // start\n  0,\n  5,\n  4,\n  0,\n  1,\n  5, // bottom\n  5,\n  7,\n  4,\n  5,\n  6,\n  7, // left\n  5,\n  2,\n  6,\n  5,\n  1,\n  2, // end\n  3,\n  6,\n  2,\n  3,\n  7,\n  6, // top\n];\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(\n  loop,\n  projection,\n  bottomPositionsArray,\n  topPositionsArray,\n  normalsArray,\n  cartographicsArray,\n  compute2dAttributes,\n) {\n  let i;\n  let index;\n  const ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\n  const vertexCount = segmentCount * 8;\n  const arraySizeVec4 = vertexCount * 4;\n  const indexCount = segmentCount * 36;\n\n  const indices =\n    vertexCount > 65535\n      ? new Uint32Array(indexCount)\n      : new Uint16Array(indexCount);\n  const positionsArray = new Float64Array(vertexCount * 3);\n\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(\n    arraySizeVec4,\n  );\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\n    arraySizeVec4,\n  );\n\n  let startHiLo2D;\n  let offsetAndRight2D;\n  let startEndNormals2D;\n  let texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  const cartographicsLength = cartographicsArray.length / 2;\n  let length2D = 0.0;\n\n  const startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  const endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n\n  let segmentStartCartesian = segmentStartTopScratch;\n  let segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n\n      segmentStartCartesian = projection.project(\n        startCartographic,\n        segmentStartCartesian,\n      );\n      segmentEndCartesian = projection.project(\n        endCartographic,\n        segmentEndCartesian,\n      );\n      length2D += Cartesian3.distance(\n        segmentStartCartesian,\n        segmentEndCartesian,\n      );\n      index += 2;\n    }\n  }\n\n  // 3D\n  const positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(\n    topPositionsArray,\n    0,\n    segmentEndCartesian,\n  );\n  let length3D = 0.0;\n\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(\n      segmentEndCartesian,\n      segmentStartCartesian,\n    );\n    segmentEndCartesian = Cartesian3.unpack(\n      topPositionsArray,\n      index,\n      segmentEndCartesian,\n    );\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  let j;\n  index = 3;\n  let cartographicsIndex = 0;\n  let vec2sWriteIndex = 0;\n  let vec3sWriteIndex = 0;\n  let vec4sWriteIndex = 0;\n  let miterBroken = false;\n\n  let endBottom = Cartesian3.unpack(\n    bottomPositionsArray,\n    0,\n    segmentEndBottomScratch,\n  );\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  let endGeometryNormal = Cartesian3.unpack(\n    normalsArray,\n    0,\n    segmentEndNormalScratch,\n  );\n\n  if (loop) {\n    const preEndBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      bottomPositionsArray.length - 6,\n      segmentStartBottomScratch,\n    );\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(\n        endGeometryNormal,\n        endGeometryNormal,\n      );\n    }\n  }\n\n  let lengthSoFar3D = 0.0;\n  let lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  let sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    let startGeometryNormal = Cartesian3.clone(\n      endGeometryNormal,\n      segmentStartNormalScratch,\n    );\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(\n        startGeometryNormal,\n        startGeometryNormal,\n      );\n    }\n\n    endBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      index,\n      segmentEndBottomScratch,\n    );\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(\n      normalsArray,\n      index,\n      segmentEndNormalScratch,\n    );\n\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    let start2D;\n    let end2D;\n    let startGeometryNormal2D;\n    let endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (\n        nudgeResult === 0 ||\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\n      ) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch,\n        );\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch,\n        );\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch,\n        );\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - Math.abs(endCartographic.longitude),\n        );\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch,\n        );\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - endCartographic.longitude,\n        );\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /* 3D */\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n    const encodedStart = EncodedCartesian3.fromCartesian(\n      startBottom,\n      encodeScratch,\n    );\n    const forwardOffset = Cartesian3.subtract(\n      endBottom,\n      startBottom,\n      offsetScratch,\n    );\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n    let startPlaneNormal = Cartesian3.cross(\n      startUp,\n      startGeometryNormal,\n      startPlaneNormalScratch,\n    );\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    let endPlaneNormal = Cartesian3.cross(\n      endGeometryNormal,\n      endUp,\n      endPlaneNormalScratch,\n    );\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n    const texcoordNormalization3DX = segmentLength3D / length3D;\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /* 2D */\n    let segmentLength2D = 0.0;\n    let encodedStart2D;\n    let forwardOffset2D;\n    let right2D;\n    let texcoordNormalization2DX = 0.0;\n    let texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n      encodedStart2D = EncodedCartesian3.fromCartesian(\n        start2D,\n        encodeScratch2D,\n      );\n      forwardOffset2D = Cartesian3.subtract(\n        end2D,\n        start2D,\n        forwardOffset2DScratch,\n      );\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      const swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      const vec4Index = vec4sWriteIndex + j * 4;\n      const vec2Index = vec2sWriteIndex + j * 2;\n      const wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      const topBottomSide =\n        j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n      Cartesian3.pack(\n        startPlaneNormal,\n        startNormalAndForwardOffsetZ,\n        vec4Index,\n      );\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n      Cartesian3.pack(\n        endPlaneNormal,\n        endNormalAndTextureCoordinateNormalizationX,\n        vec4Index,\n      );\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\n        texcoordNormalization3DX * rightPlaneSide;\n\n      Cartesian3.pack(\n        rightNormal,\n        rightNormalAndTextureCoordinateNormalizationY,\n        vec4Index,\n      );\n\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[wIndex] =\n        texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n        texcoordNormalization2D[vec2Index] =\n          texcoordNormalization2DX * rightPlaneSide;\n\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\n\n    const getHeightsRectangle = Rectangle.fromCartographicArray(\n      getHeightCartographics,\n      getHeightRectangleScratch,\n    );\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      getHeightsRectangle,\n      ellipsoid,\n    );\n    const minHeight = minMaxHeights.minimumTerrainHeight;\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    // Sum using abs() to properly account for negative eleavtions in calculating bounding sphere radius\n    sumHeights += Math.abs(minHeight);\n    sumHeights += Math.abs(maxHeight);\n\n    adjustHeights(\n      startBottom,\n      startTop,\n      minHeight,\n      maxHeight,\n      adjustHeightStartBottom,\n      adjustHeightStartTop,\n    );\n    adjustHeights(\n      endBottom,\n      endTop,\n      minHeight,\n      maxHeight,\n      adjustHeightEndBottom,\n      adjustHeightEndTop,\n    );\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    let normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      CesiumMath.EPSILON5,\n      normalNudgeScratch,\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom,\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n    normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      -2.0 * CesiumMath.EPSILON5,\n      normalNudgeScratch,\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom,\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(\n      adjustHeightStartBottom,\n      positionsArray,\n      vec3sWriteIndex + 12,\n    );\n    Cartesian3.pack(\n      adjustHeightEndBottom,\n      positionsArray,\n      vec3sWriteIndex + 15,\n    );\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n    cartographicsIndex += 2;\n    index += 3;\n\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  let indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  const boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(\n    bottomPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[0],\n  );\n  BoundingSphere.fromVertices(\n    topPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[1],\n  );\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n  const attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray,\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\n      startHiAndForwardOffsetX,\n    ),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\n      startLoAndForwardOffsetY,\n    ),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\n      startNormalAndForwardOffsetZ,\n    ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\n      endNormalAndTextureCoordinateNormalizationX,\n    ),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\n      rightNormalAndTextureCoordinateNormalizationY,\n    ),\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere,\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray,\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}