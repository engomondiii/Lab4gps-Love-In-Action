{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport ClippingPolygon from \"./ClippingPolygon.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport PolygonSignedDistanceFS from \"../Shaders/PolygonSignedDistanceFS.js\";\n\n/**\n * Specifies a set of clipping polygons. Clipping polygons selectively disable rendering in a region\n * inside or outside the specified list of {@link ClippingPolygon} objects for a single glTF model, 3D Tileset, or the globe.\n *\n * Clipping Polygons are only supported in WebGL 2 contexts.\n *\n * @alias ClippingPolygonCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ClippingPolygon[]} [options.polygons=[]] An array of {@link ClippingPolygon} objects used to selectively disable rendering on the inside of each polygon.\n * @param {boolean} [options.enabled=true] Determines whether the clipping polygons are active.\n * @param {boolean} [options.inverse=false] If true, a region will be clipped if it is outside of every polygon in the collection. Otherwise, a region will only be clipped if it is on the inside of any polygon.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n *\n * const polygons = new Cesium.ClippingPolygonCollection({\n *    polygons: [ polygon ]\n * });\n */\nfunction ClippingPolygonCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._polygons = [];\n  this._totalPositions = 0;\n\n  /**\n   * If true, clipping will be enabled.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {boolean}\n   * @default true\n   */\n  this.enabled = defaultValue(options.enabled, true);\n\n  /**\n   * If true, a region will be clipped if it is outside of every polygon in the\n   * collection. Otherwise, a region will only be clipped if it is\n   * inside of any polygon.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {boolean}\n   * @default false\n   */\n  this.inverse = defaultValue(options.inverse, false);\n\n  /**\n   * An event triggered when a new clipping polygon is added to the collection.  Event handlers\n   * are passed the new polygon and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.polygonAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping polygon is removed from the collection.  Event handlers\n   * are passed the new polygon and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.polygonRemoved = new Event();\n\n  // If this ClippingPolygonCollection has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference the tileset's ClippingPolygonCollection.\n  this._owner = undefined;\n  this._float32View = undefined;\n  this._extentsFloat32View = undefined;\n  this._extentsCount = 0;\n  this._polygonsTexture = undefined;\n  this._extentsTexture = undefined;\n  this._signedDistanceTexture = undefined;\n  this._signedDistanceComputeCommand = undefined;\n\n  // Add each ClippingPolygon object.\n  const polygons = options.polygons;\n  if (defined(polygons)) {\n    const polygonsLength = polygons.length;\n    for (let i = 0; i < polygonsLength; ++i) {\n      this._polygons.push(polygons[i]);\n    }\n  }\n}\nObject.defineProperties(ClippingPolygonCollection.prototype, {\n  /**\n   * Returns the number of polygons in this collection.  This is commonly used with\n   * {@link ClippingPolygonCollection#get} to iterate over all the polygons\n   * in the collection.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._polygons.length;\n    }\n  },\n  /**\n   * Returns the total number of positions in all polygons in the collection.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  totalPositions: {\n    get: function () {\n      return this._totalPositions;\n    }\n  },\n  /**\n   * Returns a texture containing the packed computed spherical extents for each polygon\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  extentsTexture: {\n    get: function () {\n      return this._extentsTexture;\n    }\n  },\n  /**\n   * Returns the number of packed extents, which can be fewer than the number of polygons.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  extentsCount: {\n    get: function () {\n      return this._extentsCount;\n    }\n  },\n  /**\n   * Returns the number of pixels needed in the texture containing the packed computed spherical extents for each polygon.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  pixelsNeededForExtents: {\n    get: function () {\n      return this.length; // With an RGBA texture, each pixel contains min/max latitude and longitude.\n    }\n  },\n  /**\n   * Returns the number of pixels needed in the texture containing the packed polygon positions.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  pixelsNeededForPolygonPositions: {\n    get: function () {\n      // In an RG FLOAT texture, each polygon position is 2 floats packed to a RG.\n      // Each polygon is the number of positions of that polygon, followed by the list of positions\n      return this.totalPositions + this.length;\n    }\n  },\n  /**\n   * Returns a texture containing the computed signed distance of each polygon.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  clippingTexture: {\n    get: function () {\n      return this._signedDistanceTexture;\n    }\n  },\n  /**\n   * A reference to the ClippingPolygonCollection's owner, if any.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  },\n  /**\n   * Returns a number encapsulating the state for this ClippingPolygonCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the total position count.\n   * If this value changes, then shader regeneration is necessary.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @returns {number} A Number that describes the ClippingPolygonCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPolygonsState: {\n    get: function () {\n      return this.inverse ? -this.extentsCount : this.extentsCount;\n    }\n  }\n});\n\n/**\n * Adds the specified {@link ClippingPolygon} to the collection to be used to selectively disable rendering\n * on the inside of each polygon. Use {@link ClippingPolygonCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple polygons.\n *\n * @param {ClippingPolygon} polygon The ClippingPolygon to add to the collection.\n * @returns {ClippingPolygon} The added ClippingPolygon.\n *\n * @example\n * const polygons = new Cesium.ClippingPolygonCollection();\n *\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * polygons.add(new Cesium.ClippingPolygon({\n *     positions: positions\n * }));\n *\n *\n *\n * @see ClippingPolygonCollection#remove\n * @see ClippingPolygonCollection#removeAll\n */\nClippingPolygonCollection.prototype.add = function (polygon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  const newPlaneIndex = this._polygons.length;\n  this._polygons.push(polygon);\n  this.polygonAdded.raiseEvent(polygon, newPlaneIndex);\n  return polygon;\n};\n\n/**\n * Returns the clipping polygon in the collection at the specified index.  Indices are zero-based\n * and increase as polygons are added.  Removing a polygon polygon all polygons after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link ClippingPolygonCollection#length} to iterate over all the polygons\n * in the collection.\n *\n * @param {number} index The zero-based index of the polygon.\n * @returns {ClippingPolygon} The ClippingPolygon at the specified index.\n *\n * @see ClippingPolygonCollection#length\n */\nClippingPolygonCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._polygons[index];\n};\n\n/**\n * Checks whether this collection contains a ClippingPolygon equal to the given ClippingPolygon.\n *\n * @param {ClippingPolygon} polygon The ClippingPolygon to check for.\n * @returns {boolean} true if this collection contains the ClippingPolygon, false otherwise.\n *\n * @see ClippingPolygonCollection#get\n */\nClippingPolygonCollection.prototype.contains = function (polygon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  return this._polygons.some(p => ClippingPolygon.equals(p, polygon));\n};\n\n/**\n * Removes the first occurrence of the given ClippingPolygon from the collection.\n *\n * @param {ClippingPolygon} polygon\n * @returns {boolean} <code>true</code> if the polygon was removed; <code>false</code> if the polygon was not found in the collection.\n *\n * @see ClippingPolygonCollection#add\n * @see ClippingPolygonCollection#contains\n * @see ClippingPolygonCollection#removeAll\n */\nClippingPolygonCollection.prototype.remove = function (polygon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  const polygons = this._polygons;\n  const index = polygons.findIndex(p => ClippingPolygon.equals(p, polygon));\n  if (index === -1) {\n    return false;\n  }\n  polygons.splice(index, 1);\n  this.polygonRemoved.raiseEvent(polygon, index);\n  return true;\n};\nconst scratchRectangle = new Rectangle();\n\n// Map the polygons to a list of extents-- Overlapping extents will be merged\n// into a single encompassing extent\nfunction getExtents(polygons) {\n  const extentsList = [];\n  const polygonIndicesList = [];\n  const length = polygons.length;\n  for (let polygonIndex = 0; polygonIndex < length; ++polygonIndex) {\n    const polygon = polygons[polygonIndex];\n    const extents = polygon.computeSphericalExtents();\n    let height = Math.max(extents.height * 2.5, 0.001);\n    let width = Math.max(extents.width * 2.5, 0.001);\n\n    // Pad extents to avoid floating point error when fragment culling at edges.\n    let paddedExtents = Rectangle.clone(extents);\n    paddedExtents.south -= height;\n    paddedExtents.west -= width;\n    paddedExtents.north += height;\n    paddedExtents.east += width;\n    paddedExtents.south = Math.max(paddedExtents.south, -Math.PI);\n    paddedExtents.west = Math.max(paddedExtents.west, -Math.PI);\n    paddedExtents.north = Math.min(paddedExtents.north, Math.PI);\n    paddedExtents.east = Math.min(paddedExtents.east, Math.PI);\n    const polygonIndices = [polygonIndex];\n    for (let i = 0; i < extentsList.length; ++i) {\n      const e = extentsList[i];\n      if (defined(e) && defined(Rectangle.simpleIntersection(e, paddedExtents)) && !Rectangle.equals(e, paddedExtents)) {\n        const intersectingPolygons = polygonIndicesList[i];\n        polygonIndices.push(...intersectingPolygons);\n        intersectingPolygons.reduce((extents, p) => Rectangle.union(polygons[p].computeSphericalExtents(scratchRectangle), extents, extents), extents);\n        extentsList[i] = undefined;\n        polygonIndicesList[i] = undefined;\n        height = Math.max(extents.height * 2.5, 0.001);\n        width = Math.max(extents.width * 2.5, 0.001);\n        paddedExtents = Rectangle.clone(extents, paddedExtents);\n        paddedExtents.south -= height;\n        paddedExtents.west -= width;\n        paddedExtents.north += height;\n        paddedExtents.east += width;\n        paddedExtents.south = Math.max(paddedExtents.south, -Math.PI);\n        paddedExtents.west = Math.max(paddedExtents.west, -Math.PI);\n        paddedExtents.north = Math.min(paddedExtents.north, Math.PI);\n        paddedExtents.east = Math.min(paddedExtents.east, Math.PI);\n\n        // Reiterate through the extents list until there are no more intersections\n        i = -1;\n      }\n    }\n    extentsList.push(paddedExtents);\n    polygonIndicesList.push(polygonIndices);\n  }\n  const extentsIndexByPolygon = new Map();\n  polygonIndicesList.filter(defined).forEach((polygonIndices, e) => polygonIndices.forEach(p => extentsIndexByPolygon.set(p, e)));\n  return {\n    extentsList: extentsList.filter(defined),\n    extentsIndexByPolygon: extentsIndexByPolygon\n  };\n}\n\n/**\n * Removes all polygons from the collection.\n *\n * @see ClippingPolygonCollection#add\n * @see ClippingPolygonCollection#remove\n */\nClippingPolygonCollection.prototype.removeAll = function () {\n  // Dereference this ClippingPolygonCollection from all ClippingPolygons\n  const polygons = this._polygons;\n  const polygonsCount = polygons.length;\n  for (let i = 0; i < polygonsCount; ++i) {\n    const polygon = polygons[i];\n    this.polygonRemoved.raiseEvent(polygon, i);\n  }\n  this._polygons = [];\n};\nfunction packPolygonsAsFloats(clippingPolygonCollection) {\n  const polygonsFloat32View = clippingPolygonCollection._float32View;\n  const extentsFloat32View = clippingPolygonCollection._extentsFloat32View;\n  const polygons = clippingPolygonCollection._polygons;\n  const {\n    extentsList,\n    extentsIndexByPolygon\n  } = getExtents(polygons);\n  let floatIndex = 0;\n  for (const [polygonIndex, polygon] of polygons.entries()) {\n    // Pack the length of the polygon into the polygon texture array buffer\n    const length = polygon.length;\n    polygonsFloat32View[floatIndex++] = length;\n    polygonsFloat32View[floatIndex++] = extentsIndexByPolygon.get(polygonIndex);\n\n    // Pack the polygon positions into the polygon texture array buffer\n    for (let i = 0; i < length; ++i) {\n      const spherePoint = polygon.positions[i];\n\n      // Project into plane with vertical for latitude\n      const magXY = Math.hypot(spherePoint.x, spherePoint.y);\n\n      // Use fastApproximateAtan2 for alignment with shader\n      const latitudeApproximation = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n      const longitudeApproximation = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n      polygonsFloat32View[floatIndex++] = latitudeApproximation;\n      polygonsFloat32View[floatIndex++] = longitudeApproximation;\n    }\n  }\n\n  // Pack extents\n  let extentsFloatIndex = 0;\n  for (const extents of extentsList) {\n    const longitudeRangeInverse = 1.0 / (extents.east - extents.west);\n    const latitudeRangeInverse = 1.0 / (extents.north - extents.south);\n    extentsFloat32View[extentsFloatIndex++] = extents.south;\n    extentsFloat32View[extentsFloatIndex++] = extents.west;\n    extentsFloat32View[extentsFloatIndex++] = latitudeRangeInverse;\n    extentsFloat32View[extentsFloatIndex++] = longitudeRangeInverse;\n  }\n  clippingPolygonCollection._extentsCount = extentsList.length;\n}\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping polygons.\n * <p>\n * Do not call this function directly.\n * </p>\n * @private\n * @throws {RuntimeError} ClippingPolygonCollections are only supported for WebGL 2\n */\nClippingPolygonCollection.prototype.update = function (frameState) {\n  const context = frameState.context;\n  if (!ClippingPolygonCollection.isSupported(frameState)) {\n    throw new RuntimeError(\"ClippingPolygonCollections are only supported for WebGL 2.\");\n  }\n\n  // It'd be expensive to validate any individual position has changed. Instead verify if the list of polygon positions has had elements added or removed, which should be good enough for most cases.\n  const totalPositions = this._polygons.reduce((totalPositions, polygon) => totalPositions + polygon.length, 0);\n  if (totalPositions === this.totalPositions) {\n    return;\n  }\n  this._totalPositions = totalPositions;\n\n  // If there are no clipping polygons, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n  if (defined(this._signedDistanceComputeCommand)) {\n    this._signedDistanceComputeCommand.canceled = true;\n    this._signedDistanceComputeCommand = undefined;\n  }\n  let polygonsTexture = this._polygonsTexture;\n  let extentsTexture = this._extentsTexture;\n  let signedDistanceTexture = this._signedDistanceTexture;\n  if (defined(polygonsTexture)) {\n    const currentPixelCount = polygonsTexture.width * polygonsTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (currentPixelCount < this.pixelsNeededForPolygonPositions || this.pixelsNeededForPolygonPositions < 0.25 * currentPixelCount) {\n      polygonsTexture.destroy();\n      polygonsTexture = undefined;\n      this._polygonsTexture = undefined;\n    }\n  }\n  if (!defined(polygonsTexture)) {\n    const requiredResolution = ClippingPolygonCollection.getTextureResolution(polygonsTexture, this.pixelsNeededForPolygonPositions, textureResolutionScratch);\n    polygonsTexture = new Texture({\n      context: context,\n      width: requiredResolution.x,\n      height: requiredResolution.y,\n      pixelFormat: PixelFormat.RG,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: Sampler.NEAREST,\n      flipY: false\n    });\n    this._float32View = new Float32Array(requiredResolution.x * requiredResolution.y * 2);\n    this._polygonsTexture = polygonsTexture;\n  }\n  if (defined(extentsTexture)) {\n    const currentPixelCount = extentsTexture.width * extentsTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (currentPixelCount < this.pixelsNeededForExtents || this.pixelsNeededForExtents < 0.25 * currentPixelCount) {\n      extentsTexture.destroy();\n      extentsTexture = undefined;\n      this._extentsTexture = undefined;\n    }\n  }\n  if (!defined(extentsTexture)) {\n    const requiredResolution = ClippingPolygonCollection.getTextureResolution(extentsTexture, this.pixelsNeededForExtents, textureResolutionScratch);\n    extentsTexture = new Texture({\n      context: context,\n      width: requiredResolution.x,\n      height: requiredResolution.y,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: Sampler.NEAREST,\n      flipY: false\n    });\n    this._extentsFloat32View = new Float32Array(requiredResolution.x * requiredResolution.y * 4);\n    this._extentsTexture = extentsTexture;\n  }\n  packPolygonsAsFloats(this);\n  extentsTexture.copyFrom({\n    source: {\n      width: extentsTexture.width,\n      height: extentsTexture.height,\n      arrayBufferView: this._extentsFloat32View\n    }\n  });\n  polygonsTexture.copyFrom({\n    source: {\n      width: polygonsTexture.width,\n      height: polygonsTexture.height,\n      arrayBufferView: this._float32View\n    }\n  });\n  if (!defined(signedDistanceTexture)) {\n    const textureDimensions = ClippingPolygonCollection.getClippingDistanceTextureResolution(this, textureResolutionScratch);\n    signedDistanceTexture = new Texture({\n      context: context,\n      width: textureDimensions.x,\n      height: textureDimensions.y,\n      pixelFormat: context.webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: TextureMinificationFilter.LINEAR,\n        magnificationFilter: TextureMagnificationFilter.LINEAR\n      }),\n      flipY: false\n    });\n    this._signedDistanceTexture = signedDistanceTexture;\n  }\n  this._signedDistanceComputeCommand = createSignedDistanceTextureCommand(this);\n};\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping polygons.\n * <p>\n * Do not call this function directly.\n * </p>\n * @private\n * @param {FrameState} frameState\n */\nClippingPolygonCollection.prototype.queueCommands = function (frameState) {\n  if (defined(this._signedDistanceComputeCommand)) {\n    frameState.commandList.push(this._signedDistanceComputeCommand);\n  }\n};\nfunction createSignedDistanceTextureCommand(collection) {\n  const polygonTexture = collection._polygonsTexture;\n  const extentsTexture = collection._extentsTexture;\n  return new ComputeCommand({\n    fragmentShaderSource: PolygonSignedDistanceFS,\n    outputTexture: collection._signedDistanceTexture,\n    uniformMap: {\n      u_polygonsLength: function () {\n        return collection.length;\n      },\n      u_extentsLength: function () {\n        return collection.extentsCount;\n      },\n      u_extentsTexture: function () {\n        return extentsTexture;\n      },\n      u_polygonTexture: function () {\n        return polygonTexture;\n      }\n    },\n    persists: false,\n    owner: collection,\n    postExecute: () => {\n      collection._signedDistanceComputeCommand = undefined;\n    }\n  });\n}\nconst scratchRectangleTile = new Rectangle();\nconst scratchRectangleIntersection = new Rectangle();\n/**\n * Determines the type intersection with the polygons of this ClippingPolygonCollection instance and the specified {@link TileBoundingVolume}.\n * @private\n *\n * @param {object} tileBoundingVolume The volume to determine the intersection with the polygons.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the bounding volumes are defined.\n * @returns {Intersect} The intersection type: {@link Intersect.OUTSIDE} if the entire volume is not clipped, {@link Intersect.INSIDE}\n *                      if the entire volume should be clipped, and {@link Intersect.INTERSECTING} if the volume intersects the polygons and will partially clipped.\n */\nClippingPolygonCollection.prototype.computeIntersectionWithBoundingVolume = function (tileBoundingVolume, ellipsoid) {\n  const polygons = this._polygons;\n  const length = polygons.length;\n  let intersection = Intersect.OUTSIDE;\n  if (this.inverse) {\n    intersection = Intersect.INSIDE;\n  }\n  for (let i = 0; i < length; ++i) {\n    const polygon = polygons[i];\n    const polygonBoundingRectangle = polygon.computeRectangle();\n    let tileBoundingRectangle = tileBoundingVolume.rectangle;\n    if (!defined(tileBoundingRectangle) && defined(tileBoundingVolume.boundingVolume?.computeCorners)) {\n      const points = tileBoundingVolume.boundingVolume.computeCorners();\n      tileBoundingRectangle = Rectangle.fromCartesianArray(points, ellipsoid, scratchRectangleTile);\n    }\n    if (!defined(tileBoundingRectangle)) {\n      tileBoundingRectangle = Rectangle.fromBoundingSphere(tileBoundingVolume.boundingSphere, ellipsoid, scratchRectangleTile);\n    }\n    const result = Rectangle.simpleIntersection(tileBoundingRectangle, polygonBoundingRectangle, scratchRectangleIntersection);\n    if (defined(result)) {\n      intersection = Intersect.INTERSECTING;\n    }\n  }\n  return intersection;\n};\n\n/**\n * Sets the owner for the input ClippingPolygonCollection if there wasn't another owner.\n * Destroys the owner's previous ClippingPolygonCollection if setting is successful.\n *\n * @param {ClippingPolygonCollection} [clippingPolygonsCollection] A ClippingPolygonCollection (or undefined) being attached to an object\n * @param {object} owner An Object that should receive the new ClippingPolygonCollection\n * @param {string} key The Key for the Object to reference the ClippingPolygonCollection\n * @private\n */\nClippingPolygonCollection.setOwner = function (clippingPolygonsCollection, owner, key) {\n  // Don't destroy the ClippingPolygonCollection if it is already owned by newOwner\n  if (clippingPolygonsCollection === owner[key]) {\n    return;\n  }\n  // Destroy the existing ClippingPolygonCollection, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(clippingPolygonsCollection)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(clippingPolygonsCollection._owner)) {\n      throw new DeveloperError(\"ClippingPolygonCollection should only be assigned to one object\");\n    }\n    //>>includeEnd('debug');\n    clippingPolygonsCollection._owner = owner;\n    owner[key] = clippingPolygonsCollection;\n  }\n};\n\n/**\n * Function for checking if the context will allow clipping polygons, which require floating point textures.\n *\n * @param {Scene|object} scene The scene that will contain clipped objects and clipping textures.\n * @returns {boolean} <code>true</code> if the context supports clipping polygons.\n */\nClippingPolygonCollection.isSupported = function (scene) {\n  return scene?.context.webgl2;\n};\n\n/**\n * Function for getting packed texture resolution.\n * If the ClippingPolygonCollection hasn't been updated, returns the resolution that will be\n * allocated based on the provided needed pixels.\n *\n * @param {Texture} texture The texture to be packed.\n * @param {number} pixelsNeeded The number of pixels needed based on the current polygon count.\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPolygonCollection.getTextureResolution = function (texture, pixelsNeeded, result) {\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n  const maxSize = ContextLimits.maximumTextureSize;\n  result.x = Math.min(pixelsNeeded, maxSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  result.y *= 2;\n  return result;\n};\n\n/**\n * Function for getting the clipping collection's signed distance texture resolution.\n * If the ClippingPolygonCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current settings\n *\n * @param {ClippingPolygonCollection} clippingPolygonCollection The clipping polygon collection\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPolygonCollection.getClippingDistanceTextureResolution = function (clippingPolygonCollection, result) {\n  const texture = clippingPolygonCollection.signedDistanceTexture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n  result.x = Math.min(ContextLimits.maximumTextureSize, 4096);\n  result.y = Math.min(ContextLimits.maximumTextureSize, 4096);\n  return result;\n};\n\n/**\n * Function for getting the clipping collection's extents texture resolution.\n * If the ClippingPolygonCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current polygon count.\n *\n * @param {ClippingPolygonCollection} clippingPolygonCollection The clipping polygon collection\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPolygonCollection.getClippingExtentsTextureResolution = function (clippingPolygonCollection, result) {\n  const texture = clippingPolygonCollection.extentsTexture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n  return ClippingPolygonCollection.getTextureResolution(texture, clippingPolygonCollection.pixelsNeededForExtents, result);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClippingPolygonCollection#destroy\n */\nClippingPolygonCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * clippingPolygons = clippingPolygons && clippingPolygons.destroy();\n *\n * @see ClippingPolygonCollection#isDestroyed\n */\nClippingPolygonCollection.prototype.destroy = function () {\n  if (defined(this._signedDistanceComputeCommand)) {\n    this._signedDistanceComputeCommand.canceled = true;\n  }\n  this._polygonsTexture = this._polygonsTexture && this._polygonsTexture.destroy();\n  this._extentsTexture = this._extentsTexture && this._extentsTexture.destroy();\n  this._signedDistanceTexture = this._signedDistanceTexture && this._signedDistanceTexture.destroy();\n  return destroyObject(this);\n};\nexport default ClippingPolygonCollection;","map":{"version":3,"names":["Cartesian2","CesiumMath","Check","defaultValue","defined","destroyObject","DeveloperError","Event","Intersect","PixelFormat","Rectangle","ContextLimits","PixelDatatype","RuntimeError","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","ClippingPolygon","ComputeCommand","PolygonSignedDistanceFS","ClippingPolygonCollection","options","EMPTY_OBJECT","_polygons","_totalPositions","enabled","inverse","polygonAdded","polygonRemoved","_owner","undefined","_float32View","_extentsFloat32View","_extentsCount","_polygonsTexture","_extentsTexture","_signedDistanceTexture","_signedDistanceComputeCommand","polygons","polygonsLength","length","i","push","Object","defineProperties","prototype","get","totalPositions","extentsTexture","extentsCount","pixelsNeededForExtents","pixelsNeededForPolygonPositions","clippingTexture","owner","clippingPolygonsState","add","polygon","typeOf","object","newPlaneIndex","raiseEvent","index","number","contains","some","p","equals","remove","findIndex","splice","scratchRectangle","getExtents","extentsList","polygonIndicesList","polygonIndex","extents","computeSphericalExtents","height","Math","max","width","paddedExtents","clone","south","west","north","east","PI","min","polygonIndices","e","simpleIntersection","intersectingPolygons","reduce","union","extentsIndexByPolygon","Map","filter","forEach","set","removeAll","polygonsCount","packPolygonsAsFloats","clippingPolygonCollection","polygonsFloat32View","extentsFloat32View","floatIndex","entries","spherePoint","positions","magXY","hypot","x","y","latitudeApproximation","fastApproximateAtan2","z","longitudeApproximation","extentsFloatIndex","longitudeRangeInverse","latitudeRangeInverse","textureResolutionScratch","update","frameState","context","isSupported","canceled","polygonsTexture","signedDistanceTexture","currentPixelCount","destroy","requiredResolution","getTextureResolution","pixelFormat","RG","pixelDatatype","FLOAT","sampler","NEAREST","flipY","Float32Array","RGBA","copyFrom","source","arrayBufferView","textureDimensions","getClippingDistanceTextureResolution","webgl2","RED","LUMINANCE","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR","magnificationFilter","createSignedDistanceTextureCommand","queueCommands","commandList","collection","polygonTexture","fragmentShaderSource","outputTexture","uniformMap","u_polygonsLength","u_extentsLength","u_extentsTexture","u_polygonTexture","persists","postExecute","scratchRectangleTile","scratchRectangleIntersection","computeIntersectionWithBoundingVolume","tileBoundingVolume","ellipsoid","intersection","OUTSIDE","INSIDE","polygonBoundingRectangle","computeRectangle","tileBoundingRectangle","rectangle","boundingVolume","computeCorners","points","fromCartesianArray","fromBoundingSphere","boundingSphere","result","INTERSECTING","setOwner","clippingPolygonsCollection","key","scene","texture","pixelsNeeded","maxSize","maximumTextureSize","ceil","getClippingExtentsTextureResolution","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ClippingPolygonCollection.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport ClippingPolygon from \"./ClippingPolygon.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport PolygonSignedDistanceFS from \"../Shaders/PolygonSignedDistanceFS.js\";\n\n/**\n * Specifies a set of clipping polygons. Clipping polygons selectively disable rendering in a region\n * inside or outside the specified list of {@link ClippingPolygon} objects for a single glTF model, 3D Tileset, or the globe.\n *\n * Clipping Polygons are only supported in WebGL 2 contexts.\n *\n * @alias ClippingPolygonCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ClippingPolygon[]} [options.polygons=[]] An array of {@link ClippingPolygon} objects used to selectively disable rendering on the inside of each polygon.\n * @param {boolean} [options.enabled=true] Determines whether the clipping polygons are active.\n * @param {boolean} [options.inverse=false] If true, a region will be clipped if it is outside of every polygon in the collection. Otherwise, a region will only be clipped if it is on the inside of any polygon.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n *\n * const polygons = new Cesium.ClippingPolygonCollection({\n *    polygons: [ polygon ]\n * });\n */\nfunction ClippingPolygonCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._polygons = [];\n  this._totalPositions = 0;\n\n  /**\n   * If true, clipping will be enabled.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {boolean}\n   * @default true\n   */\n  this.enabled = defaultValue(options.enabled, true);\n\n  /**\n   * If true, a region will be clipped if it is outside of every polygon in the\n   * collection. Otherwise, a region will only be clipped if it is\n   * inside of any polygon.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {boolean}\n   * @default false\n   */\n  this.inverse = defaultValue(options.inverse, false);\n\n  /**\n   * An event triggered when a new clipping polygon is added to the collection.  Event handlers\n   * are passed the new polygon and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.polygonAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping polygon is removed from the collection.  Event handlers\n   * are passed the new polygon and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.polygonRemoved = new Event();\n\n  // If this ClippingPolygonCollection has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference the tileset's ClippingPolygonCollection.\n  this._owner = undefined;\n\n  this._float32View = undefined;\n  this._extentsFloat32View = undefined;\n  this._extentsCount = 0;\n\n  this._polygonsTexture = undefined;\n  this._extentsTexture = undefined;\n  this._signedDistanceTexture = undefined;\n\n  this._signedDistanceComputeCommand = undefined;\n\n  // Add each ClippingPolygon object.\n  const polygons = options.polygons;\n  if (defined(polygons)) {\n    const polygonsLength = polygons.length;\n    for (let i = 0; i < polygonsLength; ++i) {\n      this._polygons.push(polygons[i]);\n    }\n  }\n}\n\nObject.defineProperties(ClippingPolygonCollection.prototype, {\n  /**\n   * Returns the number of polygons in this collection.  This is commonly used with\n   * {@link ClippingPolygonCollection#get} to iterate over all the polygons\n   * in the collection.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._polygons.length;\n    },\n  },\n\n  /**\n   * Returns the total number of positions in all polygons in the collection.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  totalPositions: {\n    get: function () {\n      return this._totalPositions;\n    },\n  },\n\n  /**\n   * Returns a texture containing the packed computed spherical extents for each polygon\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  extentsTexture: {\n    get: function () {\n      return this._extentsTexture;\n    },\n  },\n\n  /**\n   * Returns the number of packed extents, which can be fewer than the number of polygons.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  extentsCount: {\n    get: function () {\n      return this._extentsCount;\n    },\n  },\n\n  /**\n   * Returns the number of pixels needed in the texture containing the packed computed spherical extents for each polygon.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  pixelsNeededForExtents: {\n    get: function () {\n      return this.length; // With an RGBA texture, each pixel contains min/max latitude and longitude.\n    },\n  },\n\n  /**\n   * Returns the number of pixels needed in the texture containing the packed polygon positions.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  pixelsNeededForPolygonPositions: {\n    get: function () {\n      // In an RG FLOAT texture, each polygon position is 2 floats packed to a RG.\n      // Each polygon is the number of positions of that polygon, followed by the list of positions\n      return this.totalPositions + this.length;\n    },\n  },\n\n  /**\n   * Returns a texture containing the computed signed distance of each polygon.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  clippingTexture: {\n    get: function () {\n      return this._signedDistanceTexture;\n    },\n  },\n\n  /**\n   * A reference to the ClippingPolygonCollection's owner, if any.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n\n  /**\n   * Returns a number encapsulating the state for this ClippingPolygonCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the total position count.\n   * If this value changes, then shader regeneration is necessary.\n   *\n   * @memberof ClippingPolygonCollection.prototype\n   * @returns {number} A Number that describes the ClippingPolygonCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPolygonsState: {\n    get: function () {\n      return this.inverse ? -this.extentsCount : this.extentsCount;\n    },\n  },\n});\n\n/**\n * Adds the specified {@link ClippingPolygon} to the collection to be used to selectively disable rendering\n * on the inside of each polygon. Use {@link ClippingPolygonCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple polygons.\n *\n * @param {ClippingPolygon} polygon The ClippingPolygon to add to the collection.\n * @returns {ClippingPolygon} The added ClippingPolygon.\n *\n * @example\n * const polygons = new Cesium.ClippingPolygonCollection();\n *\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * polygons.add(new Cesium.ClippingPolygon({\n *     positions: positions\n * }));\n *\n *\n *\n * @see ClippingPolygonCollection#remove\n * @see ClippingPolygonCollection#removeAll\n */\nClippingPolygonCollection.prototype.add = function (polygon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  const newPlaneIndex = this._polygons.length;\n  this._polygons.push(polygon);\n  this.polygonAdded.raiseEvent(polygon, newPlaneIndex);\n  return polygon;\n};\n\n/**\n * Returns the clipping polygon in the collection at the specified index.  Indices are zero-based\n * and increase as polygons are added.  Removing a polygon polygon all polygons after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link ClippingPolygonCollection#length} to iterate over all the polygons\n * in the collection.\n *\n * @param {number} index The zero-based index of the polygon.\n * @returns {ClippingPolygon} The ClippingPolygon at the specified index.\n *\n * @see ClippingPolygonCollection#length\n */\nClippingPolygonCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._polygons[index];\n};\n\n/**\n * Checks whether this collection contains a ClippingPolygon equal to the given ClippingPolygon.\n *\n * @param {ClippingPolygon} polygon The ClippingPolygon to check for.\n * @returns {boolean} true if this collection contains the ClippingPolygon, false otherwise.\n *\n * @see ClippingPolygonCollection#get\n */\nClippingPolygonCollection.prototype.contains = function (polygon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  return this._polygons.some((p) => ClippingPolygon.equals(p, polygon));\n};\n\n/**\n * Removes the first occurrence of the given ClippingPolygon from the collection.\n *\n * @param {ClippingPolygon} polygon\n * @returns {boolean} <code>true</code> if the polygon was removed; <code>false</code> if the polygon was not found in the collection.\n *\n * @see ClippingPolygonCollection#add\n * @see ClippingPolygonCollection#contains\n * @see ClippingPolygonCollection#removeAll\n */\nClippingPolygonCollection.prototype.remove = function (polygon) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  const polygons = this._polygons;\n  const index = polygons.findIndex((p) => ClippingPolygon.equals(p, polygon));\n\n  if (index === -1) {\n    return false;\n  }\n\n  polygons.splice(index, 1);\n\n  this.polygonRemoved.raiseEvent(polygon, index);\n  return true;\n};\n\nconst scratchRectangle = new Rectangle();\n\n// Map the polygons to a list of extents-- Overlapping extents will be merged\n// into a single encompassing extent\nfunction getExtents(polygons) {\n  const extentsList = [];\n  const polygonIndicesList = [];\n\n  const length = polygons.length;\n  for (let polygonIndex = 0; polygonIndex < length; ++polygonIndex) {\n    const polygon = polygons[polygonIndex];\n    const extents = polygon.computeSphericalExtents();\n\n    let height = Math.max(extents.height * 2.5, 0.001);\n    let width = Math.max(extents.width * 2.5, 0.001);\n\n    // Pad extents to avoid floating point error when fragment culling at edges.\n    let paddedExtents = Rectangle.clone(extents);\n    paddedExtents.south -= height;\n    paddedExtents.west -= width;\n    paddedExtents.north += height;\n    paddedExtents.east += width;\n\n    paddedExtents.south = Math.max(paddedExtents.south, -Math.PI);\n    paddedExtents.west = Math.max(paddedExtents.west, -Math.PI);\n    paddedExtents.north = Math.min(paddedExtents.north, Math.PI);\n    paddedExtents.east = Math.min(paddedExtents.east, Math.PI);\n\n    const polygonIndices = [polygonIndex];\n    for (let i = 0; i < extentsList.length; ++i) {\n      const e = extentsList[i];\n      if (\n        defined(e) &&\n        defined(Rectangle.simpleIntersection(e, paddedExtents)) &&\n        !Rectangle.equals(e, paddedExtents)\n      ) {\n        const intersectingPolygons = polygonIndicesList[i];\n        polygonIndices.push(...intersectingPolygons);\n        intersectingPolygons.reduce(\n          (extents, p) =>\n            Rectangle.union(\n              polygons[p].computeSphericalExtents(scratchRectangle),\n              extents,\n              extents,\n            ),\n          extents,\n        );\n\n        extentsList[i] = undefined;\n        polygonIndicesList[i] = undefined;\n\n        height = Math.max(extents.height * 2.5, 0.001);\n        width = Math.max(extents.width * 2.5, 0.001);\n\n        paddedExtents = Rectangle.clone(extents, paddedExtents);\n        paddedExtents.south -= height;\n        paddedExtents.west -= width;\n        paddedExtents.north += height;\n        paddedExtents.east += width;\n\n        paddedExtents.south = Math.max(paddedExtents.south, -Math.PI);\n        paddedExtents.west = Math.max(paddedExtents.west, -Math.PI);\n        paddedExtents.north = Math.min(paddedExtents.north, Math.PI);\n        paddedExtents.east = Math.min(paddedExtents.east, Math.PI);\n\n        // Reiterate through the extents list until there are no more intersections\n        i = -1;\n      }\n    }\n\n    extentsList.push(paddedExtents);\n    polygonIndicesList.push(polygonIndices);\n  }\n\n  const extentsIndexByPolygon = new Map();\n  polygonIndicesList\n    .filter(defined)\n    .forEach((polygonIndices, e) =>\n      polygonIndices.forEach((p) => extentsIndexByPolygon.set(p, e)),\n    );\n\n  return {\n    extentsList: extentsList.filter(defined),\n    extentsIndexByPolygon: extentsIndexByPolygon,\n  };\n}\n\n/**\n * Removes all polygons from the collection.\n *\n * @see ClippingPolygonCollection#add\n * @see ClippingPolygonCollection#remove\n */\nClippingPolygonCollection.prototype.removeAll = function () {\n  // Dereference this ClippingPolygonCollection from all ClippingPolygons\n  const polygons = this._polygons;\n  const polygonsCount = polygons.length;\n  for (let i = 0; i < polygonsCount; ++i) {\n    const polygon = polygons[i];\n    this.polygonRemoved.raiseEvent(polygon, i);\n  }\n  this._polygons = [];\n};\n\nfunction packPolygonsAsFloats(clippingPolygonCollection) {\n  const polygonsFloat32View = clippingPolygonCollection._float32View;\n  const extentsFloat32View = clippingPolygonCollection._extentsFloat32View;\n  const polygons = clippingPolygonCollection._polygons;\n\n  const { extentsList, extentsIndexByPolygon } = getExtents(polygons);\n\n  let floatIndex = 0;\n  for (const [polygonIndex, polygon] of polygons.entries()) {\n    // Pack the length of the polygon into the polygon texture array buffer\n    const length = polygon.length;\n    polygonsFloat32View[floatIndex++] = length;\n    polygonsFloat32View[floatIndex++] = extentsIndexByPolygon.get(polygonIndex);\n\n    // Pack the polygon positions into the polygon texture array buffer\n    for (let i = 0; i < length; ++i) {\n      const spherePoint = polygon.positions[i];\n\n      // Project into plane with vertical for latitude\n      const magXY = Math.hypot(spherePoint.x, spherePoint.y);\n\n      // Use fastApproximateAtan2 for alignment with shader\n      const latitudeApproximation = CesiumMath.fastApproximateAtan2(\n        magXY,\n        spherePoint.z,\n      );\n      const longitudeApproximation = CesiumMath.fastApproximateAtan2(\n        spherePoint.x,\n        spherePoint.y,\n      );\n\n      polygonsFloat32View[floatIndex++] = latitudeApproximation;\n      polygonsFloat32View[floatIndex++] = longitudeApproximation;\n    }\n  }\n\n  // Pack extents\n  let extentsFloatIndex = 0;\n  for (const extents of extentsList) {\n    const longitudeRangeInverse = 1.0 / (extents.east - extents.west);\n    const latitudeRangeInverse = 1.0 / (extents.north - extents.south);\n\n    extentsFloat32View[extentsFloatIndex++] = extents.south;\n    extentsFloat32View[extentsFloatIndex++] = extents.west;\n    extentsFloat32View[extentsFloatIndex++] = latitudeRangeInverse;\n    extentsFloat32View[extentsFloatIndex++] = longitudeRangeInverse;\n  }\n\n  clippingPolygonCollection._extentsCount = extentsList.length;\n}\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping polygons.\n * <p>\n * Do not call this function directly.\n * </p>\n * @private\n * @throws {RuntimeError} ClippingPolygonCollections are only supported for WebGL 2\n */\nClippingPolygonCollection.prototype.update = function (frameState) {\n  const context = frameState.context;\n\n  if (!ClippingPolygonCollection.isSupported(frameState)) {\n    throw new RuntimeError(\n      \"ClippingPolygonCollections are only supported for WebGL 2.\",\n    );\n  }\n\n  // It'd be expensive to validate any individual position has changed. Instead verify if the list of polygon positions has had elements added or removed, which should be good enough for most cases.\n  const totalPositions = this._polygons.reduce(\n    (totalPositions, polygon) => totalPositions + polygon.length,\n    0,\n  );\n\n  if (totalPositions === this.totalPositions) {\n    return;\n  }\n\n  this._totalPositions = totalPositions;\n\n  // If there are no clipping polygons, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n\n  if (defined(this._signedDistanceComputeCommand)) {\n    this._signedDistanceComputeCommand.canceled = true;\n    this._signedDistanceComputeCommand = undefined;\n  }\n\n  let polygonsTexture = this._polygonsTexture;\n  let extentsTexture = this._extentsTexture;\n  let signedDistanceTexture = this._signedDistanceTexture;\n  if (defined(polygonsTexture)) {\n    const currentPixelCount = polygonsTexture.width * polygonsTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (\n      currentPixelCount < this.pixelsNeededForPolygonPositions ||\n      this.pixelsNeededForPolygonPositions < 0.25 * currentPixelCount\n    ) {\n      polygonsTexture.destroy();\n      polygonsTexture = undefined;\n      this._polygonsTexture = undefined;\n    }\n  }\n\n  if (!defined(polygonsTexture)) {\n    const requiredResolution = ClippingPolygonCollection.getTextureResolution(\n      polygonsTexture,\n      this.pixelsNeededForPolygonPositions,\n      textureResolutionScratch,\n    );\n\n    polygonsTexture = new Texture({\n      context: context,\n      width: requiredResolution.x,\n      height: requiredResolution.y,\n      pixelFormat: PixelFormat.RG,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: Sampler.NEAREST,\n      flipY: false,\n    });\n    this._float32View = new Float32Array(\n      requiredResolution.x * requiredResolution.y * 2,\n    );\n    this._polygonsTexture = polygonsTexture;\n  }\n\n  if (defined(extentsTexture)) {\n    const currentPixelCount = extentsTexture.width * extentsTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (\n      currentPixelCount < this.pixelsNeededForExtents ||\n      this.pixelsNeededForExtents < 0.25 * currentPixelCount\n    ) {\n      extentsTexture.destroy();\n      extentsTexture = undefined;\n      this._extentsTexture = undefined;\n    }\n  }\n\n  if (!defined(extentsTexture)) {\n    const requiredResolution = ClippingPolygonCollection.getTextureResolution(\n      extentsTexture,\n      this.pixelsNeededForExtents,\n      textureResolutionScratch,\n    );\n\n    extentsTexture = new Texture({\n      context: context,\n      width: requiredResolution.x,\n      height: requiredResolution.y,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: Sampler.NEAREST,\n      flipY: false,\n    });\n    this._extentsFloat32View = new Float32Array(\n      requiredResolution.x * requiredResolution.y * 4,\n    );\n\n    this._extentsTexture = extentsTexture;\n  }\n\n  packPolygonsAsFloats(this);\n\n  extentsTexture.copyFrom({\n    source: {\n      width: extentsTexture.width,\n      height: extentsTexture.height,\n      arrayBufferView: this._extentsFloat32View,\n    },\n  });\n\n  polygonsTexture.copyFrom({\n    source: {\n      width: polygonsTexture.width,\n      height: polygonsTexture.height,\n      arrayBufferView: this._float32View,\n    },\n  });\n\n  if (!defined(signedDistanceTexture)) {\n    const textureDimensions =\n      ClippingPolygonCollection.getClippingDistanceTextureResolution(\n        this,\n        textureResolutionScratch,\n      );\n    signedDistanceTexture = new Texture({\n      context: context,\n      width: textureDimensions.x,\n      height: textureDimensions.y,\n      pixelFormat: context.webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: TextureMinificationFilter.LINEAR,\n        magnificationFilter: TextureMagnificationFilter.LINEAR,\n      }),\n      flipY: false,\n    });\n\n    this._signedDistanceTexture = signedDistanceTexture;\n  }\n\n  this._signedDistanceComputeCommand = createSignedDistanceTextureCommand(this);\n};\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping polygons.\n * <p>\n * Do not call this function directly.\n * </p>\n * @private\n * @param {FrameState} frameState\n */\nClippingPolygonCollection.prototype.queueCommands = function (frameState) {\n  if (defined(this._signedDistanceComputeCommand)) {\n    frameState.commandList.push(this._signedDistanceComputeCommand);\n  }\n};\n\nfunction createSignedDistanceTextureCommand(collection) {\n  const polygonTexture = collection._polygonsTexture;\n  const extentsTexture = collection._extentsTexture;\n\n  return new ComputeCommand({\n    fragmentShaderSource: PolygonSignedDistanceFS,\n    outputTexture: collection._signedDistanceTexture,\n    uniformMap: {\n      u_polygonsLength: function () {\n        return collection.length;\n      },\n      u_extentsLength: function () {\n        return collection.extentsCount;\n      },\n      u_extentsTexture: function () {\n        return extentsTexture;\n      },\n      u_polygonTexture: function () {\n        return polygonTexture;\n      },\n    },\n    persists: false,\n    owner: collection,\n    postExecute: () => {\n      collection._signedDistanceComputeCommand = undefined;\n    },\n  });\n}\n\nconst scratchRectangleTile = new Rectangle();\nconst scratchRectangleIntersection = new Rectangle();\n/**\n * Determines the type intersection with the polygons of this ClippingPolygonCollection instance and the specified {@link TileBoundingVolume}.\n * @private\n *\n * @param {object} tileBoundingVolume The volume to determine the intersection with the polygons.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the bounding volumes are defined.\n * @returns {Intersect} The intersection type: {@link Intersect.OUTSIDE} if the entire volume is not clipped, {@link Intersect.INSIDE}\n *                      if the entire volume should be clipped, and {@link Intersect.INTERSECTING} if the volume intersects the polygons and will partially clipped.\n */\nClippingPolygonCollection.prototype.computeIntersectionWithBoundingVolume =\n  function (tileBoundingVolume, ellipsoid) {\n    const polygons = this._polygons;\n    const length = polygons.length;\n\n    let intersection = Intersect.OUTSIDE;\n    if (this.inverse) {\n      intersection = Intersect.INSIDE;\n    }\n\n    for (let i = 0; i < length; ++i) {\n      const polygon = polygons[i];\n\n      const polygonBoundingRectangle = polygon.computeRectangle();\n      let tileBoundingRectangle = tileBoundingVolume.rectangle;\n      if (\n        !defined(tileBoundingRectangle) &&\n        defined(tileBoundingVolume.boundingVolume?.computeCorners)\n      ) {\n        const points = tileBoundingVolume.boundingVolume.computeCorners();\n        tileBoundingRectangle = Rectangle.fromCartesianArray(\n          points,\n          ellipsoid,\n          scratchRectangleTile,\n        );\n      }\n\n      if (!defined(tileBoundingRectangle)) {\n        tileBoundingRectangle = Rectangle.fromBoundingSphere(\n          tileBoundingVolume.boundingSphere,\n          ellipsoid,\n          scratchRectangleTile,\n        );\n      }\n\n      const result = Rectangle.simpleIntersection(\n        tileBoundingRectangle,\n        polygonBoundingRectangle,\n        scratchRectangleIntersection,\n      );\n\n      if (defined(result)) {\n        intersection = Intersect.INTERSECTING;\n      }\n    }\n\n    return intersection;\n  };\n\n/**\n * Sets the owner for the input ClippingPolygonCollection if there wasn't another owner.\n * Destroys the owner's previous ClippingPolygonCollection if setting is successful.\n *\n * @param {ClippingPolygonCollection} [clippingPolygonsCollection] A ClippingPolygonCollection (or undefined) being attached to an object\n * @param {object} owner An Object that should receive the new ClippingPolygonCollection\n * @param {string} key The Key for the Object to reference the ClippingPolygonCollection\n * @private\n */\nClippingPolygonCollection.setOwner = function (\n  clippingPolygonsCollection,\n  owner,\n  key,\n) {\n  // Don't destroy the ClippingPolygonCollection if it is already owned by newOwner\n  if (clippingPolygonsCollection === owner[key]) {\n    return;\n  }\n  // Destroy the existing ClippingPolygonCollection, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(clippingPolygonsCollection)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(clippingPolygonsCollection._owner)) {\n      throw new DeveloperError(\n        \"ClippingPolygonCollection should only be assigned to one object\",\n      );\n    }\n    //>>includeEnd('debug');\n    clippingPolygonsCollection._owner = owner;\n    owner[key] = clippingPolygonsCollection;\n  }\n};\n\n/**\n * Function for checking if the context will allow clipping polygons, which require floating point textures.\n *\n * @param {Scene|object} scene The scene that will contain clipped objects and clipping textures.\n * @returns {boolean} <code>true</code> if the context supports clipping polygons.\n */\nClippingPolygonCollection.isSupported = function (scene) {\n  return scene?.context.webgl2;\n};\n\n/**\n * Function for getting packed texture resolution.\n * If the ClippingPolygonCollection hasn't been updated, returns the resolution that will be\n * allocated based on the provided needed pixels.\n *\n * @param {Texture} texture The texture to be packed.\n * @param {number} pixelsNeeded The number of pixels needed based on the current polygon count.\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPolygonCollection.getTextureResolution = function (\n  texture,\n  pixelsNeeded,\n  result,\n) {\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  const maxSize = ContextLimits.maximumTextureSize;\n  result.x = Math.min(pixelsNeeded, maxSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  result.y *= 2;\n\n  return result;\n};\n\n/**\n * Function for getting the clipping collection's signed distance texture resolution.\n * If the ClippingPolygonCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current settings\n *\n * @param {ClippingPolygonCollection} clippingPolygonCollection The clipping polygon collection\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPolygonCollection.getClippingDistanceTextureResolution = function (\n  clippingPolygonCollection,\n  result,\n) {\n  const texture = clippingPolygonCollection.signedDistanceTexture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  result.x = Math.min(ContextLimits.maximumTextureSize, 4096);\n  result.y = Math.min(ContextLimits.maximumTextureSize, 4096);\n\n  return result;\n};\n\n/**\n * Function for getting the clipping collection's extents texture resolution.\n * If the ClippingPolygonCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current polygon count.\n *\n * @param {ClippingPolygonCollection} clippingPolygonCollection The clipping polygon collection\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nClippingPolygonCollection.getClippingExtentsTextureResolution = function (\n  clippingPolygonCollection,\n  result,\n) {\n  const texture = clippingPolygonCollection.extentsTexture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  return ClippingPolygonCollection.getTextureResolution(\n    texture,\n    clippingPolygonCollection.pixelsNeededForExtents,\n    result,\n  );\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClippingPolygonCollection#destroy\n */\nClippingPolygonCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * clippingPolygons = clippingPolygons && clippingPolygons.destroy();\n *\n * @see ClippingPolygonCollection#isDestroyed\n */\nClippingPolygonCollection.prototype.destroy = function () {\n  if (defined(this._signedDistanceComputeCommand)) {\n    this._signedDistanceComputeCommand.canceled = true;\n  }\n\n  this._polygonsTexture =\n    this._polygonsTexture && this._polygonsTexture.destroy();\n  this._extentsTexture = this._extentsTexture && this._extentsTexture.destroy();\n  this._signedDistanceTexture =\n    this._signedDistanceTexture && this._signedDistanceTexture.destroy();\n  return destroyObject(this);\n};\n\nexport default ClippingPolygonCollection;\n"],"mappings":"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ACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,YAAY,EAAE;IACZH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACb,aAAa;IAC3B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEiB,sBAAsB,EAAE;IACtBJ,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACN,MAAM,CAAC,CAAC;IACtB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEW,+BAA+B,EAAE;IAC/BL,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf;MACA;MACA,OAAO,IAAI,CAACC,cAAc,GAAG,IAAI,CAACP,MAAM;IAC1C;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEY,eAAe,EAAE;IACfN,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,sBAAsB;IACpC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEiB,KAAK,EAAE;IACLP,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjB,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyB,qBAAqB,EAAE;IACrBR,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACpB,OAAO,GAAG,CAAC,IAAI,CAACuB,YAAY,GAAG,IAAI,CAACA,YAAY;IAC9D;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,yBAAyB,CAACyB,SAAS,CAACU,GAAG,GAAG,UAAUC,OAAO,EAAE;EAC3D;EACAxD,KAAK,CAACyD,MAAM,CAACC,MAAM,CAAC,SAAS,EAAEF,OAAO,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}