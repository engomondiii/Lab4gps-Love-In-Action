{"ast":null,"code":"import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Initiates a terrain height query for an array of {@link Cartographic} positions by\n * requesting tiles from a terrain provider, sampling, and interpolating.  The interpolation\n * matches the triangles used to render the terrain at the specified level.  The query\n * happens asynchronously, so this function returns a promise that is resolved when\n * the query completes.  Each point height is modified in place.  If a height can not be\n * determined because no terrain data is available for the specified level at that location,\n * or another error occurs, the height is set to undefined.  As is typical of the\n * {@link Cartographic} type, the supplied height is a height above the reference ellipsoid\n * (such as {@link Ellipsoid.WGS84}) rather than an altitude above mean sea level.  In other\n * words, it will not necessarily be 0.0 if sampled in the ocean. This function needs the\n * terrain level of detail as input, if you need to get the altitude of the terrain as precisely\n * as possible (i.e. with maximum level of detail) use {@link sampleTerrainMostDetailed}.\n *\n * @function sampleTerrain\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {number} level The terrain level-of-detail from which to query terrain heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @param {boolean} [rejectOnTileFail=false] If true, for any failed terrain tile requests, the promise will be rejected. If false, returned heights will be undefined.\n * @returns {Promise<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.\n *\n * @see sampleTerrainMostDetailed\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }\n */\nasync function sampleTerrain(terrainProvider, level, positions, rejectOnTileFail) {\n  if (!defined(rejectOnTileFail)) {\n    rejectOnTileFail = false;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"terrainProvider\", terrainProvider);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.bool(\"rejectOnTileFail\", rejectOnTileFail);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  return doSampling(terrainProvider, level, positions, rejectOnTileFail);\n}\n\n/**\n * @param {object[]} tileRequests The mutated list of requests, the first one will be attempted\n * @param {Array<Promise<void>>} results The list to put the result promises into\n * @param {boolean} rejectOnTileFail If true, the promise will be rejected.  If false, returned heights will be undefined.\n * @returns {boolean} true if the request was made, and we are okay to attempt the next item immediately,\n *  or false if we were throttled and should wait awhile before retrying.\n *\n * @private\n */\nfunction attemptConsumeNextQueueItem(tileRequests, results, rejectOnTileFail) {\n  const tileRequest = tileRequests[0];\n  const requestPromise = tileRequest.terrainProvider.requestTileGeometry(tileRequest.x, tileRequest.y, tileRequest.level);\n  if (!requestPromise) {\n    // getting back undefined instead of a promise indicates we should retry a bit later\n    return false;\n  }\n  let promise;\n  if (rejectOnTileFail) {\n    promise = requestPromise.then(createInterpolateFunction(tileRequest));\n  } else {\n    promise = requestPromise.then(createInterpolateFunction(tileRequest)).catch(createMarkFailedFunction(tileRequest));\n  }\n\n  // remove the request we've just done from the queue\n  //  and add its promise result to the result list\n  tileRequests.shift();\n  results.push(promise);\n\n  // indicate we should synchronously attempt the next request as well\n  return true;\n}\n\n/**\n * Wrap window.setTimeout in a Promise\n * @param {number} ms\n * @private\n */\nfunction delay(ms) {\n  return new Promise(function (res) {\n    setTimeout(res, ms);\n  });\n}\n\n/**\n * Recursively consumes all the tileRequests until the list has been emptied\n *  and a Promise of each result has been put into the results list\n * @param {object[]} tileRequests The list of requests desired to be made\n * @param {Array<Promise<void>>} results The list to put all the result promises into\n * @param {boolean} rejectOnTileFail If true, the promise will be rejected.  If false, returned heights will be undefined.\n * @returns {Promise<void>} A promise which resolves once all requests have been started\n *\n * @private\n */\nfunction drainTileRequestQueue(tileRequests, results, rejectOnTileFail) {\n  // nothing left to do\n  if (!tileRequests.length) {\n    return Promise.resolve();\n  }\n\n  // consume an item from the queue, which will\n  //  mutate the request and result lists, and return true if we should\n  //  immediately attempt to consume the next item as well\n  const success = attemptConsumeNextQueueItem(tileRequests, results, rejectOnTileFail);\n  if (success) {\n    return drainTileRequestQueue(tileRequests, results, rejectOnTileFail);\n  }\n\n  // wait a small fixed amount of time first, before retrying the same request again\n  return delay(100).then(() => {\n    return drainTileRequestQueue(tileRequests, results, rejectOnTileFail);\n  });\n}\nfunction doSampling(terrainProvider, level, positions, rejectOnTileFail) {\n  const tilingScheme = terrainProvider.tilingScheme;\n  let i;\n\n  // Sort points into a set of tiles\n  const tileRequests = []; // Result will be an Array as it's easier to work with\n  const tileRequestSet = {}; // A unique set\n  for (i = 0; i < positions.length; ++i) {\n    const xy = tilingScheme.positionToTileXY(positions[i], level);\n    if (!defined(xy)) {\n      continue;\n    }\n    const key = xy.toString();\n    if (!tileRequestSet.hasOwnProperty(key)) {\n      // When tile is requested for the first time\n      const value = {\n        x: xy.x,\n        y: xy.y,\n        level: level,\n        tilingScheme: tilingScheme,\n        terrainProvider: terrainProvider,\n        positions: []\n      };\n      tileRequestSet[key] = value;\n      tileRequests.push(value);\n    }\n\n    // Now append to array of points for the tile\n    tileRequestSet[key].positions.push(positions[i]);\n  }\n\n  // create our list of result promises to be filled\n  const tilePromises = [];\n  return drainTileRequestQueue(tileRequests, tilePromises, rejectOnTileFail).then(function () {\n    // now all the required requests have been started\n    //  we just wait for them all to finish\n    return Promise.all(tilePromises).then(function () {\n      return positions;\n    });\n  });\n}\n\n/**\n * Calls {@link TerrainData#interpolateHeight} on a given {@link TerrainData} for a given {@link Cartographic} and\n *  will assign the height property if the return value is not undefined.\n *\n * If the return value is false; it's suggesting that you should call {@link TerrainData#createMesh} first.\n * @param {Cartographic} position The position to interpolate for and assign the height value to\n * @param {TerrainData} terrainData\n * @param {Rectangle} rectangle\n * @returns {boolean} If the height was actually interpolated and assigned\n * @private\n */\nfunction interpolateAndAssignHeight(position, terrainData, rectangle) {\n  const height = terrainData.interpolateHeight(rectangle, position.longitude, position.latitude);\n  if (height === undefined) {\n    // if height comes back as undefined, it may implicitly mean the terrain data\n    //  requires us to call TerrainData.createMesh() first (ArcGIS requires this in particular)\n    //  so we'll return false and do that next!\n    return false;\n  }\n  position.height = height;\n  return true;\n}\nfunction createInterpolateFunction(tileRequest) {\n  const tilePositions = tileRequest.positions;\n  const rectangle = tileRequest.tilingScheme.tileXYToRectangle(tileRequest.x, tileRequest.y, tileRequest.level);\n  return function (terrainData) {\n    let isMeshRequired = false;\n    for (let i = 0; i < tilePositions.length; ++i) {\n      const position = tilePositions[i];\n      const isHeightAssigned = interpolateAndAssignHeight(position, terrainData, rectangle);\n      // we've found a position which returned undefined - hinting to us\n      //  that we probably need to create a mesh for this terrain data.\n      // so break out of this loop and create the mesh - then we'll interpolate all the heights again\n      if (!isHeightAssigned) {\n        isMeshRequired = true;\n        break;\n      }\n    }\n    if (!isMeshRequired) {\n      // all position heights were interpolated - we don't need the mesh\n      return Promise.resolve();\n    }\n\n    // create the mesh - and interpolate all the positions again\n    // note: terrain exaggeration is not passed in - we are only interested in the raw data\n    return terrainData.createMesh({\n      tilingScheme: tileRequest.tilingScheme,\n      x: tileRequest.x,\n      y: tileRequest.y,\n      level: tileRequest.level,\n      // don't throttle this mesh creation because we've asked to sample these points;\n      //  so sample them! We don't care how many tiles that is!\n      throttle: false\n    }).then(function () {\n      // mesh has been created - so go through every position (maybe again)\n      //  and re-interpolate the heights - presumably using the mesh this time\n      for (let i = 0; i < tilePositions.length; ++i) {\n        const position = tilePositions[i];\n        // if it doesn't work this time - that's fine, we tried.\n        interpolateAndAssignHeight(position, terrainData, rectangle);\n      }\n    });\n  };\n}\nfunction createMarkFailedFunction(tileRequest) {\n  const tilePositions = tileRequest.positions;\n  return function () {\n    for (let i = 0; i < tilePositions.length; ++i) {\n      const position = tilePositions[i];\n      position.height = undefined;\n    }\n  };\n}\nexport default sampleTerrain;","map":{"version":3,"names":["Check","defined","sampleTerrain","terrainProvider","level","positions","rejectOnTileFail","typeOf","object","number","bool","doSampling","attemptConsumeNextQueueItem","tileRequests","results","tileRequest","requestPromise","requestTileGeometry","x","y","promise","then","createInterpolateFunction","catch","createMarkFailedFunction","shift","push","delay","ms","Promise","res","setTimeout","drainTileRequestQueue","length","resolve","success","tilingScheme","i","tileRequestSet","xy","positionToTileXY","key","toString","hasOwnProperty","value","tilePromises","all","interpolateAndAssignHeight","position","terrainData","rectangle","height","interpolateHeight","longitude","latitude","undefined","tilePositions","tileXYToRectangle","isMeshRequired","isHeightAssigned","createMesh","throttle"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/sampleTerrain.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Initiates a terrain height query for an array of {@link Cartographic} positions by\n * requesting tiles from a terrain provider, sampling, and interpolating.  The interpolation\n * matches the triangles used to render the terrain at the specified level.  The query\n * happens asynchronously, so this function returns a promise that is resolved when\n * the query completes.  Each point height is modified in place.  If a height can not be\n * determined because no terrain data is available for the specified level at that location,\n * or another error occurs, the height is set to undefined.  As is typical of the\n * {@link Cartographic} type, the supplied height is a height above the reference ellipsoid\n * (such as {@link Ellipsoid.WGS84}) rather than an altitude above mean sea level.  In other\n * words, it will not necessarily be 0.0 if sampled in the ocean. This function needs the\n * terrain level of detail as input, if you need to get the altitude of the terrain as precisely\n * as possible (i.e. with maximum level of detail) use {@link sampleTerrainMostDetailed}.\n *\n * @function sampleTerrain\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {number} level The terrain level-of-detail from which to query terrain heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @param {boolean} [rejectOnTileFail=false] If true, for any failed terrain tile requests, the promise will be rejected. If false, returned heights will be undefined.\n * @returns {Promise<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.\n *\n * @see sampleTerrainMostDetailed\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }\n */\nasync function sampleTerrain(\n  terrainProvider,\n  level,\n  positions,\n  rejectOnTileFail,\n) {\n  if (!defined(rejectOnTileFail)) {\n    rejectOnTileFail = false;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"terrainProvider\", terrainProvider);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.bool(\"rejectOnTileFail\", rejectOnTileFail);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  return doSampling(terrainProvider, level, positions, rejectOnTileFail);\n}\n\n/**\n * @param {object[]} tileRequests The mutated list of requests, the first one will be attempted\n * @param {Array<Promise<void>>} results The list to put the result promises into\n * @param {boolean} rejectOnTileFail If true, the promise will be rejected.  If false, returned heights will be undefined.\n * @returns {boolean} true if the request was made, and we are okay to attempt the next item immediately,\n *  or false if we were throttled and should wait awhile before retrying.\n *\n * @private\n */\nfunction attemptConsumeNextQueueItem(tileRequests, results, rejectOnTileFail) {\n  const tileRequest = tileRequests[0];\n  const requestPromise = tileRequest.terrainProvider.requestTileGeometry(\n    tileRequest.x,\n    tileRequest.y,\n    tileRequest.level,\n  );\n\n  if (!requestPromise) {\n    // getting back undefined instead of a promise indicates we should retry a bit later\n    return false;\n  }\n\n  let promise;\n\n  if (rejectOnTileFail) {\n    promise = requestPromise.then(createInterpolateFunction(tileRequest));\n  } else {\n    promise = requestPromise\n      .then(createInterpolateFunction(tileRequest))\n      .catch(createMarkFailedFunction(tileRequest));\n  }\n\n  // remove the request we've just done from the queue\n  //  and add its promise result to the result list\n  tileRequests.shift();\n  results.push(promise);\n\n  // indicate we should synchronously attempt the next request as well\n  return true;\n}\n\n/**\n * Wrap window.setTimeout in a Promise\n * @param {number} ms\n * @private\n */\nfunction delay(ms) {\n  return new Promise(function (res) {\n    setTimeout(res, ms);\n  });\n}\n\n/**\n * Recursively consumes all the tileRequests until the list has been emptied\n *  and a Promise of each result has been put into the results list\n * @param {object[]} tileRequests The list of requests desired to be made\n * @param {Array<Promise<void>>} results The list to put all the result promises into\n * @param {boolean} rejectOnTileFail If true, the promise will be rejected.  If false, returned heights will be undefined.\n * @returns {Promise<void>} A promise which resolves once all requests have been started\n *\n * @private\n */\nfunction drainTileRequestQueue(tileRequests, results, rejectOnTileFail) {\n  // nothing left to do\n  if (!tileRequests.length) {\n    return Promise.resolve();\n  }\n\n  // consume an item from the queue, which will\n  //  mutate the request and result lists, and return true if we should\n  //  immediately attempt to consume the next item as well\n  const success = attemptConsumeNextQueueItem(\n    tileRequests,\n    results,\n    rejectOnTileFail,\n  );\n  if (success) {\n    return drainTileRequestQueue(tileRequests, results, rejectOnTileFail);\n  }\n\n  // wait a small fixed amount of time first, before retrying the same request again\n  return delay(100).then(() => {\n    return drainTileRequestQueue(tileRequests, results, rejectOnTileFail);\n  });\n}\n\nfunction doSampling(terrainProvider, level, positions, rejectOnTileFail) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  let i;\n\n  // Sort points into a set of tiles\n  const tileRequests = []; // Result will be an Array as it's easier to work with\n  const tileRequestSet = {}; // A unique set\n  for (i = 0; i < positions.length; ++i) {\n    const xy = tilingScheme.positionToTileXY(positions[i], level);\n    if (!defined(xy)) {\n      continue;\n    }\n\n    const key = xy.toString();\n\n    if (!tileRequestSet.hasOwnProperty(key)) {\n      // When tile is requested for the first time\n      const value = {\n        x: xy.x,\n        y: xy.y,\n        level: level,\n        tilingScheme: tilingScheme,\n        terrainProvider: terrainProvider,\n        positions: [],\n      };\n      tileRequestSet[key] = value;\n      tileRequests.push(value);\n    }\n\n    // Now append to array of points for the tile\n    tileRequestSet[key].positions.push(positions[i]);\n  }\n\n  // create our list of result promises to be filled\n  const tilePromises = [];\n  return drainTileRequestQueue(\n    tileRequests,\n    tilePromises,\n    rejectOnTileFail,\n  ).then(function () {\n    // now all the required requests have been started\n    //  we just wait for them all to finish\n    return Promise.all(tilePromises).then(function () {\n      return positions;\n    });\n  });\n}\n\n/**\n * Calls {@link TerrainData#interpolateHeight} on a given {@link TerrainData} for a given {@link Cartographic} and\n *  will assign the height property if the return value is not undefined.\n *\n * If the return value is false; it's suggesting that you should call {@link TerrainData#createMesh} first.\n * @param {Cartographic} position The position to interpolate for and assign the height value to\n * @param {TerrainData} terrainData\n * @param {Rectangle} rectangle\n * @returns {boolean} If the height was actually interpolated and assigned\n * @private\n */\nfunction interpolateAndAssignHeight(position, terrainData, rectangle) {\n  const height = terrainData.interpolateHeight(\n    rectangle,\n    position.longitude,\n    position.latitude,\n  );\n  if (height === undefined) {\n    // if height comes back as undefined, it may implicitly mean the terrain data\n    //  requires us to call TerrainData.createMesh() first (ArcGIS requires this in particular)\n    //  so we'll return false and do that next!\n    return false;\n  }\n  position.height = height;\n  return true;\n}\n\nfunction createInterpolateFunction(tileRequest) {\n  const tilePositions = tileRequest.positions;\n  const rectangle = tileRequest.tilingScheme.tileXYToRectangle(\n    tileRequest.x,\n    tileRequest.y,\n    tileRequest.level,\n  );\n  return function (terrainData) {\n    let isMeshRequired = false;\n    for (let i = 0; i < tilePositions.length; ++i) {\n      const position = tilePositions[i];\n      const isHeightAssigned = interpolateAndAssignHeight(\n        position,\n        terrainData,\n        rectangle,\n      );\n      // we've found a position which returned undefined - hinting to us\n      //  that we probably need to create a mesh for this terrain data.\n      // so break out of this loop and create the mesh - then we'll interpolate all the heights again\n      if (!isHeightAssigned) {\n        isMeshRequired = true;\n        break;\n      }\n    }\n\n    if (!isMeshRequired) {\n      // all position heights were interpolated - we don't need the mesh\n      return Promise.resolve();\n    }\n\n    // create the mesh - and interpolate all the positions again\n    // note: terrain exaggeration is not passed in - we are only interested in the raw data\n    return terrainData\n      .createMesh({\n        tilingScheme: tileRequest.tilingScheme,\n        x: tileRequest.x,\n        y: tileRequest.y,\n        level: tileRequest.level,\n        // don't throttle this mesh creation because we've asked to sample these points;\n        //  so sample them! We don't care how many tiles that is!\n        throttle: false,\n      })\n      .then(function () {\n        // mesh has been created - so go through every position (maybe again)\n        //  and re-interpolate the heights - presumably using the mesh this time\n        for (let i = 0; i < tilePositions.length; ++i) {\n          const position = tilePositions[i];\n          // if it doesn't work this time - that's fine, we tried.\n          interpolateAndAssignHeight(position, terrainData, rectangle);\n        }\n      });\n  };\n}\n\nfunction createMarkFailedFunction(tileRequest) {\n  const tilePositions = tileRequest.positions;\n  return function () {\n    for (let i = 0; i < tilePositions.length; ++i) {\n      const position = tilePositions[i];\n      position.height = undefined;\n    }\n  };\n}\n\nexport default sampleTerrain;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}