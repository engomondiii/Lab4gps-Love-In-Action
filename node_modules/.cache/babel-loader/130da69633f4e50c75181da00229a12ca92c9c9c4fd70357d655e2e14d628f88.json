{"ast":null,"code":"import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ImageBasedLightingStageFS from \"../../Shaders/Model/ImageBasedLightingStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SpecularEnvironmentCubeMap from \"../SpecularEnvironmentCubeMap.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nconst ImageBasedLightingPipelineStage = {\n  name: \"ImageBasedLightingPipelineStage\" // Helps with debugging\n};\nconst scratchCartesian = new Cartesian2();\n\n/**\n * Add shader code, uniforms, and defines related to image based lighting\n * @param {ModelRenderResources} renderResources\n * @param {Model} model\n * @param {FrameState} frameState\n * @private\n */\nImageBasedLightingPipelineStage.process = function (renderResources, model, frameState) {\n  const imageBasedLighting = model.imageBasedLighting;\n  const environmentMapManager = model.environmentMapManager;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // If environment maps or spherical harmonics are not specifically provided, use procedural lighting.\n  let specularEnvironmentMapAtlas;\n  if (!defined(imageBasedLighting.specularEnvironmentMaps)) {\n    specularEnvironmentMapAtlas = environmentMapManager.radianceCubeMap;\n  }\n  const sphericalHarmonicCoefficients = imageBasedLighting.sphericalHarmonicCoefficients ?? environmentMapManager.sphericalHarmonicCoefficients;\n  shaderBuilder.addDefine(\"USE_IBL_LIGHTING\", undefined, ShaderDestination.FRAGMENT);\n  shaderBuilder.addUniform(\"vec2\", \"model_iblFactor\", ShaderDestination.FRAGMENT);\n  if (SpecularEnvironmentCubeMap.isSupported(frameState.context)) {\n    const addMatrix = imageBasedLighting.useSphericalHarmonics || imageBasedLighting.useSpecularEnvironmentMaps || imageBasedLighting.enabled;\n    if (addMatrix) {\n      shaderBuilder.addUniform(\"mat3\", \"model_iblReferenceFrameMatrix\", ShaderDestination.FRAGMENT);\n    }\n    if (defined(specularEnvironmentMapAtlas)) {\n      shaderBuilder.addDefine(\"COMPUTE_POSITION_WC_ATMOSPHERE\", undefined, ShaderDestination.BOTH);\n    }\n    if (defined(sphericalHarmonicCoefficients) && defined(sphericalHarmonicCoefficients[0])) {\n      shaderBuilder.addDefine(\"DIFFUSE_IBL\", undefined, ShaderDestination.FRAGMENT);\n      shaderBuilder.addDefine(\"CUSTOM_SPHERICAL_HARMONICS\", undefined, ShaderDestination.FRAGMENT);\n      shaderBuilder.addUniform(\"vec3\", \"model_sphericalHarmonicCoefficients[9]\", ShaderDestination.FRAGMENT);\n    } else if (imageBasedLighting.useDefaultSphericalHarmonics) {\n      shaderBuilder.addDefine(\"DIFFUSE_IBL\", undefined, ShaderDestination.FRAGMENT);\n    }\n    if (defined(imageBasedLighting.specularEnvironmentCubeMap) && imageBasedLighting.specularEnvironmentCubeMap.ready || defined(specularEnvironmentMapAtlas)) {\n      shaderBuilder.addDefine(\"SPECULAR_IBL\", undefined, ShaderDestination.FRAGMENT);\n      shaderBuilder.addDefine(\"CUSTOM_SPECULAR_IBL\", undefined, ShaderDestination.FRAGMENT);\n      shaderBuilder.addUniform(\"samplerCube\", \"model_specularEnvironmentMaps\", ShaderDestination.FRAGMENT);\n      shaderBuilder.addUniform(\"float\", \"model_specularEnvironmentMapsMaximumLOD\", ShaderDestination.FRAGMENT);\n    } else if (model.useDefaultSpecularMaps) {\n      shaderBuilder.addDefine(\"SPECULAR_IBL\", undefined, ShaderDestination.FRAGMENT);\n    }\n  }\n  shaderBuilder.addFragmentLines(ImageBasedLightingStageFS);\n  const uniformMap = {\n    model_iblFactor: function () {\n      return Cartesian2.multiplyByScalar(imageBasedLighting.imageBasedLightingFactor, environmentMapManager?.intensity || 1.0, scratchCartesian);\n    },\n    model_iblReferenceFrameMatrix: function () {\n      return model._iblReferenceFrameMatrix;\n    },\n    model_sphericalHarmonicCoefficients: function () {\n      return sphericalHarmonicCoefficients;\n    },\n    model_specularEnvironmentMaps: function () {\n      return imageBasedLighting.specularEnvironmentCubeMap.texture;\n    },\n    model_specularEnvironmentMapsMaximumLOD: function () {\n      return imageBasedLighting.specularEnvironmentCubeMap.maximumMipmapLevel;\n    }\n  };\n  if (defined(specularEnvironmentMapAtlas)) {\n    uniformMap.model_specularEnvironmentMaps = function () {\n      return specularEnvironmentMapAtlas;\n    };\n    uniformMap.model_specularEnvironmentMapsMaximumLOD = function () {\n      return environmentMapManager.maximumMipmapLevel;\n    };\n  }\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\nexport default ImageBasedLightingPipelineStage;","map":{"version":3,"names":["combine","defined","ImageBasedLightingStageFS","ShaderDestination","SpecularEnvironmentCubeMap","Cartesian2","ImageBasedLightingPipelineStage","name","scratchCartesian","process","renderResources","model","frameState","imageBasedLighting","environmentMapManager","shaderBuilder","specularEnvironmentMapAtlas","specularEnvironmentMaps","radianceCubeMap","sphericalHarmonicCoefficients","addDefine","undefined","FRAGMENT","addUniform","isSupported","context","addMatrix","useSphericalHarmonics","useSpecularEnvironmentMaps","enabled","BOTH","useDefaultSphericalHarmonics","specularEnvironmentCubeMap","ready","useDefaultSpecularMaps","addFragmentLines","uniformMap","model_iblFactor","multiplyByScalar","imageBasedLightingFactor","intensity","model_iblReferenceFrameMatrix","_iblReferenceFrameMatrix","model_sphericalHarmonicCoefficients","model_specularEnvironmentMaps","texture","model_specularEnvironmentMapsMaximumLOD","maximumMipmapLevel"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ImageBasedLightingPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ImageBasedLightingStageFS from \"../../Shaders/Model/ImageBasedLightingStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SpecularEnvironmentCubeMap from \"../SpecularEnvironmentCubeMap.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\n\nconst ImageBasedLightingPipelineStage = {\n  name: \"ImageBasedLightingPipelineStage\", // Helps with debugging\n};\n\nconst scratchCartesian = new Cartesian2();\n\n/**\n * Add shader code, uniforms, and defines related to image based lighting\n * @param {ModelRenderResources} renderResources\n * @param {Model} model\n * @param {FrameState} frameState\n * @private\n */\nImageBasedLightingPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  const imageBasedLighting = model.imageBasedLighting;\n  const environmentMapManager = model.environmentMapManager;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // If environment maps or spherical harmonics are not specifically provided, use procedural lighting.\n  let specularEnvironmentMapAtlas;\n  if (!defined(imageBasedLighting.specularEnvironmentMaps)) {\n    specularEnvironmentMapAtlas = environmentMapManager.radianceCubeMap;\n  }\n  const sphericalHarmonicCoefficients =\n    imageBasedLighting.sphericalHarmonicCoefficients ??\n    environmentMapManager.sphericalHarmonicCoefficients;\n\n  shaderBuilder.addDefine(\n    \"USE_IBL_LIGHTING\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addUniform(\n    \"vec2\",\n    \"model_iblFactor\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (SpecularEnvironmentCubeMap.isSupported(frameState.context)) {\n    const addMatrix =\n      imageBasedLighting.useSphericalHarmonics ||\n      imageBasedLighting.useSpecularEnvironmentMaps ||\n      imageBasedLighting.enabled;\n    if (addMatrix) {\n      shaderBuilder.addUniform(\n        \"mat3\",\n        \"model_iblReferenceFrameMatrix\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n\n    if (defined(specularEnvironmentMapAtlas)) {\n      shaderBuilder.addDefine(\n        \"COMPUTE_POSITION_WC_ATMOSPHERE\",\n        undefined,\n        ShaderDestination.BOTH,\n      );\n    }\n\n    if (\n      defined(sphericalHarmonicCoefficients) &&\n      defined(sphericalHarmonicCoefficients[0])\n    ) {\n      shaderBuilder.addDefine(\n        \"DIFFUSE_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addDefine(\n        \"CUSTOM_SPHERICAL_HARMONICS\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addUniform(\n        \"vec3\",\n        \"model_sphericalHarmonicCoefficients[9]\",\n        ShaderDestination.FRAGMENT,\n      );\n    } else if (imageBasedLighting.useDefaultSphericalHarmonics) {\n      shaderBuilder.addDefine(\n        \"DIFFUSE_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n\n    if (\n      (defined(imageBasedLighting.specularEnvironmentCubeMap) &&\n        imageBasedLighting.specularEnvironmentCubeMap.ready) ||\n      defined(specularEnvironmentMapAtlas)\n    ) {\n      shaderBuilder.addDefine(\n        \"SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addDefine(\n        \"CUSTOM_SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addUniform(\n        \"samplerCube\",\n        \"model_specularEnvironmentMaps\",\n        ShaderDestination.FRAGMENT,\n      );\n      shaderBuilder.addUniform(\n        \"float\",\n        \"model_specularEnvironmentMapsMaximumLOD\",\n        ShaderDestination.FRAGMENT,\n      );\n    } else if (model.useDefaultSpecularMaps) {\n      shaderBuilder.addDefine(\n        \"SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n\n  shaderBuilder.addFragmentLines(ImageBasedLightingStageFS);\n\n  const uniformMap = {\n    model_iblFactor: function () {\n      return Cartesian2.multiplyByScalar(\n        imageBasedLighting.imageBasedLightingFactor,\n        environmentMapManager?.intensity || 1.0,\n        scratchCartesian,\n      );\n    },\n    model_iblReferenceFrameMatrix: function () {\n      return model._iblReferenceFrameMatrix;\n    },\n    model_sphericalHarmonicCoefficients: function () {\n      return sphericalHarmonicCoefficients;\n    },\n    model_specularEnvironmentMaps: function () {\n      return imageBasedLighting.specularEnvironmentCubeMap.texture;\n    },\n    model_specularEnvironmentMapsMaximumLOD: function () {\n      return imageBasedLighting.specularEnvironmentCubeMap.maximumMipmapLevel;\n    },\n  };\n\n  if (defined(specularEnvironmentMapAtlas)) {\n    uniformMap.model_specularEnvironmentMaps = function () {\n      return specularEnvironmentMapAtlas;\n    };\n    uniformMap.model_specularEnvironmentMapsMaximumLOD = function () {\n      return environmentMapManager.maximumMipmapLevel;\n    };\n  }\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nexport default ImageBasedLightingPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}