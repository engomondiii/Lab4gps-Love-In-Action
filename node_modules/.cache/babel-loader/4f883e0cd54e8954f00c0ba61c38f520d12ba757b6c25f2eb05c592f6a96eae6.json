{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DContentGroup from \"./Cesium3DContentGroup.js\";\nimport Cesium3DTileContentFactory from \"./Cesium3DTileContentFactory.js\";\nimport Cesium3DTileContentState from \"./Cesium3DTileContentState.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport Empty3DTileContent from \"./Empty3DTileContent.js\";\nimport findContentMetadata from \"./findContentMetadata.js\";\nimport findGroupMetadata from \"./findGroupMetadata.js\";\nimport findTileMetadata from \"./findTileMetadata.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport Multiple3DTileContent from \"./Multiple3DTileContent.js\";\nimport BoundingVolumeSemantics from \"./BoundingVolumeSemantics.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileBoundingS2Cell from \"./TileBoundingS2Cell.js\";\nimport TileBoundingSphere from \"./TileBoundingSphere.js\";\nimport TileOrientedBoundingBox from \"./TileOrientedBoundingBox.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\n\n/**\n * A tile in a {@link Cesium3DTileset}.  When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * <p>\n * Do not construct this directly, instead access tiles through {@link Cesium3DTileset#tileVisible}.\n * </p>\n *\n * @alias Cesium3DTile\n * @constructor\n * @param {Cesium3DTileset} tileset The tileset\n * @param {Resource} baseResource The base resource for the tileset\n * @param {object} header The JSON header for the tile\n * @param {Cesium3DTile} parent The parent tile of the new tile\n */\nfunction Cesium3DTile(tileset, baseResource, header, parent) {\n  this._tileset = tileset;\n  this._header = header;\n  const hasContentsArray = defined(header.contents);\n  const hasMultipleContents = hasContentsArray && header.contents.length > 1 || hasExtension(header, \"3DTILES_multiple_contents\");\n\n  // In the 1.0 schema, content is stored in tile.content instead of tile.contents\n  const contentHeader = hasContentsArray && !hasMultipleContents ? header.contents[0] : header.content;\n  this._contentHeader = contentHeader;\n\n  /**\n   * The local transform of this tile.\n   * @type {Matrix4}\n   */\n  this.transform = defined(header.transform) ? Matrix4.unpack(header.transform) : Matrix4.clone(Matrix4.IDENTITY);\n  const parentTransform = defined(parent) ? parent.computedTransform : tileset.modelMatrix;\n  const computedTransform = Matrix4.multiply(parentTransform, this.transform, new Matrix4());\n  const parentInitialTransform = defined(parent) ? parent._initialTransform : Matrix4.IDENTITY;\n  this._initialTransform = Matrix4.multiply(parentInitialTransform, this.transform, new Matrix4());\n\n  /**\n   * The final computed transform of this tile.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.computedTransform = computedTransform;\n\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this stores a {@link TileMetadata} object for accessing tile metadata.\n   *\n   * @type {TileMetadata}\n   * @readonly\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.metadata = findTileMetadata(tileset, header);\n  this._verticalExaggeration = 1.0;\n  this._verticalExaggerationRelativeHeight = 0.0;\n\n  // Important: tile metadata must be parsed before this line so that the\n  // metadata semantics TILE_BOUNDING_BOX, TILE_BOUNDING_REGION, or TILE_BOUNDING_SPHERE\n  // can override header.boundingVolume (if necessary)\n  this._boundingVolume = this.createBoundingVolume(header.boundingVolume, computedTransform);\n  this._boundingVolume2D = undefined;\n  let contentBoundingVolume;\n  if (defined(contentHeader) && defined(contentHeader.boundingVolume)) {\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile.  This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    contentBoundingVolume = this.createBoundingVolume(contentHeader.boundingVolume, computedTransform);\n  }\n  this._contentBoundingVolume = contentBoundingVolume;\n  this._contentBoundingVolume2D = undefined;\n  let viewerRequestVolume;\n  if (defined(header.viewerRequestVolume)) {\n    viewerRequestVolume = this.createBoundingVolume(header.viewerRequestVolume, computedTransform);\n  }\n  this._viewerRequestVolume = viewerRequestVolume;\n\n  /**\n   * The error, in meters, introduced if this tile is rendered and its children are not.\n   * This is used to compute screen space error, i.e., the error measured in pixels.\n   *\n   * @type {number}\n   * @readonly\n   */\n  this.geometricError = header.geometricError;\n  this._geometricError = header.geometricError;\n  if (!defined(this._geometricError)) {\n    this._geometricError = defined(parent) ? parent._geometricError : tileset._geometricError;\n    Cesium3DTile._deprecationWarning(\"geometricErrorUndefined\", \"Required property geometricError is undefined for this tile. Using parent's geometric error instead.\");\n  }\n  this.updateGeometricErrorScale();\n  let refine;\n  if (defined(header.refine)) {\n    if (header.refine === \"replace\" || header.refine === \"add\") {\n      Cesium3DTile._deprecationWarning(\"lowercase-refine\", `This tile uses a lowercase refine \"${header.refine}\". Instead use \"${header.refine.toUpperCase()}\".`);\n    }\n    refine = header.refine.toUpperCase() === \"REPLACE\" ? Cesium3DTileRefine.REPLACE : Cesium3DTileRefine.ADD;\n  } else if (defined(parent)) {\n    // Inherit from parent tile if omitted.\n    refine = parent.refine;\n  } else {\n    refine = Cesium3DTileRefine.REPLACE;\n  }\n\n  /**\n   * Specifies the type of refinement that is used when traversing this tile for rendering.\n   *\n   * @type {Cesium3DTileRefine}\n   * @readonly\n   * @private\n   */\n  this.refine = refine;\n\n  /**\n   * Gets the tile's children.\n   *\n   * @type {Cesium3DTile[]}\n   * @readonly\n   */\n  this.children = [];\n\n  /**\n   * This tile's parent or <code>undefined</code> if this tile is the root.\n   * <p>\n   * When a tile's content points to an external tileset JSON file, the external tileset's\n   * root tile's parent is not <code>undefined</code>; instead, the parent references\n   * the tile (with its content pointing to an external tileset JSON file) as if the two tilesets were merged.\n   * </p>\n   *\n   * @type {Cesium3DTile}\n   * @readonly\n   */\n  this.parent = parent;\n  let content;\n  let hasEmptyContent = false;\n  let contentState;\n  let contentResource;\n  let serverKey;\n  baseResource = Resource.createIfNeeded(baseResource);\n  if (hasMultipleContents) {\n    contentState = Cesium3DTileContentState.UNLOADED;\n    // Each content may have its own URI, but they all need to be resolved\n    // relative to the tileset, so the base resource is used.\n    contentResource = baseResource.clone();\n  } else if (defined(contentHeader)) {\n    let contentHeaderUri = contentHeader.uri;\n    if (defined(contentHeader.url)) {\n      Cesium3DTile._deprecationWarning(\"contentUrl\", 'This tileset JSON uses the \"content.url\" property which has been deprecated. Use \"content.uri\" instead.');\n      contentHeaderUri = contentHeader.url;\n    }\n    if (contentHeaderUri === \"\") {\n      Cesium3DTile._deprecationWarning(\"contentUriEmpty\", \"content.uri property is an empty string, which creates a circular dependency, making this tileset invalid. Omit the content property instead\");\n      content = new Empty3DTileContent(tileset, this);\n      hasEmptyContent = true;\n      contentState = Cesium3DTileContentState.READY;\n    } else {\n      contentState = Cesium3DTileContentState.UNLOADED;\n      contentResource = baseResource.getDerivedResource({\n        url: contentHeaderUri\n      });\n      serverKey = RequestScheduler.getServerKey(contentResource.getUrlComponent());\n    }\n  } else {\n    content = new Empty3DTileContent(tileset, this);\n    hasEmptyContent = true;\n    contentState = Cesium3DTileContentState.READY;\n  }\n  this._content = content;\n  this._contentResource = contentResource;\n  this._contentState = contentState;\n  this._expiredContent = undefined;\n  this._serverKey = serverKey;\n\n  /**\n   * When <code>true</code>, the tile has no content.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasEmptyContent = hasEmptyContent;\n\n  /**\n   * When <code>true</code>, the tile's content points to an external tileset.\n   * <p>\n   * This is <code>false</code> until the tile's content is loaded.\n   * </p>\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasTilesetContent = false;\n\n  /**\n   * When <code>true</code>, the tile's content is an implicit tileset.\n   * <p>\n   * This is <code>false</code> until the tile's implicit content is loaded.\n   * </p>\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.hasImplicitContent = false;\n\n  /**\n   * When <code>true</code>, the tile contains content metadata from implicit tiling. This flag is set\n   * for tiles transcoded by <code>Implicit3DTileContent</code>.\n   * <p>\n   * This is <code>false</code> until the tile's content is loaded.\n   * </p>\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.hasImplicitContentMetadata = false;\n\n  /**\n   * When <code>true</code>, the tile has multiple contents, either in the tile JSON (3D Tiles 1.1)\n   * or via the <code>3DTILES_multiple_contents</code> extension.\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_multiple_contents|3DTILES_multiple_contents extension}\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasMultipleContents = hasMultipleContents;\n\n  /**\n   * The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n   *\n   * See {@link Cesium3DTilesetCache}\n   *\n   * @type {DoublyLinkedListNode}\n   * @readonly\n   *\n   * @private\n   */\n  this.cacheNode = undefined;\n  const expire = header.expire;\n  let expireDuration;\n  let expireDate;\n  if (defined(expire)) {\n    expireDuration = expire.duration;\n    if (defined(expire.date)) {\n      expireDate = JulianDate.fromIso8601(expire.date);\n    }\n  }\n\n  /**\n   * The time in seconds after the tile's content is ready when the content expires and new content is requested.\n   *\n   * @type {number}\n   */\n  this.expireDuration = expireDuration;\n\n  /**\n   * The date when the content expires and new content is requested.\n   *\n   * @type {JulianDate}\n   */\n  this.expireDate = expireDate;\n\n  /**\n   * The time when a style was last applied to this tile.\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this.lastStyleTime = 0.0;\n\n  /**\n   * Marks whether the tile's children bounds are fully contained within the tile's bounds\n   *\n   * @type {Cesium3DTileOptimizationHint}\n   *\n   * @private\n   */\n  this._optimChildrenWithinParent = Cesium3DTileOptimizationHint.NOT_COMPUTED;\n\n  /**\n   * Tracks if the tile's relationship with a ClippingPlaneCollection has changed with regards\n   * to the ClippingPlaneCollection's state.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.clippingPlanesDirty = false;\n\n  /**\n   * Tracks if the tile's relationship with a ClippingPolygonCollection has changed with regards\n   * to the ClippingPolygonCollection's state.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.clippingPolygonsDirty = false;\n\n  /**\n   * Tracks if the tile's request should be deferred until all non-deferred\n   * tiles load.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.priorityDeferred = false;\n\n  /**\n   * For implicit tiling, an ImplicitTileset object will be attached to a\n   * placeholder tile with either implicit tiling in the JSON (3D Tiles 1.1)\n   * or the <code>3DTILES_implicit_tiling</code> extension.\n   * This way the {@link Implicit3DTileContent} can access the tile later once the content is fetched.\n   *\n   * @type {ImplicitTileset|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.implicitTileset = undefined;\n\n  /**\n   * For implicit tiling, the (level, x, y, [z]) coordinates within the\n   * implicit tileset are stored in the tile.\n   *\n   * @type {ImplicitTileCoordinates|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.implicitCoordinates = undefined;\n\n  /**\n   * For implicit tiling, each transcoded tile will hold a weak reference to\n   * the {@link ImplicitSubtree}.\n   *\n   * @type {ImplicitSubtree|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.implicitSubtree = undefined;\n\n  // Members that are updated every frame for tree traversal and rendering optimizations:\n  this._distanceToCamera = 0.0;\n  this._centerZDepth = 0.0;\n  this._screenSpaceError = 0.0;\n  this._screenSpaceErrorProgressiveResolution = 0.0; // The screen space error at a given screen height of tileset.progressiveResolutionHeightFraction * screenHeight\n  this._visibilityPlaneMask = 0;\n  this._visible = false;\n  this._inRequestVolume = false;\n  this._finalResolution = true;\n  this._depth = 0;\n  this._stackLength = 0;\n  this._selectionDepth = 0;\n  this._updatedVisibilityFrame = 0;\n  this._touchedFrame = 0;\n  this._visitedFrame = 0;\n  this._selectedFrame = 0;\n  this._wasSelectedLastFrame = false;\n  this._requestedFrame = 0;\n  this._ancestorWithContent = undefined;\n  this._ancestorWithContentAvailable = undefined;\n  this._refines = false;\n  this._shouldSelect = false;\n  this._isClipped = true;\n  this._isClippedByPolygon = false;\n  this._clippingPlanesState = 0; // encapsulates (_isClipped, clippingPlanes.enabled) and number/function\n  this._clippingPolygonsState = 0; // encapsulates (_isClipped, clippingPolygons.enabled) and number/function\n  this._debugBoundingVolume = undefined;\n  this._debugContentBoundingVolume = undefined;\n  this._debugViewerRequestVolume = undefined;\n  this._debugColor = Color.fromRandom({\n    alpha: 1.0\n  });\n  this._debugColorizeTiles = false;\n  this._priority = 0.0; // The priority used for request sorting\n  this._priorityHolder = this; // Reference to the ancestor up the tree that holds the _foveatedFactor and _distanceToCamera for all tiles in the refinement chain.\n  this._priorityProgressiveResolution = false;\n  this._priorityProgressiveResolutionScreenSpaceErrorLeaf = false;\n  this._priorityReverseScreenSpaceError = 0.0;\n  this._foveatedFactor = 0.0;\n  this._wasMinPriorityChild = false; // Needed for knowing when to continue a refinement chain. Gets reset in updateTile in traversal and gets set in updateAndPushChildren in traversal.\n\n  this._loadTimestamp = new JulianDate();\n  this._commandsLength = 0;\n  this._color = undefined;\n  this._colorDirty = false;\n  this._request = undefined;\n}\n\n// This can be overridden for testing purposes\nCesium3DTile._deprecationWarning = deprecationWarning;\nObject.defineProperties(Cesium3DTile.prototype, {\n  /**\n   * The tileset containing this tile.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {Cesium3DTileset}\n   * @readonly\n   */\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  /**\n   * The tile's content.  This represents the actual tile's payload,\n   * not the content's metadata in the tileset JSON file.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {Cesium3DTileContent}\n   * @readonly\n   */\n  content: {\n    get: function () {\n      return this._content;\n    }\n  },\n  /**\n   * Get the tile's bounding volume.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {TileBoundingVolume}\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingVolume;\n    }\n  },\n  /**\n   * Get the bounding volume of the tile's contents.  This defaults to the\n   * tile's bounding volume when the content's bounding volume is\n   * <code>undefined</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {TileBoundingVolume}\n   * @readonly\n   * @private\n   */\n  contentBoundingVolume: {\n    get: function () {\n      return defaultValue(this._contentBoundingVolume, this._boundingVolume);\n    }\n  },\n  /**\n   * Get the bounding sphere derived from the tile's bounding volume.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingVolume.boundingSphere;\n    }\n  },\n  /**\n   * Determines if the tile is visible within the current field of view\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  isVisible: {\n    get: function () {\n      return this._visible && this._inRequestVolume;\n    }\n  },\n  /**\n   * Returns the <code>extras</code> property in the tileset JSON for this tile, which contains application specific metadata.\n   * Returns <code>undefined</code> if <code>extras</code> does not exist.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {object}\n   * @readonly\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n   */\n  extras: {\n    get: function () {\n      return this._header.extras;\n    }\n  },\n  /**\n   * Gets or sets the tile's highlight color.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {Color}\n   *\n   * @default {@link Color.WHITE}\n   *\n   * @private\n   */\n  color: {\n    get: function () {\n      if (!defined(this._color)) {\n        this._color = new Color();\n      }\n      return Color.clone(this._color);\n    },\n    set: function (value) {\n      this._color = Color.clone(value, this._color);\n      this._colorDirty = true;\n    }\n  },\n  /**\n   * Determines if the tile's content is renderable. <code>false</code> if the\n   * tile has empty content or if it points to an external tileset or implicit content\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  hasRenderableContent: {\n    get: function () {\n      return !this.hasEmptyContent && !this.hasTilesetContent && !this.hasImplicitContent;\n    }\n  },\n  /**\n   * Determines if the tile has available content to render.  <code>true</code> if the tile's\n   * content is ready or if it has expired content that renders while new content loads; otherwise,\n   * <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentAvailable: {\n    get: function () {\n      return this.contentReady && this.hasRenderableContent || defined(this._expiredContent) && !this.contentFailed;\n    }\n  },\n  /**\n   * Determines if the tile's content is ready. This is automatically <code>true</code> for\n   * tile's with empty content.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentReady: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.READY;\n    }\n  },\n  /**\n   * Determines if the tile's content has not be requested. <code>true</code> if tile's\n   * content has not be requested; otherwise, <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentUnloaded: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.UNLOADED;\n    }\n  },\n  /**\n   * Determines if the tile has renderable content which is unloaded\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  hasUnloadedRenderableContent: {\n    get: function () {\n      return this.hasRenderableContent && this.contentUnloaded;\n    }\n  },\n  /**\n   * Determines if the tile's content is expired. <code>true</code> if tile's\n   * content is expired; otherwise, <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentExpired: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.EXPIRED;\n    }\n  },\n  /**\n   * Determines if the tile's content failed to load.  <code>true</code> if the tile's\n   * content failed to load; otherwise, <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentFailed: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.FAILED;\n    }\n  },\n  /**\n   * Returns the number of draw commands used by this tile.\n   *\n   * @readonly\n   *\n   * @private\n   */\n  commandsLength: {\n    get: function () {\n      return this._commandsLength;\n    }\n  }\n});\nconst scratchCartesian = new Cartesian3();\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n * @returns {Boolean}\n */\nfunction isPriorityDeferred(tile, frameState) {\n  const {\n    tileset,\n    boundingSphere\n  } = tile;\n  const {\n    radius,\n    center\n  } = boundingSphere;\n  const {\n    camera\n  } = frameState;\n\n  // If closest point on line is inside the sphere then set foveatedFactor to 0.\n  // Otherwise, the dot product is with the line from camera to the point on the sphere that is closest to the line.\n  const scaledCameraDirection = Cartesian3.multiplyByScalar(camera.directionWC, tile._centerZDepth, scratchCartesian);\n  const closestPointOnLine = Cartesian3.add(camera.positionWC, scaledCameraDirection, scratchCartesian);\n  // The distance from the camera's view direction to the tile.\n  const toLine = Cartesian3.subtract(closestPointOnLine, center, scratchCartesian);\n  const distanceToCenterLine = Cartesian3.magnitude(toLine);\n  const notTouchingSphere = distanceToCenterLine > radius;\n\n  // If camera's direction vector is inside the bounding sphere then consider\n  // this tile right along the line of sight and set _foveatedFactor to 0.\n  // Otherwise,_foveatedFactor is one minus the dot product of the camera's direction\n  // and the vector between the camera and the point on the bounding sphere closest to the view line.\n  if (notTouchingSphere) {\n    const toLineNormalized = Cartesian3.normalize(toLine, scratchCartesian);\n    const scaledToLine = Cartesian3.multiplyByScalar(toLineNormalized, radius, scratchCartesian);\n    const closestOnSphere = Cartesian3.add(center, scaledToLine, scratchCartesian);\n    const toClosestOnSphere = Cartesian3.subtract(closestOnSphere, camera.positionWC, scratchCartesian);\n    const toClosestOnSphereNormalize = Cartesian3.normalize(toClosestOnSphere, scratchCartesian);\n    tile._foveatedFactor = 1.0 - Math.abs(Cartesian3.dot(camera.directionWC, toClosestOnSphereNormalize));\n  } else {\n    tile._foveatedFactor = 0.0;\n  }\n\n  // Skip this feature if: non-skipLevelOfDetail and replace refine, if the foveated settings are turned off, if tile is progressive resolution and replace refine and skipLevelOfDetail (will help get rid of ancestor artifacts faster)\n  // Or if the tile is a preload of any kind\n  const replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  const skipLevelOfDetail = tileset.isSkippingLevelOfDetail;\n  if (replace && !skipLevelOfDetail || !tileset.foveatedScreenSpaceError || tileset.foveatedConeSize === 1.0 || tile._priorityProgressiveResolution && replace && skipLevelOfDetail || tileset._pass === Cesium3DTilePass.PRELOAD_FLIGHT || tileset._pass === Cesium3DTilePass.PRELOAD) {\n    return false;\n  }\n  const maximumFovatedFactor = 1.0 - Math.cos(camera.frustum.fov * 0.5); // 0.14 for fov = 60. NOTE very hard to defer vertically foveated tiles since max is based on fovy (which is fov). Lowering the 0.5 to a smaller fraction of the screen height will start to defer vertically foveated tiles.\n  const foveatedConeFactor = tileset.foveatedConeSize * maximumFovatedFactor;\n\n  // If it's inside the user-defined view cone, then it should not be deferred.\n  if (tile._foveatedFactor <= foveatedConeFactor) {\n    return false;\n  }\n\n  // Relax SSE based on how big the angle is between the tile and the edge of the foveated cone.\n  const range = maximumFovatedFactor - foveatedConeFactor;\n  const normalizedFoveatedFactor = CesiumMath.clamp((tile._foveatedFactor - foveatedConeFactor) / range, 0.0, 1.0);\n  const sseRelaxation = tileset.foveatedInterpolationCallback(tileset.foveatedMinimumScreenSpaceErrorRelaxation, tileset.memoryAdjustedScreenSpaceError, normalizedFoveatedFactor);\n  const sse = tile._screenSpaceError === 0.0 && defined(tile.parent) ? tile.parent._screenSpaceError * 0.5 : tile._screenSpaceError;\n  return tileset.memoryAdjustedScreenSpaceError - sseRelaxation <= sse;\n}\nconst scratchJulianDate = new JulianDate();\n\n/**\n * Get the tile's screen space error.\n *\n * @private\n * @param {FrameState} frameState\n * @param {Boolean} useParentGeometricError\n * @param {number} progressiveResolutionHeightFraction\n */\nCesium3DTile.prototype.getScreenSpaceError = function (frameState, useParentGeometricError, progressiveResolutionHeightFraction) {\n  const tileset = this._tileset;\n  const heightFraction = defaultValue(progressiveResolutionHeightFraction, 1.0);\n  const parentGeometricError = defined(this.parent) ? this.parent.geometricError : tileset._scaledGeometricError;\n  const geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n  if (geometricError === 0.0) {\n    // Leaf tiles do not have any error so save the computation\n    return 0.0;\n  }\n  const {\n    camera,\n    context\n  } = frameState;\n  let frustum = camera.frustum;\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight * heightFraction;\n  let error;\n  if (frameState.mode === SceneMode.SCENE2D || frustum instanceof OrthographicFrustum) {\n    const offCenterFrustum = frustum.offCenterFrustum;\n    if (defined(offCenterFrustum)) {\n      frustum = offCenterFrustum;\n    }\n    const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n    error = geometricError / pixelSize;\n  } else {\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, CesiumMath.EPSILON7);\n    const sseDenominator = frustum.sseDenominator;\n    error = geometricError * height / (distance * sseDenominator);\n    if (tileset.dynamicScreenSpaceError) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = CesiumMath.fog(distance, density) * factor;\n      error -= dynamicError;\n    }\n  }\n  error /= frameState.pixelRatio;\n  return error;\n};\n\n/**\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {Cesium3DTile} tile\n * @returns {Boolean}\n */\nfunction isPriorityProgressiveResolution(tileset, tile) {\n  if (tileset.progressiveResolutionHeightFraction <= 0.0 || tileset.progressiveResolutionHeightFraction > 0.5) {\n    return false;\n  }\n  const maximumScreenSpaceError = tileset.memoryAdjustedScreenSpaceError;\n  let isProgressiveResolutionTile = tile._screenSpaceErrorProgressiveResolution > maximumScreenSpaceError; // Mark non-SSE leaves\n  tile._priorityProgressiveResolutionScreenSpaceErrorLeaf = false; // Needed for skipLOD\n  const parent = tile.parent;\n  const tilePasses = tile._screenSpaceErrorProgressiveResolution <= maximumScreenSpaceError;\n  const parentFails = defined(parent) && parent._screenSpaceErrorProgressiveResolution > maximumScreenSpaceError;\n  if (tilePasses && parentFails) {\n    // A progressive resolution SSE leaf, promote its priority as well\n    tile._priorityProgressiveResolutionScreenSpaceErrorLeaf = true;\n    isProgressiveResolutionTile = true;\n  }\n  return isProgressiveResolutionTile;\n}\n\n/**\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {Cesium3DTile} tile\n * @returns {number}\n */\nfunction getPriorityReverseScreenSpaceError(tileset, tile) {\n  const parent = tile.parent;\n  const useParentScreenSpaceError = defined(parent) && (!tileset.isSkippingLevelOfDetail || tile._screenSpaceError === 0.0 || parent.hasTilesetContent || parent.hasImplicitContent);\n  const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : tile._screenSpaceError;\n  return tileset.root._screenSpaceError - screenSpaceError;\n}\n\n/**\n * Update the tile's visibility.\n *\n * @private\n * @param {FrameState} frameState\n */\nCesium3DTile.prototype.updateVisibility = function (frameState) {\n  const {\n    parent,\n    tileset\n  } = this;\n  if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n    // The tile has already been updated for this frame\n    return;\n  }\n  const parentTransform = defined(parent) ? parent.computedTransform : tileset.modelMatrix;\n  const parentVisibilityPlaneMask = defined(parent) ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;\n  this.updateTransform(parentTransform, frameState);\n  this._distanceToCamera = this.distanceToTile(frameState);\n  this._centerZDepth = this.distanceToTileCenter(frameState);\n  this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n  this._screenSpaceErrorProgressiveResolution = this.getScreenSpaceError(frameState, false, tileset.progressiveResolutionHeightFraction);\n  this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n  this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n  this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n  this._priorityReverseScreenSpaceError = getPriorityReverseScreenSpaceError(tileset, this);\n  this._priorityProgressiveResolution = isPriorityProgressiveResolution(tileset, this);\n  this.priorityDeferred = isPriorityDeferred(this, frameState);\n  this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n};\n\n/**\n * Update whether the tile has expired.\n *\n * @private\n */\nCesium3DTile.prototype.updateExpiration = function () {\n  if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent && !this.hasMultipleContents) {\n    const now = JulianDate.now(scratchJulianDate);\n    if (JulianDate.lessThan(this.expireDate, now)) {\n      this._contentState = Cesium3DTileContentState.EXPIRED;\n      this._expiredContent = this._content;\n    }\n  }\n};\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n */\nfunction updateExpireDate(tile) {\n  if (!defined(tile.expireDuration)) {\n    return;\n  }\n  const expireDurationDate = JulianDate.now(scratchJulianDate);\n  JulianDate.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n  if (defined(tile.expireDate)) {\n    if (JulianDate.lessThan(tile.expireDate, expireDurationDate)) {\n      JulianDate.clone(expireDurationDate, tile.expireDate);\n    }\n  } else {\n    tile.expireDate = JulianDate.clone(expireDurationDate);\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @returns {Function}\n */\nfunction createPriorityFunction(tile) {\n  return function () {\n    return tile._priority;\n  };\n}\n\n/**\n * Requests the tile's content.\n * <p>\n * The request may not be made if the Cesium Request Scheduler can't prioritize it.\n * </p>\n *\n * @return {Promise<Cesium3DTileContent>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nCesium3DTile.prototype.requestContent = function () {\n  // empty contents don't require any HTTP requests\n  if (this.hasEmptyContent) {\n    return;\n  }\n  if (this.hasMultipleContents) {\n    return requestMultipleContents(this);\n  }\n  return requestSingleContent(this);\n};\n\n/**\n * Multiple {@link Cesium3DTileContent}s are allowed within a single tile either through\n * the tile JSON (3D Tiles 1.1) or the <code>3DTILES_multiple_contents</code> extension.\n * Due to differences in request scheduling, this is handled separately.\n * <p>\n * This implementation of multiple contents does not\n * support tile expiry like requestSingleContent does. If this changes,\n * note that the resource.setQueryParameters() details must go inside {@link Multiple3DTileContent} since that is per-request.\n * </p>\n *\n * @private\n * @param {Cesium3DTile} tile\n * @returns {Promise<Cesium3DTileContent>|Promise<undefined>|undefined} A promise that resolves to the tile content once loaded, or a promise that resolves to undefined if the request was cancelled mid-flight, or undefined if the request cannot be scheduled this frame\n */\nfunction requestMultipleContents(tile) {\n  let multipleContents = tile._content;\n  const tileset = tile._tileset;\n  if (!defined(multipleContents)) {\n    // Create the content object immediately, it will handle scheduling\n    // requests for inner contents.\n    const contentsJson = hasExtension(tile._header, \"3DTILES_multiple_contents\") ? tile._header.extensions[\"3DTILES_multiple_contents\"] : tile._header;\n    multipleContents = new Multiple3DTileContent(tileset, tile, tile._contentResource.clone(), contentsJson);\n    tile._content = multipleContents;\n  }\n  const promise = multipleContents.requestInnerContents();\n  if (!defined(promise)) {\n    // Request could not all be scheduled this frame\n    return;\n  }\n  tile._contentState = Cesium3DTileContentState.LOADING;\n  return promise.then(content => {\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n\n    // Tile was canceled, try again later\n    if (!defined(content)) {\n      return;\n    }\n    tile._contentState = Cesium3DTileContentState.PROCESSING;\n    return multipleContents;\n  }).catch(error => {\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  });\n}\nasync function processArrayBuffer(tile, tileset, request, expired, requestPromise) {\n  const previousState = tile._contentState;\n  tile._contentState = Cesium3DTileContentState.LOADING;\n  ++tileset.statistics.numberOfPendingRequests;\n  let arrayBuffer;\n  try {\n    arrayBuffer = await requestPromise;\n  } catch (error) {\n    --tileset.statistics.numberOfPendingRequests;\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n    if (request.cancelled || request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      tile._contentState = previousState;\n      ++tileset.statistics.numberOfAttemptedRequests;\n      return;\n    }\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n  if (tile.isDestroyed()) {\n    --tileset.statistics.numberOfPendingRequests;\n    // Tile is unloaded before the content can process\n    return;\n  }\n  if (request.cancelled || request.state === RequestState.CANCELLED) {\n    // Cancelled due to low priority - try again later.\n    tile._contentState = previousState;\n    --tileset.statistics.numberOfPendingRequests;\n    ++tileset.statistics.numberOfAttemptedRequests;\n    return;\n  }\n  try {\n    const content = await makeContent(tile, arrayBuffer);\n    --tileset.statistics.numberOfPendingRequests;\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n    if (expired) {\n      tile.expireDate = undefined;\n    }\n    tile._content = content;\n    tile._contentState = Cesium3DTileContentState.PROCESSING;\n    return content;\n  } catch (error) {\n    --tileset.statistics.numberOfPendingRequests;\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @returns {Promise<Cesium3DTileContent>|Promise<undefined>|undefined} A promise that resolves to the tile content once loaded; a promise that resolves to undefined if the tile was destroyed before processing can happen or the request was cancelled mid-flight; or undefined if the request cannot be scheduled this frame.\n */\nfunction requestSingleContent(tile) {\n  // it is important to clone here. The fetchArrayBuffer() below uses\n  // throttling, but other uses of the resources do not.\n  const resource = tile._contentResource.clone();\n  const expired = tile.contentExpired;\n  if (expired) {\n    // Append a query parameter of the tile expiration date to prevent caching\n    resource.setQueryParameters({\n      expired: tile.expireDate.toString()\n    });\n  }\n  const request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TILES3D,\n    priorityFunction: createPriorityFunction(tile),\n    serverKey: tile._serverKey\n  });\n  tile._request = request;\n  resource.request = request;\n  const tileset = tile._tileset;\n  const promise = resource.fetchArrayBuffer();\n  if (!defined(promise)) {\n    ++tileset.statistics.numberOfAttemptedRequests;\n    return;\n  }\n  return processArrayBuffer(tile, tileset, request, expired, promise);\n}\n\n/**\n * Given a downloaded content payload, construct a {@link Cesium3DTileContent}.\n * <p>\n * This is only used for single contents.\n * </p>\n *\n * @param {Cesium3DTile} tile The tile\n * @param {ArrayBuffer} arrayBuffer The downloaded payload containing data for the content\n * @return {Promise<Cesium3DTileContent>} A content object\n * @private\n */\nasync function makeContent(tile, arrayBuffer) {\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n\n  // Vector and Geometry tile rendering do not support the skip LOD optimization.\n  const tileset = tile._tileset;\n  tileset._disableSkipLevelOfDetail = tileset._disableSkipLevelOfDetail || preprocessed.contentType === Cesium3DTileContentType.GEOMETRY || preprocessed.contentType === Cesium3DTileContentType.VECTOR;\n  if (preprocessed.contentType === Cesium3DTileContentType.IMPLICIT_SUBTREE || preprocessed.contentType === Cesium3DTileContentType.IMPLICIT_SUBTREE_JSON) {\n    tile.hasImplicitContent = true;\n  }\n  if (preprocessed.contentType === Cesium3DTileContentType.EXTERNAL_TILESET) {\n    tile.hasTilesetContent = true;\n  }\n  let content;\n  const contentFactory = Cesium3DTileContentFactory[preprocessed.contentType];\n  if (tile.isDestroyed()) {\n    return;\n  }\n  if (defined(preprocessed.binaryPayload)) {\n    content = await Promise.resolve(contentFactory(tileset, tile, tile._contentResource, preprocessed.binaryPayload.buffer, 0));\n  } else {\n    // JSON formats\n    content = await Promise.resolve(contentFactory(tileset, tile, tile._contentResource, preprocessed.jsonPayload));\n  }\n  const contentHeader = tile._contentHeader;\n  if (tile.hasImplicitContentMetadata) {\n    const subtree = tile.implicitSubtree;\n    const coordinates = tile.implicitCoordinates;\n    content.metadata = subtree.getContentMetadataView(coordinates, 0);\n  } else if (!tile.hasImplicitContent) {\n    content.metadata = findContentMetadata(tileset, contentHeader);\n  }\n  const groupMetadata = findGroupMetadata(tileset, contentHeader);\n  if (defined(groupMetadata)) {\n    content.group = new Cesium3DContentGroup({\n      metadata: groupMetadata\n    });\n  }\n  return content;\n}\n\n/**\n * Cancel requests for the tile's contents. This is called when the tile\n * goes out of view.\n *\n * @private\n */\nCesium3DTile.prototype.cancelRequests = function () {\n  if (this.hasMultipleContents) {\n    this._content.cancelRequests();\n  } else {\n    this._request.cancel();\n  }\n};\n\n/**\n * Unloads the tile's content.\n *\n * @private\n */\nCesium3DTile.prototype.unloadContent = function () {\n  if (!this.hasRenderableContent) {\n    return;\n  }\n  this._content = this._content && this._content.destroy();\n  this._contentState = Cesium3DTileContentState.UNLOADED;\n  this.lastStyleTime = 0.0;\n  this.clippingPlanesDirty = this._clippingPlanesState === 0;\n  this._clippingPlanesState = 0;\n  this.clippingPolygonsDirty = this._clippingPolygonsState === 0;\n  this._clippingPolygonsState = 0;\n  this._debugColorizeTiles = false;\n  this._debugBoundingVolume = this._debugBoundingVolume && this._debugBoundingVolume.destroy();\n  this._debugContentBoundingVolume = this._debugContentBoundingVolume && this._debugContentBoundingVolume.destroy();\n  this._debugViewerRequestVolume = this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy();\n};\nconst scratchProjectedBoundingSphere = new BoundingSphere();\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n * @returns {TileBoundingVolume}\n */\nfunction getBoundingVolume(tile, frameState) {\n  if (frameState.mode !== SceneMode.SCENE3D && !defined(tile._boundingVolume2D)) {\n    const boundingSphere = tile._boundingVolume.boundingSphere;\n    const sphere = BoundingSphere.projectTo2D(boundingSphere, frameState.mapProjection, scratchProjectedBoundingSphere);\n    tile._boundingVolume2D = new TileBoundingSphere(sphere.center, sphere.radius);\n  }\n  return frameState.mode !== SceneMode.SCENE3D ? tile._boundingVolume2D : tile._boundingVolume;\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n * @returns {TileBoundingVolume}\n */\nfunction getContentBoundingVolume(tile, frameState) {\n  if (frameState.mode !== SceneMode.SCENE3D && !defined(tile._contentBoundingVolume2D)) {\n    const boundingSphere = tile._contentBoundingVolume.boundingSphere;\n    const sphere = BoundingSphere.projectTo2D(boundingSphere, frameState.mapProjection, scratchProjectedBoundingSphere);\n    tile._contentBoundingVolume2D = new TileBoundingSphere(sphere.center, sphere.radius);\n  }\n  return frameState.mode !== SceneMode.SCENE3D ? tile._contentBoundingVolume2D : tile._contentBoundingVolume;\n}\n\n/**\n * Determines whether the tile's bounding volume intersects the culling volume.\n *\n * @param {FrameState} frameState The frame state.\n * @param {number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n * @returns {number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n *\n * @private\n */\nCesium3DTile.prototype.visibility = function (frameState, parentVisibilityPlaneMask) {\n  const cullingVolume = frameState.cullingVolume;\n  const boundingVolume = getBoundingVolume(this, frameState);\n  const tileset = this._tileset;\n  const clippingPlanes = tileset.clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume, tileset.clippingPlanesOriginMatrix);\n    this._isClipped = intersection !== Intersect.INSIDE;\n    if (intersection === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    }\n  }\n  const clippingPolygons = tileset.clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const intersection = clippingPolygons.computeIntersectionWithBoundingVolume(boundingVolume);\n    this._isClippedByPolygon = intersection !== Intersect.OUTSIDE;\n    // Polygon clipping intersections are determined by outer rectangles, therefore we cannot\n    // preemptively determine if a tile is completely clipped or not here.\n  }\n  return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n};\n\n/**\n * Assuming the tile's bounding volume intersects the culling volume, determines\n * whether the tile's content's bounding volume intersects the culling volume.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n *\n * @private\n */\nCesium3DTile.prototype.contentVisibility = function (frameState) {\n  // Assumes the tile's bounding volume intersects the culling volume already, so\n  // just return Intersect.INSIDE if there is no content bounding volume.\n  if (!defined(this._contentBoundingVolume)) {\n    return Intersect.INSIDE;\n  }\n  if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n    // The tile's bounding volume is completely inside the culling volume so\n    // the content bounding volume must also be inside.\n    return Intersect.INSIDE;\n  }\n\n  // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n  // tile's (not the content's) bounding volume intersects the culling volume?\n  const cullingVolume = frameState.cullingVolume;\n  const boundingVolume = getContentBoundingVolume(this, frameState);\n  const tileset = this._tileset;\n  const clippingPlanes = tileset.clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume, tileset.clippingPlanesOriginMatrix);\n    this._isClipped = intersection !== Intersect.INSIDE;\n    if (intersection === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    }\n  }\n  const clippingPolygons = tileset.clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const intersection = clippingPolygons.computeIntersectionWithBoundingVolume(boundingVolume);\n    this._isClippedByPolygon = intersection !== Intersect.OUTSIDE;\n    if (intersection === Intersect.INSIDE) {\n      return Intersect.OUTSIDE;\n    }\n  }\n  return cullingVolume.computeVisibility(boundingVolume);\n};\n\n/**\n * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {number} The distance, in meters, or zero if the camera is inside the bounding volume.\n *\n * @private\n */\nCesium3DTile.prototype.distanceToTile = function (frameState) {\n  const boundingVolume = getBoundingVolume(this, frameState);\n  return boundingVolume.distanceToCamera(frameState);\n};\nconst scratchToTileCenter = new Cartesian3();\n\n/**\n * Computes the distance from the center of the tile's bounding volume to the camera's plane defined by its position and view direction.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {number} The distance, in meters.\n *\n * @private\n */\nCesium3DTile.prototype.distanceToTileCenter = function (frameState) {\n  const tileBoundingVolume = getBoundingVolume(this, frameState);\n  const boundingVolume = tileBoundingVolume.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n  const toCenter = Cartesian3.subtract(boundingVolume.center, frameState.camera.positionWC, scratchToTileCenter);\n  return Cartesian3.dot(frameState.camera.directionWC, toCenter);\n};\n\n/**\n * Checks if the camera is inside the viewer request volume.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {boolean} Whether the camera is inside the volume.\n *\n * @private\n */\nCesium3DTile.prototype.insideViewerRequestVolume = function (frameState) {\n  const viewerRequestVolume = this._viewerRequestVolume;\n  return !defined(viewerRequestVolume) || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n};\nconst scratchMatrix = new Matrix3();\nconst scratchScale = new Cartesian3();\nconst scratchHalfAxes = new Matrix3();\nconst scratchCenter = new Cartesian3();\nconst scratchRectangle = new Rectangle();\nconst scratchOrientedBoundingBox = new OrientedBoundingBox();\nconst scratchTransform = new Matrix4();\n\n/**\n * @private\n * @param {Array} box An array of 12 numbers that define an oriented bounding box\n * @param {Matrix4} transform\n * @param {TileBoundingVolume} [result]\n * @returns {TileOrientedBoundingBox}\n */\nfunction createBox(box, transform, result) {\n  let center = Cartesian3.fromElements(box[0], box[1], box[2], scratchCenter);\n  let halfAxes = Matrix3.fromArray(box, 3, scratchHalfAxes);\n\n  // Find the transformed center and halfAxes\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getMatrix3(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n  if (defined(result)) {\n    result.update(center, halfAxes);\n    return result;\n  }\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\n/**\n * @private\n * @param {Array} region An array of six numbers that define a bounding geographic region in EPSG:4979 coordinates with the order [west, south, east, north, minimum height, maximum height]\n * @param {Matrix4} transform\n * @param {Matrix4} initialTransform\n * @param {TileOrientedBoundingBox} [result]\n * @returns {TileOrientedBoundingBox}\n */\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, Ellipsoid.WGS84, scratchOrientedBoundingBox);\n  let center = orientedBoundingBox.center;\n  let halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(transform, Matrix4.inverseTransformation(initialTransform, scratchTransform), scratchTransform);\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getMatrix3(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\n/**\n * @private\n * @param {Array} region An array of six numbers that define a bounding geographic region in EPSG:4979 coordinates with the order [west, south, east, north, minimum height, maximum height]\n * @param {Matrix4} transform\n * @param {Matrix4} initialTransform\n * @param {TileBoundingVolume} [result]\n * @returns {TileBoundingVolume}\n */\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n  if (defined(result)) {\n    result.rectangle = Rectangle.clone(rectangleRegion, result.rectangle);\n    result.minimumHeight = region[4];\n    result.maximumHeight = region[5];\n    // The TileBoundingRegion was already constructed with the default\n    // WGS84 ellipsoid, so keep it consistent when updating.\n    result.computeBoundingVolumes(Ellipsoid.WGS84);\n    return result;\n  }\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n\n/**\n * @private\n * @param {Array} sphere An array of four numbers that define a bounding sphere\n * @param {Matrix4} transform\n * @param {TileBoundingVolume} [result]\n * @returns {TileBoundingSphere}\n */\nfunction createSphere(sphere, transform, result) {\n  let center = Cartesian3.fromElements(sphere[0], sphere[1], sphere[2], scratchCenter);\n  let radius = sphere[3];\n\n  // Find the transformed center and radius\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const scale = Matrix4.getScale(transform, scratchScale);\n  const uniformScale = Cartesian3.maximumComponent(scale);\n  radius *= uniformScale;\n  if (defined(result)) {\n    result.update(center, radius);\n    return result;\n  }\n  return new TileBoundingSphere(center, radius);\n}\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n *\n * @param {object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param {TileBoundingVolume} [result] The object onto which to store the result.\n *\n * @returns {TileBoundingVolume} The modified result parameter or a new TileBoundingVolume instance if none was provided.\n *\n * @private\n */\nCesium3DTile.prototype.createBoundingVolume = function (boundingVolumeHeader, transform, result) {\n  // if explicit tile metadata includes TILE_BOUNDING_BOX, TILE_BOUNDING_REGION,\n  // or TILE_BOUNDING_SPHERE, override tile.boundingVolume.\n  const tileMetadata = this.metadata;\n  let metadataBoundingVolumeHeader;\n  if (defined(tileMetadata)) {\n    metadataBoundingVolumeHeader = BoundingVolumeSemantics.parseBoundingVolumeSemantic(\"TILE\", tileMetadata);\n  }\n  if (defined(metadataBoundingVolumeHeader)) {\n    boundingVolumeHeader = metadataBoundingVolumeHeader;\n  }\n  if (!defined(boundingVolumeHeader)) {\n    throw new RuntimeError(\"boundingVolume must be defined\");\n  }\n  if (hasExtension(boundingVolumeHeader, \"3DTILES_bounding_volume_S2\")) {\n    return new TileBoundingS2Cell(boundingVolumeHeader.extensions[\"3DTILES_bounding_volume_S2\"]);\n  }\n  const {\n    box,\n    region,\n    sphere\n  } = boundingVolumeHeader;\n  if (defined(box)) {\n    const tileOrientedBoundingBox = createBox(box, transform, result);\n    if (this._verticalExaggeration !== 1.0) {\n      exaggerateBoundingBox(tileOrientedBoundingBox, this._verticalExaggeration, this._verticalExaggerationRelativeHeight);\n    }\n    return tileOrientedBoundingBox;\n  }\n  if (defined(region)) {\n    const tileBoundingVolume = createRegion(region, transform, this._initialTransform, result);\n    if (this._verticalExaggeration === 1.0) {\n      return tileBoundingVolume;\n    }\n    if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n      exaggerateBoundingBox(tileBoundingVolume, this._verticalExaggeration, this._verticalExaggerationRelativeHeight);\n    } else {\n      tileBoundingVolume.minimumHeight = VerticalExaggeration.getHeight(tileBoundingVolume.minimumHeight, this._verticalExaggeration, this._verticalExaggerationRelativeHeight);\n      tileBoundingVolume.maximumHeight = VerticalExaggeration.getHeight(tileBoundingVolume.maximumHeight, this._verticalExaggeration, this._verticalExaggerationRelativeHeight);\n      tileBoundingVolume.computeBoundingVolumes(Ellipsoid.WGS84);\n    }\n    return tileBoundingVolume;\n  }\n  if (defined(sphere)) {\n    const tileBoundingSphere = createSphere(sphere, transform, result);\n    if (this._verticalExaggeration !== 1.0) {\n      const exaggeratedCenter = VerticalExaggeration.getPosition(tileBoundingSphere.center, Ellipsoid.WGS84, this._verticalExaggeration, this._verticalExaggerationRelativeHeight, scratchCenter);\n      const exaggeratedRadius = tileBoundingSphere.radius * this._verticalExaggeration;\n      tileBoundingSphere.update(exaggeratedCenter, exaggeratedRadius);\n    }\n    return tileBoundingSphere;\n  }\n  throw new RuntimeError(\"boundingVolume must contain a sphere, region, or box\");\n};\nconst scratchExaggeratedCorners = Cartesian3.unpackArray(new Array(8 * 3).fill(0));\n\n/**\n * Exaggerates the bounding box of a tile based on the provided exaggeration factors.\n *\n * @private\n * @param {TileOrientedBoundingBox} tileOrientedBoundingBox - The oriented bounding box of the tile.\n * @param {number} exaggeration - The exaggeration factor to apply to the tile's bounding box.\n * @param {number} exaggerationRelativeHeight - The height relative to which exaggeration will be applied.\n */\nfunction exaggerateBoundingBox(tileOrientedBoundingBox, exaggeration, exaggerationRelativeHeight) {\n  const exaggeratedCorners = tileOrientedBoundingBox.boundingVolume.computeCorners(scratchExaggeratedCorners).map(corner => VerticalExaggeration.getPosition(corner, Ellipsoid.WGS84, exaggeration, exaggerationRelativeHeight, corner));\n  const exaggeratedBox = OrientedBoundingBox.fromPoints(exaggeratedCorners, scratchOrientedBoundingBox);\n  tileOrientedBoundingBox.update(exaggeratedBox.center, exaggeratedBox.halfAxes);\n}\n\n/**\n * Update the tile's transform. The transform is applied to the tile's bounding volumes.\n *\n * @private\n * @param {Matrix4} parentTransform\n * @param {FrameState} [frameState]\n */\nCesium3DTile.prototype.updateTransform = function (parentTransform, frameState) {\n  parentTransform = defaultValue(parentTransform, Matrix4.IDENTITY);\n  const computedTransform = Matrix4.multiplyTransformation(parentTransform, this.transform, scratchTransform);\n  const transformChanged = !Matrix4.equals(computedTransform, this.computedTransform);\n  const exaggerationChanged = defined(frameState) && (this._verticalExaggeration !== frameState.verticalExaggeration || this._verticalExaggerationRelativeHeight !== frameState.verticalExaggerationRelativeHeight);\n  if (!transformChanged && !exaggerationChanged) {\n    return;\n  }\n  if (transformChanged) {\n    Matrix4.clone(computedTransform, this.computedTransform);\n  }\n  if (exaggerationChanged) {\n    this._verticalExaggeration = frameState.verticalExaggeration;\n    this._verticalExaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n  }\n\n  // Update the bounding volumes\n  const header = this._header;\n  const contentHeader = this._contentHeader;\n  this._boundingVolume = this.createBoundingVolume(header.boundingVolume, this.computedTransform, this._boundingVolume);\n  if (defined(this._contentBoundingVolume)) {\n    this._contentBoundingVolume = this.createBoundingVolume(contentHeader.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n  }\n  if (defined(this._viewerRequestVolume)) {\n    this._viewerRequestVolume = this.createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n  }\n  this.updateGeometricErrorScale();\n\n  // Destroy the debug bounding volumes. They will be generated fresh.\n  this._debugBoundingVolume = this._debugBoundingVolume && this._debugBoundingVolume.destroy();\n  this._debugContentBoundingVolume = this._debugContentBoundingVolume && this._debugContentBoundingVolume.destroy();\n  this._debugViewerRequestVolume = this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy();\n};\nCesium3DTile.prototype.updateGeometricErrorScale = function () {\n  const scale = Matrix4.getScale(this.computedTransform, scratchScale);\n  const uniformScale = Cartesian3.maximumComponent(scale);\n  this.geometricError = this._geometricError * uniformScale;\n  if (!defined(this.parent)) {\n    // Update the tileset's geometric error\n    const tileset = this._tileset;\n    tileset._scaledGeometricError = tileset._geometricError * uniformScale;\n  }\n};\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n * @param {object} passOptions\n */\nfunction applyDebugSettings(tile, tileset, frameState, passOptions) {\n  if (!passOptions.isRender) {\n    return;\n  }\n  const hasContentBoundingVolume = defined(tile._contentHeader) && defined(tile._contentHeader.boundingVolume);\n  const showVolume = tileset.debugShowBoundingVolume || tileset.debugShowContentBoundingVolume && !hasContentBoundingVolume;\n  if (showVolume) {\n    let color;\n    if (!tile._finalResolution) {\n      color = Color.YELLOW;\n    } else if (!tile.hasRenderableContent) {\n      color = Color.DARKGRAY;\n    } else {\n      color = Color.WHITE;\n    }\n    if (!defined(tile._debugBoundingVolume)) {\n      tile._debugBoundingVolume = tile._boundingVolume.createDebugVolume(color);\n    }\n    tile._debugBoundingVolume.update(frameState);\n    const attributes = tile._debugBoundingVolume.getGeometryInstanceAttributes(\"outline\");\n    attributes.color = ColorGeometryInstanceAttribute.toValue(color, attributes.color);\n  } else if (!showVolume && defined(tile._debugBoundingVolume)) {\n    tile._debugBoundingVolume = tile._debugBoundingVolume.destroy();\n  }\n  if (tileset.debugShowContentBoundingVolume && hasContentBoundingVolume) {\n    if (!defined(tile._debugContentBoundingVolume)) {\n      tile._debugContentBoundingVolume = tile._contentBoundingVolume.createDebugVolume(Color.BLUE);\n    }\n    tile._debugContentBoundingVolume.update(frameState);\n  } else if (!tileset.debugShowContentBoundingVolume && defined(tile._debugContentBoundingVolume)) {\n    tile._debugContentBoundingVolume = tile._debugContentBoundingVolume.destroy();\n  }\n  if (tileset.debugShowViewerRequestVolume && defined(tile._viewerRequestVolume)) {\n    if (!defined(tile._debugViewerRequestVolume)) {\n      tile._debugViewerRequestVolume = tile._viewerRequestVolume.createDebugVolume(Color.YELLOW);\n    }\n    tile._debugViewerRequestVolume.update(frameState);\n  } else if (!tileset.debugShowViewerRequestVolume && defined(tile._debugViewerRequestVolume)) {\n    tile._debugViewerRequestVolume = tile._debugViewerRequestVolume.destroy();\n  }\n  const debugColorizeTilesOn = tileset.debugColorizeTiles && !tile._debugColorizeTiles || defined(tileset._heatmap.tilePropertyName);\n  const debugColorizeTilesOff = !tileset.debugColorizeTiles && tile._debugColorizeTiles;\n  if (debugColorizeTilesOn) {\n    tileset._heatmap.colorize(tile, frameState); // Skipped if tileset._heatmap.tilePropertyName is undefined\n    tile._debugColorizeTiles = true;\n    tile.color = tile._debugColor;\n  } else if (debugColorizeTilesOff) {\n    tile._debugColorizeTiles = false;\n    tile.color = Color.WHITE;\n  }\n  if (tile._colorDirty) {\n    tile._colorDirty = false;\n    tile._content.applyDebugSettings(true, tile._color);\n  }\n  if (debugColorizeTilesOff) {\n    tileset.makeStyleDirty(); // Re-apply style now that colorize is switched off\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n */\nfunction updateContent(tile, tileset, frameState) {\n  const expiredContent = tile._expiredContent;\n\n  // expired content is not supported for multiple contents\n  if (!tile.hasMultipleContents && defined(expiredContent)) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      try {\n        expiredContent.update(tileset, frameState);\n      } catch (error) {\n        // Eat error for expired content\n      }\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n  if (!defined(tile.content)) {\n    // Implicit placeholder tile\n    return;\n  }\n  try {\n    tile.content.update(tileset, frameState);\n  } catch (error) {\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n}\n\n/**\n * Compute and compare ClippingPlanes state:\n *  - enabled-ness - are clipping planes enabled? is this tile clipped?\n *  - clipping plane count\n *  - clipping function (union v. intersection)\n\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n */\nfunction updateClippingPlanes(tile, tileset) {\n  const clippingPlanes = tileset.clippingPlanes;\n  let currentClippingPlanesState = 0;\n  if (defined(clippingPlanes) && tile._isClipped && clippingPlanes.enabled) {\n    currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n  // If clippingPlaneState for tile changed, mark clippingPlanesDirty so content can update\n  if (currentClippingPlanesState !== tile._clippingPlanesState) {\n    tile._clippingPlanesState = currentClippingPlanesState;\n    tile.clippingPlanesDirty = true;\n  }\n}\n\n/**\n * Compute and compare ClippingPolygons state:\n *  - enabled-ness - are clipping polygons enabled? is this tile clipped?\n *  - clipping polygon count & position count\n *  - clipping function (inverse)\n\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n */\nfunction updateClippingPolygons(tile, tileset) {\n  const clippingPolygons = tileset.clippingPolygons;\n  let currentClippingPolygonsState = 0;\n  if (defined(clippingPolygons) && tile._isClippedByPolygon && clippingPolygons.enabled) {\n    currentClippingPolygonsState = clippingPolygons.clippingPolygonsState;\n  }\n  // If clippingPolygonState for tile changed, mark clippingPolygonsDirty so content can update\n  if (currentClippingPolygonsState !== tile._clippingPolygonsState) {\n    tile._clippingPolygonsState = currentClippingPolygonsState;\n    tile.clippingPolygonsDirty = true;\n  }\n}\n\n/**\n * Get the draw commands needed to render this tile.\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n * @param {object} passOptions\n */\nCesium3DTile.prototype.update = function (tileset, frameState, passOptions) {\n  const {\n    commandList\n  } = frameState;\n  const commandStart = commandList.length;\n  updateClippingPlanes(this, tileset);\n  updateClippingPolygons(this, tileset);\n  applyDebugSettings(this, tileset, frameState, passOptions);\n  updateContent(this, tileset, frameState);\n  const commandEnd = commandList.length;\n  this._commandsLength = commandEnd - commandStart;\n  for (let i = commandStart; i < commandEnd; ++i) {\n    const command = commandList[i];\n    const translucent = command.pass === Pass.TRANSLUCENT;\n    command.depthForTranslucentClassification = translucent;\n  }\n  this.clippingPlanesDirty = false; // reset after content update\n  this.clippingPolygonsDirty = false;\n};\nconst scratchCommandList = [];\n\n/**\n * Processes the tile's content, e.g., create WebGL resources, to move from the PROCESSING to READY state.\n *\n * @param {Cesium3DTileset} tileset The tileset containing this tile.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nCesium3DTile.prototype.process = function (tileset, frameState) {\n  if (!this.contentExpired && !this.contentReady && this._content.ready) {\n    updateExpireDate(this);\n\n    // Refresh style for expired content\n    this._selectedFrame = 0;\n    this.lastStyleTime = 0.0;\n    JulianDate.now(this._loadTimestamp);\n    this._contentState = Cesium3DTileContentState.READY;\n    if (!this.hasTilesetContent && !this.hasImplicitContent) {\n      // RESEARCH_IDEA: ability to unload tiles (without content) for an\n      // external tileset when all the tiles are unloaded.\n      tileset._statistics.incrementLoadCounts(this.content);\n      ++tileset._statistics.numberOfTilesWithContentReady;\n      ++tileset._statistics.numberOfLoadedTilesTotal;\n\n      // Add to the tile cache. Previously expired tiles are already in the cache and won't get re-added.\n      tileset._cache.add(this);\n    }\n  }\n  const savedCommandList = frameState.commandList;\n  frameState.commandList = scratchCommandList;\n  try {\n    this._content.update(tileset, frameState);\n  } catch (error) {\n    this._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n  scratchCommandList.length = 0;\n  frameState.commandList = savedCommandList;\n};\n\n/**\n * @private\n * @param {number} normalizedValue\n * @param {number} numberOfDigits\n * @param {number} leftShift\n * @returns {number}\n */\nfunction isolateDigits(normalizedValue, numberOfDigits, leftShift) {\n  const scaled = normalizedValue * Math.pow(10, numberOfDigits);\n  const integer = parseInt(scaled);\n  return integer * Math.pow(10, leftShift);\n}\n\n/**\n * @private\n * @param {number} value\n * @param {number} minimum\n * @param {number} maximum\n * @returns {number}\n */\nfunction priorityNormalizeAndClamp(value, minimum, maximum) {\n  // Subtract epsilon since we only want decimal digits present in the output.\n  return Math.max(CesiumMath.normalize(value, minimum, maximum) - CesiumMath.EPSILON7, 0.0);\n}\n\n/**\n * Sets the priority of the tile based on distance and depth\n * @private\n */\nCesium3DTile.prototype.updatePriority = function () {\n  const tileset = this.tileset;\n  const preferLeaves = tileset.preferLeaves;\n  const minimumPriority = tileset._minimumPriority;\n  const maximumPriority = tileset._maximumPriority;\n\n  // Combine priority systems together by mapping them into a base 10 number where each priority controls a specific set of digits in the number.\n  // For number priorities, map them to a 0.xxxxx number then left shift it up into a set number of digits before the decimal point. Chop of the fractional part then left shift again into the position it needs to go.\n  // For blending number priorities, normalize them to 0-1 and interpolate to get a combined 0-1 number, then proceed as normal.\n  // Booleans can just be 0 or 10^leftshift.\n  // Think of digits as penalties since smaller numbers are higher priority. If a tile has some large quantity or has a flag raised it's (usually) penalized for it, expressed as a higher number for the digit.\n  // Priority number format: preloadFlightDigits(1) | foveatedDeferDigits(1) | foveatedDigits(4) | preloadProgressiveResolutionDigits(1) | preferredSortingDigits(4) . depthDigits(the decimal digits)\n  // Certain flags like preferLeaves will flip / turn off certain digits to get desired load order.\n\n  // Setup leftShifts, digit counts, and scales (for booleans)\n  const digitsForANumber = 4;\n  const digitsForABoolean = 1;\n  const preferredSortingLeftShift = 0;\n  const preferredSortingDigitsCount = digitsForANumber;\n  const foveatedLeftShift = preferredSortingLeftShift + preferredSortingDigitsCount;\n  const foveatedDigitsCount = digitsForANumber;\n  const preloadProgressiveResolutionLeftShift = foveatedLeftShift + foveatedDigitsCount;\n  const preloadProgressiveResolutionDigitsCount = digitsForABoolean;\n  const preloadProgressiveResolutionScale = Math.pow(10, preloadProgressiveResolutionLeftShift);\n  const foveatedDeferLeftShift = preloadProgressiveResolutionLeftShift + preloadProgressiveResolutionDigitsCount;\n  const foveatedDeferDigitsCount = digitsForABoolean;\n  const foveatedDeferScale = Math.pow(10, foveatedDeferLeftShift);\n  const preloadFlightLeftShift = foveatedDeferLeftShift + foveatedDeferDigitsCount;\n  const preloadFlightScale = Math.pow(10, preloadFlightLeftShift);\n\n  // Compute the digits for each priority\n  let depthDigits = priorityNormalizeAndClamp(this._depth, minimumPriority.depth, maximumPriority.depth);\n  depthDigits = preferLeaves ? 1.0 - depthDigits : depthDigits;\n\n  // Map 0-1 then convert to digit. Include a distance sort when doing non-skipLOD and replacement refinement, helps things like non-skipLOD photogrammetry\n  const useDistance = !tileset.isSkippingLevelOfDetail && this.refine === Cesium3DTileRefine.REPLACE;\n  const normalizedPreferredSorting = useDistance ? priorityNormalizeAndClamp(this._priorityHolder._distanceToCamera, minimumPriority.distance, maximumPriority.distance) : priorityNormalizeAndClamp(this._priorityReverseScreenSpaceError, minimumPriority.reverseScreenSpaceError, maximumPriority.reverseScreenSpaceError);\n  const preferredSortingDigits = isolateDigits(normalizedPreferredSorting, preferredSortingDigitsCount, preferredSortingLeftShift);\n  const preloadProgressiveResolutionDigits = this._priorityProgressiveResolution ? 0 : preloadProgressiveResolutionScale;\n  const normalizedFoveatedFactor = priorityNormalizeAndClamp(this._priorityHolder._foveatedFactor, minimumPriority.foveatedFactor, maximumPriority.foveatedFactor);\n  const foveatedDigits = isolateDigits(normalizedFoveatedFactor, foveatedDigitsCount, foveatedLeftShift);\n  const foveatedDeferDigits = this.priorityDeferred ? foveatedDeferScale : 0;\n  const preloadFlightDigits = tileset._pass === Cesium3DTilePass.PRELOAD_FLIGHT ? 0 : preloadFlightScale;\n\n  // Get the final base 10 number\n  this._priority = depthDigits + preferredSortingDigits + preloadProgressiveResolutionDigits + foveatedDigits + foveatedDeferDigits + preloadFlightDigits;\n};\n\n/**\n * @private\n */\nCesium3DTile.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nCesium3DTile.prototype.destroy = function () {\n  // For the interval between new content being requested and downloaded, expiredContent === content, so don't destroy twice\n  this._content = this._content && this._content.destroy();\n  this._expiredContent = this._expiredContent && !this._expiredContent.isDestroyed() && this._expiredContent.destroy();\n  this._debugBoundingVolume = this._debugBoundingVolume && this._debugBoundingVolume.destroy();\n  this._debugContentBoundingVolume = this._debugContentBoundingVolume && this._debugContentBoundingVolume.destroy();\n  this._debugViewerRequestVolume = this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy();\n  return destroyObject(this);\n};\nexport default Cesium3DTile;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Color","ColorGeometryInstanceAttribute","CullingVolume","defaultValue","defined","deprecationWarning","destroyObject","Ellipsoid","Intersect","JulianDate","CesiumMath","Matrix3","Matrix4","OrientedBoundingBox","OrthographicFrustum","Rectangle","Request","RequestScheduler","RequestState","RequestType","Resource","RuntimeError","Cesium3DContentGroup","Cesium3DTileContentFactory","Cesium3DTileContentState","Cesium3DTileContentType","Cesium3DTileOptimizationHint","Cesium3DTilePass","Cesium3DTileRefine","Empty3DTileContent","findContentMetadata","findGroupMetadata","findTileMetadata","hasExtension","Multiple3DTileContent","BoundingVolumeSemantics","preprocess3DTileContent","SceneMode","TileBoundingRegion","TileBoundingS2Cell","TileBoundingSphere","TileOrientedBoundingBox","Pass","VerticalExaggeration","Cesium3DTile","tileset","baseResource","header","parent","_tileset","_header","hasContentsArray","contents","hasMultipleContents","length","contentHeader","content","_contentHeader","transform","unpack","clone","IDENTITY","parentTransform","computedTransform","modelMatrix","multiply","parentInitialTransform","_initialTransform","metadata","_verticalExaggeration","_verticalExaggerationRelativeHeight","_boundingVolume","createBoundingVolume","boundingVolume","_boundingVolume2D","undefined","contentBoundingVolume","_contentBoundingVolume","_contentBoundingVolume2D","viewerRequestVolume","_viewerRequestVolume","geometricError","_geometricError","_deprecationWarning","updateGeometricErrorScale","refine","toUpperCase","REPLACE","ADD","children","hasEmptyContent","contentState","contentResource","serverKey","createIfNeeded","UNLOADED","contentHeaderUri","uri","url","READY","getDerivedResource","getServerKey","getUrlComponent","_content","_contentResource","_contentState","_expiredContent","_serverKey","hasTilesetContent","hasImplicitContent","hasImplicitContentMetadata","cacheNode","expire","expireDuration","expireDate","duration","date","fromIso8601","lastStyleTime","_optimChildrenWithinParent","NOT_COMPUTED","clippingPlanesDirty","clippingPolygonsDirty","priorityDeferred","implicitTileset","implicitCoordinates","implicitSubtree","_distanceToCamera","_centerZDepth","_screenSpaceError","_screenSpaceErrorProgressiveResolution","_visibilityPlaneMask","_visible","_inRequestVolume","_finalResolution","_depth","_stackLength","_selectionDepth","_updatedVisibilityFrame","_touchedFrame","_visitedFrame","_selectedFrame","_wasSelectedLastFrame","_requestedFrame","_ancestorWithContent","_ancestorWithContentAvailable","_refines","_shouldSelect","_isClipped","_isClippedByPolygon","_clippingPlanesState","_clippingPolygonsState","_debugBoundingVolume","_debugContentBoundingVolume","_debugViewerRequestVolume","_debugColor","fromRandom","alpha","_debugColorizeTiles","_priority","_priorityHolder","_priorityProgressiveResolution","_priorityProgressiveResolutionScreenSpaceErrorLeaf","_priorityReverseScreenSpaceError","_foveatedFactor","_wasMinPriorityChild","_loadTimestamp","_commandsLength","_color","_colorDirty","_request","Object","defineProperties","prototype","get","boundingSphere","isVisible","extras","color","set","value","hasRenderableContent","contentAvailable","contentReady","contentFailed","contentUnloaded","hasUnloadedRenderableContent","contentExpired","EXPIRED","FAILED","commandsLength","scratchCartesian","isPriorityDeferred","tile","frameState","radius","center","camera","scaledCameraDirection","multiplyByScalar","directionWC","closestPointOnLine","add","positionWC","toLine","subtract","distanceToCenterLine","magnitude","notTouchingSphere","toLineNormalized","normalize","scaledToLine","closestOnSphere","toClosestOnSphere","toClosestOnSphereNormalize","Math","abs","dot","replace","skipLevelOfDetail","isSkippingLevelOfDetail","foveatedScreenSpaceError","foveatedConeSize","_pass","PRELOAD_FLIGHT","PRELOAD","maximumFovatedFactor","cos","frustum","fov","foveatedConeFactor","range","normalizedFoveatedFactor","clamp","sseRelaxation","foveatedInterpolationCallback","foveatedMinimumScreenSpaceErrorRelaxation","memoryAdjustedScreenSpaceError","sse","scratchJulianDate","getScreenSpaceError","useParentGeometricError","progressiveResolutionHeightFraction","heightFraction","parentGeometricError","_scaledGeometricError","context","width","drawingBufferWidth","height","drawingBufferHeight","error","mode","SCENE2D","offCenterFrustum","pixelSize","max","top","bottom","right","left","distance","EPSILON7","sseDenominator","dynamicScreenSpaceError","density","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","fog","pixelRatio","isPriorityProgressiveResolution","maximumScreenSpaceError","isProgressiveResolutionTile","tilePasses","parentFails","getPriorityReverseScreenSpaceError","useParentScreenSpaceError","screenSpaceError","root","updateVisibility","parentVisibilityPlaneMask","MASK_INDETERMINATE","updateTransform","distanceToTile","distanceToTileCenter","visibility","MASK_OUTSIDE","insideViewerRequestVolume","updateExpiration","now","lessThan","updateExpireDate","expireDurationDate","addSeconds","createPriorityFunction","requestContent","requestMultipleContents","requestSingleContent","multipleContents","contentsJson","extensions","promise","requestInnerContents","LOADING","then","isDestroyed","PROCESSING","catch","processArrayBuffer","request","expired","requestPromise","previousState","statistics","numberOfPendingRequests","arrayBuffer","cancelled","state","CANCELLED","numberOfAttemptedRequests","makeContent","resource","setQueryParameters","toString","throttle","throttleByServer","type","TILES3D","priorityFunction","fetchArrayBuffer","preprocessed","_disableSkipLevelOfDetail","contentType","GEOMETRY","VECTOR","IMPLICIT_SUBTREE","IMPLICIT_SUBTREE_JSON","EXTERNAL_TILESET","contentFactory","binaryPayload","Promise","resolve","buffer","jsonPayload","subtree","coordinates","getContentMetadataView","groupMetadata","group","cancelRequests","cancel","unloadContent","destroy","scratchProjectedBoundingSphere","getBoundingVolume","SCENE3D","sphere","projectTo2D","mapProjection","getContentBoundingVolume","cullingVolume","clippingPlanes","enabled","intersection","computeIntersectionWithBoundingVolume","clippingPlanesOriginMatrix","INSIDE","OUTSIDE","clippingPolygons","computeVisibilityWithPlaneMask","contentVisibility","MASK_INSIDE","computeVisibility","distanceToCamera","scratchToTileCenter","tileBoundingVolume","toCenter","scratchMatrix","scratchScale","scratchHalfAxes","scratchCenter","scratchRectangle","scratchOrientedBoundingBox","scratchTransform","createBox","box","result","fromElements","halfAxes","fromArray","multiplyByPoint","rotationScale","getMatrix3","update","createBoxFromTransformedRegion","region","initialTransform","rectangle","minimumHeight","maximumHeight","orientedBoundingBox","fromRectangle","WGS84","multiplyTransformation","inverseTransformation","createRegion","equalsEpsilon","EPSILON8","rectangleRegion","computeBoundingVolumes","createSphere","scale","getScale","uniformScale","maximumComponent","boundingVolumeHeader","tileMetadata","metadataBoundingVolumeHeader","parseBoundingVolumeSemantic","tileOrientedBoundingBox","exaggerateBoundingBox","getHeight","tileBoundingSphere","exaggeratedCenter","getPosition","exaggeratedRadius","scratchExaggeratedCorners","unpackArray","Array","fill","exaggeration","exaggerationRelativeHeight","exaggeratedCorners","computeCorners","map","corner","exaggeratedBox","fromPoints","transformChanged","equals","exaggerationChanged","verticalExaggeration","verticalExaggerationRelativeHeight","applyDebugSettings","passOptions","isRender","hasContentBoundingVolume","showVolume","debugShowBoundingVolume","debugShowContentBoundingVolume","YELLOW","DARKGRAY","WHITE","createDebugVolume","attributes","getGeometryInstanceAttributes","toValue","BLUE","debugShowViewerRequestVolume","debugColorizeTilesOn","debugColorizeTiles","_heatmap","tilePropertyName","debugColorizeTilesOff","colorize","makeStyleDirty","updateContent","expiredContent","updateClippingPlanes","currentClippingPlanesState","clippingPlanesState","updateClippingPolygons","currentClippingPolygonsState","clippingPolygonsState","commandList","commandStart","commandEnd","i","command","translucent","pass","TRANSLUCENT","depthForTranslucentClassification","scratchCommandList","process","ready","_statistics","incrementLoadCounts","numberOfTilesWithContentReady","numberOfLoadedTilesTotal","_cache","savedCommandList","isolateDigits","normalizedValue","numberOfDigits","leftShift","scaled","pow","integer","parseInt","priorityNormalizeAndClamp","minimum","maximum","updatePriority","preferLeaves","minimumPriority","_minimumPriority","maximumPriority","_maximumPriority","digitsForANumber","digitsForABoolean","preferredSortingLeftShift","preferredSortingDigitsCount","foveatedLeftShift","foveatedDigitsCount","preloadProgressiveResolutionLeftShift","preloadProgressiveResolutionDigitsCount","preloadProgressiveResolutionScale","foveatedDeferLeftShift","foveatedDeferDigitsCount","foveatedDeferScale","preloadFlightLeftShift","preloadFlightScale","depthDigits","depth","useDistance","normalizedPreferredSorting","reverseScreenSpaceError","preferredSortingDigits","preloadProgressiveResolutionDigits","foveatedFactor","foveatedDigits","foveatedDeferDigits","preloadFlightDigits"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Cesium3DTile.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DContentGroup from \"./Cesium3DContentGroup.js\";\nimport Cesium3DTileContentFactory from \"./Cesium3DTileContentFactory.js\";\nimport Cesium3DTileContentState from \"./Cesium3DTileContentState.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport Empty3DTileContent from \"./Empty3DTileContent.js\";\nimport findContentMetadata from \"./findContentMetadata.js\";\nimport findGroupMetadata from \"./findGroupMetadata.js\";\nimport findTileMetadata from \"./findTileMetadata.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport Multiple3DTileContent from \"./Multiple3DTileContent.js\";\nimport BoundingVolumeSemantics from \"./BoundingVolumeSemantics.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileBoundingS2Cell from \"./TileBoundingS2Cell.js\";\nimport TileBoundingSphere from \"./TileBoundingSphere.js\";\nimport TileOrientedBoundingBox from \"./TileOrientedBoundingBox.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\n\n/**\n * A tile in a {@link Cesium3DTileset}.  When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * <p>\n * Do not construct this directly, instead access tiles through {@link Cesium3DTileset#tileVisible}.\n * </p>\n *\n * @alias Cesium3DTile\n * @constructor\n * @param {Cesium3DTileset} tileset The tileset\n * @param {Resource} baseResource The base resource for the tileset\n * @param {object} header The JSON header for the tile\n * @param {Cesium3DTile} parent The parent tile of the new tile\n */\nfunction Cesium3DTile(tileset, baseResource, header, parent) {\n  this._tileset = tileset;\n  this._header = header;\n\n  const hasContentsArray = defined(header.contents);\n  const hasMultipleContents =\n    (hasContentsArray && header.contents.length > 1) ||\n    hasExtension(header, \"3DTILES_multiple_contents\");\n\n  // In the 1.0 schema, content is stored in tile.content instead of tile.contents\n  const contentHeader =\n    hasContentsArray && !hasMultipleContents\n      ? header.contents[0]\n      : header.content;\n\n  this._contentHeader = contentHeader;\n\n  /**\n   * The local transform of this tile.\n   * @type {Matrix4}\n   */\n  this.transform = defined(header.transform)\n    ? Matrix4.unpack(header.transform)\n    : Matrix4.clone(Matrix4.IDENTITY);\n\n  const parentTransform = defined(parent)\n    ? parent.computedTransform\n    : tileset.modelMatrix;\n  const computedTransform = Matrix4.multiply(\n    parentTransform,\n    this.transform,\n    new Matrix4(),\n  );\n\n  const parentInitialTransform = defined(parent)\n    ? parent._initialTransform\n    : Matrix4.IDENTITY;\n  this._initialTransform = Matrix4.multiply(\n    parentInitialTransform,\n    this.transform,\n    new Matrix4(),\n  );\n\n  /**\n   * The final computed transform of this tile.\n   * @type {Matrix4}\n   * @readonly\n   */\n  this.computedTransform = computedTransform;\n\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this stores a {@link TileMetadata} object for accessing tile metadata.\n   *\n   * @type {TileMetadata}\n   * @readonly\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.metadata = findTileMetadata(tileset, header);\n\n  this._verticalExaggeration = 1.0;\n  this._verticalExaggerationRelativeHeight = 0.0;\n\n  // Important: tile metadata must be parsed before this line so that the\n  // metadata semantics TILE_BOUNDING_BOX, TILE_BOUNDING_REGION, or TILE_BOUNDING_SPHERE\n  // can override header.boundingVolume (if necessary)\n  this._boundingVolume = this.createBoundingVolume(\n    header.boundingVolume,\n    computedTransform,\n  );\n  this._boundingVolume2D = undefined;\n\n  let contentBoundingVolume;\n\n  if (defined(contentHeader) && defined(contentHeader.boundingVolume)) {\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile.  This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    contentBoundingVolume = this.createBoundingVolume(\n      contentHeader.boundingVolume,\n      computedTransform,\n    );\n  }\n  this._contentBoundingVolume = contentBoundingVolume;\n  this._contentBoundingVolume2D = undefined;\n\n  let viewerRequestVolume;\n  if (defined(header.viewerRequestVolume)) {\n    viewerRequestVolume = this.createBoundingVolume(\n      header.viewerRequestVolume,\n      computedTransform,\n    );\n  }\n  this._viewerRequestVolume = viewerRequestVolume;\n\n  /**\n   * The error, in meters, introduced if this tile is rendered and its children are not.\n   * This is used to compute screen space error, i.e., the error measured in pixels.\n   *\n   * @type {number}\n   * @readonly\n   */\n  this.geometricError = header.geometricError;\n  this._geometricError = header.geometricError;\n\n  if (!defined(this._geometricError)) {\n    this._geometricError = defined(parent)\n      ? parent._geometricError\n      : tileset._geometricError;\n    Cesium3DTile._deprecationWarning(\n      \"geometricErrorUndefined\",\n      \"Required property geometricError is undefined for this tile. Using parent's geometric error instead.\",\n    );\n  }\n\n  this.updateGeometricErrorScale();\n\n  let refine;\n  if (defined(header.refine)) {\n    if (header.refine === \"replace\" || header.refine === \"add\") {\n      Cesium3DTile._deprecationWarning(\n        \"lowercase-refine\",\n        `This tile uses a lowercase refine \"${\n          header.refine\n        }\". Instead use \"${header.refine.toUpperCase()}\".`,\n      );\n    }\n    refine =\n      header.refine.toUpperCase() === \"REPLACE\"\n        ? Cesium3DTileRefine.REPLACE\n        : Cesium3DTileRefine.ADD;\n  } else if (defined(parent)) {\n    // Inherit from parent tile if omitted.\n    refine = parent.refine;\n  } else {\n    refine = Cesium3DTileRefine.REPLACE;\n  }\n\n  /**\n   * Specifies the type of refinement that is used when traversing this tile for rendering.\n   *\n   * @type {Cesium3DTileRefine}\n   * @readonly\n   * @private\n   */\n  this.refine = refine;\n\n  /**\n   * Gets the tile's children.\n   *\n   * @type {Cesium3DTile[]}\n   * @readonly\n   */\n  this.children = [];\n\n  /**\n   * This tile's parent or <code>undefined</code> if this tile is the root.\n   * <p>\n   * When a tile's content points to an external tileset JSON file, the external tileset's\n   * root tile's parent is not <code>undefined</code>; instead, the parent references\n   * the tile (with its content pointing to an external tileset JSON file) as if the two tilesets were merged.\n   * </p>\n   *\n   * @type {Cesium3DTile}\n   * @readonly\n   */\n  this.parent = parent;\n\n  let content;\n  let hasEmptyContent = false;\n  let contentState;\n  let contentResource;\n  let serverKey;\n\n  baseResource = Resource.createIfNeeded(baseResource);\n\n  if (hasMultipleContents) {\n    contentState = Cesium3DTileContentState.UNLOADED;\n    // Each content may have its own URI, but they all need to be resolved\n    // relative to the tileset, so the base resource is used.\n    contentResource = baseResource.clone();\n  } else if (defined(contentHeader)) {\n    let contentHeaderUri = contentHeader.uri;\n    if (defined(contentHeader.url)) {\n      Cesium3DTile._deprecationWarning(\n        \"contentUrl\",\n        'This tileset JSON uses the \"content.url\" property which has been deprecated. Use \"content.uri\" instead.',\n      );\n      contentHeaderUri = contentHeader.url;\n    }\n    if (contentHeaderUri === \"\") {\n      Cesium3DTile._deprecationWarning(\n        \"contentUriEmpty\",\n        \"content.uri property is an empty string, which creates a circular dependency, making this tileset invalid. Omit the content property instead\",\n      );\n      content = new Empty3DTileContent(tileset, this);\n      hasEmptyContent = true;\n      contentState = Cesium3DTileContentState.READY;\n    } else {\n      contentState = Cesium3DTileContentState.UNLOADED;\n      contentResource = baseResource.getDerivedResource({\n        url: contentHeaderUri,\n      });\n      serverKey = RequestScheduler.getServerKey(\n        contentResource.getUrlComponent(),\n      );\n    }\n  } else {\n    content = new Empty3DTileContent(tileset, this);\n    hasEmptyContent = true;\n    contentState = Cesium3DTileContentState.READY;\n  }\n\n  this._content = content;\n  this._contentResource = contentResource;\n  this._contentState = contentState;\n  this._expiredContent = undefined;\n\n  this._serverKey = serverKey;\n\n  /**\n   * When <code>true</code>, the tile has no content.\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasEmptyContent = hasEmptyContent;\n\n  /**\n   * When <code>true</code>, the tile's content points to an external tileset.\n   * <p>\n   * This is <code>false</code> until the tile's content is loaded.\n   * </p>\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasTilesetContent = false;\n\n  /**\n   * When <code>true</code>, the tile's content is an implicit tileset.\n   * <p>\n   * This is <code>false</code> until the tile's implicit content is loaded.\n   * </p>\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.hasImplicitContent = false;\n\n  /**\n   * When <code>true</code>, the tile contains content metadata from implicit tiling. This flag is set\n   * for tiles transcoded by <code>Implicit3DTileContent</code>.\n   * <p>\n   * This is <code>false</code> until the tile's content is loaded.\n   * </p>\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.hasImplicitContentMetadata = false;\n\n  /**\n   * When <code>true</code>, the tile has multiple contents, either in the tile JSON (3D Tiles 1.1)\n   * or via the <code>3DTILES_multiple_contents</code> extension.\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_multiple_contents|3DTILES_multiple_contents extension}\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  this.hasMultipleContents = hasMultipleContents;\n\n  /**\n   * The node in the tileset's LRU cache, used to determine when to unload a tile's content.\n   *\n   * See {@link Cesium3DTilesetCache}\n   *\n   * @type {DoublyLinkedListNode}\n   * @readonly\n   *\n   * @private\n   */\n  this.cacheNode = undefined;\n\n  const expire = header.expire;\n  let expireDuration;\n  let expireDate;\n  if (defined(expire)) {\n    expireDuration = expire.duration;\n    if (defined(expire.date)) {\n      expireDate = JulianDate.fromIso8601(expire.date);\n    }\n  }\n\n  /**\n   * The time in seconds after the tile's content is ready when the content expires and new content is requested.\n   *\n   * @type {number}\n   */\n  this.expireDuration = expireDuration;\n\n  /**\n   * The date when the content expires and new content is requested.\n   *\n   * @type {JulianDate}\n   */\n  this.expireDate = expireDate;\n\n  /**\n   * The time when a style was last applied to this tile.\n   *\n   * @type {number}\n   *\n   * @private\n   */\n  this.lastStyleTime = 0.0;\n\n  /**\n   * Marks whether the tile's children bounds are fully contained within the tile's bounds\n   *\n   * @type {Cesium3DTileOptimizationHint}\n   *\n   * @private\n   */\n  this._optimChildrenWithinParent = Cesium3DTileOptimizationHint.NOT_COMPUTED;\n\n  /**\n   * Tracks if the tile's relationship with a ClippingPlaneCollection has changed with regards\n   * to the ClippingPlaneCollection's state.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.clippingPlanesDirty = false;\n\n  /**\n   * Tracks if the tile's relationship with a ClippingPolygonCollection has changed with regards\n   * to the ClippingPolygonCollection's state.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.clippingPolygonsDirty = false;\n\n  /**\n   * Tracks if the tile's request should be deferred until all non-deferred\n   * tiles load.\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  this.priorityDeferred = false;\n\n  /**\n   * For implicit tiling, an ImplicitTileset object will be attached to a\n   * placeholder tile with either implicit tiling in the JSON (3D Tiles 1.1)\n   * or the <code>3DTILES_implicit_tiling</code> extension.\n   * This way the {@link Implicit3DTileContent} can access the tile later once the content is fetched.\n   *\n   * @type {ImplicitTileset|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.implicitTileset = undefined;\n\n  /**\n   * For implicit tiling, the (level, x, y, [z]) coordinates within the\n   * implicit tileset are stored in the tile.\n   *\n   * @type {ImplicitTileCoordinates|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.implicitCoordinates = undefined;\n\n  /**\n   * For implicit tiling, each transcoded tile will hold a weak reference to\n   * the {@link ImplicitSubtree}.\n   *\n   * @type {ImplicitSubtree|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  this.implicitSubtree = undefined;\n\n  // Members that are updated every frame for tree traversal and rendering optimizations:\n  this._distanceToCamera = 0.0;\n  this._centerZDepth = 0.0;\n  this._screenSpaceError = 0.0;\n  this._screenSpaceErrorProgressiveResolution = 0.0; // The screen space error at a given screen height of tileset.progressiveResolutionHeightFraction * screenHeight\n  this._visibilityPlaneMask = 0;\n  this._visible = false;\n  this._inRequestVolume = false;\n\n  this._finalResolution = true;\n  this._depth = 0;\n  this._stackLength = 0;\n  this._selectionDepth = 0;\n\n  this._updatedVisibilityFrame = 0;\n  this._touchedFrame = 0;\n  this._visitedFrame = 0;\n  this._selectedFrame = 0;\n  this._wasSelectedLastFrame = false;\n  this._requestedFrame = 0;\n  this._ancestorWithContent = undefined;\n  this._ancestorWithContentAvailable = undefined;\n  this._refines = false;\n  this._shouldSelect = false;\n  this._isClipped = true;\n  this._isClippedByPolygon = false;\n  this._clippingPlanesState = 0; // encapsulates (_isClipped, clippingPlanes.enabled) and number/function\n  this._clippingPolygonsState = 0; // encapsulates (_isClipped, clippingPolygons.enabled) and number/function\n  this._debugBoundingVolume = undefined;\n  this._debugContentBoundingVolume = undefined;\n  this._debugViewerRequestVolume = undefined;\n  this._debugColor = Color.fromRandom({ alpha: 1.0 });\n  this._debugColorizeTiles = false;\n\n  this._priority = 0.0; // The priority used for request sorting\n  this._priorityHolder = this; // Reference to the ancestor up the tree that holds the _foveatedFactor and _distanceToCamera for all tiles in the refinement chain.\n  this._priorityProgressiveResolution = false;\n  this._priorityProgressiveResolutionScreenSpaceErrorLeaf = false;\n  this._priorityReverseScreenSpaceError = 0.0;\n  this._foveatedFactor = 0.0;\n  this._wasMinPriorityChild = false; // Needed for knowing when to continue a refinement chain. Gets reset in updateTile in traversal and gets set in updateAndPushChildren in traversal.\n\n  this._loadTimestamp = new JulianDate();\n\n  this._commandsLength = 0;\n\n  this._color = undefined;\n  this._colorDirty = false;\n\n  this._request = undefined;\n}\n\n// This can be overridden for testing purposes\nCesium3DTile._deprecationWarning = deprecationWarning;\n\nObject.defineProperties(Cesium3DTile.prototype, {\n  /**\n   * The tileset containing this tile.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {Cesium3DTileset}\n   * @readonly\n   */\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  /**\n   * The tile's content.  This represents the actual tile's payload,\n   * not the content's metadata in the tileset JSON file.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {Cesium3DTileContent}\n   * @readonly\n   */\n  content: {\n    get: function () {\n      return this._content;\n    },\n  },\n\n  /**\n   * Get the tile's bounding volume.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {TileBoundingVolume}\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingVolume;\n    },\n  },\n\n  /**\n   * Get the bounding volume of the tile's contents.  This defaults to the\n   * tile's bounding volume when the content's bounding volume is\n   * <code>undefined</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {TileBoundingVolume}\n   * @readonly\n   * @private\n   */\n  contentBoundingVolume: {\n    get: function () {\n      return defaultValue(this._contentBoundingVolume, this._boundingVolume);\n    },\n  },\n\n  /**\n   * Get the bounding sphere derived from the tile's bounding volume.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingVolume.boundingSphere;\n    },\n  },\n\n  /**\n   * Determines if the tile is visible within the current field of view\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  isVisible: {\n    get: function () {\n      return this._visible && this._inRequestVolume;\n    },\n  },\n\n  /**\n   * Returns the <code>extras</code> property in the tileset JSON for this tile, which contains application specific metadata.\n   * Returns <code>undefined</code> if <code>extras</code> does not exist.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {object}\n   * @readonly\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}\n   */\n  extras: {\n    get: function () {\n      return this._header.extras;\n    },\n  },\n\n  /**\n   * Gets or sets the tile's highlight color.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {Color}\n   *\n   * @default {@link Color.WHITE}\n   *\n   * @private\n   */\n  color: {\n    get: function () {\n      if (!defined(this._color)) {\n        this._color = new Color();\n      }\n      return Color.clone(this._color);\n    },\n    set: function (value) {\n      this._color = Color.clone(value, this._color);\n      this._colorDirty = true;\n    },\n  },\n\n  /**\n   * Determines if the tile's content is renderable. <code>false</code> if the\n   * tile has empty content or if it points to an external tileset or implicit content\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  hasRenderableContent: {\n    get: function () {\n      return (\n        !this.hasEmptyContent &&\n        !this.hasTilesetContent &&\n        !this.hasImplicitContent\n      );\n    },\n  },\n\n  /**\n   * Determines if the tile has available content to render.  <code>true</code> if the tile's\n   * content is ready or if it has expired content that renders while new content loads; otherwise,\n   * <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentAvailable: {\n    get: function () {\n      return (\n        (this.contentReady && this.hasRenderableContent) ||\n        (defined(this._expiredContent) && !this.contentFailed)\n      );\n    },\n  },\n\n  /**\n   * Determines if the tile's content is ready. This is automatically <code>true</code> for\n   * tile's with empty content.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentReady: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.READY;\n    },\n  },\n\n  /**\n   * Determines if the tile's content has not be requested. <code>true</code> if tile's\n   * content has not be requested; otherwise, <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentUnloaded: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.UNLOADED;\n    },\n  },\n\n  /**\n   * Determines if the tile has renderable content which is unloaded\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  hasUnloadedRenderableContent: {\n    get: function () {\n      return this.hasRenderableContent && this.contentUnloaded;\n    },\n  },\n\n  /**\n   * Determines if the tile's content is expired. <code>true</code> if tile's\n   * content is expired; otherwise, <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentExpired: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.EXPIRED;\n    },\n  },\n\n  /**\n   * Determines if the tile's content failed to load.  <code>true</code> if the tile's\n   * content failed to load; otherwise, <code>false</code>.\n   *\n   * @memberof Cesium3DTile.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @private\n   */\n  contentFailed: {\n    get: function () {\n      return this._contentState === Cesium3DTileContentState.FAILED;\n    },\n  },\n\n  /**\n   * Returns the number of draw commands used by this tile.\n   *\n   * @readonly\n   *\n   * @private\n   */\n  commandsLength: {\n    get: function () {\n      return this._commandsLength;\n    },\n  },\n});\n\nconst scratchCartesian = new Cartesian3();\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n * @returns {Boolean}\n */\nfunction isPriorityDeferred(tile, frameState) {\n  const { tileset, boundingSphere } = tile;\n  const { radius, center } = boundingSphere;\n  const { camera } = frameState;\n\n  // If closest point on line is inside the sphere then set foveatedFactor to 0.\n  // Otherwise, the dot product is with the line from camera to the point on the sphere that is closest to the line.\n  const scaledCameraDirection = Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    tile._centerZDepth,\n    scratchCartesian,\n  );\n  const closestPointOnLine = Cartesian3.add(\n    camera.positionWC,\n    scaledCameraDirection,\n    scratchCartesian,\n  );\n  // The distance from the camera's view direction to the tile.\n  const toLine = Cartesian3.subtract(\n    closestPointOnLine,\n    center,\n    scratchCartesian,\n  );\n  const distanceToCenterLine = Cartesian3.magnitude(toLine);\n  const notTouchingSphere = distanceToCenterLine > radius;\n\n  // If camera's direction vector is inside the bounding sphere then consider\n  // this tile right along the line of sight and set _foveatedFactor to 0.\n  // Otherwise,_foveatedFactor is one minus the dot product of the camera's direction\n  // and the vector between the camera and the point on the bounding sphere closest to the view line.\n  if (notTouchingSphere) {\n    const toLineNormalized = Cartesian3.normalize(toLine, scratchCartesian);\n    const scaledToLine = Cartesian3.multiplyByScalar(\n      toLineNormalized,\n      radius,\n      scratchCartesian,\n    );\n    const closestOnSphere = Cartesian3.add(\n      center,\n      scaledToLine,\n      scratchCartesian,\n    );\n    const toClosestOnSphere = Cartesian3.subtract(\n      closestOnSphere,\n      camera.positionWC,\n      scratchCartesian,\n    );\n    const toClosestOnSphereNormalize = Cartesian3.normalize(\n      toClosestOnSphere,\n      scratchCartesian,\n    );\n    tile._foveatedFactor =\n      1.0 -\n      Math.abs(Cartesian3.dot(camera.directionWC, toClosestOnSphereNormalize));\n  } else {\n    tile._foveatedFactor = 0.0;\n  }\n\n  // Skip this feature if: non-skipLevelOfDetail and replace refine, if the foveated settings are turned off, if tile is progressive resolution and replace refine and skipLevelOfDetail (will help get rid of ancestor artifacts faster)\n  // Or if the tile is a preload of any kind\n  const replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  const skipLevelOfDetail = tileset.isSkippingLevelOfDetail;\n  if (\n    (replace && !skipLevelOfDetail) ||\n    !tileset.foveatedScreenSpaceError ||\n    tileset.foveatedConeSize === 1.0 ||\n    (tile._priorityProgressiveResolution && replace && skipLevelOfDetail) ||\n    tileset._pass === Cesium3DTilePass.PRELOAD_FLIGHT ||\n    tileset._pass === Cesium3DTilePass.PRELOAD\n  ) {\n    return false;\n  }\n\n  const maximumFovatedFactor = 1.0 - Math.cos(camera.frustum.fov * 0.5); // 0.14 for fov = 60. NOTE very hard to defer vertically foveated tiles since max is based on fovy (which is fov). Lowering the 0.5 to a smaller fraction of the screen height will start to defer vertically foveated tiles.\n  const foveatedConeFactor = tileset.foveatedConeSize * maximumFovatedFactor;\n\n  // If it's inside the user-defined view cone, then it should not be deferred.\n  if (tile._foveatedFactor <= foveatedConeFactor) {\n    return false;\n  }\n\n  // Relax SSE based on how big the angle is between the tile and the edge of the foveated cone.\n  const range = maximumFovatedFactor - foveatedConeFactor;\n  const normalizedFoveatedFactor = CesiumMath.clamp(\n    (tile._foveatedFactor - foveatedConeFactor) / range,\n    0.0,\n    1.0,\n  );\n  const sseRelaxation = tileset.foveatedInterpolationCallback(\n    tileset.foveatedMinimumScreenSpaceErrorRelaxation,\n    tileset.memoryAdjustedScreenSpaceError,\n    normalizedFoveatedFactor,\n  );\n  const sse =\n    tile._screenSpaceError === 0.0 && defined(tile.parent)\n      ? tile.parent._screenSpaceError * 0.5\n      : tile._screenSpaceError;\n\n  return tileset.memoryAdjustedScreenSpaceError - sseRelaxation <= sse;\n}\n\nconst scratchJulianDate = new JulianDate();\n\n/**\n * Get the tile's screen space error.\n *\n * @private\n * @param {FrameState} frameState\n * @param {Boolean} useParentGeometricError\n * @param {number} progressiveResolutionHeightFraction\n */\nCesium3DTile.prototype.getScreenSpaceError = function (\n  frameState,\n  useParentGeometricError,\n  progressiveResolutionHeightFraction,\n) {\n  const tileset = this._tileset;\n  const heightFraction = defaultValue(progressiveResolutionHeightFraction, 1.0);\n  const parentGeometricError = defined(this.parent)\n    ? this.parent.geometricError\n    : tileset._scaledGeometricError;\n  const geometricError = useParentGeometricError\n    ? parentGeometricError\n    : this.geometricError;\n  if (geometricError === 0.0) {\n    // Leaf tiles do not have any error so save the computation\n    return 0.0;\n  }\n  const { camera, context } = frameState;\n  let frustum = camera.frustum;\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight * heightFraction;\n  let error;\n  if (\n    frameState.mode === SceneMode.SCENE2D ||\n    frustum instanceof OrthographicFrustum\n  ) {\n    const offCenterFrustum = frustum.offCenterFrustum;\n    if (defined(offCenterFrustum)) {\n      frustum = offCenterFrustum;\n    }\n    const pixelSize =\n      Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) /\n      Math.max(width, height);\n    error = geometricError / pixelSize;\n  } else {\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(this._distanceToCamera, CesiumMath.EPSILON7);\n    const sseDenominator = frustum.sseDenominator;\n    error = (geometricError * height) / (distance * sseDenominator);\n    if (tileset.dynamicScreenSpaceError) {\n      const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n      const factor = tileset.dynamicScreenSpaceErrorFactor;\n      const dynamicError = CesiumMath.fog(distance, density) * factor;\n      error -= dynamicError;\n    }\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n};\n\n/**\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {Cesium3DTile} tile\n * @returns {Boolean}\n */\nfunction isPriorityProgressiveResolution(tileset, tile) {\n  if (\n    tileset.progressiveResolutionHeightFraction <= 0.0 ||\n    tileset.progressiveResolutionHeightFraction > 0.5\n  ) {\n    return false;\n  }\n\n  const maximumScreenSpaceError = tileset.memoryAdjustedScreenSpaceError;\n  let isProgressiveResolutionTile =\n    tile._screenSpaceErrorProgressiveResolution > maximumScreenSpaceError; // Mark non-SSE leaves\n  tile._priorityProgressiveResolutionScreenSpaceErrorLeaf = false; // Needed for skipLOD\n  const parent = tile.parent;\n  const tilePasses =\n    tile._screenSpaceErrorProgressiveResolution <= maximumScreenSpaceError;\n  const parentFails =\n    defined(parent) &&\n    parent._screenSpaceErrorProgressiveResolution > maximumScreenSpaceError;\n  if (tilePasses && parentFails) {\n    // A progressive resolution SSE leaf, promote its priority as well\n    tile._priorityProgressiveResolutionScreenSpaceErrorLeaf = true;\n    isProgressiveResolutionTile = true;\n  }\n  return isProgressiveResolutionTile;\n}\n\n/**\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {Cesium3DTile} tile\n * @returns {number}\n */\nfunction getPriorityReverseScreenSpaceError(tileset, tile) {\n  const parent = tile.parent;\n  const useParentScreenSpaceError =\n    defined(parent) &&\n    (!tileset.isSkippingLevelOfDetail ||\n      tile._screenSpaceError === 0.0 ||\n      parent.hasTilesetContent ||\n      parent.hasImplicitContent);\n  const screenSpaceError = useParentScreenSpaceError\n    ? parent._screenSpaceError\n    : tile._screenSpaceError;\n  return tileset.root._screenSpaceError - screenSpaceError;\n}\n\n/**\n * Update the tile's visibility.\n *\n * @private\n * @param {FrameState} frameState\n */\nCesium3DTile.prototype.updateVisibility = function (frameState) {\n  const { parent, tileset } = this;\n  if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n    // The tile has already been updated for this frame\n    return;\n  }\n\n  const parentTransform = defined(parent)\n    ? parent.computedTransform\n    : tileset.modelMatrix;\n  const parentVisibilityPlaneMask = defined(parent)\n    ? parent._visibilityPlaneMask\n    : CullingVolume.MASK_INDETERMINATE;\n  this.updateTransform(parentTransform, frameState);\n  this._distanceToCamera = this.distanceToTile(frameState);\n  this._centerZDepth = this.distanceToTileCenter(frameState);\n  this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n  this._screenSpaceErrorProgressiveResolution = this.getScreenSpaceError(\n    frameState,\n    false,\n    tileset.progressiveResolutionHeightFraction,\n  );\n  this._visibilityPlaneMask = this.visibility(\n    frameState,\n    parentVisibilityPlaneMask,\n  ); // Use parent's plane mask to speed up visibility test\n  this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n  this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n  this._priorityReverseScreenSpaceError = getPriorityReverseScreenSpaceError(\n    tileset,\n    this,\n  );\n  this._priorityProgressiveResolution = isPriorityProgressiveResolution(\n    tileset,\n    this,\n  );\n  this.priorityDeferred = isPriorityDeferred(this, frameState);\n\n  this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n};\n\n/**\n * Update whether the tile has expired.\n *\n * @private\n */\nCesium3DTile.prototype.updateExpiration = function () {\n  if (\n    defined(this.expireDate) &&\n    this.contentReady &&\n    !this.hasEmptyContent &&\n    !this.hasMultipleContents\n  ) {\n    const now = JulianDate.now(scratchJulianDate);\n    if (JulianDate.lessThan(this.expireDate, now)) {\n      this._contentState = Cesium3DTileContentState.EXPIRED;\n      this._expiredContent = this._content;\n    }\n  }\n};\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n */\nfunction updateExpireDate(tile) {\n  if (!defined(tile.expireDuration)) {\n    return;\n  }\n  const expireDurationDate = JulianDate.now(scratchJulianDate);\n  JulianDate.addSeconds(\n    expireDurationDate,\n    tile.expireDuration,\n    expireDurationDate,\n  );\n\n  if (defined(tile.expireDate)) {\n    if (JulianDate.lessThan(tile.expireDate, expireDurationDate)) {\n      JulianDate.clone(expireDurationDate, tile.expireDate);\n    }\n  } else {\n    tile.expireDate = JulianDate.clone(expireDurationDate);\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @returns {Function}\n */\nfunction createPriorityFunction(tile) {\n  return function () {\n    return tile._priority;\n  };\n}\n\n/**\n * Requests the tile's content.\n * <p>\n * The request may not be made if the Cesium Request Scheduler can't prioritize it.\n * </p>\n *\n * @return {Promise<Cesium3DTileContent>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nCesium3DTile.prototype.requestContent = function () {\n  // empty contents don't require any HTTP requests\n  if (this.hasEmptyContent) {\n    return;\n  }\n\n  if (this.hasMultipleContents) {\n    return requestMultipleContents(this);\n  }\n\n  return requestSingleContent(this);\n};\n\n/**\n * Multiple {@link Cesium3DTileContent}s are allowed within a single tile either through\n * the tile JSON (3D Tiles 1.1) or the <code>3DTILES_multiple_contents</code> extension.\n * Due to differences in request scheduling, this is handled separately.\n * <p>\n * This implementation of multiple contents does not\n * support tile expiry like requestSingleContent does. If this changes,\n * note that the resource.setQueryParameters() details must go inside {@link Multiple3DTileContent} since that is per-request.\n * </p>\n *\n * @private\n * @param {Cesium3DTile} tile\n * @returns {Promise<Cesium3DTileContent>|Promise<undefined>|undefined} A promise that resolves to the tile content once loaded, or a promise that resolves to undefined if the request was cancelled mid-flight, or undefined if the request cannot be scheduled this frame\n */\nfunction requestMultipleContents(tile) {\n  let multipleContents = tile._content;\n  const tileset = tile._tileset;\n\n  if (!defined(multipleContents)) {\n    // Create the content object immediately, it will handle scheduling\n    // requests for inner contents.\n    const contentsJson = hasExtension(tile._header, \"3DTILES_multiple_contents\")\n      ? tile._header.extensions[\"3DTILES_multiple_contents\"]\n      : tile._header;\n\n    multipleContents = new Multiple3DTileContent(\n      tileset,\n      tile,\n      tile._contentResource.clone(),\n      contentsJson,\n    );\n    tile._content = multipleContents;\n  }\n\n  const promise = multipleContents.requestInnerContents();\n\n  if (!defined(promise)) {\n    // Request could not all be scheduled this frame\n    return;\n  }\n\n  tile._contentState = Cesium3DTileContentState.LOADING;\n  return promise\n    .then((content) => {\n      if (tile.isDestroyed()) {\n        // Tile is unloaded before the content can process\n        return;\n      }\n\n      // Tile was canceled, try again later\n      if (!defined(content)) {\n        return;\n      }\n\n      tile._contentState = Cesium3DTileContentState.PROCESSING;\n      return multipleContents;\n    })\n    .catch((error) => {\n      if (tile.isDestroyed()) {\n        // Tile is unloaded before the content can process\n        return;\n      }\n\n      tile._contentState = Cesium3DTileContentState.FAILED;\n      throw error;\n    });\n}\n\nasync function processArrayBuffer(\n  tile,\n  tileset,\n  request,\n  expired,\n  requestPromise,\n) {\n  const previousState = tile._contentState;\n  tile._contentState = Cesium3DTileContentState.LOADING;\n  ++tileset.statistics.numberOfPendingRequests;\n\n  let arrayBuffer;\n  try {\n    arrayBuffer = await requestPromise;\n  } catch (error) {\n    --tileset.statistics.numberOfPendingRequests;\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n\n    if (request.cancelled || request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      tile._contentState = previousState;\n      ++tileset.statistics.numberOfAttemptedRequests;\n      return;\n    }\n\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n\n  if (tile.isDestroyed()) {\n    --tileset.statistics.numberOfPendingRequests;\n    // Tile is unloaded before the content can process\n    return;\n  }\n\n  if (request.cancelled || request.state === RequestState.CANCELLED) {\n    // Cancelled due to low priority - try again later.\n    tile._contentState = previousState;\n    --tileset.statistics.numberOfPendingRequests;\n    ++tileset.statistics.numberOfAttemptedRequests;\n    return;\n  }\n\n  try {\n    const content = await makeContent(tile, arrayBuffer);\n    --tileset.statistics.numberOfPendingRequests;\n\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n\n    if (expired) {\n      tile.expireDate = undefined;\n    }\n\n    tile._content = content;\n    tile._contentState = Cesium3DTileContentState.PROCESSING;\n\n    return content;\n  } catch (error) {\n    --tileset.statistics.numberOfPendingRequests;\n    if (tile.isDestroyed()) {\n      // Tile is unloaded before the content can process\n      return;\n    }\n\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @returns {Promise<Cesium3DTileContent>|Promise<undefined>|undefined} A promise that resolves to the tile content once loaded; a promise that resolves to undefined if the tile was destroyed before processing can happen or the request was cancelled mid-flight; or undefined if the request cannot be scheduled this frame.\n */\nfunction requestSingleContent(tile) {\n  // it is important to clone here. The fetchArrayBuffer() below uses\n  // throttling, but other uses of the resources do not.\n  const resource = tile._contentResource.clone();\n  const expired = tile.contentExpired;\n  if (expired) {\n    // Append a query parameter of the tile expiration date to prevent caching\n    resource.setQueryParameters({\n      expired: tile.expireDate.toString(),\n    });\n  }\n\n  const request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TILES3D,\n    priorityFunction: createPriorityFunction(tile),\n    serverKey: tile._serverKey,\n  });\n\n  tile._request = request;\n  resource.request = request;\n  const tileset = tile._tileset;\n  const promise = resource.fetchArrayBuffer();\n  if (!defined(promise)) {\n    ++tileset.statistics.numberOfAttemptedRequests;\n    return;\n  }\n\n  return processArrayBuffer(tile, tileset, request, expired, promise);\n}\n\n/**\n * Given a downloaded content payload, construct a {@link Cesium3DTileContent}.\n * <p>\n * This is only used for single contents.\n * </p>\n *\n * @param {Cesium3DTile} tile The tile\n * @param {ArrayBuffer} arrayBuffer The downloaded payload containing data for the content\n * @return {Promise<Cesium3DTileContent>} A content object\n * @private\n */\nasync function makeContent(tile, arrayBuffer) {\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n\n  // Vector and Geometry tile rendering do not support the skip LOD optimization.\n  const tileset = tile._tileset;\n  tileset._disableSkipLevelOfDetail =\n    tileset._disableSkipLevelOfDetail ||\n    preprocessed.contentType === Cesium3DTileContentType.GEOMETRY ||\n    preprocessed.contentType === Cesium3DTileContentType.VECTOR;\n\n  if (\n    preprocessed.contentType === Cesium3DTileContentType.IMPLICIT_SUBTREE ||\n    preprocessed.contentType === Cesium3DTileContentType.IMPLICIT_SUBTREE_JSON\n  ) {\n    tile.hasImplicitContent = true;\n  }\n\n  if (preprocessed.contentType === Cesium3DTileContentType.EXTERNAL_TILESET) {\n    tile.hasTilesetContent = true;\n  }\n\n  let content;\n  const contentFactory = Cesium3DTileContentFactory[preprocessed.contentType];\n  if (tile.isDestroyed()) {\n    return;\n  }\n\n  if (defined(preprocessed.binaryPayload)) {\n    content = await Promise.resolve(\n      contentFactory(\n        tileset,\n        tile,\n        tile._contentResource,\n        preprocessed.binaryPayload.buffer,\n        0,\n      ),\n    );\n  } else {\n    // JSON formats\n    content = await Promise.resolve(\n      contentFactory(\n        tileset,\n        tile,\n        tile._contentResource,\n        preprocessed.jsonPayload,\n      ),\n    );\n  }\n\n  const contentHeader = tile._contentHeader;\n\n  if (tile.hasImplicitContentMetadata) {\n    const subtree = tile.implicitSubtree;\n    const coordinates = tile.implicitCoordinates;\n    content.metadata = subtree.getContentMetadataView(coordinates, 0);\n  } else if (!tile.hasImplicitContent) {\n    content.metadata = findContentMetadata(tileset, contentHeader);\n  }\n\n  const groupMetadata = findGroupMetadata(tileset, contentHeader);\n  if (defined(groupMetadata)) {\n    content.group = new Cesium3DContentGroup({\n      metadata: groupMetadata,\n    });\n  }\n\n  return content;\n}\n\n/**\n * Cancel requests for the tile's contents. This is called when the tile\n * goes out of view.\n *\n * @private\n */\nCesium3DTile.prototype.cancelRequests = function () {\n  if (this.hasMultipleContents) {\n    this._content.cancelRequests();\n  } else {\n    this._request.cancel();\n  }\n};\n\n/**\n * Unloads the tile's content.\n *\n * @private\n */\nCesium3DTile.prototype.unloadContent = function () {\n  if (!this.hasRenderableContent) {\n    return;\n  }\n\n  this._content = this._content && this._content.destroy();\n  this._contentState = Cesium3DTileContentState.UNLOADED;\n\n  this.lastStyleTime = 0.0;\n  this.clippingPlanesDirty = this._clippingPlanesState === 0;\n  this._clippingPlanesState = 0;\n  this.clippingPolygonsDirty = this._clippingPolygonsState === 0;\n  this._clippingPolygonsState = 0;\n\n  this._debugColorizeTiles = false;\n\n  this._debugBoundingVolume =\n    this._debugBoundingVolume && this._debugBoundingVolume.destroy();\n  this._debugContentBoundingVolume =\n    this._debugContentBoundingVolume &&\n    this._debugContentBoundingVolume.destroy();\n  this._debugViewerRequestVolume =\n    this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy();\n};\n\nconst scratchProjectedBoundingSphere = new BoundingSphere();\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n * @returns {TileBoundingVolume}\n */\nfunction getBoundingVolume(tile, frameState) {\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !defined(tile._boundingVolume2D)\n  ) {\n    const boundingSphere = tile._boundingVolume.boundingSphere;\n    const sphere = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      scratchProjectedBoundingSphere,\n    );\n    tile._boundingVolume2D = new TileBoundingSphere(\n      sphere.center,\n      sphere.radius,\n    );\n  }\n\n  return frameState.mode !== SceneMode.SCENE3D\n    ? tile._boundingVolume2D\n    : tile._boundingVolume;\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n * @returns {TileBoundingVolume}\n */\nfunction getContentBoundingVolume(tile, frameState) {\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !defined(tile._contentBoundingVolume2D)\n  ) {\n    const boundingSphere = tile._contentBoundingVolume.boundingSphere;\n    const sphere = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      scratchProjectedBoundingSphere,\n    );\n    tile._contentBoundingVolume2D = new TileBoundingSphere(\n      sphere.center,\n      sphere.radius,\n    );\n  }\n  return frameState.mode !== SceneMode.SCENE3D\n    ? tile._contentBoundingVolume2D\n    : tile._contentBoundingVolume;\n}\n\n/**\n * Determines whether the tile's bounding volume intersects the culling volume.\n *\n * @param {FrameState} frameState The frame state.\n * @param {number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n * @returns {number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n *\n * @private\n */\nCesium3DTile.prototype.visibility = function (\n  frameState,\n  parentVisibilityPlaneMask,\n) {\n  const cullingVolume = frameState.cullingVolume;\n  const boundingVolume = getBoundingVolume(this, frameState);\n\n  const tileset = this._tileset;\n  const clippingPlanes = tileset.clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n      boundingVolume,\n      tileset.clippingPlanesOriginMatrix,\n    );\n    this._isClipped = intersection !== Intersect.INSIDE;\n    if (intersection === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    }\n  }\n\n  const clippingPolygons = tileset.clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const intersection =\n      clippingPolygons.computeIntersectionWithBoundingVolume(boundingVolume);\n\n    this._isClippedByPolygon = intersection !== Intersect.OUTSIDE;\n    // Polygon clipping intersections are determined by outer rectangles, therefore we cannot\n    // preemptively determine if a tile is completely clipped or not here.\n  }\n\n  return cullingVolume.computeVisibilityWithPlaneMask(\n    boundingVolume,\n    parentVisibilityPlaneMask,\n  );\n};\n\n/**\n * Assuming the tile's bounding volume intersects the culling volume, determines\n * whether the tile's content's bounding volume intersects the culling volume.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n *\n * @private\n */\nCesium3DTile.prototype.contentVisibility = function (frameState) {\n  // Assumes the tile's bounding volume intersects the culling volume already, so\n  // just return Intersect.INSIDE if there is no content bounding volume.\n  if (!defined(this._contentBoundingVolume)) {\n    return Intersect.INSIDE;\n  }\n\n  if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n    // The tile's bounding volume is completely inside the culling volume so\n    // the content bounding volume must also be inside.\n    return Intersect.INSIDE;\n  }\n\n  // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n  // tile's (not the content's) bounding volume intersects the culling volume?\n  const cullingVolume = frameState.cullingVolume;\n  const boundingVolume = getContentBoundingVolume(this, frameState);\n\n  const tileset = this._tileset;\n  const clippingPlanes = tileset.clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n      boundingVolume,\n      tileset.clippingPlanesOriginMatrix,\n    );\n    this._isClipped = intersection !== Intersect.INSIDE;\n    if (intersection === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    }\n  }\n\n  const clippingPolygons = tileset.clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const intersection =\n      clippingPolygons.computeIntersectionWithBoundingVolume(boundingVolume);\n    this._isClippedByPolygon = intersection !== Intersect.OUTSIDE;\n    if (intersection === Intersect.INSIDE) {\n      return Intersect.OUTSIDE;\n    }\n  }\n\n  return cullingVolume.computeVisibility(boundingVolume);\n};\n\n/**\n * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {number} The distance, in meters, or zero if the camera is inside the bounding volume.\n *\n * @private\n */\nCesium3DTile.prototype.distanceToTile = function (frameState) {\n  const boundingVolume = getBoundingVolume(this, frameState);\n  return boundingVolume.distanceToCamera(frameState);\n};\n\nconst scratchToTileCenter = new Cartesian3();\n\n/**\n * Computes the distance from the center of the tile's bounding volume to the camera's plane defined by its position and view direction.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {number} The distance, in meters.\n *\n * @private\n */\nCesium3DTile.prototype.distanceToTileCenter = function (frameState) {\n  const tileBoundingVolume = getBoundingVolume(this, frameState);\n  const boundingVolume = tileBoundingVolume.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n  const toCenter = Cartesian3.subtract(\n    boundingVolume.center,\n    frameState.camera.positionWC,\n    scratchToTileCenter,\n  );\n  return Cartesian3.dot(frameState.camera.directionWC, toCenter);\n};\n\n/**\n * Checks if the camera is inside the viewer request volume.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {boolean} Whether the camera is inside the volume.\n *\n * @private\n */\nCesium3DTile.prototype.insideViewerRequestVolume = function (frameState) {\n  const viewerRequestVolume = this._viewerRequestVolume;\n  return (\n    !defined(viewerRequestVolume) ||\n    viewerRequestVolume.distanceToCamera(frameState) === 0.0\n  );\n};\n\nconst scratchMatrix = new Matrix3();\nconst scratchScale = new Cartesian3();\nconst scratchHalfAxes = new Matrix3();\nconst scratchCenter = new Cartesian3();\nconst scratchRectangle = new Rectangle();\nconst scratchOrientedBoundingBox = new OrientedBoundingBox();\nconst scratchTransform = new Matrix4();\n\n/**\n * @private\n * @param {Array} box An array of 12 numbers that define an oriented bounding box\n * @param {Matrix4} transform\n * @param {TileBoundingVolume} [result]\n * @returns {TileOrientedBoundingBox}\n */\nfunction createBox(box, transform, result) {\n  let center = Cartesian3.fromElements(box[0], box[1], box[2], scratchCenter);\n  let halfAxes = Matrix3.fromArray(box, 3, scratchHalfAxes);\n\n  // Find the transformed center and halfAxes\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getMatrix3(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result)) {\n    result.update(center, halfAxes);\n    return result;\n  }\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\n/**\n * @private\n * @param {Array} region An array of six numbers that define a bounding geographic region in EPSG:4979 coordinates with the order [west, south, east, north, minimum height, maximum height]\n * @param {Matrix4} transform\n * @param {Matrix4} initialTransform\n * @param {TileOrientedBoundingBox} [result]\n * @returns {TileOrientedBoundingBox}\n */\nfunction createBoxFromTransformedRegion(\n  region,\n  transform,\n  initialTransform,\n  result,\n) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox,\n  );\n  let center = orientedBoundingBox.center;\n  let halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform,\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getMatrix3(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\n/**\n * @private\n * @param {Array} region An array of six numbers that define a bounding geographic region in EPSG:4979 coordinates with the order [west, south, east, north, minimum height, maximum height]\n * @param {Matrix4} transform\n * @param {Matrix4} initialTransform\n * @param {TileBoundingVolume} [result]\n * @returns {TileBoundingVolume}\n */\nfunction createRegion(region, transform, initialTransform, result) {\n  if (\n    !Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)\n  ) {\n    return createBoxFromTransformedRegion(\n      region,\n      transform,\n      initialTransform,\n      result,\n    );\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  if (defined(result)) {\n    result.rectangle = Rectangle.clone(rectangleRegion, result.rectangle);\n    result.minimumHeight = region[4];\n    result.maximumHeight = region[5];\n    // The TileBoundingRegion was already constructed with the default\n    // WGS84 ellipsoid, so keep it consistent when updating.\n    result.computeBoundingVolumes(Ellipsoid.WGS84);\n    return result;\n  }\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5],\n  });\n}\n\n/**\n * @private\n * @param {Array} sphere An array of four numbers that define a bounding sphere\n * @param {Matrix4} transform\n * @param {TileBoundingVolume} [result]\n * @returns {TileBoundingSphere}\n */\nfunction createSphere(sphere, transform, result) {\n  let center = Cartesian3.fromElements(\n    sphere[0],\n    sphere[1],\n    sphere[2],\n    scratchCenter,\n  );\n  let radius = sphere[3];\n\n  // Find the transformed center and radius\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const scale = Matrix4.getScale(transform, scratchScale);\n  const uniformScale = Cartesian3.maximumComponent(scale);\n  radius *= uniformScale;\n\n  if (defined(result)) {\n    result.update(center, radius);\n    return result;\n  }\n  return new TileBoundingSphere(center, radius);\n}\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n *\n * @param {object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param {TileBoundingVolume} [result] The object onto which to store the result.\n *\n * @returns {TileBoundingVolume} The modified result parameter or a new TileBoundingVolume instance if none was provided.\n *\n * @private\n */\nCesium3DTile.prototype.createBoundingVolume = function (\n  boundingVolumeHeader,\n  transform,\n  result,\n) {\n  // if explicit tile metadata includes TILE_BOUNDING_BOX, TILE_BOUNDING_REGION,\n  // or TILE_BOUNDING_SPHERE, override tile.boundingVolume.\n  const tileMetadata = this.metadata;\n  let metadataBoundingVolumeHeader;\n  if (defined(tileMetadata)) {\n    metadataBoundingVolumeHeader =\n      BoundingVolumeSemantics.parseBoundingVolumeSemantic(\"TILE\", tileMetadata);\n  }\n  if (defined(metadataBoundingVolumeHeader)) {\n    boundingVolumeHeader = metadataBoundingVolumeHeader;\n  }\n\n  if (!defined(boundingVolumeHeader)) {\n    throw new RuntimeError(\"boundingVolume must be defined\");\n  }\n\n  if (hasExtension(boundingVolumeHeader, \"3DTILES_bounding_volume_S2\")) {\n    return new TileBoundingS2Cell(\n      boundingVolumeHeader.extensions[\"3DTILES_bounding_volume_S2\"],\n    );\n  }\n\n  const { box, region, sphere } = boundingVolumeHeader;\n  if (defined(box)) {\n    const tileOrientedBoundingBox = createBox(box, transform, result);\n    if (this._verticalExaggeration !== 1.0) {\n      exaggerateBoundingBox(\n        tileOrientedBoundingBox,\n        this._verticalExaggeration,\n        this._verticalExaggerationRelativeHeight,\n      );\n    }\n    return tileOrientedBoundingBox;\n  }\n  if (defined(region)) {\n    const tileBoundingVolume = createRegion(\n      region,\n      transform,\n      this._initialTransform,\n      result,\n    );\n    if (this._verticalExaggeration === 1.0) {\n      return tileBoundingVolume;\n    }\n    if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n      exaggerateBoundingBox(\n        tileBoundingVolume,\n        this._verticalExaggeration,\n        this._verticalExaggerationRelativeHeight,\n      );\n    } else {\n      tileBoundingVolume.minimumHeight = VerticalExaggeration.getHeight(\n        tileBoundingVolume.minimumHeight,\n        this._verticalExaggeration,\n        this._verticalExaggerationRelativeHeight,\n      );\n      tileBoundingVolume.maximumHeight = VerticalExaggeration.getHeight(\n        tileBoundingVolume.maximumHeight,\n        this._verticalExaggeration,\n        this._verticalExaggerationRelativeHeight,\n      );\n      tileBoundingVolume.computeBoundingVolumes(Ellipsoid.WGS84);\n    }\n    return tileBoundingVolume;\n  }\n  if (defined(sphere)) {\n    const tileBoundingSphere = createSphere(sphere, transform, result);\n    if (this._verticalExaggeration !== 1.0) {\n      const exaggeratedCenter = VerticalExaggeration.getPosition(\n        tileBoundingSphere.center,\n        Ellipsoid.WGS84,\n        this._verticalExaggeration,\n        this._verticalExaggerationRelativeHeight,\n        scratchCenter,\n      );\n      const exaggeratedRadius =\n        tileBoundingSphere.radius * this._verticalExaggeration;\n      tileBoundingSphere.update(exaggeratedCenter, exaggeratedRadius);\n    }\n    return tileBoundingSphere;\n  }\n  throw new RuntimeError(\n    \"boundingVolume must contain a sphere, region, or box\",\n  );\n};\n\nconst scratchExaggeratedCorners = Cartesian3.unpackArray(\n  new Array(8 * 3).fill(0),\n);\n\n/**\n * Exaggerates the bounding box of a tile based on the provided exaggeration factors.\n *\n * @private\n * @param {TileOrientedBoundingBox} tileOrientedBoundingBox - The oriented bounding box of the tile.\n * @param {number} exaggeration - The exaggeration factor to apply to the tile's bounding box.\n * @param {number} exaggerationRelativeHeight - The height relative to which exaggeration will be applied.\n */\nfunction exaggerateBoundingBox(\n  tileOrientedBoundingBox,\n  exaggeration,\n  exaggerationRelativeHeight,\n) {\n  const exaggeratedCorners = tileOrientedBoundingBox.boundingVolume\n    .computeCorners(scratchExaggeratedCorners)\n    .map((corner) =>\n      VerticalExaggeration.getPosition(\n        corner,\n        Ellipsoid.WGS84,\n        exaggeration,\n        exaggerationRelativeHeight,\n        corner,\n      ),\n    );\n  const exaggeratedBox = OrientedBoundingBox.fromPoints(\n    exaggeratedCorners,\n    scratchOrientedBoundingBox,\n  );\n  tileOrientedBoundingBox.update(\n    exaggeratedBox.center,\n    exaggeratedBox.halfAxes,\n  );\n}\n\n/**\n * Update the tile's transform. The transform is applied to the tile's bounding volumes.\n *\n * @private\n * @param {Matrix4} parentTransform\n * @param {FrameState} [frameState]\n */\nCesium3DTile.prototype.updateTransform = function (\n  parentTransform,\n  frameState,\n) {\n  parentTransform = defaultValue(parentTransform, Matrix4.IDENTITY);\n  const computedTransform = Matrix4.multiplyTransformation(\n    parentTransform,\n    this.transform,\n    scratchTransform,\n  );\n  const transformChanged = !Matrix4.equals(\n    computedTransform,\n    this.computedTransform,\n  );\n  const exaggerationChanged =\n    defined(frameState) &&\n    (this._verticalExaggeration !== frameState.verticalExaggeration ||\n      this._verticalExaggerationRelativeHeight !==\n        frameState.verticalExaggerationRelativeHeight);\n\n  if (!transformChanged && !exaggerationChanged) {\n    return;\n  }\n  if (transformChanged) {\n    Matrix4.clone(computedTransform, this.computedTransform);\n  }\n  if (exaggerationChanged) {\n    this._verticalExaggeration = frameState.verticalExaggeration;\n    this._verticalExaggerationRelativeHeight =\n      frameState.verticalExaggerationRelativeHeight;\n  }\n\n  // Update the bounding volumes\n  const header = this._header;\n  const contentHeader = this._contentHeader;\n  this._boundingVolume = this.createBoundingVolume(\n    header.boundingVolume,\n    this.computedTransform,\n    this._boundingVolume,\n  );\n  if (defined(this._contentBoundingVolume)) {\n    this._contentBoundingVolume = this.createBoundingVolume(\n      contentHeader.boundingVolume,\n      this.computedTransform,\n      this._contentBoundingVolume,\n    );\n  }\n  if (defined(this._viewerRequestVolume)) {\n    this._viewerRequestVolume = this.createBoundingVolume(\n      header.viewerRequestVolume,\n      this.computedTransform,\n      this._viewerRequestVolume,\n    );\n  }\n\n  this.updateGeometricErrorScale();\n\n  // Destroy the debug bounding volumes. They will be generated fresh.\n  this._debugBoundingVolume =\n    this._debugBoundingVolume && this._debugBoundingVolume.destroy();\n  this._debugContentBoundingVolume =\n    this._debugContentBoundingVolume &&\n    this._debugContentBoundingVolume.destroy();\n  this._debugViewerRequestVolume =\n    this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy();\n};\n\nCesium3DTile.prototype.updateGeometricErrorScale = function () {\n  const scale = Matrix4.getScale(this.computedTransform, scratchScale);\n  const uniformScale = Cartesian3.maximumComponent(scale);\n  this.geometricError = this._geometricError * uniformScale;\n\n  if (!defined(this.parent)) {\n    // Update the tileset's geometric error\n    const tileset = this._tileset;\n    tileset._scaledGeometricError = tileset._geometricError * uniformScale;\n  }\n};\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n * @param {object} passOptions\n */\nfunction applyDebugSettings(tile, tileset, frameState, passOptions) {\n  if (!passOptions.isRender) {\n    return;\n  }\n\n  const hasContentBoundingVolume =\n    defined(tile._contentHeader) && defined(tile._contentHeader.boundingVolume);\n\n  const showVolume =\n    tileset.debugShowBoundingVolume ||\n    (tileset.debugShowContentBoundingVolume && !hasContentBoundingVolume);\n  if (showVolume) {\n    let color;\n    if (!tile._finalResolution) {\n      color = Color.YELLOW;\n    } else if (!tile.hasRenderableContent) {\n      color = Color.DARKGRAY;\n    } else {\n      color = Color.WHITE;\n    }\n    if (!defined(tile._debugBoundingVolume)) {\n      tile._debugBoundingVolume = tile._boundingVolume.createDebugVolume(color);\n    }\n    tile._debugBoundingVolume.update(frameState);\n    const attributes =\n      tile._debugBoundingVolume.getGeometryInstanceAttributes(\"outline\");\n    attributes.color = ColorGeometryInstanceAttribute.toValue(\n      color,\n      attributes.color,\n    );\n  } else if (!showVolume && defined(tile._debugBoundingVolume)) {\n    tile._debugBoundingVolume = tile._debugBoundingVolume.destroy();\n  }\n\n  if (tileset.debugShowContentBoundingVolume && hasContentBoundingVolume) {\n    if (!defined(tile._debugContentBoundingVolume)) {\n      tile._debugContentBoundingVolume =\n        tile._contentBoundingVolume.createDebugVolume(Color.BLUE);\n    }\n    tile._debugContentBoundingVolume.update(frameState);\n  } else if (\n    !tileset.debugShowContentBoundingVolume &&\n    defined(tile._debugContentBoundingVolume)\n  ) {\n    tile._debugContentBoundingVolume =\n      tile._debugContentBoundingVolume.destroy();\n  }\n\n  if (\n    tileset.debugShowViewerRequestVolume &&\n    defined(tile._viewerRequestVolume)\n  ) {\n    if (!defined(tile._debugViewerRequestVolume)) {\n      tile._debugViewerRequestVolume =\n        tile._viewerRequestVolume.createDebugVolume(Color.YELLOW);\n    }\n    tile._debugViewerRequestVolume.update(frameState);\n  } else if (\n    !tileset.debugShowViewerRequestVolume &&\n    defined(tile._debugViewerRequestVolume)\n  ) {\n    tile._debugViewerRequestVolume = tile._debugViewerRequestVolume.destroy();\n  }\n\n  const debugColorizeTilesOn =\n    (tileset.debugColorizeTiles && !tile._debugColorizeTiles) ||\n    defined(tileset._heatmap.tilePropertyName);\n  const debugColorizeTilesOff =\n    !tileset.debugColorizeTiles && tile._debugColorizeTiles;\n\n  if (debugColorizeTilesOn) {\n    tileset._heatmap.colorize(tile, frameState); // Skipped if tileset._heatmap.tilePropertyName is undefined\n    tile._debugColorizeTiles = true;\n    tile.color = tile._debugColor;\n  } else if (debugColorizeTilesOff) {\n    tile._debugColorizeTiles = false;\n    tile.color = Color.WHITE;\n  }\n\n  if (tile._colorDirty) {\n    tile._colorDirty = false;\n    tile._content.applyDebugSettings(true, tile._color);\n  }\n\n  if (debugColorizeTilesOff) {\n    tileset.makeStyleDirty(); // Re-apply style now that colorize is switched off\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n */\nfunction updateContent(tile, tileset, frameState) {\n  const expiredContent = tile._expiredContent;\n\n  // expired content is not supported for multiple contents\n  if (!tile.hasMultipleContents && defined(expiredContent)) {\n    if (!tile.contentReady) {\n      // Render the expired content while the content loads\n      try {\n        expiredContent.update(tileset, frameState);\n      } catch (error) {\n        // Eat error for expired content\n      }\n      return;\n    }\n\n    // New content is ready, destroy expired content\n    tile._expiredContent.destroy();\n    tile._expiredContent = undefined;\n  }\n\n  if (!defined(tile.content)) {\n    // Implicit placeholder tile\n    return;\n  }\n\n  try {\n    tile.content.update(tileset, frameState);\n  } catch (error) {\n    tile._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n}\n\n/**\n * Compute and compare ClippingPlanes state:\n *  - enabled-ness - are clipping planes enabled? is this tile clipped?\n *  - clipping plane count\n *  - clipping function (union v. intersection)\n\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n */\nfunction updateClippingPlanes(tile, tileset) {\n  const clippingPlanes = tileset.clippingPlanes;\n  let currentClippingPlanesState = 0;\n  if (defined(clippingPlanes) && tile._isClipped && clippingPlanes.enabled) {\n    currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n  // If clippingPlaneState for tile changed, mark clippingPlanesDirty so content can update\n  if (currentClippingPlanesState !== tile._clippingPlanesState) {\n    tile._clippingPlanesState = currentClippingPlanesState;\n    tile.clippingPlanesDirty = true;\n  }\n}\n\n/**\n * Compute and compare ClippingPolygons state:\n *  - enabled-ness - are clipping polygons enabled? is this tile clipped?\n *  - clipping polygon count & position count\n *  - clipping function (inverse)\n\n * @private\n * @param {Cesium3DTile} tile\n * @param {Cesium3DTileset} tileset\n */\nfunction updateClippingPolygons(tile, tileset) {\n  const clippingPolygons = tileset.clippingPolygons;\n  let currentClippingPolygonsState = 0;\n  if (\n    defined(clippingPolygons) &&\n    tile._isClippedByPolygon &&\n    clippingPolygons.enabled\n  ) {\n    currentClippingPolygonsState = clippingPolygons.clippingPolygonsState;\n  }\n  // If clippingPolygonState for tile changed, mark clippingPolygonsDirty so content can update\n  if (currentClippingPolygonsState !== tile._clippingPolygonsState) {\n    tile._clippingPolygonsState = currentClippingPolygonsState;\n    tile.clippingPolygonsDirty = true;\n  }\n}\n\n/**\n * Get the draw commands needed to render this tile.\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n * @param {object} passOptions\n */\nCesium3DTile.prototype.update = function (tileset, frameState, passOptions) {\n  const { commandList } = frameState;\n  const commandStart = commandList.length;\n\n  updateClippingPlanes(this, tileset);\n  updateClippingPolygons(this, tileset);\n  applyDebugSettings(this, tileset, frameState, passOptions);\n  updateContent(this, tileset, frameState);\n\n  const commandEnd = commandList.length;\n  this._commandsLength = commandEnd - commandStart;\n\n  for (let i = commandStart; i < commandEnd; ++i) {\n    const command = commandList[i];\n    const translucent = command.pass === Pass.TRANSLUCENT;\n    command.depthForTranslucentClassification = translucent;\n  }\n\n  this.clippingPlanesDirty = false; // reset after content update\n  this.clippingPolygonsDirty = false;\n};\n\nconst scratchCommandList = [];\n\n/**\n * Processes the tile's content, e.g., create WebGL resources, to move from the PROCESSING to READY state.\n *\n * @param {Cesium3DTileset} tileset The tileset containing this tile.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nCesium3DTile.prototype.process = function (tileset, frameState) {\n  if (!this.contentExpired && !this.contentReady && this._content.ready) {\n    updateExpireDate(this);\n\n    // Refresh style for expired content\n    this._selectedFrame = 0;\n    this.lastStyleTime = 0.0;\n\n    JulianDate.now(this._loadTimestamp);\n    this._contentState = Cesium3DTileContentState.READY;\n\n    if (!this.hasTilesetContent && !this.hasImplicitContent) {\n      // RESEARCH_IDEA: ability to unload tiles (without content) for an\n      // external tileset when all the tiles are unloaded.\n      tileset._statistics.incrementLoadCounts(this.content);\n      ++tileset._statistics.numberOfTilesWithContentReady;\n      ++tileset._statistics.numberOfLoadedTilesTotal;\n\n      // Add to the tile cache. Previously expired tiles are already in the cache and won't get re-added.\n      tileset._cache.add(this);\n    }\n  }\n\n  const savedCommandList = frameState.commandList;\n  frameState.commandList = scratchCommandList;\n\n  try {\n    this._content.update(tileset, frameState);\n  } catch (error) {\n    this._contentState = Cesium3DTileContentState.FAILED;\n    throw error;\n  }\n\n  scratchCommandList.length = 0;\n  frameState.commandList = savedCommandList;\n};\n\n/**\n * @private\n * @param {number} normalizedValue\n * @param {number} numberOfDigits\n * @param {number} leftShift\n * @returns {number}\n */\nfunction isolateDigits(normalizedValue, numberOfDigits, leftShift) {\n  const scaled = normalizedValue * Math.pow(10, numberOfDigits);\n  const integer = parseInt(scaled);\n  return integer * Math.pow(10, leftShift);\n}\n\n/**\n * @private\n * @param {number} value\n * @param {number} minimum\n * @param {number} maximum\n * @returns {number}\n */\nfunction priorityNormalizeAndClamp(value, minimum, maximum) {\n  // Subtract epsilon since we only want decimal digits present in the output.\n  return Math.max(\n    CesiumMath.normalize(value, minimum, maximum) - CesiumMath.EPSILON7,\n    0.0,\n  );\n}\n\n/**\n * Sets the priority of the tile based on distance and depth\n * @private\n */\nCesium3DTile.prototype.updatePriority = function () {\n  const tileset = this.tileset;\n  const preferLeaves = tileset.preferLeaves;\n  const minimumPriority = tileset._minimumPriority;\n  const maximumPriority = tileset._maximumPriority;\n\n  // Combine priority systems together by mapping them into a base 10 number where each priority controls a specific set of digits in the number.\n  // For number priorities, map them to a 0.xxxxx number then left shift it up into a set number of digits before the decimal point. Chop of the fractional part then left shift again into the position it needs to go.\n  // For blending number priorities, normalize them to 0-1 and interpolate to get a combined 0-1 number, then proceed as normal.\n  // Booleans can just be 0 or 10^leftshift.\n  // Think of digits as penalties since smaller numbers are higher priority. If a tile has some large quantity or has a flag raised it's (usually) penalized for it, expressed as a higher number for the digit.\n  // Priority number format: preloadFlightDigits(1) | foveatedDeferDigits(1) | foveatedDigits(4) | preloadProgressiveResolutionDigits(1) | preferredSortingDigits(4) . depthDigits(the decimal digits)\n  // Certain flags like preferLeaves will flip / turn off certain digits to get desired load order.\n\n  // Setup leftShifts, digit counts, and scales (for booleans)\n  const digitsForANumber = 4;\n  const digitsForABoolean = 1;\n\n  const preferredSortingLeftShift = 0;\n  const preferredSortingDigitsCount = digitsForANumber;\n\n  const foveatedLeftShift =\n    preferredSortingLeftShift + preferredSortingDigitsCount;\n  const foveatedDigitsCount = digitsForANumber;\n\n  const preloadProgressiveResolutionLeftShift =\n    foveatedLeftShift + foveatedDigitsCount;\n  const preloadProgressiveResolutionDigitsCount = digitsForABoolean;\n  const preloadProgressiveResolutionScale = Math.pow(\n    10,\n    preloadProgressiveResolutionLeftShift,\n  );\n\n  const foveatedDeferLeftShift =\n    preloadProgressiveResolutionLeftShift +\n    preloadProgressiveResolutionDigitsCount;\n  const foveatedDeferDigitsCount = digitsForABoolean;\n  const foveatedDeferScale = Math.pow(10, foveatedDeferLeftShift);\n\n  const preloadFlightLeftShift =\n    foveatedDeferLeftShift + foveatedDeferDigitsCount;\n  const preloadFlightScale = Math.pow(10, preloadFlightLeftShift);\n\n  // Compute the digits for each priority\n  let depthDigits = priorityNormalizeAndClamp(\n    this._depth,\n    minimumPriority.depth,\n    maximumPriority.depth,\n  );\n  depthDigits = preferLeaves ? 1.0 - depthDigits : depthDigits;\n\n  // Map 0-1 then convert to digit. Include a distance sort when doing non-skipLOD and replacement refinement, helps things like non-skipLOD photogrammetry\n  const useDistance =\n    !tileset.isSkippingLevelOfDetail &&\n    this.refine === Cesium3DTileRefine.REPLACE;\n  const normalizedPreferredSorting = useDistance\n    ? priorityNormalizeAndClamp(\n        this._priorityHolder._distanceToCamera,\n        minimumPriority.distance,\n        maximumPriority.distance,\n      )\n    : priorityNormalizeAndClamp(\n        this._priorityReverseScreenSpaceError,\n        minimumPriority.reverseScreenSpaceError,\n        maximumPriority.reverseScreenSpaceError,\n      );\n  const preferredSortingDigits = isolateDigits(\n    normalizedPreferredSorting,\n    preferredSortingDigitsCount,\n    preferredSortingLeftShift,\n  );\n\n  const preloadProgressiveResolutionDigits = this._priorityProgressiveResolution\n    ? 0\n    : preloadProgressiveResolutionScale;\n\n  const normalizedFoveatedFactor = priorityNormalizeAndClamp(\n    this._priorityHolder._foveatedFactor,\n    minimumPriority.foveatedFactor,\n    maximumPriority.foveatedFactor,\n  );\n  const foveatedDigits = isolateDigits(\n    normalizedFoveatedFactor,\n    foveatedDigitsCount,\n    foveatedLeftShift,\n  );\n\n  const foveatedDeferDigits = this.priorityDeferred ? foveatedDeferScale : 0;\n\n  const preloadFlightDigits =\n    tileset._pass === Cesium3DTilePass.PRELOAD_FLIGHT ? 0 : preloadFlightScale;\n\n  // Get the final base 10 number\n  this._priority =\n    depthDigits +\n    preferredSortingDigits +\n    preloadProgressiveResolutionDigits +\n    foveatedDigits +\n    foveatedDeferDigits +\n    preloadFlightDigits;\n};\n\n/**\n * @private\n */\nCesium3DTile.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nCesium3DTile.prototype.destroy = function () {\n  // For the interval between new content being requested and downloaded, expiredContent === content, so don't destroy twice\n  this._content = this._content && this._content.destroy();\n  this._expiredContent =\n    this._expiredContent &&\n    !this._expiredContent.isDestroyed() &&\n    this._expiredContent.destroy();\n  this._debugBoundingVolume =\n    this._debugBoundingVolume && this._debugBoundingVolume.destroy();\n  this._debugContentBoundingVolume =\n    this._debugContentBoundingVolume &&\n    this._debugContentBoundingVolume.destroy();\n  this._debugViewerRequestVolume =\n    this._debugViewerRequestVolume && this._debugViewerRequestVolume.destroy();\n  return destroyObject(this);\n};\n\nexport default Cesium3DTile;\n"],"mappings":"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,CAACC,kBAAkB,GAAG,KAAK;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,0BAA0B,GAAG,KAAK;;EAEvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACzD,mBAAmB,GAAGA,mBAAmB;;EAE9C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC0D,SAAS,GAAGpC,SAAS;EAE1B,MAAMqC,MAAM,GAAGjE,MAAM,CAACiE,MAAM;EAC5B,IAAIC,cAAc;EAClB,IAAIC,UAAU;EACd,IAAI9G,OAAO,CAAC4G,MAAM,CAAC,EAAE;IACnBC,cAAc,GAAGD,MAAM,CAACG,QAAQ;IAChC,IAAI/G,OAAO,CAAC4G,MAAM,CAACI,IAAI,CAAC,EAAE;MACxBF,UAAU,GAAGzG,UAAU,CAAC4G,WAAW,CAACL,MAAM,CAACI,IAAI,CAAC;IAClD;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAI,CAACH,cAAc,GAAGA,cAAc;;EAEpC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGA,UAAU;;EAE5B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACI,aAAa,GAAG,GAAG;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,0BAA0B,GAAG7F,4BAA4B,CAAC8F,YAAY;;EAE3E;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAG,KAAK;;EAEhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,qBAAqB,GAAG,KAAK;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG,KAAK;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGjD,SAAS;;EAEhC;AACF;AACA;AACA;AACA;AACA;AACA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}