{"ast":null,"code":"import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport VerticalExaggeration from \"./VerticalExaggeration.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3DimScratch = new Cartesian3();\nconst cartesian2Scratch = new Cartesian2();\nconst matrix4Scratch = new Matrix4();\nconst matrix4Scratch2 = new Matrix4();\nconst SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {Cartesian3} center The center point of the vertices.\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {number} minimumHeight The minimum height.\n * @param {number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n * @param {boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\n * @param {number} [exaggeration=1.0] A scalar used to exaggerate terrain.\n * @param {number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\n *\n * @private\n */\nfunction TerrainEncoding(center, axisAlignedBoundingBox, minimumHeight, maximumHeight, fromENU, hasVertexNormals, hasWebMercatorT, hasGeodeticSurfaceNormals, exaggeration, exaggerationRelativeHeight) {\n  let quantization = TerrainQuantization.NONE;\n  let toENU;\n  let matrix;\n  if (defined(axisAlignedBoundingBox) && defined(minimumHeight) && defined(maximumHeight) && defined(fromENU)) {\n    const minimum = axisAlignedBoundingBox.minimum;\n    const maximum = axisAlignedBoundingBox.maximum;\n    const dimensions = Cartesian3.subtract(maximum, minimum, cartesian3DimScratch);\n    const hDim = maximumHeight - minimumHeight;\n    const maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n    const translation = Cartesian3.negate(minimum, cartesian3Scratch);\n    Matrix4.multiply(Matrix4.fromTranslation(translation, matrix4Scratch), toENU, toENU);\n    const scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n    matrix = Matrix4.clone(fromENU);\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\n    const translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n    const scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\n    const st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n    Matrix4.multiply(fromENU, st, fromENU);\n    Matrix4.multiply(matrix, st, matrix);\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = Cartesian3.clone(center);\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {boolean}\n   */\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n\n  /**\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\n   * @type {boolean}\n   */\n  this.hasGeodeticSurfaceNormals = defaultValue(hasGeodeticSurfaceNormals, false);\n\n  /**\n   * A scalar used to exaggerate terrain.\n   * @type {number}\n   */\n  this.exaggeration = defaultValue(exaggeration, 1.0);\n\n  /**\n   * The relative height from which terrain is exaggerated.\n   */\n  this.exaggerationRelativeHeight = defaultValue(exaggerationRelativeHeight, 0.0);\n\n  /**\n   * The number of components in each vertex. This value can differ with different quantizations.\n   * @type {number}\n   */\n  this.stride = 0;\n  this._offsetGeodeticSurfaceNormal = 0;\n  this._offsetVertexNormal = 0;\n\n  // Calculate the stride and offsets declared above\n  this._calculateStrideAndOffsets();\n}\nTerrainEncoding.prototype.encode = function (vertexBuffer, bufferIndex, position, uv, height, normalToPack, webMercatorT, geodeticSurfaceNormal) {\n  const u = uv.x;\n  const v = uv.y;\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(this.toScaledENU, position, cartesian3Scratch);\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n    const hDim = this.maximumHeight - this.minimumHeight;\n    const h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    const compressed0 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    const compressed1 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    const compressed2 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      const compressed3 = AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] = AttributeCompression.octPackFloat(normalToPack);\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\n  }\n  return bufferIndex;\n};\nconst scratchPosition = new Cartesian3();\nconst scratchGeodeticSurfaceNormal = new Cartesian3();\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (oldBuffer, newBuffer, ellipsoid) {\n  if (this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = true;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < oldStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n    const position = this.decodePosition(newBuffer, index, scratchPosition);\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(position, scratchGeodeticSurfaceNormal);\n    const bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\n  }\n};\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (oldBuffer, newBuffer) {\n  if (!this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = false;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < newStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n  }\n};\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  index *= this.stride;\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const xy = AttributeCompression.decompressTextureCoordinates(buffer[index], cartesian2Scratch);\n    result.x = xy.x;\n    result.y = xy.y;\n    const zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\n    result.z = zh.x;\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\nTerrainEncoding.prototype.getExaggeratedPosition = function (buffer, index, result) {\n  result = this.decodePosition(buffer, index, result);\n  const exaggeration = this.exaggeration;\n  const exaggerationRelativeHeight = this.exaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\n    const geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(buffer, index, scratchGeodeticSurfaceNormal);\n    const rawHeight = this.decodeHeight(buffer, index);\n    const heightDifference = VerticalExaggeration.getHeight(rawHeight, exaggeration, exaggerationRelativeHeight) - rawHeight;\n\n    // some math is unrolled for better performance\n    result.x += geodeticSurfaceNormal.x * heightDifference;\n    result.y += geodeticSurfaceNormal.y * heightDifference;\n    result.z += geodeticSurfaceNormal.z * heightDifference;\n  }\n  return result;\n};\nTerrainEncoding.prototype.decodeTextureCoordinates = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  index *= this.stride;\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(buffer[index + 2], result);\n  }\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.stride;\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const zh = AttributeCompression.decompressTextureCoordinates(buffer[index + 1], cartesian2Scratch);\n    return zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight;\n  }\n  return buffer[index + 3];\n};\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.stride;\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(buffer[index + 3], cartesian2Scratch).x;\n  }\n  return buffer[index + 6];\n};\nTerrainEncoding.prototype.getOctEncodedNormal = function (buffer, index, result) {\n  index = index * this.stride + this._offsetVertexNormal;\n  const temp = buffer[index] / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n  return Cartesian2.fromElements(x, y, result);\n};\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (buffer, index, result) {\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return result;\n};\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\n  let vertexStride = 0;\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride += 3;\n      break;\n    default:\n      vertexStride += 6;\n  }\n  if (this.hasWebMercatorT) {\n    vertexStride += 1;\n  }\n  if (this.hasVertexNormals) {\n    this._offsetVertexNormal = vertexStride;\n    vertexStride += 1;\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    this._offsetGeodeticSurfaceNormal = vertexStride;\n    vertexStride += 3;\n  }\n  this.stride = vertexStride;\n};\nconst attributesIndicesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n  geodeticSurfaceNormal: 2\n};\nconst attributesIndicesBits12 = {\n  compressed0: 0,\n  compressed1: 1,\n  geodeticSurfaceNormal: 2\n};\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  const datatype = ComponentDatatype.FLOAT;\n  const sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  const strideInBytes = this.stride * sizeInBytes;\n  let offsetInBytes = 0;\n  const attributes = [];\n  function addAttribute(index, componentsPerAttribute) {\n    attributes.push({\n      index: index,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: componentsPerAttribute,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes\n    });\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\n  }\n  if (this.quantization === TerrainQuantization.NONE) {\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\n    let componentsTexCoordAndNormals = 2;\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\n    addAttribute(attributesIndicesNone.textureCoordAndEncodedNormals, componentsTexCoordAndNormals);\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\n    }\n  } else {\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\n    const usingAttribute0Component4 = this.hasWebMercatorT || this.hasVertexNormals;\n    const usingAttribute1Component1 = this.hasWebMercatorT && this.hasVertexNormals;\n    addAttribute(attributesIndicesBits12.compressed0, usingAttribute0Component4 ? 4 : 3);\n    if (usingAttribute1Component1) {\n      addAttribute(attributesIndicesBits12.compressed1, 1);\n    }\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\n    }\n  }\n  return attributes;\n};\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesIndicesNone;\n  }\n  return attributesIndicesBits12;\n};\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(encoding)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n  result.exaggeration = encoding.exaggeration;\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\n  result._calculateStrideAndOffsets();\n  return result;\n};\nexport default TerrainEncoding;","map":{"version":3,"names":["AttributeCompression","Cartesian2","Cartesian3","ComponentDatatype","defaultValue","defined","CesiumMath","Matrix4","VerticalExaggeration","TerrainQuantization","cartesian3Scratch","cartesian3DimScratch","cartesian2Scratch","matrix4Scratch","matrix4Scratch2","SHIFT_LEFT_12","Math","pow","TerrainEncoding","center","axisAlignedBoundingBox","minimumHeight","maximumHeight","fromENU","hasVertexNormals","hasWebMercatorT","hasGeodeticSurfaceNormals","exaggeration","exaggerationRelativeHeight","quantization","NONE","toENU","matrix","minimum","maximum","dimensions","subtract","hDim","maxDim","max","maximumComponent","BITS12","inverseTransformation","translation","negate","multiply","fromTranslation","scale","x","y","z","fromScale","clone","setTranslation","ZERO","translationMatrix","scaleMatrix","st","toScaledENU","fromScaledENU","stride","_offsetGeodeticSurfaceNormal","_offsetVertexNormal","_calculateStrideAndOffsets","prototype","encode","vertexBuffer","bufferIndex","position","uv","height","normalToPack","webMercatorT","geodeticSurfaceNormal","u","v","multiplyByPoint","clamp","h","fromElements","compressed0","compressTextureCoordinates","compressed1","compressed2","compressed3","octPackFloat","scratchPosition","scratchGeodeticSurfaceNormal","addGeodeticSurfaceNormals","oldBuffer","newBuffer","ellipsoid","oldStride","vertexCount","length","newStride","index","offset","oldIndex","newIndex","decodePosition","removeGeodeticSurfaceNormals","buffer","result","xy","decompressTextureCoordinates","zh","add","getExaggeratedPosition","hasExaggeration","decodeGeodeticSurfaceNormal","rawHeight","decodeHeight","heightDifference","getHeight","decodeTextureCoordinates","decodeWebMercatorT","getOctEncodedNormal","temp","floor","vertexStride","attributesIndicesNone","position3DAndHeight","textureCoordAndEncodedNormals","attributesIndicesBits12","getAttributes","datatype","FLOAT","sizeInBytes","getSizeInBytes","strideInBytes","offsetInBytes","attributes","addAttribute","componentsPerAttribute","push","componentDatatype","componentsTexCoordAndNormals","usingAttribute0Component4","usingAttribute1Component1","getAttributeLocations","encoding","undefined"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/TerrainEncoding.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport VerticalExaggeration from \"./VerticalExaggeration.js\";\nimport TerrainQuantization from \"./TerrainQuantization.js\";\n\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3DimScratch = new Cartesian3();\nconst cartesian2Scratch = new Cartesian2();\nconst matrix4Scratch = new Matrix4();\nconst matrix4Scratch2 = new Matrix4();\n\nconst SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {Cartesian3} center The center point of the vertices.\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {number} minimumHeight The minimum height.\n * @param {number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n * @param {boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\n * @param {number} [exaggeration=1.0] A scalar used to exaggerate terrain.\n * @param {number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\n *\n * @private\n */\nfunction TerrainEncoding(\n  center,\n  axisAlignedBoundingBox,\n  minimumHeight,\n  maximumHeight,\n  fromENU,\n  hasVertexNormals,\n  hasWebMercatorT,\n  hasGeodeticSurfaceNormals,\n  exaggeration,\n  exaggerationRelativeHeight,\n) {\n  let quantization = TerrainQuantization.NONE;\n  let toENU;\n  let matrix;\n\n  if (\n    defined(axisAlignedBoundingBox) &&\n    defined(minimumHeight) &&\n    defined(maximumHeight) &&\n    defined(fromENU)\n  ) {\n    const minimum = axisAlignedBoundingBox.minimum;\n    const maximum = axisAlignedBoundingBox.maximum;\n\n    const dimensions = Cartesian3.subtract(\n      maximum,\n      minimum,\n      cartesian3DimScratch,\n    );\n    const hDim = maximumHeight - minimumHeight;\n    const maxDim = Math.max(Cartesian3.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = TerrainQuantization.BITS12;\n    } else {\n      quantization = TerrainQuantization.NONE;\n    }\n\n    toENU = Matrix4.inverseTransformation(fromENU, new Matrix4());\n\n    const translation = Cartesian3.negate(minimum, cartesian3Scratch);\n    Matrix4.multiply(\n      Matrix4.fromTranslation(translation, matrix4Scratch),\n      toENU,\n      toENU,\n    );\n\n    const scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    Matrix4.multiply(Matrix4.fromScale(scale, matrix4Scratch), toENU, toENU);\n\n    matrix = Matrix4.clone(fromENU);\n    Matrix4.setTranslation(matrix, Cartesian3.ZERO, matrix);\n\n    fromENU = Matrix4.clone(fromENU, new Matrix4());\n\n    const translationMatrix = Matrix4.fromTranslation(minimum, matrix4Scratch);\n    const scaleMatrix = Matrix4.fromScale(dimensions, matrix4Scratch2);\n    const st = Matrix4.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n\n    Matrix4.multiply(fromENU, st, fromENU);\n    Matrix4.multiply(matrix, st, matrix);\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = Cartesian3.clone(center);\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {boolean}\n   */\n  this.hasWebMercatorT = defaultValue(hasWebMercatorT, false);\n\n  /**\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\n   * @type {boolean}\n   */\n  this.hasGeodeticSurfaceNormals = defaultValue(\n    hasGeodeticSurfaceNormals,\n    false,\n  );\n\n  /**\n   * A scalar used to exaggerate terrain.\n   * @type {number}\n   */\n  this.exaggeration = defaultValue(exaggeration, 1.0);\n\n  /**\n   * The relative height from which terrain is exaggerated.\n   */\n  this.exaggerationRelativeHeight = defaultValue(\n    exaggerationRelativeHeight,\n    0.0,\n  );\n\n  /**\n   * The number of components in each vertex. This value can differ with different quantizations.\n   * @type {number}\n   */\n  this.stride = 0;\n\n  this._offsetGeodeticSurfaceNormal = 0;\n  this._offsetVertexNormal = 0;\n\n  // Calculate the stride and offsets declared above\n  this._calculateStrideAndOffsets();\n}\n\nTerrainEncoding.prototype.encode = function (\n  vertexBuffer,\n  bufferIndex,\n  position,\n  uv,\n  height,\n  normalToPack,\n  webMercatorT,\n  geodeticSurfaceNormal,\n) {\n  const u = uv.x;\n  const v = uv.y;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    position = Matrix4.multiplyByPoint(\n      this.toScaledENU,\n      position,\n      cartesian3Scratch,\n    );\n\n    position.x = CesiumMath.clamp(position.x, 0.0, 1.0);\n    position.y = CesiumMath.clamp(position.y, 0.0, 1.0);\n    position.z = CesiumMath.clamp(position.z, 0.0, 1.0);\n\n    const hDim = this.maximumHeight - this.minimumHeight;\n    const h = CesiumMath.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n    Cartesian2.fromElements(position.x, position.y, cartesian2Scratch);\n    const compressed0 =\n      AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n    Cartesian2.fromElements(position.z, h, cartesian2Scratch);\n    const compressed1 =\n      AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n    Cartesian2.fromElements(u, v, cartesian2Scratch);\n    const compressed2 =\n      AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      Cartesian2.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      const compressed3 =\n        AttributeCompression.compressTextureCoordinates(cartesian2Scratch);\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    Cartesian3.subtract(position, this.center, cartesian3Scratch);\n\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] =\n      AttributeCompression.octPackFloat(normalToPack);\n  }\n\n  if (this.hasGeodeticSurfaceNormals) {\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\n  }\n\n  return bufferIndex;\n};\n\nconst scratchPosition = new Cartesian3();\nconst scratchGeodeticSurfaceNormal = new Cartesian3();\n\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n  ellipsoid,\n) {\n  if (this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = true;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < oldStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n    const position = this.decodePosition(newBuffer, index, scratchPosition);\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      scratchGeodeticSurfaceNormal,\n    );\n\n    const bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\n  }\n};\n\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n) {\n  if (!this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  const oldStride = this.stride;\n  const vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = false;\n  this._calculateStrideAndOffsets();\n  const newStride = this.stride;\n\n  for (let index = 0; index < vertexCount; index++) {\n    for (let offset = 0; offset < newStride; offset++) {\n      const oldIndex = index * oldStride + offset;\n      const newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n  }\n};\n\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const xy = AttributeCompression.decompressTextureCoordinates(\n      buffer[index],\n      cartesian2Scratch,\n    );\n    result.x = xy.x;\n    result.y = xy.y;\n\n    const zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch,\n    );\n    result.z = zh.x;\n\n    return Matrix4.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return Cartesian3.add(result, this.center, result);\n};\n\nTerrainEncoding.prototype.getExaggeratedPosition = function (\n  buffer,\n  index,\n  result,\n) {\n  result = this.decodePosition(buffer, index, result);\n\n  const exaggeration = this.exaggeration;\n  const exaggerationRelativeHeight = this.exaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\n    const geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(\n      buffer,\n      index,\n      scratchGeodeticSurfaceNormal,\n    );\n    const rawHeight = this.decodeHeight(buffer, index);\n    const heightDifference =\n      VerticalExaggeration.getHeight(\n        rawHeight,\n        exaggeration,\n        exaggerationRelativeHeight,\n      ) - rawHeight;\n\n    // some math is unrolled for better performance\n    result.x += geodeticSurfaceNormal.x * heightDifference;\n    result.y += geodeticSurfaceNormal.y * heightDifference;\n    result.z += geodeticSurfaceNormal.z * heightDifference;\n  }\n\n  return result;\n};\n\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\n  buffer,\n  index,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 2],\n      result,\n    );\n  }\n\n  return Cartesian2.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    const zh = AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch,\n    );\n    return (\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\n    );\n  }\n\n  return buffer[index + 3];\n};\n\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === TerrainQuantization.BITS12) {\n    return AttributeCompression.decompressTextureCoordinates(\n      buffer[index + 3],\n      cartesian2Scratch,\n    ).x;\n  }\n\n  return buffer[index + 6];\n};\n\nTerrainEncoding.prototype.getOctEncodedNormal = function (\n  buffer,\n  index,\n  result,\n) {\n  index = index * this.stride + this._offsetVertexNormal;\n\n  const temp = buffer[index] / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return Cartesian2.fromElements(x, y, result);\n};\n\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (\n  buffer,\n  index,\n  result,\n) {\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return result;\n};\n\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\n  let vertexStride = 0;\n\n  switch (this.quantization) {\n    case TerrainQuantization.BITS12:\n      vertexStride += 3;\n      break;\n    default:\n      vertexStride += 6;\n  }\n  if (this.hasWebMercatorT) {\n    vertexStride += 1;\n  }\n  if (this.hasVertexNormals) {\n    this._offsetVertexNormal = vertexStride;\n    vertexStride += 1;\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    this._offsetGeodeticSurfaceNormal = vertexStride;\n    vertexStride += 3;\n  }\n\n  this.stride = vertexStride;\n};\n\nconst attributesIndicesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n  geodeticSurfaceNormal: 2,\n};\nconst attributesIndicesBits12 = {\n  compressed0: 0,\n  compressed1: 1,\n  geodeticSurfaceNormal: 2,\n};\n\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  const datatype = ComponentDatatype.FLOAT;\n  const sizeInBytes = ComponentDatatype.getSizeInBytes(datatype);\n  const strideInBytes = this.stride * sizeInBytes;\n  let offsetInBytes = 0;\n\n  const attributes = [];\n  function addAttribute(index, componentsPerAttribute) {\n    attributes.push({\n      index: index,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: componentsPerAttribute,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n    });\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\n  }\n\n  if (this.quantization === TerrainQuantization.NONE) {\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\n\n    let componentsTexCoordAndNormals = 2;\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\n    addAttribute(\n      attributesIndicesNone.textureCoordAndEncodedNormals,\n      componentsTexCoordAndNormals,\n    );\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\n    }\n  } else {\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\n    const usingAttribute0Component4 =\n      this.hasWebMercatorT || this.hasVertexNormals;\n    const usingAttribute1Component1 =\n      this.hasWebMercatorT && this.hasVertexNormals;\n    addAttribute(\n      attributesIndicesBits12.compressed0,\n      usingAttribute0Component4 ? 4 : 3,\n    );\n\n    if (usingAttribute1Component1) {\n      addAttribute(attributesIndicesBits12.compressed1, 1);\n    }\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\n    }\n  }\n\n  return attributes;\n};\n\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === TerrainQuantization.NONE) {\n    return attributesIndicesNone;\n  }\n  return attributesIndicesBits12;\n};\n\nTerrainEncoding.clone = function (encoding, result) {\n  if (!defined(encoding)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = Cartesian3.clone(encoding.center);\n  result.toScaledENU = Matrix4.clone(encoding.toScaledENU);\n  result.fromScaledENU = Matrix4.clone(encoding.fromScaledENU);\n  result.matrix = Matrix4.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n  result.exaggeration = encoding.exaggeration;\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\n\n  result._calculateStrideAndOffsets();\n\n  return result;\n};\nexport default TerrainEncoding;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}