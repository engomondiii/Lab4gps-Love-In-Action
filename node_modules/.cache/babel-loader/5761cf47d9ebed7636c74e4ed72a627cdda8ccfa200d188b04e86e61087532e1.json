{"ast":null,"code":"import binarySearch from \"./binarySearch.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Reports the availability of tiles in a {@link TilingScheme}.\n *\n * @alias TileAvailability\n * @constructor\n *\n * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.\n * @param {number} maximumLevel The maximum tile level that is potentially available.\n */\nfunction TileAvailability(tilingScheme, maximumLevel) {\n  this._tilingScheme = tilingScheme;\n  this._maximumLevel = maximumLevel;\n  this._rootNodes = [];\n}\nconst rectangleScratch = new Rectangle();\nfunction findNode(level, x, y, nodes) {\n  const count = nodes.length;\n  for (let i = 0; i < count; ++i) {\n    const node = nodes[i];\n    if (node.x === x && node.y === y && node.level === level) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n * add your ranges in order of increasing level.\n *\n * @param {number} level The level.\n * @param {number} startX The X coordinate of the first available tiles at the level.\n * @param {number} startY The Y coordinate of the first available tiles at the level.\n * @param {number} endX The X coordinate of the last available tiles at the level.\n * @param {number} endY The Y coordinate of the last available tiles at the level.\n */\nTileAvailability.prototype.addAvailableTileRange = function (level, startX, startY, endX, endY) {\n  const tilingScheme = this._tilingScheme;\n  const rootNodes = this._rootNodes;\n  if (level === 0) {\n    for (let y = startY; y <= endY; ++y) {\n      for (let x = startX; x <= endX; ++x) {\n        if (!findNode(level, x, y, rootNodes)) {\n          rootNodes.push(new QuadtreeNode(tilingScheme, undefined, 0, x, y));\n        }\n      }\n    }\n  }\n  tilingScheme.tileXYToRectangle(startX, startY, level, rectangleScratch);\n  const west = rectangleScratch.west;\n  const north = rectangleScratch.north;\n  tilingScheme.tileXYToRectangle(endX, endY, level, rectangleScratch);\n  const east = rectangleScratch.east;\n  const south = rectangleScratch.south;\n  const rectangleWithLevel = new RectangleWithLevel(level, west, south, east, north);\n  for (let i = 0; i < rootNodes.length; ++i) {\n    const rootNode = rootNodes[i];\n    if (rectanglesOverlap(rootNode.extent, rectangleWithLevel)) {\n      putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n    }\n  }\n};\n\n/**\n * Determines the level of the most detailed tile covering the position.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.\n * @return {number} The level of the most detailed tile covering the position.\n * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.\n */\nTileAvailability.prototype.computeMaximumLevelAtPosition = function (position) {\n  // Find the root node that contains this position.\n  let node;\n  for (let nodeIndex = 0; nodeIndex < this._rootNodes.length; ++nodeIndex) {\n    const rootNode = this._rootNodes[nodeIndex];\n    if (rectangleContainsPosition(rootNode.extent, position)) {\n      node = rootNode;\n      break;\n    }\n  }\n  if (!defined(node)) {\n    return -1;\n  }\n  return findMaxLevelFromNode(undefined, node, position);\n};\nconst rectanglesScratch = [];\nconst remainingToCoverByLevelScratch = [];\nconst westScratch = new Rectangle();\nconst eastScratch = new Rectangle();\n\n/**\n * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed\n * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this\n * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Rectangle} rectangle The rectangle.\n * @return {number} The best available level for the entire rectangle.\n */\nTileAvailability.prototype.computeBestAvailableLevelOverRectangle = function (rectangle) {\n  const rectangles = rectanglesScratch;\n  rectangles.length = 0;\n  if (rectangle.east < rectangle.west) {\n    // Rectangle crosses the IDL, make it two rectangles.\n    rectangles.push(Rectangle.fromRadians(-Math.PI, rectangle.south, rectangle.east, rectangle.north, westScratch));\n    rectangles.push(Rectangle.fromRadians(rectangle.west, rectangle.south, Math.PI, rectangle.north, eastScratch));\n  } else {\n    rectangles.push(rectangle);\n  }\n  const remainingToCoverByLevel = remainingToCoverByLevelScratch;\n  remainingToCoverByLevel.length = 0;\n  let i;\n  for (i = 0; i < this._rootNodes.length; ++i) {\n    updateCoverageWithNode(remainingToCoverByLevel, this._rootNodes[i], rectangles);\n  }\n  for (i = remainingToCoverByLevel.length - 1; i >= 0; --i) {\n    if (defined(remainingToCoverByLevel[i]) && remainingToCoverByLevel[i].length === 0) {\n      return i;\n    }\n  }\n  return 0;\n};\nconst cartographicScratch = new Cartographic();\n\n/**\n * Determines if a particular tile is available.\n * @param {number} level The tile level to check.\n * @param {number} x The X coordinate of the tile to check.\n * @param {number} y The Y coordinate of the tile to check.\n * @return {boolean} True if the tile is available; otherwise, false.\n */\nTileAvailability.prototype.isTileAvailable = function (level, x, y) {\n  // Get the center of the tile and find the maximum level at that position.\n  // Because availability is by tile, if the level is available at that point, it\n  // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n  // then all its parent tiles back to level 0 exist too.  This isn't really enforced\n  // anywhere, but Cesium would never load a tile for which this is not true.\n  const rectangle = this._tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n  Rectangle.center(rectangle, cartographicScratch);\n  return this.computeMaximumLevelAtPosition(cartographicScratch) >= level;\n};\n\n/**\n * Computes a bit mask indicating which of a tile's four children exist.\n * If a child's bit is set, a tile is available for that child.  If it is cleared,\n * the tile is not available.  The bit values are as follows:\n * <table>\n *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n * </table>\n *\n * @param {number} level The level of the parent tile.\n * @param {number} x The X coordinate of the parent tile.\n * @param {number} y The Y coordinate of the parent tile.\n * @return {number} The bit mask indicating child availability.\n */\nTileAvailability.prototype.computeChildMaskForTile = function (level, x, y) {\n  const childLevel = level + 1;\n  if (childLevel >= this._maximumLevel) {\n    return 0;\n  }\n  let mask = 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y + 1) ? 1 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y + 1) ? 2 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y) ? 4 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y) ? 8 : 0;\n  return mask;\n};\nfunction QuadtreeNode(tilingScheme, parent, level, x, y) {\n  this.tilingScheme = tilingScheme;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.extent = tilingScheme.tileXYToRectangle(x, y, level);\n  this.rectangles = [];\n  this._sw = undefined;\n  this._se = undefined;\n  this._nw = undefined;\n  this._ne = undefined;\n}\nObject.defineProperties(QuadtreeNode.prototype, {\n  nw: {\n    get: function () {\n      if (!this._nw) {\n        this._nw = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2);\n      }\n      return this._nw;\n    }\n  },\n  ne: {\n    get: function () {\n      if (!this._ne) {\n        this._ne = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2);\n      }\n      return this._ne;\n    }\n  },\n  sw: {\n    get: function () {\n      if (!this._sw) {\n        this._sw = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2, this.y * 2 + 1);\n      }\n      return this._sw;\n    }\n  },\n  se: {\n    get: function () {\n      if (!this._se) {\n        this._se = new QuadtreeNode(this.tilingScheme, this, this.level + 1, this.x * 2 + 1, this.y * 2 + 1);\n      }\n      return this._se;\n    }\n  }\n});\nfunction RectangleWithLevel(level, west, south, east, north) {\n  this.level = level;\n  this.west = west;\n  this.south = south;\n  this.east = east;\n  this.north = north;\n}\nfunction rectanglesOverlap(rectangle1, rectangle2) {\n  const west = Math.max(rectangle1.west, rectangle2.west);\n  const south = Math.max(rectangle1.south, rectangle2.south);\n  const east = Math.min(rectangle1.east, rectangle2.east);\n  const north = Math.min(rectangle1.north, rectangle2.north);\n  return south < north && west < east;\n}\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n  while (node.level < maxDepth) {\n    if (rectangleFullyContainsRectangle(node.nw.extent, rectangle)) {\n      node = node.nw;\n    } else if (rectangleFullyContainsRectangle(node.ne.extent, rectangle)) {\n      node = node.ne;\n    } else if (rectangleFullyContainsRectangle(node.sw.extent, rectangle)) {\n      node = node.sw;\n    } else if (rectangleFullyContainsRectangle(node.se.extent, rectangle)) {\n      node = node.se;\n    } else {\n      break;\n    }\n  }\n  if (node.rectangles.length === 0 || node.rectangles[node.rectangles.length - 1].level <= rectangle.level) {\n    node.rectangles.push(rectangle);\n  } else {\n    // Maintain ordering by level when inserting.\n    let index = binarySearch(node.rectangles, rectangle.level, rectangleLevelComparator);\n    if (index < 0) {\n      index = ~index;\n    }\n    node.rectangles.splice(index, 0, rectangle);\n  }\n}\nfunction rectangleLevelComparator(a, b) {\n  return a.level - b;\n}\nfunction rectangleFullyContainsRectangle(potentialContainer, rectangleToTest) {\n  return rectangleToTest.west >= potentialContainer.west && rectangleToTest.east <= potentialContainer.east && rectangleToTest.south >= potentialContainer.south && rectangleToTest.north <= potentialContainer.north;\n}\nfunction rectangleContainsPosition(potentialContainer, positionToTest) {\n  return positionToTest.longitude >= potentialContainer.west && positionToTest.longitude <= potentialContainer.east && positionToTest.latitude >= potentialContainer.south && positionToTest.latitude <= potentialContainer.north;\n}\nfunction findMaxLevelFromNode(stopNode, node, position) {\n  let maxLevel = 0;\n\n  // Find the deepest quadtree node containing this point.\n  let found = false;\n  while (!found) {\n    const nw = node._nw && rectangleContainsPosition(node._nw.extent, position);\n    const ne = node._ne && rectangleContainsPosition(node._ne.extent, position);\n    const sw = node._sw && rectangleContainsPosition(node._sw.extent, position);\n    const se = node._se && rectangleContainsPosition(node._se.extent, position);\n\n    // The common scenario is that the point is in only one quadrant and we can simply\n    // iterate down the tree.  But if the point is on a boundary between tiles, it is\n    // in multiple tiles and we need to check all of them, so use recursion.\n    if (nw + ne + sw + se > 1) {\n      if (nw) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._nw, position));\n      }\n      if (ne) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._ne, position));\n      }\n      if (sw) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._sw, position));\n      }\n      if (se) {\n        maxLevel = Math.max(maxLevel, findMaxLevelFromNode(node, node._se, position));\n      }\n      break;\n    } else if (nw) {\n      node = node._nw;\n    } else if (ne) {\n      node = node._ne;\n    } else if (sw) {\n      node = node._sw;\n    } else if (se) {\n      node = node._se;\n    } else {\n      found = true;\n    }\n  }\n\n  // Work up the tree until we find a rectangle that contains this point.\n  while (node !== stopNode) {\n    const rectangles = node.rectangles;\n\n    // Rectangles are sorted by level, lowest first.\n    for (let i = rectangles.length - 1; i >= 0 && rectangles[i].level > maxLevel; --i) {\n      const rectangle = rectangles[i];\n      if (rectangleContainsPosition(rectangle, position)) {\n        maxLevel = rectangle.level;\n      }\n    }\n    node = node.parent;\n  }\n  return maxLevel;\n}\nfunction updateCoverageWithNode(remainingToCoverByLevel, node, rectanglesToCover) {\n  if (!node) {\n    return;\n  }\n  let i;\n  let anyOverlap = false;\n  for (i = 0; i < rectanglesToCover.length; ++i) {\n    anyOverlap = anyOverlap || rectanglesOverlap(node.extent, rectanglesToCover[i]);\n  }\n  if (!anyOverlap) {\n    // This node is not applicable to the rectangle(s).\n    return;\n  }\n  const rectangles = node.rectangles;\n  for (i = 0; i < rectangles.length; ++i) {\n    const rectangle = rectangles[i];\n    if (!remainingToCoverByLevel[rectangle.level]) {\n      remainingToCoverByLevel[rectangle.level] = rectanglesToCover;\n    }\n    remainingToCoverByLevel[rectangle.level] = subtractRectangle(remainingToCoverByLevel[rectangle.level], rectangle);\n  }\n\n  // Update with child nodes.\n  updateCoverageWithNode(remainingToCoverByLevel, node._nw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._ne, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._sw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._se, rectanglesToCover);\n}\nfunction subtractRectangle(rectangleList, rectangleToSubtract) {\n  const result = [];\n  for (let i = 0; i < rectangleList.length; ++i) {\n    const rectangle = rectangleList[i];\n    if (!rectanglesOverlap(rectangle, rectangleToSubtract)) {\n      // Disjoint rectangles.  Original rectangle is unmodified.\n      result.push(rectangle);\n    } else {\n      // rectangleToSubtract partially or completely overlaps rectangle.\n      if (rectangle.west < rectangleToSubtract.west) {\n        result.push(new Rectangle(rectangle.west, rectangle.south, rectangleToSubtract.west, rectangle.north));\n      }\n      if (rectangle.east > rectangleToSubtract.east) {\n        result.push(new Rectangle(rectangleToSubtract.east, rectangle.south, rectangle.east, rectangle.north));\n      }\n      if (rectangle.south < rectangleToSubtract.south) {\n        result.push(new Rectangle(Math.max(rectangleToSubtract.west, rectangle.west), rectangle.south, Math.min(rectangleToSubtract.east, rectangle.east), rectangleToSubtract.south));\n      }\n      if (rectangle.north > rectangleToSubtract.north) {\n        result.push(new Rectangle(Math.max(rectangleToSubtract.west, rectangle.west), rectangleToSubtract.north, Math.min(rectangleToSubtract.east, rectangle.east), rectangle.north));\n      }\n    }\n  }\n  return result;\n}\nexport default TileAvailability;","map":{"version":3,"names":["binarySearch","Cartographic","defined","Rectangle","TileAvailability","tilingScheme","maximumLevel","_tilingScheme","_maximumLevel","_rootNodes","rectangleScratch","findNode","level","x","y","nodes","count","length","i","node","prototype","addAvailableTileRange","startX","startY","endX","endY","rootNodes","push","QuadtreeNode","undefined","tileXYToRectangle","west","north","east","south","rectangleWithLevel","RectangleWithLevel","rootNode","rectanglesOverlap","extent","putRectangleInQuadtree","computeMaximumLevelAtPosition","position","nodeIndex","rectangleContainsPosition","findMaxLevelFromNode","rectanglesScratch","remainingToCoverByLevelScratch","westScratch","eastScratch","computeBestAvailableLevelOverRectangle","rectangle","rectangles","fromRadians","Math","PI","remainingToCoverByLevel","updateCoverageWithNode","cartographicScratch","isTileAvailable","center","computeChildMaskForTile","childLevel","mask","parent","_sw","_se","_nw","_ne","Object","defineProperties","nw","get","ne","sw","se","rectangle1","rectangle2","max","min","maxDepth","rectangleFullyContainsRectangle","index","rectangleLevelComparator","splice","a","b","potentialContainer","rectangleToTest","positionToTest","longitude","latitude","stopNode","maxLevel","found","rectanglesToCover","anyOverlap","subtractRectangle","rectangleList","rectangleToSubtract","result"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/TileAvailability.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Reports the availability of tiles in a {@link TilingScheme}.\n *\n * @alias TileAvailability\n * @constructor\n *\n * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.\n * @param {number} maximumLevel The maximum tile level that is potentially available.\n */\nfunction TileAvailability(tilingScheme, maximumLevel) {\n  this._tilingScheme = tilingScheme;\n  this._maximumLevel = maximumLevel;\n\n  this._rootNodes = [];\n}\n\nconst rectangleScratch = new Rectangle();\n\nfunction findNode(level, x, y, nodes) {\n  const count = nodes.length;\n  for (let i = 0; i < count; ++i) {\n    const node = nodes[i];\n    if (node.x === x && node.y === y && node.level === level) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n * add your ranges in order of increasing level.\n *\n * @param {number} level The level.\n * @param {number} startX The X coordinate of the first available tiles at the level.\n * @param {number} startY The Y coordinate of the first available tiles at the level.\n * @param {number} endX The X coordinate of the last available tiles at the level.\n * @param {number} endY The Y coordinate of the last available tiles at the level.\n */\nTileAvailability.prototype.addAvailableTileRange = function (\n  level,\n  startX,\n  startY,\n  endX,\n  endY,\n) {\n  const tilingScheme = this._tilingScheme;\n\n  const rootNodes = this._rootNodes;\n  if (level === 0) {\n    for (let y = startY; y <= endY; ++y) {\n      for (let x = startX; x <= endX; ++x) {\n        if (!findNode(level, x, y, rootNodes)) {\n          rootNodes.push(new QuadtreeNode(tilingScheme, undefined, 0, x, y));\n        }\n      }\n    }\n  }\n\n  tilingScheme.tileXYToRectangle(startX, startY, level, rectangleScratch);\n  const west = rectangleScratch.west;\n  const north = rectangleScratch.north;\n\n  tilingScheme.tileXYToRectangle(endX, endY, level, rectangleScratch);\n  const east = rectangleScratch.east;\n  const south = rectangleScratch.south;\n\n  const rectangleWithLevel = new RectangleWithLevel(\n    level,\n    west,\n    south,\n    east,\n    north,\n  );\n\n  for (let i = 0; i < rootNodes.length; ++i) {\n    const rootNode = rootNodes[i];\n    if (rectanglesOverlap(rootNode.extent, rectangleWithLevel)) {\n      putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n    }\n  }\n};\n\n/**\n * Determines the level of the most detailed tile covering the position.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.\n * @return {number} The level of the most detailed tile covering the position.\n * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.\n */\nTileAvailability.prototype.computeMaximumLevelAtPosition = function (position) {\n  // Find the root node that contains this position.\n  let node;\n  for (let nodeIndex = 0; nodeIndex < this._rootNodes.length; ++nodeIndex) {\n    const rootNode = this._rootNodes[nodeIndex];\n    if (rectangleContainsPosition(rootNode.extent, position)) {\n      node = rootNode;\n      break;\n    }\n  }\n\n  if (!defined(node)) {\n    return -1;\n  }\n\n  return findMaxLevelFromNode(undefined, node, position);\n};\n\nconst rectanglesScratch = [];\nconst remainingToCoverByLevelScratch = [];\nconst westScratch = new Rectangle();\nconst eastScratch = new Rectangle();\n\n/**\n * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed\n * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this\n * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Rectangle} rectangle The rectangle.\n * @return {number} The best available level for the entire rectangle.\n */\nTileAvailability.prototype.computeBestAvailableLevelOverRectangle = function (\n  rectangle,\n) {\n  const rectangles = rectanglesScratch;\n  rectangles.length = 0;\n\n  if (rectangle.east < rectangle.west) {\n    // Rectangle crosses the IDL, make it two rectangles.\n    rectangles.push(\n      Rectangle.fromRadians(\n        -Math.PI,\n        rectangle.south,\n        rectangle.east,\n        rectangle.north,\n        westScratch,\n      ),\n    );\n    rectangles.push(\n      Rectangle.fromRadians(\n        rectangle.west,\n        rectangle.south,\n        Math.PI,\n        rectangle.north,\n        eastScratch,\n      ),\n    );\n  } else {\n    rectangles.push(rectangle);\n  }\n\n  const remainingToCoverByLevel = remainingToCoverByLevelScratch;\n  remainingToCoverByLevel.length = 0;\n\n  let i;\n  for (i = 0; i < this._rootNodes.length; ++i) {\n    updateCoverageWithNode(\n      remainingToCoverByLevel,\n      this._rootNodes[i],\n      rectangles,\n    );\n  }\n\n  for (i = remainingToCoverByLevel.length - 1; i >= 0; --i) {\n    if (\n      defined(remainingToCoverByLevel[i]) &&\n      remainingToCoverByLevel[i].length === 0\n    ) {\n      return i;\n    }\n  }\n\n  return 0;\n};\n\nconst cartographicScratch = new Cartographic();\n\n/**\n * Determines if a particular tile is available.\n * @param {number} level The tile level to check.\n * @param {number} x The X coordinate of the tile to check.\n * @param {number} y The Y coordinate of the tile to check.\n * @return {boolean} True if the tile is available; otherwise, false.\n */\nTileAvailability.prototype.isTileAvailable = function (level, x, y) {\n  // Get the center of the tile and find the maximum level at that position.\n  // Because availability is by tile, if the level is available at that point, it\n  // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n  // then all its parent tiles back to level 0 exist too.  This isn't really enforced\n  // anywhere, but Cesium would never load a tile for which this is not true.\n  const rectangle = this._tilingScheme.tileXYToRectangle(\n    x,\n    y,\n    level,\n    rectangleScratch,\n  );\n  Rectangle.center(rectangle, cartographicScratch);\n  return this.computeMaximumLevelAtPosition(cartographicScratch) >= level;\n};\n\n/**\n * Computes a bit mask indicating which of a tile's four children exist.\n * If a child's bit is set, a tile is available for that child.  If it is cleared,\n * the tile is not available.  The bit values are as follows:\n * <table>\n *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n * </table>\n *\n * @param {number} level The level of the parent tile.\n * @param {number} x The X coordinate of the parent tile.\n * @param {number} y The Y coordinate of the parent tile.\n * @return {number} The bit mask indicating child availability.\n */\nTileAvailability.prototype.computeChildMaskForTile = function (level, x, y) {\n  const childLevel = level + 1;\n  if (childLevel >= this._maximumLevel) {\n    return 0;\n  }\n\n  let mask = 0;\n\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y + 1) ? 1 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y + 1) ? 2 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y) ? 4 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y) ? 8 : 0;\n\n  return mask;\n};\n\nfunction QuadtreeNode(tilingScheme, parent, level, x, y) {\n  this.tilingScheme = tilingScheme;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.extent = tilingScheme.tileXYToRectangle(x, y, level);\n\n  this.rectangles = [];\n  this._sw = undefined;\n  this._se = undefined;\n  this._nw = undefined;\n  this._ne = undefined;\n}\n\nObject.defineProperties(QuadtreeNode.prototype, {\n  nw: {\n    get: function () {\n      if (!this._nw) {\n        this._nw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2,\n        );\n      }\n      return this._nw;\n    },\n  },\n\n  ne: {\n    get: function () {\n      if (!this._ne) {\n        this._ne = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2,\n        );\n      }\n      return this._ne;\n    },\n  },\n\n  sw: {\n    get: function () {\n      if (!this._sw) {\n        this._sw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2 + 1,\n        );\n      }\n      return this._sw;\n    },\n  },\n\n  se: {\n    get: function () {\n      if (!this._se) {\n        this._se = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2 + 1,\n        );\n      }\n      return this._se;\n    },\n  },\n});\n\nfunction RectangleWithLevel(level, west, south, east, north) {\n  this.level = level;\n  this.west = west;\n  this.south = south;\n  this.east = east;\n  this.north = north;\n}\n\nfunction rectanglesOverlap(rectangle1, rectangle2) {\n  const west = Math.max(rectangle1.west, rectangle2.west);\n  const south = Math.max(rectangle1.south, rectangle2.south);\n  const east = Math.min(rectangle1.east, rectangle2.east);\n  const north = Math.min(rectangle1.north, rectangle2.north);\n  return south < north && west < east;\n}\n\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n  while (node.level < maxDepth) {\n    if (rectangleFullyContainsRectangle(node.nw.extent, rectangle)) {\n      node = node.nw;\n    } else if (rectangleFullyContainsRectangle(node.ne.extent, rectangle)) {\n      node = node.ne;\n    } else if (rectangleFullyContainsRectangle(node.sw.extent, rectangle)) {\n      node = node.sw;\n    } else if (rectangleFullyContainsRectangle(node.se.extent, rectangle)) {\n      node = node.se;\n    } else {\n      break;\n    }\n  }\n\n  if (\n    node.rectangles.length === 0 ||\n    node.rectangles[node.rectangles.length - 1].level <= rectangle.level\n  ) {\n    node.rectangles.push(rectangle);\n  } else {\n    // Maintain ordering by level when inserting.\n    let index = binarySearch(\n      node.rectangles,\n      rectangle.level,\n      rectangleLevelComparator,\n    );\n    if (index < 0) {\n      index = ~index;\n    }\n    node.rectangles.splice(index, 0, rectangle);\n  }\n}\n\nfunction rectangleLevelComparator(a, b) {\n  return a.level - b;\n}\n\nfunction rectangleFullyContainsRectangle(potentialContainer, rectangleToTest) {\n  return (\n    rectangleToTest.west >= potentialContainer.west &&\n    rectangleToTest.east <= potentialContainer.east &&\n    rectangleToTest.south >= potentialContainer.south &&\n    rectangleToTest.north <= potentialContainer.north\n  );\n}\n\nfunction rectangleContainsPosition(potentialContainer, positionToTest) {\n  return (\n    positionToTest.longitude >= potentialContainer.west &&\n    positionToTest.longitude <= potentialContainer.east &&\n    positionToTest.latitude >= potentialContainer.south &&\n    positionToTest.latitude <= potentialContainer.north\n  );\n}\n\nfunction findMaxLevelFromNode(stopNode, node, position) {\n  let maxLevel = 0;\n\n  // Find the deepest quadtree node containing this point.\n  let found = false;\n  while (!found) {\n    const nw = node._nw && rectangleContainsPosition(node._nw.extent, position);\n    const ne = node._ne && rectangleContainsPosition(node._ne.extent, position);\n    const sw = node._sw && rectangleContainsPosition(node._sw.extent, position);\n    const se = node._se && rectangleContainsPosition(node._se.extent, position);\n\n    // The common scenario is that the point is in only one quadrant and we can simply\n    // iterate down the tree.  But if the point is on a boundary between tiles, it is\n    // in multiple tiles and we need to check all of them, so use recursion.\n    if (nw + ne + sw + se > 1) {\n      if (nw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._nw, position),\n        );\n      }\n      if (ne) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._ne, position),\n        );\n      }\n      if (sw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._sw, position),\n        );\n      }\n      if (se) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._se, position),\n        );\n      }\n      break;\n    } else if (nw) {\n      node = node._nw;\n    } else if (ne) {\n      node = node._ne;\n    } else if (sw) {\n      node = node._sw;\n    } else if (se) {\n      node = node._se;\n    } else {\n      found = true;\n    }\n  }\n\n  // Work up the tree until we find a rectangle that contains this point.\n  while (node !== stopNode) {\n    const rectangles = node.rectangles;\n\n    // Rectangles are sorted by level, lowest first.\n    for (\n      let i = rectangles.length - 1;\n      i >= 0 && rectangles[i].level > maxLevel;\n      --i\n    ) {\n      const rectangle = rectangles[i];\n      if (rectangleContainsPosition(rectangle, position)) {\n        maxLevel = rectangle.level;\n      }\n    }\n\n    node = node.parent;\n  }\n\n  return maxLevel;\n}\n\nfunction updateCoverageWithNode(\n  remainingToCoverByLevel,\n  node,\n  rectanglesToCover,\n) {\n  if (!node) {\n    return;\n  }\n\n  let i;\n  let anyOverlap = false;\n  for (i = 0; i < rectanglesToCover.length; ++i) {\n    anyOverlap =\n      anyOverlap || rectanglesOverlap(node.extent, rectanglesToCover[i]);\n  }\n\n  if (!anyOverlap) {\n    // This node is not applicable to the rectangle(s).\n    return;\n  }\n\n  const rectangles = node.rectangles;\n  for (i = 0; i < rectangles.length; ++i) {\n    const rectangle = rectangles[i];\n\n    if (!remainingToCoverByLevel[rectangle.level]) {\n      remainingToCoverByLevel[rectangle.level] = rectanglesToCover;\n    }\n\n    remainingToCoverByLevel[rectangle.level] = subtractRectangle(\n      remainingToCoverByLevel[rectangle.level],\n      rectangle,\n    );\n  }\n\n  // Update with child nodes.\n  updateCoverageWithNode(remainingToCoverByLevel, node._nw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._ne, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._sw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._se, rectanglesToCover);\n}\n\nfunction subtractRectangle(rectangleList, rectangleToSubtract) {\n  const result = [];\n  for (let i = 0; i < rectangleList.length; ++i) {\n    const rectangle = rectangleList[i];\n    if (!rectanglesOverlap(rectangle, rectangleToSubtract)) {\n      // Disjoint rectangles.  Original rectangle is unmodified.\n      result.push(rectangle);\n    } else {\n      // rectangleToSubtract partially or completely overlaps rectangle.\n      if (rectangle.west < rectangleToSubtract.west) {\n        result.push(\n          new Rectangle(\n            rectangle.west,\n            rectangle.south,\n            rectangleToSubtract.west,\n            rectangle.north,\n          ),\n        );\n      }\n      if (rectangle.east > rectangleToSubtract.east) {\n        result.push(\n          new Rectangle(\n            rectangleToSubtract.east,\n            rectangle.south,\n            rectangle.east,\n            rectangle.north,\n          ),\n        );\n      }\n      if (rectangle.south < rectangleToSubtract.south) {\n        result.push(\n          new Rectangle(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangle.south,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangleToSubtract.south,\n          ),\n        );\n      }\n      if (rectangle.north > rectangleToSubtract.north) {\n        result.push(\n          new Rectangle(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangleToSubtract.north,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangle.north,\n          ),\n        );\n      }\n    }\n  }\n\n  return result;\n}\nexport default TileAvailability;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}