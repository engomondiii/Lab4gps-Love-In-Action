{"ast":null,"code":"import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport Cesium3DTileFeatureTable from \"../Cesium3DTileFeatureTable.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport I3dmParser from \"../I3dmParser.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nconst I3dmLoaderState = {\n  NOT_LOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  POST_PROCESSING: 3,\n  READY: 4,\n  FAILED: 5,\n  UNLOADED: 6\n};\nconst Attribute = ModelComponents.Attribute;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Instances = ModelComponents.Instances;\n\n/**\n * Loads an Instanced 3D Model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias I3dmLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.i3dmResource The {@link Resource} containing the i3dm.\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the i3dm contents.\n * @param {number} [options.byteOffset=0] The byte offset to the beginning of the i3dm contents in the array buffer.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.X] The forward-axis of the glTF model.\n * @param {boolean} [options.loadAttributesAsTypedArray=false] Load all attributes as typed arrays instead of GPU buffers. If the attributes are interleaved in the glTF they will be de-interleaved in the typed array.\n * @param {boolean} [options.enablePick=false]  If <code>true</code>, load the positions buffer, any instanced attribute buffers, and index buffer as typed arrays for CPU-enabled picking in WebGL1.\n * @param {boolean} [options.loadIndicesForWireframe=false] Load the index buffer as a typed array so wireframe indices can be created for WebGL1.\n * @param {boolean} [options.loadPrimitiveOutline=true] If true, load outlines from the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time.\n */\nfunction I3dmLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const i3dmResource = options.i3dmResource;\n  const arrayBuffer = options.arrayBuffer;\n  let baseResource = options.baseResource;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n  const releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const incrementallyLoadTextures = defaultValue(options.incrementallyLoadTextures, true);\n  const upAxis = defaultValue(options.upAxis, Axis.Y);\n  const forwardAxis = defaultValue(options.forwardAxis, Axis.X);\n  const loadAttributesAsTypedArray = defaultValue(options.loadAttributesAsTypedArray, false);\n  const loadIndicesForWireframe = defaultValue(options.loadIndicesForWireframe, false);\n  const loadPrimitiveOutline = defaultValue(options.loadPrimitiveOutline, true);\n  const enablePick = defaultValue(options.enablePick, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.i3dmResource\", i3dmResource);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : i3dmResource.clone();\n  this._i3dmResource = i3dmResource;\n  this._baseResource = baseResource;\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._loadPrimitiveOutline = loadPrimitiveOutline;\n  this._enablePick = enablePick;\n  this._state = I3dmLoaderState.NOT_LOADED;\n  this._promise = undefined;\n  this._gltfLoader = undefined;\n\n  // Instanced attributes are initially parsed as typed arrays, but if they\n  // do not need to be further processed (e.g. turned into transform matrices),\n  // it is more efficient to turn them into buffers. The I3dmLoader will own the\n  // resources and store them here.\n  this._buffers = [];\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n  this._batchTable = undefined;\n  this._featureTable = undefined;\n  this._instancesLength = 0;\n}\nif (defined(Object.create)) {\n  I3dmLoader.prototype = Object.create(ResourceLoader.prototype);\n  I3dmLoader.prototype.constructor = I3dmLoader;\n}\nObject.defineProperties(I3dmLoader.prototype, {\n  /**\n   * true if textures are loaded, useful when incrementallyLoadTextures is true\n   *\n   * @memberof  I3dmLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  texturesLoaded: {\n    get: function () {\n      return this._gltfLoader?.texturesLoaded;\n    }\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @default {@link Matrix4.IDENTITY}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    }\n  }\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<I3dmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nI3dmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  // Parse the i3dm into its various sections.\n  const i3dm = I3dmParser.parse(this._arrayBuffer, this._byteOffset);\n  const featureTableJson = i3dm.featureTableJson;\n  const featureTableBinary = i3dm.featureTableBinary;\n  const batchTableJson = i3dm.batchTableJson;\n  const batchTableBinary = i3dm.batchTableBinary;\n  const gltfFormat = i3dm.gltfFormat;\n\n  // Generate the feature table.\n  const featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  this._featureTable = featureTable;\n\n  // Get the number of instances in the i3dm.\n  const instancesLength = featureTable.getGlobalProperty(\"INSTANCES_LENGTH\");\n  featureTable.featuresLength = instancesLength;\n  if (!defined(instancesLength)) {\n    throw new RuntimeError(\"Feature table global property: INSTANCES_LENGTH must be defined\");\n  }\n  this._instancesLength = instancesLength;\n\n  // Get the RTC center, if available, and set the loader's transform.\n  const rtcCenter = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n  if (defined(rtcCenter)) {\n    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));\n  }\n\n  // Save the batch table section to use for StructuralMetadata generation.\n  this._batchTable = {\n    json: batchTableJson,\n    binary: batchTableBinary\n  };\n  const loaderOptions = {\n    upAxis: this._upAxis,\n    forwardAxis: this._forwardAxis,\n    releaseGltfJson: this._releaseGltfJson,\n    incrementallyLoadTextures: this._incrementallyLoadTextures,\n    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,\n    enablePick: this._enablePick,\n    loadIndicesForWireframe: this._loadIndicesForWireframe,\n    loadPrimitiveOutline: this._loadPrimitiveOutline\n  };\n  if (gltfFormat === 0) {\n    let gltfUrl = getStringFromTypedArray(i3dm.gltf);\n\n    // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n    // This removes all white space and null characters from the end of the string.\n    gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, \"\");\n    const gltfResource = this._baseResource.getDerivedResource({\n      url: gltfUrl\n    });\n    loaderOptions.gltfResource = gltfResource;\n    loaderOptions.baseResource = gltfResource;\n  } else {\n    loaderOptions.gltfResource = this._i3dmResource;\n    loaderOptions.typedArray = i3dm.gltf;\n  }\n\n  // Create the GltfLoader, update the state and load the glTF.\n  const gltfLoader = new GltfLoader(loaderOptions);\n  this._gltfLoader = gltfLoader;\n  this._state = I3dmLoaderState.LOADING;\n  this._promise = gltfLoader.load().then(() => {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._state = I3dmLoaderState.PROCESSING;\n    return this;\n  }).catch(error => {\n    if (this.isDestroyed()) {\n      return;\n    }\n    throw handleError(this, error);\n  });\n  return this._promise;\n};\nfunction handleError(i3dmLoader, error) {\n  i3dmLoader.unload();\n  i3dmLoader._state = I3dmLoaderState.FAILED;\n  const errorMessage = \"Failed to load i3dm\";\n  return i3dmLoader.getError(errorMessage, error);\n}\nI3dmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === I3dmLoaderState.READY) {\n    return true;\n  }\n  const gltfLoader = this._gltfLoader;\n  let ready = false;\n  if (this._state === I3dmLoaderState.PROCESSING) {\n    ready = gltfLoader.process(frameState);\n  }\n  if (!ready) {\n    return false;\n  }\n  const components = gltfLoader.components;\n\n  // Combine the RTC_CENTER transform from the i3dm and the CESIUM_RTC\n  // transform from the glTF. In practice CESIUM_RTC is not set for\n  // instanced models but multiply the transforms just in case.\n  components.transform = Matrix4.multiplyTransformation(this._transform, components.transform, components.transform);\n  createInstances(this, components, frameState);\n  createStructuralMetadata(this, components);\n  this._components = components;\n\n  // Now that we have the parsed components, we can release the array buffer\n  this._arrayBuffer = undefined;\n  this._state = I3dmLoaderState.READY;\n  return true;\n};\nfunction createStructuralMetadata(loader, components) {\n  const batchTable = loader._batchTable;\n  const instancesLength = loader._instancesLength;\n  if (instancesLength === 0) {\n    return;\n  }\n  let structuralMetadata;\n  if (defined(batchTable.json)) {\n    // Add the structural metadata from the batch table to the model components.\n    structuralMetadata = parseBatchTable({\n      count: instancesLength,\n      batchTable: batchTable.json,\n      binaryBody: batchTable.binary\n    });\n  } else {\n    // If batch table is not defined, create a property table without any properties.\n    const emptyPropertyTable = new PropertyTable({\n      name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n      count: instancesLength\n    });\n    structuralMetadata = new StructuralMetadata({\n      schema: {},\n      propertyTables: [emptyPropertyTable]\n    });\n  }\n  components.structuralMetadata = structuralMetadata;\n}\nconst positionScratch = new Cartesian3();\nconst propertyScratch1 = new Array(4);\nconst transformScratch = new Matrix4();\nfunction createInstances(loader, components, frameState) {\n  let i;\n  const featureTable = loader._featureTable;\n  const instancesLength = loader._instancesLength;\n  if (instancesLength === 0) {\n    return;\n  }\n  const rtcCenter = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n  const eastNorthUp = featureTable.getGlobalProperty(\"EAST_NORTH_UP\");\n  const hasRotation = featureTable.hasProperty(\"NORMAL_UP\") || featureTable.hasProperty(\"NORMAL_UP_OCT32P\") || eastNorthUp;\n  const hasScale = featureTable.hasProperty(\"SCALE\") || featureTable.hasProperty(\"SCALE_NON_UNIFORM\");\n  const translationTypedArray = getPositions(featureTable, instancesLength);\n  let rotationTypedArray;\n  if (hasRotation) {\n    rotationTypedArray = new Float32Array(4 * instancesLength);\n  }\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = new Float32Array(3 * instancesLength);\n  }\n  const featureIdArray = new Float32Array(instancesLength);\n  const instancePositions = Cartesian3.unpackArray(translationTypedArray);\n  let instancePosition = new Cartesian3();\n  const instanceNormalRight = new Cartesian3();\n  const instanceNormalUp = new Cartesian3();\n  const instanceNormalForward = new Cartesian3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceQuaternionArray = new Array(4);\n  const instanceScale = new Cartesian3();\n  const instanceScaleArray = new Array(3);\n  const instanceTransform = new Matrix4();\n\n  // For I3DMs that do not define an RTC center, we manually compute a BoundingSphere and store\n  // positions relative to the center, to be uploaded to the GPU. This avoids jittering at higher\n  // precisions.\n  // Also manually compute if RTC center equals Cartesian3.ZERO\n  if (!defined(rtcCenter) || Cartesian3.equals(Cartesian3.unpack(rtcCenter), Cartesian3.ZERO)) {\n    const positionBoundingSphere = BoundingSphere.fromPoints(instancePositions);\n    for (i = 0; i < instancePositions.length; i++) {\n      Cartesian3.subtract(instancePositions[i], positionBoundingSphere.center, positionScratch);\n      translationTypedArray[3 * i + 0] = positionScratch.x;\n      translationTypedArray[3 * i + 1] = positionScratch.y;\n      translationTypedArray[3 * i + 2] = positionScratch.z;\n    }\n\n    // Set the center of the bounding sphere as the RTC center transform.\n    const centerTransform = Matrix4.fromTranslation(positionBoundingSphere.center, transformScratch);\n\n    // Combine the center transform and the CESIUM_RTC transform from the glTF.\n    // In practice CESIUM_RTC is not set for instanced models but multiply the\n    // transforms just in case.\n    components.transform = Matrix4.multiplyTransformation(centerTransform, components.transform, components.transform);\n  }\n  for (i = 0; i < instancesLength; i++) {\n    // Get the instance position\n    instancePosition = Cartesian3.clone(instancePositions[i]);\n    if (defined(rtcCenter)) {\n      Cartesian3.add(instancePosition, Cartesian3.unpack(rtcCenter), instancePosition);\n    }\n\n    // Get the instance rotation, if present\n    if (hasRotation) {\n      processRotation(featureTable, eastNorthUp, i, instanceQuaternion, instancePosition, instanceNormalUp, instanceNormalRight, instanceNormalForward, instanceRotation, instanceTransform);\n      Quaternion.pack(instanceQuaternion, instanceQuaternionArray, 0);\n      rotationTypedArray[4 * i + 0] = instanceQuaternionArray[0];\n      rotationTypedArray[4 * i + 1] = instanceQuaternionArray[1];\n      rotationTypedArray[4 * i + 2] = instanceQuaternionArray[2];\n      rotationTypedArray[4 * i + 3] = instanceQuaternionArray[3];\n    }\n\n    // Get the instance scale, if present\n    if (hasScale) {\n      processScale(featureTable, i, instanceScale);\n      Cartesian3.pack(instanceScale, instanceScaleArray, 0);\n      scaleTypedArray[3 * i + 0] = instanceScaleArray[0];\n      scaleTypedArray[3 * i + 1] = instanceScaleArray[1];\n      scaleTypedArray[3 * i + 2] = instanceScaleArray[2];\n    }\n\n    // Get the batchId\n    let batchId = featureTable.getProperty(\"BATCH_ID\", ComponentDatatype.UNSIGNED_SHORT, 1, i);\n    if (!defined(batchId)) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n    featureIdArray[i] = batchId;\n  }\n\n  // Create instances.\n  const instances = new Instances();\n  instances.transformInWorldSpace = true;\n  const buffers = loader._buffers;\n\n  // Create translation vertex attribute.\n  const translationAttribute = new Attribute();\n  translationAttribute.name = \"Instance Translation\";\n  translationAttribute.semantic = InstanceAttributeSemantic.TRANSLATION;\n  translationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  translationAttribute.type = AttributeType.VEC3;\n  translationAttribute.count = instancesLength;\n  // The min / max values of the translation attribute need to be computed\n  // by the model pipeline, so so a pointer to the typed array is stored.\n  translationAttribute.typedArray = translationTypedArray;\n  // If there is no rotation attribute, however, the translations can also be\n  // loaded as a buffer to prevent additional resource creation in the pipeline.\n  if (!hasRotation) {\n    const buffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: translationTypedArray,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    // Destruction of resources is handled by I3dmLoader.unload().\n    buffer.vertexArrayDestroyable = false;\n    buffers.push(buffer);\n    translationAttribute.buffer = buffer;\n  }\n  instances.attributes.push(translationAttribute);\n\n  // Create rotation vertex attribute.\n  if (hasRotation) {\n    const rotationAttribute = new Attribute();\n    rotationAttribute.name = \"Instance Rotation\";\n    rotationAttribute.semantic = InstanceAttributeSemantic.ROTATION;\n    rotationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    rotationAttribute.type = AttributeType.VEC4;\n    rotationAttribute.count = instancesLength;\n    rotationAttribute.typedArray = rotationTypedArray;\n    instances.attributes.push(rotationAttribute);\n  }\n\n  // Create scale vertex attribute.\n  if (hasScale) {\n    const scaleAttribute = new Attribute();\n    scaleAttribute.name = \"Instance Scale\";\n    scaleAttribute.semantic = InstanceAttributeSemantic.SCALE;\n    scaleAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    scaleAttribute.type = AttributeType.VEC3;\n    scaleAttribute.count = instancesLength;\n    if (hasRotation) {\n      // If rotations are present, all transform attributes are loaded\n      // as typed arrays to compute transform matrices for the model.\n      scaleAttribute.typedArray = scaleTypedArray;\n    } else {\n      const buffer = Buffer.createVertexBuffer({\n        context: frameState.context,\n        typedArray: scaleTypedArray,\n        usage: BufferUsage.STATIC_DRAW\n      });\n      // Destruction of resources is handled by I3dmLoader.unload().\n      buffer.vertexArrayDestroyable = false;\n      buffers.push(buffer);\n      scaleAttribute.buffer = buffer;\n    }\n    instances.attributes.push(scaleAttribute);\n  }\n\n  // Create feature ID vertex attribute.\n  const featureIdAttribute = new Attribute();\n  featureIdAttribute.name = \"Instance Feature ID\";\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.semantic = InstanceAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = instancesLength;\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: featureIdArray,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  // Destruction of resources is handled by I3dmLoader.unload().\n  buffer.vertexArrayDestroyable = false;\n  buffers.push(buffer);\n  featureIdAttribute.buffer = buffer;\n  instances.attributes.push(featureIdAttribute);\n\n  // Create feature ID attribute.\n  const featureIdInstanceAttribute = new FeatureIdAttribute();\n  featureIdInstanceAttribute.propertyTableId = 0;\n  featureIdInstanceAttribute.setIndex = 0;\n  featureIdInstanceAttribute.positionalLabel = \"instanceFeatureId_0\";\n  instances.featureIds.push(featureIdInstanceAttribute);\n\n  // Apply instancing to every node that has at least one primitive.\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n  let makeInstancesCopy = false;\n  for (i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (node.primitives.length > 0) {\n      // If the instances have not been assigned to a node already, assign\n      // it to the first node encountered. Otherwise, make a copy of them\n      // for each subsequent node.\n      node.instances = makeInstancesCopy ? createInstancesCopy(instances) : instances;\n      makeInstancesCopy = true;\n    }\n  }\n}\n\n/**\n * Returns a copy of the instances that contains shallow copies of the instanced\n * attributes. That is, the instances and attribute objects will be new copies,\n * but they will point to the same buffers and typed arrays. This is so each\n * node can manage memory separately, such that unloading memory for one\n * node does not unload it for another.\n *\n * @returns {ModelComponents.Instances}\n *\n * @private\n */\nfunction createInstancesCopy(instances) {\n  const instancesCopy = new Instances();\n  instancesCopy.transformInWorldSpace = instances.transformInWorldSpace;\n  const attributes = instances.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attributeCopy = clone(attributes[i], false);\n    instancesCopy.attributes.push(attributeCopy);\n  }\n  instancesCopy.featureIds = instances.featureIds;\n  return instancesCopy;\n}\n\n/**\n * Returns a typed array of positions from the i3dm's feature table. The positions\n * returned are dequantized, if dequantization is applied.\n *\n * @private\n */\nfunction getPositions(featureTable, instancesLength) {\n  if (featureTable.hasProperty(\"POSITION\")) {\n    // Handle positions.\n    return featureTable.getPropertyArray(\"POSITION\", ComponentDatatype.FLOAT, 3);\n  } else if (featureTable.hasProperty(\"POSITION_QUANTIZED\")) {\n    // Handle quantized positions.\n    const quantizedPositions = featureTable.getPropertyArray(\"POSITION_QUANTIZED\", ComponentDatatype.UNSIGNED_SHORT, 3);\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", ComponentDatatype.FLOAT, 3);\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n    }\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", ComponentDatatype.FLOAT, 3);\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n    }\n    const decodedPositions = new Float32Array(quantizedPositions.length);\n    for (let i = 0; i < quantizedPositions.length / 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        const index = 3 * i + j;\n        decodedPositions[index] = quantizedPositions[index] / 65535.0 * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n    return decodedPositions;\n\n    // eslint-disable-next-line no-else-return\n  } else {\n    throw new RuntimeError(\"Either POSITION or POSITION_QUANTIZED must be defined for each instance.\");\n  }\n}\nconst propertyScratch2 = new Array(4);\nfunction processRotation(featureTable, eastNorthUp, i, instanceQuaternion, instancePosition, instanceNormalUp, instanceNormalRight, instanceNormalForward, instanceRotation, instanceTransform) {\n  // Get the instance rotation\n  const normalUp = featureTable.getProperty(\"NORMAL_UP\", ComponentDatatype.FLOAT, 3, i, propertyScratch1);\n  const normalRight = featureTable.getProperty(\"NORMAL_RIGHT\", ComponentDatatype.FLOAT, 3, i, propertyScratch2);\n  let hasCustomOrientation = false;\n  if (defined(normalUp)) {\n    if (!defined(normalRight)) {\n      throw new RuntimeError(\"To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined.\");\n    }\n    Cartesian3.unpack(normalUp, 0, instanceNormalUp);\n    Cartesian3.unpack(normalRight, 0, instanceNormalRight);\n    hasCustomOrientation = true;\n  } else {\n    const octNormalUp = featureTable.getProperty(\"NORMAL_UP_OCT32P\", ComponentDatatype.UNSIGNED_SHORT, 2, i, propertyScratch1);\n    const octNormalRight = featureTable.getProperty(\"NORMAL_RIGHT_OCT32P\", ComponentDatatype.UNSIGNED_SHORT, 2, i, propertyScratch2);\n    if (defined(octNormalUp)) {\n      if (!defined(octNormalRight)) {\n        throw new RuntimeError(\"To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined.\");\n      }\n      AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n      AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n      hasCustomOrientation = true;\n    } else if (eastNorthUp) {\n      Transforms.eastNorthUpToFixedFrame(instancePosition, Ellipsoid.WGS84, instanceTransform);\n      Matrix4.getMatrix3(instanceTransform, instanceRotation);\n    } else {\n      Matrix3.clone(Matrix3.IDENTITY, instanceRotation);\n    }\n  }\n  if (hasCustomOrientation) {\n    Cartesian3.cross(instanceNormalRight, instanceNormalUp, instanceNormalForward);\n    Cartesian3.normalize(instanceNormalForward, instanceNormalForward);\n    Matrix3.setColumn(instanceRotation, 0, instanceNormalRight, instanceRotation);\n    Matrix3.setColumn(instanceRotation, 1, instanceNormalUp, instanceRotation);\n    Matrix3.setColumn(instanceRotation, 2, instanceNormalForward, instanceRotation);\n  }\n  Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);\n}\nfunction processScale(featureTable, i, instanceScale) {\n  instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);\n  const scale = featureTable.getProperty(\"SCALE\", ComponentDatatype.FLOAT, 1, i);\n  if (defined(scale)) {\n    Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);\n  }\n  const nonUniformScale = featureTable.getProperty(\"SCALE_NON_UNIFORM\", ComponentDatatype.FLOAT, 3, i, propertyScratch1);\n  if (defined(nonUniformScale)) {\n    instanceScale.x *= nonUniformScale[0];\n    instanceScale.y *= nonUniformScale[1];\n    instanceScale.z *= nonUniformScale[2];\n  }\n}\nfunction unloadBuffers(loader) {\n  const buffers = loader._buffers;\n  const length = buffers.length;\n  for (let i = 0; i < length; i++) {\n    const buffer = buffers[i];\n    if (!buffer.isDestroyed()) {\n      buffer.destroy();\n    }\n  }\n  buffers.length = 0;\n}\nI3dmLoader.prototype.isUnloaded = function () {\n  return this._state === I3dmLoaderState.UNLOADED;\n};\nI3dmLoader.prototype.unload = function () {\n  if (defined(this._gltfLoader) && !this._gltfLoader.isDestroyed()) {\n    this._gltfLoader.unload();\n  }\n  unloadBuffers(this);\n  this._components = undefined;\n  this._arrayBuffer = undefined;\n  this._state = I3dmLoaderState.UNLOADED;\n};\nexport default I3dmLoader;","map":{"version":3,"names":["AttributeCompression","BoundingSphere","Cartesian3","Check","clone","ComponentDatatype","defaultValue","defined","Ellipsoid","getStringFromTypedArray","Matrix3","Matrix4","Quaternion","RuntimeError","Transforms","Buffer","BufferUsage","AttributeType","Axis","Cesium3DTileFeatureTable","GltfLoader","InstanceAttributeSemantic","I3dmParser","MetadataClass","ModelComponents","parseBatchTable","PropertyTable","ResourceLoader","StructuralMetadata","I3dmLoaderState","NOT_LOADED","LOADING","PROCESSING","POST_PROCESSING","READY","FAILED","UNLOADED","Attribute","FeatureIdAttribute","Instances","I3dmLoader","options","EMPTY_OBJECT","i3dmResource","arrayBuffer","baseResource","byteOffset","releaseGltfJson","asynchronous","incrementallyLoadTextures","upAxis","Y","forwardAxis","X","loadAttributesAsTypedArray","loadIndicesForWireframe","loadPrimitiveOutline","enablePick","typeOf","object","_i3dmResource","_baseResource","_arrayBuffer","_byteOffset","_releaseGltfJson","_asynchronous","_incrementallyLoadTextures","_upAxis","_forwardAxis","_loadAttributesAsTypedArray","_loadIndicesForWireframe","_loadPrimitiveOutline","_enablePick","_state","_promise","undefined","_gltfLoader","_buffers","_components","_transform","IDENTITY","_batchTable","_featureTable","_instancesLength","Object","create","prototype","constructor","defineProperties","texturesLoaded","get","cacheKey","components","load","i3dm","parse","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","gltfFormat","featureTable","instancesLength","getGlobalProperty","featuresLength","rtcCenter","FLOAT","fromTranslation","fromArray","json","binary","loaderOptions","gltfUrl","gltf","replace","gltfResource","getDerivedResource","url","typedArray","gltfLoader","then","isDestroyed","catch","error","handleError","i3dmLoader","unload","errorMessage","getError","process","frameState","ready","transform","multiplyTransformation","createInstances","createStructuralMetadata","loader","batchTable","structuralMetadata","count","binaryBody","emptyPropertyTable","name","BATCH_TABLE_CLASS_NAME","schema","propertyTables","positionScratch","propertyScratch1","Array","transformScratch","i","eastNorthUp","hasRotation","hasProperty","hasScale","translationTypedArray","getPositions","rotationTypedArray","Float32Array","scaleTypedArray","featureIdArray","instancePositions","unpackArray","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceQuaternionArray","instanceScale","instanceScaleArray","instanceTransform","equals","unpack","ZERO","positionBoundingSphere","fromPoints","length","subtract","center","x","y","z","centerTransform","add","processRotation","pack","processScale","batchId","getProperty","UNSIGNED_SHORT","instances","transformInWorldSpace","buffers","translationAttribute","semantic","TRANSLATION","componentDatatype","type","VEC3","buffer","createVertexBuffer","context","usage","STATIC_DRAW","vertexArrayDestroyable","push","attributes","rotationAttribute","ROTATION","VEC4","scaleAttribute","SCALE","featureIdAttribute","setIndex","FEATURE_ID","SCALAR","featureIdInstanceAttribute","propertyTableId","positionalLabel","featureIds","nodes","nodesLength","makeInstancesCopy","node","primitives","createInstancesCopy","instancesCopy","attributesLength","attributeCopy","getPropertyArray","quantizedPositions","quantizedVolumeOffset","quantizedVolumeScale","decodedPositions","j","index","propertyScratch2","normalUp","normalRight","hasCustomOrientation","octNormalUp","octNormalRight","octDecodeInRange","eastNorthUpToFixedFrame","WGS84","getMatrix3","cross","normalize","setColumn","fromRotationMatrix","fromElements","scale","multiplyByScalar","nonUniformScale","unloadBuffers","destroy","isUnloaded"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/I3dmLoader.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport Cesium3DTileFeatureTable from \"../Cesium3DTileFeatureTable.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport I3dmParser from \"../I3dmParser.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\n\nconst I3dmLoaderState = {\n  NOT_LOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  POST_PROCESSING: 3,\n  READY: 4,\n  FAILED: 5,\n  UNLOADED: 6,\n};\n\nconst Attribute = ModelComponents.Attribute;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Instances = ModelComponents.Instances;\n\n/**\n * Loads an Instanced 3D Model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias I3dmLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.i3dmResource The {@link Resource} containing the i3dm.\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the i3dm contents.\n * @param {number} [options.byteOffset=0] The byte offset to the beginning of the i3dm contents in the array buffer.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.X] The forward-axis of the glTF model.\n * @param {boolean} [options.loadAttributesAsTypedArray=false] Load all attributes as typed arrays instead of GPU buffers. If the attributes are interleaved in the glTF they will be de-interleaved in the typed array.\n * @param {boolean} [options.enablePick=false]  If <code>true</code>, load the positions buffer, any instanced attribute buffers, and index buffer as typed arrays for CPU-enabled picking in WebGL1.\n * @param {boolean} [options.loadIndicesForWireframe=false] Load the index buffer as a typed array so wireframe indices can be created for WebGL1.\n * @param {boolean} [options.loadPrimitiveOutline=true] If true, load outlines from the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time.\n */\nfunction I3dmLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const i3dmResource = options.i3dmResource;\n  const arrayBuffer = options.arrayBuffer;\n  let baseResource = options.baseResource;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n  const releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true,\n  );\n  const upAxis = defaultValue(options.upAxis, Axis.Y);\n  const forwardAxis = defaultValue(options.forwardAxis, Axis.X);\n  const loadAttributesAsTypedArray = defaultValue(\n    options.loadAttributesAsTypedArray,\n    false,\n  );\n  const loadIndicesForWireframe = defaultValue(\n    options.loadIndicesForWireframe,\n    false,\n  );\n  const loadPrimitiveOutline = defaultValue(options.loadPrimitiveOutline, true);\n  const enablePick = defaultValue(options.enablePick, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.i3dmResource\", i3dmResource);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : i3dmResource.clone();\n\n  this._i3dmResource = i3dmResource;\n  this._baseResource = baseResource;\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._loadPrimitiveOutline = loadPrimitiveOutline;\n  this._enablePick = enablePick;\n\n  this._state = I3dmLoaderState.NOT_LOADED;\n  this._promise = undefined;\n\n  this._gltfLoader = undefined;\n\n  // Instanced attributes are initially parsed as typed arrays, but if they\n  // do not need to be further processed (e.g. turned into transform matrices),\n  // it is more efficient to turn them into buffers. The I3dmLoader will own the\n  // resources and store them here.\n  this._buffers = [];\n  this._components = undefined;\n\n  this._transform = Matrix4.IDENTITY;\n  this._batchTable = undefined;\n  this._featureTable = undefined;\n  this._instancesLength = 0;\n}\n\nif (defined(Object.create)) {\n  I3dmLoader.prototype = Object.create(ResourceLoader.prototype);\n  I3dmLoader.prototype.constructor = I3dmLoader;\n}\n\nObject.defineProperties(I3dmLoader.prototype, {\n  /**\n   * true if textures are loaded, useful when incrementallyLoadTextures is true\n   *\n   * @memberof  I3dmLoader.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  texturesLoaded: {\n    get: function () {\n      return this._gltfLoader?.texturesLoaded;\n    },\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @default {@link Matrix4.IDENTITY}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<I3dmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nI3dmLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  // Parse the i3dm into its various sections.\n  const i3dm = I3dmParser.parse(this._arrayBuffer, this._byteOffset);\n\n  const featureTableJson = i3dm.featureTableJson;\n  const featureTableBinary = i3dm.featureTableBinary;\n  const batchTableJson = i3dm.batchTableJson;\n  const batchTableBinary = i3dm.batchTableBinary;\n  const gltfFormat = i3dm.gltfFormat;\n\n  // Generate the feature table.\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary,\n  );\n  this._featureTable = featureTable;\n\n  // Get the number of instances in the i3dm.\n  const instancesLength = featureTable.getGlobalProperty(\"INSTANCES_LENGTH\");\n  featureTable.featuresLength = instancesLength;\n  if (!defined(instancesLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: INSTANCES_LENGTH must be defined\",\n    );\n  }\n  this._instancesLength = instancesLength;\n\n  // Get the RTC center, if available, and set the loader's transform.\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n  if (defined(rtcCenter)) {\n    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));\n  }\n\n  // Save the batch table section to use for StructuralMetadata generation.\n  this._batchTable = {\n    json: batchTableJson,\n    binary: batchTableBinary,\n  };\n\n  const loaderOptions = {\n    upAxis: this._upAxis,\n    forwardAxis: this._forwardAxis,\n    releaseGltfJson: this._releaseGltfJson,\n    incrementallyLoadTextures: this._incrementallyLoadTextures,\n    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,\n    enablePick: this._enablePick,\n    loadIndicesForWireframe: this._loadIndicesForWireframe,\n    loadPrimitiveOutline: this._loadPrimitiveOutline,\n  };\n\n  if (gltfFormat === 0) {\n    let gltfUrl = getStringFromTypedArray(i3dm.gltf);\n\n    // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n    // This removes all white space and null characters from the end of the string.\n    gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, \"\");\n    const gltfResource = this._baseResource.getDerivedResource({\n      url: gltfUrl,\n    });\n    loaderOptions.gltfResource = gltfResource;\n    loaderOptions.baseResource = gltfResource;\n  } else {\n    loaderOptions.gltfResource = this._i3dmResource;\n    loaderOptions.typedArray = i3dm.gltf;\n  }\n\n  // Create the GltfLoader, update the state and load the glTF.\n  const gltfLoader = new GltfLoader(loaderOptions);\n\n  this._gltfLoader = gltfLoader;\n  this._state = I3dmLoaderState.LOADING;\n\n  this._promise = gltfLoader\n    .load()\n    .then(() => {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      this._state = I3dmLoaderState.PROCESSING;\n      return this;\n    })\n    .catch((error) => {\n      if (this.isDestroyed()) {\n        return;\n      }\n      throw handleError(this, error);\n    });\n\n  return this._promise;\n};\n\nfunction handleError(i3dmLoader, error) {\n  i3dmLoader.unload();\n  i3dmLoader._state = I3dmLoaderState.FAILED;\n  const errorMessage = \"Failed to load i3dm\";\n  return i3dmLoader.getError(errorMessage, error);\n}\n\nI3dmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === I3dmLoaderState.READY) {\n    return true;\n  }\n\n  const gltfLoader = this._gltfLoader;\n  let ready = false;\n  if (this._state === I3dmLoaderState.PROCESSING) {\n    ready = gltfLoader.process(frameState);\n  }\n\n  if (!ready) {\n    return false;\n  }\n\n  const components = gltfLoader.components;\n\n  // Combine the RTC_CENTER transform from the i3dm and the CESIUM_RTC\n  // transform from the glTF. In practice CESIUM_RTC is not set for\n  // instanced models but multiply the transforms just in case.\n  components.transform = Matrix4.multiplyTransformation(\n    this._transform,\n    components.transform,\n    components.transform,\n  );\n\n  createInstances(this, components, frameState);\n  createStructuralMetadata(this, components);\n  this._components = components;\n\n  // Now that we have the parsed components, we can release the array buffer\n  this._arrayBuffer = undefined;\n\n  this._state = I3dmLoaderState.READY;\n  return true;\n};\n\nfunction createStructuralMetadata(loader, components) {\n  const batchTable = loader._batchTable;\n  const instancesLength = loader._instancesLength;\n\n  if (instancesLength === 0) {\n    return;\n  }\n\n  let structuralMetadata;\n  if (defined(batchTable.json)) {\n    // Add the structural metadata from the batch table to the model components.\n    structuralMetadata = parseBatchTable({\n      count: instancesLength,\n      batchTable: batchTable.json,\n      binaryBody: batchTable.binary,\n    });\n  } else {\n    // If batch table is not defined, create a property table without any properties.\n    const emptyPropertyTable = new PropertyTable({\n      name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n      count: instancesLength,\n    });\n    structuralMetadata = new StructuralMetadata({\n      schema: {},\n      propertyTables: [emptyPropertyTable],\n    });\n  }\n\n  components.structuralMetadata = structuralMetadata;\n}\n\nconst positionScratch = new Cartesian3();\nconst propertyScratch1 = new Array(4);\nconst transformScratch = new Matrix4();\n\nfunction createInstances(loader, components, frameState) {\n  let i;\n  const featureTable = loader._featureTable;\n  const instancesLength = loader._instancesLength;\n\n  if (instancesLength === 0) {\n    return;\n  }\n\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n\n  const eastNorthUp = featureTable.getGlobalProperty(\"EAST_NORTH_UP\");\n  const hasRotation =\n    featureTable.hasProperty(\"NORMAL_UP\") ||\n    featureTable.hasProperty(\"NORMAL_UP_OCT32P\") ||\n    eastNorthUp;\n\n  const hasScale =\n    featureTable.hasProperty(\"SCALE\") ||\n    featureTable.hasProperty(\"SCALE_NON_UNIFORM\");\n\n  const translationTypedArray = getPositions(featureTable, instancesLength);\n  let rotationTypedArray;\n  if (hasRotation) {\n    rotationTypedArray = new Float32Array(4 * instancesLength);\n  }\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = new Float32Array(3 * instancesLength);\n  }\n  const featureIdArray = new Float32Array(instancesLength);\n\n  const instancePositions = Cartesian3.unpackArray(translationTypedArray);\n  let instancePosition = new Cartesian3();\n\n  const instanceNormalRight = new Cartesian3();\n  const instanceNormalUp = new Cartesian3();\n  const instanceNormalForward = new Cartesian3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceQuaternionArray = new Array(4);\n\n  const instanceScale = new Cartesian3();\n  const instanceScaleArray = new Array(3);\n\n  const instanceTransform = new Matrix4();\n\n  // For I3DMs that do not define an RTC center, we manually compute a BoundingSphere and store\n  // positions relative to the center, to be uploaded to the GPU. This avoids jittering at higher\n  // precisions.\n  // Also manually compute if RTC center equals Cartesian3.ZERO\n  if (\n    !defined(rtcCenter) ||\n    Cartesian3.equals(Cartesian3.unpack(rtcCenter), Cartesian3.ZERO)\n  ) {\n    const positionBoundingSphere = BoundingSphere.fromPoints(instancePositions);\n\n    for (i = 0; i < instancePositions.length; i++) {\n      Cartesian3.subtract(\n        instancePositions[i],\n        positionBoundingSphere.center,\n        positionScratch,\n      );\n\n      translationTypedArray[3 * i + 0] = positionScratch.x;\n      translationTypedArray[3 * i + 1] = positionScratch.y;\n      translationTypedArray[3 * i + 2] = positionScratch.z;\n    }\n\n    // Set the center of the bounding sphere as the RTC center transform.\n    const centerTransform = Matrix4.fromTranslation(\n      positionBoundingSphere.center,\n      transformScratch,\n    );\n\n    // Combine the center transform and the CESIUM_RTC transform from the glTF.\n    // In practice CESIUM_RTC is not set for instanced models but multiply the\n    // transforms just in case.\n    components.transform = Matrix4.multiplyTransformation(\n      centerTransform,\n      components.transform,\n      components.transform,\n    );\n  }\n\n  for (i = 0; i < instancesLength; i++) {\n    // Get the instance position\n    instancePosition = Cartesian3.clone(instancePositions[i]);\n\n    if (defined(rtcCenter)) {\n      Cartesian3.add(\n        instancePosition,\n        Cartesian3.unpack(rtcCenter),\n        instancePosition,\n      );\n    }\n\n    // Get the instance rotation, if present\n    if (hasRotation) {\n      processRotation(\n        featureTable,\n        eastNorthUp,\n        i,\n        instanceQuaternion,\n        instancePosition,\n        instanceNormalUp,\n        instanceNormalRight,\n        instanceNormalForward,\n        instanceRotation,\n        instanceTransform,\n      );\n      Quaternion.pack(instanceQuaternion, instanceQuaternionArray, 0);\n      rotationTypedArray[4 * i + 0] = instanceQuaternionArray[0];\n      rotationTypedArray[4 * i + 1] = instanceQuaternionArray[1];\n      rotationTypedArray[4 * i + 2] = instanceQuaternionArray[2];\n      rotationTypedArray[4 * i + 3] = instanceQuaternionArray[3];\n    }\n\n    // Get the instance scale, if present\n    if (hasScale) {\n      processScale(featureTable, i, instanceScale);\n      Cartesian3.pack(instanceScale, instanceScaleArray, 0);\n      scaleTypedArray[3 * i + 0] = instanceScaleArray[0];\n      scaleTypedArray[3 * i + 1] = instanceScaleArray[1];\n      scaleTypedArray[3 * i + 2] = instanceScaleArray[2];\n    }\n\n    // Get the batchId\n    let batchId = featureTable.getProperty(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n      i,\n    );\n    if (!defined(batchId)) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n    featureIdArray[i] = batchId;\n  }\n\n  // Create instances.\n  const instances = new Instances();\n  instances.transformInWorldSpace = true;\n  const buffers = loader._buffers;\n\n  // Create translation vertex attribute.\n  const translationAttribute = new Attribute();\n  translationAttribute.name = \"Instance Translation\";\n  translationAttribute.semantic = InstanceAttributeSemantic.TRANSLATION;\n  translationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  translationAttribute.type = AttributeType.VEC3;\n  translationAttribute.count = instancesLength;\n  // The min / max values of the translation attribute need to be computed\n  // by the model pipeline, so so a pointer to the typed array is stored.\n  translationAttribute.typedArray = translationTypedArray;\n  // If there is no rotation attribute, however, the translations can also be\n  // loaded as a buffer to prevent additional resource creation in the pipeline.\n  if (!hasRotation) {\n    const buffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: translationTypedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    // Destruction of resources is handled by I3dmLoader.unload().\n    buffer.vertexArrayDestroyable = false;\n    buffers.push(buffer);\n\n    translationAttribute.buffer = buffer;\n  }\n\n  instances.attributes.push(translationAttribute);\n\n  // Create rotation vertex attribute.\n  if (hasRotation) {\n    const rotationAttribute = new Attribute();\n    rotationAttribute.name = \"Instance Rotation\";\n    rotationAttribute.semantic = InstanceAttributeSemantic.ROTATION;\n    rotationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    rotationAttribute.type = AttributeType.VEC4;\n    rotationAttribute.count = instancesLength;\n    rotationAttribute.typedArray = rotationTypedArray;\n    instances.attributes.push(rotationAttribute);\n  }\n\n  // Create scale vertex attribute.\n  if (hasScale) {\n    const scaleAttribute = new Attribute();\n    scaleAttribute.name = \"Instance Scale\";\n    scaleAttribute.semantic = InstanceAttributeSemantic.SCALE;\n    scaleAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    scaleAttribute.type = AttributeType.VEC3;\n    scaleAttribute.count = instancesLength;\n    if (hasRotation) {\n      // If rotations are present, all transform attributes are loaded\n      // as typed arrays to compute transform matrices for the model.\n      scaleAttribute.typedArray = scaleTypedArray;\n    } else {\n      const buffer = Buffer.createVertexBuffer({\n        context: frameState.context,\n        typedArray: scaleTypedArray,\n        usage: BufferUsage.STATIC_DRAW,\n      });\n      // Destruction of resources is handled by I3dmLoader.unload().\n      buffer.vertexArrayDestroyable = false;\n      buffers.push(buffer);\n\n      scaleAttribute.buffer = buffer;\n    }\n\n    instances.attributes.push(scaleAttribute);\n  }\n\n  // Create feature ID vertex attribute.\n  const featureIdAttribute = new Attribute();\n  featureIdAttribute.name = \"Instance Feature ID\";\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.semantic = InstanceAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = instancesLength;\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: featureIdArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  // Destruction of resources is handled by I3dmLoader.unload().\n  buffer.vertexArrayDestroyable = false;\n  buffers.push(buffer);\n  featureIdAttribute.buffer = buffer;\n\n  instances.attributes.push(featureIdAttribute);\n\n  // Create feature ID attribute.\n  const featureIdInstanceAttribute = new FeatureIdAttribute();\n  featureIdInstanceAttribute.propertyTableId = 0;\n  featureIdInstanceAttribute.setIndex = 0;\n  featureIdInstanceAttribute.positionalLabel = \"instanceFeatureId_0\";\n  instances.featureIds.push(featureIdInstanceAttribute);\n\n  // Apply instancing to every node that has at least one primitive.\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n  let makeInstancesCopy = false;\n  for (i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (node.primitives.length > 0) {\n      // If the instances have not been assigned to a node already, assign\n      // it to the first node encountered. Otherwise, make a copy of them\n      // for each subsequent node.\n      node.instances = makeInstancesCopy\n        ? createInstancesCopy(instances)\n        : instances;\n\n      makeInstancesCopy = true;\n    }\n  }\n}\n\n/**\n * Returns a copy of the instances that contains shallow copies of the instanced\n * attributes. That is, the instances and attribute objects will be new copies,\n * but they will point to the same buffers and typed arrays. This is so each\n * node can manage memory separately, such that unloading memory for one\n * node does not unload it for another.\n *\n * @returns {ModelComponents.Instances}\n *\n * @private\n */\nfunction createInstancesCopy(instances) {\n  const instancesCopy = new Instances();\n  instancesCopy.transformInWorldSpace = instances.transformInWorldSpace;\n\n  const attributes = instances.attributes;\n  const attributesLength = attributes.length;\n\n  for (let i = 0; i < attributesLength; i++) {\n    const attributeCopy = clone(attributes[i], false);\n    instancesCopy.attributes.push(attributeCopy);\n  }\n\n  instancesCopy.featureIds = instances.featureIds;\n\n  return instancesCopy;\n}\n\n/**\n * Returns a typed array of positions from the i3dm's feature table. The positions\n * returned are dequantized, if dequantization is applied.\n *\n * @private\n */\nfunction getPositions(featureTable, instancesLength) {\n  if (featureTable.hasProperty(\"POSITION\")) {\n    // Handle positions.\n    return featureTable.getPropertyArray(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n  } else if (featureTable.hasProperty(\"POSITION_QUANTIZED\")) {\n    // Handle quantized positions.\n    const quantizedPositions = featureTable.getPropertyArray(\n      \"POSITION_QUANTIZED\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      3,\n    );\n\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_OFFSET\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\",\n      );\n    }\n\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_SCALE\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\",\n      );\n    }\n\n    const decodedPositions = new Float32Array(quantizedPositions.length);\n    for (let i = 0; i < quantizedPositions.length / 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        const index = 3 * i + j;\n        decodedPositions[index] =\n          (quantizedPositions[index] / 65535.0) * quantizedVolumeScale[j] +\n          quantizedVolumeOffset[j];\n      }\n    }\n\n    return decodedPositions;\n\n    // eslint-disable-next-line no-else-return\n  } else {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined for each instance.\",\n    );\n  }\n}\n\nconst propertyScratch2 = new Array(4);\nfunction processRotation(\n  featureTable,\n  eastNorthUp,\n  i,\n  instanceQuaternion,\n  instancePosition,\n  instanceNormalUp,\n  instanceNormalRight,\n  instanceNormalForward,\n  instanceRotation,\n  instanceTransform,\n) {\n  // Get the instance rotation\n  const normalUp = featureTable.getProperty(\n    \"NORMAL_UP\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch1,\n  );\n  const normalRight = featureTable.getProperty(\n    \"NORMAL_RIGHT\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch2,\n  );\n  let hasCustomOrientation = false;\n  if (defined(normalUp)) {\n    if (!defined(normalRight)) {\n      throw new RuntimeError(\n        \"To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined.\",\n      );\n    }\n    Cartesian3.unpack(normalUp, 0, instanceNormalUp);\n    Cartesian3.unpack(normalRight, 0, instanceNormalRight);\n    hasCustomOrientation = true;\n  } else {\n    const octNormalUp = featureTable.getProperty(\n      \"NORMAL_UP_OCT32P\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      2,\n      i,\n      propertyScratch1,\n    );\n    const octNormalRight = featureTable.getProperty(\n      \"NORMAL_RIGHT_OCT32P\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      2,\n      i,\n      propertyScratch2,\n    );\n    if (defined(octNormalUp)) {\n      if (!defined(octNormalRight)) {\n        throw new RuntimeError(\n          \"To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined.\",\n        );\n      }\n      AttributeCompression.octDecodeInRange(\n        octNormalUp[0],\n        octNormalUp[1],\n        65535,\n        instanceNormalUp,\n      );\n      AttributeCompression.octDecodeInRange(\n        octNormalRight[0],\n        octNormalRight[1],\n        65535,\n        instanceNormalRight,\n      );\n      hasCustomOrientation = true;\n    } else if (eastNorthUp) {\n      Transforms.eastNorthUpToFixedFrame(\n        instancePosition,\n        Ellipsoid.WGS84,\n        instanceTransform,\n      );\n      Matrix4.getMatrix3(instanceTransform, instanceRotation);\n    } else {\n      Matrix3.clone(Matrix3.IDENTITY, instanceRotation);\n    }\n  }\n  if (hasCustomOrientation) {\n    Cartesian3.cross(\n      instanceNormalRight,\n      instanceNormalUp,\n      instanceNormalForward,\n    );\n    Cartesian3.normalize(instanceNormalForward, instanceNormalForward);\n    Matrix3.setColumn(\n      instanceRotation,\n      0,\n      instanceNormalRight,\n      instanceRotation,\n    );\n    Matrix3.setColumn(instanceRotation, 1, instanceNormalUp, instanceRotation);\n    Matrix3.setColumn(\n      instanceRotation,\n      2,\n      instanceNormalForward,\n      instanceRotation,\n    );\n  }\n  Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);\n}\n\nfunction processScale(featureTable, i, instanceScale) {\n  instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);\n  const scale = featureTable.getProperty(\n    \"SCALE\",\n    ComponentDatatype.FLOAT,\n    1,\n    i,\n  );\n  if (defined(scale)) {\n    Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);\n  }\n  const nonUniformScale = featureTable.getProperty(\n    \"SCALE_NON_UNIFORM\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch1,\n  );\n  if (defined(nonUniformScale)) {\n    instanceScale.x *= nonUniformScale[0];\n    instanceScale.y *= nonUniformScale[1];\n    instanceScale.z *= nonUniformScale[2];\n  }\n}\n\nfunction unloadBuffers(loader) {\n  const buffers = loader._buffers;\n  const length = buffers.length;\n  for (let i = 0; i < length; i++) {\n    const buffer = buffers[i];\n    if (!buffer.isDestroyed()) {\n      buffer.destroy();\n    }\n  }\n  buffers.length = 0;\n}\n\nI3dmLoader.prototype.isUnloaded = function () {\n  return this._state === I3dmLoaderState.UNLOADED;\n};\n\nI3dmLoader.prototype.unload = function () {\n  if (defined(this._gltfLoader) && !this._gltfLoader.isDestroyed()) {\n    this._gltfLoader.unload();\n  }\n\n  unloadBuffers(this);\n\n  this._components = undefined;\n  this._arrayBuffer = undefined;\n  this._state = I3dmLoaderState.UNLOADED;\n};\n\nexport default I3dmLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}