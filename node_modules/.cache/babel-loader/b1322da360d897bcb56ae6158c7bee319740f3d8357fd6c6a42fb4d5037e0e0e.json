{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Handles parsing of a Batched 3D Model.\n *\n * @namespace B3dmParser\n * @private\n */\nconst B3dmParser = {};\nB3dmParser._deprecationWarning = deprecationWarning;\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}.\n *\n * @private\n *\n * @param {ArrayBuffer} arrayBuffer The array buffer containing the b3dm.\n * @param {number} [byteOffset=0] The byte offset of the beginning of the b3dm in the array buffer.\n * @returns {object} Returns an object with the batch length, feature table (binary and json), batch table (binary and json) and glTF parts of the b3dm.\n */\nB3dmParser.parse = function (arrayBuffer, byteOffset) {\n  const byteStart = defaultValue(byteOffset, 0);\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  byteOffset = byteStart;\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(`Only Batched 3D Model version 1 is supported.  Version ${version} is not.`);\n  }\n  byteOffset += sizeOfUint32;\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  let batchLength;\n\n  // Legacy header #1: [batchLength] [batchTableByteLength]\n  // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]\n  // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n  // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.\n  // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.\n  // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead\n  if (batchTableJsonByteLength >= 570425344) {\n    // First legacy check\n    byteOffset -= sizeOfUint32 * 2;\n    batchLength = featureTableJsonByteLength;\n    batchTableJsonByteLength = featureTableBinaryByteLength;\n    batchTableBinaryByteLength = 0;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    B3dmParser._deprecationWarning(\"b3dm-legacy-header\", \"This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.\");\n  } else if (batchTableBinaryByteLength >= 570425344) {\n    // Second legacy check\n    byteOffset -= sizeOfUint32;\n    batchLength = batchTableJsonByteLength;\n    batchTableJsonByteLength = featureTableJsonByteLength;\n    batchTableBinaryByteLength = featureTableBinaryByteLength;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    B3dmParser._deprecationWarning(\"b3dm-legacy-header\", \"This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.\");\n  }\n  let featureTableJson;\n  if (featureTableJsonByteLength === 0) {\n    featureTableJson = {\n      BATCH_LENGTH: defaultValue(batchLength, 0)\n    };\n  } else {\n    featureTableJson = getJsonFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);\n    byteOffset += featureTableJsonByteLength;\n  }\n  const featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);\n    byteOffset += batchTableJsonByteLength;\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n  const gltfByteLength = byteStart + byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new RuntimeError(\"glTF byte length must be greater than 0.\");\n  }\n  let gltfView;\n  if (byteOffset % 4 === 0) {\n    gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    B3dmParser._deprecationWarning(\"b3dm-glb-unaligned\", \"The embedded glb is not aligned to a 4-byte boundary.\");\n    gltfView = new Uint8Array(uint8Array.subarray(byteOffset, byteOffset + gltfByteLength));\n  }\n  return {\n    batchLength: batchLength,\n    featureTableJson: featureTableJson,\n    featureTableBinary: featureTableBinary,\n    batchTableJson: batchTableJson,\n    batchTableBinary: batchTableBinary,\n    gltf: gltfView\n  };\n};\nexport default B3dmParser;","map":{"version":3,"names":["Check","defaultValue","deprecationWarning","getJsonFromTypedArray","RuntimeError","B3dmParser","_deprecationWarning","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","parse","arrayBuffer","byteOffset","byteStart","defined","uint8Array","Uint8Array","view","DataView","version","getUint32","byteLength","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","batchLength","featureTableJson","BATCH_LENGTH","featureTableBinary","batchTableJson","batchTableBinary","gltfByteLength","gltfView","subarray","gltf"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/B3dmParser.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Handles parsing of a Batched 3D Model.\n *\n * @namespace B3dmParser\n * @private\n */\nconst B3dmParser = {};\nB3dmParser._deprecationWarning = deprecationWarning;\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}.\n *\n * @private\n *\n * @param {ArrayBuffer} arrayBuffer The array buffer containing the b3dm.\n * @param {number} [byteOffset=0] The byte offset of the beginning of the b3dm in the array buffer.\n * @returns {object} Returns an object with the batch length, feature table (binary and json), batch table (binary and json) and glTF parts of the b3dm.\n */\nB3dmParser.parse = function (arrayBuffer, byteOffset) {\n  const byteStart = defaultValue(byteOffset, 0);\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  byteOffset = byteStart;\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Batched 3D Model version 1 is supported.  Version ${version} is not.`,\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let batchLength;\n\n  // Legacy header #1: [batchLength] [batchTableByteLength]\n  // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]\n  // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n  // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.\n  // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.\n  // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead\n  if (batchTableJsonByteLength >= 570425344) {\n    // First legacy check\n    byteOffset -= sizeOfUint32 * 2;\n    batchLength = featureTableJsonByteLength;\n    batchTableJsonByteLength = featureTableBinaryByteLength;\n    batchTableBinaryByteLength = 0;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    B3dmParser._deprecationWarning(\n      \"b3dm-legacy-header\",\n      \"This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.\",\n    );\n  } else if (batchTableBinaryByteLength >= 570425344) {\n    // Second legacy check\n    byteOffset -= sizeOfUint32;\n    batchLength = batchTableJsonByteLength;\n    batchTableJsonByteLength = featureTableJsonByteLength;\n    batchTableBinaryByteLength = featureTableBinaryByteLength;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    B3dmParser._deprecationWarning(\n      \"b3dm-legacy-header\",\n      \"This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.\",\n    );\n  }\n\n  let featureTableJson;\n  if (featureTableJsonByteLength === 0) {\n    featureTableJson = {\n      BATCH_LENGTH: defaultValue(batchLength, 0),\n    };\n  } else {\n    featureTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      featureTableJsonByteLength,\n    );\n    byteOffset += featureTableJsonByteLength;\n  }\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength,\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength,\n    );\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength,\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const gltfByteLength = byteStart + byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new RuntimeError(\"glTF byte length must be greater than 0.\");\n  }\n\n  let gltfView;\n  if (byteOffset % 4 === 0) {\n    gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    B3dmParser._deprecationWarning(\n      \"b3dm-glb-unaligned\",\n      \"The embedded glb is not aligned to a 4-byte boundary.\",\n    );\n    gltfView = new Uint8Array(\n      uint8Array.subarray(byteOffset, byteOffset + gltfByteLength),\n    );\n  }\n\n  return {\n    batchLength: batchLength,\n    featureTableJson: featureTableJson,\n    featureTableBinary: featureTableBinary,\n    batchTableJson: batchTableJson,\n    batchTableBinary: batchTableBinary,\n    gltf: gltfView,\n  };\n};\n\nexport default B3dmParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}