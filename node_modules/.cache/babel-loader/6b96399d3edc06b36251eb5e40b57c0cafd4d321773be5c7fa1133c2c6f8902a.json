{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromArray\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.fromRotation\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix2s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix2[]} array The array of matrices to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {number[]} The packed array.\n */\nMatrix2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 4 elements\");\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n  for (let i = 0; i < length; ++i) {\n    Matrix2.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Matrix2[]} [result] The array onto which to store the result.\n * @returns {Matrix2[]} The unpacked array.\n */\nMatrix2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Matrix2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @function\n * @param {number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * const v = [1.0, 1.0, 2.0, 2.0];\n * const m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = Matrix2.unpack;\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * const m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * const p = new Cesium.Cartesian2(5, 6);\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {number[]} [result] The Array onto which to store the result.\n * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {number} row The zero-based index of the row.\n * @param {number} column The zero-based index of the column.\n * @returns {number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * const myMatrix = new Cesium.Matrix2();\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 2;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  const startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 2];\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\nconst scaleScratch1 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Cartesian2} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n  return result;\n};\nconst scaleScratch2 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n  return result;\n};\nconst scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn));\n  result.y = Cartesian2.magnitude(Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn));\n  return result;\n};\nconst scaleScratch3 = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scaleScratch3);\n  return Cartesian2.maximumComponent(scaleScratch3);\n};\nconst scaleScratch4 = new Cartesian2();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} rotation The rotation matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.fromRotation\n * @see Matrix2.getRotation\n */\nMatrix2.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch4);\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.y;\n  result[3] = rotation[3] * scale.y;\n  return result;\n};\nconst scaleScratch5 = new Cartesian2();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setRotation\n * @see Matrix2.fromRotation\n */\nMatrix2.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch5);\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.y;\n  result[3] = matrix[3] / scale.y;\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = left[0] * right[0] + left[2] * right[1];\n  const column1Row0 = left[0] * right[2] + left[2] * right[3];\n  const column0Row1 = left[1] * right[0] + left[3] * right[1];\n  const column1Row1 = left[1] * right[2] + left[3] * right[3];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {number} scale The uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[2];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[3];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3];\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3];\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon;\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    }\n  }\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return `(${this[0]}, ${this[2]})\\n` + `(${this[1]}, ${this[3]})`;\n};\nexport default Matrix2;","map":{"version":3,"names":["Cartesian2","Check","defaultValue","defined","DeveloperError","Matrix2","column0Row0","column1Row0","column0Row1","column1Row1","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","clone","matrix","undefined","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromScale","scale","x","y","fromUniformScale","fromRotation","angle","cosAngle","Math","cos","sinAngle","sin","toArray","getElementIndex","column","row","lessThanOrEquals","getColumn","startIndex","setColumn","cartesian","getRow","setRow","scaleScratch1","setScale","existingScale","getScale","scaleRatioX","scaleRatioY","scaleScratch2","setUniformScale","scratchColumn","magnitude","fromElements","scaleScratch3","getMaximumScale","maximumComponent","scaleScratch4","setRotation","rotation","scaleScratch5","getRotation","multiply","left","right","add","subtract","multiplyByVector","multiplyByScalar","scalar","multiplyByScale","multiplyByUniformScale","negate","transpose","abs","equals","equalsArray","offset","equalsEpsilon","epsilon","IDENTITY","Object","freeze","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN1ROW0","COLUMN1ROW1","defineProperties","prototype","get","toString"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Matrix2.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromArray\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.fromRotation\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix2s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix2[]} array The array of matrices to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {number[]} The packed array.\n */\nMatrix2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix2.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Matrix2[]} [result] The array onto which to store the result.\n * @returns {Matrix2[]} The unpacked array.\n */\nMatrix2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Matrix2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @function\n * @param {number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * const v = [1.0, 1.0, 2.0, 2.0];\n * const m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = Matrix2.unpack;\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * const m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * const p = new Cesium.Cartesian2(5, 6);\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {number[]} [result] The Array onto which to store the result.\n * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {number} row The zero-based index of the row.\n * @param {number} column The zero-based index of the column.\n * @returns {number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * const myMatrix = new Cesium.Matrix2();\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 2;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  const startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 2];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Cartesian2} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn),\n  );\n  result.y = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn),\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scaleScratch3);\n  return Cartesian2.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian2();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} rotation The rotation matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.fromRotation\n * @see Matrix2.getRotation\n */\nMatrix2.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.y;\n  result[3] = rotation[3] * scale.y;\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian2();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setRotation\n * @see Matrix2.fromRotation\n */\nMatrix2.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.y;\n  result[3] = matrix[3] / scale.y;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = left[0] * right[0] + left[2] * right[1];\n  const column1Row0 = left[0] * right[2] + left[2] * right[3];\n  const column0Row1 = left[1] * right[0] + left[3] * right[1];\n  const column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {number} scale The uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[2];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3])\n  );\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\n\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return `(${this[0]}, ${this[2]})\\n` + `(${this[1]}, ${this[3]})`;\n};\nexport default Matrix2;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}