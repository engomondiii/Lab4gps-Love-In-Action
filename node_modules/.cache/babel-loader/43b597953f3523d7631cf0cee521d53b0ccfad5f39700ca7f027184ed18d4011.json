{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport RectangleCollisionChecker from \"../Core/RectangleCollisionChecker.js\";\nconst colorScratch = new Color();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\nfunction Batch(primitives, classificationType, color, zIndex) {\n  this.primitives = primitives;\n  this.zIndex = zIndex;\n  this.classificationType = classificationType;\n  this.color = color;\n  this.createPrimitive = false;\n  this.waitingOnCreate = false;\n  this.primitive = undefined;\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.updaters = new AssociativeArray();\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.itemsToRemove = [];\n  this.isDirty = false;\n  this.rectangleCollisionCheck = new RectangleCollisionChecker();\n}\nBatch.prototype.overlapping = function (rectangle) {\n  return this.rectangleCollisionCheck.collides(rectangle);\n};\nBatch.prototype.add = function (updater, instance) {\n  const id = updater.id;\n  this.createPrimitive = true;\n  this.geometry.set(id, instance);\n  this.updaters.set(id, updater);\n  this.rectangleCollisionCheck.insert(id, instance.geometry.rectangle);\n  if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function (entity, propertyName, newValue, oldValue) {\n      if (propertyName === \"isShowing\") {\n        that.showsUpdated.set(updater.id, updater);\n      }\n    }));\n  }\n};\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  const geometryInstance = this.geometry.get(id);\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n      this.showsUpdated.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  const removedCount = 0;\n  let primitive = this.primitive;\n  const primitives = this.primitives;\n  let i;\n  if (this.createPrimitive) {\n    const geometries = this.geometry.values;\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          primitives.remove(primitive);\n        }\n      }\n      primitive = new GroundPrimitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        classificationType: this.classificationType\n      });\n      primitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n    this.waitingOnCreate = true;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    const waitingOnCreate = this.waitingOnCreate;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const instance = this.geometry.get(updater.id);\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n      if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n        const colorProperty = updater.fillMaterialProperty.color;\n        const fillColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n        if (!Color.equals(attributes._lastColor, fillColor)) {\n          attributes._lastColor = Color.clone(fillColor, attributes._lastColor);\n          attributes.color = ColorGeometryInstanceAttribute.toValue(fillColor, attributes.color);\n        }\n      }\n      const show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      }\n      const distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n        if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n          attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n          attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n        }\n      }\n    }\n    this.updateShows(primitive);\n    this.waitingOnCreate = false;\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  this.itemsToRemove.length = removedCount;\n  return isUpdated;\n};\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const instance = this.geometry.get(updater.id);\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n    const show = updater.entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const bs = primitive.getBoundingSphere(updater.entity);\n  if (!defined(bs)) {\n    return BoundingSphereState.FAILED;\n  }\n  bs.clone(result);\n  return BoundingSphereState.DONE;\n};\nBatch.prototype.removeAllPrimitives = function () {\n  const primitives = this.primitives;\n  const primitive = this.primitive;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n    this.primitive = undefined;\n    this.geometry.removeAll();\n    this.updaters.removeAll();\n  }\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n    this.oldPrimitive = undefined;\n  }\n};\n\n/**\n * @private\n */\nfunction StaticGroundGeometryColorBatch(primitives, classificationType) {\n  this._batches = [];\n  this._primitives = primitives;\n  this._classificationType = classificationType;\n}\nStaticGroundGeometryColorBatch.prototype.add = function (time, updater) {\n  const instance = updater.createFillGeometryInstance(time);\n  const batches = this._batches;\n  const zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  let batch;\n  const length = batches.length;\n  for (let i = 0; i < length; ++i) {\n    const item = batches[i];\n    if (item.zIndex === zIndex && !item.overlapping(instance.geometry.rectangle)) {\n      batch = item;\n      break;\n    }\n  }\n  if (!defined(batch)) {\n    batch = new Batch(this._primitives, this._classificationType, instance.attributes.color.value, zIndex);\n    batches.push(batch);\n  }\n  batch.add(updater, instance);\n  return batch;\n};\nStaticGroundGeometryColorBatch.prototype.remove = function (updater) {\n  const batches = this._batches;\n  const count = batches.length;\n  for (let i = 0; i < count; ++i) {\n    if (batches[i].remove(updater)) {\n      return;\n    }\n  }\n};\nStaticGroundGeometryColorBatch.prototype.update = function (time) {\n  let i;\n  let updater;\n\n  //Perform initial update\n  let isUpdated = true;\n  const batches = this._batches;\n  const batchCount = batches.length;\n  for (i = 0; i < batchCount; ++i) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  //If any items swapped between batches we need to move them\n  for (i = 0; i < batchCount; ++i) {\n    const oldBatch = batches[i];\n    const itemsToRemove = oldBatch.itemsToRemove;\n    const itemsToMoveLength = itemsToRemove.length;\n    for (let j = 0; j < itemsToMoveLength; j++) {\n      updater = itemsToRemove[j];\n      oldBatch.remove(updater);\n      const newBatch = this.add(time, updater);\n      oldBatch.isDirty = true;\n      newBatch.isDirty = true;\n    }\n  }\n\n  //If we moved anything around, we need to re-build the primitive and remove empty batches\n  for (i = batchCount - 1; i >= 0; --i) {\n    const batch = batches[i];\n    if (batch.isDirty) {\n      isUpdated = batches[i].update(time) && isUpdated;\n      batch.isDirty = false;\n    }\n    if (batch.geometry.length === 0) {\n      batches.splice(i, 1);\n    }\n  }\n  return isUpdated;\n};\nStaticGroundGeometryColorBatch.prototype.getBoundingSphere = function (updater, result) {\n  const batches = this._batches;\n  const batchCount = batches.length;\n  for (let i = 0; i < batchCount; ++i) {\n    const batch = batches[i];\n    if (batch.contains(updater)) {\n      return batch.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\nStaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function () {\n  const batches = this._batches;\n  const batchCount = batches.length;\n  for (let i = 0; i < batchCount; ++i) {\n    batches[i].removeAllPrimitives();\n  }\n};\nexport default StaticGroundGeometryColorBatch;","map":{"version":3,"names":["AssociativeArray","Color","ColorGeometryInstanceAttribute","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","ShowGeometryInstanceAttribute","GroundPrimitive","BoundingSphereState","Property","RectangleCollisionChecker","colorScratch","distanceDisplayConditionScratch","defaultDistanceDisplayCondition","Batch","primitives","classificationType","color","zIndex","createPrimitive","waitingOnCreate","primitive","undefined","oldPrimitive","geometry","updaters","updatersWithAttributes","attributes","subscriptions","showsUpdated","itemsToRemove","isDirty","rectangleCollisionCheck","prototype","overlapping","rectangle","collides","add","updater","instance","id","set","insert","hasConstantFill","fillMaterialProperty","isConstant","distanceDisplayConditionProperty","that","entity","definitionChanged","addEventListener","propertyName","newValue","oldValue","remove","geometryInstance","get","unsubscribe","update","time","isUpdated","removedCount","i","geometries","values","geometriesLength","length","show","asynchronous","geometryInstances","slice","removeAll","ready","getGeometryInstanceAttributes","colorProperty","fillColor","getValueOrDefault","WHITE","equals","_lastColor","clone","toValue","isShowing","isFilled","currentShow","distanceDisplayCondition","_lastDistanceDisplayCondition","updateShows","value","contains","getBoundingSphere","result","PENDING","bs","FAILED","DONE","removeAllPrimitives","StaticGroundGeometryColorBatch","_batches","_primitives","_classificationType","createFillGeometryInstance","batches","batch","item","push","count","batchCount","oldBatch","itemsToMoveLength","j","newBatch","splice"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/StaticGroundGeometryColorBatch.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport RectangleCollisionChecker from \"../Core/RectangleCollisionChecker.js\";\n\nconst colorScratch = new Color();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\nfunction Batch(primitives, classificationType, color, zIndex) {\n  this.primitives = primitives;\n  this.zIndex = zIndex;\n  this.classificationType = classificationType;\n  this.color = color;\n  this.createPrimitive = false;\n  this.waitingOnCreate = false;\n  this.primitive = undefined;\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.updaters = new AssociativeArray();\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.itemsToRemove = [];\n  this.isDirty = false;\n  this.rectangleCollisionCheck = new RectangleCollisionChecker();\n}\n\nBatch.prototype.overlapping = function (rectangle) {\n  return this.rectangleCollisionCheck.collides(rectangle);\n};\n\nBatch.prototype.add = function (updater, instance) {\n  const id = updater.id;\n  this.createPrimitive = true;\n  this.geometry.set(id, instance);\n  this.updaters.set(id, updater);\n  this.rectangleCollisionCheck.insert(id, instance.geometry.rectangle);\n  if (\n    !updater.hasConstantFill ||\n    !updater.fillMaterialProperty.isConstant ||\n    !Property.isConstant(updater.distanceDisplayConditionProperty)\n  ) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    this.subscriptions.set(\n      id,\n      updater.entity.definitionChanged.addEventListener(\n        function (entity, propertyName, newValue, oldValue) {\n          if (propertyName === \"isShowing\") {\n            that.showsUpdated.set(updater.id, updater);\n          }\n        },\n      ),\n    );\n  }\n};\n\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  const geometryInstance = this.geometry.get(id);\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.rectangleCollisionCheck.remove(\n      id,\n      geometryInstance.geometry.rectangle,\n    );\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n      this.showsUpdated.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\n\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  const removedCount = 0;\n  let primitive = this.primitive;\n  const primitives = this.primitives;\n  let i;\n\n  if (this.createPrimitive) {\n    const geometries = this.geometry.values;\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          primitives.remove(primitive);\n        }\n      }\n\n      primitive = new GroundPrimitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        classificationType: this.classificationType,\n      });\n      primitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n    this.waitingOnCreate = true;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    const waitingOnCreate = this.waitingOnCreate;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const instance = this.geometry.get(updater.id);\n\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n\n      if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n        const colorProperty = updater.fillMaterialProperty.color;\n        const fillColor = Property.getValueOrDefault(\n          colorProperty,\n          time,\n          Color.WHITE,\n          colorScratch,\n        );\n\n        if (!Color.equals(attributes._lastColor, fillColor)) {\n          attributes._lastColor = Color.clone(fillColor, attributes._lastColor);\n          attributes.color = ColorGeometryInstanceAttribute.toValue(\n            fillColor,\n            attributes.color,\n          );\n        }\n      }\n\n      const show =\n        updater.entity.isShowing &&\n        (updater.hasConstantFill || updater.isFilled(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(\n          show,\n          attributes.show,\n        );\n      }\n\n      const distanceDisplayConditionProperty =\n        updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(\n          distanceDisplayConditionProperty,\n          time,\n          defaultDistanceDisplayCondition,\n          distanceDisplayConditionScratch,\n        );\n        if (\n          !DistanceDisplayCondition.equals(\n            distanceDisplayCondition,\n            attributes._lastDistanceDisplayCondition,\n          )\n        ) {\n          attributes._lastDistanceDisplayCondition =\n            DistanceDisplayCondition.clone(\n              distanceDisplayCondition,\n              attributes._lastDistanceDisplayCondition,\n            );\n          attributes.distanceDisplayCondition =\n            DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n              distanceDisplayCondition,\n              attributes.distanceDisplayCondition,\n            );\n        }\n      }\n    }\n\n    this.updateShows(primitive);\n    this.waitingOnCreate = false;\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  this.itemsToRemove.length = removedCount;\n  return isUpdated;\n};\n\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const instance = this.geometry.get(updater.id);\n\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n\n    const show = updater.entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        show,\n        attributes.show,\n      );\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\n\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\n\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n\n  const bs = primitive.getBoundingSphere(updater.entity);\n  if (!defined(bs)) {\n    return BoundingSphereState.FAILED;\n  }\n\n  bs.clone(result);\n  return BoundingSphereState.DONE;\n};\n\nBatch.prototype.removeAllPrimitives = function () {\n  const primitives = this.primitives;\n\n  const primitive = this.primitive;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n    this.primitive = undefined;\n    this.geometry.removeAll();\n    this.updaters.removeAll();\n  }\n\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n    this.oldPrimitive = undefined;\n  }\n};\n\n/**\n * @private\n */\nfunction StaticGroundGeometryColorBatch(primitives, classificationType) {\n  this._batches = [];\n  this._primitives = primitives;\n  this._classificationType = classificationType;\n}\n\nStaticGroundGeometryColorBatch.prototype.add = function (time, updater) {\n  const instance = updater.createFillGeometryInstance(time);\n  const batches = this._batches;\n  const zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  let batch;\n  const length = batches.length;\n  for (let i = 0; i < length; ++i) {\n    const item = batches[i];\n    if (\n      item.zIndex === zIndex &&\n      !item.overlapping(instance.geometry.rectangle)\n    ) {\n      batch = item;\n      break;\n    }\n  }\n\n  if (!defined(batch)) {\n    batch = new Batch(\n      this._primitives,\n      this._classificationType,\n      instance.attributes.color.value,\n      zIndex,\n    );\n    batches.push(batch);\n  }\n  batch.add(updater, instance);\n  return batch;\n};\n\nStaticGroundGeometryColorBatch.prototype.remove = function (updater) {\n  const batches = this._batches;\n  const count = batches.length;\n  for (let i = 0; i < count; ++i) {\n    if (batches[i].remove(updater)) {\n      return;\n    }\n  }\n};\n\nStaticGroundGeometryColorBatch.prototype.update = function (time) {\n  let i;\n  let updater;\n\n  //Perform initial update\n  let isUpdated = true;\n  const batches = this._batches;\n  const batchCount = batches.length;\n  for (i = 0; i < batchCount; ++i) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  //If any items swapped between batches we need to move them\n  for (i = 0; i < batchCount; ++i) {\n    const oldBatch = batches[i];\n    const itemsToRemove = oldBatch.itemsToRemove;\n    const itemsToMoveLength = itemsToRemove.length;\n    for (let j = 0; j < itemsToMoveLength; j++) {\n      updater = itemsToRemove[j];\n      oldBatch.remove(updater);\n      const newBatch = this.add(time, updater);\n      oldBatch.isDirty = true;\n      newBatch.isDirty = true;\n    }\n  }\n\n  //If we moved anything around, we need to re-build the primitive and remove empty batches\n  for (i = batchCount - 1; i >= 0; --i) {\n    const batch = batches[i];\n    if (batch.isDirty) {\n      isUpdated = batches[i].update(time) && isUpdated;\n      batch.isDirty = false;\n    }\n    if (batch.geometry.length === 0) {\n      batches.splice(i, 1);\n    }\n  }\n\n  return isUpdated;\n};\n\nStaticGroundGeometryColorBatch.prototype.getBoundingSphere = function (\n  updater,\n  result,\n) {\n  const batches = this._batches;\n  const batchCount = batches.length;\n  for (let i = 0; i < batchCount; ++i) {\n    const batch = batches[i];\n    if (batch.contains(updater)) {\n      return batch.getBoundingSphere(updater, result);\n    }\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\nStaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function () {\n  const batches = this._batches;\n  const batchCount = batches.length;\n  for (let i = 0; i < batchCount; ++i) {\n    batches[i].removeAllPrimitives();\n  }\n};\nexport default StaticGroundGeometryColorBatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}