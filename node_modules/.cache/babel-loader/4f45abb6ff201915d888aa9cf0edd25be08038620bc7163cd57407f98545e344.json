{"ast":null,"code":"import CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\n\n/**\n * An enum of metadata component types.\n *\n * @enum {string}\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst MetadataComponentType = {\n  /**\n   * An 8-bit signed integer\n   *\n   * @type {string}\n   * @constant\n   */\n  INT8: \"INT8\",\n  /**\n   * An 8-bit unsigned integer\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT8: \"UINT8\",\n  /**\n   * A 16-bit signed integer\n   *\n   * @type {string}\n   * @constant\n   */\n  INT16: \"INT16\",\n  /**\n   * A 16-bit unsigned integer\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT16: \"UINT16\",\n  /**\n   * A 32-bit signed integer\n   *\n   * @type {string}\n   * @constant\n   */\n  INT32: \"INT32\",\n  /**\n   * A 32-bit unsigned integer\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT32: \"UINT32\",\n  /**\n   * A 64-bit signed integer. This type requires BigInt support.\n   *\n   * @see FeatureDetection.supportsBigInt\n   *\n   * @type {string}\n   * @constant\n   */\n  INT64: \"INT64\",\n  /**\n   * A 64-bit signed integer. This type requires BigInt support\n   *\n   * @see FeatureDetection.supportsBigInt\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT64: \"UINT64\",\n  /**\n   * A 32-bit (single precision) floating point number\n   *\n   * @type {string}\n   * @constant\n   */\n  FLOAT32: \"FLOAT32\",\n  /**\n   * A 64-bit (double precision) floating point number\n   *\n   * @type {string}\n   * @constant\n   */\n  FLOAT64: \"FLOAT64\"\n};\n\n/**\n * Gets the minimum value for the numeric type.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * Otherwise an approximate number is returned.\n * </p>\n *\n * @param {MetadataComponentType} type The type.\n * @returns {number|bigint} The minimum value.\n *\n * @private\n */\nMetadataComponentType.getMinimum = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return -128;\n    case MetadataComponentType.UINT8:\n      return 0;\n    case MetadataComponentType.INT16:\n      return -32768;\n    case MetadataComponentType.UINT16:\n      return 0;\n    case MetadataComponentType.INT32:\n      return -2147483648;\n    case MetadataComponentType.UINT32:\n      return 0;\n    case MetadataComponentType.INT64:\n      if (FeatureDetection.supportsBigInt()) {\n        return BigInt(\"-9223372036854775808\"); // eslint-disable-line\n      }\n      return -Math.pow(2, 63);\n    case MetadataComponentType.UINT64:\n      if (FeatureDetection.supportsBigInt()) {\n        return BigInt(0); // eslint-disable-line\n      }\n      return 0;\n    case MetadataComponentType.FLOAT32:\n      // Maximum 32-bit floating point number. This value will be converted to the nearest 64-bit Number\n      return -340282346638528859811704183484516925440.0;\n    case MetadataComponentType.FLOAT64:\n      return -Number.MAX_VALUE;\n  }\n};\n\n/**\n * Gets the maximum value for the numeric type.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * Otherwise an approximate number is returned.\n * </p>\n *\n * @param {MetadataComponentType} type The type.\n * @returns {number|bigint} The maximum value.\n *\n * @private\n */\nMetadataComponentType.getMaximum = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return 127;\n    case MetadataComponentType.UINT8:\n      return 255;\n    case MetadataComponentType.INT16:\n      return 32767;\n    case MetadataComponentType.UINT16:\n      return 65535;\n    case MetadataComponentType.INT32:\n      return 2147483647;\n    case MetadataComponentType.UINT32:\n      return 4294967295;\n    case MetadataComponentType.INT64:\n      if (FeatureDetection.supportsBigInt()) {\n        // Need to initialize with a string otherwise the value will be 9223372036854775808\n        return BigInt(\"9223372036854775807\"); // eslint-disable-line\n      }\n      return Math.pow(2, 63) - 1;\n    case MetadataComponentType.UINT64:\n      if (FeatureDetection.supportsBigInt()) {\n        // Need to initialize with a string otherwise the value will be 18446744073709551616\n        return BigInt(\"18446744073709551615\"); // eslint-disable-line\n      }\n      return Math.pow(2, 64) - 1;\n    case MetadataComponentType.FLOAT32:\n      // Maximum 32-bit floating point number\n      return 340282346638528859811704183484516925440.0;\n    case MetadataComponentType.FLOAT64:\n      return Number.MAX_VALUE;\n  }\n};\n\n/**\n * Returns whether the type is an integer type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {boolean} Whether the type is an integer type.\n *\n * @private\n */\nMetadataComponentType.isIntegerType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether the type is an unsigned integer type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {boolean} Whether the type is an unsigned integer type.\n *\n * @private\n */\nMetadataComponentType.isUnsignedIntegerType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.UINT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether a type can be used in a vector, i.e. the {@link Cartesian2},\n * {@link Cartesian3}, or {@link Cartesian4} classes. This includes all numeric\n * types except for types requiring 64-bit integers\n * @param {MetadataComponentType} type The type to check\n * @return {boolean} <code>true</code> if the type can be encoded as a vector type, or <code>false</code> otherwise\n * @private\n */\nMetadataComponentType.isVectorCompatible = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Normalizes signed integers to the range [-1.0, 1.0] and unsigned integers to\n * the range [0.0, 1.0].\n * <p>\n * The value may be a BigInt for the INT64 and UINT64 types. The value is converted\n * to a 64-bit floating point number during normalization which may result in\n * small precision differences.\n * </p>\n *\n * @param {number|bigint} value The integer value.\n * @param {MetadataComponentType} type The type.\n * @returns {number} The normalized value.\n *\n * @exception {DeveloperError} value must be a number or a BigInt\n * @exception {DeveloperError} type must be an integer type\n *\n * @private\n */\nMetadataComponentType.normalize = function (value, type) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof value !== \"number\" && typeof value !== \"bigint\") {\n    throw new DeveloperError(\"value must be a number or a BigInt\");\n  }\n  if (!MetadataComponentType.isIntegerType(type)) {\n    throw new DeveloperError(\"type must be an integer type\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(Number(value) / Number(MetadataComponentType.getMaximum(type)), -1.0);\n};\n\n/**\n * Unnormalizes signed numbers in the range [-1.0, 1.0] to signed integers and\n * unsigned numbers in the range [0.0, 1.0] to unsigned integers. Values outside\n * the range are clamped to the range.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * </p>\n *\n * @param {number} value The normalized value.\n * @param {MetadataComponentType} type The type.\n * @returns {number|bigint} The integer value.\n *\n * @exception {DeveloperError} type must be an integer type\n *\n * @private\n */\nMetadataComponentType.unnormalize = function (value, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  if (!MetadataComponentType.isIntegerType(type)) {\n    throw new DeveloperError(\"type must be an integer type\");\n  }\n  //>>includeEnd('debug');\n\n  const max = MetadataComponentType.getMaximum(type);\n  const min = MetadataComponentType.isUnsignedIntegerType(type) ? 0 : -max;\n  value = CesiumMath.sign(value) * Math.round(Math.abs(value) * Number(max));\n  if ((type === MetadataComponentType.INT64 || type === MetadataComponentType.UINT64) && FeatureDetection.supportsBigInt()) {\n    value = BigInt(value); // eslint-disable-line\n  }\n  if (value > max) {\n    return max;\n  }\n  if (value < min) {\n    return min;\n  }\n  return value;\n};\n\n/**\n * @private\n */\nMetadataComponentType.applyValueTransform = function (value, offset, scale) {\n  return scale * value + offset;\n};\n\n/**\n * @private\n */\nMetadataComponentType.unapplyValueTransform = function (value, offset, scale) {\n  // if the scale is 0, avoid a divide by zero error. The result can be any\n  // finite number, so 0.0 will do nicely.\n  if (scale === 0) {\n    return 0.0;\n  }\n  return (value - offset) / scale;\n};\n\n/**\n * Gets the size in bytes for the numeric type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {number} The size in bytes.\n *\n * @private\n */\nMetadataComponentType.getSizeInBytes = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n      return 1;\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n      return 2;\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n      return 4;\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      return 8;\n    case MetadataComponentType.FLOAT32:\n      return 4;\n    case MetadataComponentType.FLOAT64:\n      return 8;\n  }\n};\n\n/**\n * Gets the {@link MetadataComponentType} from a {@link ComponentDatatype}.\n *\n * @param {ComponentDatatype} componentDatatype The component datatype.\n * @returns {MetadataComponentType} The type.\n *\n * @private\n */\nMetadataComponentType.fromComponentDatatype = function (componentDatatype) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"componentDatatype\", componentDatatype);\n  //>>includeEnd('debug');\n\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return MetadataComponentType.INT8;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return MetadataComponentType.UINT8;\n    case ComponentDatatype.SHORT:\n      return MetadataComponentType.INT16;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return MetadataComponentType.UINT16;\n    case ComponentDatatype.INT:\n      return MetadataComponentType.INT32;\n    case ComponentDatatype.UNSIGNED_INT:\n      return MetadataComponentType.UINT32;\n    case ComponentDatatype.FLOAT:\n      return MetadataComponentType.FLOAT32;\n    case ComponentDatatype.DOUBLE:\n      return MetadataComponentType.FLOAT64;\n  }\n};\n\n/**\n * Gets the {@link ComponentDatatype} from a {@link MetadataComponentType}.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {ComponentDatatype} The component datatype.\n *\n * @private\n */\nMetadataComponentType.toComponentDatatype = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return ComponentDatatype.BYTE;\n    case MetadataComponentType.UINT8:\n      return ComponentDatatype.UNSIGNED_BYTE;\n    case MetadataComponentType.INT16:\n      return ComponentDatatype.SHORT;\n    case MetadataComponentType.UINT16:\n      return ComponentDatatype.UNSIGNED_SHORT;\n    case MetadataComponentType.INT32:\n      return ComponentDatatype.INT;\n    case MetadataComponentType.UINT32:\n      return ComponentDatatype.UNSIGNED_INT;\n    case MetadataComponentType.FLOAT32:\n      return ComponentDatatype.FLOAT;\n    case MetadataComponentType.FLOAT64:\n      return ComponentDatatype.DOUBLE;\n  }\n};\nexport default Object.freeze(MetadataComponentType);","map":{"version":3,"names":["CesiumMath","Check","ComponentDatatype","DeveloperError","FeatureDetection","MetadataComponentType","INT8","UINT8","INT16","UINT16","INT32","UINT32","INT64","UINT64","FLOAT32","FLOAT64","getMinimum","type","typeOf","string","supportsBigInt","BigInt","Math","pow","Number","MAX_VALUE","getMaximum","isIntegerType","isUnsignedIntegerType","isVectorCompatible","normalize","value","max","unnormalize","number","min","sign","round","abs","applyValueTransform","offset","scale","unapplyValueTransform","getSizeInBytes","fromComponentDatatype","componentDatatype","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","DOUBLE","toComponentDatatype","Object","freeze"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/MetadataComponentType.js"],"sourcesContent":["import CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\n\n/**\n * An enum of metadata component types.\n *\n * @enum {string}\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst MetadataComponentType = {\n  /**\n   * An 8-bit signed integer\n   *\n   * @type {string}\n   * @constant\n   */\n  INT8: \"INT8\",\n  /**\n   * An 8-bit unsigned integer\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT8: \"UINT8\",\n  /**\n   * A 16-bit signed integer\n   *\n   * @type {string}\n   * @constant\n   */\n  INT16: \"INT16\",\n  /**\n   * A 16-bit unsigned integer\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT16: \"UINT16\",\n  /**\n   * A 32-bit signed integer\n   *\n   * @type {string}\n   * @constant\n   */\n  INT32: \"INT32\",\n  /**\n   * A 32-bit unsigned integer\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT32: \"UINT32\",\n  /**\n   * A 64-bit signed integer. This type requires BigInt support.\n   *\n   * @see FeatureDetection.supportsBigInt\n   *\n   * @type {string}\n   * @constant\n   */\n  INT64: \"INT64\",\n  /**\n   * A 64-bit signed integer. This type requires BigInt support\n   *\n   * @see FeatureDetection.supportsBigInt\n   *\n   * @type {string}\n   * @constant\n   */\n  UINT64: \"UINT64\",\n  /**\n   * A 32-bit (single precision) floating point number\n   *\n   * @type {string}\n   * @constant\n   */\n  FLOAT32: \"FLOAT32\",\n  /**\n   * A 64-bit (double precision) floating point number\n   *\n   * @type {string}\n   * @constant\n   */\n  FLOAT64: \"FLOAT64\",\n};\n\n/**\n * Gets the minimum value for the numeric type.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * Otherwise an approximate number is returned.\n * </p>\n *\n * @param {MetadataComponentType} type The type.\n * @returns {number|bigint} The minimum value.\n *\n * @private\n */\nMetadataComponentType.getMinimum = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return -128;\n    case MetadataComponentType.UINT8:\n      return 0;\n    case MetadataComponentType.INT16:\n      return -32768;\n    case MetadataComponentType.UINT16:\n      return 0;\n    case MetadataComponentType.INT32:\n      return -2147483648;\n    case MetadataComponentType.UINT32:\n      return 0;\n    case MetadataComponentType.INT64:\n      if (FeatureDetection.supportsBigInt()) {\n        return BigInt(\"-9223372036854775808\"); // eslint-disable-line\n      }\n      return -Math.pow(2, 63);\n    case MetadataComponentType.UINT64:\n      if (FeatureDetection.supportsBigInt()) {\n        return BigInt(0); // eslint-disable-line\n      }\n      return 0;\n    case MetadataComponentType.FLOAT32:\n      // Maximum 32-bit floating point number. This value will be converted to the nearest 64-bit Number\n      return -340282346638528859811704183484516925440.0;\n    case MetadataComponentType.FLOAT64:\n      return -Number.MAX_VALUE;\n  }\n};\n\n/**\n * Gets the maximum value for the numeric type.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * Otherwise an approximate number is returned.\n * </p>\n *\n * @param {MetadataComponentType} type The type.\n * @returns {number|bigint} The maximum value.\n *\n * @private\n */\nMetadataComponentType.getMaximum = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return 127;\n    case MetadataComponentType.UINT8:\n      return 255;\n    case MetadataComponentType.INT16:\n      return 32767;\n    case MetadataComponentType.UINT16:\n      return 65535;\n    case MetadataComponentType.INT32:\n      return 2147483647;\n    case MetadataComponentType.UINT32:\n      return 4294967295;\n    case MetadataComponentType.INT64:\n      if (FeatureDetection.supportsBigInt()) {\n        // Need to initialize with a string otherwise the value will be 9223372036854775808\n        return BigInt(\"9223372036854775807\"); // eslint-disable-line\n      }\n      return Math.pow(2, 63) - 1;\n    case MetadataComponentType.UINT64:\n      if (FeatureDetection.supportsBigInt()) {\n        // Need to initialize with a string otherwise the value will be 18446744073709551616\n        return BigInt(\"18446744073709551615\"); // eslint-disable-line\n      }\n      return Math.pow(2, 64) - 1;\n    case MetadataComponentType.FLOAT32:\n      // Maximum 32-bit floating point number\n      return 340282346638528859811704183484516925440.0;\n    case MetadataComponentType.FLOAT64:\n      return Number.MAX_VALUE;\n  }\n};\n\n/**\n * Returns whether the type is an integer type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {boolean} Whether the type is an integer type.\n *\n * @private\n */\nMetadataComponentType.isIntegerType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether the type is an unsigned integer type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {boolean} Whether the type is an unsigned integer type.\n *\n * @private\n */\nMetadataComponentType.isUnsignedIntegerType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.UINT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether a type can be used in a vector, i.e. the {@link Cartesian2},\n * {@link Cartesian3}, or {@link Cartesian4} classes. This includes all numeric\n * types except for types requiring 64-bit integers\n * @param {MetadataComponentType} type The type to check\n * @return {boolean} <code>true</code> if the type can be encoded as a vector type, or <code>false</code> otherwise\n * @private\n */\nMetadataComponentType.isVectorCompatible = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Normalizes signed integers to the range [-1.0, 1.0] and unsigned integers to\n * the range [0.0, 1.0].\n * <p>\n * The value may be a BigInt for the INT64 and UINT64 types. The value is converted\n * to a 64-bit floating point number during normalization which may result in\n * small precision differences.\n * </p>\n *\n * @param {number|bigint} value The integer value.\n * @param {MetadataComponentType} type The type.\n * @returns {number} The normalized value.\n *\n * @exception {DeveloperError} value must be a number or a BigInt\n * @exception {DeveloperError} type must be an integer type\n *\n * @private\n */\nMetadataComponentType.normalize = function (value, type) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof value !== \"number\" && typeof value !== \"bigint\") {\n    throw new DeveloperError(\"value must be a number or a BigInt\");\n  }\n  if (!MetadataComponentType.isIntegerType(type)) {\n    throw new DeveloperError(\"type must be an integer type\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(\n    Number(value) / Number(MetadataComponentType.getMaximum(type)),\n    -1.0,\n  );\n};\n\n/**\n * Unnormalizes signed numbers in the range [-1.0, 1.0] to signed integers and\n * unsigned numbers in the range [0.0, 1.0] to unsigned integers. Values outside\n * the range are clamped to the range.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * </p>\n *\n * @param {number} value The normalized value.\n * @param {MetadataComponentType} type The type.\n * @returns {number|bigint} The integer value.\n *\n * @exception {DeveloperError} type must be an integer type\n *\n * @private\n */\nMetadataComponentType.unnormalize = function (value, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  if (!MetadataComponentType.isIntegerType(type)) {\n    throw new DeveloperError(\"type must be an integer type\");\n  }\n  //>>includeEnd('debug');\n\n  const max = MetadataComponentType.getMaximum(type);\n  const min = MetadataComponentType.isUnsignedIntegerType(type) ? 0 : -max;\n\n  value = CesiumMath.sign(value) * Math.round(Math.abs(value) * Number(max));\n\n  if (\n    (type === MetadataComponentType.INT64 ||\n      type === MetadataComponentType.UINT64) &&\n    FeatureDetection.supportsBigInt()\n  ) {\n    value = BigInt(value); // eslint-disable-line\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  if (value < min) {\n    return min;\n  }\n\n  return value;\n};\n\n/**\n * @private\n */\nMetadataComponentType.applyValueTransform = function (value, offset, scale) {\n  return scale * value + offset;\n};\n\n/**\n * @private\n */\nMetadataComponentType.unapplyValueTransform = function (value, offset, scale) {\n  // if the scale is 0, avoid a divide by zero error. The result can be any\n  // finite number, so 0.0 will do nicely.\n  if (scale === 0) {\n    return 0.0;\n  }\n\n  return (value - offset) / scale;\n};\n\n/**\n * Gets the size in bytes for the numeric type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {number} The size in bytes.\n *\n * @private\n */\nMetadataComponentType.getSizeInBytes = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n      return 1;\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n      return 2;\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n      return 4;\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      return 8;\n    case MetadataComponentType.FLOAT32:\n      return 4;\n    case MetadataComponentType.FLOAT64:\n      return 8;\n  }\n};\n\n/**\n * Gets the {@link MetadataComponentType} from a {@link ComponentDatatype}.\n *\n * @param {ComponentDatatype} componentDatatype The component datatype.\n * @returns {MetadataComponentType} The type.\n *\n * @private\n */\nMetadataComponentType.fromComponentDatatype = function (componentDatatype) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"componentDatatype\", componentDatatype);\n  //>>includeEnd('debug');\n\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      return MetadataComponentType.INT8;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return MetadataComponentType.UINT8;\n    case ComponentDatatype.SHORT:\n      return MetadataComponentType.INT16;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return MetadataComponentType.UINT16;\n    case ComponentDatatype.INT:\n      return MetadataComponentType.INT32;\n    case ComponentDatatype.UNSIGNED_INT:\n      return MetadataComponentType.UINT32;\n    case ComponentDatatype.FLOAT:\n      return MetadataComponentType.FLOAT32;\n    case ComponentDatatype.DOUBLE:\n      return MetadataComponentType.FLOAT64;\n  }\n};\n\n/**\n * Gets the {@link ComponentDatatype} from a {@link MetadataComponentType}.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {ComponentDatatype} The component datatype.\n *\n * @private\n */\nMetadataComponentType.toComponentDatatype = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return ComponentDatatype.BYTE;\n    case MetadataComponentType.UINT8:\n      return ComponentDatatype.UNSIGNED_BYTE;\n    case MetadataComponentType.INT16:\n      return ComponentDatatype.SHORT;\n    case MetadataComponentType.UINT16:\n      return ComponentDatatype.UNSIGNED_SHORT;\n    case MetadataComponentType.INT32:\n      return ComponentDatatype.INT;\n    case MetadataComponentType.UINT32:\n      return ComponentDatatype.UNSIGNED_INT;\n    case MetadataComponentType.FLOAT32:\n      return ComponentDatatype.FLOAT;\n    case MetadataComponentType.FLOAT64:\n      return ComponentDatatype.DOUBLE;\n  }\n};\n\nexport default Object.freeze(MetadataComponentType);\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,iBAAiB;AACxC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,gBAAgB,MAAM,6BAA6B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG;EAC5B;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,MAAM;EACZ;AACF;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE,OAAO;EACd;AACF;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE,OAAO;EACd;AACF;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,QAAQ;EAChB;AACF;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE,OAAO;EACd;AACF;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,QAAQ;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE,OAAO;EACd;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE,QAAQ;EAChB;AACF;AACA;AACA;AACA;AACA;EACEC,OAAO,EAAE,SAAS;EAClB;AACF;AACA;AACA;AACA;AACA;EACEC,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,qBAAqB,CAACW,UAAU,GAAG,UAAUC,IAAI,EAAE;EACjD;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACC,IAAI;MAC7B,OAAO,CAAC,GAAG;IACb,KAAKD,qBAAqB,CAACE,KAAK;MAC9B,OAAO,CAAC;IACV,KAAKF,qBAAqB,CAACG,KAAK;MAC9B,OAAO,CAAC,KAAK;IACf,KAAKH,qBAAqB,CAACI,MAAM;MAC/B,OAAO,CAAC;IACV,KAAKJ,qBAAqB,CAACK,KAAK;MAC9B,OAAO,CAAC,UAAU;IACpB,KAAKL,qBAAqB,CAACM,MAAM;MAC/B,OAAO,CAAC;IACV,KAAKN,qBAAqB,CAACO,KAAK;MAC9B,IAAIR,gBAAgB,CAACgB,cAAc,CAAC,CAAC,EAAE;QACrC,OAAOC,MAAM,CAAC,sBAAsB,CAAC,CAAC,CAAC;MACzC;MACA,OAAO,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;IACzB,KAAKlB,qBAAqB,CAACQ,MAAM;MAC/B,IAAIT,gBAAgB,CAACgB,cAAc,CAAC,CAAC,EAAE;QACrC,OAAOC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;MACpB;MACA,OAAO,CAAC;IACV,KAAKhB,qBAAqB,CAACS,OAAO;MAChC;MACA,OAAO,CAAC,yCAAyC;IACnD,KAAKT,qBAAqB,CAACU,OAAO;MAChC,OAAO,CAACS,MAAM,CAACC,SAAS;EAC5B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApB,qBAAqB,CAACqB,UAAU,GAAG,UAAUT,IAAI,EAAE;EACjD;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACC,IAAI;MAC7B,OAAO,GAAG;IACZ,KAAKD,qBAAqB,CAACE,KAAK;MAC9B,OAAO,GAAG;IACZ,KAAKF,qBAAqB,CAACG,KAAK;MAC9B,OAAO,KAAK;IACd,KAAKH,qBAAqB,CAACI,MAAM;MAC/B,OAAO,KAAK;IACd,KAAKJ,qBAAqB,CAACK,KAAK;MAC9B,OAAO,UAAU;IACnB,KAAKL,qBAAqB,CAACM,MAAM;MAC/B,OAAO,UAAU;IACnB,KAAKN,qBAAqB,CAACO,KAAK;MAC9B,IAAIR,gBAAgB,CAACgB,cAAc,CAAC,CAAC,EAAE;QACrC;QACA,OAAOC,MAAM,CAAC,qBAAqB,CAAC,CAAC,CAAC;MACxC;MACA,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;IAC5B,KAAKlB,qBAAqB,CAACQ,MAAM;MAC/B,IAAIT,gBAAgB,CAACgB,cAAc,CAAC,CAAC,EAAE;QACrC;QACA,OAAOC,MAAM,CAAC,sBAAsB,CAAC,CAAC,CAAC;MACzC;MACA,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;IAC5B,KAAKlB,qBAAqB,CAACS,OAAO;MAChC;MACA,OAAO,yCAAyC;IAClD,KAAKT,qBAAqB,CAACU,OAAO;MAChC,OAAOS,MAAM,CAACC,SAAS;EAC3B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApB,qBAAqB,CAACsB,aAAa,GAAG,UAAUV,IAAI,EAAE;EACpD;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACC,IAAI;IAC/B,KAAKD,qBAAqB,CAACE,KAAK;IAChC,KAAKF,qBAAqB,CAACG,KAAK;IAChC,KAAKH,qBAAqB,CAACI,MAAM;IACjC,KAAKJ,qBAAqB,CAACK,KAAK;IAChC,KAAKL,qBAAqB,CAACM,MAAM;IACjC,KAAKN,qBAAqB,CAACO,KAAK;IAChC,KAAKP,qBAAqB,CAACQ,MAAM;MAC/B,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,qBAAqB,CAACuB,qBAAqB,GAAG,UAAUX,IAAI,EAAE;EAC5D;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACE,KAAK;IAChC,KAAKF,qBAAqB,CAACI,MAAM;IACjC,KAAKJ,qBAAqB,CAACM,MAAM;IACjC,KAAKN,qBAAqB,CAACQ,MAAM;MAC/B,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,qBAAqB,CAACwB,kBAAkB,GAAG,UAAUZ,IAAI,EAAE;EACzD;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACC,IAAI;IAC/B,KAAKD,qBAAqB,CAACE,KAAK;IAChC,KAAKF,qBAAqB,CAACG,KAAK;IAChC,KAAKH,qBAAqB,CAACI,MAAM;IACjC,KAAKJ,qBAAqB,CAACK,KAAK;IAChC,KAAKL,qBAAqB,CAACM,MAAM;IACjC,KAAKN,qBAAqB,CAACS,OAAO;IAClC,KAAKT,qBAAqB,CAACU,OAAO;MAChC,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,qBAAqB,CAACyB,SAAS,GAAG,UAAUC,KAAK,EAAEd,IAAI,EAAE;EACvD;EACA,IAAI,OAAOc,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC1D,MAAM,IAAI5B,cAAc,CAAC,oCAAoC,CAAC;EAChE;EACA,IAAI,CAACE,qBAAqB,CAACsB,aAAa,CAACV,IAAI,CAAC,EAAE;IAC9C,MAAM,IAAId,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;;EAEA,OAAOmB,IAAI,CAACU,GAAG,CACbR,MAAM,CAACO,KAAK,CAAC,GAAGP,MAAM,CAACnB,qBAAqB,CAACqB,UAAU,CAACT,IAAI,CAAC,CAAC,EAC9D,CAAC,GACH,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,qBAAqB,CAAC4B,WAAW,GAAG,UAAUF,KAAK,EAAEd,IAAI,EAAE;EACzD;EACAhB,KAAK,CAACiB,MAAM,CAACgB,MAAM,CAAC,OAAO,EAAEH,KAAK,CAAC;EACnC,IAAI,CAAC1B,qBAAqB,CAACsB,aAAa,CAACV,IAAI,CAAC,EAAE;IAC9C,MAAM,IAAId,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;;EAEA,MAAM6B,GAAG,GAAG3B,qBAAqB,CAACqB,UAAU,CAACT,IAAI,CAAC;EAClD,MAAMkB,GAAG,GAAG9B,qBAAqB,CAACuB,qBAAqB,CAACX,IAAI,CAAC,GAAG,CAAC,GAAG,CAACe,GAAG;EAExED,KAAK,GAAG/B,UAAU,CAACoC,IAAI,CAACL,KAAK,CAAC,GAAGT,IAAI,CAACe,KAAK,CAACf,IAAI,CAACgB,GAAG,CAACP,KAAK,CAAC,GAAGP,MAAM,CAACQ,GAAG,CAAC,CAAC;EAE1E,IACE,CAACf,IAAI,KAAKZ,qBAAqB,CAACO,KAAK,IACnCK,IAAI,KAAKZ,qBAAqB,CAACQ,MAAM,KACvCT,gBAAgB,CAACgB,cAAc,CAAC,CAAC,EACjC;IACAW,KAAK,GAAGV,MAAM,CAACU,KAAK,CAAC,CAAC,CAAC;EACzB;EAEA,IAAIA,KAAK,GAAGC,GAAG,EAAE;IACf,OAAOA,GAAG;EACZ;EAEA,IAAID,KAAK,GAAGI,GAAG,EAAE;IACf,OAAOA,GAAG;EACZ;EAEA,OAAOJ,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA1B,qBAAqB,CAACkC,mBAAmB,GAAG,UAAUR,KAAK,EAAES,MAAM,EAAEC,KAAK,EAAE;EAC1E,OAAOA,KAAK,GAAGV,KAAK,GAAGS,MAAM;AAC/B,CAAC;;AAED;AACA;AACA;AACAnC,qBAAqB,CAACqC,qBAAqB,GAAG,UAAUX,KAAK,EAAES,MAAM,EAAEC,KAAK,EAAE;EAC5E;EACA;EACA,IAAIA,KAAK,KAAK,CAAC,EAAE;IACf,OAAO,GAAG;EACZ;EAEA,OAAO,CAACV,KAAK,GAAGS,MAAM,IAAIC,KAAK;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApC,qBAAqB,CAACsC,cAAc,GAAG,UAAU1B,IAAI,EAAE;EACrD;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACC,IAAI;IAC/B,KAAKD,qBAAqB,CAACE,KAAK;MAC9B,OAAO,CAAC;IACV,KAAKF,qBAAqB,CAACG,KAAK;IAChC,KAAKH,qBAAqB,CAACI,MAAM;MAC/B,OAAO,CAAC;IACV,KAAKJ,qBAAqB,CAACK,KAAK;IAChC,KAAKL,qBAAqB,CAACM,MAAM;MAC/B,OAAO,CAAC;IACV,KAAKN,qBAAqB,CAACO,KAAK;IAChC,KAAKP,qBAAqB,CAACQ,MAAM;MAC/B,OAAO,CAAC;IACV,KAAKR,qBAAqB,CAACS,OAAO;MAChC,OAAO,CAAC;IACV,KAAKT,qBAAqB,CAACU,OAAO;MAChC,OAAO,CAAC;EACZ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,qBAAqB,CAACuC,qBAAqB,GAAG,UAAUC,iBAAiB,EAAE;EACzE;EACA5C,KAAK,CAACiB,MAAM,CAACgB,MAAM,CAAC,mBAAmB,EAAEW,iBAAiB,CAAC;EAC3D;;EAEA,QAAQA,iBAAiB;IACvB,KAAK3C,iBAAiB,CAAC4C,IAAI;MACzB,OAAOzC,qBAAqB,CAACC,IAAI;IACnC,KAAKJ,iBAAiB,CAAC6C,aAAa;MAClC,OAAO1C,qBAAqB,CAACE,KAAK;IACpC,KAAKL,iBAAiB,CAAC8C,KAAK;MAC1B,OAAO3C,qBAAqB,CAACG,KAAK;IACpC,KAAKN,iBAAiB,CAAC+C,cAAc;MACnC,OAAO5C,qBAAqB,CAACI,MAAM;IACrC,KAAKP,iBAAiB,CAACgD,GAAG;MACxB,OAAO7C,qBAAqB,CAACK,KAAK;IACpC,KAAKR,iBAAiB,CAACiD,YAAY;MACjC,OAAO9C,qBAAqB,CAACM,MAAM;IACrC,KAAKT,iBAAiB,CAACkD,KAAK;MAC1B,OAAO/C,qBAAqB,CAACS,OAAO;IACtC,KAAKZ,iBAAiB,CAACmD,MAAM;MAC3B,OAAOhD,qBAAqB,CAACU,OAAO;EACxC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,qBAAqB,CAACiD,mBAAmB,GAAG,UAAUrC,IAAI,EAAE;EAC1D;EACAhB,KAAK,CAACiB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;EACjC;;EAEA,QAAQA,IAAI;IACV,KAAKZ,qBAAqB,CAACC,IAAI;MAC7B,OAAOJ,iBAAiB,CAAC4C,IAAI;IAC/B,KAAKzC,qBAAqB,CAACE,KAAK;MAC9B,OAAOL,iBAAiB,CAAC6C,aAAa;IACxC,KAAK1C,qBAAqB,CAACG,KAAK;MAC9B,OAAON,iBAAiB,CAAC8C,KAAK;IAChC,KAAK3C,qBAAqB,CAACI,MAAM;MAC/B,OAAOP,iBAAiB,CAAC+C,cAAc;IACzC,KAAK5C,qBAAqB,CAACK,KAAK;MAC9B,OAAOR,iBAAiB,CAACgD,GAAG;IAC9B,KAAK7C,qBAAqB,CAACM,MAAM;MAC/B,OAAOT,iBAAiB,CAACiD,YAAY;IACvC,KAAK9C,qBAAqB,CAACS,OAAO;MAChC,OAAOZ,iBAAiB,CAACkD,KAAK;IAChC,KAAK/C,qBAAqB,CAACU,OAAO;MAChC,OAAOb,iBAAiB,CAACmD,MAAM;EACnC;AACF,CAAC;AAED,eAAeE,MAAM,CAACC,MAAM,CAACnD,qBAAqB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}