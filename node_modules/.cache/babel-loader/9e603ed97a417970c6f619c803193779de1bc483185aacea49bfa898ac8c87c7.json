{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n// The atlas is made up of regions of space called nodes that contain images or child nodes.\nfunction TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {\n  this.bottomLeft = defaultValue(bottomLeft, Cartesian2.ZERO);\n  this.topRight = defaultValue(topRight, Cartesian2.ZERO);\n  this.childNode1 = childNode1;\n  this.childNode2 = childNode2;\n  this.imageIndex = imageIndex;\n}\nconst defaultInitialSize = new Cartesian2(16.0, 16.0);\n\n/**\n * A TextureAtlas stores multiple images in one square texture and keeps\n * track of the texture coordinates for each image. TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it is\n * important to check {@link TextureAtlas#getGUID} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.context The context in which the texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\nfunction TextureAtlas(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const borderWidthInPixels = defaultValue(options.borderWidthInPixels, 1.0);\n  const initialSize = defaultValue(options.initialSize, defaultInitialSize);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (borderWidthInPixels < 0) {\n    throw new DeveloperError(\"borderWidthInPixels must be greater than or equal to zero.\");\n  }\n  if (initialSize.x < 1 || initialSize.y < 1) {\n    throw new DeveloperError(\"initialSize must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  this._context = options.context;\n  this._pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._textureCoordinates = [];\n  this._guid = createGuid();\n  this._idHash = {};\n  this._indexHash = {};\n  this._initialSize = initialSize;\n  this._root = undefined;\n}\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    }\n  },\n  /**\n   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   */\n  textureCoordinates: {\n    get: function () {\n      return this._textureCoordinates;\n    }\n  },\n  /**\n   * The texture that all of the images are being written to.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture}\n   */\n  texture: {\n    get: function () {\n      if (!defined(this._texture)) {\n        this._texture = new Texture({\n          context: this._context,\n          width: this._initialSize.x,\n          height: this._initialSize.y,\n          pixelFormat: this._pixelFormat\n        });\n      }\n      return this._texture;\n    }\n  },\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImages is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#getGUID} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   */\n  numberOfImages: {\n    get: function () {\n      return this._textureCoordinates.length;\n    }\n  },\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {string}\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    }\n  }\n});\n\n// Builds a larger texture and copies the old texture into the new one.\nfunction resizeAtlas(textureAtlas, image) {\n  const context = textureAtlas._context;\n  const numImages = textureAtlas.numberOfImages;\n  const scalingFactor = 2.0;\n  const borderWidthInPixels = textureAtlas._borderWidthInPixels;\n  if (numImages > 0) {\n    const oldAtlasWidth = textureAtlas._texture.width;\n    const oldAtlasHeight = textureAtlas._texture.height;\n    const atlasWidth = scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);\n    const atlasHeight = scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);\n    const widthRatio = oldAtlasWidth / atlasWidth;\n    const heightRatio = oldAtlasHeight / atlasHeight;\n\n    // Create new node structure, putting the old root node in the bottom left.\n    const nodeBottomRight = new TextureAtlasNode(new Cartesian2(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels), new Cartesian2(atlasWidth, oldAtlasHeight));\n    const nodeBottomHalf = new TextureAtlasNode(new Cartesian2(), new Cartesian2(atlasWidth, oldAtlasHeight), textureAtlas._root, nodeBottomRight);\n    const nodeTopHalf = new TextureAtlasNode(new Cartesian2(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels), new Cartesian2(atlasWidth, atlasHeight));\n    const nodeMain = new TextureAtlasNode(new Cartesian2(), new Cartesian2(atlasWidth, atlasHeight), nodeBottomHalf, nodeTopHalf);\n\n    // Resize texture coordinates.\n    for (let i = 0; i < textureAtlas._textureCoordinates.length; i++) {\n      const texCoord = textureAtlas._textureCoordinates[i];\n      if (defined(texCoord)) {\n        texCoord.x *= widthRatio;\n        texCoord.y *= heightRatio;\n        texCoord.width *= widthRatio;\n        texCoord.height *= heightRatio;\n      }\n    }\n\n    // Copy larger texture.\n    const newTexture = new Texture({\n      context: textureAtlas._context,\n      width: atlasWidth,\n      height: atlasHeight,\n      pixelFormat: textureAtlas._pixelFormat\n    });\n    const framebuffer = new Framebuffer({\n      context: context,\n      colorTextures: [textureAtlas._texture],\n      destroyAttachments: false\n    });\n    framebuffer._bind();\n    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);\n    framebuffer._unBind();\n    framebuffer.destroy();\n    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = newTexture;\n    textureAtlas._root = nodeMain;\n  } else {\n    // First image exceeds initialSize\n    let initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);\n    let initialHeight = scalingFactor * (image.height + 2 * borderWidthInPixels);\n    if (initialWidth < textureAtlas._initialSize.x) {\n      initialWidth = textureAtlas._initialSize.x;\n    }\n    if (initialHeight < textureAtlas._initialSize.y) {\n      initialHeight = textureAtlas._initialSize.y;\n    }\n    textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = new Texture({\n      context: textureAtlas._context,\n      width: initialWidth,\n      height: initialHeight,\n      pixelFormat: textureAtlas._pixelFormat\n    });\n    textureAtlas._root = new TextureAtlasNode(new Cartesian2(borderWidthInPixels, borderWidthInPixels), new Cartesian2(initialWidth, initialHeight));\n  }\n}\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nfunction findNode(textureAtlas, node, image) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // If a leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    // Node already contains an image, don't add to it.\n    if (defined(node.imageIndex)) {\n      return undefined;\n    }\n    const nodeWidth = node.topRight.x - node.bottomLeft.x;\n    const nodeHeight = node.topRight.y - node.bottomLeft.y;\n    const widthDifference = nodeWidth - image.width;\n    const heightDifference = nodeHeight - image.height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y));\n      // Only make a second child if the border gives enough space.\n      const childNode2BottomLeftX = node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftX < node.topRight.x) {\n        node.childNode2 = new TextureAtlasNode(new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.topRight.y));\n      }\n    }\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    else {\n      node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height));\n      // Only make a second child if the border gives enough space.\n      const childNode2BottomLeftY = node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftY < node.topRight.y) {\n        node.childNode2 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY), new Cartesian2(node.topRight.x, node.topRight.y));\n      }\n    }\n    return findNode(textureAtlas, node.childNode1, image);\n  }\n\n  // If not a leaf node\n  return findNode(textureAtlas, node.childNode1, image) || findNode(textureAtlas, node.childNode2, image);\n}\n\n// Adds image of given index to the texture atlas. Called from addImage and addImages.\nfunction addImage(textureAtlas, image, index) {\n  const node = findNode(textureAtlas, textureAtlas._root, image);\n  if (defined(node)) {\n    // Found a node that can hold the image.\n    node.imageIndex = index;\n\n    // Add texture coordinate and write to texture\n    const atlasWidth = textureAtlas._texture.width;\n    const atlasHeight = textureAtlas._texture.height;\n    const nodeWidth = node.topRight.x - node.bottomLeft.x;\n    const nodeHeight = node.topRight.y - node.bottomLeft.y;\n    const x = node.bottomLeft.x / atlasWidth;\n    const y = node.bottomLeft.y / atlasHeight;\n    const w = nodeWidth / atlasWidth;\n    const h = nodeHeight / atlasHeight;\n    textureAtlas._textureCoordinates[index] = new BoundingRectangle(x, y, w, h);\n    textureAtlas._texture.copyFrom({\n      source: image,\n      xOffset: node.bottomLeft.x,\n      yOffset: node.bottomLeft.y\n    });\n  } else {\n    // No node found, must resize the texture atlas.\n    resizeAtlas(textureAtlas, image);\n    addImage(textureAtlas, image, index);\n  }\n  textureAtlas._guid = createGuid();\n}\nfunction getIndex(atlas, image) {\n  if (!defined(atlas) || atlas.isDestroyed()) {\n    return -1;\n  }\n  const index = atlas.numberOfImages;\n  addImage(atlas, image, index);\n  return index;\n}\n\n/**\n * If the image is already in the atlas, the existing index is returned. Otherwise, the result is undefined.\n *\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @returns {number|undefined} The image index, or undefined if the image does not exist in the atlas.\n */\nTextureAtlas.prototype.getImageIndex = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._indexHash[id];\n};\n\n/**\n * Adds an image to the atlas synchronously.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement} image An image or canvas to add to the texture atlas.\n * @returns {number} The image index.\n */\nTextureAtlas.prototype.addImageSync = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = this._indexHash[id];\n  if (defined(index)) {\n    // we're already aware of this source\n    return index;\n  }\n  index = getIndex(this, image);\n  // store the promise\n  this._idHash[id] = Promise.resolve(index);\n  this._indexHash[id] = index;\n  // but return the value synchronously\n  return index;\n};\n\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise<number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let indexPromise = this._idHash[id];\n  if (defined(indexPromise)) {\n    // we're already aware of this source\n    return indexPromise;\n  }\n\n  // not in atlas, create the promise for the index\n\n  if (typeof image === \"function\") {\n    // if image is a function, call it\n    image = image(id);\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(image)) {\n      throw new DeveloperError(\"image is required.\");\n    }\n    //>>includeEnd('debug');\n  } else if (typeof image === \"string\" || image instanceof Resource) {\n    // Get a resource\n    const resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n  const that = this;\n  indexPromise = Promise.resolve(image).then(function (image) {\n    const index = getIndex(that, image);\n    that._indexHash[id] = index;\n    return index;\n  });\n\n  // store the promise\n  this._idHash[id] = indexPromise;\n  return indexPromise;\n};\n\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n *\n * @param {string} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} sub-region measured in pixels from the bottom-left.\n *\n * @returns {Promise<number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(subRegion)) {\n    throw new DeveloperError(\"subRegion is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indexPromise = this._idHash[id];\n  if (!defined(indexPromise)) {\n    throw new RuntimeError(`image with id \"${id}\" not found in the atlas.`);\n  }\n  const that = this;\n  return Promise.resolve(indexPromise).then(function (index) {\n    if (index === -1) {\n      // the atlas is destroyed\n      return -1;\n    }\n    const atlasWidth = that._texture.width;\n    const atlasHeight = that._texture.height;\n    const baseRegion = that._textureCoordinates[index];\n    const x = baseRegion.x + subRegion.x / atlasWidth;\n    const y = baseRegion.y + subRegion.y / atlasHeight;\n    const w = subRegion.width / atlasWidth;\n    const h = subRegion.height / atlasHeight;\n    const newIndex = that._textureCoordinates.push(new BoundingRectangle(x, y, w, h)) - 1;\n    that._indexHash[id] = newIndex;\n    that._guid = createGuid();\n    return newIndex;\n  });\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureAtlas#destroy\n */\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * atlas = atlas && atlas.destroy();\n *\n * @see TextureAtlas#isDestroyed\n */\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A function that creates an image.\n * @callback TextureAtlas.CreateImageCallback\n * @param {string} id The identifier of the image to load.\n * @returns {HTMLImageElement|Promise<HTMLImageElement>} The image, or a promise that will resolve to an image.\n */\nexport default TextureAtlas;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","createGuid","defaultValue","defined","destroyObject","DeveloperError","PixelFormat","Resource","RuntimeError","Framebuffer","Texture","TextureAtlasNode","bottomLeft","topRight","childNode1","childNode2","imageIndex","ZERO","defaultInitialSize","TextureAtlas","options","EMPTY_OBJECT","borderWidthInPixels","initialSize","context","x","y","_context","_pixelFormat","pixelFormat","RGBA","_borderWidthInPixels","_textureCoordinates","_guid","_idHash","_indexHash","_initialSize","_root","undefined","Object","defineProperties","prototype","get","textureCoordinates","texture","_texture","width","height","numberOfImages","length","guid","resizeAtlas","textureAtlas","image","numImages","scalingFactor","oldAtlasWidth","oldAtlasHeight","atlasWidth","atlasHeight","widthRatio","heightRatio","nodeBottomRight","nodeBottomHalf","nodeTopHalf","nodeMain","i","texCoord","newTexture","framebuffer","colorTextures","destroyAttachments","_bind","copyFromFramebuffer","_unBind","destroy","initialWidth","initialHeight","findNode","node","nodeWidth","nodeHeight","widthDifference","heightDifference","childNode2BottomLeftX","childNode2BottomLeftY","addImage","index","w","h","copyFrom","source","xOffset","yOffset","getIndex","atlas","isDestroyed","getImageIndex","id","addImageSync","Promise","resolve","indexPromise","resource","createIfNeeded","fetchImage","that","then","addSubRegion","subRegion","baseRegion","newIndex","push"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TextureAtlas.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n// The atlas is made up of regions of space called nodes that contain images or child nodes.\nfunction TextureAtlasNode(\n  bottomLeft,\n  topRight,\n  childNode1,\n  childNode2,\n  imageIndex,\n) {\n  this.bottomLeft = defaultValue(bottomLeft, Cartesian2.ZERO);\n  this.topRight = defaultValue(topRight, Cartesian2.ZERO);\n  this.childNode1 = childNode1;\n  this.childNode2 = childNode2;\n  this.imageIndex = imageIndex;\n}\n\nconst defaultInitialSize = new Cartesian2(16.0, 16.0);\n\n/**\n * A TextureAtlas stores multiple images in one square texture and keeps\n * track of the texture coordinates for each image. TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it is\n * important to check {@link TextureAtlas#getGUID} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.context The context in which the texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\nfunction TextureAtlas(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const borderWidthInPixels = defaultValue(options.borderWidthInPixels, 1.0);\n  const initialSize = defaultValue(options.initialSize, defaultInitialSize);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (borderWidthInPixels < 0) {\n    throw new DeveloperError(\n      \"borderWidthInPixels must be greater than or equal to zero.\",\n    );\n  }\n  if (initialSize.x < 1 || initialSize.y < 1) {\n    throw new DeveloperError(\"initialSize must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  this._context = options.context;\n  this._pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._textureCoordinates = [];\n  this._guid = createGuid();\n  this._idHash = {};\n  this._indexHash = {};\n  this._initialSize = initialSize;\n\n  this._root = undefined;\n}\n\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    },\n  },\n\n  /**\n   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   */\n  textureCoordinates: {\n    get: function () {\n      return this._textureCoordinates;\n    },\n  },\n\n  /**\n   * The texture that all of the images are being written to.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture}\n   */\n  texture: {\n    get: function () {\n      if (!defined(this._texture)) {\n        this._texture = new Texture({\n          context: this._context,\n          width: this._initialSize.x,\n          height: this._initialSize.y,\n          pixelFormat: this._pixelFormat,\n        });\n      }\n      return this._texture;\n    },\n  },\n\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImages is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#getGUID} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   */\n  numberOfImages: {\n    get: function () {\n      return this._textureCoordinates.length;\n    },\n  },\n\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {string}\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    },\n  },\n});\n\n// Builds a larger texture and copies the old texture into the new one.\nfunction resizeAtlas(textureAtlas, image) {\n  const context = textureAtlas._context;\n  const numImages = textureAtlas.numberOfImages;\n  const scalingFactor = 2.0;\n  const borderWidthInPixels = textureAtlas._borderWidthInPixels;\n  if (numImages > 0) {\n    const oldAtlasWidth = textureAtlas._texture.width;\n    const oldAtlasHeight = textureAtlas._texture.height;\n    const atlasWidth =\n      scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);\n    const atlasHeight =\n      scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);\n    const widthRatio = oldAtlasWidth / atlasWidth;\n    const heightRatio = oldAtlasHeight / atlasHeight;\n\n    // Create new node structure, putting the old root node in the bottom left.\n    const nodeBottomRight = new TextureAtlasNode(\n      new Cartesian2(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels),\n      new Cartesian2(atlasWidth, oldAtlasHeight),\n    );\n    const nodeBottomHalf = new TextureAtlasNode(\n      new Cartesian2(),\n      new Cartesian2(atlasWidth, oldAtlasHeight),\n      textureAtlas._root,\n      nodeBottomRight,\n    );\n    const nodeTopHalf = new TextureAtlasNode(\n      new Cartesian2(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels),\n      new Cartesian2(atlasWidth, atlasHeight),\n    );\n    const nodeMain = new TextureAtlasNode(\n      new Cartesian2(),\n      new Cartesian2(atlasWidth, atlasHeight),\n      nodeBottomHalf,\n      nodeTopHalf,\n    );\n\n    // Resize texture coordinates.\n    for (let i = 0; i < textureAtlas._textureCoordinates.length; i++) {\n      const texCoord = textureAtlas._textureCoordinates[i];\n      if (defined(texCoord)) {\n        texCoord.x *= widthRatio;\n        texCoord.y *= heightRatio;\n        texCoord.width *= widthRatio;\n        texCoord.height *= heightRatio;\n      }\n    }\n\n    // Copy larger texture.\n    const newTexture = new Texture({\n      context: textureAtlas._context,\n      width: atlasWidth,\n      height: atlasHeight,\n      pixelFormat: textureAtlas._pixelFormat,\n    });\n\n    const framebuffer = new Framebuffer({\n      context: context,\n      colorTextures: [textureAtlas._texture],\n      destroyAttachments: false,\n    });\n\n    framebuffer._bind();\n    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);\n    framebuffer._unBind();\n    framebuffer.destroy();\n    textureAtlas._texture =\n      textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = newTexture;\n    textureAtlas._root = nodeMain;\n  } else {\n    // First image exceeds initialSize\n    let initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);\n    let initialHeight =\n      scalingFactor * (image.height + 2 * borderWidthInPixels);\n    if (initialWidth < textureAtlas._initialSize.x) {\n      initialWidth = textureAtlas._initialSize.x;\n    }\n    if (initialHeight < textureAtlas._initialSize.y) {\n      initialHeight = textureAtlas._initialSize.y;\n    }\n    textureAtlas._texture =\n      textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = new Texture({\n      context: textureAtlas._context,\n      width: initialWidth,\n      height: initialHeight,\n      pixelFormat: textureAtlas._pixelFormat,\n    });\n    textureAtlas._root = new TextureAtlasNode(\n      new Cartesian2(borderWidthInPixels, borderWidthInPixels),\n      new Cartesian2(initialWidth, initialHeight),\n    );\n  }\n}\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nfunction findNode(textureAtlas, node, image) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // If a leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    // Node already contains an image, don't add to it.\n    if (defined(node.imageIndex)) {\n      return undefined;\n    }\n\n    const nodeWidth = node.topRight.x - node.bottomLeft.x;\n    const nodeHeight = node.topRight.y - node.bottomLeft.y;\n    const widthDifference = nodeWidth - image.width;\n    const heightDifference = nodeHeight - image.height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureAtlasNode(\n        new Cartesian2(node.bottomLeft.x, node.bottomLeft.y),\n        new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y),\n      );\n      // Only make a second child if the border gives enough space.\n      const childNode2BottomLeftX =\n        node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftX < node.topRight.x) {\n        node.childNode2 = new TextureAtlasNode(\n          new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y),\n          new Cartesian2(node.topRight.x, node.topRight.y),\n        );\n      }\n    }\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    else {\n      node.childNode1 = new TextureAtlasNode(\n        new Cartesian2(node.bottomLeft.x, node.bottomLeft.y),\n        new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height),\n      );\n      // Only make a second child if the border gives enough space.\n      const childNode2BottomLeftY =\n        node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftY < node.topRight.y) {\n        node.childNode2 = new TextureAtlasNode(\n          new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY),\n          new Cartesian2(node.topRight.x, node.topRight.y),\n        );\n      }\n    }\n    return findNode(textureAtlas, node.childNode1, image);\n  }\n\n  // If not a leaf node\n  return (\n    findNode(textureAtlas, node.childNode1, image) ||\n    findNode(textureAtlas, node.childNode2, image)\n  );\n}\n\n// Adds image of given index to the texture atlas. Called from addImage and addImages.\nfunction addImage(textureAtlas, image, index) {\n  const node = findNode(textureAtlas, textureAtlas._root, image);\n  if (defined(node)) {\n    // Found a node that can hold the image.\n    node.imageIndex = index;\n\n    // Add texture coordinate and write to texture\n    const atlasWidth = textureAtlas._texture.width;\n    const atlasHeight = textureAtlas._texture.height;\n    const nodeWidth = node.topRight.x - node.bottomLeft.x;\n    const nodeHeight = node.topRight.y - node.bottomLeft.y;\n    const x = node.bottomLeft.x / atlasWidth;\n    const y = node.bottomLeft.y / atlasHeight;\n    const w = nodeWidth / atlasWidth;\n    const h = nodeHeight / atlasHeight;\n    textureAtlas._textureCoordinates[index] = new BoundingRectangle(x, y, w, h);\n    textureAtlas._texture.copyFrom({\n      source: image,\n      xOffset: node.bottomLeft.x,\n      yOffset: node.bottomLeft.y,\n    });\n  } else {\n    // No node found, must resize the texture atlas.\n    resizeAtlas(textureAtlas, image);\n    addImage(textureAtlas, image, index);\n  }\n\n  textureAtlas._guid = createGuid();\n}\n\nfunction getIndex(atlas, image) {\n  if (!defined(atlas) || atlas.isDestroyed()) {\n    return -1;\n  }\n\n  const index = atlas.numberOfImages;\n\n  addImage(atlas, image, index);\n\n  return index;\n}\n\n/**\n * If the image is already in the atlas, the existing index is returned. Otherwise, the result is undefined.\n *\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @returns {number|undefined} The image index, or undefined if the image does not exist in the atlas.\n */\nTextureAtlas.prototype.getImageIndex = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._indexHash[id];\n};\n\n/**\n * Adds an image to the atlas synchronously.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement} image An image or canvas to add to the texture atlas.\n * @returns {number} The image index.\n */\nTextureAtlas.prototype.addImageSync = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = this._indexHash[id];\n  if (defined(index)) {\n    // we're already aware of this source\n    return index;\n  }\n\n  index = getIndex(this, image);\n  // store the promise\n  this._idHash[id] = Promise.resolve(index);\n  this._indexHash[id] = index;\n  // but return the value synchronously\n  return index;\n};\n\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise<number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let indexPromise = this._idHash[id];\n  if (defined(indexPromise)) {\n    // we're already aware of this source\n    return indexPromise;\n  }\n\n  // not in atlas, create the promise for the index\n\n  if (typeof image === \"function\") {\n    // if image is a function, call it\n    image = image(id);\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(image)) {\n      throw new DeveloperError(\"image is required.\");\n    }\n    //>>includeEnd('debug');\n  } else if (typeof image === \"string\" || image instanceof Resource) {\n    // Get a resource\n    const resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n\n  const that = this;\n  indexPromise = Promise.resolve(image).then(function (image) {\n    const index = getIndex(that, image);\n    that._indexHash[id] = index;\n    return index;\n  });\n\n  // store the promise\n  this._idHash[id] = indexPromise;\n\n  return indexPromise;\n};\n\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n *\n * @param {string} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} sub-region measured in pixels from the bottom-left.\n *\n * @returns {Promise<number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(subRegion)) {\n    throw new DeveloperError(\"subRegion is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indexPromise = this._idHash[id];\n  if (!defined(indexPromise)) {\n    throw new RuntimeError(`image with id \"${id}\" not found in the atlas.`);\n  }\n\n  const that = this;\n  return Promise.resolve(indexPromise).then(function (index) {\n    if (index === -1) {\n      // the atlas is destroyed\n      return -1;\n    }\n    const atlasWidth = that._texture.width;\n    const atlasHeight = that._texture.height;\n\n    const baseRegion = that._textureCoordinates[index];\n    const x = baseRegion.x + subRegion.x / atlasWidth;\n    const y = baseRegion.y + subRegion.y / atlasHeight;\n    const w = subRegion.width / atlasWidth;\n    const h = subRegion.height / atlasHeight;\n    const newIndex =\n      that._textureCoordinates.push(new BoundingRectangle(x, y, w, h)) - 1;\n    that._indexHash[id] = newIndex;\n\n    that._guid = createGuid();\n\n    return newIndex;\n  });\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureAtlas#destroy\n */\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * atlas = atlas && atlas.destroy();\n *\n * @see TextureAtlas#isDestroyed\n */\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A function that creates an image.\n * @callback TextureAtlas.CreateImageCallback\n * @param {string} id The identifier of the image to load.\n * @returns {HTMLImageElement|Promise<HTMLImageElement>} The image, or a promise that will resolve to an image.\n */\nexport default TextureAtlas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}