{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport PrimitiveOutlineGenerator from \"./Model/PrimitiveOutlineGenerator.js\";\n\n/**\n * Simple struct for tracking whether an attribute will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.AttributeLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Attribute} attribute The attribute to be updated\n *\n * @private\n */\nfunction AttributeLoadPlan(attribute) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"attribute\", attribute);\n  //>>includeEnd('debug');\n\n  /**\n   * The attribute to track.\n   *\n   * @type {ModelComponents.Attribute}\n   * @readonly\n   * @private\n   */\n  this.attribute = attribute;\n\n  /**\n   * Whether the attribute will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the attribute will be loaded as a packed typed array by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Simple struct for tracking whether an index buffer will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.IndicesLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Indices} indices The indices to be updated\n *\n * @private\n */\nfunction IndicesLoadPlan(indices) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"indices\", indices);\n  //>>includeEnd('debug');\n\n  /**\n   * The indices to track.\n   *\n   * @type {ModelComponents.Indices}\n   * @readonly\n   * @private\n   */\n  this.indices = indices;\n\n  /**\n   * Whether the indices will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the indices will be loaded as a typed array copy of the GPU\n   * buffer by the time {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Primitives may need post-processing steps after their attributes and indices\n * have loaded, such as generating outlines for the CESIUM_primitive_outline glTF\n * extension. This object tracks what indices and attributes need to be\n * post-processed.\n *\n * @alias PrimitiveLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Primitive} primitive The primitive to track\n *\n * @private\n */\nfunction PrimitiveLoadPlan(primitive) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"primitive\", primitive);\n  //>>includeEnd('debug');\n\n  /**\n   * The primitive to track.\n   *\n   * @type {ModelComponents.Primitive}\n   * @readonly\n   * @private\n   */\n  this.primitive = primitive;\n\n  /**\n   * A flat list of attributes that need to be post-processed. This includes\n   * both regular attributes and morph target attributes.\n   *\n   * @type {PrimitiveLoadPlan.AttributeLoadPlan[]}\n   * @private\n   */\n  this.attributePlans = [];\n\n  /**\n   * Information about the triangle indices that need to be post-processed,\n   * if they exist.\n   *\n   * @type {PrimitiveLoadPlan.IndicesLoadPlan}\n   * @private\n   */\n  this.indicesPlan = undefined;\n\n  /**\n   * Set this true to indicate that the primitive has the\n   * CESIUM_primitive_outline extension and needs to be post-processed\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.needsOutlines = false;\n\n  /**\n   * The outline edge indices from the CESIUM_primitive_outline extension\n   *\n   * @type {number[]}\n   * @private\n   */\n  this.outlineIndices = undefined;\n}\n\n/**\n * Apply post-processing steps that may modify geometry such as generating\n * outline coordinates. If no post-processing steps are needed, this function\n * is a no-op.\n *\n * @param {Context} context The context for generating buffers on the GPU\n */\nPrimitiveLoadPlan.prototype.postProcess = function (context) {\n  // Handle CESIUM_primitive_outline. This modifies indices and attributes and\n  // also generates a new attribute for the outline coordinates. These steps\n  // are synchronous.\n  if (this.needsOutlines) {\n    generateOutlines(this);\n    generateBuffers(this, context);\n  }\n};\nfunction generateOutlines(loadPlan) {\n  const primitive = loadPlan.primitive;\n  const indices = primitive.indices;\n  const vertexCount = primitive.attributes[0].count;\n  const generator = new PrimitiveOutlineGenerator({\n    triangleIndices: indices.typedArray,\n    outlineIndices: loadPlan.outlineIndices,\n    originalVertexCount: vertexCount\n  });\n\n  // The generator modifies/adds indices. In some uncommon cases it may have\n  // to upgrade to 16- or 32-bit indices so the datatype may change.\n  indices.typedArray = generator.updatedTriangleIndices;\n  indices.indexDatatype = IndexDatatype.fromTypedArray(indices.typedArray);\n\n  // The outline generator creates a new attribute for the outline coordinates\n  // that are used with a lookup texture.\n  const outlineCoordinates = makeOutlineCoordinatesAttribute(generator.outlineCoordinates);\n  const outlineCoordinatesPlan = new AttributeLoadPlan(outlineCoordinates);\n  outlineCoordinatesPlan.loadBuffer = true;\n  outlineCoordinatesPlan.loadTypedArray = false;\n  loadPlan.attributePlans.push(outlineCoordinatesPlan);\n  primitive.outlineCoordinates = outlineCoordinatesPlan.attribute;\n\n  // Some vertices may be copied due to the addition of the new attribute\n  // which may have multiple values at a vertex depending on the face\n  const attributePlans = loadPlan.attributePlans;\n  const attributesLength = loadPlan.attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attribute = attributePlans[i].attribute;\n    attribute.typedArray = generator.updateAttribute(attribute.typedArray);\n  }\n}\nfunction makeOutlineCoordinatesAttribute(outlineCoordinatesTypedArray) {\n  const attribute = new ModelComponents.Attribute();\n  attribute.name = \"_OUTLINE_COORDINATES\";\n  attribute.typedArray = outlineCoordinatesTypedArray;\n  attribute.componentDatatype = ComponentDatatype.FLOAT;\n  attribute.type = AttributeType.VEC3;\n  attribute.normalized = false;\n  attribute.count = outlineCoordinatesTypedArray.length / 3;\n  return attribute;\n}\nfunction generateBuffers(loadPlan, context) {\n  generateAttributeBuffers(loadPlan.attributePlans, context);\n  if (defined(loadPlan.indicesPlan)) {\n    generateIndexBuffers(loadPlan.indicesPlan, context);\n  }\n}\nfunction generateAttributeBuffers(attributePlans, context) {\n  const attributesLength = attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attributePlan = attributePlans[i];\n    const attribute = attributePlan.attribute;\n    const typedArray = attribute.typedArray;\n    if (attributePlan.loadBuffer) {\n      const buffer = Buffer.createVertexBuffer({\n        typedArray: typedArray,\n        context: context,\n        usage: BufferUsage.STATIC_DRAW\n      });\n      buffer.vertexArrayDestroyable = false;\n      attribute.buffer = buffer;\n    }\n    if (!attributePlan.loadTypedArray) {\n      attribute.typedArray = undefined;\n    }\n  }\n}\nfunction generateIndexBuffers(indicesPlan, context) {\n  const indices = indicesPlan.indices;\n  if (indicesPlan.loadBuffer) {\n    const buffer = Buffer.createIndexBuffer({\n      typedArray: indices.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: indices.indexDatatype\n    });\n    indices.buffer = buffer;\n    buffer.vertexArrayDestroyable = false;\n  }\n  if (!indicesPlan.loadTypedArray) {\n    indices.typedArray = undefined;\n  }\n}\nPrimitiveLoadPlan.AttributeLoadPlan = AttributeLoadPlan;\nPrimitiveLoadPlan.IndicesLoadPlan = IndicesLoadPlan;\nexport default PrimitiveLoadPlan;","map":{"version":3,"names":["Check","ComponentDatatype","defined","IndexDatatype","Buffer","BufferUsage","AttributeType","ModelComponents","PrimitiveOutlineGenerator","AttributeLoadPlan","attribute","typeOf","object","loadBuffer","loadTypedArray","IndicesLoadPlan","indices","PrimitiveLoadPlan","primitive","attributePlans","indicesPlan","undefined","needsOutlines","outlineIndices","prototype","postProcess","context","generateOutlines","generateBuffers","loadPlan","vertexCount","attributes","count","generator","triangleIndices","typedArray","originalVertexCount","updatedTriangleIndices","indexDatatype","fromTypedArray","outlineCoordinates","makeOutlineCoordinatesAttribute","outlineCoordinatesPlan","push","attributesLength","length","i","updateAttribute","outlineCoordinatesTypedArray","Attribute","name","componentDatatype","FLOAT","type","VEC3","normalized","generateAttributeBuffers","generateIndexBuffers","attributePlan","buffer","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","createIndexBuffer"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PrimitiveLoadPlan.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport PrimitiveOutlineGenerator from \"./Model/PrimitiveOutlineGenerator.js\";\n\n/**\n * Simple struct for tracking whether an attribute will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.AttributeLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Attribute} attribute The attribute to be updated\n *\n * @private\n */\nfunction AttributeLoadPlan(attribute) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"attribute\", attribute);\n  //>>includeEnd('debug');\n\n  /**\n   * The attribute to track.\n   *\n   * @type {ModelComponents.Attribute}\n   * @readonly\n   * @private\n   */\n  this.attribute = attribute;\n\n  /**\n   * Whether the attribute will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the attribute will be loaded as a packed typed array by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Simple struct for tracking whether an index buffer will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.IndicesLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Indices} indices The indices to be updated\n *\n * @private\n */\nfunction IndicesLoadPlan(indices) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"indices\", indices);\n  //>>includeEnd('debug');\n\n  /**\n   * The indices to track.\n   *\n   * @type {ModelComponents.Indices}\n   * @readonly\n   * @private\n   */\n  this.indices = indices;\n\n  /**\n   * Whether the indices will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the indices will be loaded as a typed array copy of the GPU\n   * buffer by the time {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Primitives may need post-processing steps after their attributes and indices\n * have loaded, such as generating outlines for the CESIUM_primitive_outline glTF\n * extension. This object tracks what indices and attributes need to be\n * post-processed.\n *\n * @alias PrimitiveLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Primitive} primitive The primitive to track\n *\n * @private\n */\nfunction PrimitiveLoadPlan(primitive) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"primitive\", primitive);\n  //>>includeEnd('debug');\n\n  /**\n   * The primitive to track.\n   *\n   * @type {ModelComponents.Primitive}\n   * @readonly\n   * @private\n   */\n  this.primitive = primitive;\n\n  /**\n   * A flat list of attributes that need to be post-processed. This includes\n   * both regular attributes and morph target attributes.\n   *\n   * @type {PrimitiveLoadPlan.AttributeLoadPlan[]}\n   * @private\n   */\n  this.attributePlans = [];\n\n  /**\n   * Information about the triangle indices that need to be post-processed,\n   * if they exist.\n   *\n   * @type {PrimitiveLoadPlan.IndicesLoadPlan}\n   * @private\n   */\n  this.indicesPlan = undefined;\n\n  /**\n   * Set this true to indicate that the primitive has the\n   * CESIUM_primitive_outline extension and needs to be post-processed\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.needsOutlines = false;\n\n  /**\n   * The outline edge indices from the CESIUM_primitive_outline extension\n   *\n   * @type {number[]}\n   * @private\n   */\n  this.outlineIndices = undefined;\n}\n\n/**\n * Apply post-processing steps that may modify geometry such as generating\n * outline coordinates. If no post-processing steps are needed, this function\n * is a no-op.\n *\n * @param {Context} context The context for generating buffers on the GPU\n */\nPrimitiveLoadPlan.prototype.postProcess = function (context) {\n  // Handle CESIUM_primitive_outline. This modifies indices and attributes and\n  // also generates a new attribute for the outline coordinates. These steps\n  // are synchronous.\n  if (this.needsOutlines) {\n    generateOutlines(this);\n    generateBuffers(this, context);\n  }\n};\n\nfunction generateOutlines(loadPlan) {\n  const primitive = loadPlan.primitive;\n  const indices = primitive.indices;\n\n  const vertexCount = primitive.attributes[0].count;\n\n  const generator = new PrimitiveOutlineGenerator({\n    triangleIndices: indices.typedArray,\n    outlineIndices: loadPlan.outlineIndices,\n    originalVertexCount: vertexCount,\n  });\n\n  // The generator modifies/adds indices. In some uncommon cases it may have\n  // to upgrade to 16- or 32-bit indices so the datatype may change.\n  indices.typedArray = generator.updatedTriangleIndices;\n  indices.indexDatatype = IndexDatatype.fromTypedArray(indices.typedArray);\n\n  // The outline generator creates a new attribute for the outline coordinates\n  // that are used with a lookup texture.\n  const outlineCoordinates = makeOutlineCoordinatesAttribute(\n    generator.outlineCoordinates,\n  );\n  const outlineCoordinatesPlan = new AttributeLoadPlan(outlineCoordinates);\n  outlineCoordinatesPlan.loadBuffer = true;\n  outlineCoordinatesPlan.loadTypedArray = false;\n  loadPlan.attributePlans.push(outlineCoordinatesPlan);\n  primitive.outlineCoordinates = outlineCoordinatesPlan.attribute;\n\n  // Some vertices may be copied due to the addition of the new attribute\n  // which may have multiple values at a vertex depending on the face\n  const attributePlans = loadPlan.attributePlans;\n  const attributesLength = loadPlan.attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attribute = attributePlans[i].attribute;\n    attribute.typedArray = generator.updateAttribute(attribute.typedArray);\n  }\n}\n\nfunction makeOutlineCoordinatesAttribute(outlineCoordinatesTypedArray) {\n  const attribute = new ModelComponents.Attribute();\n  attribute.name = \"_OUTLINE_COORDINATES\";\n  attribute.typedArray = outlineCoordinatesTypedArray;\n  attribute.componentDatatype = ComponentDatatype.FLOAT;\n  attribute.type = AttributeType.VEC3;\n  attribute.normalized = false;\n  attribute.count = outlineCoordinatesTypedArray.length / 3;\n\n  return attribute;\n}\n\nfunction generateBuffers(loadPlan, context) {\n  generateAttributeBuffers(loadPlan.attributePlans, context);\n\n  if (defined(loadPlan.indicesPlan)) {\n    generateIndexBuffers(loadPlan.indicesPlan, context);\n  }\n}\n\nfunction generateAttributeBuffers(attributePlans, context) {\n  const attributesLength = attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attributePlan = attributePlans[i];\n    const attribute = attributePlan.attribute;\n    const typedArray = attribute.typedArray;\n\n    if (attributePlan.loadBuffer) {\n      const buffer = Buffer.createVertexBuffer({\n        typedArray: typedArray,\n        context: context,\n        usage: BufferUsage.STATIC_DRAW,\n      });\n      buffer.vertexArrayDestroyable = false;\n      attribute.buffer = buffer;\n    }\n\n    if (!attributePlan.loadTypedArray) {\n      attribute.typedArray = undefined;\n    }\n  }\n}\n\nfunction generateIndexBuffers(indicesPlan, context) {\n  const indices = indicesPlan.indices;\n  if (indicesPlan.loadBuffer) {\n    const buffer = Buffer.createIndexBuffer({\n      typedArray: indices.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: indices.indexDatatype,\n    });\n    indices.buffer = buffer;\n    buffer.vertexArrayDestroyable = false;\n  }\n\n  if (!indicesPlan.loadTypedArray) {\n    indices.typedArray = undefined;\n  }\n}\n\nPrimitiveLoadPlan.AttributeLoadPlan = AttributeLoadPlan;\nPrimitiveLoadPlan.IndicesLoadPlan = IndicesLoadPlan;\nexport default PrimitiveLoadPlan;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}