{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Rectangle from \"./Rectangle.js\";\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst sqrt = Math.sqrt;\n\n/**\n * @private\n */\nconst RectangleGeometryLibrary = {};\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computePosition = function (computedOptions, ellipsoid, computeST, row, col, position, st) {\n  const radiiSquared = ellipsoid.radiiSquared;\n  const nwCorner = computedOptions.nwCorner;\n  const rectangle = computedOptions.boundingRectangle;\n  let stLatitude = nwCorner.latitude - computedOptions.granYCos * row + col * computedOptions.granXSin;\n  const cosLatitude = cos(stLatitude);\n  const nZ = sin(stLatitude);\n  const kZ = radiiSquared.z * nZ;\n  let stLongitude = nwCorner.longitude + row * computedOptions.granYSin + col * computedOptions.granXCos;\n  const nX = cosLatitude * cos(stLongitude);\n  const nY = cosLatitude * sin(stLongitude);\n  const kX = radiiSquared.x * nX;\n  const kY = radiiSquared.y * nY;\n  const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n  position.x = kX / gamma;\n  position.y = kY / gamma;\n  position.z = kZ / gamma;\n  if (computeST) {\n    const stNwCorner = computedOptions.stNwCorner;\n    if (defined(stNwCorner)) {\n      stLatitude = stNwCorner.latitude - computedOptions.stGranYCos * row + col * computedOptions.stGranXSin;\n      stLongitude = stNwCorner.longitude + row * computedOptions.stGranYSin + col * computedOptions.stGranXCos;\n      st.x = (stLongitude - computedOptions.stWest) * computedOptions.lonScalar;\n      st.y = (stLatitude - computedOptions.stSouth) * computedOptions.latScalar;\n    } else {\n      st.x = (stLongitude - rectangle.west) * computedOptions.lonScalar;\n      st.y = (stLatitude - rectangle.south) * computedOptions.latScalar;\n    }\n  }\n};\nconst rotationMatrixScratch = new Matrix2();\nlet nwCartesian = new Cartesian3();\nconst centerScratch = new Cartographic();\nlet centerCartesian = new Cartesian3();\nconst proj = new GeographicProjection();\nfunction getRotationOptions(nwCorner, rotation, granularityX, granularityY, center, width, height) {\n  const cosRotation = Math.cos(rotation);\n  const granYCos = granularityY * cosRotation;\n  const granXCos = granularityX * cosRotation;\n  const sinRotation = Math.sin(rotation);\n  const granYSin = granularityY * sinRotation;\n  const granXSin = granularityX * sinRotation;\n  proj._ellipsoid = Ellipsoid.default;\n  nwCartesian = proj.project(nwCorner, nwCartesian);\n  nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\n  const rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\n  nwCartesian = Matrix2.multiplyByVector(rotationMatrix, nwCartesian, nwCartesian);\n  nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\n  nwCorner = proj.unproject(nwCartesian, nwCorner);\n  width -= 1;\n  height -= 1;\n  const latitude = nwCorner.latitude;\n  const latitude0 = latitude + width * granXSin;\n  const latitude1 = latitude - granYCos * height;\n  const latitude2 = latitude - granYCos * height + width * granXSin;\n  const north = Math.max(latitude, latitude0, latitude1, latitude2);\n  const south = Math.min(latitude, latitude0, latitude1, latitude2);\n  const longitude = nwCorner.longitude;\n  const longitude0 = longitude + width * granXCos;\n  const longitude1 = longitude + height * granYSin;\n  const longitude2 = longitude + height * granYSin + width * granXCos;\n  const east = Math.max(longitude, longitude0, longitude1, longitude2);\n  const west = Math.min(longitude, longitude0, longitude1, longitude2);\n  return {\n    north: north,\n    south: south,\n    east: east,\n    west: west,\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner\n  };\n}\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computeOptions = function (rectangle, granularity, rotation, stRotation, boundingRectangleScratch, nwCornerResult, stNwCornerResult) {\n  let east = rectangle.east;\n  let west = rectangle.west;\n  let north = rectangle.north;\n  let south = rectangle.south;\n  let northCap = false;\n  let southCap = false;\n  if (north === CesiumMath.PI_OVER_TWO) {\n    northCap = true;\n  }\n  if (south === -CesiumMath.PI_OVER_TWO) {\n    southCap = true;\n  }\n  let dx;\n  const dy = north - south;\n  if (west > east) {\n    dx = CesiumMath.TWO_PI - west + east;\n  } else {\n    dx = east - west;\n  }\n  const width = Math.ceil(dx / granularity) + 1;\n  const height = Math.ceil(dy / granularity) + 1;\n  const granularityX = dx / (width - 1);\n  const granularityY = dy / (height - 1);\n  const nwCorner = Rectangle.northwest(rectangle, nwCornerResult);\n  const center = Rectangle.center(rectangle, centerScratch);\n  if (rotation !== 0 || stRotation !== 0) {\n    if (center.longitude < nwCorner.longitude) {\n      center.longitude += CesiumMath.TWO_PI;\n    }\n    proj._ellipsoid = Ellipsoid.default;\n    centerCartesian = proj.project(center, centerCartesian);\n  }\n  const granYCos = granularityY;\n  const granXCos = granularityX;\n  const granYSin = 0.0;\n  const granXSin = 0.0;\n  const boundingRectangle = Rectangle.clone(rectangle, boundingRectangleScratch);\n  const computedOptions = {\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n    boundingRectangle: boundingRectangle,\n    width: width,\n    height: height,\n    northCap: northCap,\n    southCap: southCap\n  };\n  if (rotation !== 0) {\n    const rotationOptions = getRotationOptions(nwCorner, rotation, granularityX, granularityY, center, width, height);\n    north = rotationOptions.north;\n    south = rotationOptions.south;\n    east = rotationOptions.east;\n    west = rotationOptions.west;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO || south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {\n      throw new DeveloperError(\"Rotated rectangle is invalid.  It crosses over either the north or south pole.\");\n    }\n    //>>includeEnd('debug')\n\n    computedOptions.granYCos = rotationOptions.granYCos;\n    computedOptions.granYSin = rotationOptions.granYSin;\n    computedOptions.granXCos = rotationOptions.granXCos;\n    computedOptions.granXSin = rotationOptions.granXSin;\n    boundingRectangle.north = north;\n    boundingRectangle.south = south;\n    boundingRectangle.east = east;\n    boundingRectangle.west = west;\n  }\n  if (stRotation !== 0) {\n    rotation = rotation - stRotation;\n    const stNwCorner = Rectangle.northwest(boundingRectangle, stNwCornerResult);\n    const stRotationOptions = getRotationOptions(stNwCorner, rotation, granularityX, granularityY, center, width, height);\n    computedOptions.stGranYCos = stRotationOptions.granYCos;\n    computedOptions.stGranXCos = stRotationOptions.granXCos;\n    computedOptions.stGranYSin = stRotationOptions.granYSin;\n    computedOptions.stGranXSin = stRotationOptions.granXSin;\n    computedOptions.stNwCorner = stNwCorner;\n    computedOptions.stWest = stRotationOptions.west;\n    computedOptions.stSouth = stRotationOptions.south;\n  }\n  return computedOptions;\n};\nexport default RectangleGeometryLibrary;","map":{"version":3,"names":["Cartesian3","Cartographic","defined","DeveloperError","Ellipsoid","GeographicProjection","CesiumMath","Matrix2","Rectangle","cos","Math","sin","sqrt","RectangleGeometryLibrary","computePosition","computedOptions","ellipsoid","computeST","row","col","position","st","radiiSquared","nwCorner","rectangle","boundingRectangle","stLatitude","latitude","granYCos","granXSin","cosLatitude","nZ","kZ","z","stLongitude","longitude","granYSin","granXCos","nX","nY","kX","x","kY","y","gamma","stNwCorner","stGranYCos","stGranXSin","stGranYSin","stGranXCos","stWest","lonScalar","stSouth","latScalar","west","south","rotationMatrixScratch","nwCartesian","centerScratch","centerCartesian","proj","getRotationOptions","rotation","granularityX","granularityY","center","width","height","cosRotation","sinRotation","_ellipsoid","default","project","subtract","rotationMatrix","fromRotation","multiplyByVector","add","unproject","latitude0","latitude1","latitude2","north","max","min","longitude0","longitude1","longitude2","east","computeOptions","granularity","stRotation","boundingRectangleScratch","nwCornerResult","stNwCornerResult","northCap","southCap","PI_OVER_TWO","dx","dy","TWO_PI","ceil","northwest","clone","rotationOptions","stRotationOptions"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/RectangleGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Rectangle from \"./Rectangle.js\";\n\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst sqrt = Math.sqrt;\n\n/**\n * @private\n */\nconst RectangleGeometryLibrary = {};\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computePosition = function (\n  computedOptions,\n  ellipsoid,\n  computeST,\n  row,\n  col,\n  position,\n  st,\n) {\n  const radiiSquared = ellipsoid.radiiSquared;\n  const nwCorner = computedOptions.nwCorner;\n  const rectangle = computedOptions.boundingRectangle;\n\n  let stLatitude =\n    nwCorner.latitude -\n    computedOptions.granYCos * row +\n    col * computedOptions.granXSin;\n  const cosLatitude = cos(stLatitude);\n  const nZ = sin(stLatitude);\n  const kZ = radiiSquared.z * nZ;\n\n  let stLongitude =\n    nwCorner.longitude +\n    row * computedOptions.granYSin +\n    col * computedOptions.granXCos;\n  const nX = cosLatitude * cos(stLongitude);\n  const nY = cosLatitude * sin(stLongitude);\n\n  const kX = radiiSquared.x * nX;\n  const kY = radiiSquared.y * nY;\n\n  const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n\n  position.x = kX / gamma;\n  position.y = kY / gamma;\n  position.z = kZ / gamma;\n\n  if (computeST) {\n    const stNwCorner = computedOptions.stNwCorner;\n    if (defined(stNwCorner)) {\n      stLatitude =\n        stNwCorner.latitude -\n        computedOptions.stGranYCos * row +\n        col * computedOptions.stGranXSin;\n      stLongitude =\n        stNwCorner.longitude +\n        row * computedOptions.stGranYSin +\n        col * computedOptions.stGranXCos;\n\n      st.x = (stLongitude - computedOptions.stWest) * computedOptions.lonScalar;\n      st.y = (stLatitude - computedOptions.stSouth) * computedOptions.latScalar;\n    } else {\n      st.x = (stLongitude - rectangle.west) * computedOptions.lonScalar;\n      st.y = (stLatitude - rectangle.south) * computedOptions.latScalar;\n    }\n  }\n};\n\nconst rotationMatrixScratch = new Matrix2();\nlet nwCartesian = new Cartesian3();\nconst centerScratch = new Cartographic();\nlet centerCartesian = new Cartesian3();\nconst proj = new GeographicProjection();\n\nfunction getRotationOptions(\n  nwCorner,\n  rotation,\n  granularityX,\n  granularityY,\n  center,\n  width,\n  height,\n) {\n  const cosRotation = Math.cos(rotation);\n  const granYCos = granularityY * cosRotation;\n  const granXCos = granularityX * cosRotation;\n\n  const sinRotation = Math.sin(rotation);\n  const granYSin = granularityY * sinRotation;\n  const granXSin = granularityX * sinRotation;\n\n  proj._ellipsoid = Ellipsoid.default;\n  nwCartesian = proj.project(nwCorner, nwCartesian);\n\n  nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\n  const rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\n  nwCartesian = Matrix2.multiplyByVector(\n    rotationMatrix,\n    nwCartesian,\n    nwCartesian,\n  );\n  nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\n  nwCorner = proj.unproject(nwCartesian, nwCorner);\n\n  width -= 1;\n  height -= 1;\n\n  const latitude = nwCorner.latitude;\n  const latitude0 = latitude + width * granXSin;\n  const latitude1 = latitude - granYCos * height;\n  const latitude2 = latitude - granYCos * height + width * granXSin;\n\n  const north = Math.max(latitude, latitude0, latitude1, latitude2);\n  const south = Math.min(latitude, latitude0, latitude1, latitude2);\n\n  const longitude = nwCorner.longitude;\n  const longitude0 = longitude + width * granXCos;\n  const longitude1 = longitude + height * granYSin;\n  const longitude2 = longitude + height * granYSin + width * granXCos;\n\n  const east = Math.max(longitude, longitude0, longitude1, longitude2);\n  const west = Math.min(longitude, longitude0, longitude1, longitude2);\n\n  return {\n    north: north,\n    south: south,\n    east: east,\n    west: west,\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n  };\n}\n\n/**\n * @private\n */\nRectangleGeometryLibrary.computeOptions = function (\n  rectangle,\n  granularity,\n  rotation,\n  stRotation,\n  boundingRectangleScratch,\n  nwCornerResult,\n  stNwCornerResult,\n) {\n  let east = rectangle.east;\n  let west = rectangle.west;\n  let north = rectangle.north;\n  let south = rectangle.south;\n\n  let northCap = false;\n  let southCap = false;\n\n  if (north === CesiumMath.PI_OVER_TWO) {\n    northCap = true;\n  }\n  if (south === -CesiumMath.PI_OVER_TWO) {\n    southCap = true;\n  }\n\n  let dx;\n  const dy = north - south;\n  if (west > east) {\n    dx = CesiumMath.TWO_PI - west + east;\n  } else {\n    dx = east - west;\n  }\n\n  const width = Math.ceil(dx / granularity) + 1;\n  const height = Math.ceil(dy / granularity) + 1;\n  const granularityX = dx / (width - 1);\n  const granularityY = dy / (height - 1);\n\n  const nwCorner = Rectangle.northwest(rectangle, nwCornerResult);\n  const center = Rectangle.center(rectangle, centerScratch);\n  if (rotation !== 0 || stRotation !== 0) {\n    if (center.longitude < nwCorner.longitude) {\n      center.longitude += CesiumMath.TWO_PI;\n    }\n    proj._ellipsoid = Ellipsoid.default;\n    centerCartesian = proj.project(center, centerCartesian);\n  }\n\n  const granYCos = granularityY;\n  const granXCos = granularityX;\n  const granYSin = 0.0;\n  const granXSin = 0.0;\n\n  const boundingRectangle = Rectangle.clone(\n    rectangle,\n    boundingRectangleScratch,\n  );\n\n  const computedOptions = {\n    granYCos: granYCos,\n    granYSin: granYSin,\n    granXCos: granXCos,\n    granXSin: granXSin,\n    nwCorner: nwCorner,\n    boundingRectangle: boundingRectangle,\n    width: width,\n    height: height,\n    northCap: northCap,\n    southCap: southCap,\n  };\n\n  if (rotation !== 0) {\n    const rotationOptions = getRotationOptions(\n      nwCorner,\n      rotation,\n      granularityX,\n      granularityY,\n      center,\n      width,\n      height,\n    );\n    north = rotationOptions.north;\n    south = rotationOptions.south;\n    east = rotationOptions.east;\n    west = rotationOptions.west;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      north < -CesiumMath.PI_OVER_TWO ||\n      north > CesiumMath.PI_OVER_TWO ||\n      south < -CesiumMath.PI_OVER_TWO ||\n      south > CesiumMath.PI_OVER_TWO\n    ) {\n      throw new DeveloperError(\n        \"Rotated rectangle is invalid.  It crosses over either the north or south pole.\",\n      );\n    }\n    //>>includeEnd('debug')\n\n    computedOptions.granYCos = rotationOptions.granYCos;\n    computedOptions.granYSin = rotationOptions.granYSin;\n    computedOptions.granXCos = rotationOptions.granXCos;\n    computedOptions.granXSin = rotationOptions.granXSin;\n\n    boundingRectangle.north = north;\n    boundingRectangle.south = south;\n    boundingRectangle.east = east;\n    boundingRectangle.west = west;\n  }\n\n  if (stRotation !== 0) {\n    rotation = rotation - stRotation;\n    const stNwCorner = Rectangle.northwest(boundingRectangle, stNwCornerResult);\n\n    const stRotationOptions = getRotationOptions(\n      stNwCorner,\n      rotation,\n      granularityX,\n      granularityY,\n      center,\n      width,\n      height,\n    );\n\n    computedOptions.stGranYCos = stRotationOptions.granYCos;\n    computedOptions.stGranXCos = stRotationOptions.granXCos;\n    computedOptions.stGranYSin = stRotationOptions.granYSin;\n    computedOptions.stGranXSin = stRotationOptions.granXSin;\n    computedOptions.stNwCorner = stNwCorner;\n    computedOptions.stWest = stRotationOptions.west;\n    computedOptions.stSouth = stRotationOptions.south;\n  }\n\n  return computedOptions;\n};\nexport default RectangleGeometryLibrary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}