{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nconst CorridorGeometryLibrary = {};\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\nconst scratch3 = new Cartesian3();\nconst scratch4 = new Cartesian3();\nconst scaleArray2 = [new Cartesian3(), new Cartesian3()];\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\nconst cartesian7 = new Cartesian3();\nconst cartesian8 = new Cartesian3();\nconst cartesian9 = new Cartesian3();\nconst cartesian10 = new Cartesian3();\nconst quaterion = new Quaternion();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\n  const angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\n  const granularity = cornerType === CornerType.BEVELED ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n  const size = granularity * 3;\n  const array = new Array(size);\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\n  } else {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\n  }\n  let index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (let i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n  return array;\n}\nfunction addEndCaps(calculatedPositions) {\n  let cornerPoint = cartesian1;\n  let startPoint = cartesian2;\n  let endPoint = cartesian3;\n  let leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n  const length = calculatedPositions.length - 1;\n  const rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n  return [firstEndCap, lastEndCap];\n}\nfunction computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\n  let cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\n}\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  const rightPositions = new Array(positions.length);\n  const leftPositions = new Array(positions.length);\n  const scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  const scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  let rightIndex = 0;\n  let leftIndex = positions.length - 1;\n  for (let i = 0; i < positions.length; i += 3) {\n    const pos = Cartesian3.fromArray(positions, i, scratch3);\n    const rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n    const leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (attribute, value, front, back) {\n  const x = value.x;\n  const y = value.y;\n  const z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  const granularity = params.granularity;\n  const positions = params.positions;\n  const ellipsoid = params.ellipsoid;\n  const width = params.width / 2;\n  const cornerType = params.cornerType;\n  const saveAttributes = params.saveAttributes;\n  let normal = cartesian1;\n  let forward = cartesian2;\n  let backward = cartesian3;\n  let left = cartesian4;\n  let cornerDirection = cartesian5;\n  let startPoint = cartesian6;\n  let previousPos = cartesian7;\n  let rightPos = cartesian8;\n  let leftPos = cartesian9;\n  let center = cartesian10;\n  let calculatedPositions = [];\n  const calculatedLefts = saveAttributes ? [] : undefined;\n  const calculatedNormals = saveAttributes ? [] : undefined;\n  let position = positions[0]; //add first point\n  let nextPosition = positions[1];\n  forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  let subdividedPositions;\n  const corners = [];\n  let i;\n  const length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n    const forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n    const backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n    const doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n    if (doCorner) {\n      cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\n      cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\n      cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n      cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\n        leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n        previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          corners.push({\n            leftPositions: computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\n        rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n        previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          corners.push({\n            rightPositions: computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid\n  });\n  calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  let endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions\n  };\n};\nexport default CorridorGeometryLibrary;","map":{"version":3,"names":["Cartesian3","CornerType","defined","CesiumMath","Matrix3","PolylinePipeline","PolylineVolumeGeometryLibrary","Quaternion","CorridorGeometryLibrary","scratch1","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","rotMatrix","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","angle","angleBetween","subtract","granularity","BEVELED","Math","ceil","toRadians","size","array","Array","x","y","z","m","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","addEndCaps","calculatedPositions","leftEdge","fromArray","length","midpoint","firstEndCap","ROUNDED","rightEdge","lastEndCap","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","rightPositions","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","rightPos","leftPos","push","addAttribute","attribute","value","front","back","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","nextPosition","normalize","geodeticSurfaceNormal","cross","subdividedPositions","corners","forwardProjection","dot","backwardProjection","doCorner","equalsEpsilon","abs","EPSILON7","max","magnitude","angleIsGreaterThanPi","generateArc","endPositions","lefts","normals"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nconst CorridorGeometryLibrary = {};\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\nconst scratch3 = new Cartesian3();\nconst scratch4 = new Cartesian3();\n\nconst scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\nconst cartesian7 = new Cartesian3();\nconst cartesian8 = new Cartesian3();\nconst cartesian9 = new Cartesian3();\nconst cartesian10 = new Cartesian3();\n\nconst quaterion = new Quaternion();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  cornerPoint,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2),\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 1\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n  const size = granularity * 3;\n  const array = new Array(size);\n\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(cornerPoint, scratch1),\n        angle / granularity,\n        quaterion,\n      ),\n      rotMatrix,\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\n      rotMatrix,\n    );\n  }\n\n  let index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (let i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  let cornerPoint = cartesian1;\n  let startPoint = cartesian2;\n  let endPoint = cartesian3;\n\n  let leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(\n    calculatedPositions[1],\n    leftEdge.length - 3,\n    startPoint,\n  );\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const firstEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false,\n  );\n\n  const length = calculatedPositions.length - 1;\n  const rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(\n    rightEdge,\n    rightEdge.length - 3,\n    startPoint,\n  );\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const lastEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false,\n  );\n\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(\n  position,\n  leftCornerDirection,\n  lastPoint,\n  leftIsOutside,\n) {\n  let cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(\n      leftCornerDirection,\n      leftCornerDirection,\n    );\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [\n    cornerPoint.x,\n    cornerPoint.y,\n    cornerPoint.z,\n    lastPoint.x,\n    lastPoint.y,\n    lastPoint.z,\n  ];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  const rightPositions = new Array(positions.length);\n  const leftPositions = new Array(positions.length);\n  const scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  const scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  let rightIndex = 0;\n  let leftIndex = positions.length - 1;\n\n  for (let i = 0; i < positions.length; i += 3) {\n    const pos = Cartesian3.fromArray(positions, i, scratch3);\n    const rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n\n    const leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (\n  attribute,\n  value,\n  front,\n  back,\n) {\n  const x = value.x;\n  const y = value.y;\n  const z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  const granularity = params.granularity;\n  const positions = params.positions;\n  const ellipsoid = params.ellipsoid;\n  const width = params.width / 2;\n  const cornerType = params.cornerType;\n  const saveAttributes = params.saveAttributes;\n  let normal = cartesian1;\n  let forward = cartesian2;\n  let backward = cartesian3;\n  let left = cartesian4;\n  let cornerDirection = cartesian5;\n  let startPoint = cartesian6;\n  let previousPos = cartesian7;\n  let rightPos = cartesian8;\n  let leftPos = cartesian9;\n  let center = cartesian10;\n  let calculatedPositions = [];\n  const calculatedLefts = saveAttributes ? [] : undefined;\n  const calculatedNormals = saveAttributes ? [] : undefined;\n  let position = positions[0]; //add first point\n  let nextPosition = positions[1];\n\n  forward = Cartesian3.normalize(\n    Cartesian3.subtract(nextPosition, position, forward),\n    forward,\n  );\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n\n  let subdividedPositions;\n  const corners = [];\n  let i;\n  const length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(\n      Cartesian3.subtract(nextPosition, position, forward),\n      forward,\n    );\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(forward, normal),\n      scratchForwardProjection,\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(backward, normal),\n      scratchBackwardProjection,\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7,\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.normalize(\n        Cartesian3.add(forward, backward, cornerDirection),\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        normal,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.cross(\n        normal,\n        cornerDirection,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        width /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1),\n          ),\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid,\n      );\n      cornerDirection = Cartesian3.multiplyByScalar(\n        cornerDirection,\n        scalar,\n        cornerDirection,\n      );\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, center),\n          center,\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos,\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions,\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left,\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos,\n        );\n        previousPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, previousPos),\n          previousPos,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            leftPositions: computeRoundCorner(\n              rightPos,\n              startPoint,\n              leftPos,\n              cornerType,\n              leftIsOutside,\n            ),\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(\n              position,\n              Cartesian3.negate(cornerDirection, cornerDirection),\n              leftPos,\n              leftIsOutside,\n            ),\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, center),\n            center,\n          ),\n          center,\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos,\n          ),\n          rightPos,\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions,\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left,\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos,\n          ),\n          rightPos,\n        );\n        previousPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, previousPos),\n            previousPos,\n          ),\n          previousPos,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            rightPositions: computeRoundCorner(\n              leftPos,\n              startPoint,\n              rightPos,\n              cornerType,\n              leftIsOutside,\n            ),\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(\n              position,\n              cornerDirection,\n              rightPos,\n              leftIsOutside,\n            ),\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  calculatedPositions = addShiftedPositions(\n    subdividedPositions,\n    left,\n    width,\n    calculatedPositions,\n  );\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  let endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions,\n  };\n};\nexport default CorridorGeometryLibrary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}