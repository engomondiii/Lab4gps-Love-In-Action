{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport HermiteSpline from \"./HermiteSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nconst scratchTimeVec = new Cartesian4();\nconst scratchTemp0 = new Cartesian3();\nconst scratchTemp1 = new Cartesian3();\nfunction createEvaluateFunction(spline) {\n  const points = spline.points;\n  const times = spline.times;\n  if (points.length < 3) {\n    const t0 = times[0];\n    const invSpan = 1.0 / (times[1] - t0);\n    const p0 = points[0];\n    const p1 = points[1];\n    return function (time, result) {\n      if (!defined(result)) {\n        result = new Cartesian3();\n      }\n      const u = (time - t0) * invSpan;\n      return Cartesian3.lerp(p0, p1, u, result);\n    };\n  }\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Cartesian3();\n    }\n    const i = spline._lastTimeIndex = spline.findTimeInterval(time, spline._lastTimeIndex);\n    const u = (time - times[i]) / (times[i + 1] - times[i]);\n    const timeVec = scratchTimeVec;\n    timeVec.z = u;\n    timeVec.y = u * u;\n    timeVec.x = timeVec.y * u;\n    timeVec.w = 1.0;\n    let p0;\n    let p1;\n    let p2;\n    let p3;\n    let coefs;\n    if (i === 0) {\n      p0 = points[0];\n      p1 = points[1];\n      p2 = spline.firstTangent;\n      p3 = Cartesian3.subtract(points[2], p0, scratchTemp0);\n      Cartesian3.multiplyByScalar(p3, 0.5, p3);\n      coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);\n    } else if (i === points.length - 2) {\n      p0 = points[i];\n      p1 = points[i + 1];\n      p3 = spline.lastTangent;\n      p2 = Cartesian3.subtract(p1, points[i - 1], scratchTemp0);\n      Cartesian3.multiplyByScalar(p2, 0.5, p2);\n      coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);\n    } else {\n      p0 = points[i - 1];\n      p1 = points[i];\n      p2 = points[i + 1];\n      p3 = points[i + 2];\n      coefs = Matrix4.multiplyByVector(CatmullRomSpline.catmullRomCoefficientMatrix, timeVec, timeVec);\n    }\n    result = Cartesian3.multiplyByScalar(p0, coefs.x, result);\n    Cartesian3.multiplyByScalar(p1, coefs.y, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p2, coefs.z, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p3, coefs.w, scratchTemp1);\n    return Cartesian3.add(result, scratchTemp1, result);\n  };\n}\nconst firstTangentScratch = new Cartesian3();\nconst lastTangentScratch = new Cartesian3();\n\n/**\n * A Catmull-Rom spline is a cubic spline where the tangent at control points,\n * except the first and last, are computed using the previous and next control points.\n * Catmull-Rom splines are in the class C<sup>1</sup>.\n *\n * @alias CatmullRomSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3} [options.firstTangent] The tangent of the curve at the first control point.\n *                     If the tangent is not given, it will be estimated.\n * @param {Cartesian3} [options.lastTangent] The tangent of the curve at the last control point.\n *                     If the tangent is not given, it will be estimated.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * // spline above the earth from Philadelphia to Los Angeles\n * const spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * const p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction CatmullRomSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const points = options.points;\n  const times = options.times;\n  let firstTangent = options.firstTangent;\n  let lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"points\", points);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"points.length\", points.length, 2);\n  Check.typeOf.number.equals(\"times.length\", \"points.length\", times.length, points.length);\n  //>>includeEnd('debug');\n\n  if (points.length > 2) {\n    if (!defined(firstTangent)) {\n      firstTangent = firstTangentScratch;\n      Cartesian3.multiplyByScalar(points[1], 2.0, firstTangent);\n      Cartesian3.subtract(firstTangent, points[2], firstTangent);\n      Cartesian3.subtract(firstTangent, points[0], firstTangent);\n      Cartesian3.multiplyByScalar(firstTangent, 0.5, firstTangent);\n    }\n    if (!defined(lastTangent)) {\n      const n = points.length - 1;\n      lastTangent = lastTangentScratch;\n      Cartesian3.multiplyByScalar(points[n - 1], 2.0, lastTangent);\n      Cartesian3.subtract(points[n], lastTangent, lastTangent);\n      Cartesian3.add(lastTangent, points[n - 2], lastTangent);\n      Cartesian3.multiplyByScalar(lastTangent, 0.5, lastTangent);\n    }\n  }\n  this._times = times;\n  this._points = points;\n  this._firstTangent = Cartesian3.clone(firstTangent);\n  this._lastTangent = Cartesian3.clone(lastTangent);\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\nObject.defineProperties(CatmullRomSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    }\n  },\n  /**\n   * The tangent at the first control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  firstTangent: {\n    get: function () {\n      return this._firstTangent;\n    }\n  },\n  /**\n   * The tangent at the last control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  lastTangent: {\n    get: function () {\n      return this._lastTangent;\n    }\n  }\n});\n\n/**\n * @private\n */\nCatmullRomSpline.catmullRomCoefficientMatrix = new Matrix4(-0.5, 1.0, -0.5, 0.0, 1.5, -2.5, 0.0, 1.0, -1.5, 2.0, 0.5, 0.0, 0.5, -0.5, 0.0, 0.0);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nCatmullRomSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nCatmullRomSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default CatmullRomSpline;","map":{"version":3,"names":["Cartesian3","Cartesian4","Check","defaultValue","defined","HermiteSpline","Matrix4","Spline","scratchTimeVec","scratchTemp0","scratchTemp1","createEvaluateFunction","spline","points","times","length","t0","invSpan","p0","p1","time","result","u","lerp","i","_lastTimeIndex","findTimeInterval","timeVec","z","y","x","w","p2","p3","coefs","firstTangent","subtract","multiplyByScalar","multiplyByVector","hermiteCoefficientMatrix","lastTangent","CatmullRomSpline","catmullRomCoefficientMatrix","add","firstTangentScratch","lastTangentScratch","options","EMPTY_OBJECT","typeOf","number","greaterThanOrEquals","equals","n","_times","_points","_firstTangent","clone","_lastTangent","_evaluateFunction","Object","defineProperties","prototype","get","wrapTime","clampTime","evaluate"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CatmullRomSpline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport HermiteSpline from \"./HermiteSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\n\nconst scratchTimeVec = new Cartesian4();\nconst scratchTemp0 = new Cartesian3();\nconst scratchTemp1 = new Cartesian3();\n\nfunction createEvaluateFunction(spline) {\n  const points = spline.points;\n  const times = spline.times;\n\n  if (points.length < 3) {\n    const t0 = times[0];\n    const invSpan = 1.0 / (times[1] - t0);\n\n    const p0 = points[0];\n    const p1 = points[1];\n\n    return function (time, result) {\n      if (!defined(result)) {\n        result = new Cartesian3();\n      }\n      const u = (time - t0) * invSpan;\n      return Cartesian3.lerp(p0, p1, u, result);\n    };\n  }\n\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Cartesian3();\n    }\n    const i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex,\n    ));\n    const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    const timeVec = scratchTimeVec;\n    timeVec.z = u;\n    timeVec.y = u * u;\n    timeVec.x = timeVec.y * u;\n    timeVec.w = 1.0;\n\n    let p0;\n    let p1;\n    let p2;\n    let p3;\n    let coefs;\n\n    if (i === 0) {\n      p0 = points[0];\n      p1 = points[1];\n      p2 = spline.firstTangent;\n\n      p3 = Cartesian3.subtract(points[2], p0, scratchTemp0);\n      Cartesian3.multiplyByScalar(p3, 0.5, p3);\n\n      coefs = Matrix4.multiplyByVector(\n        HermiteSpline.hermiteCoefficientMatrix,\n        timeVec,\n        timeVec,\n      );\n    } else if (i === points.length - 2) {\n      p0 = points[i];\n      p1 = points[i + 1];\n      p3 = spline.lastTangent;\n\n      p2 = Cartesian3.subtract(p1, points[i - 1], scratchTemp0);\n      Cartesian3.multiplyByScalar(p2, 0.5, p2);\n\n      coefs = Matrix4.multiplyByVector(\n        HermiteSpline.hermiteCoefficientMatrix,\n        timeVec,\n        timeVec,\n      );\n    } else {\n      p0 = points[i - 1];\n      p1 = points[i];\n      p2 = points[i + 1];\n      p3 = points[i + 2];\n      coefs = Matrix4.multiplyByVector(\n        CatmullRomSpline.catmullRomCoefficientMatrix,\n        timeVec,\n        timeVec,\n      );\n    }\n    result = Cartesian3.multiplyByScalar(p0, coefs.x, result);\n    Cartesian3.multiplyByScalar(p1, coefs.y, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p2, coefs.z, scratchTemp1);\n    Cartesian3.add(result, scratchTemp1, result);\n    Cartesian3.multiplyByScalar(p3, coefs.w, scratchTemp1);\n    return Cartesian3.add(result, scratchTemp1, result);\n  };\n}\n\nconst firstTangentScratch = new Cartesian3();\nconst lastTangentScratch = new Cartesian3();\n\n/**\n * A Catmull-Rom spline is a cubic spline where the tangent at control points,\n * except the first and last, are computed using the previous and next control points.\n * Catmull-Rom splines are in the class C<sup>1</sup>.\n *\n * @alias CatmullRomSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3} [options.firstTangent] The tangent of the curve at the first control point.\n *                     If the tangent is not given, it will be estimated.\n * @param {Cartesian3} [options.lastTangent] The tangent of the curve at the last control point.\n *                     If the tangent is not given, it will be estimated.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * // spline above the earth from Philadelphia to Los Angeles\n * const spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * const p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction CatmullRomSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const points = options.points;\n  const times = options.times;\n  let firstTangent = options.firstTangent;\n  let lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"points\", points);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"points.length\", points.length, 2);\n  Check.typeOf.number.equals(\n    \"times.length\",\n    \"points.length\",\n    times.length,\n    points.length,\n  );\n  //>>includeEnd('debug');\n\n  if (points.length > 2) {\n    if (!defined(firstTangent)) {\n      firstTangent = firstTangentScratch;\n      Cartesian3.multiplyByScalar(points[1], 2.0, firstTangent);\n      Cartesian3.subtract(firstTangent, points[2], firstTangent);\n      Cartesian3.subtract(firstTangent, points[0], firstTangent);\n      Cartesian3.multiplyByScalar(firstTangent, 0.5, firstTangent);\n    }\n\n    if (!defined(lastTangent)) {\n      const n = points.length - 1;\n      lastTangent = lastTangentScratch;\n      Cartesian3.multiplyByScalar(points[n - 1], 2.0, lastTangent);\n      Cartesian3.subtract(points[n], lastTangent, lastTangent);\n      Cartesian3.add(lastTangent, points[n - 2], lastTangent);\n      Cartesian3.multiplyByScalar(lastTangent, 0.5, lastTangent);\n    }\n  }\n\n  this._times = times;\n  this._points = points;\n  this._firstTangent = Cartesian3.clone(firstTangent);\n  this._lastTangent = Cartesian3.clone(lastTangent);\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(CatmullRomSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * The tangent at the first control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  firstTangent: {\n    get: function () {\n      return this._firstTangent;\n    },\n  },\n\n  /**\n   * The tangent at the last control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  lastTangent: {\n    get: function () {\n      return this._lastTangent;\n    },\n  },\n});\n\n/**\n * @private\n */\nCatmullRomSpline.catmullRomCoefficientMatrix = new Matrix4(\n  -0.5,\n  1.0,\n  -0.5,\n  0.0,\n  1.5,\n  -2.5,\n  0.0,\n  1.0,\n  -1.5,\n  2.0,\n  0.5,\n  0.0,\n  0.5,\n  -0.5,\n  0.0,\n  0.0,\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nCatmullRomSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nCatmullRomSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default CatmullRomSpline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}