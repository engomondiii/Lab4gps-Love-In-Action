{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport DepthPlaneFS from \"../Shaders/DepthPlaneFS.js\";\nimport DepthPlaneVS from \"../Shaders/DepthPlaneVS.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\n\n/**\n * @private\n */\nfunction DepthPlane(depthPlaneEllipsoidOffset) {\n  this._rs = undefined;\n  this._sp = undefined;\n  this._va = undefined;\n  this._command = undefined;\n  this._mode = undefined;\n  this._useLogDepth = false;\n  this._ellipsoidOffset = defaultValue(depthPlaneEllipsoidOffset, 0);\n}\nconst depthQuadScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(12) : [];\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nfunction computeDepthQuad(ellipsoid, frameState) {\n  const radii = ellipsoid.radii;\n  const camera = frameState.camera;\n  let center, eastOffset, northOffset;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    center = Cartesian3.ZERO;\n    eastOffset = camera.rightWC;\n    northOffset = camera.upWC;\n  } else {\n    const p = camera.positionWC;\n\n    // Find the corresponding position in the scaled space of the ellipsoid.\n    const q = Cartesian3.multiplyComponents(ellipsoid.oneOverRadii, p, scratchCartesian1);\n    const qUnit = Cartesian3.normalize(q, scratchCartesian2);\n\n    // Determine the east and north directions at q.\n    const eUnit = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, q, scratchCartesian3), scratchCartesian3);\n    const nUnit = Cartesian3.normalize(Cartesian3.cross(qUnit, eUnit, scratchCartesian4), scratchCartesian4);\n    const qMagnitude = Cartesian3.magnitude(q);\n\n    // Determine the radius of the 'limb' of the ellipsoid.\n    const wMagnitude = Math.sqrt(qMagnitude * qMagnitude - 1.0);\n\n    // Compute the center and offsets.\n    center = Cartesian3.multiplyByScalar(qUnit, 1.0 / qMagnitude, scratchCartesian1);\n    const scalar = wMagnitude / qMagnitude;\n    eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian2);\n    northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3);\n  }\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  Cartesian3.pack(upperLeft, depthQuadScratch, 0);\n  const lowerLeft = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  Cartesian3.pack(lowerLeft, depthQuadScratch, 3);\n  const upperRight = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  Cartesian3.pack(upperRight, depthQuadScratch, 6);\n  const lowerRight = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  Cartesian3.pack(lowerRight, depthQuadScratch, 9);\n  return depthQuadScratch;\n}\nDepthPlane.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    return;\n  }\n  const context = frameState.context;\n\n  // Allow offsetting the ellipsoid radius to address rendering artifacts below ellipsoid zero elevation.\n  const radii = frameState.mapProjection.ellipsoid.radii;\n  const ellipsoid = new Ellipsoid(radii.x + this._ellipsoidOffset, radii.y + this._ellipsoidOffset, radii.z + this._ellipsoidOffset);\n  const useLogDepth = frameState.useLogDepth;\n  if (!defined(this._command)) {\n    this._rs = RenderState.fromCache({\n      // Write depth, not color\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true\n      },\n      colorMask: {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false\n      }\n    });\n    this._command = new DrawCommand({\n      renderState: this._rs,\n      boundingVolume: new BoundingSphere(Cartesian3.ZERO, ellipsoid.maximumRadius),\n      pass: Pass.OPAQUE,\n      owner: this\n    });\n  }\n  if (!defined(this._sp) || this._useLogDepth !== useLogDepth) {\n    this._useLogDepth = useLogDepth;\n    const vs = new ShaderSource({\n      sources: [DepthPlaneVS]\n    });\n    const fs = new ShaderSource({\n      sources: [DepthPlaneFS]\n    });\n    if (useLogDepth) {\n      fs.defines.push(\"LOG_DEPTH\");\n      vs.defines.push(\"LOG_DEPTH\");\n    }\n    this._sp = ShaderProgram.replaceCache({\n      shaderProgram: this._sp,\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: {\n        position: 0\n      }\n    });\n    this._command.shaderProgram = this._sp;\n  }\n\n  // update depth plane\n  const depthQuad = computeDepthQuad(ellipsoid, frameState);\n\n  // depth plane\n  if (!defined(this._va)) {\n    const geometry = new Geometry({\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 3,\n          values: depthQuad\n        })\n      },\n      indices: [0, 1, 2, 2, 1, 3],\n      primitiveType: PrimitiveType.TRIANGLES\n    });\n    this._va = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: {\n        position: 0\n      },\n      bufferUsage: BufferUsage.DYNAMIC_DRAW\n    });\n    this._command.vertexArray = this._va;\n  } else {\n    this._va.getAttribute(0).vertexBuffer.copyFromArrayView(depthQuad);\n  }\n};\nDepthPlane.prototype.execute = function (context, passState) {\n  if (this._mode === SceneMode.SCENE3D) {\n    this._command.execute(context, passState);\n  }\n};\nDepthPlane.prototype.isDestroyed = function () {\n  return false;\n};\nDepthPlane.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._va = this._va && this._va.destroy();\n};\nexport default DepthPlane;","map":{"version":3,"names":["BoundingSphere","Cartesian3","ComponentDatatype","defined","FeatureDetection","Geometry","GeometryAttribute","OrthographicFrustum","PrimitiveType","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","DepthPlaneFS","DepthPlaneVS","SceneMode","defaultValue","Ellipsoid","DepthPlane","depthPlaneEllipsoidOffset","_rs","undefined","_sp","_va","_command","_mode","_useLogDepth","_ellipsoidOffset","depthQuadScratch","supportsTypedArrays","Float32Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","computeDepthQuad","ellipsoid","frameState","radii","camera","center","eastOffset","northOffset","frustum","ZERO","rightWC","upWC","p","positionWC","q","multiplyComponents","oneOverRadii","qUnit","normalize","eUnit","cross","UNIT_Z","nUnit","qMagnitude","magnitude","wMagnitude","Math","sqrt","multiplyByScalar","scalar","upperLeft","add","subtract","pack","lowerLeft","upperRight","lowerRight","prototype","update","mode","SCENE3D","context","mapProjection","x","y","z","useLogDepth","fromCache","cull","enabled","depthTest","colorMask","red","green","blue","alpha","renderState","boundingVolume","maximumRadius","pass","OPAQUE","owner","vs","sources","fs","defines","push","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","attributeLocations","position","depthQuad","geometry","attributes","componentDatatype","FLOAT","componentsPerAttribute","values","indices","primitiveType","TRIANGLES","fromGeometry","bufferUsage","DYNAMIC_DRAW","vertexArray","getAttribute","vertexBuffer","copyFromArrayView","execute","passState","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/DepthPlane.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport DepthPlaneFS from \"../Shaders/DepthPlaneFS.js\";\nimport DepthPlaneVS from \"../Shaders/DepthPlaneVS.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\n\n/**\n * @private\n */\nfunction DepthPlane(depthPlaneEllipsoidOffset) {\n  this._rs = undefined;\n  this._sp = undefined;\n  this._va = undefined;\n  this._command = undefined;\n  this._mode = undefined;\n  this._useLogDepth = false;\n  this._ellipsoidOffset = defaultValue(depthPlaneEllipsoidOffset, 0);\n}\n\nconst depthQuadScratch = FeatureDetection.supportsTypedArrays()\n  ? new Float32Array(12)\n  : [];\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\n\nfunction computeDepthQuad(ellipsoid, frameState) {\n  const radii = ellipsoid.radii;\n  const camera = frameState.camera;\n  let center, eastOffset, northOffset;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    center = Cartesian3.ZERO;\n    eastOffset = camera.rightWC;\n    northOffset = camera.upWC;\n  } else {\n    const p = camera.positionWC;\n\n    // Find the corresponding position in the scaled space of the ellipsoid.\n    const q = Cartesian3.multiplyComponents(\n      ellipsoid.oneOverRadii,\n      p,\n      scratchCartesian1,\n    );\n\n    const qUnit = Cartesian3.normalize(q, scratchCartesian2);\n\n    // Determine the east and north directions at q.\n    const eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, q, scratchCartesian3),\n      scratchCartesian3,\n    );\n    const nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian4),\n      scratchCartesian4,\n    );\n\n    const qMagnitude = Cartesian3.magnitude(q);\n\n    // Determine the radius of the 'limb' of the ellipsoid.\n    const wMagnitude = Math.sqrt(qMagnitude * qMagnitude - 1.0);\n\n    // Compute the center and offsets.\n    center = Cartesian3.multiplyByScalar(\n      qUnit,\n      1.0 / qMagnitude,\n      scratchCartesian1,\n    );\n    const scalar = wMagnitude / qMagnitude;\n    eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian2);\n    northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3);\n  }\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  Cartesian3.pack(upperLeft, depthQuadScratch, 0);\n\n  const lowerLeft = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  Cartesian3.pack(lowerLeft, depthQuadScratch, 3);\n\n  const upperRight = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  Cartesian3.pack(upperRight, depthQuadScratch, 6);\n\n  const lowerRight = Cartesian3.subtract(\n    center,\n    northOffset,\n    scratchCartesian5,\n  );\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  Cartesian3.pack(lowerRight, depthQuadScratch, 9);\n\n  return depthQuadScratch;\n}\n\nDepthPlane.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    return;\n  }\n\n  const context = frameState.context;\n\n  // Allow offsetting the ellipsoid radius to address rendering artifacts below ellipsoid zero elevation.\n  const radii = frameState.mapProjection.ellipsoid.radii;\n  const ellipsoid = new Ellipsoid(\n    radii.x + this._ellipsoidOffset,\n    radii.y + this._ellipsoidOffset,\n    radii.z + this._ellipsoidOffset,\n  );\n\n  const useLogDepth = frameState.useLogDepth;\n\n  if (!defined(this._command)) {\n    this._rs = RenderState.fromCache({\n      // Write depth, not color\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n      },\n      colorMask: {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false,\n      },\n    });\n\n    this._command = new DrawCommand({\n      renderState: this._rs,\n      boundingVolume: new BoundingSphere(\n        Cartesian3.ZERO,\n        ellipsoid.maximumRadius,\n      ),\n      pass: Pass.OPAQUE,\n      owner: this,\n    });\n  }\n\n  if (!defined(this._sp) || this._useLogDepth !== useLogDepth) {\n    this._useLogDepth = useLogDepth;\n\n    const vs = new ShaderSource({\n      sources: [DepthPlaneVS],\n    });\n    const fs = new ShaderSource({\n      sources: [DepthPlaneFS],\n    });\n    if (useLogDepth) {\n      fs.defines.push(\"LOG_DEPTH\");\n      vs.defines.push(\"LOG_DEPTH\");\n    }\n\n    this._sp = ShaderProgram.replaceCache({\n      shaderProgram: this._sp,\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: {\n        position: 0,\n      },\n    });\n\n    this._command.shaderProgram = this._sp;\n  }\n\n  // update depth plane\n  const depthQuad = computeDepthQuad(ellipsoid, frameState);\n\n  // depth plane\n  if (!defined(this._va)) {\n    const geometry = new Geometry({\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 3,\n          values: depthQuad,\n        }),\n      },\n      indices: [0, 1, 2, 2, 1, 3],\n      primitiveType: PrimitiveType.TRIANGLES,\n    });\n\n    this._va = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: {\n        position: 0,\n      },\n      bufferUsage: BufferUsage.DYNAMIC_DRAW,\n    });\n\n    this._command.vertexArray = this._va;\n  } else {\n    this._va.getAttribute(0).vertexBuffer.copyFromArrayView(depthQuad);\n  }\n};\n\nDepthPlane.prototype.execute = function (context, passState) {\n  if (this._mode === SceneMode.SCENE3D) {\n    this._command.execute(context, passState);\n  }\n};\n\nDepthPlane.prototype.isDestroyed = function () {\n  return false;\n};\n\nDepthPlane.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._va = this._va && this._va.destroy();\n};\nexport default DepthPlane;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}