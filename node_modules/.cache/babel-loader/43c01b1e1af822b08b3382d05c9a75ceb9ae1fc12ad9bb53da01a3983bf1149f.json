{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"precision highp float;\\n\\\n\\n\\\nin vec2 v_textureCoordinates;\\n\\\n\\n\\\nuniform vec3 u_faceDirection; // Current cubemap face\\n\\\nuniform vec3 u_positionWC;\\n\\\nuniform mat4 u_enuToFixedFrame;\\n\\\nuniform vec4 u_brightnessSaturationGammaIntensity;\\n\\\nuniform vec4 u_groundColor; // alpha component represent albedo\\n\\\n\\n\\\nvec4 getCubeMapDirection(vec2 uv, vec3 faceDir) {\\n\\\n    vec2 scaledUV = uv * 2.0 - 1.0;\\n\\\n\\n\\\n    if (faceDir.x != 0.0) {\\n\\\n        return vec4(faceDir.x,  scaledUV.x * faceDir.x, -scaledUV.y, 0.0);\\n\\\n    } else if (faceDir.y != 0.0) {\\n\\\n        return vec4(scaledUV.x, -scaledUV.y * faceDir.y, faceDir.y, 0.0);\\n\\\n    } else {\\n\\\n        return vec4(scaledUV.x * faceDir.z, -faceDir.z, -scaledUV.y, 0.0); \\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid main() {    \\n\\\n    float height = length(u_positionWC);\\n\\\n    float atmosphereInnerRadius = u_radiiAndDynamicAtmosphereColor.y;\\n\\\n    float ellipsoidHeight = max(height - atmosphereInnerRadius, 0.0);\\n\\\n\\n\\\n    // Scale the position to ensure the sky color is present, even when underground.\\n\\\n    vec3 positionWC = u_positionWC / height * (ellipsoidHeight + atmosphereInnerRadius);\\n\\\n\\n\\\n    float atmosphereOuterRadius = u_radiiAndDynamicAtmosphereColor.x;\\n\\\n    float atmosphereHeight = atmosphereOuterRadius - atmosphereInnerRadius;\\n\\\n\\n\\\n    vec3 direction = (u_enuToFixedFrame * getCubeMapDirection(v_textureCoordinates, u_faceDirection)).xyz;\\n\\\n    vec3 normalizedDirection = normalize(direction);\\n\\\n\\n\\\n    czm_ray ray = czm_ray(positionWC, normalizedDirection);\\n\\\n    czm_raySegment intersection = czm_raySphereIntersectionInterval(ray, vec3(0.0), atmosphereInnerRadius);\\n\\\n    if (!czm_isEmpty(intersection)) {\\n\\\n        intersection = czm_rayEllipsoidIntersectionInterval(ray, vec3(0.0), czm_ellipsoidInverseRadii);\\n\\\n    }\\n\\\n\\n\\\n    bool onEllipsoid = intersection.start >= 0.0;\\n\\\n    float rayLength = czm_branchFreeTernary(onEllipsoid, intersection.start, atmosphereOuterRadius);\\n\\\n\\n\\\n    // Compute sky color for each position on a sphere at radius centered around the provided position's origin\\n\\\n    vec3 skyPositionWC = positionWC + normalizedDirection * rayLength;\\n\\\n\\n\\\n    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;\\n\\\n    vec3 lightDirectionWC = normalize(czm_getDynamicAtmosphereLightDirection(skyPositionWC, lightEnum));\\n\\\n    vec3 mieColor;\\n\\\n    vec3 rayleighColor;\\n\\\n    float opacity;\\n\\\n    czm_computeScattering(\\n\\\n        ray,\\n\\\n        rayLength,\\n\\\n        lightDirectionWC,\\n\\\n        atmosphereInnerRadius, \\n\\\n        rayleighColor,\\n\\\n        mieColor,\\n\\\n        opacity\\n\\\n    );\\n\\\n\\n\\\n    vec4 atmopshereColor = czm_computeAtmosphereColor(ray, lightDirectionWC, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n#ifdef ATMOSPHERE_COLOR_CORRECT\\n\\\n    const bool ignoreBlackPixels = true;\\n\\\n    atmopshereColor.rgb = czm_applyHSBShift(atmopshereColor.rgb, czm_atmosphereHsbShift, ignoreBlackPixels);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 lookupDirection = -normalizedDirection;\\n\\\n     // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z.\\n\\\n    lookupDirection.x = -lookupDirection.x;\\n\\\n    lookupDirection = -normalize(czm_temeToPseudoFixed * lookupDirection);\\n\\\n    lookupDirection.x = -lookupDirection.x;\\n\\\n\\n\\\n    // Values outside the atmopshere are rendered as black, when they should be treated as transparent\\n\\\n    float skyAlpha = clamp((1.0 - ellipsoidHeight / atmosphereHeight) * atmopshereColor.a, 0.0, 1.0);\\n\\\n    skyAlpha = czm_branchFreeTernary(length(atmopshereColor.rgb) <= czm_epsilon7, 0.0, skyAlpha); // Treat black as transparent\\n\\\n\\n\\\n    // Blend starmap with atmopshere scattering\\n\\\n    float intensity = u_brightnessSaturationGammaIntensity.w;\\n\\\n    vec4 sceneSkyBoxColor = czm_textureCube(czm_environmentMap, lookupDirection);\\n\\\n    vec3 skyBackgroundColor = mix(czm_backgroundColor.rgb, sceneSkyBoxColor.rgb, sceneSkyBoxColor.a);\\n\\\n    vec4 combinedSkyColor = vec4(mix(skyBackgroundColor, atmopshereColor.rgb * intensity, skyAlpha), 1.0);\\n\\\n\\n\\\n    // Compute ground color based on amount of reflected light, then blend it with ground atmosphere based on height\\n\\\n    vec3 up = normalize(positionWC);\\n\\\n    float occlusion = max(dot(lightDirectionWC, up), 0.05);\\n\\\n    vec4 groundColor = vec4(u_groundColor.rgb * u_groundColor.a * (vec3(intensity * occlusion) + atmopshereColor.rgb), 1.0);\\n\\\n    vec4 blendedGroundColor = mix(groundColor, atmopshereColor, clamp(ellipsoidHeight / atmosphereHeight, 0.0, 1.0));\\n\\\n\\n\\\n    vec4 color = czm_branchFreeTernary(onEllipsoid, blendedGroundColor, combinedSkyColor);\\n\\\n\\n\\\n    float brightness = u_brightnessSaturationGammaIntensity.x;\\n\\\n    float saturation = u_brightnessSaturationGammaIntensity.y;\\n\\\n    float gamma = u_brightnessSaturationGammaIntensity.z;\\n\\\n\\n\\\n#ifdef ENVIRONMENT_COLOR_CORRECT\\n\\\n    color.rgb = mix(vec3(0.0), color.rgb, brightness);\\n\\\n    color.rgb = czm_saturation(color.rgb, saturation);\\n\\\n#endif\\n\\\n    color.rgb = pow(color.rgb, vec3(gamma)); // Normally this would be in the ifdef above, but there is a precision issue with the atmopshere scattering transmittance (alpha). Having this line is a workaround for that issue, even when gamma is 1.0.\\n\\\n    color.rgb = czm_gammaCorrect(color.rgb);\\n\\\n\\n\\\n    out_FragColor = color;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/ComputeRadianceMapFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"precision highp float;\\n\\\n\\n\\\nin vec2 v_textureCoordinates;\\n\\\n\\n\\\nuniform vec3 u_faceDirection; // Current cubemap face\\n\\\nuniform vec3 u_positionWC;\\n\\\nuniform mat4 u_enuToFixedFrame;\\n\\\nuniform vec4 u_brightnessSaturationGammaIntensity;\\n\\\nuniform vec4 u_groundColor; // alpha component represent albedo\\n\\\n\\n\\\nvec4 getCubeMapDirection(vec2 uv, vec3 faceDir) {\\n\\\n    vec2 scaledUV = uv * 2.0 - 1.0;\\n\\\n\\n\\\n    if (faceDir.x != 0.0) {\\n\\\n        return vec4(faceDir.x,  scaledUV.x * faceDir.x, -scaledUV.y, 0.0);\\n\\\n    } else if (faceDir.y != 0.0) {\\n\\\n        return vec4(scaledUV.x, -scaledUV.y * faceDir.y, faceDir.y, 0.0);\\n\\\n    } else {\\n\\\n        return vec4(scaledUV.x * faceDir.z, -faceDir.z, -scaledUV.y, 0.0); \\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid main() {    \\n\\\n    float height = length(u_positionWC);\\n\\\n    float atmosphereInnerRadius = u_radiiAndDynamicAtmosphereColor.y;\\n\\\n    float ellipsoidHeight = max(height - atmosphereInnerRadius, 0.0);\\n\\\n\\n\\\n    // Scale the position to ensure the sky color is present, even when underground.\\n\\\n    vec3 positionWC = u_positionWC / height * (ellipsoidHeight + atmosphereInnerRadius);\\n\\\n\\n\\\n    float atmosphereOuterRadius = u_radiiAndDynamicAtmosphereColor.x;\\n\\\n    float atmosphereHeight = atmosphereOuterRadius - atmosphereInnerRadius;\\n\\\n\\n\\\n    vec3 direction = (u_enuToFixedFrame * getCubeMapDirection(v_textureCoordinates, u_faceDirection)).xyz;\\n\\\n    vec3 normalizedDirection = normalize(direction);\\n\\\n\\n\\\n    czm_ray ray = czm_ray(positionWC, normalizedDirection);\\n\\\n    czm_raySegment intersection = czm_raySphereIntersectionInterval(ray, vec3(0.0), atmosphereInnerRadius);\\n\\\n    if (!czm_isEmpty(intersection)) {\\n\\\n        intersection = czm_rayEllipsoidIntersectionInterval(ray, vec3(0.0), czm_ellipsoidInverseRadii);\\n\\\n    }\\n\\\n\\n\\\n    bool onEllipsoid = intersection.start >= 0.0;\\n\\\n    float rayLength = czm_branchFreeTernary(onEllipsoid, intersection.start, atmosphereOuterRadius);\\n\\\n\\n\\\n    // Compute sky color for each position on a sphere at radius centered around the provided position's origin\\n\\\n    vec3 skyPositionWC = positionWC + normalizedDirection * rayLength;\\n\\\n\\n\\\n    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;\\n\\\n    vec3 lightDirectionWC = normalize(czm_getDynamicAtmosphereLightDirection(skyPositionWC, lightEnum));\\n\\\n    vec3 mieColor;\\n\\\n    vec3 rayleighColor;\\n\\\n    float opacity;\\n\\\n    czm_computeScattering(\\n\\\n        ray,\\n\\\n        rayLength,\\n\\\n        lightDirectionWC,\\n\\\n        atmosphereInnerRadius, \\n\\\n        rayleighColor,\\n\\\n        mieColor,\\n\\\n        opacity\\n\\\n    );\\n\\\n\\n\\\n    vec4 atmopshereColor = czm_computeAtmosphereColor(ray, lightDirectionWC, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n#ifdef ATMOSPHERE_COLOR_CORRECT\\n\\\n    const bool ignoreBlackPixels = true;\\n\\\n    atmopshereColor.rgb = czm_applyHSBShift(atmopshereColor.rgb, czm_atmosphereHsbShift, ignoreBlackPixels);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 lookupDirection = -normalizedDirection;\\n\\\n     // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z.\\n\\\n    lookupDirection.x = -lookupDirection.x;\\n\\\n    lookupDirection = -normalize(czm_temeToPseudoFixed * lookupDirection);\\n\\\n    lookupDirection.x = -lookupDirection.x;\\n\\\n\\n\\\n    // Values outside the atmopshere are rendered as black, when they should be treated as transparent\\n\\\n    float skyAlpha = clamp((1.0 - ellipsoidHeight / atmosphereHeight) * atmopshereColor.a, 0.0, 1.0);\\n\\\n    skyAlpha = czm_branchFreeTernary(length(atmopshereColor.rgb) <= czm_epsilon7, 0.0, skyAlpha); // Treat black as transparent\\n\\\n\\n\\\n    // Blend starmap with atmopshere scattering\\n\\\n    float intensity = u_brightnessSaturationGammaIntensity.w;\\n\\\n    vec4 sceneSkyBoxColor = czm_textureCube(czm_environmentMap, lookupDirection);\\n\\\n    vec3 skyBackgroundColor = mix(czm_backgroundColor.rgb, sceneSkyBoxColor.rgb, sceneSkyBoxColor.a);\\n\\\n    vec4 combinedSkyColor = vec4(mix(skyBackgroundColor, atmopshereColor.rgb * intensity, skyAlpha), 1.0);\\n\\\n\\n\\\n    // Compute ground color based on amount of reflected light, then blend it with ground atmosphere based on height\\n\\\n    vec3 up = normalize(positionWC);\\n\\\n    float occlusion = max(dot(lightDirectionWC, up), 0.05);\\n\\\n    vec4 groundColor = vec4(u_groundColor.rgb * u_groundColor.a * (vec3(intensity * occlusion) + atmopshereColor.rgb), 1.0);\\n\\\n    vec4 blendedGroundColor = mix(groundColor, atmopshereColor, clamp(ellipsoidHeight / atmosphereHeight, 0.0, 1.0));\\n\\\n\\n\\\n    vec4 color = czm_branchFreeTernary(onEllipsoid, blendedGroundColor, combinedSkyColor);\\n\\\n\\n\\\n    float brightness = u_brightnessSaturationGammaIntensity.x;\\n\\\n    float saturation = u_brightnessSaturationGammaIntensity.y;\\n\\\n    float gamma = u_brightnessSaturationGammaIntensity.z;\\n\\\n\\n\\\n#ifdef ENVIRONMENT_COLOR_CORRECT\\n\\\n    color.rgb = mix(vec3(0.0), color.rgb, brightness);\\n\\\n    color.rgb = czm_saturation(color.rgb, saturation);\\n\\\n#endif\\n\\\n    color.rgb = pow(color.rgb, vec3(gamma)); // Normally this would be in the ifdef above, but there is a precision issue with the atmopshere scattering transmittance (alpha). Having this line is a workaround for that issue, even when gamma is 1.0.\\n\\\n    color.rgb = czm_gammaCorrect(color.rgb);\\n\\\n\\n\\\n    out_FragColor = color;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}