{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nconst removeDuplicatesEpsilon = CesiumMath.EPSILON10;\n\n/**\n * Removes adjacent duplicate values in an array of values.\n *\n * @param {any[]} [values] The array of values.\n * @param {Function} equalsEpsilon Function to compare values with an epsilon. Boolean equalsEpsilon(left, right, epsilon).\n * @param {boolean} [wrapAround=false] Compare the last value in the array against the first value. If they are equal, the last value is removed.\n * @param {number[]} [removedIndices=undefined] Store the indices that correspond to the duplicate items removed from the array, if there were any.\n * @returns {any[]|undefined} A new array of values with no adjacent duplicate values or the input array if no duplicates were found.\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0), (1.0, 1.0, 1.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * // removedIndices will be equal to [1, 3, 5]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n * @private\n */\nfunction arrayRemoveDuplicates(values, equalsEpsilon, wrapAround, removedIndices) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"equalsEpsilon\", equalsEpsilon);\n  //>>includeEnd('debug');\n\n  if (!defined(values)) {\n    return undefined;\n  }\n  wrapAround = defaultValue(wrapAround, false);\n  const storeRemovedIndices = defined(removedIndices);\n  const length = values.length;\n  if (length < 2) {\n    return values;\n  }\n  let i;\n  let v0 = values[0];\n  let v1;\n\n  // We only want to create a new array if there are duplicates in the array.\n  // As such, cleanedValues is undefined until it encounters the first duplicate, if it exists.\n  let cleanedValues;\n  let lastCleanIndex = 0;\n\n  // removedIndexLCI keeps track of where lastCleanIndex would be if it were sorted into the removedIndices array.\n  // In case of arrays such as [A, B, C, ..., A, A, A], removedIndices will not be sorted properly without this.\n  let removedIndexLCI = -1;\n  for (i = 1; i < length; ++i) {\n    v1 = values[i];\n    if (equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {\n      if (!defined(cleanedValues)) {\n        cleanedValues = values.slice(0, i);\n        lastCleanIndex = i - 1;\n        removedIndexLCI = 0;\n      }\n      if (storeRemovedIndices) {\n        removedIndices.push(i);\n      }\n    } else {\n      if (defined(cleanedValues)) {\n        cleanedValues.push(v1);\n        lastCleanIndex = i;\n        if (storeRemovedIndices) {\n          removedIndexLCI = removedIndices.length;\n        }\n      }\n      v0 = v1;\n    }\n  }\n  if (wrapAround && equalsEpsilon(values[0], values[length - 1], removeDuplicatesEpsilon)) {\n    if (storeRemovedIndices) {\n      if (defined(cleanedValues)) {\n        removedIndices.splice(removedIndexLCI, 0, lastCleanIndex);\n      } else {\n        removedIndices.push(length - 1);\n      }\n    }\n    if (defined(cleanedValues)) {\n      cleanedValues.length -= 1;\n    } else {\n      cleanedValues = values.slice(0, -1);\n    }\n  }\n  return defined(cleanedValues) ? cleanedValues : values;\n}\nexport default arrayRemoveDuplicates;","map":{"version":3,"names":["Check","defaultValue","defined","CesiumMath","removeDuplicatesEpsilon","EPSILON10","arrayRemoveDuplicates","values","equalsEpsilon","wrapAround","removedIndices","undefined","storeRemovedIndices","length","i","v0","v1","cleanedValues","lastCleanIndex","removedIndexLCI","slice","push","splice"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/arrayRemoveDuplicates.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst removeDuplicatesEpsilon = CesiumMath.EPSILON10;\n\n/**\n * Removes adjacent duplicate values in an array of values.\n *\n * @param {any[]} [values] The array of values.\n * @param {Function} equalsEpsilon Function to compare values with an epsilon. Boolean equalsEpsilon(left, right, epsilon).\n * @param {boolean} [wrapAround=false] Compare the last value in the array against the first value. If they are equal, the last value is removed.\n * @param {number[]} [removedIndices=undefined] Store the indices that correspond to the duplicate items removed from the array, if there were any.\n * @returns {any[]|undefined} A new array of values with no adjacent duplicate values or the input array if no duplicates were found.\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0), (1.0, 1.0, 1.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * // removedIndices will be equal to [1, 3, 5]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n * @private\n */\nfunction arrayRemoveDuplicates(\n  values,\n  equalsEpsilon,\n  wrapAround,\n  removedIndices,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"equalsEpsilon\", equalsEpsilon);\n  //>>includeEnd('debug');\n\n  if (!defined(values)) {\n    return undefined;\n  }\n\n  wrapAround = defaultValue(wrapAround, false);\n  const storeRemovedIndices = defined(removedIndices);\n\n  const length = values.length;\n  if (length < 2) {\n    return values;\n  }\n\n  let i;\n  let v0 = values[0];\n  let v1;\n\n  // We only want to create a new array if there are duplicates in the array.\n  // As such, cleanedValues is undefined until it encounters the first duplicate, if it exists.\n  let cleanedValues;\n  let lastCleanIndex = 0;\n\n  // removedIndexLCI keeps track of where lastCleanIndex would be if it were sorted into the removedIndices array.\n  // In case of arrays such as [A, B, C, ..., A, A, A], removedIndices will not be sorted properly without this.\n  let removedIndexLCI = -1;\n\n  for (i = 1; i < length; ++i) {\n    v1 = values[i];\n    if (equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {\n      if (!defined(cleanedValues)) {\n        cleanedValues = values.slice(0, i);\n        lastCleanIndex = i - 1;\n        removedIndexLCI = 0;\n      }\n      if (storeRemovedIndices) {\n        removedIndices.push(i);\n      }\n    } else {\n      if (defined(cleanedValues)) {\n        cleanedValues.push(v1);\n        lastCleanIndex = i;\n        if (storeRemovedIndices) {\n          removedIndexLCI = removedIndices.length;\n        }\n      }\n      v0 = v1;\n    }\n  }\n\n  if (\n    wrapAround &&\n    equalsEpsilon(values[0], values[length - 1], removeDuplicatesEpsilon)\n  ) {\n    if (storeRemovedIndices) {\n      if (defined(cleanedValues)) {\n        removedIndices.splice(removedIndexLCI, 0, lastCleanIndex);\n      } else {\n        removedIndices.push(length - 1);\n      }\n    }\n\n    if (defined(cleanedValues)) {\n      cleanedValues.length -= 1;\n    } else {\n      cleanedValues = values.slice(0, -1);\n    }\n  }\n\n  return defined(cleanedValues) ? cleanedValues : values;\n}\n\nexport default arrayRemoveDuplicates;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}