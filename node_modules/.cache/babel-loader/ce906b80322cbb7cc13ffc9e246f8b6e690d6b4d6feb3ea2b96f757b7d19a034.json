{"ast":null,"code":"import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelSilhouetteStageFS from \"../../Shaders/Model/ModelSilhouetteStageFS.js\";\nimport ModelSilhouetteStageVS from \"../../Shaders/Model/ModelSilhouetteStageVS.js\";\n\n/**\n * The model silhouette pipeline stage is responsible applying silhouettes to the model.\n *\n * @namespace ModelSilhouettePipelineStage\n *\n * @private\n */\nconst ModelSilhouettePipelineStage = {\n  name: \"ModelSilhouettePipelineStage\" // Helps with debugging\n};\n\n/**\n * Tracks how many silhouettes have been created. This value is used to\n * assign a reference number to the stencil.\n *\n * @type {number}\n * @private\n */\nModelSilhouettePipelineStage.silhouettesLength = 0;\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>defines the silhouette ID for the model, if it doesn't yet exist\n *  <li>adds a define to the shaders to indicate that the model uses silhouettes</li>\n *  <li>adds a function to the vertex shader to create the silhouette around the model</li>\n *  <li>adds a function to the fragment shader to apply color to the silhouette</li>\n *  <li>adds the uniforms to the shaders for the corresponding silhouette properties</li>\n *  <li>adds a uniform to distinguish which draw command is used to render the silhouette</li>\n *  <li>sets a variable in the render resources denoting whether the model has a silhouette</li>\n * </ul>\n *\n * <p>\n * Note that the model must have a normal attribute in order to use silhouettes. The flag for this is\n * added to the shader in GeometryPipelineStage.\n * </p>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelSilhouettePipelineStage.process = function (renderResources, model, frameState) {\n  if (!defined(model._silhouetteId)) {\n    model._silhouetteId = ++ModelSilhouettePipelineStage.silhouettesLength;\n  }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_SILHOUETTE\", undefined, ShaderDestination.BOTH);\n  shaderBuilder.addVertexLines(ModelSilhouetteStageVS);\n  shaderBuilder.addFragmentLines(ModelSilhouetteStageFS);\n  shaderBuilder.addUniform(\"vec4\", \"model_silhouetteColor\", ShaderDestination.FRAGMENT);\n  shaderBuilder.addUniform(\"float\", \"model_silhouetteSize\", ShaderDestination.VERTEX);\n\n  // Rendering silhouettes requires two draw commands:\n  // - First, the model is rendered as normal, writing to the stencil buffer.\n  // - Second, the silhouette is drawn, and the stencil buffer is used to cutout\n  //   the part that overlaps the regular model.\n  //\n  // To avoid creating a second shader program to handle silhouettes, a uniform\n  // is used to distinguish between the two draw commands. The second command will set\n  // this uniform true, such that only it applies the silhouette stage.\n  shaderBuilder.addUniform(\"bool\", \"model_silhouettePass\", ShaderDestination.BOTH);\n  const uniformMap = {\n    model_silhouetteColor: function () {\n      return model.silhouetteColor;\n    },\n    model_silhouetteSize: function () {\n      return model.silhouetteSize;\n    },\n    model_silhouettePass: function () {\n      // This will be set to true by the draw command that draws the silhouette.\n      return false;\n    }\n  };\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n  renderResources.hasSilhouette = true;\n};\nexport default ModelSilhouettePipelineStage;","map":{"version":3,"names":["combine","defined","ShaderDestination","ModelSilhouetteStageFS","ModelSilhouetteStageVS","ModelSilhouettePipelineStage","name","silhouettesLength","process","renderResources","model","frameState","_silhouetteId","shaderBuilder","addDefine","undefined","BOTH","addVertexLines","addFragmentLines","addUniform","FRAGMENT","VERTEX","uniformMap","model_silhouetteColor","silhouetteColor","model_silhouetteSize","silhouetteSize","model_silhouettePass","hasSilhouette"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelSilhouettePipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelSilhouetteStageFS from \"../../Shaders/Model/ModelSilhouetteStageFS.js\";\nimport ModelSilhouetteStageVS from \"../../Shaders/Model/ModelSilhouetteStageVS.js\";\n\n/**\n * The model silhouette pipeline stage is responsible applying silhouettes to the model.\n *\n * @namespace ModelSilhouettePipelineStage\n *\n * @private\n */\nconst ModelSilhouettePipelineStage = {\n  name: \"ModelSilhouettePipelineStage\", // Helps with debugging\n};\n\n/**\n * Tracks how many silhouettes have been created. This value is used to\n * assign a reference number to the stencil.\n *\n * @type {number}\n * @private\n */\nModelSilhouettePipelineStage.silhouettesLength = 0;\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>defines the silhouette ID for the model, if it doesn't yet exist\n *  <li>adds a define to the shaders to indicate that the model uses silhouettes</li>\n *  <li>adds a function to the vertex shader to create the silhouette around the model</li>\n *  <li>adds a function to the fragment shader to apply color to the silhouette</li>\n *  <li>adds the uniforms to the shaders for the corresponding silhouette properties</li>\n *  <li>adds a uniform to distinguish which draw command is used to render the silhouette</li>\n *  <li>sets a variable in the render resources denoting whether the model has a silhouette</li>\n * </ul>\n *\n * <p>\n * Note that the model must have a normal attribute in order to use silhouettes. The flag for this is\n * added to the shader in GeometryPipelineStage.\n * </p>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {Model} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelSilhouettePipelineStage.process = function (\n  renderResources,\n  model,\n  frameState,\n) {\n  if (!defined(model._silhouetteId)) {\n    model._silhouetteId = ++ModelSilhouettePipelineStage.silhouettesLength;\n  }\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_SILHOUETTE\", undefined, ShaderDestination.BOTH);\n\n  shaderBuilder.addVertexLines(ModelSilhouetteStageVS);\n  shaderBuilder.addFragmentLines(ModelSilhouetteStageFS);\n\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_silhouetteColor\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addUniform(\n    \"float\",\n    \"model_silhouetteSize\",\n    ShaderDestination.VERTEX,\n  );\n\n  // Rendering silhouettes requires two draw commands:\n  // - First, the model is rendered as normal, writing to the stencil buffer.\n  // - Second, the silhouette is drawn, and the stencil buffer is used to cutout\n  //   the part that overlaps the regular model.\n  //\n  // To avoid creating a second shader program to handle silhouettes, a uniform\n  // is used to distinguish between the two draw commands. The second command will set\n  // this uniform true, such that only it applies the silhouette stage.\n  shaderBuilder.addUniform(\n    \"bool\",\n    \"model_silhouettePass\",\n    ShaderDestination.BOTH,\n  );\n\n  const uniformMap = {\n    model_silhouetteColor: function () {\n      return model.silhouetteColor;\n    },\n    model_silhouetteSize: function () {\n      return model.silhouetteSize;\n    },\n    model_silhouettePass: function () {\n      // This will be set to true by the draw command that draws the silhouette.\n      return false;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n  renderResources.hasSilhouette = true;\n};\n\nexport default ModelSilhouettePipelineStage;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,iBAAiB,MAAM,qCAAqC;AACnE,OAAOC,sBAAsB,MAAM,+CAA+C;AAClF,OAAOC,sBAAsB,MAAM,+CAA+C;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAG;EACnCC,IAAI,EAAE,8BAA8B,CAAE;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,4BAA4B,CAACE,iBAAiB,GAAG,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,4BAA4B,CAACG,OAAO,GAAG,UACrCC,eAAe,EACfC,KAAK,EACLC,UAAU,EACV;EACA,IAAI,CAACV,OAAO,CAACS,KAAK,CAACE,aAAa,CAAC,EAAE;IACjCF,KAAK,CAACE,aAAa,GAAG,EAAEP,4BAA4B,CAACE,iBAAiB;EACxE;EAEA,MAAMM,aAAa,GAAGJ,eAAe,CAACI,aAAa;EACnDA,aAAa,CAACC,SAAS,CAAC,gBAAgB,EAAEC,SAAS,EAAEb,iBAAiB,CAACc,IAAI,CAAC;EAE5EH,aAAa,CAACI,cAAc,CAACb,sBAAsB,CAAC;EACpDS,aAAa,CAACK,gBAAgB,CAACf,sBAAsB,CAAC;EAEtDU,aAAa,CAACM,UAAU,CACtB,MAAM,EACN,uBAAuB,EACvBjB,iBAAiB,CAACkB,QACpB,CAAC;EAEDP,aAAa,CAACM,UAAU,CACtB,OAAO,EACP,sBAAsB,EACtBjB,iBAAiB,CAACmB,MACpB,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAR,aAAa,CAACM,UAAU,CACtB,MAAM,EACN,sBAAsB,EACtBjB,iBAAiB,CAACc,IACpB,CAAC;EAED,MAAMM,UAAU,GAAG;IACjBC,qBAAqB,EAAE,SAAAA,CAAA,EAAY;MACjC,OAAOb,KAAK,CAACc,eAAe;IAC9B,CAAC;IACDC,oBAAoB,EAAE,SAAAA,CAAA,EAAY;MAChC,OAAOf,KAAK,CAACgB,cAAc;IAC7B,CAAC;IACDC,oBAAoB,EAAE,SAAAA,CAAA,EAAY;MAChC;MACA,OAAO,KAAK;IACd;EACF,CAAC;EAEDlB,eAAe,CAACa,UAAU,GAAGtB,OAAO,CAACsB,UAAU,EAAEb,eAAe,CAACa,UAAU,CAAC;EAC5Eb,eAAe,CAACmB,aAAa,GAAG,IAAI;AACtC,CAAC;AAED,eAAevB,4BAA4B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}