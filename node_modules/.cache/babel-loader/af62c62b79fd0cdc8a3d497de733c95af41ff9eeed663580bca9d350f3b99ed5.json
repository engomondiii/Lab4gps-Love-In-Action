{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport sampleTerrain from \"./sampleTerrain.js\";\nconst scratchCartesian2 = new Cartesian2();\n\n/**\n * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.\n *\n * @function sampleTerrainMostDetailed\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @param {boolean} [rejectOnTileFail=false] If true, for a failed terrain tile request the promise will be rejected. If false, returned heights will be undefined.\n * @returns {Promise<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.  This\n *                                     promise will reject if the terrain provider's `availability` property is undefined.\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }\n */\nasync function sampleTerrainMostDetailed(terrainProvider, positions, rejectOnTileFail) {\n  if (!defined(rejectOnTileFail)) {\n    rejectOnTileFail = false;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(terrainProvider)) {\n    throw new DeveloperError(\"terrainProvider is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const byLevel = [];\n  const maxLevels = [];\n  const availability = terrainProvider.availability;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(availability)) {\n    throw new DeveloperError(\"sampleTerrainMostDetailed requires a terrain provider that has tile availability.\");\n  }\n  //>>includeEnd('debug');\n\n  const promises = [];\n  for (let i = 0; i < positions.length; ++i) {\n    const position = positions[i];\n    const maxLevel = availability.computeMaximumLevelAtPosition(position);\n    maxLevels[i] = maxLevel;\n    if (maxLevel === 0) {\n      // This is a special case where we have a parent terrain and we are requesting\n      // heights from an area that isn't covered by the top level terrain at all.\n      // This will essentially trigger the loading of the parent terrains root tile\n      terrainProvider.tilingScheme.positionToTileXY(position, 1, scratchCartesian2);\n      const promise = terrainProvider.loadTileDataAvailability(scratchCartesian2.x, scratchCartesian2.y, 1);\n      if (defined(promise)) {\n        promises.push(promise);\n      }\n    }\n    let atLevel = byLevel[maxLevel];\n    if (!defined(atLevel)) {\n      byLevel[maxLevel] = atLevel = [];\n    }\n    atLevel.push(position);\n  }\n  await Promise.all(promises);\n  await Promise.all(byLevel.map(function (positionsAtLevel, index) {\n    if (defined(positionsAtLevel)) {\n      return sampleTerrain(terrainProvider, index, positionsAtLevel, rejectOnTileFail);\n    }\n  }));\n  const changedPositions = [];\n  for (let i = 0; i < positions.length; ++i) {\n    const position = positions[i];\n    const maxLevel = availability.computeMaximumLevelAtPosition(position);\n    if (maxLevel !== maxLevels[i]) {\n      // Now that we loaded the max availability, a higher level has become available\n      changedPositions.push(position);\n    }\n  }\n  if (changedPositions.length > 0) {\n    await sampleTerrainMostDetailed(terrainProvider, changedPositions, rejectOnTileFail);\n  }\n  return positions;\n}\nexport default sampleTerrainMostDetailed;","map":{"version":3,"names":["Cartesian2","defined","DeveloperError","sampleTerrain","scratchCartesian2","sampleTerrainMostDetailed","terrainProvider","positions","rejectOnTileFail","byLevel","maxLevels","availability","promises","i","length","position","maxLevel","computeMaximumLevelAtPosition","tilingScheme","positionToTileXY","promise","loadTileDataAvailability","x","y","push","atLevel","Promise","all","map","positionsAtLevel","index","changedPositions"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/sampleTerrainMostDetailed.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport sampleTerrain from \"./sampleTerrain.js\";\n\nconst scratchCartesian2 = new Cartesian2();\n\n/**\n * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.\n *\n * @function sampleTerrainMostDetailed\n *\n * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.\n * @param {Cartographic[]} positions The positions to update with terrain heights.\n * @param {boolean} [rejectOnTileFail=false] If true, for a failed terrain tile request the promise will be rejected. If false, returned heights will be undefined.\n * @returns {Promise<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.  This\n *                                     promise will reject if the terrain provider's `availability` property is undefined.\n *\n * @example\n * // Query the terrain height of two Cartographic positions\n * const terrainProvider = await Cesium.createWorldTerrainAsync();\n * const positions = [\n *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n *     Cesium.Cartographic.fromDegrees(87.0, 28.0)\n * ];\n * const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);\n * // positions[0].height and positions[1].height have been updated.\n * // updatedPositions is just a reference to positions.\n *\n * // To handle tile errors, pass true for the rejectOnTileFail parameter.\n * try {\n *    const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions, true);\n * } catch (error) {\n *   // A tile request error occurred.\n * }\n */\nasync function sampleTerrainMostDetailed(\n  terrainProvider,\n  positions,\n  rejectOnTileFail,\n) {\n  if (!defined(rejectOnTileFail)) {\n    rejectOnTileFail = false;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(terrainProvider)) {\n    throw new DeveloperError(\"terrainProvider is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const byLevel = [];\n  const maxLevels = [];\n\n  const availability = terrainProvider.availability;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(availability)) {\n    throw new DeveloperError(\n      \"sampleTerrainMostDetailed requires a terrain provider that has tile availability.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const promises = [];\n  for (let i = 0; i < positions.length; ++i) {\n    const position = positions[i];\n    const maxLevel = availability.computeMaximumLevelAtPosition(position);\n    maxLevels[i] = maxLevel;\n    if (maxLevel === 0) {\n      // This is a special case where we have a parent terrain and we are requesting\n      // heights from an area that isn't covered by the top level terrain at all.\n      // This will essentially trigger the loading of the parent terrains root tile\n      terrainProvider.tilingScheme.positionToTileXY(\n        position,\n        1,\n        scratchCartesian2,\n      );\n      const promise = terrainProvider.loadTileDataAvailability(\n        scratchCartesian2.x,\n        scratchCartesian2.y,\n        1,\n      );\n      if (defined(promise)) {\n        promises.push(promise);\n      }\n    }\n\n    let atLevel = byLevel[maxLevel];\n    if (!defined(atLevel)) {\n      byLevel[maxLevel] = atLevel = [];\n    }\n    atLevel.push(position);\n  }\n\n  await Promise.all(promises);\n  await Promise.all(\n    byLevel.map(function (positionsAtLevel, index) {\n      if (defined(positionsAtLevel)) {\n        return sampleTerrain(\n          terrainProvider,\n          index,\n          positionsAtLevel,\n          rejectOnTileFail,\n        );\n      }\n    }),\n  );\n  const changedPositions = [];\n  for (let i = 0; i < positions.length; ++i) {\n    const position = positions[i];\n    const maxLevel = availability.computeMaximumLevelAtPosition(position);\n\n    if (maxLevel !== maxLevels[i]) {\n      // Now that we loaded the max availability, a higher level has become available\n      changedPositions.push(position);\n    }\n  }\n\n  if (changedPositions.length > 0) {\n    await sampleTerrainMostDetailed(\n      terrainProvider,\n      changedPositions,\n      rejectOnTileFail,\n    );\n  }\n\n  return positions;\n}\nexport default sampleTerrainMostDetailed;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}