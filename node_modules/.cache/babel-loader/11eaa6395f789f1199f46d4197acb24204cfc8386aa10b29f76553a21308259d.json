{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\n\n/**\n * A post process stage that will get the luminance value at each pixel and\n * uses parallel reduction to compute the average luminance in a 1x1 texture.\n * This texture can be used as input for tone mapping.\n *\n * @constructor\n * @private\n */\nfunction AutoExposure() {\n  this._uniformMap = undefined;\n  this._command = undefined;\n  this._colorTexture = undefined;\n  this._depthTexture = undefined;\n  this._ready = false;\n  this._name = \"czm_autoexposure\";\n  this._logDepthChanged = undefined;\n  this._useLogDepth = undefined;\n  this._framebuffers = undefined;\n  this._previousLuminance = new FramebufferManager();\n  this._commands = undefined;\n  this._clearCommand = undefined;\n  this._minMaxLuminance = new Cartesian2();\n\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @type {boolean}\n   */\n  this.enabled = true;\n  this._enabled = true;\n\n  /**\n   * The minimum value used to clamp the luminance.\n   *\n   * @type {number}\n   * @default 0.1\n   */\n  this.minimumLuminance = 0.1;\n\n  /**\n   * The maximum value used to clamp the luminance.\n   *\n   * @type {number}\n   * @default 10.0\n   */\n  this.maximumLuminance = 10.0;\n}\nObject.defineProperties(AutoExposure.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>\n   * and {@link AutoExposure#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures\n   * to load.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * A reference to the texture written to when executing this post process stage.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      const framebuffers = this._framebuffers;\n      if (!defined(framebuffers)) {\n        return undefined;\n      }\n      return framebuffers[framebuffers.length - 1].getColorTexture(0);\n    }\n  }\n});\nfunction destroyFramebuffers(autoexposure) {\n  const framebuffers = autoexposure._framebuffers;\n  if (!defined(framebuffers)) {\n    return;\n  }\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    framebuffers[i].destroy();\n  }\n  autoexposure._framebuffers = undefined;\n  autoexposure._previousLuminance.destroy();\n  autoexposure._previousLuminance = undefined;\n}\nfunction createFramebuffers(autoexposure, context) {\n  destroyFramebuffers(autoexposure);\n  let width = autoexposure._width;\n  let height = autoexposure._height;\n  const pixelDatatype = context.halfFloatingPointTexture ? PixelDatatype.HALF_FLOAT : PixelDatatype.FLOAT;\n  const length = Math.ceil(Math.log(Math.max(width, height)) / Math.log(3.0));\n  const framebuffers = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    width = Math.max(Math.ceil(width / 3.0), 1.0);\n    height = Math.max(Math.ceil(height / 3.0), 1.0);\n    framebuffers[i] = new FramebufferManager();\n    framebuffers[i].update(context, width, height, 1, pixelDatatype);\n  }\n  const lastTexture = framebuffers[length - 1].getColorTexture(0);\n  autoexposure._previousLuminance.update(context, lastTexture.width, lastTexture.height, 1, pixelDatatype);\n  autoexposure._framebuffers = framebuffers;\n}\nfunction destroyCommands(autoexposure) {\n  const commands = autoexposure._commands;\n  if (!defined(commands)) {\n    return;\n  }\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    commands[i].shaderProgram.destroy();\n  }\n  autoexposure._commands = undefined;\n}\nfunction createUniformMap(autoexposure, index) {\n  let uniforms;\n  if (index === 0) {\n    uniforms = {\n      colorTexture: function () {\n        return autoexposure._colorTexture;\n      },\n      colorTextureDimensions: function () {\n        return autoexposure._colorTexture.dimensions;\n      }\n    };\n  } else {\n    const texture = autoexposure._framebuffers[index - 1].getColorTexture(0);\n    uniforms = {\n      colorTexture: function () {\n        return texture;\n      },\n      colorTextureDimensions: function () {\n        return texture.dimensions;\n      }\n    };\n  }\n  uniforms.minMaxLuminance = function () {\n    return autoexposure._minMaxLuminance;\n  };\n  uniforms.previousLuminance = function () {\n    return autoexposure._previousLuminance.getColorTexture(0);\n  };\n  return uniforms;\n}\nfunction getShaderSource(index, length) {\n  let source = \"uniform sampler2D colorTexture; \\n\" + \"in vec2 v_textureCoordinates; \\n\" + \"float sampleTexture(vec2 offset) { \\n\";\n  if (index === 0) {\n    source += \"    vec4 color = texture(colorTexture, v_textureCoordinates + offset); \\n\" + \"    return czm_luminance(color.rgb); \\n\";\n  } else {\n    source += \"    return texture(colorTexture, v_textureCoordinates + offset).r; \\n\";\n  }\n  source += \"}\\n\\n\";\n  source += \"uniform vec2 colorTextureDimensions; \\n\" + \"uniform vec2 minMaxLuminance; \\n\" + \"uniform sampler2D previousLuminance; \\n\" + \"void main() { \\n\" + \"    float color = 0.0; \\n\" + \"    float xStep = 1.0 / colorTextureDimensions.x; \\n\" + \"    float yStep = 1.0 / colorTextureDimensions.y; \\n\" + \"    int count = 0; \\n\" + \"    for (int i = 0; i < 3; ++i) { \\n\" + \"        for (int j = 0; j < 3; ++j) { \\n\" + \"            vec2 offset; \\n\" + \"            offset.x = -xStep + float(i) * xStep; \\n\" + \"            offset.y = -yStep + float(j) * yStep; \\n\" + \"            if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0) { \\n\" + \"                continue; \\n\" + \"            } \\n\" + \"            color += sampleTexture(offset); \\n\" + \"            ++count; \\n\" + \"        } \\n\" + \"    } \\n\" + \"    if (count > 0) { \\n\" + \"        color /= float(count); \\n\" + \"    } \\n\";\n  if (index === length - 1) {\n    source += \"    float previous = texture(previousLuminance, vec2(0.5)).r; \\n\" + \"    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \\n\" + \"    color = previous + (color - previous) / (60.0 * 1.5); \\n\" + \"    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \\n\";\n  }\n  source += \"    out_FragColor = vec4(color); \\n\" + \"} \\n\";\n  return source;\n}\nfunction createCommands(autoexposure, context) {\n  destroyCommands(autoexposure);\n  const framebuffers = autoexposure._framebuffers;\n  const length = framebuffers.length;\n  const commands = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    commands[i] = context.createViewportQuadCommand(getShaderSource(i, length), {\n      framebuffer: framebuffers[i].framebuffer,\n      uniformMap: createUniformMap(autoexposure, i)\n    });\n  }\n  autoexposure._commands = commands;\n}\n\n/**\n * A function that will be called before execute. Used to clear any textures attached to framebuffers.\n * @param {Context} context The context.\n * @private\n */\nAutoExposure.prototype.clear = function (context) {\n  const framebuffers = this._framebuffers;\n  if (!defined(framebuffers)) {\n    return;\n  }\n  let clearCommand = this._clearCommand;\n  if (!defined(clearCommand)) {\n    clearCommand = this._clearCommand = new ClearCommand({\n      color: new Color(0.0, 0.0, 0.0, 0.0),\n      framebuffer: undefined\n    });\n  }\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    framebuffers[i].clear(context, clearCommand);\n  }\n};\n\n/**\n * A function that will be called before execute. Used to create WebGL resources and load any textures.\n * @param {Context} context The context.\n * @private\n */\nAutoExposure.prototype.update = function (context) {\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  if (width !== this._width || height !== this._height) {\n    this._width = width;\n    this._height = height;\n    createFramebuffers(this, context);\n    createCommands(this, context);\n    if (!this._ready) {\n      this._ready = true;\n    }\n  }\n  this._minMaxLuminance.x = this.minimumLuminance;\n  this._minMaxLuminance.y = this.maximumLuminance;\n  const framebuffers = this._framebuffers;\n  const temp = framebuffers[framebuffers.length - 1];\n  framebuffers[framebuffers.length - 1] = this._previousLuminance;\n  this._commands[this._commands.length - 1].framebuffer = this._previousLuminance.framebuffer;\n  this._previousLuminance = temp;\n};\n\n/**\n * Executes the post-process stage. The color texture is the texture rendered to by the scene or from the previous stage.\n * @param {Context} context The context.\n * @param {Texture} colorTexture The input color texture.\n * @private\n */\nAutoExposure.prototype.execute = function (context, colorTexture) {\n  this._colorTexture = colorTexture;\n  const commands = this._commands;\n  if (!defined(commands)) {\n    return;\n  }\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    commands[i].execute(context);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see AutoExposure#destroy\n */\nAutoExposure.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see AutoExposure#isDestroyed\n */\nAutoExposure.prototype.destroy = function () {\n  destroyFramebuffers(this);\n  destroyCommands(this);\n  return destroyObject(this);\n};\nexport default AutoExposure;","map":{"version":3,"names":["Cartesian2","Color","defined","destroyObject","ClearCommand","FramebufferManager","PixelDatatype","AutoExposure","_uniformMap","undefined","_command","_colorTexture","_depthTexture","_ready","_name","_logDepthChanged","_useLogDepth","_framebuffers","_previousLuminance","_commands","_clearCommand","_minMaxLuminance","enabled","_enabled","minimumLuminance","maximumLuminance","Object","defineProperties","prototype","ready","get","name","outputTexture","framebuffers","length","getColorTexture","destroyFramebuffers","autoexposure","i","destroy","createFramebuffers","context","width","_width","height","_height","pixelDatatype","halfFloatingPointTexture","HALF_FLOAT","FLOAT","Math","ceil","log","max","Array","update","lastTexture","destroyCommands","commands","shaderProgram","createUniformMap","index","uniforms","colorTexture","colorTextureDimensions","dimensions","texture","minMaxLuminance","previousLuminance","getShaderSource","source","createCommands","createViewportQuadCommand","framebuffer","uniformMap","clear","clearCommand","color","drawingBufferWidth","drawingBufferHeight","x","y","temp","execute","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/AutoExposure.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\n\n/**\n * A post process stage that will get the luminance value at each pixel and\n * uses parallel reduction to compute the average luminance in a 1x1 texture.\n * This texture can be used as input for tone mapping.\n *\n * @constructor\n * @private\n */\nfunction AutoExposure() {\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._colorTexture = undefined;\n  this._depthTexture = undefined;\n\n  this._ready = false;\n\n  this._name = \"czm_autoexposure\";\n\n  this._logDepthChanged = undefined;\n  this._useLogDepth = undefined;\n\n  this._framebuffers = undefined;\n  this._previousLuminance = new FramebufferManager();\n\n  this._commands = undefined;\n  this._clearCommand = undefined;\n\n  this._minMaxLuminance = new Cartesian2();\n\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @type {boolean}\n   */\n  this.enabled = true;\n  this._enabled = true;\n\n  /**\n   * The minimum value used to clamp the luminance.\n   *\n   * @type {number}\n   * @default 0.1\n   */\n  this.minimumLuminance = 0.1;\n\n  /**\n   * The maximum value used to clamp the luminance.\n   *\n   * @type {number}\n   * @default 10.0\n   */\n  this.maximumLuminance = 10.0;\n}\n\nObject.defineProperties(AutoExposure.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>\n   * and {@link AutoExposure#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures\n   * to load.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * A reference to the texture written to when executing this post process stage.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      const framebuffers = this._framebuffers;\n      if (!defined(framebuffers)) {\n        return undefined;\n      }\n      return framebuffers[framebuffers.length - 1].getColorTexture(0);\n    },\n  },\n});\n\nfunction destroyFramebuffers(autoexposure) {\n  const framebuffers = autoexposure._framebuffers;\n  if (!defined(framebuffers)) {\n    return;\n  }\n\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    framebuffers[i].destroy();\n  }\n  autoexposure._framebuffers = undefined;\n\n  autoexposure._previousLuminance.destroy();\n  autoexposure._previousLuminance = undefined;\n}\n\nfunction createFramebuffers(autoexposure, context) {\n  destroyFramebuffers(autoexposure);\n\n  let width = autoexposure._width;\n  let height = autoexposure._height;\n\n  const pixelDatatype = context.halfFloatingPointTexture\n    ? PixelDatatype.HALF_FLOAT\n    : PixelDatatype.FLOAT;\n\n  const length = Math.ceil(Math.log(Math.max(width, height)) / Math.log(3.0));\n  const framebuffers = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    width = Math.max(Math.ceil(width / 3.0), 1.0);\n    height = Math.max(Math.ceil(height / 3.0), 1.0);\n    framebuffers[i] = new FramebufferManager();\n    framebuffers[i].update(context, width, height, 1, pixelDatatype);\n  }\n\n  const lastTexture = framebuffers[length - 1].getColorTexture(0);\n  autoexposure._previousLuminance.update(\n    context,\n    lastTexture.width,\n    lastTexture.height,\n    1,\n    pixelDatatype,\n  );\n  autoexposure._framebuffers = framebuffers;\n}\n\nfunction destroyCommands(autoexposure) {\n  const commands = autoexposure._commands;\n  if (!defined(commands)) {\n    return;\n  }\n\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    commands[i].shaderProgram.destroy();\n  }\n  autoexposure._commands = undefined;\n}\n\nfunction createUniformMap(autoexposure, index) {\n  let uniforms;\n  if (index === 0) {\n    uniforms = {\n      colorTexture: function () {\n        return autoexposure._colorTexture;\n      },\n      colorTextureDimensions: function () {\n        return autoexposure._colorTexture.dimensions;\n      },\n    };\n  } else {\n    const texture = autoexposure._framebuffers[index - 1].getColorTexture(0);\n    uniforms = {\n      colorTexture: function () {\n        return texture;\n      },\n      colorTextureDimensions: function () {\n        return texture.dimensions;\n      },\n    };\n  }\n\n  uniforms.minMaxLuminance = function () {\n    return autoexposure._minMaxLuminance;\n  };\n  uniforms.previousLuminance = function () {\n    return autoexposure._previousLuminance.getColorTexture(0);\n  };\n\n  return uniforms;\n}\n\nfunction getShaderSource(index, length) {\n  let source =\n    \"uniform sampler2D colorTexture; \\n\" +\n    \"in vec2 v_textureCoordinates; \\n\" +\n    \"float sampleTexture(vec2 offset) { \\n\";\n\n  if (index === 0) {\n    source +=\n      \"    vec4 color = texture(colorTexture, v_textureCoordinates + offset); \\n\" +\n      \"    return czm_luminance(color.rgb); \\n\";\n  } else {\n    source +=\n      \"    return texture(colorTexture, v_textureCoordinates + offset).r; \\n\";\n  }\n\n  source += \"}\\n\\n\";\n\n  source +=\n    \"uniform vec2 colorTextureDimensions; \\n\" +\n    \"uniform vec2 minMaxLuminance; \\n\" +\n    \"uniform sampler2D previousLuminance; \\n\" +\n    \"void main() { \\n\" +\n    \"    float color = 0.0; \\n\" +\n    \"    float xStep = 1.0 / colorTextureDimensions.x; \\n\" +\n    \"    float yStep = 1.0 / colorTextureDimensions.y; \\n\" +\n    \"    int count = 0; \\n\" +\n    \"    for (int i = 0; i < 3; ++i) { \\n\" +\n    \"        for (int j = 0; j < 3; ++j) { \\n\" +\n    \"            vec2 offset; \\n\" +\n    \"            offset.x = -xStep + float(i) * xStep; \\n\" +\n    \"            offset.y = -yStep + float(j) * yStep; \\n\" +\n    \"            if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0) { \\n\" +\n    \"                continue; \\n\" +\n    \"            } \\n\" +\n    \"            color += sampleTexture(offset); \\n\" +\n    \"            ++count; \\n\" +\n    \"        } \\n\" +\n    \"    } \\n\" +\n    \"    if (count > 0) { \\n\" +\n    \"        color /= float(count); \\n\" +\n    \"    } \\n\";\n\n  if (index === length - 1) {\n    source +=\n      \"    float previous = texture(previousLuminance, vec2(0.5)).r; \\n\" +\n      \"    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \\n\" +\n      \"    color = previous + (color - previous) / (60.0 * 1.5); \\n\" +\n      \"    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \\n\";\n  }\n\n  source += \"    out_FragColor = vec4(color); \\n\" + \"} \\n\";\n  return source;\n}\n\nfunction createCommands(autoexposure, context) {\n  destroyCommands(autoexposure);\n  const framebuffers = autoexposure._framebuffers;\n  const length = framebuffers.length;\n\n  const commands = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    commands[i] = context.createViewportQuadCommand(\n      getShaderSource(i, length),\n      {\n        framebuffer: framebuffers[i].framebuffer,\n        uniformMap: createUniformMap(autoexposure, i),\n      },\n    );\n  }\n  autoexposure._commands = commands;\n}\n\n/**\n * A function that will be called before execute. Used to clear any textures attached to framebuffers.\n * @param {Context} context The context.\n * @private\n */\nAutoExposure.prototype.clear = function (context) {\n  const framebuffers = this._framebuffers;\n  if (!defined(framebuffers)) {\n    return;\n  }\n\n  let clearCommand = this._clearCommand;\n  if (!defined(clearCommand)) {\n    clearCommand = this._clearCommand = new ClearCommand({\n      color: new Color(0.0, 0.0, 0.0, 0.0),\n      framebuffer: undefined,\n    });\n  }\n\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    framebuffers[i].clear(context, clearCommand);\n  }\n};\n\n/**\n * A function that will be called before execute. Used to create WebGL resources and load any textures.\n * @param {Context} context The context.\n * @private\n */\nAutoExposure.prototype.update = function (context) {\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n\n  if (width !== this._width || height !== this._height) {\n    this._width = width;\n    this._height = height;\n\n    createFramebuffers(this, context);\n    createCommands(this, context);\n\n    if (!this._ready) {\n      this._ready = true;\n    }\n  }\n\n  this._minMaxLuminance.x = this.minimumLuminance;\n  this._minMaxLuminance.y = this.maximumLuminance;\n\n  const framebuffers = this._framebuffers;\n  const temp = framebuffers[framebuffers.length - 1];\n  framebuffers[framebuffers.length - 1] = this._previousLuminance;\n  this._commands[this._commands.length - 1].framebuffer =\n    this._previousLuminance.framebuffer;\n  this._previousLuminance = temp;\n};\n\n/**\n * Executes the post-process stage. The color texture is the texture rendered to by the scene or from the previous stage.\n * @param {Context} context The context.\n * @param {Texture} colorTexture The input color texture.\n * @private\n */\nAutoExposure.prototype.execute = function (context, colorTexture) {\n  this._colorTexture = colorTexture;\n\n  const commands = this._commands;\n  if (!defined(commands)) {\n    return;\n  }\n\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    commands[i].execute(context);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see AutoExposure#destroy\n */\nAutoExposure.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see AutoExposure#isDestroyed\n */\nAutoExposure.prototype.destroy = function () {\n  destroyFramebuffers(this);\n  destroyCommands(this);\n  return destroyObject(this);\n};\nexport default AutoExposure;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}