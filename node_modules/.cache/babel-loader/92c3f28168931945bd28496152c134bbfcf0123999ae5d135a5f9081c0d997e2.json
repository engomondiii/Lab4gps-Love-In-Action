{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ArcType from \"../Core/ArcType.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CoplanarPolygonGeometry from \"../Core/CoplanarPolygonGeometry.js\";\nimport CoplanarPolygonOutlineGeometry from \"../Core/CoplanarPolygonOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipsoidTangentPlane from \"../Core/EllipsoidTangentPlane.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\nimport PolygonOutlineGeometry from \"../Core/PolygonOutlineGeometry.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\nconst heightAndPerPositionHeightWarning = \"Entity polygons cannot have both height and perPositionHeight.  height will be ignored\";\nconst heightReferenceAndPerPositionHeightWarning = \"heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored\";\nconst scratchColor = new Color();\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst scratchRectangle = new Rectangle();\nconst scratch2DPositions = [];\nconst cart2Scratch = new Cartesian2();\nfunction PolygonGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.polygonHierarchy = undefined;\n  this.perPositionHeight = undefined;\n  this.closeTop = undefined;\n  this.closeBottom = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.offsetAttribute = undefined;\n  this.arcType = undefined;\n  this.textureCoordinates = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for polygons.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias PolygonGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction PolygonGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new PolygonGeometryOptions(entity),\n    geometryPropertyName: \"polygon\",\n    observedPropertyNames: [\"availability\", \"polygon\"]\n  });\n  this._onEntityPropertyChanged(entity, \"polygon\", entity.polygon, undefined);\n}\nif (defined(Object.create)) {\n  PolygonGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n  PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nPolygonGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const options = this._options;\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n    offset: undefined,\n    color: undefined\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  let geometry;\n  if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n    geometry = new CoplanarPolygonGeometry(options);\n  } else {\n    geometry = new PolygonGeometry(options);\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: geometry,\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nPolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const options = this._options;\n  const outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n  if (defined(options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  let geometry;\n  if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n    geometry = new CoplanarPolygonOutlineGeometry(options);\n  } else {\n    geometry = new PolygonOutlineGeometry(options);\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: geometry,\n    attributes: attributes\n  });\n};\nPolygonGeometryUpdater.prototype._computeCenter = function (time, result) {\n  const hierarchy = Property.getValueOrUndefined(this._entity.polygon.hierarchy, time);\n  if (!defined(hierarchy)) {\n    return;\n  }\n  const positions = hierarchy.positions;\n  if (positions.length === 0) {\n    return;\n  }\n  const ellipsoid = this._scene.ellipsoid;\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(positions, scratch2DPositions);\n  const length = positions2D.length;\n  let area = 0;\n  let j = length - 1;\n  let centroid2D = new Cartesian2();\n  for (let i = 0; i < length; j = i++) {\n    const p1 = positions2D[i];\n    const p2 = positions2D[j];\n    const f = p1.x * p2.y - p2.x * p1.y;\n    let sum = Cartesian2.add(p1, p2, cart2Scratch);\n    sum = Cartesian2.multiplyByScalar(sum, f, sum);\n    centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);\n    area += f;\n  }\n  const a = 1.0 / (area * 3.0);\n  centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);\n  return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);\n};\nPolygonGeometryUpdater.prototype._isHidden = function (entity, polygon) {\n  return !defined(polygon.hierarchy) || GeometryUpdater.prototype._isHidden.call(this, entity, polygon);\n};\nPolygonGeometryUpdater.prototype._isOnTerrain = function (entity, polygon) {\n  const onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(this, entity, polygon);\n  const perPositionHeightProperty = polygon.perPositionHeight;\n  const perPositionHeightEnabled = defined(perPositionHeightProperty) && (perPositionHeightProperty.isConstant ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE) : true);\n  return onTerrain && !perPositionHeightEnabled;\n};\nPolygonGeometryUpdater.prototype._isDynamic = function (entity, polygon) {\n  return !polygon.hierarchy.isConstant ||\n  //\n  !Property.isConstant(polygon.height) ||\n  //\n  !Property.isConstant(polygon.extrudedHeight) ||\n  //\n  !Property.isConstant(polygon.granularity) ||\n  //\n  !Property.isConstant(polygon.stRotation) ||\n  //\n  !Property.isConstant(polygon.textureCoordinates) ||\n  //\n  !Property.isConstant(polygon.outlineWidth) ||\n  //\n  !Property.isConstant(polygon.perPositionHeight) ||\n  //\n  !Property.isConstant(polygon.closeTop) ||\n  //\n  !Property.isConstant(polygon.closeBottom) ||\n  //\n  !Property.isConstant(polygon.zIndex) ||\n  //\n  !Property.isConstant(polygon.arcType) ||\n  //\n  this._onTerrain && !Property.isConstant(this._materialProperty) && !(this._materialProperty instanceof ColorMaterialProperty);\n};\nPolygonGeometryUpdater.prototype._setStaticOptions = function (entity, polygon) {\n  const isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n  const options = this._options;\n  options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  const hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);\n  let heightValue = Property.getValueOrUndefined(polygon.height, Iso8601.MINIMUM_VALUE);\n  const heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  let extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, Iso8601.MINIMUM_VALUE);\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  const perPositionHeightValue = Property.getValueOrDefault(polygon.perPositionHeight, Iso8601.MINIMUM_VALUE, false);\n  heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  let offsetAttribute;\n  if (perPositionHeightValue) {\n    if (defined(heightValue)) {\n      heightValue = undefined;\n      oneTimeWarning(heightAndPerPositionHeightWarning);\n    }\n    if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n      heightValue = undefined;\n      oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n    }\n  } else {\n    if (defined(extrudedHeightValue) && !defined(heightValue)) {\n      heightValue = 0;\n    }\n    offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  }\n  options.polygonHierarchy = hierarchyValue;\n  options.granularity = Property.getValueOrUndefined(polygon.granularity, Iso8601.MINIMUM_VALUE);\n  options.stRotation = Property.getValueOrUndefined(polygon.stRotation, Iso8601.MINIMUM_VALUE);\n  options.perPositionHeight = perPositionHeightValue;\n  options.closeTop = Property.getValueOrDefault(polygon.closeTop, Iso8601.MINIMUM_VALUE, true);\n  options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, Iso8601.MINIMUM_VALUE, true);\n  options.offsetAttribute = offsetAttribute;\n  options.height = heightValue;\n  options.arcType = Property.getValueOrDefault(polygon.arcType, Iso8601.MINIMUM_VALUE, ArcType.GEODESIC);\n  options.textureCoordinates = Property.getValueOrUndefined(polygon.textureCoordinates, Iso8601.MINIMUM_VALUE);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    const rectangle = PolygonGeometry.computeRectangleFromPositions(options.polygonHierarchy.positions, options.ellipsoid, options.arcType, scratchRectangle);\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(rectangle).minimumTerrainHeight;\n  }\n  options.extrudedHeight = extrudedHeightValue;\n};\nPolygonGeometryUpdater.prototype._getIsClosed = function (options) {\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const isExtruded = defined(extrudedHeight) && extrudedHeight !== height;\n  return !options.perPositionHeight && (!isExtruded && height === 0 || isExtruded && options.closeTop && options.closeBottom);\n};\nPolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;\n\n/**\n * @private\n */\nfunction DyanmicPolygonGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\nif (defined(Object.create)) {\n  DyanmicPolygonGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DyanmicPolygonGeometryUpdater.prototype.constructor = DyanmicPolygonGeometryUpdater;\n}\nDyanmicPolygonGeometryUpdater.prototype._isHidden = function (entity, polygon, time) {\n  return !defined(this._options.polygonHierarchy) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time);\n};\nDyanmicPolygonGeometryUpdater.prototype._setOptions = function (entity, polygon, time) {\n  const options = this._options;\n  options.polygonHierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);\n  let heightValue = Property.getValueOrUndefined(polygon.height, time);\n  const heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, time, HeightReference.NONE);\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, time, HeightReference.NONE);\n  let extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, time);\n  const perPositionHeightValue = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n  heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, extrudedHeightReferenceValue);\n  let offsetAttribute;\n  if (perPositionHeightValue) {\n    if (defined(heightValue)) {\n      heightValue = undefined;\n      oneTimeWarning(heightAndPerPositionHeightWarning);\n    }\n    if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n      heightValue = undefined;\n      oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n    }\n  } else {\n    if (defined(extrudedHeightValue) && !defined(heightValue)) {\n      heightValue = 0;\n    }\n    offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  }\n  options.granularity = Property.getValueOrUndefined(polygon.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);\n  options.textureCoordinates = Property.getValueOrUndefined(polygon.textureCoordinates, time);\n  options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n  options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);\n  options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, time, true);\n  options.offsetAttribute = offsetAttribute;\n  options.height = heightValue;\n  options.arcType = Property.getValueOrDefault(polygon.arcType, time, ArcType.GEODESIC);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    const rectangle = PolygonGeometry.computeRectangleFromPositions(options.polygonHierarchy.positions, options.ellipsoid, options.arcType, scratchRectangle);\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(rectangle).minimumTerrainHeight;\n  }\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default PolygonGeometryUpdater;","map":{"version":3,"names":["ApproximateTerrainHeights","ArcType","Cartesian2","Cartesian3","Check","Color","ColorGeometryInstanceAttribute","CoplanarPolygonGeometry","CoplanarPolygonOutlineGeometry","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","EllipsoidTangentPlane","GeometryInstance","Iso8601","OffsetGeometryInstanceAttribute","oneTimeWarning","PolygonGeometry","PolygonOutlineGeometry","Rectangle","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","GroundGeometryUpdater","Property","heightAndPerPositionHeightWarning","heightReferenceAndPerPositionHeightWarning","scratchColor","defaultOffset","ZERO","offsetScratch","scratchRectangle","scratch2DPositions","cart2Scratch","PolygonGeometryOptions","entity","id","vertexFormat","undefined","polygonHierarchy","perPositionHeight","closeTop","closeBottom","height","extrudedHeight","granularity","stRotation","offsetAttribute","arcType","textureCoordinates","PolygonGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","polygon","Object","create","prototype","constructor","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","options","_options","attributes","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","fromDistanceDisplayCondition","_distanceDisplayConditionProperty","offset","color","_materialProperty","currentColor","isConstant","WHITE","fromColor","fromCartesian3","getValueOrDefault","_terrainOffsetProperty","geometry","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","hierarchy","getValueOrUndefined","positions","length","ellipsoid","_scene","tangentPlane","fromPoints","positions2D","projectPointsOntoPlane","area","j","centroid2D","i","p1","p2","f","x","y","sum","add","multiplyByScalar","a","projectPointOntoEllipsoid","_isHidden","_isOnTerrain","onTerrain","perPositionHeightProperty","perPositionHeightEnabled","MINIMUM_VALUE","_isDynamic","outlineWidth","zIndex","_onTerrain","_setStaticOptions","isColorMaterial","VERTEX_FORMAT","MaterialSupport","TEXTURED","hierarchyValue","heightValue","heightReferenceValue","heightReference","NONE","extrudedHeightValue","extrudedHeightReferenceValue","extrudedHeightReference","perPositionHeightValue","getGeometryHeight","computeGeometryOffsetAttribute","GEODESIC","getGeometryExtrudedHeight","CLAMP_TO_GROUND","rectangle","computeRectangleFromPositions","getMinimumMaximumHeights","minimumTerrainHeight","_getIsClosed","isExtruded","DyanmicPolygonGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/PolygonGeometryUpdater.js"],"sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ArcType from \"../Core/ArcType.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport CoplanarPolygonGeometry from \"../Core/CoplanarPolygonGeometry.js\";\nimport CoplanarPolygonOutlineGeometry from \"../Core/CoplanarPolygonOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipsoidTangentPlane from \"../Core/EllipsoidTangentPlane.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\nimport PolygonOutlineGeometry from \"../Core/PolygonOutlineGeometry.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\n\nconst heightAndPerPositionHeightWarning =\n  \"Entity polygons cannot have both height and perPositionHeight.  height will be ignored\";\nconst heightReferenceAndPerPositionHeightWarning =\n  \"heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored\";\n\nconst scratchColor = new Color();\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst scratchRectangle = new Rectangle();\nconst scratch2DPositions = [];\nconst cart2Scratch = new Cartesian2();\n\nfunction PolygonGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.polygonHierarchy = undefined;\n  this.perPositionHeight = undefined;\n  this.closeTop = undefined;\n  this.closeBottom = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.offsetAttribute = undefined;\n  this.arcType = undefined;\n  this.textureCoordinates = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for polygons.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias PolygonGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction PolygonGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new PolygonGeometryOptions(entity),\n    geometryPropertyName: \"polygon\",\n    observedPropertyNames: [\"availability\", \"polygon\"],\n  });\n\n  this._onEntityPropertyChanged(entity, \"polygon\", entity.polygon, undefined);\n}\n\nif (defined(Object.create)) {\n  PolygonGeometryUpdater.prototype = Object.create(\n    GroundGeometryUpdater.prototype,\n  );\n  PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nPolygonGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const options = this._options;\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._fillProperty.getValue(time),\n    ),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        this._distanceDisplayConditionProperty.getValue(time),\n      ),\n    offset: undefined,\n    color: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  let geometry;\n  if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n    geometry = new CoplanarPolygonGeometry(options);\n  } else {\n    geometry = new PolygonGeometry(options);\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: geometry,\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nPolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const options = this._options;\n  const outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time),\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        distanceDisplayCondition,\n      ),\n    offset: undefined,\n  };\n\n  if (defined(options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  let geometry;\n  if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n    geometry = new CoplanarPolygonOutlineGeometry(options);\n  } else {\n    geometry = new PolygonOutlineGeometry(options);\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: geometry,\n    attributes: attributes,\n  });\n};\n\nPolygonGeometryUpdater.prototype._computeCenter = function (time, result) {\n  const hierarchy = Property.getValueOrUndefined(\n    this._entity.polygon.hierarchy,\n    time,\n  );\n  if (!defined(hierarchy)) {\n    return;\n  }\n  const positions = hierarchy.positions;\n  if (positions.length === 0) {\n    return;\n  }\n  const ellipsoid = this._scene.ellipsoid;\n\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    scratch2DPositions,\n  );\n\n  const length = positions2D.length;\n  let area = 0;\n  let j = length - 1;\n  let centroid2D = new Cartesian2();\n  for (let i = 0; i < length; j = i++) {\n    const p1 = positions2D[i];\n    const p2 = positions2D[j];\n    const f = p1.x * p2.y - p2.x * p1.y;\n\n    let sum = Cartesian2.add(p1, p2, cart2Scratch);\n    sum = Cartesian2.multiplyByScalar(sum, f, sum);\n    centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);\n\n    area += f;\n  }\n\n  const a = 1.0 / (area * 3.0);\n  centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);\n  return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);\n};\n\nPolygonGeometryUpdater.prototype._isHidden = function (entity, polygon) {\n  return (\n    !defined(polygon.hierarchy) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, polygon)\n  );\n};\n\nPolygonGeometryUpdater.prototype._isOnTerrain = function (entity, polygon) {\n  const onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(\n    this,\n    entity,\n    polygon,\n  );\n  const perPositionHeightProperty = polygon.perPositionHeight;\n  const perPositionHeightEnabled =\n    defined(perPositionHeightProperty) &&\n    (perPositionHeightProperty.isConstant\n      ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE)\n      : true);\n  return onTerrain && !perPositionHeightEnabled;\n};\n\nPolygonGeometryUpdater.prototype._isDynamic = function (entity, polygon) {\n  return (\n    !polygon.hierarchy.isConstant || //\n    !Property.isConstant(polygon.height) || //\n    !Property.isConstant(polygon.extrudedHeight) || //\n    !Property.isConstant(polygon.granularity) || //\n    !Property.isConstant(polygon.stRotation) || //\n    !Property.isConstant(polygon.textureCoordinates) || //\n    !Property.isConstant(polygon.outlineWidth) || //\n    !Property.isConstant(polygon.perPositionHeight) || //\n    !Property.isConstant(polygon.closeTop) || //\n    !Property.isConstant(polygon.closeBottom) || //\n    !Property.isConstant(polygon.zIndex) || //\n    !Property.isConstant(polygon.arcType) || //\n    (this._onTerrain &&\n      !Property.isConstant(this._materialProperty) &&\n      !(this._materialProperty instanceof ColorMaterialProperty))\n  );\n};\n\nPolygonGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  polygon,\n) {\n  const isColorMaterial =\n    this._materialProperty instanceof ColorMaterialProperty;\n\n  const options = this._options;\n  options.vertexFormat = isColorMaterial\n    ? PerInstanceColorAppearance.VERTEX_FORMAT\n    : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n\n  const hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);\n  let heightValue = Property.getValueOrUndefined(\n    polygon.height,\n    Iso8601.MINIMUM_VALUE,\n  );\n  const heightReferenceValue = Property.getValueOrDefault(\n    polygon.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n  let extrudedHeightValue = Property.getValueOrUndefined(\n    polygon.extrudedHeight,\n    Iso8601.MINIMUM_VALUE,\n  );\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(\n    polygon.extrudedHeightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n  const perPositionHeightValue = Property.getValueOrDefault(\n    polygon.perPositionHeight,\n    Iso8601.MINIMUM_VALUE,\n    false,\n  );\n\n  heightValue = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue,\n  );\n\n  let offsetAttribute;\n  if (perPositionHeightValue) {\n    if (defined(heightValue)) {\n      heightValue = undefined;\n      oneTimeWarning(heightAndPerPositionHeightWarning);\n    }\n    if (\n      heightReferenceValue !== HeightReference.NONE &&\n      perPositionHeightValue\n    ) {\n      heightValue = undefined;\n      oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n    }\n  } else {\n    if (defined(extrudedHeightValue) && !defined(heightValue)) {\n      heightValue = 0;\n    }\n    offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n      heightValue,\n      heightReferenceValue,\n      extrudedHeightValue,\n      extrudedHeightReferenceValue,\n    );\n  }\n\n  options.polygonHierarchy = hierarchyValue;\n  options.granularity = Property.getValueOrUndefined(\n    polygon.granularity,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.stRotation = Property.getValueOrUndefined(\n    polygon.stRotation,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.perPositionHeight = perPositionHeightValue;\n  options.closeTop = Property.getValueOrDefault(\n    polygon.closeTop,\n    Iso8601.MINIMUM_VALUE,\n    true,\n  );\n  options.closeBottom = Property.getValueOrDefault(\n    polygon.closeBottom,\n    Iso8601.MINIMUM_VALUE,\n    true,\n  );\n  options.offsetAttribute = offsetAttribute;\n  options.height = heightValue;\n  options.arcType = Property.getValueOrDefault(\n    polygon.arcType,\n    Iso8601.MINIMUM_VALUE,\n    ArcType.GEODESIC,\n  );\n  options.textureCoordinates = Property.getValueOrUndefined(\n    polygon.textureCoordinates,\n    Iso8601.MINIMUM_VALUE,\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue,\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    const rectangle = PolygonGeometry.computeRectangleFromPositions(\n      options.polygonHierarchy.positions,\n      options.ellipsoid,\n      options.arcType,\n      scratchRectangle,\n    );\n    extrudedHeightValue =\n      ApproximateTerrainHeights.getMinimumMaximumHeights(\n        rectangle,\n      ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nPolygonGeometryUpdater.prototype._getIsClosed = function (options) {\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const isExtruded = defined(extrudedHeight) && extrudedHeight !== height;\n  return (\n    !options.perPositionHeight &&\n    ((!isExtruded && height === 0) ||\n      (isExtruded && options.closeTop && options.closeBottom))\n  );\n};\n\nPolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;\n\n/**\n * @private\n */\nfunction DyanmicPolygonGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives,\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives,\n  );\n}\n\nif (defined(Object.create)) {\n  DyanmicPolygonGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype,\n  );\n  DyanmicPolygonGeometryUpdater.prototype.constructor =\n    DyanmicPolygonGeometryUpdater;\n}\n\nDyanmicPolygonGeometryUpdater.prototype._isHidden = function (\n  entity,\n  polygon,\n  time,\n) {\n  return (\n    !defined(this._options.polygonHierarchy) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time)\n  );\n};\n\nDyanmicPolygonGeometryUpdater.prototype._setOptions = function (\n  entity,\n  polygon,\n  time,\n) {\n  const options = this._options;\n\n  options.polygonHierarchy = Property.getValueOrUndefined(\n    polygon.hierarchy,\n    time,\n  );\n\n  let heightValue = Property.getValueOrUndefined(polygon.height, time);\n  const heightReferenceValue = Property.getValueOrDefault(\n    polygon.heightReference,\n    time,\n    HeightReference.NONE,\n  );\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(\n    polygon.extrudedHeightReference,\n    time,\n    HeightReference.NONE,\n  );\n  let extrudedHeightValue = Property.getValueOrUndefined(\n    polygon.extrudedHeight,\n    time,\n  );\n  const perPositionHeightValue = Property.getValueOrUndefined(\n    polygon.perPositionHeight,\n    time,\n  );\n\n  heightValue = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    extrudedHeightReferenceValue,\n  );\n\n  let offsetAttribute;\n  if (perPositionHeightValue) {\n    if (defined(heightValue)) {\n      heightValue = undefined;\n      oneTimeWarning(heightAndPerPositionHeightWarning);\n    }\n    if (\n      heightReferenceValue !== HeightReference.NONE &&\n      perPositionHeightValue\n    ) {\n      heightValue = undefined;\n      oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n    }\n  } else {\n    if (defined(extrudedHeightValue) && !defined(heightValue)) {\n      heightValue = 0;\n    }\n\n    offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(\n      heightValue,\n      heightReferenceValue,\n      extrudedHeightValue,\n      extrudedHeightReferenceValue,\n    );\n  }\n\n  options.granularity = Property.getValueOrUndefined(polygon.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);\n  options.textureCoordinates = Property.getValueOrUndefined(\n    polygon.textureCoordinates,\n    time,\n  );\n  options.perPositionHeight = Property.getValueOrUndefined(\n    polygon.perPositionHeight,\n    time,\n  );\n  options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);\n  options.closeBottom = Property.getValueOrDefault(\n    polygon.closeBottom,\n    time,\n    true,\n  );\n  options.offsetAttribute = offsetAttribute;\n  options.height = heightValue;\n  options.arcType = Property.getValueOrDefault(\n    polygon.arcType,\n    time,\n    ArcType.GEODESIC,\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue,\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    const rectangle = PolygonGeometry.computeRectangleFromPositions(\n      options.polygonHierarchy.positions,\n      options.ellipsoid,\n      options.arcType,\n      scratchRectangle,\n    );\n    extrudedHeightValue =\n      ApproximateTerrainHeights.getMinimumMaximumHeights(\n        rectangle,\n      ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default PolygonGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}