{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nexport default Ray;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","Ray","origin","direction","clone","ZERO","equals","normalize","ray","result","undefined","getPoint","t","typeOf","object","number","multiplyByScalar","add"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Ray.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Represents a ray that extends infinitely from the provided origin in the provided direction.\n * @alias Ray\n * @constructor\n *\n * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n */\nfunction Ray(origin, direction) {\n  direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\n  if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n    Cartesian3.normalize(direction, direction);\n  }\n\n  /**\n   * The origin of the ray.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\n\n  /**\n   * The direction of the ray.\n   * @type {Cartesian3}\n   */\n  this.direction = direction;\n}\n\n/**\n * Duplicates a Ray instance.\n *\n * @param {Ray} ray The ray to duplicate.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)\n */\nRay.clone = function (ray, result) {\n  if (!defined(ray)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Ray(ray.origin, ray.direction);\n  }\n  result.origin = Cartesian3.clone(ray.origin);\n  result.direction = Cartesian3.clone(ray.direction);\n  return result;\n};\n\n/**\n * Computes the point along the ray given by r(t) = o + t*d,\n * where o is the origin of the ray and d is the direction.\n *\n * @param {Ray} ray The ray.\n * @param {number} t A scalar value.\n * @param {Cartesian3} [result] The object in which the result will be stored.\n * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n *\n * @example\n * //Get the first intersection point of a ray and an ellipsoid.\n * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n * const point = Cesium.Ray.getPoint(ray, intersection.start);\n */\nRay.getPoint = function (ray, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ray\", ray);\n  Check.typeOf.number(\"t\", t);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\nexport default Ray;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,iBAAiB;AACxC,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,OAAO,MAAM,cAAc;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,GAAGA,CAACC,MAAM,EAAEC,SAAS,EAAE;EAC9BA,SAAS,GAAGN,UAAU,CAACO,KAAK,CAACL,YAAY,CAACI,SAAS,EAAEN,UAAU,CAACQ,IAAI,CAAC,CAAC;EACtE,IAAI,CAACR,UAAU,CAACS,MAAM,CAACH,SAAS,EAAEN,UAAU,CAACQ,IAAI,CAAC,EAAE;IAClDR,UAAU,CAACU,SAAS,CAACJ,SAAS,EAAEA,SAAS,CAAC;EAC5C;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAI,CAACD,MAAM,GAAGL,UAAU,CAACO,KAAK,CAACL,YAAY,CAACG,MAAM,EAAEL,UAAU,CAACQ,IAAI,CAAC,CAAC;;EAErE;AACF;AACA;AACA;EACE,IAAI,CAACF,SAAS,GAAGA,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,GAAG,CAACG,KAAK,GAAG,UAAUI,GAAG,EAAEC,MAAM,EAAE;EACjC,IAAI,CAACT,OAAO,CAACQ,GAAG,CAAC,EAAE;IACjB,OAAOE,SAAS;EAClB;EACA,IAAI,CAACV,OAAO,CAACS,MAAM,CAAC,EAAE;IACpB,OAAO,IAAIR,GAAG,CAACO,GAAG,CAACN,MAAM,EAAEM,GAAG,CAACL,SAAS,CAAC;EAC3C;EACAM,MAAM,CAACP,MAAM,GAAGL,UAAU,CAACO,KAAK,CAACI,GAAG,CAACN,MAAM,CAAC;EAC5CO,MAAM,CAACN,SAAS,GAAGN,UAAU,CAACO,KAAK,CAACI,GAAG,CAACL,SAAS,CAAC;EAClD,OAAOM,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,GAAG,CAACU,QAAQ,GAAG,UAAUH,GAAG,EAAEI,CAAC,EAAEH,MAAM,EAAE;EACvC;EACAX,KAAK,CAACe,MAAM,CAACC,MAAM,CAAC,KAAK,EAAEN,GAAG,CAAC;EAC/BV,KAAK,CAACe,MAAM,CAACE,MAAM,CAAC,GAAG,EAAEH,CAAC,CAAC;EAC3B;;EAEA,IAAI,CAACZ,OAAO,CAACS,MAAM,CAAC,EAAE;IACpBA,MAAM,GAAG,IAAIZ,UAAU,CAAC,CAAC;EAC3B;EAEAY,MAAM,GAAGZ,UAAU,CAACmB,gBAAgB,CAACR,GAAG,CAACL,SAAS,EAAES,CAAC,EAAEH,MAAM,CAAC;EAC9D,OAAOZ,UAAU,CAACoB,GAAG,CAACT,GAAG,CAACN,MAAM,EAAEO,MAAM,EAAEA,MAAM,CAAC;AACnD,CAAC;AACD,eAAeR,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}