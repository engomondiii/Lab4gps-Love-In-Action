{"ast":null,"code":"import ArcType from \"../Core/ArcType.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport getExtensionFromUri from \"../Core/getExtensionFromUri.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport objectToQuery from \"../Core/objectToQuery.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport queryToObject from \"../Core/queryToObject.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Autolinker from \"autolinker\";\nimport Uri from \"urijs\";\nimport * as zip from \"@zip.js/zip.js/lib/zip-no-worker.js\";\nimport getElement from \"./getElement.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport KmlCamera from \"./KmlCamera.js\";\nimport KmlLookAt from \"./KmlLookAt.js\";\nimport KmlTour from \"./KmlTour.js\";\nimport KmlTourFlyTo from \"./KmlTourFlyTo.js\";\nimport KmlTourWait from \"./KmlTourWait.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\n\n//This is by no means an exhaustive list of MIME types.\n//The purpose of this list is to be able to accurately identify content embedded\n//in KMZ files. Eventually, we can make this configurable by the end user so they can add\n//there own content types if they have KMZ files that require it.\nconst MimeTypes = {\n  avi: \"video/x-msvideo\",\n  bmp: \"image/bmp\",\n  bz2: \"application/x-bzip2\",\n  chm: \"application/vnd.ms-htmlhelp\",\n  css: \"text/css\",\n  csv: \"text/csv\",\n  doc: \"application/msword\",\n  dvi: \"application/x-dvi\",\n  eps: \"application/postscript\",\n  flv: \"video/x-flv\",\n  gif: \"image/gif\",\n  gz: \"application/x-gzip\",\n  htm: \"text/html\",\n  html: \"text/html\",\n  ico: \"image/vnd.microsoft.icon\",\n  jnlp: \"application/x-java-jnlp-file\",\n  jpeg: \"image/jpeg\",\n  jpg: \"image/jpeg\",\n  m3u: \"audio/x-mpegurl\",\n  m4v: \"video/mp4\",\n  mathml: \"application/mathml+xml\",\n  mid: \"audio/midi\",\n  midi: \"audio/midi\",\n  mov: \"video/quicktime\",\n  mp3: \"audio/mpeg\",\n  mp4: \"video/mp4\",\n  mp4v: \"video/mp4\",\n  mpeg: \"video/mpeg\",\n  mpg: \"video/mpeg\",\n  odp: \"application/vnd.oasis.opendocument.presentation\",\n  ods: \"application/vnd.oasis.opendocument.spreadsheet\",\n  odt: \"application/vnd.oasis.opendocument.text\",\n  ogg: \"application/ogg\",\n  pdf: \"application/pdf\",\n  png: \"image/png\",\n  pps: \"application/vnd.ms-powerpoint\",\n  ppt: \"application/vnd.ms-powerpoint\",\n  ps: \"application/postscript\",\n  qt: \"video/quicktime\",\n  rdf: \"application/rdf+xml\",\n  rss: \"application/rss+xml\",\n  rtf: \"application/rtf\",\n  svg: \"image/svg+xml\",\n  swf: \"application/x-shockwave-flash\",\n  text: \"text/plain\",\n  tif: \"image/tiff\",\n  tiff: \"image/tiff\",\n  txt: \"text/plain\",\n  wav: \"audio/x-wav\",\n  wma: \"audio/x-ms-wma\",\n  wmv: \"video/x-ms-wmv\",\n  xml: \"application/xml\",\n  zip: \"application/zip\",\n  detectFromFilename: function (filename) {\n    let ext = filename.toLowerCase();\n    ext = getExtensionFromUri(ext);\n    return MimeTypes[ext];\n  }\n};\nlet parser;\nif (typeof DOMParser !== \"undefined\") {\n  parser = new DOMParser();\n}\nconst autolinker = new Autolinker({\n  stripPrefix: false,\n  email: false,\n  replaceFn: function (match) {\n    //Prevent matching of non-explicit urls.\n    //i.e. foo.id won't match but http://foo.id will\n    return match.urlMatchType === \"scheme\" || match.urlMatchType === \"www\";\n  }\n});\nconst BILLBOARD_SIZE = 32;\nconst BILLBOARD_NEAR_DISTANCE = 2414016;\nconst BILLBOARD_NEAR_RATIO = 1.0;\nconst BILLBOARD_FAR_DISTANCE = 1.6093e7;\nconst BILLBOARD_FAR_RATIO = 0.1;\nconst kmlNamespaces = [null, undefined, \"http://www.opengis.net/kml/2.2\", \"http://earth.google.com/kml/2.2\", \"http://earth.google.com/kml/2.1\", \"http://earth.google.com/kml/2.0\"];\nconst gxNamespaces = [\"http://www.google.com/kml/ext/2.2\"];\nconst atomNamespaces = [\"http://www.w3.org/2005/Atom\"];\nconst namespaces = {\n  kml: kmlNamespaces,\n  gx: gxNamespaces,\n  atom: atomNamespaces,\n  kmlgx: kmlNamespaces.concat(gxNamespaces)\n};\n\n// Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types\nconst featureTypes = {\n  Document: processDocument,\n  Folder: processFolder,\n  Placemark: processPlacemark,\n  NetworkLink: processNetworkLink,\n  GroundOverlay: processGroundOverlay,\n  PhotoOverlay: processUnsupportedFeature,\n  ScreenOverlay: processScreenOverlay,\n  Tour: processTour\n};\nfunction DeferredLoading(dataSource) {\n  this._dataSource = dataSource;\n  this._deferred = defer();\n  this._stack = [];\n  this._promises = [];\n  this._timeoutSet = false;\n  this._used = false;\n  this._started = 0;\n  this._timeThreshold = 1000; // Initial load is 1 second\n}\nObject.defineProperties(DeferredLoading.prototype, {\n  dataSource: {\n    get: function () {\n      return this._dataSource;\n    }\n  }\n});\nDeferredLoading.prototype.addNodes = function (nodes, processingData) {\n  this._stack.push({\n    nodes: nodes,\n    index: 0,\n    processingData: processingData\n  });\n  this._used = true;\n};\nDeferredLoading.prototype.addPromise = function (promise) {\n  this._promises.push(promise);\n};\nDeferredLoading.prototype.wait = function () {\n  // Case where we had a non-document/folder as the root\n  const deferred = this._deferred;\n  if (!this._used) {\n    deferred.resolve();\n  }\n  return Promise.all([deferred.promise, Promise.all(this._promises)]);\n};\nDeferredLoading.prototype.process = function () {\n  const isFirstCall = this._stack.length === 1;\n  if (isFirstCall) {\n    this._started = KmlDataSource._getTimestamp();\n  }\n  return this._process(isFirstCall);\n};\nDeferredLoading.prototype._giveUpTime = function () {\n  if (this._timeoutSet) {\n    // Timeout was already set so just return\n    return;\n  }\n  this._timeoutSet = true;\n  this._timeThreshold = 50; // After the first load lower threshold to 0.5 seconds\n  const that = this;\n  setTimeout(function () {\n    that._timeoutSet = false;\n    that._started = KmlDataSource._getTimestamp();\n    that._process(true);\n  }, 0);\n};\nDeferredLoading.prototype._nextNode = function () {\n  const stack = this._stack;\n  const top = stack[stack.length - 1];\n  const index = top.index;\n  const nodes = top.nodes;\n  if (index === nodes.length) {\n    return;\n  }\n  ++top.index;\n  return nodes[index];\n};\nDeferredLoading.prototype._pop = function () {\n  const stack = this._stack;\n  stack.pop();\n\n  // Return false if we are done\n  if (stack.length === 0) {\n    this._deferred.resolve();\n    return false;\n  }\n  return true;\n};\nDeferredLoading.prototype._process = function (isFirstCall) {\n  const dataSource = this.dataSource;\n  const processingData = this._stack[this._stack.length - 1].processingData;\n  let child = this._nextNode();\n  while (defined(child)) {\n    const featureProcessor = featureTypes[child.localName];\n    if (defined(featureProcessor) && (namespaces.kml.indexOf(child.namespaceURI) !== -1 || namespaces.gx.indexOf(child.namespaceURI) !== -1)) {\n      featureProcessor(dataSource, child, processingData, this);\n\n      // Give up time and continue loading later\n      if (this._timeoutSet || KmlDataSource._getTimestamp() > this._started + this._timeThreshold) {\n        this._giveUpTime();\n        return;\n      }\n    }\n    child = this._nextNode();\n  }\n\n  // If we are a recursive call from a subfolder, just return so the parent folder can continue processing\n  // If we aren't then make another call to processNodes because there is stuff still left in the queue\n  if (this._pop() && isFirstCall) {\n    this._process(true);\n  }\n};\nfunction isZipFile(blob) {\n  const magicBlob = blob.slice(0, Math.min(4, blob.size));\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(new DataView(reader.result).getUint32(0, false) === 0x504b0304);\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsArrayBuffer(magicBlob);\n  return deferred.promise;\n}\nfunction readBlobAsText(blob) {\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(reader.result);\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsText(blob);\n  return deferred.promise;\n}\nfunction insertNamespaces(text) {\n  const namespaceMap = {\n    xsi: \"http://www.w3.org/2001/XMLSchema-instance\"\n  };\n  let firstPart, lastPart, reg, declaration;\n  for (const key in namespaceMap) {\n    if (namespaceMap.hasOwnProperty(key)) {\n      reg = RegExp(`[< ]${key}:`);\n      declaration = `xmlns:${key}=`;\n      if (reg.test(text) && text.indexOf(declaration) === -1) {\n        if (!defined(firstPart)) {\n          firstPart = text.substr(0, text.indexOf(\"<kml\") + 4);\n          lastPart = text.substr(firstPart.length);\n        }\n        firstPart += ` ${declaration}\"${namespaceMap[key]}\"`;\n      }\n    }\n  }\n  if (defined(firstPart)) {\n    text = firstPart + lastPart;\n  }\n  return text;\n}\nfunction removeDuplicateNamespaces(text) {\n  let index = text.indexOf(\"xmlns:\");\n  const endDeclaration = text.indexOf(\">\", index);\n  let namespace, startIndex, endIndex;\n  while (index !== -1 && index < endDeclaration) {\n    namespace = text.slice(index, text.indexOf('\"', index));\n    startIndex = index;\n    index = text.indexOf(namespace, index + 1);\n    if (index !== -1) {\n      endIndex = text.indexOf('\"', text.indexOf('\"', index) + 1);\n      text = text.slice(0, index - 1) + text.slice(endIndex + 1, text.length);\n      index = text.indexOf(\"xmlns:\", startIndex - 1);\n    } else {\n      index = text.indexOf(\"xmlns:\", startIndex + 1);\n    }\n  }\n  return text;\n}\nfunction loadXmlFromZip(entry, uriResolver) {\n  return Promise.resolve(entry.getData(new zip.TextWriter())).then(function (text) {\n    text = insertNamespaces(text);\n    text = removeDuplicateNamespaces(text);\n    uriResolver.kml = parser.parseFromString(text, \"application/xml\");\n  });\n}\nfunction loadDataUriFromZip(entry, uriResolver) {\n  const mimeType = defaultValue(MimeTypes.detectFromFilename(entry.filename), \"application/octet-stream\");\n  return Promise.resolve(entry.getData(new zip.Data64URIWriter(mimeType))).then(function (dataUri) {\n    uriResolver[entry.filename] = dataUri;\n  });\n}\nfunction embedDataUris(div, elementType, attributeName, uriResolver) {\n  const keys = uriResolver.keys;\n  const baseUri = new Uri(\".\");\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    if (defined(value)) {\n      const relativeUri = new Uri(value);\n      const uri = relativeUri.absoluteTo(baseUri).toString();\n      const index = keys.indexOf(uri);\n      if (index !== -1) {\n        const key = keys[index];\n        element.setAttribute(attributeName, uriResolver[key]);\n        if (elementType === \"a\" && element.getAttribute(\"download\") === null) {\n          element.setAttribute(\"download\", key);\n        }\n      }\n    }\n  }\n}\nfunction applyBasePath(div, elementType, attributeName, sourceResource) {\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    const resource = resolveHref(value, sourceResource);\n    if (defined(resource)) {\n      element.setAttribute(attributeName, resource.url);\n    }\n  }\n}\n\n// an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse\n// correctly, as they do in Google Earth.\nfunction createEntity(node, entityCollection, context) {\n  let id = queryStringAttribute(node, \"id\");\n  id = defined(id) && id.length !== 0 ? id : createGuid();\n  if (defined(context)) {\n    id = context + id;\n  }\n\n  // If we have a duplicate ID just generate one.\n  // This isn't valid KML but Google Earth handles this case.\n  let entity = entityCollection.getById(id);\n  if (defined(entity)) {\n    id = createGuid();\n    if (defined(context)) {\n      id = context + id;\n    }\n  }\n  entity = entityCollection.add(new Entity({\n    id: id\n  }));\n  if (!defined(entity.kml)) {\n    entity.addProperty(\"kml\");\n    entity.kml = new KmlFeatureData();\n  }\n  return entity;\n}\nfunction isExtrudable(altitudeMode, gxAltitudeMode) {\n  return altitudeMode === \"absolute\" || altitudeMode === \"relativeToGround\" || gxAltitudeMode === \"relativeToSeaFloor\";\n}\nfunction readCoordinate(value, ellipsoid) {\n  //Google Earth treats empty or missing coordinates as 0.\n  if (!defined(value)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n  const digits = value.match(/[^\\s,\\n]+/g);\n  if (!defined(digits)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n  let longitude = parseFloat(digits[0]);\n  let latitude = parseFloat(digits[1]);\n  let height = parseFloat(digits[2]);\n  longitude = isNaN(longitude) ? 0.0 : longitude;\n  latitude = isNaN(latitude) ? 0.0 : latitude;\n  height = isNaN(height) ? 0.0 : height;\n  return Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);\n}\nfunction readCoordinates(element, ellipsoid) {\n  if (!defined(element)) {\n    return undefined;\n  }\n  const tuples = element.textContent.match(/[^\\s\\n]+/g);\n  if (!defined(tuples)) {\n    return undefined;\n  }\n  const length = tuples.length;\n  const result = new Array(length);\n  let resultIndex = 0;\n  for (let i = 0; i < length; i++) {\n    result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);\n  }\n  return result;\n}\nfunction queryNumericAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  if (value !== null) {\n    const result = parseFloat(value);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\nfunction queryStringAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  return value !== null ? value : undefined;\n}\nfunction queryFirstNode(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      return child;\n    }\n  }\n  return undefined;\n}\nfunction queryNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const result = [];\n  const childNodes = node.getElementsByTagNameNS(\"*\", tagName);\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      result.push(child);\n    }\n  }\n  return result;\n}\nfunction queryChildNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return [];\n  }\n  const result = [];\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      result.push(child);\n    }\n  }\n  return result;\n}\nfunction queryNumericValue(node, tagName, namespace) {\n  const resultNode = queryFirstNode(node, tagName, namespace);\n  if (defined(resultNode)) {\n    const result = parseFloat(resultNode.textContent);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\nfunction queryStringValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    return result.textContent.trim();\n  }\n  return undefined;\n}\nfunction queryBooleanValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    const value = result.textContent.trim();\n    return value === \"1\" || /^true$/i.test(value);\n  }\n  return undefined;\n}\nfunction resolveHref(href, sourceResource, uriResolver) {\n  if (!defined(href)) {\n    return undefined;\n  }\n  let resource;\n  if (defined(uriResolver)) {\n    // To resolve issues with KML sources defined in Windows style paths.\n    href = href.replace(/\\\\/g, \"/\");\n    let blob = uriResolver[href];\n    if (defined(blob)) {\n      resource = new Resource({\n        url: blob\n      });\n    } else {\n      // Needed for multiple levels of KML files in a KMZ\n      const baseUri = new Uri(sourceResource.getUrlComponent());\n      const uri = new Uri(href);\n      blob = uriResolver[uri.absoluteTo(baseUri)];\n      if (defined(blob)) {\n        resource = new Resource({\n          url: blob\n        });\n      }\n    }\n  }\n  if (!defined(resource)) {\n    resource = sourceResource.getDerivedResource({\n      url: href\n    });\n  }\n  return resource;\n}\nconst colorOptions = {\n  maximumRed: undefined,\n  red: undefined,\n  maximumGreen: undefined,\n  green: undefined,\n  maximumBlue: undefined,\n  blue: undefined\n};\nfunction parseColorString(value, isRandom) {\n  if (!defined(value) || /^\\s*$/gm.test(value)) {\n    return undefined;\n  }\n  if (value[0] === \"#\") {\n    value = value.substring(1);\n  }\n  const alpha = parseInt(value.substring(0, 2), 16) / 255.0;\n  const blue = parseInt(value.substring(2, 4), 16) / 255.0;\n  const green = parseInt(value.substring(4, 6), 16) / 255.0;\n  const red = parseInt(value.substring(6, 8), 16) / 255.0;\n  if (!isRandom) {\n    return new Color(red, green, blue, alpha);\n  }\n  if (red > 0) {\n    colorOptions.maximumRed = red;\n    colorOptions.red = undefined;\n  } else {\n    colorOptions.maximumRed = undefined;\n    colorOptions.red = 0;\n  }\n  if (green > 0) {\n    colorOptions.maximumGreen = green;\n    colorOptions.green = undefined;\n  } else {\n    colorOptions.maximumGreen = undefined;\n    colorOptions.green = 0;\n  }\n  if (blue > 0) {\n    colorOptions.maximumBlue = blue;\n    colorOptions.blue = undefined;\n  } else {\n    colorOptions.maximumBlue = undefined;\n    colorOptions.blue = 0;\n  }\n  colorOptions.alpha = alpha;\n  return Color.fromRandom(colorOptions);\n}\nfunction queryColorValue(node, tagName, namespace) {\n  const value = queryStringValue(node, tagName, namespace);\n  if (!defined(value)) {\n    return undefined;\n  }\n  return parseColorString(value, queryStringValue(node, \"colorMode\", namespace) === \"random\");\n}\nfunction processTimeStamp(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeStamp\", namespaces.kmlgx);\n  const whenString = queryStringValue(node, \"when\", namespaces.kmlgx);\n  if (!defined(node) || !defined(whenString) || whenString.length === 0) {\n    return undefined;\n  }\n\n  //According to the KML spec, a TimeStamp represents a \"single moment in time\"\n  //However, since Cesium animates much differently than Google Earth, that doesn't\n  //Make much sense here.  Instead, we use the TimeStamp as the moment the feature\n  //comes into existence.  This works much better and gives a similar feel to\n  //GE's experience.\n  const when = JulianDate.fromIso8601(whenString);\n  const result = new TimeIntervalCollection();\n  result.addInterval(new TimeInterval({\n    start: when,\n    stop: Iso8601.MAXIMUM_VALUE\n  }));\n  return result;\n}\nfunction processTimeSpan(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeSpan\", namespaces.kmlgx);\n  if (!defined(node)) {\n    return undefined;\n  }\n  let result;\n  const beginNode = queryFirstNode(node, \"begin\", namespaces.kmlgx);\n  let beginDate = defined(beginNode) ? JulianDate.fromIso8601(beginNode.textContent) : undefined;\n  const endNode = queryFirstNode(node, \"end\", namespaces.kmlgx);\n  let endDate = defined(endNode) ? JulianDate.fromIso8601(endNode.textContent) : undefined;\n  if (defined(beginDate) && defined(endDate)) {\n    if (JulianDate.lessThan(endDate, beginDate)) {\n      const tmp = beginDate;\n      beginDate = endDate;\n      endDate = tmp;\n    }\n    result = new TimeIntervalCollection();\n    result.addInterval(new TimeInterval({\n      start: beginDate,\n      stop: endDate\n    }));\n  } else if (defined(beginDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(new TimeInterval({\n      start: beginDate,\n      stop: Iso8601.MAXIMUM_VALUE\n    }));\n  } else if (defined(endDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(new TimeInterval({\n      start: Iso8601.MINIMUM_VALUE,\n      stop: endDate\n    }));\n  }\n  return result;\n}\nfunction createDefaultBillboard() {\n  const billboard = new BillboardGraphics();\n  billboard.width = BILLBOARD_SIZE;\n  billboard.height = BILLBOARD_SIZE;\n  billboard.scaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n  billboard.pixelOffsetScaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n  return billboard;\n}\nfunction createDefaultPolygon() {\n  const polygon = new PolygonGraphics();\n  polygon.outline = true;\n  polygon.outlineColor = Color.WHITE;\n  return polygon;\n}\nfunction createDefaultLabel() {\n  const label = new LabelGraphics();\n  label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n  label.pixelOffset = new Cartesian2(17, 0);\n  label.horizontalOrigin = HorizontalOrigin.LEFT;\n  label.font = \"16px sans-serif\";\n  label.style = LabelStyle.FILL_AND_OUTLINE;\n  return label;\n}\nfunction getIconHref(iconNode, dataSource, sourceResource, uriResolver, canRefresh) {\n  let href = queryStringValue(iconNode, \"href\", namespaces.kml);\n  if (!defined(href) || href.length === 0) {\n    return undefined;\n  }\n  if (href.indexOf(\"root://icons/palette-\") === 0) {\n    const palette = href.charAt(21);\n\n    // Get the icon number\n    let x = defaultValue(queryNumericValue(iconNode, \"x\", namespaces.gx), 0);\n    let y = defaultValue(queryNumericValue(iconNode, \"y\", namespaces.gx), 0);\n    x = Math.min(x / 32, 7);\n    y = 7 - Math.min(y / 32, 7);\n    const iconNum = 8 * y + x;\n    href = `https://maps.google.com/mapfiles/kml/pal${palette}/icon${iconNum}.png`;\n  }\n  const hrefResource = resolveHref(href, sourceResource, uriResolver);\n  if (canRefresh) {\n    const refreshMode = queryStringValue(iconNode, \"refreshMode\", namespaces.kml);\n    const viewRefreshMode = queryStringValue(iconNode, \"viewRefreshMode\", namespaces.kml);\n    if (refreshMode === \"onInterval\" || refreshMode === \"onExpire\") {\n      oneTimeWarning(`kml-refreshMode-${refreshMode}`, `KML - Unsupported Icon refreshMode: ${refreshMode}`);\n    } else if (viewRefreshMode === \"onStop\" || viewRefreshMode === \"onRegion\") {\n      oneTimeWarning(`kml-refreshMode-${viewRefreshMode}`, `KML - Unsupported Icon viewRefreshMode: ${viewRefreshMode}`);\n    }\n    const viewBoundScale = defaultValue(queryStringValue(iconNode, \"viewBoundScale\", namespaces.kml), 1.0);\n    const defaultViewFormat = viewRefreshMode === \"onStop\" ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\" : \"\";\n    const viewFormat = defaultValue(queryStringValue(iconNode, \"viewFormat\", namespaces.kml), defaultViewFormat);\n    const httpQuery = queryStringValue(iconNode, \"httpQuery\", namespaces.kml);\n    if (defined(viewFormat)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n    }\n    if (defined(httpQuery)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n    }\n    const ellipsoid = dataSource._ellipsoid;\n    processNetworkLinkQueryString(hrefResource, dataSource.camera, dataSource.canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);\n    return hrefResource;\n  }\n  return hrefResource;\n}\nfunction processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver) {\n  let scale = queryNumericValue(node, \"scale\", namespaces.kml);\n  const heading = queryNumericValue(node, \"heading\", namespaces.kml);\n  const color = queryColorValue(node, \"color\", namespaces.kml);\n  const iconNode = queryFirstNode(node, \"Icon\", namespaces.kml);\n  let icon = getIconHref(iconNode, dataSource, sourceResource, uriResolver, false);\n\n  // If icon tags are present but blank, we do not want to show an icon\n  if (defined(iconNode) && !defined(icon)) {\n    icon = false;\n  }\n  const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n  const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n  const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n  const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n  const hotSpotNode = queryFirstNode(node, \"hotSpot\", namespaces.kml);\n  const hotSpotX = queryNumericAttribute(hotSpotNode, \"x\");\n  const hotSpotY = queryNumericAttribute(hotSpotNode, \"y\");\n  const hotSpotXUnit = queryStringAttribute(hotSpotNode, \"xunits\");\n  const hotSpotYUnit = queryStringAttribute(hotSpotNode, \"yunits\");\n  let billboard = targetEntity.billboard;\n  if (!defined(billboard)) {\n    billboard = createDefaultBillboard();\n    targetEntity.billboard = billboard;\n  }\n  billboard.image = icon;\n  billboard.scale = scale;\n  billboard.color = color;\n  if (defined(x) || defined(y) || defined(w) || defined(h)) {\n    billboard.imageSubRegion = new BoundingRectangle(x, y, w, h);\n  }\n\n  //GE treats a heading of zero as no heading\n  //You can still point north using a 360 degree angle (or any multiple of 360)\n  if (defined(heading) && heading !== 0) {\n    billboard.rotation = CesiumMath.toRadians(-heading);\n    billboard.alignedAxis = Cartesian3.UNIT_Z;\n  }\n\n  //Hotpot is the KML equivalent of pixel offset\n  //The hotspot origin is the lower left, but we leave\n  //our billboard origin at the center and simply\n  //modify the pixel offset to take this into account\n  scale = defaultValue(scale, 1.0);\n  let xOffset;\n  let yOffset;\n  if (defined(hotSpotX)) {\n    if (hotSpotXUnit === \"pixels\") {\n      xOffset = -hotSpotX * scale;\n    } else if (hotSpotXUnit === \"insetPixels\") {\n      xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;\n    } else if (hotSpotXUnit === \"fraction\") {\n      xOffset = -hotSpotX * BILLBOARD_SIZE * scale;\n    }\n    xOffset += BILLBOARD_SIZE * 0.5 * scale;\n  }\n  if (defined(hotSpotY)) {\n    if (hotSpotYUnit === \"pixels\") {\n      yOffset = hotSpotY * scale;\n    } else if (hotSpotYUnit === \"insetPixels\") {\n      yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;\n    } else if (hotSpotYUnit === \"fraction\") {\n      yOffset = hotSpotY * BILLBOARD_SIZE * scale;\n    }\n    yOffset -= BILLBOARD_SIZE * 0.5 * scale;\n  }\n  if (defined(xOffset) || defined(yOffset)) {\n    billboard.pixelOffset = new Cartesian2(xOffset, yOffset);\n  }\n}\nfunction applyStyle(dataSource, styleNode, targetEntity, sourceResource, uriResolver) {\n  for (let i = 0, len = styleNode.childNodes.length; i < len; i++) {\n    const node = styleNode.childNodes.item(i);\n    if (node.localName === \"IconStyle\") {\n      processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver);\n    } else if (node.localName === \"LabelStyle\") {\n      let label = targetEntity.label;\n      if (!defined(label)) {\n        label = createDefaultLabel();\n        targetEntity.label = label;\n      }\n      label.scale = defaultValue(queryNumericValue(node, \"scale\", namespaces.kml), label.scale);\n      label.fillColor = defaultValue(queryColorValue(node, \"color\", namespaces.kml), label.fillColor);\n      label.text = targetEntity.name;\n    } else if (node.localName === \"LineStyle\") {\n      let polyline = targetEntity.polyline;\n      if (!defined(polyline)) {\n        polyline = new PolylineGraphics();\n        targetEntity.polyline = polyline;\n      }\n      polyline.width = queryNumericValue(node, \"width\", namespaces.kml);\n      polyline.material = queryColorValue(node, \"color\", namespaces.kml);\n      if (defined(queryColorValue(node, \"outerColor\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:outerColor\", \"KML - gx:outerColor is not supported in a LineStyle\");\n      }\n      if (defined(queryNumericValue(node, \"outerWidth\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:outerWidth\", \"KML - gx:outerWidth is not supported in a LineStyle\");\n      }\n      if (defined(queryNumericValue(node, \"physicalWidth\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:physicalWidth\", \"KML - gx:physicalWidth is not supported in a LineStyle\");\n      }\n      if (defined(queryBooleanValue(node, \"labelVisibility\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:labelVisibility\", \"KML - gx:labelVisibility is not supported in a LineStyle\");\n      }\n    } else if (node.localName === \"PolyStyle\") {\n      let polygon = targetEntity.polygon;\n      if (!defined(polygon)) {\n        polygon = createDefaultPolygon();\n        targetEntity.polygon = polygon;\n      }\n      polygon.material = defaultValue(queryColorValue(node, \"color\", namespaces.kml), polygon.material);\n      polygon.fill = defaultValue(queryBooleanValue(node, \"fill\", namespaces.kml), polygon.fill);\n      polygon.outline = defaultValue(queryBooleanValue(node, \"outline\", namespaces.kml), polygon.outline);\n    } else if (node.localName === \"BalloonStyle\") {\n      const bgColor = defaultValue(parseColorString(queryStringValue(node, \"bgColor\", namespaces.kml)), Color.WHITE);\n      const textColor = defaultValue(parseColorString(queryStringValue(node, \"textColor\", namespaces.kml)), Color.BLACK);\n      const text = queryStringValue(node, \"text\", namespaces.kml);\n\n      //This is purely an internal property used in style processing,\n      //it never ends up on the final entity.\n      targetEntity.addProperty(\"balloonStyle\");\n      targetEntity.balloonStyle = {\n        bgColor: bgColor,\n        textColor: textColor,\n        text: text\n      };\n    } else if (node.localName === \"ListStyle\") {\n      const listItemType = queryStringValue(node, \"listItemType\", namespaces.kml);\n      if (listItemType === \"radioFolder\" || listItemType === \"checkOffOnly\") {\n        oneTimeWarning(`kml-listStyle-${listItemType}`, `KML - Unsupported ListStyle with listItemType: ${listItemType}`);\n      }\n    }\n  }\n}\n\n//Processes and merges any inline styles for the provided node into the provided entity.\nfunction computeFinalStyle(dataSource, placeMark, styleCollection, sourceResource, uriResolver) {\n  const result = new Entity();\n  let styleEntity;\n\n  //Google earth seems to always use the last inline Style/StyleMap only\n  let styleIndex = -1;\n  const childNodes = placeMark.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === \"Style\" || child.localName === \"StyleMap\") {\n      styleIndex = q;\n    }\n  }\n  if (styleIndex !== -1) {\n    const inlineStyleNode = childNodes[styleIndex];\n    if (inlineStyleNode.localName === \"Style\") {\n      applyStyle(dataSource, inlineStyleNode, result, sourceResource, uriResolver);\n    } else {\n      // StyleMap\n      const pairs = queryChildNodes(inlineStyleNode, \"Pair\", namespaces.kml);\n      for (let p = 0; p < pairs.length; p++) {\n        const pair = pairs[p];\n        const key = queryStringValue(pair, \"key\", namespaces.kml);\n        if (key === \"normal\") {\n          const styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n          if (defined(styleUrl)) {\n            styleEntity = styleCollection.getById(styleUrl);\n            if (!defined(styleEntity)) {\n              styleEntity = styleCollection.getById(`#${styleUrl}`);\n            }\n            if (defined(styleEntity)) {\n              result.merge(styleEntity);\n            }\n          } else {\n            const node = queryFirstNode(pair, \"Style\", namespaces.kml);\n            applyStyle(dataSource, node, result, sourceResource, uriResolver);\n          }\n        } else {\n          oneTimeWarning(`kml-styleMap-${key}`, `KML - Unsupported StyleMap key: ${key}`);\n        }\n      }\n    }\n  }\n\n  //Google earth seems to always use the first external style only.\n  const externalStyle = queryStringValue(placeMark, \"styleUrl\", namespaces.kml);\n  if (defined(externalStyle)) {\n    let id = externalStyle;\n    if (externalStyle[0] !== \"#\" && externalStyle.indexOf(\"#\") !== -1) {\n      const tokens = externalStyle.split(\"#\");\n      const uri = tokens[0];\n      const resource = sourceResource.getDerivedResource({\n        url: uri\n      });\n      id = `${resource.getUrlComponent()}#${tokens[1]}`;\n    }\n    styleEntity = styleCollection.getById(id);\n    if (!defined(styleEntity)) {\n      styleEntity = styleCollection.getById(`#${id}`);\n    }\n    if (defined(styleEntity)) {\n      result.merge(styleEntity);\n    }\n  }\n  return result;\n}\n\n//Asynchronously processes an external style file.\nfunction processExternalStyles(dataSource, resource, styleCollection) {\n  return resource.fetchXML().then(function (styleKml) {\n    return processStyles(dataSource, styleKml, styleCollection, resource, true);\n  });\n}\n\n//Processes all shared and external styles and stores\n//their id into the provided styleCollection.\n//Returns an array of promises that will resolve when\n//each style is loaded.\nfunction processStyles(dataSource, kml, styleCollection, sourceResource, isExternal, uriResolver) {\n  let i;\n  let id;\n  let styleEntity;\n  let node;\n  const styleNodes = queryNodes(kml, \"Style\", namespaces.kml);\n  if (defined(styleNodes)) {\n    const styleNodesLength = styleNodes.length;\n    for (i = 0; i < styleNodesLength; i++) {\n      node = styleNodes[i];\n      id = queryStringAttribute(node, \"id\");\n      if (defined(id)) {\n        id = `#${id}`;\n        if (isExternal && defined(sourceResource)) {\n          id = sourceResource.getUrlComponent() + id;\n        }\n        if (!defined(styleCollection.getById(id))) {\n          styleEntity = new Entity({\n            id: id\n          });\n          styleCollection.add(styleEntity);\n          applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);\n        }\n      }\n    }\n  }\n  const styleMaps = queryNodes(kml, \"StyleMap\", namespaces.kml);\n  if (defined(styleMaps)) {\n    const styleMapsLength = styleMaps.length;\n    for (i = 0; i < styleMapsLength; i++) {\n      const styleMap = styleMaps[i];\n      id = queryStringAttribute(styleMap, \"id\");\n      if (defined(id)) {\n        const pairs = queryChildNodes(styleMap, \"Pair\", namespaces.kml);\n        for (let p = 0; p < pairs.length; p++) {\n          const pair = pairs[p];\n          const key = queryStringValue(pair, \"key\", namespaces.kml);\n          if (key === \"normal\") {\n            id = `#${id}`;\n            if (isExternal && defined(sourceResource)) {\n              id = sourceResource.getUrlComponent() + id;\n            }\n            if (!defined(styleCollection.getById(id))) {\n              styleEntity = styleCollection.getOrCreateEntity(id);\n              let styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n              if (defined(styleUrl)) {\n                if (styleUrl[0] !== \"#\") {\n                  styleUrl = `#${styleUrl}`;\n                }\n                if (isExternal && defined(sourceResource)) {\n                  styleUrl = sourceResource.getUrlComponent() + styleUrl;\n                }\n                const base = styleCollection.getById(styleUrl);\n                if (defined(base)) {\n                  styleEntity.merge(base);\n                }\n              } else {\n                node = queryFirstNode(pair, \"Style\", namespaces.kml);\n                applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);\n              }\n            }\n          } else {\n            oneTimeWarning(`kml-styleMap-${key}`, `KML - Unsupported StyleMap key: ${key}`);\n          }\n        }\n      }\n    }\n  }\n  const promises = [];\n  const styleUrlNodes = kml.getElementsByTagName(\"styleUrl\");\n  const styleUrlNodesLength = styleUrlNodes.length;\n  for (i = 0; i < styleUrlNodesLength; i++) {\n    const styleReference = styleUrlNodes[i].textContent;\n    if (styleReference[0] !== \"#\") {\n      //According to the spec, all local styles should start with a #\n      //and everything else is an external style that has a # seperating\n      //the URL of the document and the style.  However, Google Earth\n      //also accepts styleUrls without a # as meaning a local style.\n      const tokens = styleReference.split(\"#\");\n      if (tokens.length === 2) {\n        const uri = tokens[0];\n        const resource = sourceResource.getDerivedResource({\n          url: uri\n        });\n        promises.push(processExternalStyles(dataSource, resource, styleCollection));\n      }\n    }\n  }\n  return promises;\n}\nfunction createDropLine(entityCollection, entity, styleEntity) {\n  const entityPosition = new ReferenceProperty(entityCollection, entity.id, [\"position\"]);\n  const surfacePosition = new ScaledPositionProperty(entity.position);\n  entity.polyline = defined(styleEntity.polyline) ? styleEntity.polyline.clone() : new PolylineGraphics();\n  entity.polyline.positions = new PositionPropertyArray([entityPosition, surfacePosition]);\n}\nfunction heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {\n  if (!defined(altitudeMode) && !defined(gxAltitudeMode) || altitudeMode === \"clampToGround\") {\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n  if (altitudeMode === \"relativeToGround\") {\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n  if (altitudeMode === \"absolute\") {\n    return HeightReference.NONE;\n  }\n  if (gxAltitudeMode === \"clampToSeaFloor\") {\n    oneTimeWarning(\"kml-gx:altitudeMode-clampToSeaFloor\", \"KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround.\");\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n  if (gxAltitudeMode === \"relativeToSeaFloor\") {\n    oneTimeWarning(\"kml-gx:altitudeMode-relativeToSeaFloor\", \"KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround.\");\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n  if (defined(altitudeMode)) {\n    oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown <kml:altitudeMode>:${altitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`);\n  } else {\n    oneTimeWarning(\"kml-gx:altitudeMode-unknown\", `KML - Unknown <gx:altitudeMode>:${gxAltitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`);\n  }\n\n  // Clamp to ground is the default\n  return HeightReference.CLAMP_TO_GROUND;\n}\nfunction createPositionPropertyFromAltitudeMode(property, altitudeMode, gxAltitudeMode) {\n  if (gxAltitudeMode === \"relativeToSeaFloor\" || altitudeMode === \"absolute\" || altitudeMode === \"relativeToGround\") {\n    //Just return the ellipsoid referenced property until we support MSL\n    return property;\n  }\n  if (defined(altitudeMode) && altitudeMode !== \"clampToGround\" ||\n  //\n  defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\") {\n    oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${defaultValue(altitudeMode, gxAltitudeMode)}`);\n  }\n\n  // Clamp to ground is the default\n  return new ScaledPositionProperty(property);\n}\nfunction createPositionPropertyArrayFromAltitudeMode(properties, altitudeMode, gxAltitudeMode, ellipsoid) {\n  if (!defined(properties)) {\n    return undefined;\n  }\n  if (gxAltitudeMode === \"relativeToSeaFloor\" || altitudeMode === \"absolute\" || altitudeMode === \"relativeToGround\") {\n    //Just return the ellipsoid referenced property until we support MSL\n    return properties;\n  }\n  if (defined(altitudeMode) && altitudeMode !== \"clampToGround\" ||\n  //\n  defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\") {\n    oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${defaultValue(altitudeMode, gxAltitudeMode)}`);\n  }\n\n  // Clamp to ground is the default\n  const propertiesLength = properties.length;\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i];\n    ellipsoid.scaleToGeodeticSurface(property, property);\n  }\n  return properties;\n}\nfunction processPositionGraphics(dataSource, entity, styleEntity, heightReference) {\n  let label = entity.label;\n  if (!defined(label)) {\n    label = defined(styleEntity.label) ? styleEntity.label.clone() : createDefaultLabel();\n    entity.label = label;\n  }\n  label.text = entity.name;\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    billboard = defined(styleEntity.billboard) ? styleEntity.billboard.clone() : createDefaultBillboard();\n    entity.billboard = billboard;\n  }\n  if (!defined(billboard.image)) {\n    billboard.image = dataSource._pinBuilder.fromColor(Color.YELLOW, 64);\n\n    // If there were empty <Icon> tags in the KML, then billboard.image was set to false above\n    // However, in this case, the false value would have been converted to a property afterwards\n    // Thus, we check if billboard.image is defined with value of false\n  } else if (!billboard.image.getValue()) {\n    billboard.image = undefined;\n  }\n  let scale = 1.0;\n  if (defined(billboard.scale)) {\n    scale = billboard.scale.getValue();\n    if (scale !== 0) {\n      label.pixelOffset = new Cartesian2(scale * 16 + 1, 0);\n    } else {\n      //Minor tweaks to better match Google Earth.\n      label.pixelOffset = undefined;\n      label.horizontalOrigin = undefined;\n    }\n  }\n  if (defined(heightReference) && dataSource._clampToGround) {\n    billboard.heightReference = heightReference;\n    label.heightReference = heightReference;\n  }\n}\nfunction processPathGraphics(entity, styleEntity) {\n  let path = entity.path;\n  if (!defined(path)) {\n    path = new PathGraphics();\n    path.leadTime = 0;\n    entity.path = path;\n  }\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    path.material = polyline.material;\n    path.width = polyline.width;\n  }\n}\nfunction processPoint(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const coordinatesString = queryStringValue(geometryNode, \"coordinates\", namespaces.kml);\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const ellipsoid = dataSource._ellipsoid;\n  const position = readCoordinate(coordinatesString, ellipsoid);\n  entity.position = position;\n  processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));\n  if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n  return true;\n}\nfunction processLineStringOrLinearRing(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const coordinatesNode = queryFirstNode(geometryNode, \"coordinates\", namespaces.kml);\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const tessellate = queryBooleanValue(geometryNode, \"tessellate\", namespaces.kml);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const zIndex = queryNumericValue(geometryNode, \"drawOrder\", namespaces.gx);\n  const ellipsoid = dataSource._ellipsoid;\n  const coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  let polyline = styleEntity.polyline;\n  if (canExtrude && extrude) {\n    const wall = new WallGraphics();\n    entity.wall = wall;\n    wall.positions = coordinates;\n    const polygon = styleEntity.polygon;\n    if (defined(polygon)) {\n      wall.fill = polygon.fill;\n      wall.material = polygon.material;\n    }\n\n    //Always outline walls so they show up in 2D.\n    wall.outline = true;\n    if (defined(polyline)) {\n      wall.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;\n      wall.outlineWidth = polyline.width;\n    } else if (defined(polygon)) {\n      wall.outlineColor = defined(polygon.material) ? polygon.material.color : Color.WHITE;\n    }\n  } else if (dataSource._clampToGround && !canExtrude && tessellate) {\n    const polylineGraphics = new PolylineGraphics();\n    polylineGraphics.clampToGround = true;\n    entity.polyline = polylineGraphics;\n    polylineGraphics.positions = coordinates;\n    if (defined(polyline)) {\n      polylineGraphics.material = defined(polyline.material) ? polyline.material.color.getValue(Iso8601.MINIMUM_VALUE) : Color.WHITE;\n      polylineGraphics.width = defaultValue(polyline.width, 1.0);\n    } else {\n      polylineGraphics.material = Color.WHITE;\n      polylineGraphics.width = 1.0;\n    }\n    polylineGraphics.zIndex = zIndex;\n  } else {\n    if (defined(zIndex)) {\n      oneTimeWarning(\"kml-gx:drawOrder\", \"KML - gx:drawOrder is not supported in LineStrings when clampToGround is false\");\n    }\n    if (dataSource._clampToGround && !tessellate) {\n      oneTimeWarning(\"kml-line-tesselate\", \"Ignoring clampToGround for KML lines without the tessellate flag.\");\n    }\n    polyline = defined(polyline) ? polyline.clone() : new PolylineGraphics();\n    entity.polyline = polyline;\n    polyline.positions = createPositionPropertyArrayFromAltitudeMode(coordinates, altitudeMode, gxAltitudeMode, ellipsoid);\n    if (!tessellate || canExtrude) {\n      polyline.arcType = ArcType.NONE;\n    }\n  }\n  return true;\n}\nfunction processPolygon(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const outerBoundaryIsNode = queryFirstNode(geometryNode, \"outerBoundaryIs\", namespaces.kml);\n  let linearRingNode = queryFirstNode(outerBoundaryIsNode, \"LinearRing\", namespaces.kml);\n  let coordinatesNode = queryFirstNode(linearRingNode, \"coordinates\", namespaces.kml);\n  const ellipsoid = dataSource._ellipsoid;\n  let coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const polygon = defined(styleEntity.polygon) ? styleEntity.polygon.clone() : createDefaultPolygon();\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    polygon.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;\n    polygon.outlineWidth = polyline.width;\n  }\n  entity.polygon = polygon;\n  if (canExtrude) {\n    polygon.perPositionHeight = true;\n    polygon.extrudedHeight = extrude ? 0 : undefined;\n  } else if (!dataSource._clampToGround) {\n    polygon.height = 0;\n  }\n  if (defined(coordinates)) {\n    const hierarchy = new PolygonHierarchy(coordinates);\n    const innerBoundaryIsNodes = queryChildNodes(geometryNode, \"innerBoundaryIs\", namespaces.kml);\n    for (let j = 0; j < innerBoundaryIsNodes.length; j++) {\n      linearRingNode = queryChildNodes(innerBoundaryIsNodes[j], \"LinearRing\", namespaces.kml);\n      for (let k = 0; k < linearRingNode.length; k++) {\n        coordinatesNode = queryFirstNode(linearRingNode[k], \"coordinates\", namespaces.kml);\n        coordinates = readCoordinates(coordinatesNode, ellipsoid);\n        if (defined(coordinates)) {\n          hierarchy.holes.push(new PolygonHierarchy(coordinates));\n        }\n      }\n    }\n    polygon.hierarchy = hierarchy;\n  }\n  return true;\n}\nfunction processTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const coordNodes = queryChildNodes(geometryNode, \"coord\", namespaces.gx);\n  const angleNodes = queryChildNodes(geometryNode, \"angles\", namespaces.gx);\n  const timeNodes = queryChildNodes(geometryNode, \"when\", namespaces.kml);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const ellipsoid = dataSource._ellipsoid;\n  if (angleNodes.length > 0) {\n    oneTimeWarning(\"kml-gx:angles\", \"KML - gx:angles are not supported in gx:Tracks\");\n  }\n  const length = Math.min(coordNodes.length, timeNodes.length);\n  const coordinates = [];\n  const times = [];\n  for (let i = 0; i < length; i++) {\n    const position = readCoordinate(coordNodes[i].textContent, ellipsoid);\n    coordinates.push(position);\n    times.push(JulianDate.fromIso8601(timeNodes[i].textContent));\n  }\n  const property = new SampledPositionProperty();\n  property.addSamples(times, coordinates);\n  entity.position = property;\n  processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));\n  processPathGraphics(entity, styleEntity);\n  entity.availability = new TimeIntervalCollection();\n  if (timeNodes.length > 0) {\n    entity.availability.addInterval(new TimeInterval({\n      start: times[0],\n      stop: times[times.length - 1]\n    }));\n  }\n  if (canExtrude && extrude) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n  return true;\n}\nfunction addToMultiTrack(times, positions, composite, availability, dropShowProperty, extrude, altitudeMode, gxAltitudeMode, includeEndPoints) {\n  const start = times[0];\n  const stop = times[times.length - 1];\n  const data = new SampledPositionProperty();\n  data.addSamples(times, positions);\n  composite.intervals.addInterval(new TimeInterval({\n    start: start,\n    stop: stop,\n    isStartIncluded: includeEndPoints,\n    isStopIncluded: includeEndPoints,\n    data: createPositionPropertyFromAltitudeMode(data, altitudeMode, gxAltitudeMode)\n  }));\n  availability.addInterval(new TimeInterval({\n    start: start,\n    stop: stop,\n    isStartIncluded: includeEndPoints,\n    isStopIncluded: includeEndPoints\n  }));\n  dropShowProperty.intervals.addInterval(new TimeInterval({\n    start: start,\n    stop: stop,\n    isStartIncluded: includeEndPoints,\n    isStopIncluded: includeEndPoints,\n    data: extrude\n  }));\n}\nfunction processMultiTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  // Multitrack options do not work in GE as detailed in the spec,\n  // rather than altitudeMode being at the MultiTrack level,\n  // GE just defers all settings to the underlying track.\n\n  const interpolate = queryBooleanValue(geometryNode, \"interpolate\", namespaces.gx);\n  const trackNodes = queryChildNodes(geometryNode, \"Track\", namespaces.gx);\n  let times;\n  let lastStop;\n  let lastStopPosition;\n  let needDropLine = false;\n  const dropShowProperty = new TimeIntervalCollectionProperty();\n  const availability = new TimeIntervalCollection();\n  const composite = new CompositePositionProperty();\n  const ellipsoid = dataSource._ellipsoid;\n  for (let i = 0, len = trackNodes.length; i < len; i++) {\n    const trackNode = trackNodes[i];\n    const timeNodes = queryChildNodes(trackNode, \"when\", namespaces.kml);\n    const coordNodes = queryChildNodes(trackNode, \"coord\", namespaces.gx);\n    const altitudeMode = queryStringValue(trackNode, \"altitudeMode\", namespaces.kml);\n    const gxAltitudeMode = queryStringValue(trackNode, \"altitudeMode\", namespaces.gx);\n    const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n    const extrude = queryBooleanValue(trackNode, \"extrude\", namespaces.kml);\n    const length = Math.min(coordNodes.length, timeNodes.length);\n    const positions = [];\n    times = [];\n    for (let x = 0; x < length; x++) {\n      const position = readCoordinate(coordNodes[x].textContent, ellipsoid);\n      positions.push(position);\n      times.push(JulianDate.fromIso8601(timeNodes[x].textContent));\n    }\n    if (interpolate) {\n      //If we are interpolating, then we need to fill in the end of\n      //the last track and the beginning of this one with a sampled\n      //property.  From testing in Google Earth, this property\n      //is never extruded and always absolute.\n      if (defined(lastStop)) {\n        addToMultiTrack([lastStop, times[0]], [lastStopPosition, positions[0]], composite, availability, dropShowProperty, false, \"absolute\", undefined, false);\n      }\n      lastStop = times[length - 1];\n      lastStopPosition = positions[positions.length - 1];\n    }\n    addToMultiTrack(times, positions, composite, availability, dropShowProperty, canExtrude && extrude, altitudeMode, gxAltitudeMode, true);\n    needDropLine = needDropLine || canExtrude && extrude;\n  }\n  entity.availability = availability;\n  entity.position = composite;\n  processPositionGraphics(dataSource, entity, styleEntity);\n  processPathGraphics(entity, styleEntity);\n  if (needDropLine) {\n    createDropLine(entityCollection, entity, styleEntity);\n    entity.polyline.show = dropShowProperty;\n  }\n  return true;\n}\nconst geometryTypes = {\n  Point: processPoint,\n  LineString: processLineStringOrLinearRing,\n  LinearRing: processLineStringOrLinearRing,\n  Polygon: processPolygon,\n  Track: processTrack,\n  MultiTrack: processMultiTrack,\n  MultiGeometry: processMultiGeometry,\n  Model: processUnsupportedGeometry\n};\nfunction processMultiGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity, context) {\n  const childNodes = geometryNode.childNodes;\n  let hasGeometry = false;\n  for (let i = 0, len = childNodes.length; i < len; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      const childEntity = createEntity(childNode, entityCollection, context);\n      childEntity.parent = entity;\n      childEntity.name = entity.name;\n      childEntity.availability = entity.availability;\n      childEntity.description = entity.description;\n      childEntity.kml = entity.kml;\n      if (geometryProcessor(dataSource, entityCollection, childNode, childEntity, styleEntity)) {\n        hasGeometry = true;\n      }\n    }\n  }\n  return hasGeometry;\n}\nfunction processUnsupportedGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  oneTimeWarning(\"kml-unsupportedGeometry\", `KML - Unsupported geometry: ${geometryNode.localName}`);\n  return false;\n}\nfunction processExtendedData(node, entity) {\n  const extendedDataNode = queryFirstNode(node, \"ExtendedData\", namespaces.kml);\n  if (!defined(extendedDataNode)) {\n    return undefined;\n  }\n  if (defined(queryFirstNode(extendedDataNode, \"SchemaData\", namespaces.kml))) {\n    oneTimeWarning(\"kml-schemaData\", \"KML - SchemaData is unsupported\");\n  }\n  if (defined(queryStringAttribute(extendedDataNode, \"xmlns:prefix\"))) {\n    oneTimeWarning(\"kml-extendedData\", \"KML - ExtendedData with xmlns:prefix is unsupported\");\n  }\n  const result = {};\n  const dataNodes = queryChildNodes(extendedDataNode, \"Data\", namespaces.kml);\n  if (defined(dataNodes)) {\n    const length = dataNodes.length;\n    for (let i = 0; i < length; i++) {\n      const dataNode = dataNodes[i];\n      const name = queryStringAttribute(dataNode, \"name\");\n      if (defined(name)) {\n        result[name] = {\n          displayName: queryStringValue(dataNode, \"displayName\", namespaces.kml),\n          value: queryStringValue(dataNode, \"value\", namespaces.kml)\n        };\n      }\n    }\n  }\n  entity.kml.extendedData = result;\n}\nlet scratchDiv;\nif (typeof document !== \"undefined\") {\n  scratchDiv = document.createElement(\"div\");\n}\nfunction processDescription(node, entity, styleEntity, uriResolver, sourceResource) {\n  let i;\n  let key;\n  let keys;\n  const kmlData = entity.kml;\n  const extendedData = kmlData.extendedData;\n  const description = queryStringValue(node, \"description\", namespaces.kml);\n  const balloonStyle = defaultValue(entity.balloonStyle, styleEntity.balloonStyle);\n  let background = Color.WHITE;\n  let foreground = Color.BLACK;\n  let text = description;\n  if (defined(balloonStyle)) {\n    background = defaultValue(balloonStyle.bgColor, Color.WHITE);\n    foreground = defaultValue(balloonStyle.textColor, Color.BLACK);\n    text = defaultValue(balloonStyle.text, description);\n  }\n  let value;\n  if (defined(text)) {\n    text = text.replace(\"$[name]\", defaultValue(entity.name, \"\"));\n    text = text.replace(\"$[description]\", defaultValue(description, \"\"));\n    text = text.replace(\"$[address]\", defaultValue(kmlData.address, \"\"));\n    text = text.replace(\"$[Snippet]\", defaultValue(kmlData.snippet, \"\"));\n    text = text.replace(\"$[id]\", entity.id);\n\n    //While not explicitly defined by the OGC spec, in Google Earth\n    //The appearance of geDirections adds the directions to/from links\n    //We simply replace this string with nothing.\n    text = text.replace(\"$[geDirections]\", \"\");\n    if (defined(extendedData)) {\n      const matches = text.match(/\\$\\[.+?\\]/g);\n      if (matches !== null) {\n        for (i = 0; i < matches.length; i++) {\n          const token = matches[i];\n          let propertyName = token.substr(2, token.length - 3);\n          const isDisplayName = /\\/displayName$/.test(propertyName);\n          propertyName = propertyName.replace(/\\/displayName$/, \"\");\n          value = extendedData[propertyName];\n          if (defined(value)) {\n            value = isDisplayName ? value.displayName : value.value;\n          }\n          if (defined(value)) {\n            text = text.replace(token, defaultValue(value, \"\"));\n          }\n        }\n      }\n    }\n  } else if (defined(extendedData)) {\n    //If no description exists, build a table out of the extended data\n    keys = Object.keys(extendedData);\n    if (keys.length > 0) {\n      text = '<table class=\"cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter\"><tbody>';\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = extendedData[key];\n        text += `<tr><th>${defaultValue(value.displayName, key)}</th><td>${defaultValue(value.value, \"\")}</td></tr>`;\n      }\n      text += \"</tbody></table>\";\n    }\n  }\n  if (!defined(text)) {\n    //No description\n    return;\n  }\n\n  //Turns non-explicit links into clickable links.\n  text = autolinker.link(text);\n\n  //Use a temporary div to manipulate the links\n  //so that they open in a new window.\n  scratchDiv.innerHTML = text;\n  const links = scratchDiv.querySelectorAll(\"a\");\n  for (i = 0; i < links.length; i++) {\n    links[i].setAttribute(\"target\", \"_blank\");\n  }\n\n  //Rewrite any KMZ embedded urls\n  if (defined(uriResolver) && uriResolver.keys.length > 1) {\n    embedDataUris(scratchDiv, \"a\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"link\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"area\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"img\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"iframe\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"audio\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"source\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"track\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"input\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"embed\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"script\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"poster\", uriResolver);\n  }\n\n  //Make relative urls absolute using the sourceResource\n  applyBasePath(scratchDiv, \"a\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"link\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"area\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"img\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"iframe\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"audio\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"source\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"track\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"input\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"embed\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"script\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"poster\", sourceResource);\n  let tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n  tmp += \"overflow:auto;\";\n  tmp += \"word-wrap:break-word;\";\n  tmp += `background-color:${background.toCssColorString()};`;\n  tmp += `color:${foreground.toCssColorString()};`;\n  tmp += '\">';\n  tmp += `${scratchDiv.innerHTML}</div>`;\n  scratchDiv.innerHTML = \"\";\n\n  //Set the final HTML as the description.\n  entity.description = tmp;\n}\nfunction processFeature(dataSource, featureNode, processingData) {\n  const entityCollection = processingData.entityCollection;\n  const parent = processingData.parentEntity;\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n  const entity = createEntity(featureNode, entityCollection, processingData.context);\n  const kmlData = entity.kml;\n  const styleEntity = computeFinalStyle(dataSource, featureNode, processingData.styleCollection, sourceResource, uriResolver);\n  const name = queryStringValue(featureNode, \"name\", namespaces.kml);\n  entity.name = name;\n  entity.parent = parent;\n  let availability = processTimeSpan(featureNode);\n  if (!defined(availability)) {\n    availability = processTimeStamp(featureNode);\n  }\n  entity.availability = availability;\n  mergeAvailabilityWithParent(entity);\n\n  // Per KML spec \"A Feature is visible only if it and all its ancestors are visible.\"\n  function ancestryIsVisible(parentEntity) {\n    if (!parentEntity) {\n      return true;\n    }\n    return parentEntity.show && ancestryIsVisible(parentEntity.parent);\n  }\n  const visibility = queryBooleanValue(featureNode, \"visibility\", namespaces.kml);\n  entity.show = ancestryIsVisible(parent) && defaultValue(visibility, true);\n  //const open = queryBooleanValue(featureNode, 'open', namespaces.kml);\n\n  const authorNode = queryFirstNode(featureNode, \"author\", namespaces.atom);\n  const author = kmlData.author;\n  author.name = queryStringValue(authorNode, \"name\", namespaces.atom);\n  author.uri = queryStringValue(authorNode, \"uri\", namespaces.atom);\n  author.email = queryStringValue(authorNode, \"email\", namespaces.atom);\n  const linkNode = queryFirstNode(featureNode, \"link\", namespaces.atom);\n  const link = kmlData.link;\n  link.href = queryStringAttribute(linkNode, \"href\");\n  link.hreflang = queryStringAttribute(linkNode, \"hreflang\");\n  link.rel = queryStringAttribute(linkNode, \"rel\");\n  link.type = queryStringAttribute(linkNode, \"type\");\n  link.title = queryStringAttribute(linkNode, \"title\");\n  link.length = queryStringAttribute(linkNode, \"length\");\n  kmlData.address = queryStringValue(featureNode, \"address\", namespaces.kml);\n  kmlData.phoneNumber = queryStringValue(featureNode, \"phoneNumber\", namespaces.kml);\n  kmlData.snippet = queryStringValue(featureNode, \"Snippet\", namespaces.kml);\n  processExtendedData(featureNode, entity);\n  processDescription(featureNode, entity, styleEntity, uriResolver, sourceResource);\n  const ellipsoid = dataSource._ellipsoid;\n  processLookAt(featureNode, entity, ellipsoid);\n  processCamera(featureNode, entity, ellipsoid);\n  if (defined(queryFirstNode(featureNode, \"Region\", namespaces.kml))) {\n    oneTimeWarning(\"kml-region\", \"KML - Placemark Regions are unsupported\");\n  }\n  return {\n    entity: entity,\n    styleEntity: styleEntity\n  };\n}\nfunction processDocument(dataSource, node, processingData, deferredLoading) {\n  deferredLoading.addNodes(node.childNodes, processingData);\n  deferredLoading.process();\n}\nfunction processFolder(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const newProcessingData = clone(processingData);\n  newProcessingData.parentEntity = r.entity;\n  processDocument(dataSource, node, newProcessingData, deferredLoading);\n}\nfunction processPlacemark(dataSource, placemark, processingData, deferredLoading) {\n  const r = processFeature(dataSource, placemark, processingData);\n  const entity = r.entity;\n  const styleEntity = r.styleEntity;\n  let hasGeometry = false;\n  const childNodes = placemark.childNodes;\n  for (let i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      // pass the placemark entity id as a context for case of defining multiple child entities together to handle case\n      // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.\n      geometryProcessor(dataSource, processingData.entityCollection, childNode, entity, styleEntity, entity.id);\n      hasGeometry = true;\n    }\n  }\n  if (!hasGeometry) {\n    entity.merge(styleEntity);\n    processPositionGraphics(dataSource, entity, styleEntity);\n  }\n}\nconst playlistNodeProcessors = {\n  FlyTo: processTourFlyTo,\n  Wait: processTourWait,\n  SoundCue: processTourUnsupportedNode,\n  AnimatedUpdate: processTourUnsupportedNode,\n  TourControl: processTourUnsupportedNode\n};\nfunction processTour(dataSource, node, processingData, deferredLoading) {\n  const name = queryStringValue(node, \"name\", namespaces.kml);\n  const id = queryStringAttribute(node, \"id\");\n  const tour = new KmlTour(name, id);\n  const playlistNode = queryFirstNode(node, \"Playlist\", namespaces.gx);\n  if (playlistNode) {\n    const ellipsoid = dataSource._ellipsoid;\n    const childNodes = playlistNode.childNodes;\n    for (let i = 0; i < childNodes.length; i++) {\n      const entryNode = childNodes[i];\n      if (entryNode.localName) {\n        const playlistNodeProcessor = playlistNodeProcessors[entryNode.localName];\n        if (playlistNodeProcessor) {\n          playlistNodeProcessor(tour, entryNode, ellipsoid);\n        } else {\n          console.log(`Unknown KML Tour playlist entry type ${entryNode.localName}`);\n        }\n      }\n    }\n  }\n  dataSource._kmlTours.push(tour);\n}\nfunction processTourUnsupportedNode(tour, entryNode) {\n  oneTimeWarning(`KML Tour unsupported node ${entryNode.localName}`);\n}\nfunction processTourWait(tour, entryNode) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  tour.addPlaylistEntry(new KmlTourWait(duration));\n}\nfunction processTourFlyTo(tour, entryNode, ellipsoid) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  const flyToMode = queryStringValue(entryNode, \"flyToMode\", namespaces.gx);\n  const t = {\n    kml: {}\n  };\n  processLookAt(entryNode, t, ellipsoid);\n  processCamera(entryNode, t, ellipsoid);\n  const view = t.kml.lookAt || t.kml.camera;\n  const flyto = new KmlTourFlyTo(duration, flyToMode, view);\n  tour.addPlaylistEntry(flyto);\n}\nfunction processCamera(featureNode, entity, ellipsoid) {\n  const camera = queryFirstNode(featureNode, \"Camera\", namespaces.kml);\n  if (defined(camera)) {\n    const lon = defaultValue(queryNumericValue(camera, \"longitude\", namespaces.kml), 0.0);\n    const lat = defaultValue(queryNumericValue(camera, \"latitude\", namespaces.kml), 0.0);\n    const altitude = defaultValue(queryNumericValue(camera, \"altitude\", namespaces.kml), 0.0);\n    const heading = defaultValue(queryNumericValue(camera, \"heading\", namespaces.kml), 0.0);\n    const tilt = defaultValue(queryNumericValue(camera, \"tilt\", namespaces.kml), 0.0);\n    const roll = defaultValue(queryNumericValue(camera, \"roll\", namespaces.kml), 0.0);\n    const position = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n    const hpr = HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);\n    entity.kml.camera = new KmlCamera(position, hpr);\n  }\n}\nfunction processLookAt(featureNode, entity, ellipsoid) {\n  const lookAt = queryFirstNode(featureNode, \"LookAt\", namespaces.kml);\n  if (defined(lookAt)) {\n    const lon = defaultValue(queryNumericValue(lookAt, \"longitude\", namespaces.kml), 0.0);\n    const lat = defaultValue(queryNumericValue(lookAt, \"latitude\", namespaces.kml), 0.0);\n    const altitude = defaultValue(queryNumericValue(lookAt, \"altitude\", namespaces.kml), 0.0);\n    let heading = queryNumericValue(lookAt, \"heading\", namespaces.kml);\n    let tilt = queryNumericValue(lookAt, \"tilt\", namespaces.kml);\n    const range = defaultValue(queryNumericValue(lookAt, \"range\", namespaces.kml), 0.0);\n    tilt = CesiumMath.toRadians(defaultValue(tilt, 0.0));\n    heading = CesiumMath.toRadians(defaultValue(heading, 0.0));\n    const hpr = new HeadingPitchRange(heading, tilt - CesiumMath.PI_OVER_TWO, range);\n    const viewPoint = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n    entity.kml.lookAt = new KmlLookAt(viewPoint, hpr);\n  }\n}\nfunction processScreenOverlay(dataSource, screenOverlayNode, processingData, deferredLoading) {\n  const screenOverlay = processingData.screenOverlayContainer;\n  if (!defined(screenOverlay)) {\n    return undefined;\n  }\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n  const iconNode = queryFirstNode(screenOverlayNode, \"Icon\", namespaces.kml);\n  const icon = getIconHref(iconNode, dataSource, sourceResource, uriResolver, false);\n  if (!defined(icon)) {\n    return undefined;\n  }\n  const img = document.createElement(\"img\");\n  dataSource._screenOverlays.push(img);\n  img.src = icon.url;\n  img.onload = function () {\n    const styles = [\"position: absolute\"];\n    const screenXY = queryFirstNode(screenOverlayNode, \"screenXY\", namespaces.kml);\n    const overlayXY = queryFirstNode(screenOverlayNode, \"overlayXY\", namespaces.kml);\n    const size = queryFirstNode(screenOverlayNode, \"size\", namespaces.kml);\n    let x, y;\n    let xUnit, yUnit;\n    let xStyle, yStyle;\n    if (defined(size)) {\n      x = queryNumericAttribute(size, \"x\");\n      y = queryNumericAttribute(size, \"y\");\n      xUnit = queryStringAttribute(size, \"xunits\");\n      yUnit = queryStringAttribute(size, \"yunits\");\n      if (defined(x) && x !== -1 && x !== 0) {\n        if (xUnit === \"fraction\") {\n          xStyle = `width: ${Math.floor(x * 100)}%`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `width: ${x}px`;\n        }\n        styles.push(xStyle);\n      }\n      if (defined(y) && y !== -1 && y !== 0) {\n        if (yUnit === \"fraction\") {\n          yStyle = `height: ${Math.floor(y * 100)}%`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `height: ${y}px`;\n        }\n        styles.push(yStyle);\n      }\n    }\n\n    // set the interim style so the width/height properties get calculated\n    img.style = styles.join(\";\");\n    let xOrigin = 0;\n    let yOrigin = img.height;\n    if (defined(overlayXY)) {\n      x = queryNumericAttribute(overlayXY, \"x\");\n      y = queryNumericAttribute(overlayXY, \"y\");\n      xUnit = queryStringAttribute(overlayXY, \"xunits\");\n      yUnit = queryStringAttribute(overlayXY, \"yunits\");\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xOrigin = x * img.width;\n        } else if (xUnit === \"pixels\") {\n          xOrigin = x;\n        } else if (xUnit === \"insetPixels\") {\n          xOrigin = x;\n        }\n      }\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yOrigin = y * img.height;\n        } else if (yUnit === \"pixels\") {\n          yOrigin = y;\n        } else if (yUnit === \"insetPixels\") {\n          yOrigin = y;\n        }\n      }\n    }\n    if (defined(screenXY)) {\n      x = queryNumericAttribute(screenXY, \"x\");\n      y = queryNumericAttribute(screenXY, \"y\");\n      xUnit = queryStringAttribute(screenXY, \"xunits\");\n      yUnit = queryStringAttribute(screenXY, \"yunits\");\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xStyle = `${\"left: \" + \"calc(\"}${Math.floor(x * 100)}% - ${xOrigin}px)`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `left: ${x - xOrigin}px`;\n        } else if (xUnit === \"insetPixels\") {\n          xStyle = `right: ${x - xOrigin}px`;\n        }\n        styles.push(xStyle);\n      }\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yStyle = `${\"bottom: \" + \"calc(\"}${Math.floor(y * 100)}% - ${yOrigin}px)`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `bottom: ${y - yOrigin}px`;\n        } else if (yUnit === \"insetPixels\") {\n          yStyle = `top: ${y - yOrigin}px`;\n        }\n        styles.push(yStyle);\n      }\n    }\n    img.style = styles.join(\";\");\n  };\n  screenOverlay.appendChild(img);\n}\nfunction processGroundOverlay(dataSource, groundOverlay, processingData, deferredLoading) {\n  const r = processFeature(dataSource, groundOverlay, processingData);\n  const entity = r.entity;\n  let geometry;\n  let isLatLonQuad = false;\n  const ellipsoid = dataSource._ellipsoid;\n  const positions = readCoordinates(queryFirstNode(groundOverlay, \"LatLonQuad\", namespaces.gx), ellipsoid);\n  const zIndex = queryNumericValue(groundOverlay, \"drawOrder\", namespaces.kml);\n  if (defined(positions)) {\n    geometry = createDefaultPolygon();\n    geometry.hierarchy = new PolygonHierarchy(positions);\n    geometry.zIndex = zIndex;\n    entity.polygon = geometry;\n    isLatLonQuad = true;\n  } else {\n    geometry = new RectangleGraphics();\n    geometry.zIndex = zIndex;\n    entity.rectangle = geometry;\n    const latLonBox = queryFirstNode(groundOverlay, \"LatLonBox\", namespaces.kml);\n    if (defined(latLonBox)) {\n      let west = queryNumericValue(latLonBox, \"west\", namespaces.kml);\n      let south = queryNumericValue(latLonBox, \"south\", namespaces.kml);\n      let east = queryNumericValue(latLonBox, \"east\", namespaces.kml);\n      let north = queryNumericValue(latLonBox, \"north\", namespaces.kml);\n      if (defined(west)) {\n        west = CesiumMath.negativePiToPi(CesiumMath.toRadians(west));\n      }\n      if (defined(south)) {\n        south = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(south));\n      }\n      if (defined(east)) {\n        east = CesiumMath.negativePiToPi(CesiumMath.toRadians(east));\n      }\n      if (defined(north)) {\n        north = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(north));\n      }\n      geometry.coordinates = new Rectangle(west, south, east, north);\n      const rotation = queryNumericValue(latLonBox, \"rotation\", namespaces.kml);\n      if (defined(rotation)) {\n        const rotationRadians = CesiumMath.toRadians(rotation);\n        geometry.rotation = rotationRadians;\n        geometry.stRotation = rotationRadians;\n      }\n    }\n  }\n  const iconNode = queryFirstNode(groundOverlay, \"Icon\", namespaces.kml);\n  const href = getIconHref(iconNode, dataSource, processingData.sourceResource, processingData.uriResolver, true);\n  if (defined(href)) {\n    if (isLatLonQuad) {\n      oneTimeWarning(\"kml-gx:LatLonQuad\", \"KML - gx:LatLonQuad Icon does not support texture projection.\");\n    }\n    const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n    const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n    const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n    const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n    if (defined(x) || defined(y) || defined(w) || defined(h)) {\n      oneTimeWarning(\"kml-groundOverlay-xywh\", \"KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays\");\n    }\n    geometry.material = href;\n    geometry.material.color = queryColorValue(groundOverlay, \"color\", namespaces.kml);\n    geometry.material.transparent = true;\n  } else {\n    geometry.material = queryColorValue(groundOverlay, \"color\", namespaces.kml);\n  }\n  let altitudeMode = queryStringValue(groundOverlay, \"altitudeMode\", namespaces.kml);\n  if (defined(altitudeMode)) {\n    if (altitudeMode === \"absolute\") {\n      //Use height above ellipsoid until we support MSL.\n      geometry.height = queryNumericValue(groundOverlay, \"altitude\", namespaces.kml);\n      geometry.zIndex = undefined;\n    } else if (altitudeMode !== \"clampToGround\") {\n      oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${altitudeMode}`);\n    }\n    // else just use the default of 0 until we support 'clampToGround'\n  } else {\n    altitudeMode = queryStringValue(groundOverlay, \"altitudeMode\", namespaces.gx);\n    if (altitudeMode === \"relativeToSeaFloor\") {\n      oneTimeWarning(\"kml-altitudeMode-relativeToSeaFloor\", \"KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute.\");\n      geometry.height = queryNumericValue(groundOverlay, \"altitude\", namespaces.kml);\n      geometry.zIndex = undefined;\n    } else if (altitudeMode === \"clampToSeaFloor\") {\n      oneTimeWarning(\"kml-altitudeMode-clampToSeaFloor\", \"KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.\");\n    } else if (defined(altitudeMode)) {\n      oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${altitudeMode}`);\n    }\n  }\n}\nfunction processUnsupportedFeature(dataSource, node, processingData, deferredLoading) {\n  dataSource._unsupportedNode.raiseEvent(dataSource, processingData.parentEntity, node, processingData.entityCollection, processingData.styleCollection, processingData.sourceResource, processingData.uriResolver);\n  oneTimeWarning(`kml-unsupportedFeature-${node.nodeName}`, `KML - Unsupported feature: ${node.nodeName}`);\n}\nconst RefreshMode = {\n  INTERVAL: 0,\n  EXPIRE: 1,\n  STOP: 2\n};\nfunction cleanupString(s) {\n  if (!defined(s) || s.length === 0) {\n    return \"\";\n  }\n  const sFirst = s[0];\n  if (sFirst === \"&\" || sFirst === \"?\") {\n    s = s.substring(1);\n  }\n  return s;\n}\nconst zeroRectangle = new Rectangle();\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian2 = new Cartesian2();\nconst scratchCartesian3 = new Cartesian3();\nfunction processNetworkLinkQueryString(resource, camera, canvas, viewBoundScale, bbox, ellipsoid) {\n  function fixLatitude(value) {\n    if (value < -CesiumMath.PI_OVER_TWO) {\n      return -CesiumMath.PI_OVER_TWO;\n    } else if (value > CesiumMath.PI_OVER_TWO) {\n      return CesiumMath.PI_OVER_TWO;\n    }\n    return value;\n  }\n  function fixLongitude(value) {\n    if (value > CesiumMath.PI) {\n      return value - CesiumMath.TWO_PI;\n    } else if (value < -CesiumMath.PI) {\n      return value + CesiumMath.TWO_PI;\n    }\n    return value;\n  }\n  let queryString = objectToQuery(resource.queryParameters);\n\n  // objectToQuery escapes [ and ], so fix that\n  queryString = queryString.replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n  if (defined(camera) && camera._mode !== SceneMode.MORPHING) {\n    let centerCartesian;\n    let centerCartographic;\n    bbox = defaultValue(bbox, zeroRectangle);\n    if (defined(canvas)) {\n      scratchCartesian2.x = canvas.clientWidth * 0.5;\n      scratchCartesian2.y = canvas.clientHeight * 0.5;\n      centerCartesian = camera.pickEllipsoid(scratchCartesian2, ellipsoid, scratchCartesian3);\n    }\n    if (defined(centerCartesian)) {\n      centerCartographic = ellipsoid.cartesianToCartographic(centerCartesian, scratchCartographic);\n    } else {\n      centerCartographic = Rectangle.center(bbox, scratchCartographic);\n      centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);\n    }\n    if (defined(viewBoundScale) && !CesiumMath.equalsEpsilon(viewBoundScale, 1.0, CesiumMath.EPSILON9)) {\n      const newHalfWidth = bbox.width * viewBoundScale * 0.5;\n      const newHalfHeight = bbox.height * viewBoundScale * 0.5;\n      bbox = new Rectangle(fixLongitude(centerCartographic.longitude - newHalfWidth), fixLatitude(centerCartographic.latitude - newHalfHeight), fixLongitude(centerCartographic.longitude + newHalfWidth), fixLatitude(centerCartographic.latitude + newHalfHeight));\n    }\n    queryString = queryString.replace(\"[bboxWest]\", CesiumMath.toDegrees(bbox.west).toString());\n    queryString = queryString.replace(\"[bboxSouth]\", CesiumMath.toDegrees(bbox.south).toString());\n    queryString = queryString.replace(\"[bboxEast]\", CesiumMath.toDegrees(bbox.east).toString());\n    queryString = queryString.replace(\"[bboxNorth]\", CesiumMath.toDegrees(bbox.north).toString());\n    const lon = CesiumMath.toDegrees(centerCartographic.longitude).toString();\n    const lat = CesiumMath.toDegrees(centerCartographic.latitude).toString();\n    queryString = queryString.replace(\"[lookatLon]\", lon);\n    queryString = queryString.replace(\"[lookatLat]\", lat);\n    queryString = queryString.replace(\"[lookatTilt]\", CesiumMath.toDegrees(camera.pitch).toString());\n    queryString = queryString.replace(\"[lookatHeading]\", CesiumMath.toDegrees(camera.heading).toString());\n    queryString = queryString.replace(\"[lookatRange]\", Cartesian3.distance(camera.positionWC, centerCartesian));\n    queryString = queryString.replace(\"[lookatTerrainLon]\", lon);\n    queryString = queryString.replace(\"[lookatTerrainLat]\", lat);\n    queryString = queryString.replace(\"[lookatTerrainAlt]\", centerCartographic.height.toString());\n    ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);\n    queryString = queryString.replace(\"[cameraLon]\", CesiumMath.toDegrees(scratchCartographic.longitude).toString());\n    queryString = queryString.replace(\"[cameraLat]\", CesiumMath.toDegrees(scratchCartographic.latitude).toString());\n    queryString = queryString.replace(\"[cameraAlt]\", CesiumMath.toDegrees(scratchCartographic.height).toString());\n    const frustum = camera.frustum;\n    const aspectRatio = frustum.aspectRatio;\n    let horizFov = \"\";\n    let vertFov = \"\";\n    if (defined(aspectRatio)) {\n      const fov = CesiumMath.toDegrees(frustum.fov);\n      if (aspectRatio > 1.0) {\n        horizFov = fov;\n        vertFov = fov / aspectRatio;\n      } else {\n        vertFov = fov;\n        horizFov = fov * aspectRatio;\n      }\n    }\n    queryString = queryString.replace(\"[horizFov]\", horizFov.toString());\n    queryString = queryString.replace(\"[vertFov]\", vertFov.toString());\n  } else {\n    queryString = queryString.replace(\"[bboxWest]\", \"-180\");\n    queryString = queryString.replace(\"[bboxSouth]\", \"-90\");\n    queryString = queryString.replace(\"[bboxEast]\", \"180\");\n    queryString = queryString.replace(\"[bboxNorth]\", \"90\");\n    queryString = queryString.replace(\"[lookatLon]\", \"\");\n    queryString = queryString.replace(\"[lookatLat]\", \"\");\n    queryString = queryString.replace(\"[lookatRange]\", \"\");\n    queryString = queryString.replace(\"[lookatTilt]\", \"\");\n    queryString = queryString.replace(\"[lookatHeading]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLon]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLat]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainAlt]\", \"\");\n    queryString = queryString.replace(\"[cameraLon]\", \"\");\n    queryString = queryString.replace(\"[cameraLat]\", \"\");\n    queryString = queryString.replace(\"[cameraAlt]\", \"\");\n    queryString = queryString.replace(\"[horizFov]\", \"\");\n    queryString = queryString.replace(\"[vertFov]\", \"\");\n  }\n  if (defined(canvas)) {\n    queryString = queryString.replace(\"[horizPixels]\", canvas.clientWidth);\n    queryString = queryString.replace(\"[vertPixels]\", canvas.clientHeight);\n  } else {\n    queryString = queryString.replace(\"[horizPixels]\", \"\");\n    queryString = queryString.replace(\"[vertPixels]\", \"\");\n  }\n  queryString = queryString.replace(\"[terrainEnabled]\", \"1\");\n  queryString = queryString.replace(\"[clientVersion]\", \"1\");\n  queryString = queryString.replace(\"[kmlVersion]\", \"2.2\");\n  queryString = queryString.replace(\"[clientName]\", \"Cesium\");\n  queryString = queryString.replace(\"[language]\", \"English\");\n  resource.setQueryParameters(queryToObject(queryString));\n}\nfunction processNetworkLink(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const networkEntity = r.entity;\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n  let link = queryFirstNode(node, \"Link\", namespaces.kml);\n  if (!defined(link)) {\n    link = queryFirstNode(node, \"Url\", namespaces.kml);\n  }\n  if (defined(link)) {\n    let href = queryStringValue(link, \"href\", namespaces.kml);\n    let viewRefreshMode;\n    let viewBoundScale;\n    if (defined(href)) {\n      let newSourceUri = href;\n      href = resolveHref(href, sourceResource, processingData.uriResolver);\n\n      // We need to pass in the original path if resolveHref returns a data uri because the network link\n      //  references a document in a KMZ archive\n      if (/^data:/.test(href.getUrlComponent())) {\n        // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it\n        if (!/\\.kmz/i.test(sourceResource.getUrlComponent())) {\n          newSourceUri = sourceResource.getDerivedResource({\n            url: newSourceUri\n          });\n        }\n      } else {\n        newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri\n        viewRefreshMode = queryStringValue(link, \"viewRefreshMode\", namespaces.kml);\n        if (viewRefreshMode === \"onRegion\") {\n          oneTimeWarning(\"kml-refrehMode-onRegion\", \"KML - Unsupported viewRefreshMode: onRegion\");\n          return;\n        }\n        viewBoundScale = defaultValue(queryStringValue(link, \"viewBoundScale\", namespaces.kml), 1.0);\n        const defaultViewFormat = viewRefreshMode === \"onStop\" ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\" : \"\";\n        const viewFormat = defaultValue(queryStringValue(link, \"viewFormat\", namespaces.kml), defaultViewFormat);\n        const httpQuery = queryStringValue(link, \"httpQuery\", namespaces.kml);\n        if (defined(viewFormat)) {\n          href.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n        }\n        if (defined(httpQuery)) {\n          href.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n        }\n        const ellipsoid = dataSource._ellipsoid;\n        processNetworkLinkQueryString(href, dataSource.camera, dataSource.canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);\n      }\n      const options = {\n        sourceUri: newSourceUri,\n        uriResolver: uriResolver,\n        context: networkEntity.id,\n        screenOverlayContainer: processingData.screenOverlayContainer\n      };\n      const networkLinkCollection = new EntityCollection();\n      const promise = load(dataSource, networkLinkCollection, href, options).then(function (rootElement) {\n        const entities = dataSource._entityCollection;\n        const newEntities = networkLinkCollection.values;\n        entities.suspendEvents();\n        for (let i = 0; i < newEntities.length; i++) {\n          const newEntity = newEntities[i];\n          if (!defined(newEntity.parent)) {\n            newEntity.parent = networkEntity;\n            mergeAvailabilityWithParent(newEntity);\n          }\n          entities.add(newEntity);\n        }\n        entities.resumeEvents();\n\n        // Add network links to a list if we need they will need to be updated\n        const refreshMode = queryStringValue(link, \"refreshMode\", namespaces.kml);\n        let refreshInterval = defaultValue(queryNumericValue(link, \"refreshInterval\", namespaces.kml), 0);\n        if (refreshMode === \"onInterval\" && refreshInterval > 0 || refreshMode === \"onExpire\" || viewRefreshMode === \"onStop\") {\n          const networkLinkControl = queryFirstNode(rootElement, \"NetworkLinkControl\", namespaces.kml);\n          const hasNetworkLinkControl = defined(networkLinkControl);\n          const now = JulianDate.now();\n          const networkLinkInfo = {\n            id: createGuid(),\n            href: href,\n            cookie: {},\n            lastUpdated: now,\n            updating: false,\n            entity: networkEntity,\n            viewBoundScale: viewBoundScale,\n            needsUpdate: false,\n            cameraUpdateTime: now\n          };\n          let minRefreshPeriod = 0;\n          if (hasNetworkLinkControl) {\n            networkLinkInfo.cookie = queryToObject(defaultValue(queryStringValue(networkLinkControl, \"cookie\", namespaces.kml), \"\"));\n            minRefreshPeriod = defaultValue(queryNumericValue(networkLinkControl, \"minRefreshPeriod\", namespaces.kml), 0);\n          }\n          if (refreshMode === \"onInterval\") {\n            if (hasNetworkLinkControl) {\n              refreshInterval = Math.max(minRefreshPeriod, refreshInterval);\n            }\n            networkLinkInfo.refreshMode = RefreshMode.INTERVAL;\n            networkLinkInfo.time = refreshInterval;\n          } else if (refreshMode === \"onExpire\") {\n            let expires;\n            if (hasNetworkLinkControl) {\n              expires = queryStringValue(networkLinkControl, \"expires\", namespaces.kml);\n            }\n            if (defined(expires)) {\n              try {\n                const date = JulianDate.fromIso8601(expires);\n                const diff = JulianDate.secondsDifference(date, now);\n                if (diff > 0 && diff < minRefreshPeriod) {\n                  JulianDate.addSeconds(now, minRefreshPeriod, date);\n                }\n                networkLinkInfo.refreshMode = RefreshMode.EXPIRE;\n                networkLinkInfo.time = date;\n              } catch (e) {\n                oneTimeWarning(\"kml-refreshMode-onInterval-onExpire\", \"KML - NetworkLinkControl expires is not a valid date\");\n              }\n            } else {\n              oneTimeWarning(\"kml-refreshMode-onExpire\", \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\");\n            }\n          } else if (defined(dataSource.camera)) {\n            // Only allow onStop refreshes if we have a camera\n            networkLinkInfo.refreshMode = RefreshMode.STOP;\n            networkLinkInfo.time = defaultValue(queryNumericValue(link, \"viewRefreshTime\", namespaces.kml), 0);\n          } else {\n            oneTimeWarning(\"kml-refrehMode-onStop-noCamera\", \"A NetworkLink with viewRefreshMode=onStop requires the `camera` property to be defined.\");\n          }\n          if (defined(networkLinkInfo.refreshMode)) {\n            dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);\n          }\n        }\n      }).catch(function (error) {\n        oneTimeWarning(`An error occured during loading ${href.url}`);\n        dataSource._error.raiseEvent(dataSource, error);\n      });\n      deferredLoading.addPromise(promise);\n    }\n  }\n}\nfunction processFeatureNode(dataSource, node, processingData, deferredLoading) {\n  const featureProcessor = featureTypes[node.localName];\n  if (defined(featureProcessor)) {\n    return featureProcessor(dataSource, node, processingData, deferredLoading);\n  }\n  return processUnsupportedFeature(dataSource, node, processingData, deferredLoading);\n}\nfunction loadKml(dataSource, entityCollection, kml, sourceResource, uriResolver, screenOverlayContainer, context) {\n  entityCollection.removeAll();\n  const documentElement = kml.documentElement;\n  const document = documentElement.localName === \"Document\" ? documentElement : queryFirstNode(documentElement, \"Document\", namespaces.kml);\n  let name = queryStringValue(document, \"name\", namespaces.kml);\n  if (!defined(name)) {\n    name = getFilenameFromUri(sourceResource.getUrlComponent());\n  }\n\n  // Only set the name from the root document\n  if (!defined(dataSource._name)) {\n    dataSource._name = name;\n  }\n  const deferredLoading = new KmlDataSource._DeferredLoading(dataSource);\n  const styleCollection = new EntityCollection(dataSource);\n  return Promise.all(processStyles(dataSource, kml, styleCollection, sourceResource, false, uriResolver)).then(function () {\n    let element = kml.documentElement;\n    if (element.localName === \"kml\") {\n      const childNodes = element.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const tmp = childNodes[i];\n        if (defined(featureTypes[tmp.localName])) {\n          element = tmp;\n          break;\n        }\n      }\n    }\n    const processingData = {\n      parentEntity: undefined,\n      entityCollection: entityCollection,\n      styleCollection: styleCollection,\n      sourceResource: sourceResource,\n      uriResolver: uriResolver,\n      context: context,\n      screenOverlayContainer: screenOverlayContainer\n    };\n    entityCollection.suspendEvents();\n    processFeatureNode(dataSource, element, processingData, deferredLoading);\n    entityCollection.resumeEvents();\n    return deferredLoading.wait().then(function () {\n      return kml.documentElement;\n    });\n  });\n}\nfunction loadKmz(dataSource, entityCollection, blob, sourceResource, screenOverlayContainer) {\n  const zWorkerUrl = buildModuleUrl(\"ThirdParty/Workers/z-worker-pako.js\");\n  zip.configure({\n    workerScripts: {\n      deflate: [zWorkerUrl, \"./pako_deflate.min.js\"],\n      inflate: [zWorkerUrl, \"./pako_inflate.min.js\"]\n    }\n  });\n  const reader = new zip.ZipReader(new zip.BlobReader(blob));\n  return Promise.resolve(reader.getEntries()).then(function (entries) {\n    const promises = [];\n    const uriResolver = {};\n    let docEntry;\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      if (!entry.directory) {\n        if (/\\.kml$/i.test(entry.filename)) {\n          // We use the first KML document we come across\n          //  https://developers.google.com/kml/documentation/kmzarchives\n          // Unless we come across a .kml file at the root of the archive because GE does this\n          if (!defined(docEntry) || !/\\//i.test(entry.filename)) {\n            if (defined(docEntry)) {\n              // We found one at the root so load the initial kml as a data uri\n              promises.push(loadDataUriFromZip(docEntry, uriResolver));\n            }\n            docEntry = entry;\n          } else {\n            // Wasn't the first kml and wasn't at the root\n            promises.push(loadDataUriFromZip(entry, uriResolver));\n          }\n        } else {\n          promises.push(loadDataUriFromZip(entry, uriResolver));\n        }\n      }\n    }\n\n    // Now load the root KML document\n    if (defined(docEntry)) {\n      promises.push(loadXmlFromZip(docEntry, uriResolver));\n    }\n    return Promise.all(promises).then(function () {\n      reader.close();\n      if (!defined(uriResolver.kml)) {\n        throw new RuntimeError(\"KMZ file does not contain a KML document.\");\n      }\n      uriResolver.keys = Object.keys(uriResolver);\n      return loadKml(dataSource, entityCollection, uriResolver.kml, sourceResource, uriResolver, screenOverlayContainer);\n    });\n  });\n}\nfunction load(dataSource, entityCollection, data, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let sourceUri = options.sourceUri;\n  const uriResolver = options.uriResolver;\n  const context = options.context;\n  let screenOverlayContainer = options.screenOverlayContainer;\n  let promise = data;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchBlob();\n    sourceUri = defaultValue(sourceUri, data.clone());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  } else {\n    sourceUri = defaultValue(sourceUri, Resource.DEFAULT.clone());\n  }\n  sourceUri = Resource.createIfNeeded(sourceUri);\n  if (defined(screenOverlayContainer)) {\n    screenOverlayContainer = getElement(screenOverlayContainer);\n  }\n  return Promise.resolve(promise).then(function (dataToLoad) {\n    if (dataToLoad instanceof Blob) {\n      return isZipFile(dataToLoad).then(function (isZip) {\n        if (isZip) {\n          return loadKmz(dataSource, entityCollection, dataToLoad, sourceUri, screenOverlayContainer);\n        }\n        return readBlobAsText(dataToLoad).then(function (text) {\n          //There's no official way to validate if a parse was successful.\n          //The following check detects the error on various browsers.\n\n          //Insert missing namespaces\n          text = insertNamespaces(text);\n\n          //Remove Duplicate Namespaces\n          text = removeDuplicateNamespaces(text);\n\n          //IE raises an exception\n          let kml;\n          let error;\n          try {\n            kml = parser.parseFromString(text, \"application/xml\");\n          } catch (e) {\n            error = e.toString();\n          }\n\n          //The parse succeeds on Chrome and Firefox, but the error\n          //handling is different in each.\n          if (defined(error) || kml.body || kml.documentElement.tagName === \"parsererror\") {\n            //Firefox has error information as the firstChild nodeValue.\n            let msg = defined(error) ? error : kml.documentElement.firstChild.nodeValue;\n\n            //Chrome has it in the body text.\n            if (!msg) {\n              msg = kml.body.innerText;\n            }\n\n            //Return the error\n            throw new RuntimeError(msg);\n          }\n          return loadKml(dataSource, entityCollection, kml, sourceUri, uriResolver, screenOverlayContainer, context);\n        });\n      });\n    }\n    return loadKml(dataSource, entityCollection, dataToLoad, sourceUri, uriResolver, screenOverlayContainer, context);\n  }).catch(function (error) {\n    dataSource._error.raiseEvent(dataSource, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n}\n\n// NOTE: LoadOptions properties are repeated in ConstructorOptions because some\n// tooling does not support \"base types\" for @typedef.  Remove if/when\n// https://github.com/microsoft/TypeScript/issues/20077 and/or\n// https://github.com/jsdoc/jsdoc/issues/1199 actually get resolved\n/**\n * @typedef {object} KmlDataSource.LoadOptions\n *\n * Initialization options for the `load` method.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n */\n\n/**\n * @typedef {object} KmlDataSource.ConstructorOptions\n *\n * Options for constructing a new KmlDataSource, or calling the static `load` method.\n *\n * @property {Camera} [camera] The camera that is used for viewRefreshModes and sending camera properties to network links.\n * @property {HTMLCanvasElement} [canvas] The canvas that is used for sending viewer properties to network links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n\n*/\n\n/**\n * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).\n * <p>\n * KML support in Cesium is incomplete, but a large amount of the standard,\n * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue\n * {@link https://github.com/CesiumGS/cesium/issues/873|#873} for a\n * detailed list of what is and isn't supported. Cesium will also write information to the\n * console when it encounters most unsupported features.\n * </p>\n * <p>\n * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>\n * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}\n * under the <code>kml</code> property.\n * </p>\n *\n * @alias KmlDataSource\n * @constructor\n *\n * @param {KmlDataSource.ConstructorOptions} [options] Object describing initialization options\n *\n * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}\n * @see {@link https://developers.google.com/kml/|Google KML Documentation}\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=KML.html|Cesium Sandcastle KML Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n *      {\n *           camera: viewer.scene.camera,\n *           canvas: viewer.scene.canvas\n *      })\n * );\n */\nfunction KmlDataSource(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const camera = options.camera;\n  const canvas = options.canvas;\n  this._changed = new Event();\n  this._error = new Event();\n  this._loading = new Event();\n  this._refresh = new Event();\n  this._unsupportedNode = new Event();\n  this._clock = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._name = undefined;\n  this._isLoading = false;\n  this._pinBuilder = new PinBuilder();\n  this._networkLinks = new AssociativeArray();\n  this._entityCluster = new EntityCluster();\n\n  /**\n   * The current size of this Canvas will be used to populate the Link parameters\n   * for client height and width.\n   *\n   * @type {HTMLCanvasElement | undefined}\n   */\n  this.canvas = canvas;\n\n  /**\n   * The position and orientation of this {@link Camera} will be used to\n   * populate various camera parameters when making network requests.\n   * Camera movement will determine when to trigger NetworkLink refresh if\n   * <code>viewRefreshMode</code> is <code>onStop</code>.\n   *\n   * @type {Camera | undefined}\n   */\n  this.camera = camera;\n  this._lastCameraView = {\n    position: defined(camera) ? Cartesian3.clone(camera.positionWC) : undefined,\n    direction: defined(camera) ? Cartesian3.clone(camera.directionWC) : undefined,\n    up: defined(camera) ? Cartesian3.clone(camera.upWC) : undefined,\n    bbox: defined(camera) ? camera.computeViewRectangle() : Rectangle.clone(Rectangle.MAX_VALUE)\n  };\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Create a list of Credit's from the resource that the user can't remove\n  this._resourceCredits = [];\n  this._kmlTours = [];\n  this._screenOverlays = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided KML data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.ConstructorOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.\n */\nKmlDataSource.load = function (data, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const dataSource = new KmlDataSource(options);\n  return dataSource.load(data, options);\n};\nObject.defineProperties(KmlDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * This will be automatically be set to the KML document name on load.\n   * @memberof KmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    }\n  },\n  /**\n   * Gets the clock settings defined by the loaded KML. This represents the total\n   * availability interval for all time-dynamic data. If the KML does not contain\n   * time-dynamic data, this value is undefined.\n   * @memberof KmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    }\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    }\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    }\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source refreshes a network link.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  refreshEvent: {\n    get: function () {\n      return this._refresh;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source finds an unsupported node type.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  unsupportedNodeEvent: {\n    get: function () {\n      return this._unsupportedNode;\n    }\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    }\n  },\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    }\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof KmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n  /**\n   * Gets the KML Tours that are used to guide the camera to specified destinations on given time intervals.\n   * @memberof KmlDataSource.prototype\n   * @type {KmlTour[]}\n   */\n  kmlTours: {\n    get: function () {\n      return this._kmlTours;\n    }\n  }\n});\n\n/**\n * Asynchronously loads the provided KML data, replacing any existing data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.\n */\nKmlDataSource.prototype.load = function (data, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  DataSource.setLoading(this, true);\n  const oldName = this._name;\n  this._name = undefined;\n  this._clampToGround = defaultValue(options.clampToGround, false);\n  const that = this;\n  return load(this, this._entityCollection, data, options).then(function () {\n    let clock;\n    const availability = that._entityCollection.computeAvailability();\n    let start = availability.start;\n    let stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      let date;\n\n      //If start is min time just start at midnight this morning, local time\n      if (isMinStart) {\n        date = new Date();\n        date.setHours(0, 0, 0, 0);\n        start = JulianDate.fromDate(date);\n      }\n\n      //If stop is max value just stop at midnight tonight, local time\n      if (isMaxStop) {\n        date = new Date();\n        date.setHours(24, 0, 0, 0);\n        stop = JulianDate.fromDate(date);\n      }\n      clock = new DataSourceClock();\n      clock.startTime = start;\n      clock.stopTime = stop;\n      clock.currentTime = JulianDate.clone(start);\n      clock.clockRange = ClockRange.LOOP_STOP;\n      clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n      clock.multiplier = Math.round(Math.min(Math.max(JulianDate.secondsDifference(stop, start) / 60, 1), 3.15569e7));\n    }\n    let changed = false;\n    if (clock !== that._clock) {\n      that._clock = clock;\n      changed = true;\n    }\n    if (oldName !== that._name) {\n      changed = true;\n    }\n    if (changed) {\n      that._changed.raiseEvent(that);\n    }\n    DataSource.setLoading(that, false);\n    return that;\n  }).catch(function (error) {\n    DataSource.setLoading(that, false);\n    that._error.raiseEvent(that, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n};\n\n/**\n * Cleans up any non-entity elements created by the data source. Currently this only affects ScreenOverlay elements.\n */\nKmlDataSource.prototype.destroy = function () {\n  while (this._screenOverlays.length > 0) {\n    const elem = this._screenOverlays.pop();\n    elem.remove();\n  }\n};\nfunction mergeAvailabilityWithParent(child) {\n  const parent = child.parent;\n  if (defined(parent)) {\n    const parentAvailability = parent.availability;\n    if (defined(parentAvailability)) {\n      const childAvailability = child.availability;\n      if (defined(childAvailability)) {\n        childAvailability.intersect(parentAvailability);\n      } else {\n        child.availability = parentAvailability;\n      }\n    }\n  }\n}\nfunction getNetworkLinkUpdateCallback(dataSource, networkLink, newEntityCollection, networkLinks, processedHref) {\n  return function (rootElement) {\n    if (!networkLinks.contains(networkLink.id)) {\n      // Got into the odd case where a parent network link was updated while a child\n      //  network link update was in flight, so just throw it away.\n      return;\n    }\n    let remove = false;\n    const networkLinkControl = queryFirstNode(rootElement, \"NetworkLinkControl\", namespaces.kml);\n    const hasNetworkLinkControl = defined(networkLinkControl);\n    let minRefreshPeriod = 0;\n    if (hasNetworkLinkControl) {\n      if (defined(queryFirstNode(networkLinkControl, \"Update\", namespaces.kml))) {\n        oneTimeWarning(\"kml-networkLinkControl-update\", \"KML - NetworkLinkControl updates aren't supported.\");\n        networkLink.updating = false;\n        networkLinks.remove(networkLink.id);\n        return;\n      }\n      networkLink.cookie = queryToObject(defaultValue(queryStringValue(networkLinkControl, \"cookie\", namespaces.kml), \"\"));\n      minRefreshPeriod = defaultValue(queryNumericValue(networkLinkControl, \"minRefreshPeriod\", namespaces.kml), 0);\n    }\n    const now = JulianDate.now();\n    const refreshMode = networkLink.refreshMode;\n    if (refreshMode === RefreshMode.INTERVAL) {\n      if (defined(networkLinkControl)) {\n        networkLink.time = Math.max(minRefreshPeriod, networkLink.time);\n      }\n    } else if (refreshMode === RefreshMode.EXPIRE) {\n      let expires;\n      if (defined(networkLinkControl)) {\n        expires = queryStringValue(networkLinkControl, \"expires\", namespaces.kml);\n      }\n      if (defined(expires)) {\n        try {\n          const date = JulianDate.fromIso8601(expires);\n          const diff = JulianDate.secondsDifference(date, now);\n          if (diff > 0 && diff < minRefreshPeriod) {\n            JulianDate.addSeconds(now, minRefreshPeriod, date);\n          }\n          networkLink.time = date;\n        } catch (e) {\n          oneTimeWarning(\"kml-networkLinkControl-expires\", \"KML - NetworkLinkControl expires is not a valid date\");\n          remove = true;\n        }\n      } else {\n        oneTimeWarning(\"kml-refreshMode-onExpire\", \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\");\n        remove = true;\n      }\n    }\n    const networkLinkEntity = networkLink.entity;\n    const entityCollection = dataSource._entityCollection;\n    const newEntities = newEntityCollection.values;\n    function removeChildren(entity) {\n      entityCollection.remove(entity);\n      const children = entity._children;\n      const count = children.length;\n      for (let i = 0; i < count; ++i) {\n        removeChildren(children[i]);\n      }\n    }\n\n    // Remove old entities\n    entityCollection.suspendEvents();\n    const entitiesCopy = entityCollection.values.slice();\n    let i;\n    for (i = 0; i < entitiesCopy.length; ++i) {\n      const entityToRemove = entitiesCopy[i];\n      if (entityToRemove.parent === networkLinkEntity) {\n        entityToRemove.parent = undefined;\n        removeChildren(entityToRemove);\n      }\n    }\n    entityCollection.resumeEvents();\n\n    // Add new entities\n    entityCollection.suspendEvents();\n    for (i = 0; i < newEntities.length; i++) {\n      const newEntity = newEntities[i];\n      if (!defined(newEntity.parent)) {\n        newEntity.parent = networkLinkEntity;\n        mergeAvailabilityWithParent(newEntity);\n      }\n      entityCollection.add(newEntity);\n    }\n    entityCollection.resumeEvents();\n\n    // No refresh information remove it, otherwise update lastUpdate time\n    if (remove) {\n      networkLinks.remove(networkLink.id);\n    } else {\n      networkLink.lastUpdated = now;\n    }\n    const availability = entityCollection.computeAvailability();\n    const start = availability.start;\n    const stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      const clock = dataSource._clock;\n      if (clock.startTime !== start || clock.stopTime !== stop) {\n        clock.startTime = start;\n        clock.stopTime = stop;\n        dataSource._changed.raiseEvent(dataSource);\n      }\n    }\n    networkLink.updating = false;\n    networkLink.needsUpdate = false;\n    dataSource._refresh.raiseEvent(dataSource, processedHref.getUrlComponent(true));\n  };\n}\nconst entitiesToIgnore = new AssociativeArray();\n\n/**\n * Updates any NetworkLink that require updating.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nKmlDataSource.prototype.update = function (time) {\n  const networkLinks = this._networkLinks;\n  if (networkLinks.length === 0) {\n    return true;\n  }\n  const now = JulianDate.now();\n  const that = this;\n  entitiesToIgnore.removeAll();\n  function recurseIgnoreEntities(entity) {\n    const children = entity._children;\n    const count = children.length;\n    for (let i = 0; i < count; ++i) {\n      const child = children[i];\n      entitiesToIgnore.set(child.id, child);\n      recurseIgnoreEntities(child);\n    }\n  }\n  let cameraViewUpdate = false;\n  const lastCameraView = this._lastCameraView;\n  const camera = this.camera;\n  if (defined(camera) && !(camera.positionWC.equalsEpsilon(lastCameraView.position, CesiumMath.EPSILON7) && camera.directionWC.equalsEpsilon(lastCameraView.direction, CesiumMath.EPSILON7) && camera.upWC.equalsEpsilon(lastCameraView.up, CesiumMath.EPSILON7))) {\n    // Camera has changed so update the last view\n    lastCameraView.position = Cartesian3.clone(camera.positionWC);\n    lastCameraView.direction = Cartesian3.clone(camera.directionWC);\n    lastCameraView.up = Cartesian3.clone(camera.upWC);\n    lastCameraView.bbox = camera.computeViewRectangle();\n    cameraViewUpdate = true;\n  }\n  const newNetworkLinks = new AssociativeArray();\n  let changed = false;\n  networkLinks.values.forEach(function (networkLink) {\n    const entity = networkLink.entity;\n    if (entitiesToIgnore.contains(entity.id)) {\n      return;\n    }\n    if (!networkLink.updating) {\n      let doUpdate = false;\n      if (networkLink.refreshMode === RefreshMode.INTERVAL) {\n        if (JulianDate.secondsDifference(now, networkLink.lastUpdated) > networkLink.time) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.EXPIRE) {\n        if (JulianDate.greaterThan(now, networkLink.time)) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.STOP) {\n        if (cameraViewUpdate) {\n          networkLink.needsUpdate = true;\n          networkLink.cameraUpdateTime = now;\n        }\n        if (networkLink.needsUpdate && JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >= networkLink.time) {\n          doUpdate = true;\n        }\n      }\n      if (doUpdate) {\n        recurseIgnoreEntities(entity);\n        networkLink.updating = true;\n        const newEntityCollection = new EntityCollection();\n        const href = networkLink.href.clone();\n        href.setQueryParameters(networkLink.cookie);\n        const ellipsoid = defaultValue(that._ellipsoid, Ellipsoid.default);\n        processNetworkLinkQueryString(href, that.camera, that.canvas, networkLink.viewBoundScale, lastCameraView.bbox, ellipsoid);\n        load(that, newEntityCollection, href, {\n          context: entity.id\n        }).then(getNetworkLinkUpdateCallback(that, networkLink, newEntityCollection, newNetworkLinks, href)).catch(function (error) {\n          const msg = `NetworkLink ${networkLink.href} refresh failed: ${error}`;\n          console.log(msg);\n          that._error.raiseEvent(that, msg);\n        });\n        changed = true;\n      }\n    }\n    newNetworkLinks.set(networkLink.id, networkLink);\n  });\n  if (changed) {\n    this._networkLinks = newNetworkLinks;\n    this._changed.raiseEvent(this);\n  }\n  return true;\n};\n\n/**\n * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.\n * @alias KmlFeatureData\n * @constructor\n */\nfunction KmlFeatureData() {\n  /**\n   * @typedef KmlFeatureData.Author\n   * @type {object}\n   * @property {string} name Gets the name.\n   * @property {string} uri Gets the URI.\n   * @property {number} age Gets the email.\n   */\n\n  /**\n   * Gets the atom syndication format author field.\n   * @type {KmlFeatureData.Author}\n   */\n  this.author = {\n    name: undefined,\n    uri: undefined,\n    email: undefined\n  };\n\n  /**\n   * @typedef KmlFeatureData.Link\n   * @type {object}\n   * @property {string} href Gets the href.\n   * @property {string} hreflang Gets the language of the linked resource.\n   * @property {string} rel Gets the link relation.\n   * @property {string} type Gets the link type.\n   * @property {string} title Gets the link title.\n   * @property {string} length Gets the link length.\n   */\n\n  /**\n   * Gets the link.\n   * @type {KmlFeatureData.Link}\n   */\n  this.link = {\n    href: undefined,\n    hreflang: undefined,\n    rel: undefined,\n    type: undefined,\n    title: undefined,\n    length: undefined\n  };\n\n  /**\n   * Gets the unstructured address field.\n   * @type {string}\n   */\n  this.address = undefined;\n  /**\n   * Gets the phone number.\n   * @type {string}\n   */\n  this.phoneNumber = undefined;\n  /**\n   * Gets the snippet.\n   * @type {string}\n   */\n  this.snippet = undefined;\n  /**\n   * Gets the extended data, parsed into a JSON object.\n   * Currently only the <code>Data</code> property is supported.\n   * <code>SchemaData</code> and custom data are ignored.\n   * @type {string}\n   */\n  this.extendedData = undefined;\n}\n\n// For testing\nKmlDataSource._DeferredLoading = DeferredLoading;\nKmlDataSource._getTimestamp = getTimestamp;\nexport default KmlDataSource;","map":{"version":3,"names":["ArcType","AssociativeArray","BoundingRectangle","buildModuleUrl","Cartesian2","Cartesian3","Cartographic","ClockRange","ClockStep","clone","Color","createGuid","Credit","defaultValue","defer","defined","DeveloperError","Ellipsoid","Event","getExtensionFromUri","getFilenameFromUri","getTimestamp","HeadingPitchRange","HeadingPitchRoll","Iso8601","JulianDate","CesiumMath","NearFarScalar","objectToQuery","oneTimeWarning","PinBuilder","PolygonHierarchy","queryToObject","Rectangle","Resource","RuntimeError","TimeInterval","TimeIntervalCollection","HeightReference","HorizontalOrigin","LabelStyle","SceneMode","Autolinker","Uri","zip","getElement","BillboardGraphics","CompositePositionProperty","DataSource","DataSourceClock","Entity","EntityCluster","EntityCollection","KmlCamera","KmlLookAt","KmlTour","KmlTourFlyTo","KmlTourWait","LabelGraphics","PathGraphics","PolygonGraphics","PolylineGraphics","PositionPropertyArray","RectangleGraphics","ReferenceProperty","SampledPositionProperty","ScaledPositionProperty","TimeIntervalCollectionProperty","WallGraphics","MimeTypes","avi","bmp","bz2","chm","css","csv","doc","dvi","eps","flv","gif","gz","htm","html","ico","jnlp","jpeg","jpg","m3u","m4v","mathml","mid","midi","mov","mp3","mp4","mp4v","mpeg","mpg","odp","ods","odt","ogg","pdf","png","pps","ppt","ps","qt","rdf","rss","rtf","svg","swf","text","tif","tiff","txt","wav","wma","wmv","xml","detectFromFilename","filename","ext","toLowerCase","parser","DOMParser","autolinker","stripPrefix","email","replaceFn","match","urlMatchType","BILLBOARD_SIZE","BILLBOARD_NEAR_DISTANCE","BILLBOARD_NEAR_RATIO","BILLBOARD_FAR_DISTANCE","BILLBOARD_FAR_RATIO","kmlNamespaces","undefined","gxNamespaces","atomNamespaces","namespaces","kml","gx","atom","kmlgx","concat","featureTypes","Document","processDocument","Folder","processFolder","Placemark","processPlacemark","NetworkLink","processNetworkLink","GroundOverlay","processGroundOverlay","PhotoOverlay","processUnsupportedFeature","ScreenOverlay","processScreenOverlay","Tour","processTour","DeferredLoading","dataSource","_dataSource","_deferred","_stack","_promises","_timeoutSet","_used","_started","_timeThreshold","Object","defineProperties","prototype","get","addNodes","nodes","processingData","push","index","addPromise","promise","wait","deferred","resolve","Promise","all","process","isFirstCall","length","KmlDataSource","_getTimestamp","_process","_giveUpTime","that","setTimeout","_nextNode","stack","top","_pop","pop","child","featureProcessor","localName","indexOf","namespaceURI","isZipFile","blob","magicBlob","slice","Math","min","size","reader","FileReader","addEventListener","DataView","result","getUint32","reject","error","readAsArrayBuffer","readBlobAsText","readAsText","insertNamespaces","namespaceMap","xsi","firstPart","lastPart","reg","declaration","key","hasOwnProperty","RegExp","test","substr","removeDuplicateNamespaces","endDeclaration","namespace","startIndex","endIndex","loadXmlFromZip","entry","uriResolver","getData","TextWriter","then","parseFromString","loadDataUriFromZip","mimeType","Data64URIWriter","dataUri","embedDataUris","div","elementType","attributeName","keys","baseUri","elements","querySelectorAll","i","element","value","getAttribute","relativeUri","uri","absoluteTo","toString","setAttribute","applyBasePath","sourceResource","resource","resolveHref","url","createEntity","node","entityCollection","context","id","queryStringAttribute","entity","getById","add","addProperty","KmlFeatureData","isExtrudable","altitudeMode","gxAltitudeMode","readCoordinate","ellipsoid","fromDegrees","digits","longitude","parseFloat","latitude","height","isNaN","readCoordinates","tuples","textContent","Array","resultIndex","queryNumericAttribute","queryFirstNode","tagName","childNodes","q","queryNodes","getElementsByTagNameNS","queryChildNodes","queryNumericValue","resultNode","queryStringValue","trim","queryBooleanValue","href","replace","getUrlComponent","getDerivedResource","colorOptions","maximumRed","red","maximumGreen","green","maximumBlue","blue","parseColorString","isRandom","substring","alpha","parseInt","fromRandom","queryColorValue","processTimeStamp","featureNode","whenString","when","fromIso8601","addInterval","start","stop","MAXIMUM_VALUE","processTimeSpan","beginNode","beginDate","endNode","endDate","lessThan","tmp","MINIMUM_VALUE","createDefaultBillboard","billboard","width","scaleByDistance","pixelOffsetScaleByDistance","createDefaultPolygon","polygon","outline","outlineColor","WHITE","createDefaultLabel","label","translucencyByDistance","pixelOffset","horizontalOrigin","LEFT","font","style","FILL_AND_OUTLINE","getIconHref","iconNode","canRefresh","palette","charAt","x","y","iconNum","hrefResource","refreshMode","viewRefreshMode","viewBoundScale","defaultViewFormat","viewFormat","httpQuery","setQueryParameters","cleanupString","_ellipsoid","processNetworkLinkQueryString","camera","canvas","_lastCameraView","bbox","processBillboardIcon","targetEntity","scale","heading","color","icon","w","h","hotSpotNode","hotSpotX","hotSpotY","hotSpotXUnit","hotSpotYUnit","image","imageSubRegion","rotation","toRadians","alignedAxis","UNIT_Z","xOffset","yOffset","applyStyle","styleNode","len","item","fillColor","name","polyline","material","fill","bgColor","textColor","BLACK","balloonStyle","listItemType","computeFinalStyle","placeMark","styleCollection","styleEntity","styleIndex","inlineStyleNode","pairs","p","pair","styleUrl","merge","externalStyle","tokens","split","processExternalStyles","fetchXML","styleKml","processStyles","isExternal","styleNodes","styleNodesLength","styleMaps","styleMapsLength","styleMap","getOrCreateEntity","base","promises","styleUrlNodes","getElementsByTagName","styleUrlNodesLength","styleReference","createDropLine","entityPosition","surfacePosition","position","positions","heightReferenceFromAltitudeMode","CLAMP_TO_GROUND","RELATIVE_TO_GROUND","NONE","createPositionPropertyFromAltitudeMode","property","createPositionPropertyArrayFromAltitudeMode","properties","propertiesLength","scaleToGeodeticSurface","processPositionGraphics","heightReference","_pinBuilder","fromColor","YELLOW","getValue","_clampToGround","processPathGraphics","path","leadTime","processPoint","geometryNode","coordinatesString","extrude","processLineStringOrLinearRing","coordinatesNode","tessellate","canExtrude","zIndex","coordinates","wall","outlineWidth","polylineGraphics","clampToGround","arcType","processPolygon","outerBoundaryIsNode","linearRingNode","perPositionHeight","extrudedHeight","hierarchy","innerBoundaryIsNodes","j","k","holes","processTrack","coordNodes","angleNodes","timeNodes","times","addSamples","availability","addToMultiTrack","composite","dropShowProperty","includeEndPoints","data","intervals","isStartIncluded","isStopIncluded","processMultiTrack","interpolate","trackNodes","lastStop","lastStopPosition","needDropLine","trackNode","show","geometryTypes","Point","LineString","LinearRing","Polygon","Track","MultiTrack","MultiGeometry","processMultiGeometry","Model","processUnsupportedGeometry","hasGeometry","childNode","geometryProcessor","childEntity","parent","description","processExtendedData","extendedDataNode","dataNodes","dataNode","displayName","extendedData","scratchDiv","document","createElement","processDescription","kmlData","background","foreground","address","snippet","matches","token","propertyName","isDisplayName","link","innerHTML","links","toCssColorString","processFeature","parentEntity","mergeAvailabilityWithParent","ancestryIsVisible","visibility","authorNode","author","linkNode","hreflang","rel","type","title","phoneNumber","processLookAt","processCamera","deferredLoading","r","newProcessingData","placemark","playlistNodeProcessors","FlyTo","processTourFlyTo","Wait","processTourWait","SoundCue","processTourUnsupportedNode","AnimatedUpdate","TourControl","tour","playlistNode","entryNode","playlistNodeProcessor","console","log","_kmlTours","duration","addPlaylistEntry","flyToMode","t","view","lookAt","flyto","lon","lat","altitude","tilt","roll","hpr","range","PI_OVER_TWO","viewPoint","screenOverlayNode","screenOverlay","screenOverlayContainer","img","_screenOverlays","src","onload","styles","screenXY","overlayXY","xUnit","yUnit","xStyle","yStyle","floor","join","xOrigin","yOrigin","appendChild","groundOverlay","geometry","isLatLonQuad","rectangle","latLonBox","west","south","east","north","negativePiToPi","clampToLatitudeRange","rotationRadians","stRotation","transparent","_unsupportedNode","raiseEvent","nodeName","RefreshMode","INTERVAL","EXPIRE","STOP","s","sFirst","zeroRectangle","scratchCartographic","scratchCartesian2","scratchCartesian3","fixLatitude","fixLongitude","PI","TWO_PI","queryString","queryParameters","_mode","MORPHING","centerCartesian","centerCartographic","clientWidth","clientHeight","pickEllipsoid","cartesianToCartographic","center","cartographicToCartesian","equalsEpsilon","EPSILON9","newHalfWidth","newHalfHeight","toDegrees","pitch","distance","positionWC","frustum","aspectRatio","horizFov","vertFov","fov","networkEntity","newSourceUri","options","sourceUri","networkLinkCollection","load","rootElement","entities","_entityCollection","newEntities","values","suspendEvents","newEntity","resumeEvents","refreshInterval","networkLinkControl","hasNetworkLinkControl","now","networkLinkInfo","cookie","lastUpdated","updating","needsUpdate","cameraUpdateTime","minRefreshPeriod","max","time","expires","date","diff","secondsDifference","addSeconds","e","_networkLinks","set","catch","_error","processFeatureNode","loadKml","removeAll","documentElement","_name","_DeferredLoading","loadKmz","zWorkerUrl","configure","workerScripts","deflate","inflate","ZipReader","BlobReader","getEntries","entries","docEntry","directory","close","EMPTY_OBJECT","createIfNeeded","fetchBlob","resourceCredits","_resourceCredits","credits","DEFAULT","dataToLoad","Blob","isZip","body","msg","firstChild","nodeValue","innerText","_changed","_loading","_refresh","_clock","_isLoading","_entityCluster","direction","directionWC","up","upWC","computeViewRectangle","MAX_VALUE","default","credit","_credit","clock","isLoading","changedEvent","errorEvent","loadingEvent","refreshEvent","unsupportedNodeEvent","clustering","kmlTours","setLoading","oldName","computeAvailability","isMinStart","equals","isMaxStop","Date","setHours","fromDate","startTime","stopTime","currentTime","clockRange","LOOP_STOP","clockStep","SYSTEM_CLOCK_MULTIPLIER","multiplier","round","changed","destroy","elem","remove","parentAvailability","childAvailability","intersect","getNetworkLinkUpdateCallback","networkLink","newEntityCollection","networkLinks","processedHref","contains","networkLinkEntity","removeChildren","children","_children","count","entitiesCopy","entityToRemove","entitiesToIgnore","update","recurseIgnoreEntities","cameraViewUpdate","lastCameraView","EPSILON7","newNetworkLinks","forEach","doUpdate","greaterThan"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/KmlDataSource.js"],"sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport getExtensionFromUri from \"../Core/getExtensionFromUri.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport objectToQuery from \"../Core/objectToQuery.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport queryToObject from \"../Core/queryToObject.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Autolinker from \"autolinker\";\nimport Uri from \"urijs\";\nimport * as zip from \"@zip.js/zip.js/lib/zip-no-worker.js\";\nimport getElement from \"./getElement.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport KmlCamera from \"./KmlCamera.js\";\nimport KmlLookAt from \"./KmlLookAt.js\";\nimport KmlTour from \"./KmlTour.js\";\nimport KmlTourFlyTo from \"./KmlTourFlyTo.js\";\nimport KmlTourWait from \"./KmlTourWait.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\n\n//This is by no means an exhaustive list of MIME types.\n//The purpose of this list is to be able to accurately identify content embedded\n//in KMZ files. Eventually, we can make this configurable by the end user so they can add\n//there own content types if they have KMZ files that require it.\nconst MimeTypes = {\n  avi: \"video/x-msvideo\",\n  bmp: \"image/bmp\",\n  bz2: \"application/x-bzip2\",\n  chm: \"application/vnd.ms-htmlhelp\",\n  css: \"text/css\",\n  csv: \"text/csv\",\n  doc: \"application/msword\",\n  dvi: \"application/x-dvi\",\n  eps: \"application/postscript\",\n  flv: \"video/x-flv\",\n  gif: \"image/gif\",\n  gz: \"application/x-gzip\",\n  htm: \"text/html\",\n  html: \"text/html\",\n  ico: \"image/vnd.microsoft.icon\",\n  jnlp: \"application/x-java-jnlp-file\",\n  jpeg: \"image/jpeg\",\n  jpg: \"image/jpeg\",\n  m3u: \"audio/x-mpegurl\",\n  m4v: \"video/mp4\",\n  mathml: \"application/mathml+xml\",\n  mid: \"audio/midi\",\n  midi: \"audio/midi\",\n  mov: \"video/quicktime\",\n  mp3: \"audio/mpeg\",\n  mp4: \"video/mp4\",\n  mp4v: \"video/mp4\",\n  mpeg: \"video/mpeg\",\n  mpg: \"video/mpeg\",\n  odp: \"application/vnd.oasis.opendocument.presentation\",\n  ods: \"application/vnd.oasis.opendocument.spreadsheet\",\n  odt: \"application/vnd.oasis.opendocument.text\",\n  ogg: \"application/ogg\",\n  pdf: \"application/pdf\",\n  png: \"image/png\",\n  pps: \"application/vnd.ms-powerpoint\",\n  ppt: \"application/vnd.ms-powerpoint\",\n  ps: \"application/postscript\",\n  qt: \"video/quicktime\",\n  rdf: \"application/rdf+xml\",\n  rss: \"application/rss+xml\",\n  rtf: \"application/rtf\",\n  svg: \"image/svg+xml\",\n  swf: \"application/x-shockwave-flash\",\n  text: \"text/plain\",\n  tif: \"image/tiff\",\n  tiff: \"image/tiff\",\n  txt: \"text/plain\",\n  wav: \"audio/x-wav\",\n  wma: \"audio/x-ms-wma\",\n  wmv: \"video/x-ms-wmv\",\n  xml: \"application/xml\",\n  zip: \"application/zip\",\n\n  detectFromFilename: function (filename) {\n    let ext = filename.toLowerCase();\n    ext = getExtensionFromUri(ext);\n    return MimeTypes[ext];\n  },\n};\n\nlet parser;\nif (typeof DOMParser !== \"undefined\") {\n  parser = new DOMParser();\n}\n\nconst autolinker = new Autolinker({\n  stripPrefix: false,\n  email: false,\n  replaceFn: function (match) {\n    //Prevent matching of non-explicit urls.\n    //i.e. foo.id won't match but http://foo.id will\n    return match.urlMatchType === \"scheme\" || match.urlMatchType === \"www\";\n  },\n});\n\nconst BILLBOARD_SIZE = 32;\n\nconst BILLBOARD_NEAR_DISTANCE = 2414016;\nconst BILLBOARD_NEAR_RATIO = 1.0;\nconst BILLBOARD_FAR_DISTANCE = 1.6093e7;\nconst BILLBOARD_FAR_RATIO = 0.1;\n\nconst kmlNamespaces = [\n  null,\n  undefined,\n  \"http://www.opengis.net/kml/2.2\",\n  \"http://earth.google.com/kml/2.2\",\n  \"http://earth.google.com/kml/2.1\",\n  \"http://earth.google.com/kml/2.0\",\n];\nconst gxNamespaces = [\"http://www.google.com/kml/ext/2.2\"];\nconst atomNamespaces = [\"http://www.w3.org/2005/Atom\"];\nconst namespaces = {\n  kml: kmlNamespaces,\n  gx: gxNamespaces,\n  atom: atomNamespaces,\n  kmlgx: kmlNamespaces.concat(gxNamespaces),\n};\n\n// Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types\nconst featureTypes = {\n  Document: processDocument,\n  Folder: processFolder,\n  Placemark: processPlacemark,\n  NetworkLink: processNetworkLink,\n  GroundOverlay: processGroundOverlay,\n  PhotoOverlay: processUnsupportedFeature,\n  ScreenOverlay: processScreenOverlay,\n  Tour: processTour,\n};\n\nfunction DeferredLoading(dataSource) {\n  this._dataSource = dataSource;\n  this._deferred = defer();\n  this._stack = [];\n  this._promises = [];\n  this._timeoutSet = false;\n  this._used = false;\n\n  this._started = 0;\n  this._timeThreshold = 1000; // Initial load is 1 second\n}\n\nObject.defineProperties(DeferredLoading.prototype, {\n  dataSource: {\n    get: function () {\n      return this._dataSource;\n    },\n  },\n});\n\nDeferredLoading.prototype.addNodes = function (nodes, processingData) {\n  this._stack.push({\n    nodes: nodes,\n    index: 0,\n    processingData: processingData,\n  });\n  this._used = true;\n};\n\nDeferredLoading.prototype.addPromise = function (promise) {\n  this._promises.push(promise);\n};\n\nDeferredLoading.prototype.wait = function () {\n  // Case where we had a non-document/folder as the root\n  const deferred = this._deferred;\n  if (!this._used) {\n    deferred.resolve();\n  }\n\n  return Promise.all([deferred.promise, Promise.all(this._promises)]);\n};\n\nDeferredLoading.prototype.process = function () {\n  const isFirstCall = this._stack.length === 1;\n  if (isFirstCall) {\n    this._started = KmlDataSource._getTimestamp();\n  }\n\n  return this._process(isFirstCall);\n};\n\nDeferredLoading.prototype._giveUpTime = function () {\n  if (this._timeoutSet) {\n    // Timeout was already set so just return\n    return;\n  }\n\n  this._timeoutSet = true;\n  this._timeThreshold = 50; // After the first load lower threshold to 0.5 seconds\n  const that = this;\n  setTimeout(function () {\n    that._timeoutSet = false;\n    that._started = KmlDataSource._getTimestamp();\n    that._process(true);\n  }, 0);\n};\n\nDeferredLoading.prototype._nextNode = function () {\n  const stack = this._stack;\n  const top = stack[stack.length - 1];\n  const index = top.index;\n  const nodes = top.nodes;\n  if (index === nodes.length) {\n    return;\n  }\n  ++top.index;\n\n  return nodes[index];\n};\n\nDeferredLoading.prototype._pop = function () {\n  const stack = this._stack;\n  stack.pop();\n\n  // Return false if we are done\n  if (stack.length === 0) {\n    this._deferred.resolve();\n    return false;\n  }\n\n  return true;\n};\n\nDeferredLoading.prototype._process = function (isFirstCall) {\n  const dataSource = this.dataSource;\n  const processingData = this._stack[this._stack.length - 1].processingData;\n\n  let child = this._nextNode();\n  while (defined(child)) {\n    const featureProcessor = featureTypes[child.localName];\n    if (\n      defined(featureProcessor) &&\n      (namespaces.kml.indexOf(child.namespaceURI) !== -1 ||\n        namespaces.gx.indexOf(child.namespaceURI) !== -1)\n    ) {\n      featureProcessor(dataSource, child, processingData, this);\n\n      // Give up time and continue loading later\n      if (\n        this._timeoutSet ||\n        KmlDataSource._getTimestamp() > this._started + this._timeThreshold\n      ) {\n        this._giveUpTime();\n        return;\n      }\n    }\n\n    child = this._nextNode();\n  }\n\n  // If we are a recursive call from a subfolder, just return so the parent folder can continue processing\n  // If we aren't then make another call to processNodes because there is stuff still left in the queue\n  if (this._pop() && isFirstCall) {\n    this._process(true);\n  }\n};\n\nfunction isZipFile(blob) {\n  const magicBlob = blob.slice(0, Math.min(4, blob.size));\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(\n      new DataView(reader.result).getUint32(0, false) === 0x504b0304,\n    );\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsArrayBuffer(magicBlob);\n  return deferred.promise;\n}\n\nfunction readBlobAsText(blob) {\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(reader.result);\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsText(blob);\n  return deferred.promise;\n}\n\nfunction insertNamespaces(text) {\n  const namespaceMap = {\n    xsi: \"http://www.w3.org/2001/XMLSchema-instance\",\n  };\n  let firstPart, lastPart, reg, declaration;\n\n  for (const key in namespaceMap) {\n    if (namespaceMap.hasOwnProperty(key)) {\n      reg = RegExp(`[< ]${key}:`);\n      declaration = `xmlns:${key}=`;\n      if (reg.test(text) && text.indexOf(declaration) === -1) {\n        if (!defined(firstPart)) {\n          firstPart = text.substr(0, text.indexOf(\"<kml\") + 4);\n          lastPart = text.substr(firstPart.length);\n        }\n        firstPart += ` ${declaration}\"${namespaceMap[key]}\"`;\n      }\n    }\n  }\n\n  if (defined(firstPart)) {\n    text = firstPart + lastPart;\n  }\n\n  return text;\n}\n\nfunction removeDuplicateNamespaces(text) {\n  let index = text.indexOf(\"xmlns:\");\n  const endDeclaration = text.indexOf(\">\", index);\n  let namespace, startIndex, endIndex;\n\n  while (index !== -1 && index < endDeclaration) {\n    namespace = text.slice(index, text.indexOf('\"', index));\n    startIndex = index;\n    index = text.indexOf(namespace, index + 1);\n    if (index !== -1) {\n      endIndex = text.indexOf('\"', text.indexOf('\"', index) + 1);\n      text = text.slice(0, index - 1) + text.slice(endIndex + 1, text.length);\n      index = text.indexOf(\"xmlns:\", startIndex - 1);\n    } else {\n      index = text.indexOf(\"xmlns:\", startIndex + 1);\n    }\n  }\n\n  return text;\n}\n\nfunction loadXmlFromZip(entry, uriResolver) {\n  return Promise.resolve(entry.getData(new zip.TextWriter())).then(\n    function (text) {\n      text = insertNamespaces(text);\n      text = removeDuplicateNamespaces(text);\n      uriResolver.kml = parser.parseFromString(text, \"application/xml\");\n    },\n  );\n}\n\nfunction loadDataUriFromZip(entry, uriResolver) {\n  const mimeType = defaultValue(\n    MimeTypes.detectFromFilename(entry.filename),\n    \"application/octet-stream\",\n  );\n  return Promise.resolve(entry.getData(new zip.Data64URIWriter(mimeType))).then(\n    function (dataUri) {\n      uriResolver[entry.filename] = dataUri;\n    },\n  );\n}\n\nfunction embedDataUris(div, elementType, attributeName, uriResolver) {\n  const keys = uriResolver.keys;\n  const baseUri = new Uri(\".\");\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    if (defined(value)) {\n      const relativeUri = new Uri(value);\n      const uri = relativeUri.absoluteTo(baseUri).toString();\n      const index = keys.indexOf(uri);\n      if (index !== -1) {\n        const key = keys[index];\n        element.setAttribute(attributeName, uriResolver[key]);\n        if (elementType === \"a\" && element.getAttribute(\"download\") === null) {\n          element.setAttribute(\"download\", key);\n        }\n      }\n    }\n  }\n}\n\nfunction applyBasePath(div, elementType, attributeName, sourceResource) {\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    const resource = resolveHref(value, sourceResource);\n    if (defined(resource)) {\n      element.setAttribute(attributeName, resource.url);\n    }\n  }\n}\n\n// an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse\n// correctly, as they do in Google Earth.\nfunction createEntity(node, entityCollection, context) {\n  let id = queryStringAttribute(node, \"id\");\n  id = defined(id) && id.length !== 0 ? id : createGuid();\n  if (defined(context)) {\n    id = context + id;\n  }\n\n  // If we have a duplicate ID just generate one.\n  // This isn't valid KML but Google Earth handles this case.\n  let entity = entityCollection.getById(id);\n  if (defined(entity)) {\n    id = createGuid();\n    if (defined(context)) {\n      id = context + id;\n    }\n  }\n\n  entity = entityCollection.add(new Entity({ id: id }));\n  if (!defined(entity.kml)) {\n    entity.addProperty(\"kml\");\n    entity.kml = new KmlFeatureData();\n  }\n  return entity;\n}\n\nfunction isExtrudable(altitudeMode, gxAltitudeMode) {\n  return (\n    altitudeMode === \"absolute\" ||\n    altitudeMode === \"relativeToGround\" ||\n    gxAltitudeMode === \"relativeToSeaFloor\"\n  );\n}\n\nfunction readCoordinate(value, ellipsoid) {\n  //Google Earth treats empty or missing coordinates as 0.\n  if (!defined(value)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n\n  const digits = value.match(/[^\\s,\\n]+/g);\n  if (!defined(digits)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n\n  let longitude = parseFloat(digits[0]);\n  let latitude = parseFloat(digits[1]);\n  let height = parseFloat(digits[2]);\n\n  longitude = isNaN(longitude) ? 0.0 : longitude;\n  latitude = isNaN(latitude) ? 0.0 : latitude;\n  height = isNaN(height) ? 0.0 : height;\n\n  return Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);\n}\n\nfunction readCoordinates(element, ellipsoid) {\n  if (!defined(element)) {\n    return undefined;\n  }\n\n  const tuples = element.textContent.match(/[^\\s\\n]+/g);\n  if (!defined(tuples)) {\n    return undefined;\n  }\n\n  const length = tuples.length;\n  const result = new Array(length);\n  let resultIndex = 0;\n  for (let i = 0; i < length; i++) {\n    result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);\n  }\n  return result;\n}\n\nfunction queryNumericAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  const value = node.getAttribute(attributeName);\n  if (value !== null) {\n    const result = parseFloat(value);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\n\nfunction queryStringAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  return value !== null ? value : undefined;\n}\n\nfunction queryFirstNode(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      return child;\n    }\n  }\n  return undefined;\n}\n\nfunction queryNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const result = [];\n  const childNodes = node.getElementsByTagNameNS(\"*\", tagName);\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\nfunction queryChildNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return [];\n  }\n  const result = [];\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\nfunction queryNumericValue(node, tagName, namespace) {\n  const resultNode = queryFirstNode(node, tagName, namespace);\n  if (defined(resultNode)) {\n    const result = parseFloat(resultNode.textContent);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\n\nfunction queryStringValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    return result.textContent.trim();\n  }\n  return undefined;\n}\n\nfunction queryBooleanValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    const value = result.textContent.trim();\n    return value === \"1\" || /^true$/i.test(value);\n  }\n  return undefined;\n}\n\nfunction resolveHref(href, sourceResource, uriResolver) {\n  if (!defined(href)) {\n    return undefined;\n  }\n\n  let resource;\n  if (defined(uriResolver)) {\n    // To resolve issues with KML sources defined in Windows style paths.\n    href = href.replace(/\\\\/g, \"/\");\n    let blob = uriResolver[href];\n    if (defined(blob)) {\n      resource = new Resource({\n        url: blob,\n      });\n    } else {\n      // Needed for multiple levels of KML files in a KMZ\n      const baseUri = new Uri(sourceResource.getUrlComponent());\n      const uri = new Uri(href);\n      blob = uriResolver[uri.absoluteTo(baseUri)];\n      if (defined(blob)) {\n        resource = new Resource({\n          url: blob,\n        });\n      }\n    }\n  }\n\n  if (!defined(resource)) {\n    resource = sourceResource.getDerivedResource({\n      url: href,\n    });\n  }\n\n  return resource;\n}\n\nconst colorOptions = {\n  maximumRed: undefined,\n  red: undefined,\n  maximumGreen: undefined,\n  green: undefined,\n  maximumBlue: undefined,\n  blue: undefined,\n};\n\nfunction parseColorString(value, isRandom) {\n  if (!defined(value) || /^\\s*$/gm.test(value)) {\n    return undefined;\n  }\n\n  if (value[0] === \"#\") {\n    value = value.substring(1);\n  }\n\n  const alpha = parseInt(value.substring(0, 2), 16) / 255.0;\n  const blue = parseInt(value.substring(2, 4), 16) / 255.0;\n  const green = parseInt(value.substring(4, 6), 16) / 255.0;\n  const red = parseInt(value.substring(6, 8), 16) / 255.0;\n\n  if (!isRandom) {\n    return new Color(red, green, blue, alpha);\n  }\n\n  if (red > 0) {\n    colorOptions.maximumRed = red;\n    colorOptions.red = undefined;\n  } else {\n    colorOptions.maximumRed = undefined;\n    colorOptions.red = 0;\n  }\n  if (green > 0) {\n    colorOptions.maximumGreen = green;\n    colorOptions.green = undefined;\n  } else {\n    colorOptions.maximumGreen = undefined;\n    colorOptions.green = 0;\n  }\n  if (blue > 0) {\n    colorOptions.maximumBlue = blue;\n    colorOptions.blue = undefined;\n  } else {\n    colorOptions.maximumBlue = undefined;\n    colorOptions.blue = 0;\n  }\n  colorOptions.alpha = alpha;\n  return Color.fromRandom(colorOptions);\n}\n\nfunction queryColorValue(node, tagName, namespace) {\n  const value = queryStringValue(node, tagName, namespace);\n  if (!defined(value)) {\n    return undefined;\n  }\n  return parseColorString(\n    value,\n    queryStringValue(node, \"colorMode\", namespace) === \"random\",\n  );\n}\n\nfunction processTimeStamp(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeStamp\", namespaces.kmlgx);\n  const whenString = queryStringValue(node, \"when\", namespaces.kmlgx);\n\n  if (!defined(node) || !defined(whenString) || whenString.length === 0) {\n    return undefined;\n  }\n\n  //According to the KML spec, a TimeStamp represents a \"single moment in time\"\n  //However, since Cesium animates much differently than Google Earth, that doesn't\n  //Make much sense here.  Instead, we use the TimeStamp as the moment the feature\n  //comes into existence.  This works much better and gives a similar feel to\n  //GE's experience.\n  const when = JulianDate.fromIso8601(whenString);\n  const result = new TimeIntervalCollection();\n  result.addInterval(\n    new TimeInterval({\n      start: when,\n      stop: Iso8601.MAXIMUM_VALUE,\n    }),\n  );\n  return result;\n}\n\nfunction processTimeSpan(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeSpan\", namespaces.kmlgx);\n  if (!defined(node)) {\n    return undefined;\n  }\n  let result;\n\n  const beginNode = queryFirstNode(node, \"begin\", namespaces.kmlgx);\n  let beginDate = defined(beginNode)\n    ? JulianDate.fromIso8601(beginNode.textContent)\n    : undefined;\n\n  const endNode = queryFirstNode(node, \"end\", namespaces.kmlgx);\n  let endDate = defined(endNode)\n    ? JulianDate.fromIso8601(endNode.textContent)\n    : undefined;\n\n  if (defined(beginDate) && defined(endDate)) {\n    if (JulianDate.lessThan(endDate, beginDate)) {\n      const tmp = beginDate;\n      beginDate = endDate;\n      endDate = tmp;\n    }\n    result = new TimeIntervalCollection();\n    result.addInterval(\n      new TimeInterval({\n        start: beginDate,\n        stop: endDate,\n      }),\n    );\n  } else if (defined(beginDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(\n      new TimeInterval({\n        start: beginDate,\n        stop: Iso8601.MAXIMUM_VALUE,\n      }),\n    );\n  } else if (defined(endDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(\n      new TimeInterval({\n        start: Iso8601.MINIMUM_VALUE,\n        stop: endDate,\n      }),\n    );\n  }\n\n  return result;\n}\n\nfunction createDefaultBillboard() {\n  const billboard = new BillboardGraphics();\n  billboard.width = BILLBOARD_SIZE;\n  billboard.height = BILLBOARD_SIZE;\n  billboard.scaleByDistance = new NearFarScalar(\n    BILLBOARD_NEAR_DISTANCE,\n    BILLBOARD_NEAR_RATIO,\n    BILLBOARD_FAR_DISTANCE,\n    BILLBOARD_FAR_RATIO,\n  );\n  billboard.pixelOffsetScaleByDistance = new NearFarScalar(\n    BILLBOARD_NEAR_DISTANCE,\n    BILLBOARD_NEAR_RATIO,\n    BILLBOARD_FAR_DISTANCE,\n    BILLBOARD_FAR_RATIO,\n  );\n  return billboard;\n}\n\nfunction createDefaultPolygon() {\n  const polygon = new PolygonGraphics();\n  polygon.outline = true;\n  polygon.outlineColor = Color.WHITE;\n  return polygon;\n}\n\nfunction createDefaultLabel() {\n  const label = new LabelGraphics();\n  label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n  label.pixelOffset = new Cartesian2(17, 0);\n  label.horizontalOrigin = HorizontalOrigin.LEFT;\n  label.font = \"16px sans-serif\";\n  label.style = LabelStyle.FILL_AND_OUTLINE;\n  return label;\n}\n\nfunction getIconHref(\n  iconNode,\n  dataSource,\n  sourceResource,\n  uriResolver,\n  canRefresh,\n) {\n  let href = queryStringValue(iconNode, \"href\", namespaces.kml);\n  if (!defined(href) || href.length === 0) {\n    return undefined;\n  }\n\n  if (href.indexOf(\"root://icons/palette-\") === 0) {\n    const palette = href.charAt(21);\n\n    // Get the icon number\n    let x = defaultValue(queryNumericValue(iconNode, \"x\", namespaces.gx), 0);\n    let y = defaultValue(queryNumericValue(iconNode, \"y\", namespaces.gx), 0);\n    x = Math.min(x / 32, 7);\n    y = 7 - Math.min(y / 32, 7);\n    const iconNum = 8 * y + x;\n\n    href = `https://maps.google.com/mapfiles/kml/pal${palette}/icon${iconNum}.png`;\n  }\n\n  const hrefResource = resolveHref(href, sourceResource, uriResolver);\n\n  if (canRefresh) {\n    const refreshMode = queryStringValue(\n      iconNode,\n      \"refreshMode\",\n      namespaces.kml,\n    );\n    const viewRefreshMode = queryStringValue(\n      iconNode,\n      \"viewRefreshMode\",\n      namespaces.kml,\n    );\n    if (refreshMode === \"onInterval\" || refreshMode === \"onExpire\") {\n      oneTimeWarning(\n        `kml-refreshMode-${refreshMode}`,\n        `KML - Unsupported Icon refreshMode: ${refreshMode}`,\n      );\n    } else if (viewRefreshMode === \"onStop\" || viewRefreshMode === \"onRegion\") {\n      oneTimeWarning(\n        `kml-refreshMode-${viewRefreshMode}`,\n        `KML - Unsupported Icon viewRefreshMode: ${viewRefreshMode}`,\n      );\n    }\n\n    const viewBoundScale = defaultValue(\n      queryStringValue(iconNode, \"viewBoundScale\", namespaces.kml),\n      1.0,\n    );\n    const defaultViewFormat =\n      viewRefreshMode === \"onStop\"\n        ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\"\n        : \"\";\n    const viewFormat = defaultValue(\n      queryStringValue(iconNode, \"viewFormat\", namespaces.kml),\n      defaultViewFormat,\n    );\n    const httpQuery = queryStringValue(iconNode, \"httpQuery\", namespaces.kml);\n    if (defined(viewFormat)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n    }\n    if (defined(httpQuery)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n    }\n\n    const ellipsoid = dataSource._ellipsoid;\n    processNetworkLinkQueryString(\n      hrefResource,\n      dataSource.camera,\n      dataSource.canvas,\n      viewBoundScale,\n      dataSource._lastCameraView.bbox,\n      ellipsoid,\n    );\n\n    return hrefResource;\n  }\n\n  return hrefResource;\n}\n\nfunction processBillboardIcon(\n  dataSource,\n  node,\n  targetEntity,\n  sourceResource,\n  uriResolver,\n) {\n  let scale = queryNumericValue(node, \"scale\", namespaces.kml);\n  const heading = queryNumericValue(node, \"heading\", namespaces.kml);\n  const color = queryColorValue(node, \"color\", namespaces.kml);\n\n  const iconNode = queryFirstNode(node, \"Icon\", namespaces.kml);\n  let icon = getIconHref(\n    iconNode,\n    dataSource,\n    sourceResource,\n    uriResolver,\n    false,\n  );\n\n  // If icon tags are present but blank, we do not want to show an icon\n  if (defined(iconNode) && !defined(icon)) {\n    icon = false;\n  }\n\n  const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n  const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n  const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n  const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n\n  const hotSpotNode = queryFirstNode(node, \"hotSpot\", namespaces.kml);\n  const hotSpotX = queryNumericAttribute(hotSpotNode, \"x\");\n  const hotSpotY = queryNumericAttribute(hotSpotNode, \"y\");\n  const hotSpotXUnit = queryStringAttribute(hotSpotNode, \"xunits\");\n  const hotSpotYUnit = queryStringAttribute(hotSpotNode, \"yunits\");\n\n  let billboard = targetEntity.billboard;\n  if (!defined(billboard)) {\n    billboard = createDefaultBillboard();\n    targetEntity.billboard = billboard;\n  }\n\n  billboard.image = icon;\n  billboard.scale = scale;\n  billboard.color = color;\n\n  if (defined(x) || defined(y) || defined(w) || defined(h)) {\n    billboard.imageSubRegion = new BoundingRectangle(x, y, w, h);\n  }\n\n  //GE treats a heading of zero as no heading\n  //You can still point north using a 360 degree angle (or any multiple of 360)\n  if (defined(heading) && heading !== 0) {\n    billboard.rotation = CesiumMath.toRadians(-heading);\n    billboard.alignedAxis = Cartesian3.UNIT_Z;\n  }\n\n  //Hotpot is the KML equivalent of pixel offset\n  //The hotspot origin is the lower left, but we leave\n  //our billboard origin at the center and simply\n  //modify the pixel offset to take this into account\n  scale = defaultValue(scale, 1.0);\n\n  let xOffset;\n  let yOffset;\n  if (defined(hotSpotX)) {\n    if (hotSpotXUnit === \"pixels\") {\n      xOffset = -hotSpotX * scale;\n    } else if (hotSpotXUnit === \"insetPixels\") {\n      xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;\n    } else if (hotSpotXUnit === \"fraction\") {\n      xOffset = -hotSpotX * BILLBOARD_SIZE * scale;\n    }\n    xOffset += BILLBOARD_SIZE * 0.5 * scale;\n  }\n\n  if (defined(hotSpotY)) {\n    if (hotSpotYUnit === \"pixels\") {\n      yOffset = hotSpotY * scale;\n    } else if (hotSpotYUnit === \"insetPixels\") {\n      yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;\n    } else if (hotSpotYUnit === \"fraction\") {\n      yOffset = hotSpotY * BILLBOARD_SIZE * scale;\n    }\n\n    yOffset -= BILLBOARD_SIZE * 0.5 * scale;\n  }\n\n  if (defined(xOffset) || defined(yOffset)) {\n    billboard.pixelOffset = new Cartesian2(xOffset, yOffset);\n  }\n}\n\nfunction applyStyle(\n  dataSource,\n  styleNode,\n  targetEntity,\n  sourceResource,\n  uriResolver,\n) {\n  for (let i = 0, len = styleNode.childNodes.length; i < len; i++) {\n    const node = styleNode.childNodes.item(i);\n    if (node.localName === \"IconStyle\") {\n      processBillboardIcon(\n        dataSource,\n        node,\n        targetEntity,\n        sourceResource,\n        uriResolver,\n      );\n    } else if (node.localName === \"LabelStyle\") {\n      let label = targetEntity.label;\n      if (!defined(label)) {\n        label = createDefaultLabel();\n        targetEntity.label = label;\n      }\n      label.scale = defaultValue(\n        queryNumericValue(node, \"scale\", namespaces.kml),\n        label.scale,\n      );\n      label.fillColor = defaultValue(\n        queryColorValue(node, \"color\", namespaces.kml),\n        label.fillColor,\n      );\n      label.text = targetEntity.name;\n    } else if (node.localName === \"LineStyle\") {\n      let polyline = targetEntity.polyline;\n      if (!defined(polyline)) {\n        polyline = new PolylineGraphics();\n        targetEntity.polyline = polyline;\n      }\n      polyline.width = queryNumericValue(node, \"width\", namespaces.kml);\n      polyline.material = queryColorValue(node, \"color\", namespaces.kml);\n      if (defined(queryColorValue(node, \"outerColor\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:outerColor\",\n          \"KML - gx:outerColor is not supported in a LineStyle\",\n        );\n      }\n      if (defined(queryNumericValue(node, \"outerWidth\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:outerWidth\",\n          \"KML - gx:outerWidth is not supported in a LineStyle\",\n        );\n      }\n      if (defined(queryNumericValue(node, \"physicalWidth\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:physicalWidth\",\n          \"KML - gx:physicalWidth is not supported in a LineStyle\",\n        );\n      }\n      if (defined(queryBooleanValue(node, \"labelVisibility\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:labelVisibility\",\n          \"KML - gx:labelVisibility is not supported in a LineStyle\",\n        );\n      }\n    } else if (node.localName === \"PolyStyle\") {\n      let polygon = targetEntity.polygon;\n      if (!defined(polygon)) {\n        polygon = createDefaultPolygon();\n        targetEntity.polygon = polygon;\n      }\n      polygon.material = defaultValue(\n        queryColorValue(node, \"color\", namespaces.kml),\n        polygon.material,\n      );\n      polygon.fill = defaultValue(\n        queryBooleanValue(node, \"fill\", namespaces.kml),\n        polygon.fill,\n      );\n      polygon.outline = defaultValue(\n        queryBooleanValue(node, \"outline\", namespaces.kml),\n        polygon.outline,\n      );\n    } else if (node.localName === \"BalloonStyle\") {\n      const bgColor = defaultValue(\n        parseColorString(queryStringValue(node, \"bgColor\", namespaces.kml)),\n        Color.WHITE,\n      );\n      const textColor = defaultValue(\n        parseColorString(queryStringValue(node, \"textColor\", namespaces.kml)),\n        Color.BLACK,\n      );\n      const text = queryStringValue(node, \"text\", namespaces.kml);\n\n      //This is purely an internal property used in style processing,\n      //it never ends up on the final entity.\n      targetEntity.addProperty(\"balloonStyle\");\n      targetEntity.balloonStyle = {\n        bgColor: bgColor,\n        textColor: textColor,\n        text: text,\n      };\n    } else if (node.localName === \"ListStyle\") {\n      const listItemType = queryStringValue(\n        node,\n        \"listItemType\",\n        namespaces.kml,\n      );\n      if (listItemType === \"radioFolder\" || listItemType === \"checkOffOnly\") {\n        oneTimeWarning(\n          `kml-listStyle-${listItemType}`,\n          `KML - Unsupported ListStyle with listItemType: ${listItemType}`,\n        );\n      }\n    }\n  }\n}\n\n//Processes and merges any inline styles for the provided node into the provided entity.\nfunction computeFinalStyle(\n  dataSource,\n  placeMark,\n  styleCollection,\n  sourceResource,\n  uriResolver,\n) {\n  const result = new Entity();\n  let styleEntity;\n\n  //Google earth seems to always use the last inline Style/StyleMap only\n  let styleIndex = -1;\n  const childNodes = placeMark.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === \"Style\" || child.localName === \"StyleMap\") {\n      styleIndex = q;\n    }\n  }\n\n  if (styleIndex !== -1) {\n    const inlineStyleNode = childNodes[styleIndex];\n    if (inlineStyleNode.localName === \"Style\") {\n      applyStyle(\n        dataSource,\n        inlineStyleNode,\n        result,\n        sourceResource,\n        uriResolver,\n      );\n    } else {\n      // StyleMap\n      const pairs = queryChildNodes(inlineStyleNode, \"Pair\", namespaces.kml);\n      for (let p = 0; p < pairs.length; p++) {\n        const pair = pairs[p];\n        const key = queryStringValue(pair, \"key\", namespaces.kml);\n        if (key === \"normal\") {\n          const styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n          if (defined(styleUrl)) {\n            styleEntity = styleCollection.getById(styleUrl);\n            if (!defined(styleEntity)) {\n              styleEntity = styleCollection.getById(`#${styleUrl}`);\n            }\n            if (defined(styleEntity)) {\n              result.merge(styleEntity);\n            }\n          } else {\n            const node = queryFirstNode(pair, \"Style\", namespaces.kml);\n            applyStyle(dataSource, node, result, sourceResource, uriResolver);\n          }\n        } else {\n          oneTimeWarning(\n            `kml-styleMap-${key}`,\n            `KML - Unsupported StyleMap key: ${key}`,\n          );\n        }\n      }\n    }\n  }\n\n  //Google earth seems to always use the first external style only.\n  const externalStyle = queryStringValue(placeMark, \"styleUrl\", namespaces.kml);\n  if (defined(externalStyle)) {\n    let id = externalStyle;\n    if (externalStyle[0] !== \"#\" && externalStyle.indexOf(\"#\") !== -1) {\n      const tokens = externalStyle.split(\"#\");\n      const uri = tokens[0];\n      const resource = sourceResource.getDerivedResource({\n        url: uri,\n      });\n\n      id = `${resource.getUrlComponent()}#${tokens[1]}`;\n    }\n\n    styleEntity = styleCollection.getById(id);\n    if (!defined(styleEntity)) {\n      styleEntity = styleCollection.getById(`#${id}`);\n    }\n    if (defined(styleEntity)) {\n      result.merge(styleEntity);\n    }\n  }\n\n  return result;\n}\n\n//Asynchronously processes an external style file.\nfunction processExternalStyles(dataSource, resource, styleCollection) {\n  return resource.fetchXML().then(function (styleKml) {\n    return processStyles(dataSource, styleKml, styleCollection, resource, true);\n  });\n}\n\n//Processes all shared and external styles and stores\n//their id into the provided styleCollection.\n//Returns an array of promises that will resolve when\n//each style is loaded.\nfunction processStyles(\n  dataSource,\n  kml,\n  styleCollection,\n  sourceResource,\n  isExternal,\n  uriResolver,\n) {\n  let i;\n  let id;\n  let styleEntity;\n\n  let node;\n  const styleNodes = queryNodes(kml, \"Style\", namespaces.kml);\n  if (defined(styleNodes)) {\n    const styleNodesLength = styleNodes.length;\n    for (i = 0; i < styleNodesLength; i++) {\n      node = styleNodes[i];\n      id = queryStringAttribute(node, \"id\");\n      if (defined(id)) {\n        id = `#${id}`;\n        if (isExternal && defined(sourceResource)) {\n          id = sourceResource.getUrlComponent() + id;\n        }\n        if (!defined(styleCollection.getById(id))) {\n          styleEntity = new Entity({\n            id: id,\n          });\n          styleCollection.add(styleEntity);\n          applyStyle(\n            dataSource,\n            node,\n            styleEntity,\n            sourceResource,\n            uriResolver,\n          );\n        }\n      }\n    }\n  }\n\n  const styleMaps = queryNodes(kml, \"StyleMap\", namespaces.kml);\n  if (defined(styleMaps)) {\n    const styleMapsLength = styleMaps.length;\n    for (i = 0; i < styleMapsLength; i++) {\n      const styleMap = styleMaps[i];\n      id = queryStringAttribute(styleMap, \"id\");\n      if (defined(id)) {\n        const pairs = queryChildNodes(styleMap, \"Pair\", namespaces.kml);\n        for (let p = 0; p < pairs.length; p++) {\n          const pair = pairs[p];\n          const key = queryStringValue(pair, \"key\", namespaces.kml);\n          if (key === \"normal\") {\n            id = `#${id}`;\n            if (isExternal && defined(sourceResource)) {\n              id = sourceResource.getUrlComponent() + id;\n            }\n            if (!defined(styleCollection.getById(id))) {\n              styleEntity = styleCollection.getOrCreateEntity(id);\n\n              let styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n              if (defined(styleUrl)) {\n                if (styleUrl[0] !== \"#\") {\n                  styleUrl = `#${styleUrl}`;\n                }\n\n                if (isExternal && defined(sourceResource)) {\n                  styleUrl = sourceResource.getUrlComponent() + styleUrl;\n                }\n                const base = styleCollection.getById(styleUrl);\n\n                if (defined(base)) {\n                  styleEntity.merge(base);\n                }\n              } else {\n                node = queryFirstNode(pair, \"Style\", namespaces.kml);\n                applyStyle(\n                  dataSource,\n                  node,\n                  styleEntity,\n                  sourceResource,\n                  uriResolver,\n                );\n              }\n            }\n          } else {\n            oneTimeWarning(\n              `kml-styleMap-${key}`,\n              `KML - Unsupported StyleMap key: ${key}`,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  const promises = [];\n  const styleUrlNodes = kml.getElementsByTagName(\"styleUrl\");\n  const styleUrlNodesLength = styleUrlNodes.length;\n  for (i = 0; i < styleUrlNodesLength; i++) {\n    const styleReference = styleUrlNodes[i].textContent;\n    if (styleReference[0] !== \"#\") {\n      //According to the spec, all local styles should start with a #\n      //and everything else is an external style that has a # seperating\n      //the URL of the document and the style.  However, Google Earth\n      //also accepts styleUrls without a # as meaning a local style.\n      const tokens = styleReference.split(\"#\");\n      if (tokens.length === 2) {\n        const uri = tokens[0];\n        const resource = sourceResource.getDerivedResource({\n          url: uri,\n        });\n\n        promises.push(\n          processExternalStyles(dataSource, resource, styleCollection),\n        );\n      }\n    }\n  }\n\n  return promises;\n}\n\nfunction createDropLine(entityCollection, entity, styleEntity) {\n  const entityPosition = new ReferenceProperty(entityCollection, entity.id, [\n    \"position\",\n  ]);\n  const surfacePosition = new ScaledPositionProperty(entity.position);\n  entity.polyline = defined(styleEntity.polyline)\n    ? styleEntity.polyline.clone()\n    : new PolylineGraphics();\n  entity.polyline.positions = new PositionPropertyArray([\n    entityPosition,\n    surfacePosition,\n  ]);\n}\n\nfunction heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {\n  if (\n    (!defined(altitudeMode) && !defined(gxAltitudeMode)) ||\n    altitudeMode === \"clampToGround\"\n  ) {\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n\n  if (altitudeMode === \"relativeToGround\") {\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n\n  if (altitudeMode === \"absolute\") {\n    return HeightReference.NONE;\n  }\n\n  if (gxAltitudeMode === \"clampToSeaFloor\") {\n    oneTimeWarning(\n      \"kml-gx:altitudeMode-clampToSeaFloor\",\n      \"KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround.\",\n    );\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n\n  if (gxAltitudeMode === \"relativeToSeaFloor\") {\n    oneTimeWarning(\n      \"kml-gx:altitudeMode-relativeToSeaFloor\",\n      \"KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround.\",\n    );\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n\n  if (defined(altitudeMode)) {\n    oneTimeWarning(\n      \"kml-altitudeMode-unknown\",\n      `KML - Unknown <kml:altitudeMode>:${altitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`,\n    );\n  } else {\n    oneTimeWarning(\n      \"kml-gx:altitudeMode-unknown\",\n      `KML - Unknown <gx:altitudeMode>:${gxAltitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`,\n    );\n  }\n\n  // Clamp to ground is the default\n  return HeightReference.CLAMP_TO_GROUND;\n}\n\nfunction createPositionPropertyFromAltitudeMode(\n  property,\n  altitudeMode,\n  gxAltitudeMode,\n) {\n  if (\n    gxAltitudeMode === \"relativeToSeaFloor\" ||\n    altitudeMode === \"absolute\" ||\n    altitudeMode === \"relativeToGround\"\n  ) {\n    //Just return the ellipsoid referenced property until we support MSL\n    return property;\n  }\n\n  if (\n    (defined(altitudeMode) && altitudeMode !== \"clampToGround\") || //\n    (defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\")\n  ) {\n    oneTimeWarning(\n      \"kml-altitudeMode-unknown\",\n      `KML - Unknown altitudeMode: ${defaultValue(\n        altitudeMode,\n        gxAltitudeMode,\n      )}`,\n    );\n  }\n\n  // Clamp to ground is the default\n  return new ScaledPositionProperty(property);\n}\n\nfunction createPositionPropertyArrayFromAltitudeMode(\n  properties,\n  altitudeMode,\n  gxAltitudeMode,\n  ellipsoid,\n) {\n  if (!defined(properties)) {\n    return undefined;\n  }\n\n  if (\n    gxAltitudeMode === \"relativeToSeaFloor\" ||\n    altitudeMode === \"absolute\" ||\n    altitudeMode === \"relativeToGround\"\n  ) {\n    //Just return the ellipsoid referenced property until we support MSL\n    return properties;\n  }\n\n  if (\n    (defined(altitudeMode) && altitudeMode !== \"clampToGround\") || //\n    (defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\")\n  ) {\n    oneTimeWarning(\n      \"kml-altitudeMode-unknown\",\n      `KML - Unknown altitudeMode: ${defaultValue(\n        altitudeMode,\n        gxAltitudeMode,\n      )}`,\n    );\n  }\n\n  // Clamp to ground is the default\n  const propertiesLength = properties.length;\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i];\n    ellipsoid.scaleToGeodeticSurface(property, property);\n  }\n  return properties;\n}\n\nfunction processPositionGraphics(\n  dataSource,\n  entity,\n  styleEntity,\n  heightReference,\n) {\n  let label = entity.label;\n  if (!defined(label)) {\n    label = defined(styleEntity.label)\n      ? styleEntity.label.clone()\n      : createDefaultLabel();\n    entity.label = label;\n  }\n  label.text = entity.name;\n\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    billboard = defined(styleEntity.billboard)\n      ? styleEntity.billboard.clone()\n      : createDefaultBillboard();\n    entity.billboard = billboard;\n  }\n\n  if (!defined(billboard.image)) {\n    billboard.image = dataSource._pinBuilder.fromColor(Color.YELLOW, 64);\n\n    // If there were empty <Icon> tags in the KML, then billboard.image was set to false above\n    // However, in this case, the false value would have been converted to a property afterwards\n    // Thus, we check if billboard.image is defined with value of false\n  } else if (!billboard.image.getValue()) {\n    billboard.image = undefined;\n  }\n\n  let scale = 1.0;\n  if (defined(billboard.scale)) {\n    scale = billboard.scale.getValue();\n    if (scale !== 0) {\n      label.pixelOffset = new Cartesian2(scale * 16 + 1, 0);\n    } else {\n      //Minor tweaks to better match Google Earth.\n      label.pixelOffset = undefined;\n      label.horizontalOrigin = undefined;\n    }\n  }\n\n  if (defined(heightReference) && dataSource._clampToGround) {\n    billboard.heightReference = heightReference;\n    label.heightReference = heightReference;\n  }\n}\n\nfunction processPathGraphics(entity, styleEntity) {\n  let path = entity.path;\n  if (!defined(path)) {\n    path = new PathGraphics();\n    path.leadTime = 0;\n    entity.path = path;\n  }\n\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    path.material = polyline.material;\n    path.width = polyline.width;\n  }\n}\n\nfunction processPoint(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const coordinatesString = queryStringValue(\n    geometryNode,\n    \"coordinates\",\n    namespaces.kml,\n  );\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const ellipsoid = dataSource._ellipsoid;\n  const position = readCoordinate(coordinatesString, ellipsoid);\n\n  entity.position = position;\n  processPositionGraphics(\n    dataSource,\n    entity,\n    styleEntity,\n    heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode),\n  );\n\n  if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n\n  return true;\n}\n\nfunction processLineStringOrLinearRing(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const coordinatesNode = queryFirstNode(\n    geometryNode,\n    \"coordinates\",\n    namespaces.kml,\n  );\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const tessellate = queryBooleanValue(\n    geometryNode,\n    \"tessellate\",\n    namespaces.kml,\n  );\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const zIndex = queryNumericValue(geometryNode, \"drawOrder\", namespaces.gx);\n\n  const ellipsoid = dataSource._ellipsoid;\n  const coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  let polyline = styleEntity.polyline;\n  if (canExtrude && extrude) {\n    const wall = new WallGraphics();\n    entity.wall = wall;\n    wall.positions = coordinates;\n    const polygon = styleEntity.polygon;\n\n    if (defined(polygon)) {\n      wall.fill = polygon.fill;\n      wall.material = polygon.material;\n    }\n\n    //Always outline walls so they show up in 2D.\n    wall.outline = true;\n    if (defined(polyline)) {\n      wall.outlineColor = defined(polyline.material)\n        ? polyline.material.color\n        : Color.WHITE;\n      wall.outlineWidth = polyline.width;\n    } else if (defined(polygon)) {\n      wall.outlineColor = defined(polygon.material)\n        ? polygon.material.color\n        : Color.WHITE;\n    }\n  } else if (dataSource._clampToGround && !canExtrude && tessellate) {\n    const polylineGraphics = new PolylineGraphics();\n    polylineGraphics.clampToGround = true;\n    entity.polyline = polylineGraphics;\n    polylineGraphics.positions = coordinates;\n    if (defined(polyline)) {\n      polylineGraphics.material = defined(polyline.material)\n        ? polyline.material.color.getValue(Iso8601.MINIMUM_VALUE)\n        : Color.WHITE;\n      polylineGraphics.width = defaultValue(polyline.width, 1.0);\n    } else {\n      polylineGraphics.material = Color.WHITE;\n      polylineGraphics.width = 1.0;\n    }\n    polylineGraphics.zIndex = zIndex;\n  } else {\n    if (defined(zIndex)) {\n      oneTimeWarning(\n        \"kml-gx:drawOrder\",\n        \"KML - gx:drawOrder is not supported in LineStrings when clampToGround is false\",\n      );\n    }\n    if (dataSource._clampToGround && !tessellate) {\n      oneTimeWarning(\n        \"kml-line-tesselate\",\n        \"Ignoring clampToGround for KML lines without the tessellate flag.\",\n      );\n    }\n\n    polyline = defined(polyline) ? polyline.clone() : new PolylineGraphics();\n    entity.polyline = polyline;\n    polyline.positions = createPositionPropertyArrayFromAltitudeMode(\n      coordinates,\n      altitudeMode,\n      gxAltitudeMode,\n      ellipsoid,\n    );\n    if (!tessellate || canExtrude) {\n      polyline.arcType = ArcType.NONE;\n    }\n  }\n\n  return true;\n}\n\nfunction processPolygon(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const outerBoundaryIsNode = queryFirstNode(\n    geometryNode,\n    \"outerBoundaryIs\",\n    namespaces.kml,\n  );\n  let linearRingNode = queryFirstNode(\n    outerBoundaryIsNode,\n    \"LinearRing\",\n    namespaces.kml,\n  );\n  let coordinatesNode = queryFirstNode(\n    linearRingNode,\n    \"coordinates\",\n    namespaces.kml,\n  );\n  const ellipsoid = dataSource._ellipsoid;\n  let coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n\n  const polygon = defined(styleEntity.polygon)\n    ? styleEntity.polygon.clone()\n    : createDefaultPolygon();\n\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    polygon.outlineColor = defined(polyline.material)\n      ? polyline.material.color\n      : Color.WHITE;\n    polygon.outlineWidth = polyline.width;\n  }\n  entity.polygon = polygon;\n\n  if (canExtrude) {\n    polygon.perPositionHeight = true;\n    polygon.extrudedHeight = extrude ? 0 : undefined;\n  } else if (!dataSource._clampToGround) {\n    polygon.height = 0;\n  }\n\n  if (defined(coordinates)) {\n    const hierarchy = new PolygonHierarchy(coordinates);\n    const innerBoundaryIsNodes = queryChildNodes(\n      geometryNode,\n      \"innerBoundaryIs\",\n      namespaces.kml,\n    );\n    for (let j = 0; j < innerBoundaryIsNodes.length; j++) {\n      linearRingNode = queryChildNodes(\n        innerBoundaryIsNodes[j],\n        \"LinearRing\",\n        namespaces.kml,\n      );\n      for (let k = 0; k < linearRingNode.length; k++) {\n        coordinatesNode = queryFirstNode(\n          linearRingNode[k],\n          \"coordinates\",\n          namespaces.kml,\n        );\n        coordinates = readCoordinates(coordinatesNode, ellipsoid);\n        if (defined(coordinates)) {\n          hierarchy.holes.push(new PolygonHierarchy(coordinates));\n        }\n      }\n    }\n    polygon.hierarchy = hierarchy;\n  }\n\n  return true;\n}\n\nfunction processTrack(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const coordNodes = queryChildNodes(geometryNode, \"coord\", namespaces.gx);\n  const angleNodes = queryChildNodes(geometryNode, \"angles\", namespaces.gx);\n  const timeNodes = queryChildNodes(geometryNode, \"when\", namespaces.kml);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const ellipsoid = dataSource._ellipsoid;\n\n  if (angleNodes.length > 0) {\n    oneTimeWarning(\n      \"kml-gx:angles\",\n      \"KML - gx:angles are not supported in gx:Tracks\",\n    );\n  }\n\n  const length = Math.min(coordNodes.length, timeNodes.length);\n  const coordinates = [];\n  const times = [];\n  for (let i = 0; i < length; i++) {\n    const position = readCoordinate(coordNodes[i].textContent, ellipsoid);\n    coordinates.push(position);\n    times.push(JulianDate.fromIso8601(timeNodes[i].textContent));\n  }\n  const property = new SampledPositionProperty();\n  property.addSamples(times, coordinates);\n  entity.position = property;\n  processPositionGraphics(\n    dataSource,\n    entity,\n    styleEntity,\n    heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode),\n  );\n  processPathGraphics(entity, styleEntity);\n\n  entity.availability = new TimeIntervalCollection();\n\n  if (timeNodes.length > 0) {\n    entity.availability.addInterval(\n      new TimeInterval({\n        start: times[0],\n        stop: times[times.length - 1],\n      }),\n    );\n  }\n\n  if (canExtrude && extrude) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n\n  return true;\n}\n\nfunction addToMultiTrack(\n  times,\n  positions,\n  composite,\n  availability,\n  dropShowProperty,\n  extrude,\n  altitudeMode,\n  gxAltitudeMode,\n  includeEndPoints,\n) {\n  const start = times[0];\n  const stop = times[times.length - 1];\n\n  const data = new SampledPositionProperty();\n  data.addSamples(times, positions);\n\n  composite.intervals.addInterval(\n    new TimeInterval({\n      start: start,\n      stop: stop,\n      isStartIncluded: includeEndPoints,\n      isStopIncluded: includeEndPoints,\n      data: createPositionPropertyFromAltitudeMode(\n        data,\n        altitudeMode,\n        gxAltitudeMode,\n      ),\n    }),\n  );\n  availability.addInterval(\n    new TimeInterval({\n      start: start,\n      stop: stop,\n      isStartIncluded: includeEndPoints,\n      isStopIncluded: includeEndPoints,\n    }),\n  );\n  dropShowProperty.intervals.addInterval(\n    new TimeInterval({\n      start: start,\n      stop: stop,\n      isStartIncluded: includeEndPoints,\n      isStopIncluded: includeEndPoints,\n      data: extrude,\n    }),\n  );\n}\n\nfunction processMultiTrack(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  // Multitrack options do not work in GE as detailed in the spec,\n  // rather than altitudeMode being at the MultiTrack level,\n  // GE just defers all settings to the underlying track.\n\n  const interpolate = queryBooleanValue(\n    geometryNode,\n    \"interpolate\",\n    namespaces.gx,\n  );\n  const trackNodes = queryChildNodes(geometryNode, \"Track\", namespaces.gx);\n\n  let times;\n  let lastStop;\n  let lastStopPosition;\n  let needDropLine = false;\n  const dropShowProperty = new TimeIntervalCollectionProperty();\n  const availability = new TimeIntervalCollection();\n  const composite = new CompositePositionProperty();\n  const ellipsoid = dataSource._ellipsoid;\n  for (let i = 0, len = trackNodes.length; i < len; i++) {\n    const trackNode = trackNodes[i];\n    const timeNodes = queryChildNodes(trackNode, \"when\", namespaces.kml);\n    const coordNodes = queryChildNodes(trackNode, \"coord\", namespaces.gx);\n    const altitudeMode = queryStringValue(\n      trackNode,\n      \"altitudeMode\",\n      namespaces.kml,\n    );\n    const gxAltitudeMode = queryStringValue(\n      trackNode,\n      \"altitudeMode\",\n      namespaces.gx,\n    );\n    const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n    const extrude = queryBooleanValue(trackNode, \"extrude\", namespaces.kml);\n\n    const length = Math.min(coordNodes.length, timeNodes.length);\n\n    const positions = [];\n    times = [];\n    for (let x = 0; x < length; x++) {\n      const position = readCoordinate(coordNodes[x].textContent, ellipsoid);\n      positions.push(position);\n      times.push(JulianDate.fromIso8601(timeNodes[x].textContent));\n    }\n\n    if (interpolate) {\n      //If we are interpolating, then we need to fill in the end of\n      //the last track and the beginning of this one with a sampled\n      //property.  From testing in Google Earth, this property\n      //is never extruded and always absolute.\n      if (defined(lastStop)) {\n        addToMultiTrack(\n          [lastStop, times[0]],\n          [lastStopPosition, positions[0]],\n          composite,\n          availability,\n          dropShowProperty,\n          false,\n          \"absolute\",\n          undefined,\n          false,\n        );\n      }\n      lastStop = times[length - 1];\n      lastStopPosition = positions[positions.length - 1];\n    }\n\n    addToMultiTrack(\n      times,\n      positions,\n      composite,\n      availability,\n      dropShowProperty,\n      canExtrude && extrude,\n      altitudeMode,\n      gxAltitudeMode,\n      true,\n    );\n    needDropLine = needDropLine || (canExtrude && extrude);\n  }\n\n  entity.availability = availability;\n  entity.position = composite;\n  processPositionGraphics(dataSource, entity, styleEntity);\n  processPathGraphics(entity, styleEntity);\n  if (needDropLine) {\n    createDropLine(entityCollection, entity, styleEntity);\n    entity.polyline.show = dropShowProperty;\n  }\n\n  return true;\n}\n\nconst geometryTypes = {\n  Point: processPoint,\n  LineString: processLineStringOrLinearRing,\n  LinearRing: processLineStringOrLinearRing,\n  Polygon: processPolygon,\n  Track: processTrack,\n  MultiTrack: processMultiTrack,\n  MultiGeometry: processMultiGeometry,\n  Model: processUnsupportedGeometry,\n};\n\nfunction processMultiGeometry(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n  context,\n) {\n  const childNodes = geometryNode.childNodes;\n  let hasGeometry = false;\n  for (let i = 0, len = childNodes.length; i < len; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      const childEntity = createEntity(childNode, entityCollection, context);\n      childEntity.parent = entity;\n      childEntity.name = entity.name;\n      childEntity.availability = entity.availability;\n      childEntity.description = entity.description;\n      childEntity.kml = entity.kml;\n      if (\n        geometryProcessor(\n          dataSource,\n          entityCollection,\n          childNode,\n          childEntity,\n          styleEntity,\n        )\n      ) {\n        hasGeometry = true;\n      }\n    }\n  }\n\n  return hasGeometry;\n}\n\nfunction processUnsupportedGeometry(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  oneTimeWarning(\n    \"kml-unsupportedGeometry\",\n    `KML - Unsupported geometry: ${geometryNode.localName}`,\n  );\n  return false;\n}\n\nfunction processExtendedData(node, entity) {\n  const extendedDataNode = queryFirstNode(node, \"ExtendedData\", namespaces.kml);\n\n  if (!defined(extendedDataNode)) {\n    return undefined;\n  }\n\n  if (defined(queryFirstNode(extendedDataNode, \"SchemaData\", namespaces.kml))) {\n    oneTimeWarning(\"kml-schemaData\", \"KML - SchemaData is unsupported\");\n  }\n  if (defined(queryStringAttribute(extendedDataNode, \"xmlns:prefix\"))) {\n    oneTimeWarning(\n      \"kml-extendedData\",\n      \"KML - ExtendedData with xmlns:prefix is unsupported\",\n    );\n  }\n\n  const result = {};\n  const dataNodes = queryChildNodes(extendedDataNode, \"Data\", namespaces.kml);\n  if (defined(dataNodes)) {\n    const length = dataNodes.length;\n    for (let i = 0; i < length; i++) {\n      const dataNode = dataNodes[i];\n      const name = queryStringAttribute(dataNode, \"name\");\n      if (defined(name)) {\n        result[name] = {\n          displayName: queryStringValue(\n            dataNode,\n            \"displayName\",\n            namespaces.kml,\n          ),\n          value: queryStringValue(dataNode, \"value\", namespaces.kml),\n        };\n      }\n    }\n  }\n  entity.kml.extendedData = result;\n}\n\nlet scratchDiv;\nif (typeof document !== \"undefined\") {\n  scratchDiv = document.createElement(\"div\");\n}\n\nfunction processDescription(\n  node,\n  entity,\n  styleEntity,\n  uriResolver,\n  sourceResource,\n) {\n  let i;\n  let key;\n  let keys;\n\n  const kmlData = entity.kml;\n  const extendedData = kmlData.extendedData;\n  const description = queryStringValue(node, \"description\", namespaces.kml);\n\n  const balloonStyle = defaultValue(\n    entity.balloonStyle,\n    styleEntity.balloonStyle,\n  );\n\n  let background = Color.WHITE;\n  let foreground = Color.BLACK;\n  let text = description;\n\n  if (defined(balloonStyle)) {\n    background = defaultValue(balloonStyle.bgColor, Color.WHITE);\n    foreground = defaultValue(balloonStyle.textColor, Color.BLACK);\n    text = defaultValue(balloonStyle.text, description);\n  }\n\n  let value;\n  if (defined(text)) {\n    text = text.replace(\"$[name]\", defaultValue(entity.name, \"\"));\n    text = text.replace(\"$[description]\", defaultValue(description, \"\"));\n    text = text.replace(\"$[address]\", defaultValue(kmlData.address, \"\"));\n    text = text.replace(\"$[Snippet]\", defaultValue(kmlData.snippet, \"\"));\n    text = text.replace(\"$[id]\", entity.id);\n\n    //While not explicitly defined by the OGC spec, in Google Earth\n    //The appearance of geDirections adds the directions to/from links\n    //We simply replace this string with nothing.\n    text = text.replace(\"$[geDirections]\", \"\");\n\n    if (defined(extendedData)) {\n      const matches = text.match(/\\$\\[.+?\\]/g);\n      if (matches !== null) {\n        for (i = 0; i < matches.length; i++) {\n          const token = matches[i];\n          let propertyName = token.substr(2, token.length - 3);\n          const isDisplayName = /\\/displayName$/.test(propertyName);\n          propertyName = propertyName.replace(/\\/displayName$/, \"\");\n\n          value = extendedData[propertyName];\n          if (defined(value)) {\n            value = isDisplayName ? value.displayName : value.value;\n          }\n          if (defined(value)) {\n            text = text.replace(token, defaultValue(value, \"\"));\n          }\n        }\n      }\n    }\n  } else if (defined(extendedData)) {\n    //If no description exists, build a table out of the extended data\n    keys = Object.keys(extendedData);\n    if (keys.length > 0) {\n      text =\n        '<table class=\"cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter\"><tbody>';\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = extendedData[key];\n        text += `<tr><th>${defaultValue(\n          value.displayName,\n          key,\n        )}</th><td>${defaultValue(value.value, \"\")}</td></tr>`;\n      }\n      text += \"</tbody></table>\";\n    }\n  }\n\n  if (!defined(text)) {\n    //No description\n    return;\n  }\n\n  //Turns non-explicit links into clickable links.\n  text = autolinker.link(text);\n\n  //Use a temporary div to manipulate the links\n  //so that they open in a new window.\n  scratchDiv.innerHTML = text;\n  const links = scratchDiv.querySelectorAll(\"a\");\n  for (i = 0; i < links.length; i++) {\n    links[i].setAttribute(\"target\", \"_blank\");\n  }\n\n  //Rewrite any KMZ embedded urls\n  if (defined(uriResolver) && uriResolver.keys.length > 1) {\n    embedDataUris(scratchDiv, \"a\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"link\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"area\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"img\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"iframe\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"audio\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"source\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"track\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"input\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"embed\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"script\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"poster\", uriResolver);\n  }\n\n  //Make relative urls absolute using the sourceResource\n  applyBasePath(scratchDiv, \"a\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"link\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"area\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"img\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"iframe\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"audio\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"source\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"track\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"input\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"embed\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"script\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"poster\", sourceResource);\n\n  let tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n  tmp += \"overflow:auto;\";\n  tmp += \"word-wrap:break-word;\";\n  tmp += `background-color:${background.toCssColorString()};`;\n  tmp += `color:${foreground.toCssColorString()};`;\n  tmp += '\">';\n  tmp += `${scratchDiv.innerHTML}</div>`;\n  scratchDiv.innerHTML = \"\";\n\n  //Set the final HTML as the description.\n  entity.description = tmp;\n}\n\nfunction processFeature(dataSource, featureNode, processingData) {\n  const entityCollection = processingData.entityCollection;\n  const parent = processingData.parentEntity;\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n\n  const entity = createEntity(\n    featureNode,\n    entityCollection,\n    processingData.context,\n  );\n  const kmlData = entity.kml;\n  const styleEntity = computeFinalStyle(\n    dataSource,\n    featureNode,\n    processingData.styleCollection,\n    sourceResource,\n    uriResolver,\n  );\n\n  const name = queryStringValue(featureNode, \"name\", namespaces.kml);\n  entity.name = name;\n  entity.parent = parent;\n\n  let availability = processTimeSpan(featureNode);\n  if (!defined(availability)) {\n    availability = processTimeStamp(featureNode);\n  }\n  entity.availability = availability;\n\n  mergeAvailabilityWithParent(entity);\n\n  // Per KML spec \"A Feature is visible only if it and all its ancestors are visible.\"\n  function ancestryIsVisible(parentEntity) {\n    if (!parentEntity) {\n      return true;\n    }\n    return parentEntity.show && ancestryIsVisible(parentEntity.parent);\n  }\n\n  const visibility = queryBooleanValue(\n    featureNode,\n    \"visibility\",\n    namespaces.kml,\n  );\n  entity.show = ancestryIsVisible(parent) && defaultValue(visibility, true);\n  //const open = queryBooleanValue(featureNode, 'open', namespaces.kml);\n\n  const authorNode = queryFirstNode(featureNode, \"author\", namespaces.atom);\n  const author = kmlData.author;\n  author.name = queryStringValue(authorNode, \"name\", namespaces.atom);\n  author.uri = queryStringValue(authorNode, \"uri\", namespaces.atom);\n  author.email = queryStringValue(authorNode, \"email\", namespaces.atom);\n\n  const linkNode = queryFirstNode(featureNode, \"link\", namespaces.atom);\n  const link = kmlData.link;\n  link.href = queryStringAttribute(linkNode, \"href\");\n  link.hreflang = queryStringAttribute(linkNode, \"hreflang\");\n  link.rel = queryStringAttribute(linkNode, \"rel\");\n  link.type = queryStringAttribute(linkNode, \"type\");\n  link.title = queryStringAttribute(linkNode, \"title\");\n  link.length = queryStringAttribute(linkNode, \"length\");\n\n  kmlData.address = queryStringValue(featureNode, \"address\", namespaces.kml);\n  kmlData.phoneNumber = queryStringValue(\n    featureNode,\n    \"phoneNumber\",\n    namespaces.kml,\n  );\n  kmlData.snippet = queryStringValue(featureNode, \"Snippet\", namespaces.kml);\n\n  processExtendedData(featureNode, entity);\n  processDescription(\n    featureNode,\n    entity,\n    styleEntity,\n    uriResolver,\n    sourceResource,\n  );\n\n  const ellipsoid = dataSource._ellipsoid;\n  processLookAt(featureNode, entity, ellipsoid);\n  processCamera(featureNode, entity, ellipsoid);\n\n  if (defined(queryFirstNode(featureNode, \"Region\", namespaces.kml))) {\n    oneTimeWarning(\"kml-region\", \"KML - Placemark Regions are unsupported\");\n  }\n\n  return {\n    entity: entity,\n    styleEntity: styleEntity,\n  };\n}\n\nfunction processDocument(dataSource, node, processingData, deferredLoading) {\n  deferredLoading.addNodes(node.childNodes, processingData);\n  deferredLoading.process();\n}\n\nfunction processFolder(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const newProcessingData = clone(processingData);\n  newProcessingData.parentEntity = r.entity;\n  processDocument(dataSource, node, newProcessingData, deferredLoading);\n}\n\nfunction processPlacemark(\n  dataSource,\n  placemark,\n  processingData,\n  deferredLoading,\n) {\n  const r = processFeature(dataSource, placemark, processingData);\n  const entity = r.entity;\n  const styleEntity = r.styleEntity;\n\n  let hasGeometry = false;\n  const childNodes = placemark.childNodes;\n  for (let i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      // pass the placemark entity id as a context for case of defining multiple child entities together to handle case\n      // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.\n      geometryProcessor(\n        dataSource,\n        processingData.entityCollection,\n        childNode,\n        entity,\n        styleEntity,\n        entity.id,\n      );\n      hasGeometry = true;\n    }\n  }\n\n  if (!hasGeometry) {\n    entity.merge(styleEntity);\n    processPositionGraphics(dataSource, entity, styleEntity);\n  }\n}\n\nconst playlistNodeProcessors = {\n  FlyTo: processTourFlyTo,\n  Wait: processTourWait,\n  SoundCue: processTourUnsupportedNode,\n  AnimatedUpdate: processTourUnsupportedNode,\n  TourControl: processTourUnsupportedNode,\n};\n\nfunction processTour(dataSource, node, processingData, deferredLoading) {\n  const name = queryStringValue(node, \"name\", namespaces.kml);\n  const id = queryStringAttribute(node, \"id\");\n  const tour = new KmlTour(name, id);\n\n  const playlistNode = queryFirstNode(node, \"Playlist\", namespaces.gx);\n  if (playlistNode) {\n    const ellipsoid = dataSource._ellipsoid;\n    const childNodes = playlistNode.childNodes;\n    for (let i = 0; i < childNodes.length; i++) {\n      const entryNode = childNodes[i];\n      if (entryNode.localName) {\n        const playlistNodeProcessor =\n          playlistNodeProcessors[entryNode.localName];\n        if (playlistNodeProcessor) {\n          playlistNodeProcessor(tour, entryNode, ellipsoid);\n        } else {\n          console.log(\n            `Unknown KML Tour playlist entry type ${entryNode.localName}`,\n          );\n        }\n      }\n    }\n  }\n\n  dataSource._kmlTours.push(tour);\n}\n\nfunction processTourUnsupportedNode(tour, entryNode) {\n  oneTimeWarning(`KML Tour unsupported node ${entryNode.localName}`);\n}\n\nfunction processTourWait(tour, entryNode) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  tour.addPlaylistEntry(new KmlTourWait(duration));\n}\n\nfunction processTourFlyTo(tour, entryNode, ellipsoid) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  const flyToMode = queryStringValue(entryNode, \"flyToMode\", namespaces.gx);\n\n  const t = { kml: {} };\n\n  processLookAt(entryNode, t, ellipsoid);\n  processCamera(entryNode, t, ellipsoid);\n\n  const view = t.kml.lookAt || t.kml.camera;\n\n  const flyto = new KmlTourFlyTo(duration, flyToMode, view);\n  tour.addPlaylistEntry(flyto);\n}\n\nfunction processCamera(featureNode, entity, ellipsoid) {\n  const camera = queryFirstNode(featureNode, \"Camera\", namespaces.kml);\n  if (defined(camera)) {\n    const lon = defaultValue(\n      queryNumericValue(camera, \"longitude\", namespaces.kml),\n      0.0,\n    );\n    const lat = defaultValue(\n      queryNumericValue(camera, \"latitude\", namespaces.kml),\n      0.0,\n    );\n    const altitude = defaultValue(\n      queryNumericValue(camera, \"altitude\", namespaces.kml),\n      0.0,\n    );\n\n    const heading = defaultValue(\n      queryNumericValue(camera, \"heading\", namespaces.kml),\n      0.0,\n    );\n    const tilt = defaultValue(\n      queryNumericValue(camera, \"tilt\", namespaces.kml),\n      0.0,\n    );\n    const roll = defaultValue(\n      queryNumericValue(camera, \"roll\", namespaces.kml),\n      0.0,\n    );\n\n    const position = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n    const hpr = HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);\n\n    entity.kml.camera = new KmlCamera(position, hpr);\n  }\n}\n\nfunction processLookAt(featureNode, entity, ellipsoid) {\n  const lookAt = queryFirstNode(featureNode, \"LookAt\", namespaces.kml);\n  if (defined(lookAt)) {\n    const lon = defaultValue(\n      queryNumericValue(lookAt, \"longitude\", namespaces.kml),\n      0.0,\n    );\n    const lat = defaultValue(\n      queryNumericValue(lookAt, \"latitude\", namespaces.kml),\n      0.0,\n    );\n    const altitude = defaultValue(\n      queryNumericValue(lookAt, \"altitude\", namespaces.kml),\n      0.0,\n    );\n    let heading = queryNumericValue(lookAt, \"heading\", namespaces.kml);\n    let tilt = queryNumericValue(lookAt, \"tilt\", namespaces.kml);\n    const range = defaultValue(\n      queryNumericValue(lookAt, \"range\", namespaces.kml),\n      0.0,\n    );\n\n    tilt = CesiumMath.toRadians(defaultValue(tilt, 0.0));\n    heading = CesiumMath.toRadians(defaultValue(heading, 0.0));\n\n    const hpr = new HeadingPitchRange(\n      heading,\n      tilt - CesiumMath.PI_OVER_TWO,\n      range,\n    );\n    const viewPoint = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n\n    entity.kml.lookAt = new KmlLookAt(viewPoint, hpr);\n  }\n}\n\nfunction processScreenOverlay(\n  dataSource,\n  screenOverlayNode,\n  processingData,\n  deferredLoading,\n) {\n  const screenOverlay = processingData.screenOverlayContainer;\n  if (!defined(screenOverlay)) {\n    return undefined;\n  }\n\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n\n  const iconNode = queryFirstNode(screenOverlayNode, \"Icon\", namespaces.kml);\n  const icon = getIconHref(\n    iconNode,\n    dataSource,\n    sourceResource,\n    uriResolver,\n    false,\n  );\n\n  if (!defined(icon)) {\n    return undefined;\n  }\n\n  const img = document.createElement(\"img\");\n  dataSource._screenOverlays.push(img);\n\n  img.src = icon.url;\n  img.onload = function () {\n    const styles = [\"position: absolute\"];\n\n    const screenXY = queryFirstNode(\n      screenOverlayNode,\n      \"screenXY\",\n      namespaces.kml,\n    );\n    const overlayXY = queryFirstNode(\n      screenOverlayNode,\n      \"overlayXY\",\n      namespaces.kml,\n    );\n    const size = queryFirstNode(screenOverlayNode, \"size\", namespaces.kml);\n\n    let x, y;\n    let xUnit, yUnit;\n    let xStyle, yStyle;\n\n    if (defined(size)) {\n      x = queryNumericAttribute(size, \"x\");\n      y = queryNumericAttribute(size, \"y\");\n      xUnit = queryStringAttribute(size, \"xunits\");\n      yUnit = queryStringAttribute(size, \"yunits\");\n\n      if (defined(x) && x !== -1 && x !== 0) {\n        if (xUnit === \"fraction\") {\n          xStyle = `width: ${Math.floor(x * 100)}%`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `width: ${x}px`;\n        }\n\n        styles.push(xStyle);\n      }\n\n      if (defined(y) && y !== -1 && y !== 0) {\n        if (yUnit === \"fraction\") {\n          yStyle = `height: ${Math.floor(y * 100)}%`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `height: ${y}px`;\n        }\n\n        styles.push(yStyle);\n      }\n    }\n\n    // set the interim style so the width/height properties get calculated\n    img.style = styles.join(\";\");\n\n    let xOrigin = 0;\n    let yOrigin = img.height;\n\n    if (defined(overlayXY)) {\n      x = queryNumericAttribute(overlayXY, \"x\");\n      y = queryNumericAttribute(overlayXY, \"y\");\n      xUnit = queryStringAttribute(overlayXY, \"xunits\");\n      yUnit = queryStringAttribute(overlayXY, \"yunits\");\n\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xOrigin = x * img.width;\n        } else if (xUnit === \"pixels\") {\n          xOrigin = x;\n        } else if (xUnit === \"insetPixels\") {\n          xOrigin = x;\n        }\n      }\n\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yOrigin = y * img.height;\n        } else if (yUnit === \"pixels\") {\n          yOrigin = y;\n        } else if (yUnit === \"insetPixels\") {\n          yOrigin = y;\n        }\n      }\n    }\n\n    if (defined(screenXY)) {\n      x = queryNumericAttribute(screenXY, \"x\");\n      y = queryNumericAttribute(screenXY, \"y\");\n      xUnit = queryStringAttribute(screenXY, \"xunits\");\n      yUnit = queryStringAttribute(screenXY, \"yunits\");\n\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xStyle = `${\"left: \" + \"calc(\"}${Math.floor(\n            x * 100,\n          )}% - ${xOrigin}px)`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `left: ${x - xOrigin}px`;\n        } else if (xUnit === \"insetPixels\") {\n          xStyle = `right: ${x - xOrigin}px`;\n        }\n\n        styles.push(xStyle);\n      }\n\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yStyle = `${\"bottom: \" + \"calc(\"}${Math.floor(\n            y * 100,\n          )}% - ${yOrigin}px)`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `bottom: ${y - yOrigin}px`;\n        } else if (yUnit === \"insetPixels\") {\n          yStyle = `top: ${y - yOrigin}px`;\n        }\n\n        styles.push(yStyle);\n      }\n    }\n\n    img.style = styles.join(\";\");\n  };\n\n  screenOverlay.appendChild(img);\n}\n\nfunction processGroundOverlay(\n  dataSource,\n  groundOverlay,\n  processingData,\n  deferredLoading,\n) {\n  const r = processFeature(dataSource, groundOverlay, processingData);\n  const entity = r.entity;\n\n  let geometry;\n  let isLatLonQuad = false;\n\n  const ellipsoid = dataSource._ellipsoid;\n  const positions = readCoordinates(\n    queryFirstNode(groundOverlay, \"LatLonQuad\", namespaces.gx),\n    ellipsoid,\n  );\n  const zIndex = queryNumericValue(groundOverlay, \"drawOrder\", namespaces.kml);\n  if (defined(positions)) {\n    geometry = createDefaultPolygon();\n    geometry.hierarchy = new PolygonHierarchy(positions);\n    geometry.zIndex = zIndex;\n    entity.polygon = geometry;\n    isLatLonQuad = true;\n  } else {\n    geometry = new RectangleGraphics();\n    geometry.zIndex = zIndex;\n    entity.rectangle = geometry;\n\n    const latLonBox = queryFirstNode(\n      groundOverlay,\n      \"LatLonBox\",\n      namespaces.kml,\n    );\n    if (defined(latLonBox)) {\n      let west = queryNumericValue(latLonBox, \"west\", namespaces.kml);\n      let south = queryNumericValue(latLonBox, \"south\", namespaces.kml);\n      let east = queryNumericValue(latLonBox, \"east\", namespaces.kml);\n      let north = queryNumericValue(latLonBox, \"north\", namespaces.kml);\n\n      if (defined(west)) {\n        west = CesiumMath.negativePiToPi(CesiumMath.toRadians(west));\n      }\n      if (defined(south)) {\n        south = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(south));\n      }\n      if (defined(east)) {\n        east = CesiumMath.negativePiToPi(CesiumMath.toRadians(east));\n      }\n      if (defined(north)) {\n        north = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(north));\n      }\n      geometry.coordinates = new Rectangle(west, south, east, north);\n\n      const rotation = queryNumericValue(latLonBox, \"rotation\", namespaces.kml);\n      if (defined(rotation)) {\n        const rotationRadians = CesiumMath.toRadians(rotation);\n        geometry.rotation = rotationRadians;\n        geometry.stRotation = rotationRadians;\n      }\n    }\n  }\n\n  const iconNode = queryFirstNode(groundOverlay, \"Icon\", namespaces.kml);\n  const href = getIconHref(\n    iconNode,\n    dataSource,\n    processingData.sourceResource,\n    processingData.uriResolver,\n    true,\n  );\n  if (defined(href)) {\n    if (isLatLonQuad) {\n      oneTimeWarning(\n        \"kml-gx:LatLonQuad\",\n        \"KML - gx:LatLonQuad Icon does not support texture projection.\",\n      );\n    }\n    const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n    const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n    const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n    const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n\n    if (defined(x) || defined(y) || defined(w) || defined(h)) {\n      oneTimeWarning(\n        \"kml-groundOverlay-xywh\",\n        \"KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays\",\n      );\n    }\n\n    geometry.material = href;\n    geometry.material.color = queryColorValue(\n      groundOverlay,\n      \"color\",\n      namespaces.kml,\n    );\n    geometry.material.transparent = true;\n  } else {\n    geometry.material = queryColorValue(groundOverlay, \"color\", namespaces.kml);\n  }\n\n  let altitudeMode = queryStringValue(\n    groundOverlay,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n\n  if (defined(altitudeMode)) {\n    if (altitudeMode === \"absolute\") {\n      //Use height above ellipsoid until we support MSL.\n      geometry.height = queryNumericValue(\n        groundOverlay,\n        \"altitude\",\n        namespaces.kml,\n      );\n      geometry.zIndex = undefined;\n    } else if (altitudeMode !== \"clampToGround\") {\n      oneTimeWarning(\n        \"kml-altitudeMode-unknown\",\n        `KML - Unknown altitudeMode: ${altitudeMode}`,\n      );\n    }\n    // else just use the default of 0 until we support 'clampToGround'\n  } else {\n    altitudeMode = queryStringValue(\n      groundOverlay,\n      \"altitudeMode\",\n      namespaces.gx,\n    );\n    if (altitudeMode === \"relativeToSeaFloor\") {\n      oneTimeWarning(\n        \"kml-altitudeMode-relativeToSeaFloor\",\n        \"KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute.\",\n      );\n      geometry.height = queryNumericValue(\n        groundOverlay,\n        \"altitude\",\n        namespaces.kml,\n      );\n      geometry.zIndex = undefined;\n    } else if (altitudeMode === \"clampToSeaFloor\") {\n      oneTimeWarning(\n        \"kml-altitudeMode-clampToSeaFloor\",\n        \"KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.\",\n      );\n    } else if (defined(altitudeMode)) {\n      oneTimeWarning(\n        \"kml-altitudeMode-unknown\",\n        `KML - Unknown altitudeMode: ${altitudeMode}`,\n      );\n    }\n  }\n}\n\nfunction processUnsupportedFeature(\n  dataSource,\n  node,\n  processingData,\n  deferredLoading,\n) {\n  dataSource._unsupportedNode.raiseEvent(\n    dataSource,\n    processingData.parentEntity,\n    node,\n    processingData.entityCollection,\n    processingData.styleCollection,\n    processingData.sourceResource,\n    processingData.uriResolver,\n  );\n  oneTimeWarning(\n    `kml-unsupportedFeature-${node.nodeName}`,\n    `KML - Unsupported feature: ${node.nodeName}`,\n  );\n}\n\nconst RefreshMode = {\n  INTERVAL: 0,\n  EXPIRE: 1,\n  STOP: 2,\n};\n\nfunction cleanupString(s) {\n  if (!defined(s) || s.length === 0) {\n    return \"\";\n  }\n\n  const sFirst = s[0];\n  if (sFirst === \"&\" || sFirst === \"?\") {\n    s = s.substring(1);\n  }\n\n  return s;\n}\n\nconst zeroRectangle = new Rectangle();\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian2 = new Cartesian2();\nconst scratchCartesian3 = new Cartesian3();\n\nfunction processNetworkLinkQueryString(\n  resource,\n  camera,\n  canvas,\n  viewBoundScale,\n  bbox,\n  ellipsoid,\n) {\n  function fixLatitude(value) {\n    if (value < -CesiumMath.PI_OVER_TWO) {\n      return -CesiumMath.PI_OVER_TWO;\n    } else if (value > CesiumMath.PI_OVER_TWO) {\n      return CesiumMath.PI_OVER_TWO;\n    }\n    return value;\n  }\n\n  function fixLongitude(value) {\n    if (value > CesiumMath.PI) {\n      return value - CesiumMath.TWO_PI;\n    } else if (value < -CesiumMath.PI) {\n      return value + CesiumMath.TWO_PI;\n    }\n\n    return value;\n  }\n\n  let queryString = objectToQuery(resource.queryParameters);\n\n  // objectToQuery escapes [ and ], so fix that\n  queryString = queryString.replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n\n  if (defined(camera) && camera._mode !== SceneMode.MORPHING) {\n    let centerCartesian;\n    let centerCartographic;\n\n    bbox = defaultValue(bbox, zeroRectangle);\n    if (defined(canvas)) {\n      scratchCartesian2.x = canvas.clientWidth * 0.5;\n      scratchCartesian2.y = canvas.clientHeight * 0.5;\n      centerCartesian = camera.pickEllipsoid(\n        scratchCartesian2,\n        ellipsoid,\n        scratchCartesian3,\n      );\n    }\n\n    if (defined(centerCartesian)) {\n      centerCartographic = ellipsoid.cartesianToCartographic(\n        centerCartesian,\n        scratchCartographic,\n      );\n    } else {\n      centerCartographic = Rectangle.center(bbox, scratchCartographic);\n      centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);\n    }\n\n    if (\n      defined(viewBoundScale) &&\n      !CesiumMath.equalsEpsilon(viewBoundScale, 1.0, CesiumMath.EPSILON9)\n    ) {\n      const newHalfWidth = bbox.width * viewBoundScale * 0.5;\n      const newHalfHeight = bbox.height * viewBoundScale * 0.5;\n      bbox = new Rectangle(\n        fixLongitude(centerCartographic.longitude - newHalfWidth),\n        fixLatitude(centerCartographic.latitude - newHalfHeight),\n        fixLongitude(centerCartographic.longitude + newHalfWidth),\n        fixLatitude(centerCartographic.latitude + newHalfHeight),\n      );\n    }\n\n    queryString = queryString.replace(\n      \"[bboxWest]\",\n      CesiumMath.toDegrees(bbox.west).toString(),\n    );\n    queryString = queryString.replace(\n      \"[bboxSouth]\",\n      CesiumMath.toDegrees(bbox.south).toString(),\n    );\n    queryString = queryString.replace(\n      \"[bboxEast]\",\n      CesiumMath.toDegrees(bbox.east).toString(),\n    );\n    queryString = queryString.replace(\n      \"[bboxNorth]\",\n      CesiumMath.toDegrees(bbox.north).toString(),\n    );\n\n    const lon = CesiumMath.toDegrees(centerCartographic.longitude).toString();\n    const lat = CesiumMath.toDegrees(centerCartographic.latitude).toString();\n    queryString = queryString.replace(\"[lookatLon]\", lon);\n    queryString = queryString.replace(\"[lookatLat]\", lat);\n    queryString = queryString.replace(\n      \"[lookatTilt]\",\n      CesiumMath.toDegrees(camera.pitch).toString(),\n    );\n    queryString = queryString.replace(\n      \"[lookatHeading]\",\n      CesiumMath.toDegrees(camera.heading).toString(),\n    );\n    queryString = queryString.replace(\n      \"[lookatRange]\",\n      Cartesian3.distance(camera.positionWC, centerCartesian),\n    );\n    queryString = queryString.replace(\"[lookatTerrainLon]\", lon);\n    queryString = queryString.replace(\"[lookatTerrainLat]\", lat);\n    queryString = queryString.replace(\n      \"[lookatTerrainAlt]\",\n      centerCartographic.height.toString(),\n    );\n\n    ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);\n    queryString = queryString.replace(\n      \"[cameraLon]\",\n      CesiumMath.toDegrees(scratchCartographic.longitude).toString(),\n    );\n    queryString = queryString.replace(\n      \"[cameraLat]\",\n      CesiumMath.toDegrees(scratchCartographic.latitude).toString(),\n    );\n    queryString = queryString.replace(\n      \"[cameraAlt]\",\n      CesiumMath.toDegrees(scratchCartographic.height).toString(),\n    );\n\n    const frustum = camera.frustum;\n    const aspectRatio = frustum.aspectRatio;\n    let horizFov = \"\";\n    let vertFov = \"\";\n    if (defined(aspectRatio)) {\n      const fov = CesiumMath.toDegrees(frustum.fov);\n      if (aspectRatio > 1.0) {\n        horizFov = fov;\n        vertFov = fov / aspectRatio;\n      } else {\n        vertFov = fov;\n        horizFov = fov * aspectRatio;\n      }\n    }\n    queryString = queryString.replace(\"[horizFov]\", horizFov.toString());\n    queryString = queryString.replace(\"[vertFov]\", vertFov.toString());\n  } else {\n    queryString = queryString.replace(\"[bboxWest]\", \"-180\");\n    queryString = queryString.replace(\"[bboxSouth]\", \"-90\");\n    queryString = queryString.replace(\"[bboxEast]\", \"180\");\n    queryString = queryString.replace(\"[bboxNorth]\", \"90\");\n\n    queryString = queryString.replace(\"[lookatLon]\", \"\");\n    queryString = queryString.replace(\"[lookatLat]\", \"\");\n    queryString = queryString.replace(\"[lookatRange]\", \"\");\n    queryString = queryString.replace(\"[lookatTilt]\", \"\");\n    queryString = queryString.replace(\"[lookatHeading]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLon]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLat]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainAlt]\", \"\");\n\n    queryString = queryString.replace(\"[cameraLon]\", \"\");\n    queryString = queryString.replace(\"[cameraLat]\", \"\");\n    queryString = queryString.replace(\"[cameraAlt]\", \"\");\n    queryString = queryString.replace(\"[horizFov]\", \"\");\n    queryString = queryString.replace(\"[vertFov]\", \"\");\n  }\n\n  if (defined(canvas)) {\n    queryString = queryString.replace(\"[horizPixels]\", canvas.clientWidth);\n    queryString = queryString.replace(\"[vertPixels]\", canvas.clientHeight);\n  } else {\n    queryString = queryString.replace(\"[horizPixels]\", \"\");\n    queryString = queryString.replace(\"[vertPixels]\", \"\");\n  }\n\n  queryString = queryString.replace(\"[terrainEnabled]\", \"1\");\n  queryString = queryString.replace(\"[clientVersion]\", \"1\");\n  queryString = queryString.replace(\"[kmlVersion]\", \"2.2\");\n  queryString = queryString.replace(\"[clientName]\", \"Cesium\");\n  queryString = queryString.replace(\"[language]\", \"English\");\n\n  resource.setQueryParameters(queryToObject(queryString));\n}\n\nfunction processNetworkLink(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const networkEntity = r.entity;\n\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n\n  let link = queryFirstNode(node, \"Link\", namespaces.kml);\n\n  if (!defined(link)) {\n    link = queryFirstNode(node, \"Url\", namespaces.kml);\n  }\n  if (defined(link)) {\n    let href = queryStringValue(link, \"href\", namespaces.kml);\n    let viewRefreshMode;\n    let viewBoundScale;\n    if (defined(href)) {\n      let newSourceUri = href;\n      href = resolveHref(href, sourceResource, processingData.uriResolver);\n\n      // We need to pass in the original path if resolveHref returns a data uri because the network link\n      //  references a document in a KMZ archive\n      if (/^data:/.test(href.getUrlComponent())) {\n        // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it\n        if (!/\\.kmz/i.test(sourceResource.getUrlComponent())) {\n          newSourceUri = sourceResource.getDerivedResource({\n            url: newSourceUri,\n          });\n        }\n      } else {\n        newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri\n        viewRefreshMode = queryStringValue(\n          link,\n          \"viewRefreshMode\",\n          namespaces.kml,\n        );\n        if (viewRefreshMode === \"onRegion\") {\n          oneTimeWarning(\n            \"kml-refrehMode-onRegion\",\n            \"KML - Unsupported viewRefreshMode: onRegion\",\n          );\n          return;\n        }\n        viewBoundScale = defaultValue(\n          queryStringValue(link, \"viewBoundScale\", namespaces.kml),\n          1.0,\n        );\n        const defaultViewFormat =\n          viewRefreshMode === \"onStop\"\n            ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\"\n            : \"\";\n        const viewFormat = defaultValue(\n          queryStringValue(link, \"viewFormat\", namespaces.kml),\n          defaultViewFormat,\n        );\n        const httpQuery = queryStringValue(link, \"httpQuery\", namespaces.kml);\n        if (defined(viewFormat)) {\n          href.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n        }\n        if (defined(httpQuery)) {\n          href.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n        }\n\n        const ellipsoid = dataSource._ellipsoid;\n        processNetworkLinkQueryString(\n          href,\n          dataSource.camera,\n          dataSource.canvas,\n          viewBoundScale,\n          dataSource._lastCameraView.bbox,\n          ellipsoid,\n        );\n      }\n\n      const options = {\n        sourceUri: newSourceUri,\n        uriResolver: uriResolver,\n        context: networkEntity.id,\n        screenOverlayContainer: processingData.screenOverlayContainer,\n      };\n      const networkLinkCollection = new EntityCollection();\n      const promise = load(dataSource, networkLinkCollection, href, options)\n        .then(function (rootElement) {\n          const entities = dataSource._entityCollection;\n          const newEntities = networkLinkCollection.values;\n          entities.suspendEvents();\n          for (let i = 0; i < newEntities.length; i++) {\n            const newEntity = newEntities[i];\n            if (!defined(newEntity.parent)) {\n              newEntity.parent = networkEntity;\n              mergeAvailabilityWithParent(newEntity);\n            }\n\n            entities.add(newEntity);\n          }\n          entities.resumeEvents();\n\n          // Add network links to a list if we need they will need to be updated\n          const refreshMode = queryStringValue(\n            link,\n            \"refreshMode\",\n            namespaces.kml,\n          );\n          let refreshInterval = defaultValue(\n            queryNumericValue(link, \"refreshInterval\", namespaces.kml),\n            0,\n          );\n          if (\n            (refreshMode === \"onInterval\" && refreshInterval > 0) ||\n            refreshMode === \"onExpire\" ||\n            viewRefreshMode === \"onStop\"\n          ) {\n            const networkLinkControl = queryFirstNode(\n              rootElement,\n              \"NetworkLinkControl\",\n              namespaces.kml,\n            );\n            const hasNetworkLinkControl = defined(networkLinkControl);\n\n            const now = JulianDate.now();\n            const networkLinkInfo = {\n              id: createGuid(),\n              href: href,\n              cookie: {},\n              lastUpdated: now,\n              updating: false,\n              entity: networkEntity,\n              viewBoundScale: viewBoundScale,\n              needsUpdate: false,\n              cameraUpdateTime: now,\n            };\n\n            let minRefreshPeriod = 0;\n            if (hasNetworkLinkControl) {\n              networkLinkInfo.cookie = queryToObject(\n                defaultValue(\n                  queryStringValue(\n                    networkLinkControl,\n                    \"cookie\",\n                    namespaces.kml,\n                  ),\n                  \"\",\n                ),\n              );\n              minRefreshPeriod = defaultValue(\n                queryNumericValue(\n                  networkLinkControl,\n                  \"minRefreshPeriod\",\n                  namespaces.kml,\n                ),\n                0,\n              );\n            }\n\n            if (refreshMode === \"onInterval\") {\n              if (hasNetworkLinkControl) {\n                refreshInterval = Math.max(minRefreshPeriod, refreshInterval);\n              }\n              networkLinkInfo.refreshMode = RefreshMode.INTERVAL;\n              networkLinkInfo.time = refreshInterval;\n            } else if (refreshMode === \"onExpire\") {\n              let expires;\n              if (hasNetworkLinkControl) {\n                expires = queryStringValue(\n                  networkLinkControl,\n                  \"expires\",\n                  namespaces.kml,\n                );\n              }\n              if (defined(expires)) {\n                try {\n                  const date = JulianDate.fromIso8601(expires);\n                  const diff = JulianDate.secondsDifference(date, now);\n                  if (diff > 0 && diff < minRefreshPeriod) {\n                    JulianDate.addSeconds(now, minRefreshPeriod, date);\n                  }\n                  networkLinkInfo.refreshMode = RefreshMode.EXPIRE;\n                  networkLinkInfo.time = date;\n                } catch (e) {\n                  oneTimeWarning(\n                    \"kml-refreshMode-onInterval-onExpire\",\n                    \"KML - NetworkLinkControl expires is not a valid date\",\n                  );\n                }\n              } else {\n                oneTimeWarning(\n                  \"kml-refreshMode-onExpire\",\n                  \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\",\n                );\n              }\n            } else if (defined(dataSource.camera)) {\n              // Only allow onStop refreshes if we have a camera\n              networkLinkInfo.refreshMode = RefreshMode.STOP;\n              networkLinkInfo.time = defaultValue(\n                queryNumericValue(link, \"viewRefreshTime\", namespaces.kml),\n                0,\n              );\n            } else {\n              oneTimeWarning(\n                \"kml-refrehMode-onStop-noCamera\",\n                \"A NetworkLink with viewRefreshMode=onStop requires the `camera` property to be defined.\",\n              );\n            }\n\n            if (defined(networkLinkInfo.refreshMode)) {\n              dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);\n            }\n          }\n        })\n        .catch(function (error) {\n          oneTimeWarning(`An error occured during loading ${href.url}`);\n          dataSource._error.raiseEvent(dataSource, error);\n        });\n\n      deferredLoading.addPromise(promise);\n    }\n  }\n}\n\nfunction processFeatureNode(dataSource, node, processingData, deferredLoading) {\n  const featureProcessor = featureTypes[node.localName];\n  if (defined(featureProcessor)) {\n    return featureProcessor(dataSource, node, processingData, deferredLoading);\n  }\n\n  return processUnsupportedFeature(\n    dataSource,\n    node,\n    processingData,\n    deferredLoading,\n  );\n}\n\nfunction loadKml(\n  dataSource,\n  entityCollection,\n  kml,\n  sourceResource,\n  uriResolver,\n  screenOverlayContainer,\n  context,\n) {\n  entityCollection.removeAll();\n\n  const documentElement = kml.documentElement;\n  const document =\n    documentElement.localName === \"Document\"\n      ? documentElement\n      : queryFirstNode(documentElement, \"Document\", namespaces.kml);\n  let name = queryStringValue(document, \"name\", namespaces.kml);\n  if (!defined(name)) {\n    name = getFilenameFromUri(sourceResource.getUrlComponent());\n  }\n\n  // Only set the name from the root document\n  if (!defined(dataSource._name)) {\n    dataSource._name = name;\n  }\n\n  const deferredLoading = new KmlDataSource._DeferredLoading(dataSource);\n  const styleCollection = new EntityCollection(dataSource);\n  return Promise.all(\n    processStyles(\n      dataSource,\n      kml,\n      styleCollection,\n      sourceResource,\n      false,\n      uriResolver,\n    ),\n  ).then(function () {\n    let element = kml.documentElement;\n    if (element.localName === \"kml\") {\n      const childNodes = element.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const tmp = childNodes[i];\n        if (defined(featureTypes[tmp.localName])) {\n          element = tmp;\n          break;\n        }\n      }\n    }\n\n    const processingData = {\n      parentEntity: undefined,\n      entityCollection: entityCollection,\n      styleCollection: styleCollection,\n      sourceResource: sourceResource,\n      uriResolver: uriResolver,\n      context: context,\n      screenOverlayContainer: screenOverlayContainer,\n    };\n\n    entityCollection.suspendEvents();\n    processFeatureNode(dataSource, element, processingData, deferredLoading);\n    entityCollection.resumeEvents();\n\n    return deferredLoading.wait().then(function () {\n      return kml.documentElement;\n    });\n  });\n}\n\nfunction loadKmz(\n  dataSource,\n  entityCollection,\n  blob,\n  sourceResource,\n  screenOverlayContainer,\n) {\n  const zWorkerUrl = buildModuleUrl(\"ThirdParty/Workers/z-worker-pako.js\");\n  zip.configure({\n    workerScripts: {\n      deflate: [zWorkerUrl, \"./pako_deflate.min.js\"],\n      inflate: [zWorkerUrl, \"./pako_inflate.min.js\"],\n    },\n  });\n\n  const reader = new zip.ZipReader(new zip.BlobReader(blob));\n  return Promise.resolve(reader.getEntries()).then(function (entries) {\n    const promises = [];\n    const uriResolver = {};\n    let docEntry;\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      if (!entry.directory) {\n        if (/\\.kml$/i.test(entry.filename)) {\n          // We use the first KML document we come across\n          //  https://developers.google.com/kml/documentation/kmzarchives\n          // Unless we come across a .kml file at the root of the archive because GE does this\n          if (!defined(docEntry) || !/\\//i.test(entry.filename)) {\n            if (defined(docEntry)) {\n              // We found one at the root so load the initial kml as a data uri\n              promises.push(loadDataUriFromZip(docEntry, uriResolver));\n            }\n            docEntry = entry;\n          } else {\n            // Wasn't the first kml and wasn't at the root\n            promises.push(loadDataUriFromZip(entry, uriResolver));\n          }\n        } else {\n          promises.push(loadDataUriFromZip(entry, uriResolver));\n        }\n      }\n    }\n\n    // Now load the root KML document\n    if (defined(docEntry)) {\n      promises.push(loadXmlFromZip(docEntry, uriResolver));\n    }\n    return Promise.all(promises).then(function () {\n      reader.close();\n      if (!defined(uriResolver.kml)) {\n        throw new RuntimeError(\"KMZ file does not contain a KML document.\");\n      }\n      uriResolver.keys = Object.keys(uriResolver);\n      return loadKml(\n        dataSource,\n        entityCollection,\n        uriResolver.kml,\n        sourceResource,\n        uriResolver,\n        screenOverlayContainer,\n      );\n    });\n  });\n}\n\nfunction load(dataSource, entityCollection, data, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let sourceUri = options.sourceUri;\n  const uriResolver = options.uriResolver;\n  const context = options.context;\n  let screenOverlayContainer = options.screenOverlayContainer;\n\n  let promise = data;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchBlob();\n    sourceUri = defaultValue(sourceUri, data.clone());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  } else {\n    sourceUri = defaultValue(sourceUri, Resource.DEFAULT.clone());\n  }\n\n  sourceUri = Resource.createIfNeeded(sourceUri);\n\n  if (defined(screenOverlayContainer)) {\n    screenOverlayContainer = getElement(screenOverlayContainer);\n  }\n\n  return Promise.resolve(promise)\n    .then(function (dataToLoad) {\n      if (dataToLoad instanceof Blob) {\n        return isZipFile(dataToLoad).then(function (isZip) {\n          if (isZip) {\n            return loadKmz(\n              dataSource,\n              entityCollection,\n              dataToLoad,\n              sourceUri,\n              screenOverlayContainer,\n            );\n          }\n          return readBlobAsText(dataToLoad).then(function (text) {\n            //There's no official way to validate if a parse was successful.\n            //The following check detects the error on various browsers.\n\n            //Insert missing namespaces\n            text = insertNamespaces(text);\n\n            //Remove Duplicate Namespaces\n            text = removeDuplicateNamespaces(text);\n\n            //IE raises an exception\n            let kml;\n            let error;\n            try {\n              kml = parser.parseFromString(text, \"application/xml\");\n            } catch (e) {\n              error = e.toString();\n            }\n\n            //The parse succeeds on Chrome and Firefox, but the error\n            //handling is different in each.\n            if (\n              defined(error) ||\n              kml.body ||\n              kml.documentElement.tagName === \"parsererror\"\n            ) {\n              //Firefox has error information as the firstChild nodeValue.\n              let msg = defined(error)\n                ? error\n                : kml.documentElement.firstChild.nodeValue;\n\n              //Chrome has it in the body text.\n              if (!msg) {\n                msg = kml.body.innerText;\n              }\n\n              //Return the error\n              throw new RuntimeError(msg);\n            }\n            return loadKml(\n              dataSource,\n              entityCollection,\n              kml,\n              sourceUri,\n              uriResolver,\n              screenOverlayContainer,\n              context,\n            );\n          });\n        });\n      }\n      return loadKml(\n        dataSource,\n        entityCollection,\n        dataToLoad,\n        sourceUri,\n        uriResolver,\n        screenOverlayContainer,\n        context,\n      );\n    })\n    .catch(function (error) {\n      dataSource._error.raiseEvent(dataSource, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n}\n\n// NOTE: LoadOptions properties are repeated in ConstructorOptions because some\n// tooling does not support \"base types\" for @typedef.  Remove if/when\n// https://github.com/microsoft/TypeScript/issues/20077 and/or\n// https://github.com/jsdoc/jsdoc/issues/1199 actually get resolved\n/**\n * @typedef {object} KmlDataSource.LoadOptions\n *\n * Initialization options for the `load` method.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n */\n\n/**\n * @typedef {object} KmlDataSource.ConstructorOptions\n *\n * Options for constructing a new KmlDataSource, or calling the static `load` method.\n *\n * @property {Camera} [camera] The camera that is used for viewRefreshModes and sending camera properties to network links.\n * @property {HTMLCanvasElement} [canvas] The canvas that is used for sending viewer properties to network links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n\n*/\n\n/**\n * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).\n * <p>\n * KML support in Cesium is incomplete, but a large amount of the standard,\n * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue\n * {@link https://github.com/CesiumGS/cesium/issues/873|#873} for a\n * detailed list of what is and isn't supported. Cesium will also write information to the\n * console when it encounters most unsupported features.\n * </p>\n * <p>\n * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>\n * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}\n * under the <code>kml</code> property.\n * </p>\n *\n * @alias KmlDataSource\n * @constructor\n *\n * @param {KmlDataSource.ConstructorOptions} [options] Object describing initialization options\n *\n * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}\n * @see {@link https://developers.google.com/kml/|Google KML Documentation}\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=KML.html|Cesium Sandcastle KML Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n *      {\n *           camera: viewer.scene.camera,\n *           canvas: viewer.scene.canvas\n *      })\n * );\n */\nfunction KmlDataSource(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const camera = options.camera;\n  const canvas = options.canvas;\n\n  this._changed = new Event();\n  this._error = new Event();\n  this._loading = new Event();\n  this._refresh = new Event();\n  this._unsupportedNode = new Event();\n\n  this._clock = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._name = undefined;\n  this._isLoading = false;\n  this._pinBuilder = new PinBuilder();\n  this._networkLinks = new AssociativeArray();\n  this._entityCluster = new EntityCluster();\n\n  /**\n   * The current size of this Canvas will be used to populate the Link parameters\n   * for client height and width.\n   *\n   * @type {HTMLCanvasElement | undefined}\n   */\n  this.canvas = canvas;\n\n  /**\n   * The position and orientation of this {@link Camera} will be used to\n   * populate various camera parameters when making network requests.\n   * Camera movement will determine when to trigger NetworkLink refresh if\n   * <code>viewRefreshMode</code> is <code>onStop</code>.\n   *\n   * @type {Camera | undefined}\n   */\n  this.camera = camera;\n\n  this._lastCameraView = {\n    position: defined(camera) ? Cartesian3.clone(camera.positionWC) : undefined,\n    direction: defined(camera)\n      ? Cartesian3.clone(camera.directionWC)\n      : undefined,\n    up: defined(camera) ? Cartesian3.clone(camera.upWC) : undefined,\n    bbox: defined(camera)\n      ? camera.computeViewRectangle()\n      : Rectangle.clone(Rectangle.MAX_VALUE),\n  };\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Create a list of Credit's from the resource that the user can't remove\n  this._resourceCredits = [];\n\n  this._kmlTours = [];\n\n  this._screenOverlays = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided KML data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.ConstructorOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.\n */\nKmlDataSource.load = function (data, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const dataSource = new KmlDataSource(options);\n  return dataSource.load(data, options);\n};\n\nObject.defineProperties(KmlDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * This will be automatically be set to the KML document name on load.\n   * @memberof KmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets the clock settings defined by the loaded KML. This represents the total\n   * availability interval for all time-dynamic data. If the KML does not contain\n   * time-dynamic data, this value is undefined.\n   * @memberof KmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source refreshes a network link.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  refreshEvent: {\n    get: function () {\n      return this._refresh;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source finds an unsupported node type.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  unsupportedNodeEvent: {\n    get: function () {\n      return this._unsupportedNode;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof KmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n  /**\n   * Gets the KML Tours that are used to guide the camera to specified destinations on given time intervals.\n   * @memberof KmlDataSource.prototype\n   * @type {KmlTour[]}\n   */\n  kmlTours: {\n    get: function () {\n      return this._kmlTours;\n    },\n  },\n});\n\n/**\n * Asynchronously loads the provided KML data, replacing any existing data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.\n */\nKmlDataSource.prototype.load = function (data, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  DataSource.setLoading(this, true);\n\n  const oldName = this._name;\n  this._name = undefined;\n  this._clampToGround = defaultValue(options.clampToGround, false);\n\n  const that = this;\n  return load(this, this._entityCollection, data, options)\n    .then(function () {\n      let clock;\n\n      const availability = that._entityCollection.computeAvailability();\n\n      let start = availability.start;\n      let stop = availability.stop;\n      const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n      const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n      if (!isMinStart || !isMaxStop) {\n        let date;\n\n        //If start is min time just start at midnight this morning, local time\n        if (isMinStart) {\n          date = new Date();\n          date.setHours(0, 0, 0, 0);\n          start = JulianDate.fromDate(date);\n        }\n\n        //If stop is max value just stop at midnight tonight, local time\n        if (isMaxStop) {\n          date = new Date();\n          date.setHours(24, 0, 0, 0);\n          stop = JulianDate.fromDate(date);\n        }\n\n        clock = new DataSourceClock();\n        clock.startTime = start;\n        clock.stopTime = stop;\n        clock.currentTime = JulianDate.clone(start);\n        clock.clockRange = ClockRange.LOOP_STOP;\n        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n        clock.multiplier = Math.round(\n          Math.min(\n            Math.max(JulianDate.secondsDifference(stop, start) / 60, 1),\n            3.15569e7,\n          ),\n        );\n      }\n\n      let changed = false;\n      if (clock !== that._clock) {\n        that._clock = clock;\n        changed = true;\n      }\n\n      if (oldName !== that._name) {\n        changed = true;\n      }\n\n      if (changed) {\n        that._changed.raiseEvent(that);\n      }\n\n      DataSource.setLoading(that, false);\n\n      return that;\n    })\n    .catch(function (error) {\n      DataSource.setLoading(that, false);\n      that._error.raiseEvent(that, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n};\n\n/**\n * Cleans up any non-entity elements created by the data source. Currently this only affects ScreenOverlay elements.\n */\nKmlDataSource.prototype.destroy = function () {\n  while (this._screenOverlays.length > 0) {\n    const elem = this._screenOverlays.pop();\n    elem.remove();\n  }\n};\n\nfunction mergeAvailabilityWithParent(child) {\n  const parent = child.parent;\n  if (defined(parent)) {\n    const parentAvailability = parent.availability;\n    if (defined(parentAvailability)) {\n      const childAvailability = child.availability;\n      if (defined(childAvailability)) {\n        childAvailability.intersect(parentAvailability);\n      } else {\n        child.availability = parentAvailability;\n      }\n    }\n  }\n}\n\nfunction getNetworkLinkUpdateCallback(\n  dataSource,\n  networkLink,\n  newEntityCollection,\n  networkLinks,\n  processedHref,\n) {\n  return function (rootElement) {\n    if (!networkLinks.contains(networkLink.id)) {\n      // Got into the odd case where a parent network link was updated while a child\n      //  network link update was in flight, so just throw it away.\n      return;\n    }\n    let remove = false;\n    const networkLinkControl = queryFirstNode(\n      rootElement,\n      \"NetworkLinkControl\",\n      namespaces.kml,\n    );\n    const hasNetworkLinkControl = defined(networkLinkControl);\n\n    let minRefreshPeriod = 0;\n    if (hasNetworkLinkControl) {\n      if (\n        defined(queryFirstNode(networkLinkControl, \"Update\", namespaces.kml))\n      ) {\n        oneTimeWarning(\n          \"kml-networkLinkControl-update\",\n          \"KML - NetworkLinkControl updates aren't supported.\",\n        );\n        networkLink.updating = false;\n        networkLinks.remove(networkLink.id);\n        return;\n      }\n      networkLink.cookie = queryToObject(\n        defaultValue(\n          queryStringValue(networkLinkControl, \"cookie\", namespaces.kml),\n          \"\",\n        ),\n      );\n      minRefreshPeriod = defaultValue(\n        queryNumericValue(\n          networkLinkControl,\n          \"minRefreshPeriod\",\n          namespaces.kml,\n        ),\n        0,\n      );\n    }\n\n    const now = JulianDate.now();\n    const refreshMode = networkLink.refreshMode;\n    if (refreshMode === RefreshMode.INTERVAL) {\n      if (defined(networkLinkControl)) {\n        networkLink.time = Math.max(minRefreshPeriod, networkLink.time);\n      }\n    } else if (refreshMode === RefreshMode.EXPIRE) {\n      let expires;\n      if (defined(networkLinkControl)) {\n        expires = queryStringValue(\n          networkLinkControl,\n          \"expires\",\n          namespaces.kml,\n        );\n      }\n      if (defined(expires)) {\n        try {\n          const date = JulianDate.fromIso8601(expires);\n          const diff = JulianDate.secondsDifference(date, now);\n          if (diff > 0 && diff < minRefreshPeriod) {\n            JulianDate.addSeconds(now, minRefreshPeriod, date);\n          }\n          networkLink.time = date;\n        } catch (e) {\n          oneTimeWarning(\n            \"kml-networkLinkControl-expires\",\n            \"KML - NetworkLinkControl expires is not a valid date\",\n          );\n          remove = true;\n        }\n      } else {\n        oneTimeWarning(\n          \"kml-refreshMode-onExpire\",\n          \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\",\n        );\n        remove = true;\n      }\n    }\n\n    const networkLinkEntity = networkLink.entity;\n    const entityCollection = dataSource._entityCollection;\n    const newEntities = newEntityCollection.values;\n\n    function removeChildren(entity) {\n      entityCollection.remove(entity);\n      const children = entity._children;\n      const count = children.length;\n      for (let i = 0; i < count; ++i) {\n        removeChildren(children[i]);\n      }\n    }\n\n    // Remove old entities\n    entityCollection.suspendEvents();\n    const entitiesCopy = entityCollection.values.slice();\n    let i;\n    for (i = 0; i < entitiesCopy.length; ++i) {\n      const entityToRemove = entitiesCopy[i];\n      if (entityToRemove.parent === networkLinkEntity) {\n        entityToRemove.parent = undefined;\n        removeChildren(entityToRemove);\n      }\n    }\n    entityCollection.resumeEvents();\n\n    // Add new entities\n    entityCollection.suspendEvents();\n    for (i = 0; i < newEntities.length; i++) {\n      const newEntity = newEntities[i];\n      if (!defined(newEntity.parent)) {\n        newEntity.parent = networkLinkEntity;\n        mergeAvailabilityWithParent(newEntity);\n      }\n      entityCollection.add(newEntity);\n    }\n    entityCollection.resumeEvents();\n\n    // No refresh information remove it, otherwise update lastUpdate time\n    if (remove) {\n      networkLinks.remove(networkLink.id);\n    } else {\n      networkLink.lastUpdated = now;\n    }\n\n    const availability = entityCollection.computeAvailability();\n\n    const start = availability.start;\n    const stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      const clock = dataSource._clock;\n\n      if (clock.startTime !== start || clock.stopTime !== stop) {\n        clock.startTime = start;\n        clock.stopTime = stop;\n        dataSource._changed.raiseEvent(dataSource);\n      }\n    }\n\n    networkLink.updating = false;\n    networkLink.needsUpdate = false;\n    dataSource._refresh.raiseEvent(\n      dataSource,\n      processedHref.getUrlComponent(true),\n    );\n  };\n}\n\nconst entitiesToIgnore = new AssociativeArray();\n\n/**\n * Updates any NetworkLink that require updating.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nKmlDataSource.prototype.update = function (time) {\n  const networkLinks = this._networkLinks;\n  if (networkLinks.length === 0) {\n    return true;\n  }\n\n  const now = JulianDate.now();\n  const that = this;\n\n  entitiesToIgnore.removeAll();\n\n  function recurseIgnoreEntities(entity) {\n    const children = entity._children;\n    const count = children.length;\n    for (let i = 0; i < count; ++i) {\n      const child = children[i];\n      entitiesToIgnore.set(child.id, child);\n      recurseIgnoreEntities(child);\n    }\n  }\n\n  let cameraViewUpdate = false;\n  const lastCameraView = this._lastCameraView;\n  const camera = this.camera;\n  if (\n    defined(camera) &&\n    !(\n      camera.positionWC.equalsEpsilon(\n        lastCameraView.position,\n        CesiumMath.EPSILON7,\n      ) &&\n      camera.directionWC.equalsEpsilon(\n        lastCameraView.direction,\n        CesiumMath.EPSILON7,\n      ) &&\n      camera.upWC.equalsEpsilon(lastCameraView.up, CesiumMath.EPSILON7)\n    )\n  ) {\n    // Camera has changed so update the last view\n    lastCameraView.position = Cartesian3.clone(camera.positionWC);\n    lastCameraView.direction = Cartesian3.clone(camera.directionWC);\n    lastCameraView.up = Cartesian3.clone(camera.upWC);\n    lastCameraView.bbox = camera.computeViewRectangle();\n    cameraViewUpdate = true;\n  }\n\n  const newNetworkLinks = new AssociativeArray();\n  let changed = false;\n  networkLinks.values.forEach(function (networkLink) {\n    const entity = networkLink.entity;\n    if (entitiesToIgnore.contains(entity.id)) {\n      return;\n    }\n\n    if (!networkLink.updating) {\n      let doUpdate = false;\n      if (networkLink.refreshMode === RefreshMode.INTERVAL) {\n        if (\n          JulianDate.secondsDifference(now, networkLink.lastUpdated) >\n          networkLink.time\n        ) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.EXPIRE) {\n        if (JulianDate.greaterThan(now, networkLink.time)) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.STOP) {\n        if (cameraViewUpdate) {\n          networkLink.needsUpdate = true;\n          networkLink.cameraUpdateTime = now;\n        }\n\n        if (\n          networkLink.needsUpdate &&\n          JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >=\n            networkLink.time\n        ) {\n          doUpdate = true;\n        }\n      }\n\n      if (doUpdate) {\n        recurseIgnoreEntities(entity);\n        networkLink.updating = true;\n        const newEntityCollection = new EntityCollection();\n        const href = networkLink.href.clone();\n\n        href.setQueryParameters(networkLink.cookie);\n        const ellipsoid = defaultValue(that._ellipsoid, Ellipsoid.default);\n        processNetworkLinkQueryString(\n          href,\n          that.camera,\n          that.canvas,\n          networkLink.viewBoundScale,\n          lastCameraView.bbox,\n          ellipsoid,\n        );\n\n        load(that, newEntityCollection, href, {\n          context: entity.id,\n        })\n          .then(\n            getNetworkLinkUpdateCallback(\n              that,\n              networkLink,\n              newEntityCollection,\n              newNetworkLinks,\n              href,\n            ),\n          )\n          .catch(function (error) {\n            const msg = `NetworkLink ${networkLink.href} refresh failed: ${error}`;\n            console.log(msg);\n            that._error.raiseEvent(that, msg);\n          });\n        changed = true;\n      }\n    }\n    newNetworkLinks.set(networkLink.id, networkLink);\n  });\n\n  if (changed) {\n    this._networkLinks = newNetworkLinks;\n    this._changed.raiseEvent(this);\n  }\n\n  return true;\n};\n\n/**\n * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.\n * @alias KmlFeatureData\n * @constructor\n */\nfunction KmlFeatureData() {\n  /**\n   * @typedef KmlFeatureData.Author\n   * @type {object}\n   * @property {string} name Gets the name.\n   * @property {string} uri Gets the URI.\n   * @property {number} age Gets the email.\n   */\n\n  /**\n   * Gets the atom syndication format author field.\n   * @type {KmlFeatureData.Author}\n   */\n  this.author = {\n    name: undefined,\n    uri: undefined,\n    email: undefined,\n  };\n\n  /**\n   * @typedef KmlFeatureData.Link\n   * @type {object}\n   * @property {string} href Gets the href.\n   * @property {string} hreflang Gets the language of the linked resource.\n   * @property {string} rel Gets the link relation.\n   * @property {string} type Gets the link type.\n   * @property {string} title Gets the link title.\n   * @property {string} length Gets the link length.\n   */\n\n  /**\n   * Gets the link.\n   * @type {KmlFeatureData.Link}\n   */\n  this.link = {\n    href: undefined,\n    hreflang: undefined,\n    rel: undefined,\n    type: undefined,\n    title: undefined,\n    length: undefined,\n  };\n\n  /**\n   * Gets the unstructured address field.\n   * @type {string}\n   */\n  this.address = undefined;\n  /**\n   * Gets the phone number.\n   * @type {string}\n   */\n  this.phoneNumber = undefined;\n  /**\n   * Gets the snippet.\n   * @type {string}\n   */\n  this.snippet = undefined;\n  /**\n   * Gets the extended data, parsed into a JSON object.\n   * Currently only the <code>Data</code> property is supported.\n   * <code>SchemaData</code> and custom data are ignored.\n   * @type {string}\n   */\n  this.extendedData = undefined;\n}\n\n// For testing\nKmlDataSource._DeferredLoading = DeferredLoading;\nKmlDataSource._getTimestamp = getTimestamp;\n\nexport default KmlDataSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}