{"ast":null,"code":"import defined from \"../Core/defined.js\";\n\n/**\n * A priority queue of tiles to be replaced, if necessary, to make room for new tiles.  The queue\n * is implemented as a linked list.\n *\n * @alias TileReplacementQueue\n * @private\n */\nfunction TileReplacementQueue() {\n  this.head = undefined;\n  this.tail = undefined;\n  this.count = 0;\n  this._lastBeforeStartOfFrame = undefined;\n}\n\n/**\n * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the\n * list were used last frame and must not be unloaded.\n */\nTileReplacementQueue.prototype.markStartOfRenderFrame = function () {\n  this._lastBeforeStartOfFrame = this.head;\n};\n\n/**\n * Reduces the size of the queue to a specified size by unloading the least-recently used\n * tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number\n * of tiles above the specified maximum.\n *\n * @param {number} maximumTiles The maximum number of tiles in the queue.\n */\nTileReplacementQueue.prototype.trimTiles = function (maximumTiles) {\n  let tileToTrim = this.tail;\n  let keepTrimming = true;\n  while (keepTrimming && defined(this._lastBeforeStartOfFrame) && this.count > maximumTiles && defined(tileToTrim)) {\n    // Stop trimming after we process the last tile not used in the\n    // current frame.\n    keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;\n    const previous = tileToTrim.replacementPrevious;\n    if (tileToTrim.eligibleForUnloading) {\n      tileToTrim.freeResources();\n      remove(this, tileToTrim);\n    }\n    tileToTrim = previous;\n  }\n};\nfunction remove(tileReplacementQueue, item) {\n  const previous = item.replacementPrevious;\n  const next = item.replacementNext;\n  if (item === tileReplacementQueue._lastBeforeStartOfFrame) {\n    tileReplacementQueue._lastBeforeStartOfFrame = next;\n  }\n  if (item === tileReplacementQueue.head) {\n    tileReplacementQueue.head = next;\n  } else {\n    previous.replacementNext = next;\n  }\n  if (item === tileReplacementQueue.tail) {\n    tileReplacementQueue.tail = previous;\n  } else {\n    next.replacementPrevious = previous;\n  }\n  item.replacementPrevious = undefined;\n  item.replacementNext = undefined;\n  --tileReplacementQueue.count;\n}\n\n/**\n * Marks a tile as rendered this frame and moves it before the first tile that was not rendered\n * this frame.\n *\n * @param {TileReplacementQueue} item The tile that was rendered.\n */\nTileReplacementQueue.prototype.markTileRendered = function (item) {\n  const head = this.head;\n  if (head === item) {\n    if (item === this._lastBeforeStartOfFrame) {\n      this._lastBeforeStartOfFrame = item.replacementNext;\n    }\n    return;\n  }\n  ++this.count;\n  if (!defined(head)) {\n    // no other tiles in the list\n    item.replacementPrevious = undefined;\n    item.replacementNext = undefined;\n    this.head = item;\n    this.tail = item;\n    return;\n  }\n  if (defined(item.replacementPrevious) || defined(item.replacementNext)) {\n    // tile already in the list, remove from its current location\n    remove(this, item);\n  }\n  item.replacementPrevious = undefined;\n  item.replacementNext = head;\n  head.replacementPrevious = item;\n  this.head = item;\n};\nexport default TileReplacementQueue;","map":{"version":3,"names":["defined","TileReplacementQueue","head","undefined","tail","count","_lastBeforeStartOfFrame","prototype","markStartOfRenderFrame","trimTiles","maximumTiles","tileToTrim","keepTrimming","previous","replacementPrevious","eligibleForUnloading","freeResources","remove","tileReplacementQueue","item","next","replacementNext","markTileRendered"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TileReplacementQueue.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\n\n/**\n * A priority queue of tiles to be replaced, if necessary, to make room for new tiles.  The queue\n * is implemented as a linked list.\n *\n * @alias TileReplacementQueue\n * @private\n */\nfunction TileReplacementQueue() {\n  this.head = undefined;\n  this.tail = undefined;\n  this.count = 0;\n  this._lastBeforeStartOfFrame = undefined;\n}\n\n/**\n * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the\n * list were used last frame and must not be unloaded.\n */\nTileReplacementQueue.prototype.markStartOfRenderFrame = function () {\n  this._lastBeforeStartOfFrame = this.head;\n};\n\n/**\n * Reduces the size of the queue to a specified size by unloading the least-recently used\n * tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number\n * of tiles above the specified maximum.\n *\n * @param {number} maximumTiles The maximum number of tiles in the queue.\n */\nTileReplacementQueue.prototype.trimTiles = function (maximumTiles) {\n  let tileToTrim = this.tail;\n  let keepTrimming = true;\n  while (\n    keepTrimming &&\n    defined(this._lastBeforeStartOfFrame) &&\n    this.count > maximumTiles &&\n    defined(tileToTrim)\n  ) {\n    // Stop trimming after we process the last tile not used in the\n    // current frame.\n    keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;\n\n    const previous = tileToTrim.replacementPrevious;\n\n    if (tileToTrim.eligibleForUnloading) {\n      tileToTrim.freeResources();\n      remove(this, tileToTrim);\n    }\n\n    tileToTrim = previous;\n  }\n};\n\nfunction remove(tileReplacementQueue, item) {\n  const previous = item.replacementPrevious;\n  const next = item.replacementNext;\n\n  if (item === tileReplacementQueue._lastBeforeStartOfFrame) {\n    tileReplacementQueue._lastBeforeStartOfFrame = next;\n  }\n\n  if (item === tileReplacementQueue.head) {\n    tileReplacementQueue.head = next;\n  } else {\n    previous.replacementNext = next;\n  }\n\n  if (item === tileReplacementQueue.tail) {\n    tileReplacementQueue.tail = previous;\n  } else {\n    next.replacementPrevious = previous;\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = undefined;\n\n  --tileReplacementQueue.count;\n}\n\n/**\n * Marks a tile as rendered this frame and moves it before the first tile that was not rendered\n * this frame.\n *\n * @param {TileReplacementQueue} item The tile that was rendered.\n */\nTileReplacementQueue.prototype.markTileRendered = function (item) {\n  const head = this.head;\n  if (head === item) {\n    if (item === this._lastBeforeStartOfFrame) {\n      this._lastBeforeStartOfFrame = item.replacementNext;\n    }\n    return;\n  }\n\n  ++this.count;\n\n  if (!defined(head)) {\n    // no other tiles in the list\n    item.replacementPrevious = undefined;\n    item.replacementNext = undefined;\n    this.head = item;\n    this.tail = item;\n    return;\n  }\n\n  if (defined(item.replacementPrevious) || defined(item.replacementNext)) {\n    // tile already in the list, remove from its current location\n    remove(this, item);\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = head;\n  head.replacementPrevious = item;\n\n  this.head = item;\n};\nexport default TileReplacementQueue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}