{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ClippingPolygonCollection from \"./ClippingPolygonCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.showWaterEffect = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  this.vertexShadowDarkness = 0.3;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this.undergroundColor = undefined;\n  this.undergroundColorAlphaByDistance = undefined;\n  this.lambertDiffuseMultiplier = 0.0;\n  this.materialUniformMap = undefined;\n  this._materialUniformMap = undefined;\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n  this._errorEvent = new Event();\n  this._removeLayerAddedListener = this._imageryLayers.layerAdded.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerAdded, this);\n  this._removeLayerRemovedListener = this._imageryLayers.layerRemoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerRemoved, this);\n  this._removeLayerMovedListener = this._imageryLayers.layerMoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerMoved, this);\n  this._removeLayerShownListener = this._imageryLayers.layerShownOrHidden.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden, this);\n  this._imageryLayersUpdatedEvent = new Event();\n  this._layerOrderChanged = false;\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n  this._vertexArraysToDestroy = [];\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined\n  };\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * A property specifying a {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   * @type {ClippingPolygonCollection}\n   * @private\n   */\n  this._clippingPolygons = undefined;\n\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n  this._oldVerticalExaggeration = undefined;\n  this._oldVerticalExaggerationRelativeHeight = undefined;\n}\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(value, this._firstPassInitialColor);\n    }\n  },\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._quadtree = value;\n    }\n  },\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      if (!defined(this._terrainProvider)) {\n        return undefined;\n      }\n      return this._terrainProvider.tilingScheme;\n    }\n  },\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    }\n  },\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      }\n      this._terrainProvider = terrainProvider;\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    }\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  },\n  /**\n   * The {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   *\n   * @type {ClippingPolygonCollection}\n   *\n   * @private\n   */\n  clippingPolygons: {\n    get: function () {\n      return this._clippingPolygons;\n    },\n    set: function (value) {\n      ClippingPolygonCollection.setOwner(value, this, \"_clippingPolygons\");\n    }\n  }\n});\nfunction sortTileImageryByLayerIndex(a, b) {\n  let aImagery = a.loadingImagery;\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n  let bImagery = b.loadingImagery;\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\nfunction updateCredits(surface, frameState) {\n  const creditDisplay = frameState.creditDisplay;\n  const terrainProvider = surface._terrainProvider;\n  if (defined(terrainProvider) && defined(terrainProvider.credit)) {\n    creditDisplay.addCreditToNextFrame(terrainProvider.credit);\n  }\n  const imageryLayers = surface._imageryLayers;\n  for (let i = 0, len = imageryLayers.length; i < len; ++i) {\n    const layer = imageryLayers.get(i);\n    if (layer.ready && layer.show && defined(layer.imageryProvider.credit)) {\n      creditDisplay.addCreditToNextFrame(layer.imageryProvider.credit);\n    }\n  }\n}\n\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false;\n\n    // Sort the TileImagery instances in each tile by the layer index.\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  }\n\n  // Add credits for terrain and imagery providers.\n  updateCredits(this, frameState);\n  const vertexArraysToDestroy = this._vertexArraysToDestroy;\n  const length = vertexArraysToDestroy.length;\n  for (let j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n  vertexArraysToDestroy.length = 0;\n};\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (let i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    const tiles = tilesToRenderByTextureCount[i];\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  }\n  // update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n\n  // update clipping polygons\n  const clippingPolygons = this._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    clippingPolygons.update(frameState);\n    clippingPolygons.queueCommands(frameState);\n  }\n  this._usedDrawCommands = 0;\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS\n      }\n    });\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL\n      },\n      blending: BlendingState.ALPHA_BLEND\n    });\n    let rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  }\n\n  // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(this, this._quadtree._tilesToRender, frameState, this._vertexArraysToDestroy);\n  }\n\n  // When vertical exaggeration changes, all of the loaded tiles need to generate\n  // geodetic surface normals so they can scale properly when rendered.\n  // When exaggeration is reset, geodetic surface normals are removed to decrease\n  // memory usage. Some tiles might have been constructed with the correct\n  // exaggeration already, so skip over them.\n\n  // If the geodetic surface normals can't be created because the tile doesn't\n  // have a mesh, keep checking until the tile does have a mesh. This can happen\n  // if the tile's mesh starts construction in a worker thread right before the\n  // exaggeration changes.\n\n  const quadtree = this.quadtree;\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n  const exaggerationChanged = this._oldVerticalExaggeration !== exaggeration || this._oldVerticalExaggerationRelativeHeight !== exaggerationRelativeHeight;\n\n  // Keep track of the next time there is a change in exaggeration\n  this._oldVerticalExaggeration = exaggeration;\n  this._oldVerticalExaggerationRelativeHeight = exaggerationRelativeHeight;\n  if (exaggerationChanged) {\n    quadtree.forEachLoadedTile(function (tile) {\n      const surfaceTile = tile.data;\n      surfaceTile.updateExaggeration(tile, frameState, quadtree);\n    });\n  }\n\n  // Add the tile render commands to the command list, sorted by texture count.\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (let textureCountIndex = 0, textureCountLength = tilesToRenderByTextureCount.length; textureCountIndex < textureCountLength; ++textureCountIndex) {\n    const tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n    for (let tileIndex = 0, tileLength = tilesToRender.length; tileIndex < tileLength; ++tileIndex) {\n      const tile = tilesToRender[tileIndex];\n      const tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(frameState.minimumTerrainHeight, tileBoundingRegion.minimumHeight);\n    }\n  }\n};\nfunction pushCommand(command, frameState) {\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  if (globeTranslucencyState.translucent) {\n    const isBlendCommand = command.renderState.blending.enabled;\n    globeTranslucencyState.pushDerivedCommands(command, isBlendCommand, frameState);\n  } else {\n    frameState.commandList.push(command);\n  }\n}\n\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  const drawCommands = this._drawCommands;\n  for (let i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    pushCommand(drawCommands[i], frameState);\n  }\n};\n\n/**\n * Cancels any imagery re-projections in the queue.\n */\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error in meters.\n */\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  if (!defined(this._terrainProvider)) {\n    return 0;\n  }\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n */\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n\n  let surfaceTile = tile.data;\n  let terrainOnly = true;\n  let terrainStateBefore;\n  if (defined(surfaceTile)) {\n    terrainOnly = surfaceTile.boundingVolumeSourceTile !== tile || tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n  GlobeSurfaceTile.processStateMachine(tile, frameState, this.terrainProvider, this._imageryLayers, this.quadtree, this._vertexArraysToDestroy, terrainOnly);\n  surfaceTile = tile.data;\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !== Visibility.NONE && surfaceTile.boundingVolumeSourceTile === tile) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(tile, frameState, this.terrainProvider, this._imageryLayers, this.quadtree, this._vertexArraysToDestroy, terrainOnly);\n    }\n  }\n};\nconst boundingSphereScratch = new BoundingSphere();\nconst rectangleIntersectionScratch = new Rectangle();\nconst splitCartographicLimitRectangleScratch = new Rectangle();\nconst rectangleCenterScratch = new Cartographic();\n\n// cartographicLimitRectangle may span the IDL, but tiles never will.\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n  const splitRectangle = Rectangle.clone(cartographicLimitRectangle, splitCartographicLimitRectangleScratch);\n  const tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n  return splitRectangle;\n}\nfunction isUndergroundVisible(tileProvider, frameState) {\n  if (frameState.cameraUnderground) {\n    return true;\n  }\n  if (frameState.globeTranslucencyState.translucent) {\n    return true;\n  }\n  if (tileProvider.backFaceCulling) {\n    return false;\n  }\n  const clippingPlanes = tileProvider._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    return true;\n  }\n  const clippingPolygons = tileProvider._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    return true;\n  }\n  if (!Rectangle.equals(tileProvider.cartographicLimitRectangle, Rectangle.MAX_VALUE)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} Visibility.NONE if the tile is not visible,\n *                       Visibility.PARTIAL if the tile is partially visible, or\n *                       Visibility.FULL if the tile is fully visible.\n */\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (tile, frameState, occluders) {\n  const distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n  const undergroundVisible = isUndergroundVisible(this, frameState);\n  if (frameState.fog.enabled && !undergroundVisible) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n  const surfaceTile = tile.data;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n  const cullingVolume = frameState.cullingVolume;\n  let boundingVolume = tileBoundingRegion.boundingVolume;\n  if (!defined(boundingVolume)) {\n    boundingVolume = tileBoundingRegion.boundingSphere;\n  }\n\n  // Check if the tile is outside the limit area in cartographic space\n  surfaceTile.clippedByBoundaries = false;\n  const clippedCartographicLimitRectangle = clipRectangleAntimeridian(tile.rectangle, this.cartographicLimitRectangle);\n  const areaLimitIntersection = Rectangle.simpleIntersection(clippedCartographicLimitRectangle, tile.rectangle, rectangleIntersectionScratch);\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, boundingVolume);\n    Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n    if (frameState.mode === SceneMode.MORPHING && defined(surfaceTile.renderedMesh)) {\n      boundingVolume = BoundingSphere.union(tileBoundingRegion.boundingSphere, boundingVolume, boundingVolume);\n    }\n  }\n  if (!defined(boundingVolume)) {\n    return Visibility.PARTIAL;\n  }\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume);\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n  const clippingPolygons = this._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const polygonIntersection = clippingPolygons.computeIntersectionWithBoundingVolume(tileBoundingRegion);\n    tile.isClipped = polygonIntersection !== Intersect.OUTSIDE;\n    // Polygon clipping intersections are determined by outer rectangles, therefore we cannot\n    // preemptively determine if a tile is completely clipped or not here.\n  }\n  let visibility;\n  const intersection = cullingVolume.computeVisibility(boundingVolume);\n  if (intersection === Intersect.OUTSIDE) {\n    visibility = Visibility.NONE;\n  } else if (intersection === Intersect.INTERSECTING) {\n    visibility = Visibility.PARTIAL;\n  } else if (intersection === Intersect.INSIDE) {\n    visibility = Visibility.FULL;\n  }\n  if (visibility === Visibility.NONE) {\n    return visibility;\n  }\n  const ortho3D = frameState.mode === SceneMode.SCENE3D && frameState.camera.frustum instanceof OrthographicFrustum;\n  if (frameState.mode === SceneMode.SCENE3D && !ortho3D && defined(occluders) && !undergroundVisible) {\n    const occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n    if (!defined(occludeePointInScaledSpace)) {\n      return visibility;\n    }\n    if (occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(occludeePointInScaledSpace, tileBoundingRegion.minimumHeight)) {\n      return visibility;\n    }\n    return Visibility.NONE;\n  }\n  return visibility;\n};\n\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n  const childAvailable = this.terrainProvider.getTileDataAvailable(tile.x * 2, tile.y * 2, tile.level + 1);\n  return childAvailable !== undefined;\n};\nconst readyImageryScratch = [];\nconst canRenderTraversalStack = [];\n\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (tile, frameState) {\n  const surfaceTile = tile.data;\n  const readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n  let terrainReady = false;\n  let initialImageryState = false;\n  let imagery;\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY;\n\n    // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n    initialImageryState = true;\n    imagery = surfaceTile.imagery;\n  }\n  let i;\n  let len;\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      const tileImagery = imagery[i];\n      const loadingImagery = tileImagery.loadingImagery;\n      const isReady = !defined(loadingImagery) || loadingImagery.state === ImageryState.FAILED || loadingImagery.state === ImageryState.INVALID;\n      const layerIndex = (tileImagery.loadingImagery || tileImagery.readyImagery).imageryLayer._layerIndex;\n\n      // For a layer to be ready, all tiles belonging to that layer must be ready.\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n  const lastFrame = this.quadtree._lastSelectionFrameNumber;\n\n  // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n  const stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(tile.southwestChild, tile.southeastChild, tile.northwestChild, tile.northeastChild);\n  while (stack.length > 0) {\n    const descendant = stack.pop();\n    const lastFrameSelectionResult = descendant._lastSelectionResultFrame === lastFrame ? descendant._lastSelectionResult : TileSelectionResult.NONE;\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      const descendantSurface = descendant.data;\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n      if (!terrainReady && descendant.data.terrainState === TerrainState.READY) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n      const descendantImagery = descendant.data.imagery;\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        const descendantTileImagery = descendantImagery[i];\n        const descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        const descendantIsReady = !defined(descendantLoadingImagery) || descendantLoadingImagery.state === ImageryState.FAILED || descendantLoadingImagery.state === ImageryState.INVALID;\n        const descendantLayerIndex = (descendantTileImagery.loadingImagery || descendantTileImagery.readyImagery).imageryLayer._layerIndex;\n\n        // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(descendant.southwestChild, descendant.southeastChild, descendant.northwestChild, descendant.northeastChild);\n    }\n  }\n  return true;\n};\nconst tileDirectionScratch = new Cartesian3();\n\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {number} The load priority value.\n */\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (tile, frameState) {\n  const surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n  const obb = surfaceTile.tileBoundingRegion.boundingVolume;\n  if (obb === undefined) {\n    return 0.0;\n  }\n  const cameraPosition = frameState.camera.positionWC;\n  const cameraDirection = frameState.camera.directionWC;\n  const tileDirection = Cartesian3.subtract(obb.center, cameraPosition, tileDirectionScratch);\n  const magnitude = Cartesian3.magnitude(tileDirection);\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance;\n};\nconst modifiedModelViewScratch = new Matrix4();\nconst modifiedModelViewProjectionScratch = new Matrix4();\nconst tileRectangleScratch = new Cartesian4();\nconst localizedCartographicLimitRectangleScratch = new Cartesian4();\nconst localizedTranslucencyRectangleScratch = new Cartesian4();\nconst rtcScratch = new Cartesian3();\nconst centerEyeScratch = new Cartesian3();\nconst southwestScratch = new Cartesian3();\nconst northeastScratch = new Cartesian3();\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (tile, frameState) {\n  let readyTextureCount = 0;\n  const tileImageryCollection = tile.data.imagery;\n  for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (defined(tileImagery.readyImagery) && tileImagery.readyImagery.imageryLayer.alpha !== 0.0) {\n      ++readyTextureCount;\n    }\n  }\n  let tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n  tileSet.push(tile);\n  const surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n  const debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\nconst cornerPositionsScratch = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\nfunction computeOccludeePoint(tileProvider, center, rectangle, minimumHeight, maximumHeight, result) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(rectangle.west, rectangle.south, maximumHeight, ellipsoid, cornerPositions[0]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.south, maximumHeight, ellipsoid, cornerPositions[1]);\n  Cartesian3.fromRadians(rectangle.west, rectangle.north, maximumHeight, ellipsoid, cornerPositions[2]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.north, maximumHeight, ellipsoid, cornerPositions[3]);\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(center, cornerPositions, minimumHeight, result);\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {number} The distance from the camera to the closest point on the tile, in meters.\n */\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (tile, frameState) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based on that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n\n  updateTileBoundingRegion(tile, this, frameState);\n  const surfaceTile = tile.data;\n  const boundingVolumeSourceTile = surfaceTile.boundingVolumeSourceTile;\n  if (boundingVolumeSourceTile === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  }\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const min = tileBoundingRegion.minimumHeight;\n  const max = tileBoundingRegion.maximumHeight;\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    const cameraHeight = frameState.camera.positionCartographic.height;\n    const distanceToMin = Math.abs(cameraHeight - min);\n    const distanceToMax = Math.abs(cameraHeight - max);\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n  const result = tileBoundingRegion.distanceToCamera(frameState);\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n  return result;\n};\nfunction updateTileBoundingRegion(tile, tileProvider, frameState) {\n  let surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0\n    });\n  }\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const oldMinimumHeight = tileBoundingRegion.minimumHeight;\n  const oldMaximumHeight = tileBoundingRegion.maximumHeight;\n  let hasBoundingVolumesFromMesh = false;\n  let sourceTile = tile;\n\n  // Get min and max heights from the mesh.\n  // If the mesh is not available, get them from the terrain data.\n  // If the terrain data is not available either, get them from an ancestor.\n  // If none of the ancestors are available, then there are no min and max heights for this tile at this time.\n  const mesh = surfaceTile.mesh;\n  const terrainData = surfaceTile.terrainData;\n  if (mesh !== undefined && mesh.minimumHeight !== undefined && mesh.maximumHeight !== undefined) {\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    hasBoundingVolumesFromMesh = true;\n  } else if (terrainData !== undefined && terrainData._minimumHeight !== undefined && terrainData._maximumHeight !== undefined) {\n    tileBoundingRegion.minimumHeight = terrainData._minimumHeight;\n    tileBoundingRegion.maximumHeight = terrainData._maximumHeight;\n  } else {\n    // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n    tileBoundingRegion.minimumHeight = Number.NaN;\n    tileBoundingRegion.maximumHeight = Number.NaN;\n    let ancestorTile = tile.parent;\n    while (ancestorTile !== undefined) {\n      const ancestorSurfaceTile = ancestorTile.data;\n      if (ancestorSurfaceTile !== undefined) {\n        const ancestorMesh = ancestorSurfaceTile.mesh;\n        const ancestorTerrainData = ancestorSurfaceTile.terrainData;\n        if (ancestorMesh !== undefined && ancestorMesh.minimumHeight !== undefined && ancestorMesh.maximumHeight !== undefined) {\n          tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n          break;\n        } else if (ancestorTerrainData !== undefined && ancestorTerrainData._minimumHeight !== undefined && ancestorTerrainData._maximumHeight !== undefined) {\n          tileBoundingRegion.minimumHeight = ancestorTerrainData._minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorTerrainData._maximumHeight;\n          break;\n        }\n      }\n      ancestorTile = ancestorTile.parent;\n    }\n    sourceTile = ancestorTile;\n  }\n\n  // Update bounding regions from the min and max heights\n  if (sourceTile !== undefined) {\n    const exaggeration = frameState.verticalExaggeration;\n    const exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n    const hasExaggeration = exaggeration !== 1.0;\n    if (hasExaggeration) {\n      hasBoundingVolumesFromMesh = false;\n      tileBoundingRegion.minimumHeight = VerticalExaggeration.getHeight(tileBoundingRegion.minimumHeight, exaggeration, exaggerationRelativeHeight);\n      tileBoundingRegion.maximumHeight = VerticalExaggeration.getHeight(tileBoundingRegion.maximumHeight, exaggeration, exaggerationRelativeHeight);\n    }\n    if (hasBoundingVolumesFromMesh) {\n      if (!surfaceTile.boundingVolumeIsFromMesh) {\n        tileBoundingRegion._orientedBoundingBox = OrientedBoundingBox.clone(mesh.orientedBoundingBox, tileBoundingRegion._orientedBoundingBox);\n        tileBoundingRegion._boundingSphere = BoundingSphere.clone(mesh.boundingSphere3D, tileBoundingRegion._boundingSphere);\n        surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(mesh.occludeePointInScaledSpace, surfaceTile.occludeePointInScaledSpace);\n\n        // If the occludee point is not defined, fallback to calculating it from the OBB\n        if (!defined(surfaceTile.occludeePointInScaledSpace)) {\n          surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(tileProvider, tileBoundingRegion._orientedBoundingBox.center, tile.rectangle, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, surfaceTile.occludeePointInScaledSpace);\n        }\n      }\n    } else {\n      const needsBounds = tileBoundingRegion._orientedBoundingBox === undefined || tileBoundingRegion._boundingSphere === undefined;\n      const heightChanged = tileBoundingRegion.minimumHeight !== oldMinimumHeight || tileBoundingRegion.maximumHeight !== oldMaximumHeight;\n      if (heightChanged || needsBounds) {\n        // Bounding volumes need to be recomputed in some circumstances\n        tileBoundingRegion.computeBoundingVolumes(ellipsoid);\n        surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(tileProvider, tileBoundingRegion._orientedBoundingBox.center, tile.rectangle, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, surfaceTile.occludeePointInScaledSpace);\n      }\n    }\n    surfaceTile.boundingVolumeSourceTile = sourceTile;\n    surfaceTile.boundingVolumeIsFromMesh = hasBoundingVolumesFromMesh;\n  } else {\n    surfaceTile.boundingVolumeSourceTile = undefined;\n    surfaceTile.boundingVolumeIsFromMesh = false;\n  }\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._clippingPolygons = this._clippingPolygons && this._clippingPolygons.destroy();\n  this._removeLayerAddedListener = this._removeLayerAddedListener && this._removeLayerAddedListener();\n  this._removeLayerRemovedListener = this._removeLayerRemovedListener && this._removeLayerRemovedListener();\n  this._removeLayerMovedListener = this._removeLayerMovedListener && this._removeLayerMovedListener();\n  this._removeLayerShownListener = this._removeLayerShownListener && this._removeLayerShownListener();\n  return destroyObject(this);\n};\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    let tileImagery;\n    let imagery;\n    let startIndex = -1;\n    const tileImageryCollection = tile.data.imagery;\n    const length = tileImageryCollection.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery);\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n    if (startIndex !== -1) {\n      const endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery) ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery) : undefined;\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(tile, terrainProvider, endIndex);\n      }\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n    return true; // Everything is done, so remove the callback\n  };\n}\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (this.isDestroyed()) {\n    return;\n  }\n  if (layer.show) {\n    const terrainProvider = this._terrainProvider;\n    const that = this;\n    const tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n    const reloadFunction = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n        let i;\n\n        // Figure out how many TileImageries we will need to remove and where to insert new ones\n        const tileImageryCollection = tile.data.imagery;\n        const length = tileImageryCollection.length;\n        let startIndex = -1;\n        let tileImageriesToFree = 0;\n        for (i = 0; i < length; ++i) {\n          const tileImagery = tileImageryCollection[i];\n          const imagery = defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery);\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n        if (startIndex === -1) {\n          return;\n        }\n\n        // Insert immediately after existing TileImageries\n        const insertionPoint = startIndex + tileImageriesToFree;\n\n        // Create new TileImageries for all loaded tiles\n        if (layer._createTileImagerySkeletons(tile, terrainProvider, insertionPoint)) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(tileImageriesToFree, layer, terrainProvider);\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    };\n    if (layer.ready) {\n      const imageryProvider = layer.imageryProvider;\n      imageryProvider._reload = reloadFunction;\n    }\n\n    // create TileImageries for this layer for all previously loaded tiles\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING;\n\n        // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n        if (tile.level !== 0 && (tile._lastSelectionResultFrame !== that.quadtree._lastSelectionFrameNumber || tile._lastSelectionResult !== TileSelectionResult.RENDERED)) {\n          tile.renderable = false;\n        }\n      }\n    });\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    const tileImageryCollection = tile.data.imagery;\n    let startIndex = -1;\n    let numDestroyed = 0;\n    for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      const tileImagery = tileImageryCollection[i];\n      let imagery = tileImagery.loadingImagery;\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (layer, newIndex, oldIndex) {\n  this._layerOrderChanged = true;\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (layer, index, show) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  const uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_atmosphereLightIntensity: function () {\n      return this.properties.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return this.properties.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return this.properties.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return this.properties.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return this.properties.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return this.properties.atmosphereMieAnisotropy;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_verticalExaggerationAndRelativeHeight: function () {\n      return this.properties.verticalExaggerationAndRelativeHeight;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const centerEye = Matrix4.multiplyByPoint(viewMatrix, this.properties.rtc, centerEyeScratch);\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const projectionMatrix = frameState.context.uniformState.projection;\n      const centerEye = Matrix4.multiplyByPoint(viewMatrix, this.properties.rtc, centerEyeScratch);\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewProjectionScratch);\n      Matrix4.multiply(projectionMatrix, modifiedModelViewProjectionScratch, modifiedModelViewProjectionScratch);\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureNightAlpha: function () {\n      return this.properties.dayTextureNightAlpha;\n    },\n    u_dayTextureDayAlpha: function () {\n      return this.properties.dayTextureDayAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      const transform = defined(clippingPlanes) ? Matrix4.multiply(frameState.context.uniformState.view, clippingPlanes.modelMatrix, scratchClippingPlanesMatrix) : Matrix4.IDENTITY;\n      return Matrix4.inverseTranspose(transform, scratchInverseTransposeClippingPlanesMatrix);\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_clippingDistance: function () {\n      const texture = globeSurfaceTileProvider._clippingPolygons.clippingTexture;\n      if (defined(texture)) {\n        return texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_clippingExtents: function () {\n      const texture = globeSurfaceTileProvider._clippingPolygons.extentsTexture;\n      if (defined(texture)) {\n        return texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n    u_frontFaceAlphaByDistance: function () {\n      return this.properties.frontFaceAlphaByDistance;\n    },\n    u_backFaceAlphaByDistance: function () {\n      return this.properties.backFaceAlphaByDistance;\n    },\n    u_translucencyRectangle: function () {\n      return this.properties.localizedTranslucencyRectangle;\n    },\n    u_undergroundColor: function () {\n      return this.properties.undergroundColor;\n    },\n    u_undergroundColorAlphaByDistance: function () {\n      return this.properties.undergroundColorAlphaByDistance;\n    },\n    u_lambertDiffuseMultiplier: function () {\n      return this.properties.lambertDiffuseMultiplier;\n    },\n    u_vertexShadowDarkness: function () {\n      return this.properties.vertexShadowDarkness;\n    },\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      atmosphereLightIntensity: 10.0,\n      atmosphereRayleighCoefficient: new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6),\n      atmosphereMieCoefficient: new Cartesian3(21e-6, 21e-6, 21e-6),\n      atmosphereRayleighScaleHeight: 10000.0,\n      atmosphereMieScaleHeight: 3200.0,\n      atmosphereMieAnisotropy: 0.9,\n      hsbShift: new Cartesian3(),\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n      verticalExaggerationAndRelativeHeight: new Cartesian2(1.0, 0.0),\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureNightAlpha: [],\n      dayTextureDayAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n      localizedCartographicLimitRectangle: new Cartesian4(),\n      frontFaceAlphaByDistance: new Cartesian4(),\n      backFaceAlphaByDistance: new Cartesian4(),\n      localizedTranslucencyRectangle: new Cartesian4(),\n      undergroundColor: Color.clone(Color.TRANSPARENT),\n      undergroundColorAlphaByDistance: new Cartesian4(),\n      lambertDiffuseMultiplier: 0.0,\n      vertexShadowDarkness: 0.0\n    }\n  };\n  if (defined(globeSurfaceTileProvider.materialUniformMap)) {\n    return combine(uniformMap, globeSurfaceTileProvider.materialUniformMap);\n  }\n  return uniformMap;\n}\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  const surfaceTile = tile.data;\n  let mesh;\n  let vertexArray;\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (defined(surfaceTile.fill) && defined(surfaceTile.fill.vertexArray)) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(context, vertexArray, mesh);\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  const indices = terrainMesh.indices;\n  const geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES\n  };\n  GeometryPipeline.toWireframe(geometry);\n  const wireframeIndices = geometry.indices;\n  const wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(wireframeIndices.BYTES_PER_ELEMENT)\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer\n  });\n}\nlet getDebugOrientedBoundingBox;\nlet getDebugBoundingSphere;\nlet debugDestroyPrimitive;\n(function () {\n  const instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0)\n    })\n  });\n  const instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 1.0\n    })\n  });\n  let modelMatrix = new Matrix4();\n  let previousVolume;\n  let primitive;\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true\n      }),\n      asynchronous: false\n    });\n  }\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(obb.halfAxes, obb.center, modelMatrix);\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color = ColorGeometryInstanceAttribute.fromColor(color);\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(modelMatrix, sphere.radius, modelMatrix);\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color = ColorGeometryInstanceAttribute.fromColor(color);\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\nconst otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nconst surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applyDayNightAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  enableClippingPolygons: undefined,\n  clippingPolygons: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined,\n  hasGeodeticSurfaceNormals: undefined,\n  hasExaggeration: undefined\n};\nconst defaultUndergroundColor = Color.TRANSPARENT;\nconst defaultUndergroundColorAlphaByDistance = new NearFarScalar();\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  const surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n  const creditDisplay = frameState.creditDisplay;\n  const terrainData = surfaceTile.terrainData;\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    const tileCredits = terrainData.credits;\n    for (let tileCreditIndex = 0, tileCreditLength = tileCredits.length; tileCreditIndex < tileCreditLength; ++tileCreditIndex) {\n      creditDisplay.addCreditToNextFrame(tileCredits[tileCreditIndex]);\n    }\n  }\n  let maxTextures = ContextLimits.maximumTextureImageUnits;\n  let waterMaskTexture = surfaceTile.waterMaskTexture;\n  let waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale = surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n  const cameraUnderground = frameState.cameraUnderground;\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  const translucent = globeTranslucencyState.translucent;\n  const frontFaceAlphaByDistance = globeTranslucencyState.frontFaceAlphaByDistance;\n  const backFaceAlphaByDistance = globeTranslucencyState.backFaceAlphaByDistance;\n  const translucencyRectangle = globeTranslucencyState.rectangle;\n  const undergroundColor = defaultValue(tileProvider.undergroundColor, defaultUndergroundColor);\n  const undergroundColorAlphaByDistance = defaultValue(tileProvider.undergroundColorAlphaByDistance, defaultUndergroundColorAlphaByDistance);\n  const showUndergroundColor = isUndergroundVisible(tileProvider, frameState) && frameState.mode === SceneMode.SCENE3D && undergroundColor.alpha > 0.0 && (undergroundColorAlphaByDistance.nearValue > 0.0 || undergroundColorAlphaByDistance.farValue > 0.0);\n  const lambertDiffuseMultiplier = tileProvider.lambertDiffuseMultiplier;\n  const vertexShadowDarkness = tileProvider.vertexShadowDarkness;\n  const hasWaterMask = tileProvider.hasWaterMask && defined(waterMaskTexture);\n  const showReflectiveOcean = hasWaterMask && tileProvider.showWaterEffect;\n  const oceanNormalMap = tileProvider.oceanNormalMap;\n  const showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  const terrainProvider = tileProvider.terrainProvider;\n  const hasVertexNormals = defined(terrainProvider) && tileProvider.terrainProvider.hasVertexNormals;\n  const enableFog = frameState.fog.enabled && frameState.fog.renderable && !cameraUnderground;\n  const showGroundAtmosphere = tileProvider.showGroundAtmosphere && frameState.mode === SceneMode.SCENE3D;\n  const castShadows = ShadowMode.castShadows(tileProvider.shadows) && !translucent;\n  const receiveShadows = ShadowMode.receiveShadows(tileProvider.shadows) && !translucent;\n  const hueShift = tileProvider.hueShift;\n  const saturationShift = tileProvider.saturationShift;\n  const brightnessShift = tileProvider.brightnessShift;\n  let colorCorrect = !(CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7));\n  let perFragmentGroundAtmosphere = false;\n  if (showGroundAtmosphere) {\n    const cameraDistance = Cartesian3.magnitude(frameState.camera.positionWC);\n    const fadeOutDistance = tileProvider.nightFadeOutDistance;\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n  if (hasWaterMask) {\n    --maxTextures;\n  }\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n  if (defined(frameState.shadowState) && frameState.shadowState.shadowsEnabled) {\n    --maxTextures;\n  }\n  if (defined(tileProvider.clippingPlanes) && tileProvider.clippingPlanes.enabled) {\n    --maxTextures;\n  }\n  if (defined(tileProvider.clippingPolygons) && tileProvider.clippingPolygons.enabled) {\n    --maxTextures;\n    --maxTextures;\n  }\n  maxTextures -= globeTranslucencyState.numberOfTextureUniforms;\n  const mesh = surfaceTile.renderedMesh;\n  let rtc = mesh.center;\n  const encoding = mesh.encoding;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  const hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n\n  // Not used in 3D.\n  const tileRectangle = tileRectangleScratch;\n\n  // Only used for Mercator projections.\n  let southLatitude = 0.0;\n  let northLatitude = 0.0;\n  let southMercatorY = 0.0;\n  let oneOverMercatorHeight = 0.0;\n  let useWebMercatorProjection = false;\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    const projection = frameState.mapProjection;\n    const southwest = projection.project(Rectangle.southwest(tile.rectangle), southwestScratch);\n    const northeast = projection.project(Rectangle.northeast(tile.rectangle), northeastScratch);\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y;\n\n    // In 2D and Columbus View, use the center of the tile for RTC rendering.\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n    if (frameState.mode === SceneMode.SCENE2D && encoding.quantization === TerrainQuantization.BITS12) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      const epsilon = 1.0 / (Math.pow(2.0, 12.0) - 1.0) * 0.5;\n      const widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      const heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);\n      oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) - southMercatorY);\n      useWebMercatorProjection = true;\n    }\n  }\n  const surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.hasWaterMask = hasWaterMask;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting = tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun = tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.atmosphereLightIntensity = tileProvider.atmosphereLightIntensity;\n  surfaceShaderSetOptions.atmosphereRayleighCoefficient = tileProvider.atmosphereRayleighCoefficient;\n  surfaceShaderSetOptions.atmosphereMieCoefficient = tileProvider.atmosphereMieCoefficient;\n  surfaceShaderSetOptions.atmosphereRayleighScaleHeight = tileProvider.atmosphereRayleighScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieScaleHeight = tileProvider.atmosphereMieScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieAnisotropy = tileProvider.atmosphereMieAnisotropy;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere = perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n  surfaceShaderSetOptions.hasGeodeticSurfaceNormals = hasGeodeticSurfaceNormals;\n  surfaceShaderSetOptions.hasExaggeration = hasExaggeration;\n  const tileImageryCollection = surfaceTile.imagery;\n  let imageryIndex = 0;\n  const imageryLen = tileImageryCollection.length;\n  const showSkirts = tileProvider.showSkirts && !cameraUnderground && !translucent;\n  const backFaceCulling = tileProvider.backFaceCulling && !cameraUnderground && !translucent;\n  const firstPassRenderState = backFaceCulling ? tileProvider._renderState : tileProvider._disableCullingRenderState;\n  const otherPassesRenderState = backFaceCulling ? tileProvider._blendRenderState : tileProvider._disableCullingBlendRenderState;\n  let renderState = firstPassRenderState;\n  let initialColor = tileProvider._firstPassInitialColor;\n  const context = frameState.context;\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n  const materialUniformMapChanged = tileProvider._materialUniformMap !== tileProvider.materialUniformMap;\n  if (materialUniformMapChanged) {\n    tileProvider._materialUniformMap = tileProvider.materialUniformMap;\n    const drawCommandsLength = tileProvider._drawCommands.length;\n    for (let i = 0; i < drawCommandsLength; ++i) {\n      tileProvider._uniformMaps[i] = createTileUniformMap(frameState, tileProvider);\n    }\n  }\n  do {\n    let numberOfDayTextures = 0;\n    let command;\n    let uniformMap;\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n      tileProvider._drawCommands.push(command);\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n    command.owner = tile;\n    ++tileProvider._usedDrawCommands;\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      const obb = tileBoundingRegion.boundingVolume;\n      const boundingSphere = tileBoundingRegion.boundingSphere;\n      // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(boundingSphere)) {\n        getDebugBoundingSphere(boundingSphere, Color.RED).update(frameState);\n      }\n    }\n    const uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x = tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y = tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x = tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.atmosphereLightIntensity = tileProvider.atmosphereLightIntensity;\n    uniformMapProperties.atmosphereRayleighCoefficient = tileProvider.atmosphereRayleighCoefficient;\n    uniformMapProperties.atmosphereMieCoefficient = tileProvider.atmosphereMieCoefficient;\n    uniformMapProperties.atmosphereRayleighScaleHeight = tileProvider.atmosphereRayleighScaleHeight;\n    uniformMapProperties.atmosphereMieScaleHeight = tileProvider.atmosphereMieScaleHeight;\n    uniformMapProperties.atmosphereMieAnisotropy = tileProvider.atmosphereMieAnisotropy;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity = tileProvider.zoomedOutOceanSpecularIntensity;\n    const frontFaceAlphaByDistanceFinal = cameraUnderground ? backFaceAlphaByDistance : frontFaceAlphaByDistance;\n    const backFaceAlphaByDistanceFinal = cameraUnderground ? frontFaceAlphaByDistance : backFaceAlphaByDistance;\n    if (defined(frontFaceAlphaByDistanceFinal)) {\n      Cartesian4.fromElements(frontFaceAlphaByDistanceFinal.near, frontFaceAlphaByDistanceFinal.nearValue, frontFaceAlphaByDistanceFinal.far, frontFaceAlphaByDistanceFinal.farValue, uniformMapProperties.frontFaceAlphaByDistance);\n      Cartesian4.fromElements(backFaceAlphaByDistanceFinal.near, backFaceAlphaByDistanceFinal.nearValue, backFaceAlphaByDistanceFinal.far, backFaceAlphaByDistanceFinal.farValue, uniformMapProperties.backFaceAlphaByDistance);\n    }\n    Cartesian4.fromElements(undergroundColorAlphaByDistance.near, undergroundColorAlphaByDistance.nearValue, undergroundColorAlphaByDistance.far, undergroundColorAlphaByDistance.farValue, uniformMapProperties.undergroundColorAlphaByDistance);\n    Color.clone(undergroundColor, uniformMapProperties.undergroundColor);\n    uniformMapProperties.lambertDiffuseMultiplier = lambertDiffuseMultiplier;\n    uniformMapProperties.vertexShadowDarkness = vertexShadowDarkness;\n    const highlightFillTile = !defined(surfaceTile.vertexArray) && defined(tileProvider.fillHighlightColor) && tileProvider.fillHighlightColor.alpha > 0.0;\n    if (highlightFillTile) {\n      Color.clone(tileProvider.fillHighlightColor, uniformMapProperties.fillHighlightColor);\n    }\n    uniformMapProperties.verticalExaggerationAndRelativeHeight.x = exaggeration;\n    uniformMapProperties.verticalExaggerationAndRelativeHeight.y = exaggerationRelativeHeight;\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y = oneOverMercatorHeight;\n\n    // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n    const localizedCartographicLimitRectangle = localizedCartographicLimitRectangleScratch;\n    const cartographicLimitRectangle = clipRectangleAntimeridian(tile.rectangle, tileProvider.cartographicLimitRectangle);\n    const localizedTranslucencyRectangle = localizedTranslucencyRectangleScratch;\n    const clippedTranslucencyRectangle = clipRectangleAntimeridian(tile.rectangle, translucencyRectangle);\n    Cartesian3.fromElements(hueShift, saturationShift, brightnessShift, uniformMapProperties.hsbShift);\n    const cartographicTileRectangle = tile.rectangle;\n    const inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    const inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x = (cartographicLimitRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedCartographicLimitRectangle.y = (cartographicLimitRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n    localizedCartographicLimitRectangle.z = (cartographicLimitRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedCartographicLimitRectangle.w = (cartographicLimitRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n    Cartesian4.clone(localizedCartographicLimitRectangle, uniformMapProperties.localizedCartographicLimitRectangle);\n    localizedTranslucencyRectangle.x = (clippedTranslucencyRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedTranslucencyRectangle.y = (clippedTranslucencyRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n    localizedTranslucencyRectangle.z = (clippedTranslucencyRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedTranslucencyRectangle.w = (clippedTranslucencyRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n    Cartesian4.clone(localizedTranslucencyRectangle, uniformMapProperties.localizedTranslucencyRectangle);\n\n    // For performance, render fog only when fog is enabled and the effect of\n    // fog would be non-negligible. This prevents the shader from running when\n    // the camera is in space, for example.\n    const applyFog = enableFog && CesiumMath.fog(tile._distance, frameState.fog.density) > CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n    let applyBrightness = false;\n    let applyContrast = false;\n    let applyHue = false;\n    let applySaturation = false;\n    let applyGamma = false;\n    let applyAlpha = false;\n    let applyDayNightAlpha = false;\n    let applySplit = false;\n    let applyCutout = false;\n    let applyColorToAlpha = false;\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      const tileImagery = tileImageryCollection[imageryIndex];\n      const imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n      const texture = tileImagery.useWebMercatorT ? imagery.textureWebMercator : imagery.texture;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      }\n      //>>includeEnd('debug');\n\n      const imageryLayer = imagery.imageryLayer;\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);\n      }\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] = tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] = tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] = tileImagery.useWebMercatorT;\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] = imageryLayer.alpha;\n      applyAlpha = applyAlpha || uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] = imageryLayer.nightAlpha;\n      applyDayNightAlpha = applyDayNightAlpha || uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] = imageryLayer.dayAlpha;\n      applyDayNightAlpha = applyDayNightAlpha || uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] = imageryLayer.brightness;\n      applyBrightness = applyBrightness || uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !== ImageryLayer.DEFAULT_BRIGHTNESS;\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] = imageryLayer.contrast;\n      applyContrast = applyContrast || uniformMapProperties.dayTextureContrast[numberOfDayTextures] !== ImageryLayer.DEFAULT_CONTRAST;\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] = imageryLayer.hue;\n      applyHue = applyHue || uniformMapProperties.dayTextureHue[numberOfDayTextures] !== ImageryLayer.DEFAULT_HUE;\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] = imageryLayer.saturation;\n      applySaturation = applySaturation || uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !== ImageryLayer.DEFAULT_SATURATION;\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] = 1.0 / imageryLayer.gamma;\n      applyGamma = applyGamma || uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !== 1.0 / ImageryLayer.DEFAULT_GAMMA;\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] = imageryLayer.splitDirection;\n      applySplit = applySplit || uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0;\n\n      // Update cutout rectangle\n      let dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures] = new Cartesian4();\n      }\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n      if (defined(imageryLayer.cutoutRectangle)) {\n        const cutoutRectangle = clipRectangleAntimeridian(cartographicTileRectangle, imageryLayer.cutoutRectangle);\n        const intersection = Rectangle.simpleIntersection(cutoutRectangle, cartographicTileRectangle, rectangleIntersectionScratch);\n        applyCutout = defined(intersection) || applyCutout;\n        dayTextureCutoutRectangle.x = (cutoutRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n        dayTextureCutoutRectangle.y = (cutoutRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n        dayTextureCutoutRectangle.z = (cutoutRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n        dayTextureCutoutRectangle.w = (cutoutRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n      }\n\n      // Update color to alpha\n      let colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures] = new Cartesian4();\n      }\n      const hasColorToAlpha = defined(imageryLayer.colorToAlpha) && imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n      if (defined(imagery.credits)) {\n        const credits = imagery.credits;\n        for (let creditIndex = 0, creditLength = credits.length; creditIndex < creditLength; ++creditIndex) {\n          creditDisplay.addCreditToNextFrame(credits[creditIndex]);\n        }\n      }\n      ++numberOfDayTextures;\n    }\n\n    // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(waterMaskTranslationAndScale, uniformMapProperties.waterMaskTranslationAndScale);\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias);\n\n    // update clipping planes\n    const clippingPlanes = tileProvider._clippingPlanes;\n    const clippingPlanesEnabled = defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(clippingPlanes.edgeColor, uniformMapProperties.clippingPlanesEdgeColor);\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    // update clipping polygons\n    const clippingPolygons = tileProvider._clippingPolygons;\n    const clippingPolygonsEnabled = defined(clippingPolygons) && clippingPolygons.enabled && tile.isClipped;\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applyDayNightAlpha = applyDayNightAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.enableClippingPolygons = clippingPolygonsEnabled;\n    surfaceShaderSetOptions.clippingPolygons = clippingPolygons;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    surfaceShaderSetOptions.showUndergroundColor = showUndergroundColor;\n    surfaceShaderSetOptions.translucent = translucent;\n    let count = surfaceTile.renderedMesh.indices.length;\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(surfaceShaderSetOptions);\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray = surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n    let boundingVolume = command.boundingVolume;\n    const orientedBoundingBox = command.orientedBoundingBox;\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, boundingVolume);\n      Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(tileBoundingRegion.boundingSphere, boundingVolume, boundingVolume);\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(tileBoundingRegion.boundingSphere, boundingVolume);\n      command.orientedBoundingBox = OrientedBoundingBox.clone(tileBoundingRegion.boundingVolume, orientedBoundingBox);\n    }\n    command.dirty = true;\n    if (translucent) {\n      globeTranslucencyState.updateDerivedCommands(command, frameState);\n    }\n    pushCommand(command, frameState);\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\nexport default GlobeSurfaceTileProvider;","map":{"version":3,"names":["BoundingSphere","BoxOutlineGeometry","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","ColorGeometryInstanceAttribute","combine","defaultValue","defined","destroyObject","DeveloperError","Event","GeometryInstance","GeometryPipeline","IndexDatatype","Intersect","CesiumMath","Matrix4","NearFarScalar","OrientedBoundingBox","OrthographicFrustum","PrimitiveType","Rectangle","SphereOutlineGeometry","VerticalExaggeration","TerrainQuantization","Visibility","WebMercatorProjection","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","VertexArray","BlendingState","ClippingPlaneCollection","ClippingPolygonCollection","DepthFunction","GlobeSurfaceTile","ImageryLayer","ImageryState","PerInstanceColorAppearance","Primitive","QuadtreeTileLoadState","SceneMode","ShadowMode","TerrainFillMesh","TerrainState","TileBoundingRegion","TileSelectionResult","GlobeSurfaceTileProvider","options","terrainProvider","imageryLayers","surfaceShaderSet","lightingFadeOutDistance","lightingFadeInDistance","hasWaterMask","showWaterEffect","oceanNormalMap","undefined","zoomedOutOceanSpecularIntensity","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","shadows","RECEIVE_ONLY","vertexShadowDarkness","fillHighlightColor","hueShift","saturationShift","brightnessShift","showSkirts","backFaceCulling","undergroundColor","undergroundColorAlphaByDistance","lambertDiffuseMultiplier","materialUniformMap","_materialUniformMap","_quadtree","_terrainProvider","_imageryLayers","_surfaceShaderSet","_renderState","_blendRenderState","_disableCullingRenderState","_disableCullingBlendRenderState","_errorEvent","_removeLayerAddedListener","layerAdded","addEventListener","prototype","_onLayerAdded","_removeLayerRemovedListener","layerRemoved","_onLayerRemoved","_removeLayerMovedListener","layerMoved","_onLayerMoved","_removeLayerShownListener","layerShownOrHidden","_onLayerShownOrHidden","_imageryLayersUpdatedEvent","_layerOrderChanged","_tilesToRenderByTextureCount","_drawCommands","_uniformMaps","_usedDrawCommands","_vertexArraysToDestroy","_debug","wireframe","boundingSphereTile","_baseColor","_firstPassInitialColor","baseColor","_clippingPlanes","_clippingPolygons","cartographicLimitRectangle","MAX_VALUE","_hasLoadedTilesThisFrame","_hasFillTilesThisFrame","_oldVerticalExaggeration","_oldVerticalExaggerationRelativeHeight","Object","defineProperties","get","set","value","fromColor","quadtree","tilingScheme","errorEvent","imageryLayersUpdatedEvent","invalidateAllTiles","clippingPlanes","setOwner","clippingPolygons","sortTileImageryByLayerIndex","a","b","aImagery","loadingImagery","readyImagery","bImagery","imageryLayer","_layerIndex","update","frameState","_update","updateCredits","surface","creditDisplay","credit","addCreditToNextFrame","i","len","length","layer","ready","show","imageryProvider","initialize","queueReprojectionCommands","forEachLoadedTile","tile","data","imagery","sort","vertexArraysToDestroy","j","_freeVertexArray","beginUpdate","tilesToRenderByTextureCount","tiles","enabled","queueCommands","endUpdate","fromCache","cull","depthTest","func","LESS","LESS_OR_EQUAL","blending","ALPHA_BLEND","rs","updateFillTiles","_tilesToRender","exaggeration","verticalExaggeration","exaggerationRelativeHeight","verticalExaggerationRelativeHeight","exaggerationChanged","surfaceTile","updateExaggeration","textureCountIndex","textureCountLength","tilesToRender","tileIndex","tileLength","tileBoundingRegion","addDrawCommandsForTile","minimumTerrainHeight","Math","min","minimumHeight","pushCommand","command","globeTranslucencyState","translucent","isBlendCommand","renderState","pushDerivedCommands","commandList","push","updateForPick","drawCommands","cancelReprojections","getLevelMaximumGeometricError","level","loadTile","terrainOnly","terrainStateBefore","boundingVolumeSourceTile","_lastSelectionResult","CULLED_BUT_NEEDED","terrainState","processStateMachine","computeTileVisibility","occluders","NONE","boundingSphereScratch","rectangleIntersectionScratch","splitCartographicLimitRectangleScratch","rectangleCenterScratch","clipRectangleAntimeridian","tileRectangle","west","east","splitRectangle","tileCenter","center","longitude","PI","isUndergroundVisible","tileProvider","cameraUnderground","equals","distance","computeDistanceToTile","_distance","undergroundVisible","fog","density","PARTIAL","cullingVolume","boundingVolume","boundingSphere","clippedByBoundaries","clippedCartographicLimitRectangle","rectangle","areaLimitIntersection","simpleIntersection","mode","SCENE3D","fromRectangleWithHeights2D","mapProjection","maximumHeight","fromElements","z","x","y","MORPHING","renderedMesh","union","planeIntersection","computeIntersectionWithBoundingVolume","isClipped","INSIDE","OUTSIDE","polygonIntersection","visibility","intersection","computeVisibility","INTERSECTING","FULL","ortho3D","camera","frustum","occludeePointInScaledSpace","ellipsoid","isScaledSpacePointVisiblePossiblyUnderEllipsoid","canRefine","terrainData","childAvailable","getTileDataAvailable","readyImageryScratch","canRenderTraversalStack","canRenderWithoutLosingDetail","terrainReady","initialImageryState","READY","tileImagery","isReady","state","FAILED","INVALID","layerIndex","lastFrame","_lastSelectionFrameNumber","stack","southwestChild","southeastChild","northwestChild","northeastChild","descendant","pop","lastFrameSelectionResult","_lastSelectionResultFrame","RENDERED","descendantSurface","descendantImagery","descendantTileImagery","descendantLoadingImagery","descendantIsReady","descendantLayerIndex","REFINED","tileDirectionScratch","computeTileLoadPriority","obb","cameraPosition","positionWC","cameraDirection","directionWC","tileDirection","subtract","magnitude","EPSILON5","divideByScalar","dot","modifiedModelViewScratch","modifiedModelViewProjectionScratch","tileRectangleScratch","localizedCartographicLimitRectangleScratch","localizedTranslucencyRectangleScratch","rtcScratch","centerEyeScratch","southwestScratch","northeastScratch","showTileThisFrame","readyTextureCount","tileImageryCollection","alpha","tileSet","vertexArray","debug","tilesRendered","texturesRendered","cornerPositionsScratch","computeOccludeePoint","result","ellipsoidalOccluder","_occluders","cornerPositions","fromRadians","south","north","computeHorizonCullingPointPossiblyUnderEllipsoid","updateTileBoundingRegion","max","cameraHeight","positionCartographic","height","distanceToMin","abs","distanceToMax","distanceToCamera","computeBoundingVolumes","oldMinimumHeight","oldMaximumHeight","hasBoundingVolumesFromMesh","sourceTile","mesh","_minimumHeight","_maximumHeight","Number","NaN","ancestorTile","parent","ancestorSurfaceTile","ancestorMesh","ancestorTerrainData","hasExaggeration","getHeight","boundingVolumeIsFromMesh","_orientedBoundingBox","orientedBoundingBox","_boundingSphere","boundingSphere3D","needsBounds","heightChanged","isDestroyed","destroy","_tileProvider","getTileReadyCallback","tileImageriesToFree","startIndex","endIndex","_createTileImagerySkeletons","freeResources","splice","index","that","tileImageryUpdatedEvent","reloadFunction","_imageryCache","_loadedCallbacks","insertionPoint","LOADING","_reload","renderable","raiseEvent","numDestroyed","newIndex","oldIndex","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createTileUniformMap","globeSurfaceTileProvider","uniformMap","u_initialColor","properties","initialColor","u_fillHighlightColor","u_zoomedOutOceanSpecularIntensity","u_oceanNormalMap","u_atmosphereLightIntensity","atmosphereLightIntensity","u_atmosphereRayleighCoefficient","atmosphereRayleighCoefficient","u_atmosphereMieCoefficient","atmosphereMieCoefficient","u_atmosphereRayleighScaleHeight","atmosphereRayleighScaleHeight","u_atmosphereMieScaleHeight","atmosphereMieScaleHeight","u_atmosphereMieAnisotropy","atmosphereMieAnisotropy","u_lightingFadeDistance","lightingFadeDistance","u_nightFadeDistance","nightFadeDistance","u_center3D","center3D","u_verticalExaggerationAndRelativeHeight","verticalExaggerationAndRelativeHeight","u_tileRectangle","u_modifiedModelView","viewMatrix","context","uniformState","view","centerEye","multiplyByPoint","rtc","setTranslation","u_modifiedModelViewProjection","projectionMatrix","projection","multiply","u_dayTextures","dayTextures","u_dayTextureTranslationAndScale","dayTextureTranslationAndScale","u_dayTextureTexCoordsRectangle","dayTextureTexCoordsRectangle","u_dayTextureUseWebMercatorT","dayTextureUseWebMercatorT","u_dayTextureAlpha","dayTextureAlpha","u_dayTextureNightAlpha","dayTextureNightAlpha","u_dayTextureDayAlpha","dayTextureDayAlpha","u_dayTextureBrightness","dayTextureBrightness","u_dayTextureContrast","dayTextureContrast","u_dayTextureHue","dayTextureHue","u_dayTextureSaturation","dayTextureSaturation","u_dayTextureOneOverGamma","dayTextureOneOverGamma","u_dayIntensity","dayIntensity","u_southAndNorthLatitude","southAndNorthLatitude","u_southMercatorYAndOneOverHeight","southMercatorYAndOneOverHeight","u_waterMask","waterMask","u_waterMaskTranslationAndScale","waterMaskTranslationAndScale","u_minMaxHeight","minMaxHeight","u_scaleAndBias","scaleAndBias","u_dayTextureSplit","dayTextureSplit","u_dayTextureCutoutRectangles","dayTextureCutoutRectangles","u_clippingPlanes","texture","defaultTexture","u_cartographicLimitRectangle","localizedCartographicLimitRectangle","u_clippingPlanesMatrix","transform","modelMatrix","IDENTITY","inverseTranspose","u_clippingPlanesEdgeStyle","style","clippingPlanesEdgeColor","clippingPlanesEdgeWidth","u_clippingDistance","clippingTexture","u_clippingExtents","extentsTexture","u_minimumBrightness","minimumBrightness","u_hsbShift","hsbShift","u_colorsToAlpha","colorsToAlpha","u_frontFaceAlphaByDistance","frontFaceAlphaByDistance","u_backFaceAlphaByDistance","backFaceAlphaByDistance","u_translucencyRectangle","localizedTranslucencyRectangle","u_undergroundColor","u_undergroundColorAlphaByDistance","u_lambertDiffuseMultiplier","u_vertexShadowDarkness","modifiedModelView","WHITE","TRANSPARENT","createWireframeVertexArrayIfNecessary","provider","fill","wireframeVertexArray","createWireframeVertexArray","terrainMesh","indices","geometry","primitiveType","TRIANGLES","toWireframe","wireframeIndices","wireframeIndexBuffer","createIndexBuffer","typedArray","usage","STATIC_DRAW","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","attributes","_attributes","indexBuffer","getDebugOrientedBoundingBox","getDebugBoundingSphere","debugDestroyPrimitive","instanceOBB","fromDimensions","dimensions","instanceSphere","radius","previousVolume","primitive","createDebugPrimitive","instance","geometryInstances","appearance","flat","asynchronous","color","fromRotationTranslation","halfAxes","sphere","fromTranslation","multiplyByUniformScale","otherPassesInitialColor","surfaceShaderSetOptionsScratch","numberOfDayTextures","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applyDayNightAlpha","applySplit","showReflectiveOcean","showOceanWaves","perFragmentGroundAtmosphere","hasVertexNormals","useWebMercatorProjection","enableFog","enableClippingPlanes","enableClippingPolygons","hasImageryLayerCutout","colorCorrect","colorToAlpha","hasGeodeticSurfaceNormals","defaultUndergroundColor","defaultUndergroundColorAlphaByDistance","credits","tileCredits","tileCreditIndex","tileCreditLength","maxTextures","maximumTextureImageUnits","waterMaskTexture","translucencyRectangle","showUndergroundColor","nearValue","farValue","castShadows","receiveShadows","equalsEpsilon","EPSILON7","cameraDistance","fadeOutDistance","nightFadeOutDistance","shadowState","shadowsEnabled","numberOfTextureUniforms","encoding","southLatitude","northLatitude","southMercatorY","oneOverMercatorHeight","southwest","project","northeast","w","SCENE2D","quantization","BITS12","epsilon","pow","widthEpsilon","heightEpsilon","geodeticLatitudeToMercatorAngle","surfaceShaderSetOptions","imageryIndex","imageryLen","firstPassRenderState","otherPassesRenderState","materialUniformMapChanged","drawCommandsLength","owner","RED","uniformMapProperties","nightFadeInDistance","frontFaceAlphaByDistanceFinal","backFaceAlphaByDistanceFinal","near","far","highlightFillTile","clippedTranslucencyRectangle","cartographicTileRectangle","inverseTileWidth","width","inverseTileHeight","applyFog","EPSILON3","applyCutout","applyColorToAlpha","useWebMercatorT","textureWebMercator","textureTranslationAndScale","_calculateTextureTranslationAndScale","textureCoordinateRectangle","nightAlpha","dayAlpha","brightness","DEFAULT_BRIGHTNESS","contrast","DEFAULT_CONTRAST","hue","DEFAULT_HUE","saturation","DEFAULT_SATURATION","gamma","DEFAULT_GAMMA","splitDirection","dayTextureCutoutRectangle","ZERO","cutoutRectangle","hasColorToAlpha","colorToAlphaThreshold","red","green","blue","creditIndex","creditLength","matrix","clippingPlanesEnabled","edgeColor","edgeWidth","clippingPolygonsEnabled","count","indexCountWithoutSkirts","shaderProgram","getShaderProgram","pass","GLOBE","LINES","dirty","updateDerivedCommands"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GlobeSurfaceTileProvider.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ClippingPolygonCollection from \"./ClippingPolygonCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.showWaterEffect = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  this.vertexShadowDarkness = 0.3;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this.undergroundColor = undefined;\n  this.undergroundColorAlphaByDistance = undefined;\n\n  this.lambertDiffuseMultiplier = 0.0;\n\n  this.materialUniformMap = undefined;\n  this._materialUniformMap = undefined;\n\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n\n  this._errorEvent = new Event();\n\n  this._removeLayerAddedListener =\n    this._imageryLayers.layerAdded.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerAdded,\n      this,\n    );\n  this._removeLayerRemovedListener =\n    this._imageryLayers.layerRemoved.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerRemoved,\n      this,\n    );\n  this._removeLayerMovedListener =\n    this._imageryLayers.layerMoved.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerMoved,\n      this,\n    );\n  this._removeLayerShownListener =\n    this._imageryLayers.layerShownOrHidden.addEventListener(\n      GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden,\n      this,\n    );\n  this._imageryLayersUpdatedEvent = new Event();\n\n  this._layerOrderChanged = false;\n\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n\n  this._vertexArraysToDestroy = [];\n\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined,\n  };\n\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * A property specifying a {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   * @type {ClippingPolygonCollection}\n   * @private\n   */\n  this._clippingPolygons = undefined;\n\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n\n  this._oldVerticalExaggeration = undefined;\n  this._oldVerticalExaggerationRelativeHeight = undefined;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(\n        value,\n        this._firstPassInitialColor,\n      );\n    },\n  },\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._quadtree = value;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      if (!defined(this._terrainProvider)) {\n        return undefined;\n      }\n\n      return this._terrainProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      }\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    },\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * The {@link ClippingPolygonCollection} used to selectively disable rendering inside or outside a list of polygons.\n   *\n   * @type {ClippingPolygonCollection}\n   *\n   * @private\n   */\n  clippingPolygons: {\n    get: function () {\n      return this._clippingPolygons;\n    },\n    set: function (value) {\n      ClippingPolygonCollection.setOwner(value, this, \"_clippingPolygons\");\n    },\n  },\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  let aImagery = a.loadingImagery;\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  let bImagery = b.loadingImagery;\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  const creditDisplay = frameState.creditDisplay;\n  const terrainProvider = surface._terrainProvider;\n  if (defined(terrainProvider) && defined(terrainProvider.credit)) {\n    creditDisplay.addCreditToNextFrame(terrainProvider.credit);\n  }\n\n  const imageryLayers = surface._imageryLayers;\n  for (let i = 0, len = imageryLayers.length; i < len; ++i) {\n    const layer = imageryLayers.get(i);\n    if (layer.ready && layer.show && defined(layer.imageryProvider.credit)) {\n      creditDisplay.addCreditToNextFrame(layer.imageryProvider.credit);\n    }\n  }\n}\n\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false;\n\n    // Sort the TileImagery instances in each tile by the layer index.\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  }\n\n  // Add credits for terrain and imagery providers.\n  updateCredits(this, frameState);\n\n  const vertexArraysToDestroy = this._vertexArraysToDestroy;\n  const length = vertexArraysToDestroy.length;\n  for (let j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n  vertexArraysToDestroy.length = 0;\n};\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (let i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    const tiles = tilesToRenderByTextureCount[i];\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  }\n  // update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n\n  // update clipping polygons\n  const clippingPolygons = this._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    clippingPolygons.update(frameState);\n    clippingPolygons.queueCommands(frameState);\n  }\n\n  this._usedDrawCommands = 0;\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS,\n      },\n    });\n\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n\n    let rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  }\n\n  // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(\n      this,\n      this._quadtree._tilesToRender,\n      frameState,\n      this._vertexArraysToDestroy,\n    );\n  }\n\n  // When vertical exaggeration changes, all of the loaded tiles need to generate\n  // geodetic surface normals so they can scale properly when rendered.\n  // When exaggeration is reset, geodetic surface normals are removed to decrease\n  // memory usage. Some tiles might have been constructed with the correct\n  // exaggeration already, so skip over them.\n\n  // If the geodetic surface normals can't be created because the tile doesn't\n  // have a mesh, keep checking until the tile does have a mesh. This can happen\n  // if the tile's mesh starts construction in a worker thread right before the\n  // exaggeration changes.\n\n  const quadtree = this.quadtree;\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  const exaggerationChanged =\n    this._oldVerticalExaggeration !== exaggeration ||\n    this._oldVerticalExaggerationRelativeHeight !== exaggerationRelativeHeight;\n\n  // Keep track of the next time there is a change in exaggeration\n  this._oldVerticalExaggeration = exaggeration;\n  this._oldVerticalExaggerationRelativeHeight = exaggerationRelativeHeight;\n\n  if (exaggerationChanged) {\n    quadtree.forEachLoadedTile(function (tile) {\n      const surfaceTile = tile.data;\n      surfaceTile.updateExaggeration(tile, frameState, quadtree);\n    });\n  }\n\n  // Add the tile render commands to the command list, sorted by texture count.\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (\n    let textureCountIndex = 0,\n      textureCountLength = tilesToRenderByTextureCount.length;\n    textureCountIndex < textureCountLength;\n    ++textureCountIndex\n  ) {\n    const tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (\n      let tileIndex = 0, tileLength = tilesToRender.length;\n      tileIndex < tileLength;\n      ++tileIndex\n    ) {\n      const tile = tilesToRender[tileIndex];\n      const tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(\n        frameState.minimumTerrainHeight,\n        tileBoundingRegion.minimumHeight,\n      );\n    }\n  }\n};\n\nfunction pushCommand(command, frameState) {\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  if (globeTranslucencyState.translucent) {\n    const isBlendCommand = command.renderState.blending.enabled;\n    globeTranslucencyState.pushDerivedCommands(\n      command,\n      isBlendCommand,\n      frameState,\n    );\n  } else {\n    frameState.commandList.push(command);\n  }\n}\n\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  const drawCommands = this._drawCommands;\n  for (let i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    pushCommand(drawCommands[i], frameState);\n  }\n};\n\n/**\n * Cancels any imagery re-projections in the queue.\n */\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error in meters.\n */\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (\n  level,\n) {\n  if (!defined(this._terrainProvider)) {\n    return 0;\n  }\n\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n */\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n\n  let surfaceTile = tile.data;\n  let terrainOnly = true;\n  let terrainStateBefore;\n  if (defined(surfaceTile)) {\n    terrainOnly =\n      surfaceTile.boundingVolumeSourceTile !== tile ||\n      tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(\n    tile,\n    frameState,\n    this.terrainProvider,\n    this._imageryLayers,\n    this.quadtree,\n    this._vertexArraysToDestroy,\n    terrainOnly,\n  );\n\n  surfaceTile = tile.data;\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (\n      this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !==\n        Visibility.NONE &&\n      surfaceTile.boundingVolumeSourceTile === tile\n    ) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(\n        tile,\n        frameState,\n        this.terrainProvider,\n        this._imageryLayers,\n        this.quadtree,\n        this._vertexArraysToDestroy,\n        terrainOnly,\n      );\n    }\n  }\n};\n\nconst boundingSphereScratch = new BoundingSphere();\nconst rectangleIntersectionScratch = new Rectangle();\nconst splitCartographicLimitRectangleScratch = new Rectangle();\nconst rectangleCenterScratch = new Cartographic();\n\n// cartographicLimitRectangle may span the IDL, but tiles never will.\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n  const splitRectangle = Rectangle.clone(\n    cartographicLimitRectangle,\n    splitCartographicLimitRectangleScratch,\n  );\n  const tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n  return splitRectangle;\n}\n\nfunction isUndergroundVisible(tileProvider, frameState) {\n  if (frameState.cameraUnderground) {\n    return true;\n  }\n\n  if (frameState.globeTranslucencyState.translucent) {\n    return true;\n  }\n\n  if (tileProvider.backFaceCulling) {\n    return false;\n  }\n\n  const clippingPlanes = tileProvider._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    return true;\n  }\n\n  const clippingPolygons = tileProvider._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    return true;\n  }\n\n  if (\n    !Rectangle.equals(\n      tileProvider.cartographicLimitRectangle,\n      Rectangle.MAX_VALUE,\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} Visibility.NONE if the tile is not visible,\n *                       Visibility.PARTIAL if the tile is partially visible, or\n *                       Visibility.FULL if the tile is fully visible.\n */\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (\n  tile,\n  frameState,\n  occluders,\n) {\n  const distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n\n  const undergroundVisible = isUndergroundVisible(this, frameState);\n\n  if (frameState.fog.enabled && !undergroundVisible) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  const surfaceTile = tile.data;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  const cullingVolume = frameState.cullingVolume;\n  let boundingVolume = tileBoundingRegion.boundingVolume;\n\n  if (!defined(boundingVolume)) {\n    boundingVolume = tileBoundingRegion.boundingSphere;\n  }\n\n  // Check if the tile is outside the limit area in cartographic space\n  surfaceTile.clippedByBoundaries = false;\n  const clippedCartographicLimitRectangle = clipRectangleAntimeridian(\n    tile.rectangle,\n    this.cartographicLimitRectangle,\n  );\n  const areaLimitIntersection = Rectangle.simpleIntersection(\n    clippedCartographicLimitRectangle,\n    tile.rectangle,\n    rectangleIntersectionScratch,\n  );\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(\n      tile.rectangle,\n      frameState.mapProjection,\n      tileBoundingRegion.minimumHeight,\n      tileBoundingRegion.maximumHeight,\n      boundingVolume,\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center,\n    );\n\n    if (\n      frameState.mode === SceneMode.MORPHING &&\n      defined(surfaceTile.renderedMesh)\n    ) {\n      boundingVolume = BoundingSphere.union(\n        tileBoundingRegion.boundingSphere,\n        boundingVolume,\n        boundingVolume,\n      );\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Visibility.PARTIAL;\n  }\n\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const planeIntersection =\n      clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume);\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  const clippingPolygons = this._clippingPolygons;\n  if (defined(clippingPolygons) && clippingPolygons.enabled) {\n    const polygonIntersection =\n      clippingPolygons.computeIntersectionWithBoundingVolume(\n        tileBoundingRegion,\n      );\n    tile.isClipped = polygonIntersection !== Intersect.OUTSIDE;\n    // Polygon clipping intersections are determined by outer rectangles, therefore we cannot\n    // preemptively determine if a tile is completely clipped or not here.\n  }\n\n  let visibility;\n  const intersection = cullingVolume.computeVisibility(boundingVolume);\n\n  if (intersection === Intersect.OUTSIDE) {\n    visibility = Visibility.NONE;\n  } else if (intersection === Intersect.INTERSECTING) {\n    visibility = Visibility.PARTIAL;\n  } else if (intersection === Intersect.INSIDE) {\n    visibility = Visibility.FULL;\n  }\n\n  if (visibility === Visibility.NONE) {\n    return visibility;\n  }\n\n  const ortho3D =\n    frameState.mode === SceneMode.SCENE3D &&\n    frameState.camera.frustum instanceof OrthographicFrustum;\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    !ortho3D &&\n    defined(occluders) &&\n    !undergroundVisible\n  ) {\n    const occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n    if (!defined(occludeePointInScaledSpace)) {\n      return visibility;\n    }\n\n    if (\n      occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(\n        occludeePointInScaledSpace,\n        tileBoundingRegion.minimumHeight,\n      )\n    ) {\n      return visibility;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return visibility;\n};\n\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n  const childAvailable = this.terrainProvider.getTileDataAvailable(\n    tile.x * 2,\n    tile.y * 2,\n    tile.level + 1,\n  );\n  return childAvailable !== undefined;\n};\n\nconst readyImageryScratch = [];\nconst canRenderTraversalStack = [];\n\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (\n  tile,\n  frameState,\n) {\n  const surfaceTile = tile.data;\n\n  const readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n\n  let terrainReady = false;\n  let initialImageryState = false;\n  let imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY;\n\n    // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n    initialImageryState = true;\n\n    imagery = surfaceTile.imagery;\n  }\n\n  let i;\n  let len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      const tileImagery = imagery[i];\n      const loadingImagery = tileImagery.loadingImagery;\n      const isReady =\n        !defined(loadingImagery) ||\n        loadingImagery.state === ImageryState.FAILED ||\n        loadingImagery.state === ImageryState.INVALID;\n      const layerIndex = (\n        tileImagery.loadingImagery || tileImagery.readyImagery\n      ).imageryLayer._layerIndex;\n\n      // For a layer to be ready, all tiles belonging to that layer must be ready.\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  const lastFrame = this.quadtree._lastSelectionFrameNumber;\n\n  // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n  const stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(\n    tile.southwestChild,\n    tile.southeastChild,\n    tile.northwestChild,\n    tile.northeastChild,\n  );\n\n  while (stack.length > 0) {\n    const descendant = stack.pop();\n    const lastFrameSelectionResult =\n      descendant._lastSelectionResultFrame === lastFrame\n        ? descendant._lastSelectionResult\n        : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      const descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (\n        !terrainReady &&\n        descendant.data.terrainState === TerrainState.READY\n      ) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      const descendantImagery = descendant.data.imagery;\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        const descendantTileImagery = descendantImagery[i];\n        const descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        const descendantIsReady =\n          !defined(descendantLoadingImagery) ||\n          descendantLoadingImagery.state === ImageryState.FAILED ||\n          descendantLoadingImagery.state === ImageryState.INVALID;\n        const descendantLayerIndex = (\n          descendantTileImagery.loadingImagery ||\n          descendantTileImagery.readyImagery\n        ).imageryLayer._layerIndex;\n\n        // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(\n        descendant.southwestChild,\n        descendant.southeastChild,\n        descendant.northwestChild,\n        descendant.northeastChild,\n      );\n    }\n  }\n\n  return true;\n};\n\nconst tileDirectionScratch = new Cartesian3();\n\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {number} The load priority value.\n */\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (\n  tile,\n  frameState,\n) {\n  const surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  const obb = surfaceTile.tileBoundingRegion.boundingVolume;\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  const cameraPosition = frameState.camera.positionWC;\n  const cameraDirection = frameState.camera.directionWC;\n  const tileDirection = Cartesian3.subtract(\n    obb.center,\n    cameraPosition,\n    tileDirectionScratch,\n  );\n  const magnitude = Cartesian3.magnitude(tileDirection);\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (\n    (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance\n  );\n};\n\nconst modifiedModelViewScratch = new Matrix4();\nconst modifiedModelViewProjectionScratch = new Matrix4();\nconst tileRectangleScratch = new Cartesian4();\nconst localizedCartographicLimitRectangleScratch = new Cartesian4();\nconst localizedTranslucencyRectangleScratch = new Cartesian4();\nconst rtcScratch = new Cartesian3();\nconst centerEyeScratch = new Cartesian3();\nconst southwestScratch = new Cartesian3();\nconst northeastScratch = new Cartesian3();\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (\n  tile,\n  frameState,\n) {\n  let readyTextureCount = 0;\n  const tileImageryCollection = tile.data.imagery;\n  for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (\n      defined(tileImagery.readyImagery) &&\n      tileImagery.readyImagery.imageryLayer.alpha !== 0.0\n    ) {\n      ++readyTextureCount;\n    }\n  }\n\n  let tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n\n  const surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  const debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nconst cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result,\n) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0],\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1],\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2],\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3],\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result,\n  );\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {number} The distance from the camera to the closest point on the tile, in meters.\n */\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (\n  tile,\n  frameState,\n) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based on that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n\n  updateTileBoundingRegion(tile, this, frameState);\n\n  const surfaceTile = tile.data;\n  const boundingVolumeSourceTile = surfaceTile.boundingVolumeSourceTile;\n  if (boundingVolumeSourceTile === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  }\n\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const min = tileBoundingRegion.minimumHeight;\n  const max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    const cameraHeight = frameState.camera.positionCartographic.height;\n    const distanceToMin = Math.abs(cameraHeight - min);\n    const distanceToMax = Math.abs(cameraHeight - max);\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  const result = tileBoundingRegion.distanceToCamera(frameState);\n\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, tileProvider, frameState) {\n  let surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0,\n    });\n  }\n\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const oldMinimumHeight = tileBoundingRegion.minimumHeight;\n  const oldMaximumHeight = tileBoundingRegion.maximumHeight;\n  let hasBoundingVolumesFromMesh = false;\n  let sourceTile = tile;\n\n  // Get min and max heights from the mesh.\n  // If the mesh is not available, get them from the terrain data.\n  // If the terrain data is not available either, get them from an ancestor.\n  // If none of the ancestors are available, then there are no min and max heights for this tile at this time.\n  const mesh = surfaceTile.mesh;\n  const terrainData = surfaceTile.terrainData;\n  if (\n    mesh !== undefined &&\n    mesh.minimumHeight !== undefined &&\n    mesh.maximumHeight !== undefined\n  ) {\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    hasBoundingVolumesFromMesh = true;\n  } else if (\n    terrainData !== undefined &&\n    terrainData._minimumHeight !== undefined &&\n    terrainData._maximumHeight !== undefined\n  ) {\n    tileBoundingRegion.minimumHeight = terrainData._minimumHeight;\n    tileBoundingRegion.maximumHeight = terrainData._maximumHeight;\n  } else {\n    // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n    tileBoundingRegion.minimumHeight = Number.NaN;\n    tileBoundingRegion.maximumHeight = Number.NaN;\n\n    let ancestorTile = tile.parent;\n    while (ancestorTile !== undefined) {\n      const ancestorSurfaceTile = ancestorTile.data;\n      if (ancestorSurfaceTile !== undefined) {\n        const ancestorMesh = ancestorSurfaceTile.mesh;\n        const ancestorTerrainData = ancestorSurfaceTile.terrainData;\n        if (\n          ancestorMesh !== undefined &&\n          ancestorMesh.minimumHeight !== undefined &&\n          ancestorMesh.maximumHeight !== undefined\n        ) {\n          tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n          break;\n        } else if (\n          ancestorTerrainData !== undefined &&\n          ancestorTerrainData._minimumHeight !== undefined &&\n          ancestorTerrainData._maximumHeight !== undefined\n        ) {\n          tileBoundingRegion.minimumHeight = ancestorTerrainData._minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorTerrainData._maximumHeight;\n          break;\n        }\n      }\n      ancestorTile = ancestorTile.parent;\n    }\n    sourceTile = ancestorTile;\n  }\n\n  // Update bounding regions from the min and max heights\n  if (sourceTile !== undefined) {\n    const exaggeration = frameState.verticalExaggeration;\n    const exaggerationRelativeHeight =\n      frameState.verticalExaggerationRelativeHeight;\n    const hasExaggeration = exaggeration !== 1.0;\n    if (hasExaggeration) {\n      hasBoundingVolumesFromMesh = false;\n      tileBoundingRegion.minimumHeight = VerticalExaggeration.getHeight(\n        tileBoundingRegion.minimumHeight,\n        exaggeration,\n        exaggerationRelativeHeight,\n      );\n      tileBoundingRegion.maximumHeight = VerticalExaggeration.getHeight(\n        tileBoundingRegion.maximumHeight,\n        exaggeration,\n        exaggerationRelativeHeight,\n      );\n    }\n\n    if (hasBoundingVolumesFromMesh) {\n      if (!surfaceTile.boundingVolumeIsFromMesh) {\n        tileBoundingRegion._orientedBoundingBox = OrientedBoundingBox.clone(\n          mesh.orientedBoundingBox,\n          tileBoundingRegion._orientedBoundingBox,\n        );\n        tileBoundingRegion._boundingSphere = BoundingSphere.clone(\n          mesh.boundingSphere3D,\n          tileBoundingRegion._boundingSphere,\n        );\n        surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(\n          mesh.occludeePointInScaledSpace,\n          surfaceTile.occludeePointInScaledSpace,\n        );\n\n        // If the occludee point is not defined, fallback to calculating it from the OBB\n        if (!defined(surfaceTile.occludeePointInScaledSpace)) {\n          surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n            tileProvider,\n            tileBoundingRegion._orientedBoundingBox.center,\n            tile.rectangle,\n            tileBoundingRegion.minimumHeight,\n            tileBoundingRegion.maximumHeight,\n            surfaceTile.occludeePointInScaledSpace,\n          );\n        }\n      }\n    } else {\n      const needsBounds =\n        tileBoundingRegion._orientedBoundingBox === undefined ||\n        tileBoundingRegion._boundingSphere === undefined;\n      const heightChanged =\n        tileBoundingRegion.minimumHeight !== oldMinimumHeight ||\n        tileBoundingRegion.maximumHeight !== oldMaximumHeight;\n      if (heightChanged || needsBounds) {\n        // Bounding volumes need to be recomputed in some circumstances\n        tileBoundingRegion.computeBoundingVolumes(ellipsoid);\n        surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n          tileProvider,\n          tileBoundingRegion._orientedBoundingBox.center,\n          tile.rectangle,\n          tileBoundingRegion.minimumHeight,\n          tileBoundingRegion.maximumHeight,\n          surfaceTile.occludeePointInScaledSpace,\n        );\n      }\n    }\n    surfaceTile.boundingVolumeSourceTile = sourceTile;\n    surfaceTile.boundingVolumeIsFromMesh = hasBoundingVolumesFromMesh;\n  } else {\n    surfaceTile.boundingVolumeSourceTile = undefined;\n    surfaceTile.boundingVolumeIsFromMesh = false;\n  }\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._clippingPolygons =\n    this._clippingPolygons && this._clippingPolygons.destroy();\n  this._removeLayerAddedListener =\n    this._removeLayerAddedListener && this._removeLayerAddedListener();\n  this._removeLayerRemovedListener =\n    this._removeLayerRemovedListener && this._removeLayerRemovedListener();\n  this._removeLayerMovedListener =\n    this._removeLayerMovedListener && this._removeLayerMovedListener();\n  this._removeLayerShownListener =\n    this._removeLayerShownListener && this._removeLayerShownListener();\n\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    let tileImagery;\n    let imagery;\n    let startIndex = -1;\n    const tileImageryCollection = tile.data.imagery;\n    const length = tileImageryCollection.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(\n        tileImagery.readyImagery,\n        tileImagery.loadingImagery,\n      );\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      const endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery)\n        ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery)\n        : undefined;\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(\n          tile,\n          terrainProvider,\n          endIndex,\n        );\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (this.isDestroyed()) {\n    return;\n  }\n\n  if (layer.show) {\n    const terrainProvider = this._terrainProvider;\n\n    const that = this;\n    const tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n    const reloadFunction = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        let i;\n\n        // Figure out how many TileImageries we will need to remove and where to insert new ones\n        const tileImageryCollection = tile.data.imagery;\n        const length = tileImageryCollection.length;\n        let startIndex = -1;\n        let tileImageriesToFree = 0;\n        for (i = 0; i < length; ++i) {\n          const tileImagery = tileImageryCollection[i];\n          const imagery = defaultValue(\n            tileImagery.readyImagery,\n            tileImagery.loadingImagery,\n          );\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        }\n\n        // Insert immediately after existing TileImageries\n        const insertionPoint = startIndex + tileImageriesToFree;\n\n        // Create new TileImageries for all loaded tiles\n        if (\n          layer._createTileImagerySkeletons(\n            tile,\n            terrainProvider,\n            insertionPoint,\n          )\n        ) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(\n            tileImageriesToFree,\n            layer,\n            terrainProvider,\n          );\n\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    };\n\n    if (layer.ready) {\n      const imageryProvider = layer.imageryProvider;\n      imageryProvider._reload = reloadFunction;\n    }\n\n    // create TileImageries for this layer for all previously loaded tiles\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING;\n\n        // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n        if (\n          tile.level !== 0 &&\n          (tile._lastSelectionResultFrame !==\n            that.quadtree._lastSelectionFrameNumber ||\n            tile._lastSelectionResult !== TileSelectionResult.RENDERED)\n        ) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    const tileImageryCollection = tile.data.imagery;\n\n    let startIndex = -1;\n    let numDestroyed = 0;\n    for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      const tileImagery = tileImageryCollection[i];\n      let imagery = tileImagery.loadingImagery;\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (\n  layer,\n  newIndex,\n  oldIndex,\n) {\n  this._layerOrderChanged = true;\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (\n  layer,\n  index,\n  show,\n) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  const uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_atmosphereLightIntensity: function () {\n      return this.properties.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return this.properties.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return this.properties.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return this.properties.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return this.properties.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return this.properties.atmosphereMieAnisotropy;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_verticalExaggerationAndRelativeHeight: function () {\n      return this.properties.verticalExaggerationAndRelativeHeight;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch,\n      );\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const projectionMatrix = frameState.context.uniformState.projection;\n      const centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch,\n      );\n      Matrix4.setTranslation(\n        viewMatrix,\n        centerEye,\n        modifiedModelViewProjectionScratch,\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewProjectionScratch,\n        modifiedModelViewProjectionScratch,\n      );\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureNightAlpha: function () {\n      return this.properties.dayTextureNightAlpha;\n    },\n    u_dayTextureDayAlpha: function () {\n      return this.properties.dayTextureDayAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      const transform = defined(clippingPlanes)\n        ? Matrix4.multiply(\n            frameState.context.uniformState.view,\n            clippingPlanes.modelMatrix,\n            scratchClippingPlanesMatrix,\n          )\n        : Matrix4.IDENTITY;\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix,\n      );\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_clippingDistance: function () {\n      const texture =\n        globeSurfaceTileProvider._clippingPolygons.clippingTexture;\n      if (defined(texture)) {\n        return texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_clippingExtents: function () {\n      const texture = globeSurfaceTileProvider._clippingPolygons.extentsTexture;\n      if (defined(texture)) {\n        return texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n    u_frontFaceAlphaByDistance: function () {\n      return this.properties.frontFaceAlphaByDistance;\n    },\n    u_backFaceAlphaByDistance: function () {\n      return this.properties.backFaceAlphaByDistance;\n    },\n    u_translucencyRectangle: function () {\n      return this.properties.localizedTranslucencyRectangle;\n    },\n    u_undergroundColor: function () {\n      return this.properties.undergroundColor;\n    },\n    u_undergroundColorAlphaByDistance: function () {\n      return this.properties.undergroundColorAlphaByDistance;\n    },\n    u_lambertDiffuseMultiplier: function () {\n      return this.properties.lambertDiffuseMultiplier;\n    },\n    u_vertexShadowDarkness: function () {\n      return this.properties.vertexShadowDarkness;\n    },\n\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      atmosphereLightIntensity: 10.0,\n      atmosphereRayleighCoefficient: new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6),\n      atmosphereMieCoefficient: new Cartesian3(21e-6, 21e-6, 21e-6),\n      atmosphereRayleighScaleHeight: 10000.0,\n      atmosphereMieScaleHeight: 3200.0,\n      atmosphereMieAnisotropy: 0.9,\n      hsbShift: new Cartesian3(),\n\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n\n      verticalExaggerationAndRelativeHeight: new Cartesian2(1.0, 0.0),\n\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureNightAlpha: [],\n      dayTextureDayAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n\n      localizedCartographicLimitRectangle: new Cartesian4(),\n\n      frontFaceAlphaByDistance: new Cartesian4(),\n      backFaceAlphaByDistance: new Cartesian4(),\n      localizedTranslucencyRectangle: new Cartesian4(),\n      undergroundColor: Color.clone(Color.TRANSPARENT),\n      undergroundColorAlphaByDistance: new Cartesian4(),\n      lambertDiffuseMultiplier: 0.0,\n      vertexShadowDarkness: 0.0,\n    },\n  };\n\n  if (defined(globeSurfaceTileProvider.materialUniformMap)) {\n    return combine(uniformMap, globeSurfaceTileProvider.materialUniformMap);\n  }\n\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  const surfaceTile = tile.data;\n\n  let mesh;\n  let vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (\n    defined(surfaceTile.fill) &&\n    defined(surfaceTile.fill.vertexArray)\n  ) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(\n    context,\n    vertexArray,\n    mesh,\n  );\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  const indices = terrainMesh.indices;\n\n  const geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  GeometryPipeline.toWireframe(geometry);\n\n  const wireframeIndices = geometry.indices;\n  const wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(\n      wireframeIndices.BYTES_PER_ELEMENT,\n    ),\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer,\n  });\n}\n\nlet getDebugOrientedBoundingBox;\nlet getDebugBoundingSphere;\nlet debugDestroyPrimitive;\n\n(function () {\n  const instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    }),\n  });\n  const instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({ radius: 1.0 }),\n  });\n  let modelMatrix = new Matrix4();\n  let previousVolume;\n  let primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(\n      obb.halfAxes,\n      obb.center,\n      modelMatrix,\n    );\n\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color =\n      ColorGeometryInstanceAttribute.fromColor(color);\n\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(\n      modelMatrix,\n      sphere.radius,\n      modelMatrix,\n    );\n\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color =\n      ColorGeometryInstanceAttribute.fromColor(color);\n\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nconst otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nconst surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applyDayNightAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  enableClippingPolygons: undefined,\n  clippingPolygons: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined,\n  hasGeodeticSurfaceNormals: undefined,\n  hasExaggeration: undefined,\n};\n\nconst defaultUndergroundColor = Color.TRANSPARENT;\nconst defaultUndergroundColorAlphaByDistance = new NearFarScalar();\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  const surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  const creditDisplay = frameState.creditDisplay;\n\n  const terrainData = surfaceTile.terrainData;\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    const tileCredits = terrainData.credits;\n    for (\n      let tileCreditIndex = 0, tileCreditLength = tileCredits.length;\n      tileCreditIndex < tileCreditLength;\n      ++tileCreditIndex\n    ) {\n      creditDisplay.addCreditToNextFrame(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  let maxTextures = ContextLimits.maximumTextureImageUnits;\n\n  let waterMaskTexture = surfaceTile.waterMaskTexture;\n  let waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale =\n      surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  const cameraUnderground = frameState.cameraUnderground;\n\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  const translucent = globeTranslucencyState.translucent;\n  const frontFaceAlphaByDistance =\n    globeTranslucencyState.frontFaceAlphaByDistance;\n  const backFaceAlphaByDistance =\n    globeTranslucencyState.backFaceAlphaByDistance;\n  const translucencyRectangle = globeTranslucencyState.rectangle;\n\n  const undergroundColor = defaultValue(\n    tileProvider.undergroundColor,\n    defaultUndergroundColor,\n  );\n  const undergroundColorAlphaByDistance = defaultValue(\n    tileProvider.undergroundColorAlphaByDistance,\n    defaultUndergroundColorAlphaByDistance,\n  );\n  const showUndergroundColor =\n    isUndergroundVisible(tileProvider, frameState) &&\n    frameState.mode === SceneMode.SCENE3D &&\n    undergroundColor.alpha > 0.0 &&\n    (undergroundColorAlphaByDistance.nearValue > 0.0 ||\n      undergroundColorAlphaByDistance.farValue > 0.0);\n\n  const lambertDiffuseMultiplier = tileProvider.lambertDiffuseMultiplier;\n  const vertexShadowDarkness = tileProvider.vertexShadowDarkness;\n\n  const hasWaterMask = tileProvider.hasWaterMask && defined(waterMaskTexture);\n  const showReflectiveOcean = hasWaterMask && tileProvider.showWaterEffect;\n  const oceanNormalMap = tileProvider.oceanNormalMap;\n  const showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  const terrainProvider = tileProvider.terrainProvider;\n  const hasVertexNormals =\n    defined(terrainProvider) && tileProvider.terrainProvider.hasVertexNormals;\n  const enableFog =\n    frameState.fog.enabled && frameState.fog.renderable && !cameraUnderground;\n  const showGroundAtmosphere =\n    tileProvider.showGroundAtmosphere && frameState.mode === SceneMode.SCENE3D;\n  const castShadows =\n    ShadowMode.castShadows(tileProvider.shadows) && !translucent;\n  const receiveShadows =\n    ShadowMode.receiveShadows(tileProvider.shadows) && !translucent;\n\n  const hueShift = tileProvider.hueShift;\n  const saturationShift = tileProvider.saturationShift;\n  const brightnessShift = tileProvider.brightnessShift;\n\n  let colorCorrect = !(\n    CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7)\n  );\n\n  let perFragmentGroundAtmosphere = false;\n  if (showGroundAtmosphere) {\n    const cameraDistance = Cartesian3.magnitude(frameState.camera.positionWC);\n    const fadeOutDistance = tileProvider.nightFadeOutDistance;\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (hasWaterMask) {\n    --maxTextures;\n  }\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n  if (\n    defined(frameState.shadowState) &&\n    frameState.shadowState.shadowsEnabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPlanes) &&\n    tileProvider.clippingPlanes.enabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPolygons) &&\n    tileProvider.clippingPolygons.enabled\n  ) {\n    --maxTextures;\n    --maxTextures;\n  }\n\n  maxTextures -= globeTranslucencyState.numberOfTextureUniforms;\n\n  const mesh = surfaceTile.renderedMesh;\n  let rtc = mesh.center;\n  const encoding = mesh.encoding;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  const hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n\n  // Not used in 3D.\n  const tileRectangle = tileRectangleScratch;\n\n  // Only used for Mercator projections.\n  let southLatitude = 0.0;\n  let northLatitude = 0.0;\n  let southMercatorY = 0.0;\n  let oneOverMercatorHeight = 0.0;\n\n  let useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    const projection = frameState.mapProjection;\n    const southwest = projection.project(\n      Rectangle.southwest(tile.rectangle),\n      southwestScratch,\n    );\n    const northeast = projection.project(\n      Rectangle.northeast(tile.rectangle),\n      northeastScratch,\n    );\n\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y;\n\n    // In 2D and Columbus View, use the center of the tile for RTC rendering.\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (\n      frameState.mode === SceneMode.SCENE2D &&\n      encoding.quantization === TerrainQuantization.BITS12\n    ) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      const epsilon = (1.0 / (Math.pow(2.0, 12.0) - 1.0)) * 0.5;\n      const widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      const heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n\n      southMercatorY =\n        WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);\n\n      oneOverMercatorHeight =\n        1.0 /\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) -\n          southMercatorY);\n\n      useWebMercatorProjection = true;\n    }\n  }\n\n  const surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.hasWaterMask = hasWaterMask;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting =\n    tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun =\n    tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.atmosphereLightIntensity =\n    tileProvider.atmosphereLightIntensity;\n  surfaceShaderSetOptions.atmosphereRayleighCoefficient =\n    tileProvider.atmosphereRayleighCoefficient;\n  surfaceShaderSetOptions.atmosphereMieCoefficient =\n    tileProvider.atmosphereMieCoefficient;\n  surfaceShaderSetOptions.atmosphereRayleighScaleHeight =\n    tileProvider.atmosphereRayleighScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieScaleHeight =\n    tileProvider.atmosphereMieScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieAnisotropy =\n    tileProvider.atmosphereMieAnisotropy;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere =\n    perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n  surfaceShaderSetOptions.hasGeodeticSurfaceNormals = hasGeodeticSurfaceNormals;\n  surfaceShaderSetOptions.hasExaggeration = hasExaggeration;\n\n  const tileImageryCollection = surfaceTile.imagery;\n  let imageryIndex = 0;\n  const imageryLen = tileImageryCollection.length;\n\n  const showSkirts =\n    tileProvider.showSkirts && !cameraUnderground && !translucent;\n  const backFaceCulling =\n    tileProvider.backFaceCulling && !cameraUnderground && !translucent;\n  const firstPassRenderState = backFaceCulling\n    ? tileProvider._renderState\n    : tileProvider._disableCullingRenderState;\n  const otherPassesRenderState = backFaceCulling\n    ? tileProvider._blendRenderState\n    : tileProvider._disableCullingBlendRenderState;\n  let renderState = firstPassRenderState;\n\n  let initialColor = tileProvider._firstPassInitialColor;\n\n  const context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  const materialUniformMapChanged =\n    tileProvider._materialUniformMap !== tileProvider.materialUniformMap;\n  if (materialUniformMapChanged) {\n    tileProvider._materialUniformMap = tileProvider.materialUniformMap;\n    const drawCommandsLength = tileProvider._drawCommands.length;\n    for (let i = 0; i < drawCommandsLength; ++i) {\n      tileProvider._uniformMaps[i] = createTileUniformMap(\n        frameState,\n        tileProvider,\n      );\n    }\n  }\n\n  do {\n    let numberOfDayTextures = 0;\n\n    let command;\n    let uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      const obb = tileBoundingRegion.boundingVolume;\n      const boundingSphere = tileBoundingRegion.boundingSphere;\n      // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(boundingSphere)) {\n        getDebugBoundingSphere(boundingSphere, Color.RED).update(frameState);\n      }\n    }\n\n    const uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x =\n      tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y =\n      tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x =\n      tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.atmosphereLightIntensity =\n      tileProvider.atmosphereLightIntensity;\n    uniformMapProperties.atmosphereRayleighCoefficient =\n      tileProvider.atmosphereRayleighCoefficient;\n    uniformMapProperties.atmosphereMieCoefficient =\n      tileProvider.atmosphereMieCoefficient;\n    uniformMapProperties.atmosphereRayleighScaleHeight =\n      tileProvider.atmosphereRayleighScaleHeight;\n    uniformMapProperties.atmosphereMieScaleHeight =\n      tileProvider.atmosphereMieScaleHeight;\n    uniformMapProperties.atmosphereMieAnisotropy =\n      tileProvider.atmosphereMieAnisotropy;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity =\n      tileProvider.zoomedOutOceanSpecularIntensity;\n\n    const frontFaceAlphaByDistanceFinal = cameraUnderground\n      ? backFaceAlphaByDistance\n      : frontFaceAlphaByDistance;\n    const backFaceAlphaByDistanceFinal = cameraUnderground\n      ? frontFaceAlphaByDistance\n      : backFaceAlphaByDistance;\n\n    if (defined(frontFaceAlphaByDistanceFinal)) {\n      Cartesian4.fromElements(\n        frontFaceAlphaByDistanceFinal.near,\n        frontFaceAlphaByDistanceFinal.nearValue,\n        frontFaceAlphaByDistanceFinal.far,\n        frontFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.frontFaceAlphaByDistance,\n      );\n      Cartesian4.fromElements(\n        backFaceAlphaByDistanceFinal.near,\n        backFaceAlphaByDistanceFinal.nearValue,\n        backFaceAlphaByDistanceFinal.far,\n        backFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.backFaceAlphaByDistance,\n      );\n    }\n\n    Cartesian4.fromElements(\n      undergroundColorAlphaByDistance.near,\n      undergroundColorAlphaByDistance.nearValue,\n      undergroundColorAlphaByDistance.far,\n      undergroundColorAlphaByDistance.farValue,\n      uniformMapProperties.undergroundColorAlphaByDistance,\n    );\n    Color.clone(undergroundColor, uniformMapProperties.undergroundColor);\n\n    uniformMapProperties.lambertDiffuseMultiplier = lambertDiffuseMultiplier;\n    uniformMapProperties.vertexShadowDarkness = vertexShadowDarkness;\n\n    const highlightFillTile =\n      !defined(surfaceTile.vertexArray) &&\n      defined(tileProvider.fillHighlightColor) &&\n      tileProvider.fillHighlightColor.alpha > 0.0;\n    if (highlightFillTile) {\n      Color.clone(\n        tileProvider.fillHighlightColor,\n        uniformMapProperties.fillHighlightColor,\n      );\n    }\n\n    uniformMapProperties.verticalExaggerationAndRelativeHeight.x = exaggeration;\n    uniformMapProperties.verticalExaggerationAndRelativeHeight.y =\n      exaggerationRelativeHeight;\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y =\n      oneOverMercatorHeight;\n\n    // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n    const localizedCartographicLimitRectangle =\n      localizedCartographicLimitRectangleScratch;\n    const cartographicLimitRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      tileProvider.cartographicLimitRectangle,\n    );\n\n    const localizedTranslucencyRectangle =\n      localizedTranslucencyRectangleScratch;\n    const clippedTranslucencyRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      translucencyRectangle,\n    );\n\n    Cartesian3.fromElements(\n      hueShift,\n      saturationShift,\n      brightnessShift,\n      uniformMapProperties.hsbShift,\n    );\n\n    const cartographicTileRectangle = tile.rectangle;\n    const inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    const inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x =\n      (cartographicLimitRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.y =\n      (cartographicLimitRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedCartographicLimitRectangle.z =\n      (cartographicLimitRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.w =\n      (cartographicLimitRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedCartographicLimitRectangle,\n      uniformMapProperties.localizedCartographicLimitRectangle,\n    );\n\n    localizedTranslucencyRectangle.x =\n      (clippedTranslucencyRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.y =\n      (clippedTranslucencyRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedTranslucencyRectangle.z =\n      (clippedTranslucencyRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.w =\n      (clippedTranslucencyRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedTranslucencyRectangle,\n      uniformMapProperties.localizedTranslucencyRectangle,\n    );\n\n    // For performance, render fog only when fog is enabled and the effect of\n    // fog would be non-negligible. This prevents the shader from running when\n    // the camera is in space, for example.\n    const applyFog =\n      enableFog &&\n      CesiumMath.fog(tile._distance, frameState.fog.density) >\n        CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n\n    let applyBrightness = false;\n    let applyContrast = false;\n    let applyHue = false;\n    let applySaturation = false;\n    let applyGamma = false;\n    let applyAlpha = false;\n    let applyDayNightAlpha = false;\n    let applySplit = false;\n    let applyCutout = false;\n    let applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      const tileImagery = tileImageryCollection[imageryIndex];\n      const imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      const texture = tileImagery.useWebMercatorT\n        ? imagery.textureWebMercator\n        : imagery.texture;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      }\n      //>>includeEnd('debug');\n\n      const imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale =\n          imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] =\n        tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] =\n        tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] =\n        tileImagery.useWebMercatorT;\n\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] =\n        imageryLayer.alpha;\n      applyAlpha =\n        applyAlpha ||\n        uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] =\n        imageryLayer.nightAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] =\n        imageryLayer.dayAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] =\n        imageryLayer.brightness;\n      applyBrightness =\n        applyBrightness ||\n        uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_BRIGHTNESS;\n\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] =\n        imageryLayer.contrast;\n      applyContrast =\n        applyContrast ||\n        uniformMapProperties.dayTextureContrast[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_CONTRAST;\n\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] =\n        imageryLayer.hue;\n      applyHue =\n        applyHue ||\n        uniformMapProperties.dayTextureHue[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_HUE;\n\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] =\n        imageryLayer.saturation;\n      applySaturation =\n        applySaturation ||\n        uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_SATURATION;\n\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] =\n        1.0 / imageryLayer.gamma;\n      applyGamma =\n        applyGamma ||\n        uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !==\n          1.0 / ImageryLayer.DEFAULT_GAMMA;\n\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] =\n        imageryLayer.splitDirection;\n      applySplit =\n        applySplit ||\n        uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0;\n\n      // Update cutout rectangle\n      let dayTextureCutoutRectangle =\n        uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle =\n          uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures] =\n            new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n      if (defined(imageryLayer.cutoutRectangle)) {\n        const cutoutRectangle = clipRectangleAntimeridian(\n          cartographicTileRectangle,\n          imageryLayer.cutoutRectangle,\n        );\n        const intersection = Rectangle.simpleIntersection(\n          cutoutRectangle,\n          cartographicTileRectangle,\n          rectangleIntersectionScratch,\n        );\n        applyCutout = defined(intersection) || applyCutout;\n\n        dayTextureCutoutRectangle.x =\n          (cutoutRectangle.west - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.y =\n          (cutoutRectangle.south - cartographicTileRectangle.south) *\n          inverseTileHeight;\n        dayTextureCutoutRectangle.z =\n          (cutoutRectangle.east - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.w =\n          (cutoutRectangle.north - cartographicTileRectangle.south) *\n          inverseTileHeight;\n      }\n\n      // Update color to alpha\n      let colorToAlpha =\n        uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures] =\n          new Cartesian4();\n      }\n\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        const credits = imagery.credits;\n        for (\n          let creditIndex = 0, creditLength = credits.length;\n          creditIndex < creditLength;\n          ++creditIndex\n        ) {\n          creditDisplay.addCreditToNextFrame(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    }\n\n    // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(\n      waterMaskTranslationAndScale,\n      uniformMapProperties.waterMaskTranslationAndScale,\n    );\n\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias);\n\n    // update clipping planes\n    const clippingPlanes = tileProvider._clippingPlanes;\n    const clippingPlanesEnabled =\n      defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(\n        clippingPlanes.edgeColor,\n        uniformMapProperties.clippingPlanesEdgeColor,\n      );\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    // update clipping polygons\n    const clippingPolygons = tileProvider._clippingPolygons;\n    const clippingPolygonsEnabled =\n      defined(clippingPolygons) && clippingPolygons.enabled && tile.isClipped;\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applyDayNightAlpha = applyDayNightAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.enableClippingPolygons = clippingPolygonsEnabled;\n    surfaceShaderSetOptions.clippingPolygons = clippingPolygons;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    surfaceShaderSetOptions.showUndergroundColor = showUndergroundColor;\n    surfaceShaderSetOptions.translucent = translucent;\n\n    let count = surfaceTile.renderedMesh.indices.length;\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(\n      surfaceShaderSetOptions,\n    );\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray =\n      surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    let boundingVolume = command.boundingVolume;\n    const orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        frameState.mapProjection,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        boundingVolume,\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center,\n      );\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(\n          tileBoundingRegion.boundingSphere,\n          boundingVolume,\n          boundingVolume,\n        );\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(\n        tileBoundingRegion.boundingSphere,\n        boundingVolume,\n      );\n      command.orientedBoundingBox = OrientedBoundingBox.clone(\n        tileBoundingRegion.boundingVolume,\n        orientedBoundingBox,\n      );\n    }\n\n    command.dirty = true;\n\n    if (translucent) {\n      globeTranslucencyState.updateDerivedCommands(command, frameState);\n    }\n\n    pushCommand(command, frameState);\n\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\nexport default GlobeSurfaceTileProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}