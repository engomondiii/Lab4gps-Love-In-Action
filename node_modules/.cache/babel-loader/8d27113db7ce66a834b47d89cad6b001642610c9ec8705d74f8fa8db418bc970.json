{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Box defines (set in Scene/VoxelBoxShape.js)\\n\\\n#define BOX_HAS_SHAPE_BOUNDS\\n\\\n*/\\n\\\n\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    uniform vec3 u_boxUvToShapeUvScale;\\n\\\n    uniform vec3 u_boxUvToShapeUvTranslate;\\n\\\n#endif\\n\\\n\\n\\\nPointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {\\n\\\n    // For BOX, UV space = shape space, so we can use positionUv as-is,\\n\\\n    // and the Jacobian is the identity matrix, except that a step of 1\\n\\\n    // only spans half the shape space [-1, 1], so the identity is scaled.\\n\\\n    return PointJacobianT(positionUv, mat3(0.5));\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeToShapeUvSpace(in vec3 positionShape) {\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    return positionShape * u_boxUvToShapeUvScale + u_boxUvToShapeUvTranslate;\\n\\\n#else\\n\\\n    return positionShape;\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);\\n\\\n    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);\\n\\\n    return pointJacobian;\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeUvToUvSpace(in vec3 shapeUv) {\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    return (shapeUv - u_boxUvToShapeUvTranslate) / u_boxUvToShapeUvScale;\\n\\\n#else\\n\\\n    return shapeUv;\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    return shapeUv / u_boxUvToShapeUvScale;\\n\\\n#else\\n\\\n    return shapeUv;\\n\\\n#endif\\n\\\n}\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/convertUvToBox.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Box defines (set in Scene/VoxelBoxShape.js)\\n\\\n#define BOX_HAS_SHAPE_BOUNDS\\n\\\n*/\\n\\\n\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    uniform vec3 u_boxUvToShapeUvScale;\\n\\\n    uniform vec3 u_boxUvToShapeUvTranslate;\\n\\\n#endif\\n\\\n\\n\\\nPointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {\\n\\\n    // For BOX, UV space = shape space, so we can use positionUv as-is,\\n\\\n    // and the Jacobian is the identity matrix, except that a step of 1\\n\\\n    // only spans half the shape space [-1, 1], so the identity is scaled.\\n\\\n    return PointJacobianT(positionUv, mat3(0.5));\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeToShapeUvSpace(in vec3 positionShape) {\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    return positionShape * u_boxUvToShapeUvScale + u_boxUvToShapeUvTranslate;\\n\\\n#else\\n\\\n    return positionShape;\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nPointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);\\n\\\n    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);\\n\\\n    return pointJacobian;\\n\\\n}\\n\\\n\\n\\\nvec3 convertShapeUvToUvSpace(in vec3 shapeUv) {\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    return (shapeUv - u_boxUvToShapeUvTranslate) / u_boxUvToShapeUvScale;\\n\\\n#else\\n\\\n    return shapeUv;\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n#if defined(BOX_HAS_SHAPE_BOUNDS)\\n\\\n    return shapeUv / u_boxUvToShapeUvScale;\\n\\\n#else\\n\\\n    return shapeUv;\\n\\\n#endif\\n\\\n}\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}