{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nconst PolylinePipeline = {};\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  const radiansDistanceSquared = Math.pow(p0.longitude - p1.longitude, 2) + Math.pow(p0.latitude - p1.latitude, 2);\n  return Math.max(1, Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity))));\n};\nconst cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  const length = positions.length;\n  const heights = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\nconst wrapLongitudeInversMatrix = new Matrix4();\nconst wrapLongitudeOrigin = new Cartesian3();\nconst wrapLongitudeXZNormal = new Cartesian3();\nconst wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeYZNormal = new Cartesian3();\nconst wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeIntersection = new Cartesian3();\nconst wrapLongitudeOffset = new Cartesian3();\nconst subdivideHeightsScratchArray = [];\nfunction subdivideHeights(numPoints, h0, h1) {\n  const heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n  for (i = 0; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n  return heights;\n}\nconst carto1 = new Cartographic();\nconst carto2 = new Cartographic();\nconst cartesian = new Cartesian3();\nconst scaleFirst = new Cartesian3();\nconst scaleLast = new Cartesian3();\nconst ellipsoidGeodesic = new EllipsoidGeodesic();\nlet ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\n  const first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  const last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  const start = ellipsoid.cartesianToCartographic(first, carto1);\n  const end = ellipsoid.cartesianToCartographic(last, carto2);\n  const heights = subdivideHeights(numPoints, h0, h1);\n  ellipsoidGeodesic.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, array, offset) {\n  const start = ellipsoid.cartesianToCartographic(p0, carto1);\n  const end = ellipsoid.cartesianToCartographic(p1, carto2);\n  const numPoints = PolylinePipeline.numberOfPointsRhumbLine(start, end, granularity);\n  start.height = 0.0;\n  end.height = 0.0;\n  const heights = subdivideHeights(numPoints, h0, h1);\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  const cartesians = [];\n  const segments = [];\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    const inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\n    const origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\n    const xzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal), wrapLongitudeXZNormal);\n    const xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n    const yzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal), wrapLongitudeYZNormal);\n    const yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n    let count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    let prev = cartesians[0];\n    const length = positions.length;\n    for (let i = 1; i < length; ++i) {\n      const cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\n        // and intersects the xz-plane\n        const intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          const offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n          cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n          segments.push(count + 1);\n          Cartesian3.negate(offset, offset);\n          cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n          count = 1;\n        }\n      }\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n      prev = cur;\n    }\n    segments.push(count);\n  }\n  return {\n    positions: cartesians,\n    lengths: segments\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {number[]} A new array of positions of type {number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n    return [p.x, p.y, p.z];\n  }\n  let minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n  let numPoints = 0;\n  let i;\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);\n  }\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n    offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\n  }\n  subdivideHeightsScratchArray.length = 0;\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n  return newPositions;\n};\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {number[]} A new array of positions of type {number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n    return [p.x, p.y, p.z];\n  }\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  let numPoints = 0;\n  let i;\n  let c0 = ellipsoid.cartesianToCartographic(positions[0], scratchCartographic0);\n  let c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(positions[i + 1], scratchCartographic1);\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n    offset = generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, newPositions, offset);\n  }\n  subdivideHeightsScratchArray.length = 0;\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  const numberArray = PolylinePipeline.generateArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  const numberArray = PolylinePipeline.generateRhumbArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;","map":{"version":3,"names":["Cartesian3","Cartographic","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidGeodesic","EllipsoidRhumbLine","IntersectionTests","CesiumMath","Matrix4","Plane","PolylinePipeline","numberOfPoints","p0","p1","minDistance","distance","Math","ceil","numberOfPointsRhumbLine","granularity","radiansDistanceSquared","pow","longitude","latitude","max","sqrt","cartoScratch","extractHeights","positions","ellipsoid","length","heights","Array","i","p","cartesianToCartographic","height","wrapLongitudeInversMatrix","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","dHeight","heightPerVertex","h","carto1","carto2","cartesian","scaleFirst","scaleLast","ellipsoidGeodesic","ellipsoidRhumb","generateCartesianArc","array","offset","first","scaleToGeodeticSurface","last","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","index","cart","cartographicToCartesian","pack","carto","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","equals","undefined","wrapLongitude","modelMatrix","cartesians","segments","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","ZERO","xzNormal","normalize","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","push","clone","prev","cur","getPointDistance","intersection","lineSegmentPlane","multiplyByScalar","negate","add","lengths","generateArc","options","default","hasHeightArray","isArray","n","geodeticSurfaceNormal","x","y","z","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c0","c1","numberArray","size","unpack"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/PolylinePipeline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nconst PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  const radiansDistanceSquared =\n    Math.pow(p0.longitude - p1.longitude, 2) +\n    Math.pow(p0.latitude - p1.latitude, 2);\n\n  return Math.max(\n    1,\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity))),\n  );\n};\n\nconst cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  const length = positions.length;\n  const heights = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\n\nconst wrapLongitudeInversMatrix = new Matrix4();\nconst wrapLongitudeOrigin = new Cartesian3();\nconst wrapLongitudeXZNormal = new Cartesian3();\nconst wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeYZNormal = new Cartesian3();\nconst wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeIntersection = new Cartesian3();\nconst wrapLongitudeOffset = new Cartesian3();\n\nconst subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  const heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nconst carto1 = new Cartographic();\nconst carto2 = new Cartographic();\nconst cartesian = new Cartesian3();\nconst scaleFirst = new Cartesian3();\nconst scaleLast = new Cartesian3();\nconst ellipsoidGeodesic = new EllipsoidGeodesic();\nlet ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(\n  p0,\n  p1,\n  minDistance,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset,\n) {\n  const first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  const last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  const start = ellipsoid.cartesianToCartographic(first, carto1);\n  const end = ellipsoid.cartesianToCartographic(last, carto2);\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  ellipsoidGeodesic.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidGeodesic.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2,\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(\n  p0,\n  p1,\n  granularity,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset,\n) {\n  const start = ellipsoid.cartesianToCartographic(p0, carto1);\n  const end = ellipsoid.cartesianToCartographic(p1, carto2);\n  const numPoints = PolylinePipeline.numberOfPointsRhumbLine(\n    start,\n    end,\n    granularity,\n  );\n  start.height = 0.0;\n  end.height = 0.0;\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidRhumb.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2,\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  const cartesians = [];\n  const segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    const inverseModelMatrix = Matrix4.inverseTransformation(\n      modelMatrix,\n      wrapLongitudeInversMatrix,\n    );\n\n    const origin = Matrix4.multiplyByPoint(\n      inverseModelMatrix,\n      Cartesian3.ZERO,\n      wrapLongitudeOrigin,\n    );\n    const xzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_Y,\n        wrapLongitudeXZNormal,\n      ),\n      wrapLongitudeXZNormal,\n    );\n    const xzPlane = Plane.fromPointNormal(\n      origin,\n      xzNormal,\n      wrapLongitudeXZPlane,\n    );\n    const yzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_X,\n        wrapLongitudeYZNormal,\n      ),\n      wrapLongitudeYZNormal,\n    );\n    const yzPlane = Plane.fromPointNormal(\n      origin,\n      yzNormal,\n      wrapLongitudeYZPlane,\n    );\n\n    let count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    let prev = cartesians[0];\n\n    const length = positions.length;\n    for (let i = 1; i < length; ++i) {\n      const cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\n        Plane.getPointDistance(yzPlane, cur) < 0.0\n      ) {\n        // and intersects the xz-plane\n        const intersection = IntersectionTests.lineSegmentPlane(\n          prev,\n          cur,\n          xzPlane,\n          wrapLongitudeIntersection,\n        );\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          const offset = Cartesian3.multiplyByScalar(\n            xzNormal,\n            5.0e-9,\n            wrapLongitudeOffset,\n          );\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3()),\n          );\n          segments.push(count + 1);\n\n          Cartesian3.negate(offset, offset);\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3()),\n          );\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments,\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {number[]} A new array of positions of type {number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  let minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    const granularity = defaultValue(\n      options.granularity,\n      CesiumMath.RADIANS_PER_DEGREE,\n    );\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  let numPoints = 0;\n  let i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(\n      positions[i],\n      positions[i + 1],\n      minDistance,\n    );\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianArc(\n      p0,\n      p1,\n      minDistance,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset,\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {number[]} A new array of positions of type {number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n\n  let numPoints = 0;\n  let i;\n\n  let c0 = ellipsoid.cartesianToCartographic(\n    positions[0],\n    scratchCartographic0,\n  );\n  let c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(\n      positions[i + 1],\n      scratchCartographic1,\n    );\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianRhumbArc(\n      p0,\n      p1,\n      granularity,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset,\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  const numberArray = PolylinePipeline.generateArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {number|number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  const numberArray = PolylinePipeline.generateRhumbArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,iBAAiB;AACxC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,UAAU,MAAM,WAAW;AAClC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,KAAK,MAAM,YAAY;;AAE9B;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC,CAAC;AAE3BA,gBAAgB,CAACC,cAAc,GAAG,UAAUC,EAAE,EAAEC,EAAE,EAAEC,WAAW,EAAE;EAC/D,MAAMC,QAAQ,GAAGjB,UAAU,CAACiB,QAAQ,CAACH,EAAE,EAAEC,EAAE,CAAC;EAC5C,OAAOG,IAAI,CAACC,IAAI,CAACF,QAAQ,GAAGD,WAAW,CAAC;AAC1C,CAAC;AAEDJ,gBAAgB,CAACQ,uBAAuB,GAAG,UAAUN,EAAE,EAAEC,EAAE,EAAEM,WAAW,EAAE;EACxE,MAAMC,sBAAsB,GAC1BJ,IAAI,CAACK,GAAG,CAACT,EAAE,CAACU,SAAS,GAAGT,EAAE,CAACS,SAAS,EAAE,CAAC,CAAC,GACxCN,IAAI,CAACK,GAAG,CAACT,EAAE,CAACW,QAAQ,GAAGV,EAAE,CAACU,QAAQ,EAAE,CAAC,CAAC;EAExC,OAAOP,IAAI,CAACQ,GAAG,CACb,CAAC,EACDR,IAAI,CAACC,IAAI,CAACD,IAAI,CAACS,IAAI,CAACL,sBAAsB,IAAID,WAAW,GAAGA,WAAW,CAAC,CAAC,CAC3E,CAAC;AACH,CAAC;AAED,MAAMO,YAAY,GAAG,IAAI3B,YAAY,CAAC,CAAC;AACvCW,gBAAgB,CAACiB,cAAc,GAAG,UAAUC,SAAS,EAAEC,SAAS,EAAE;EAChE,MAAMC,MAAM,GAAGF,SAAS,CAACE,MAAM;EAC/B,MAAMC,OAAO,GAAG,IAAIC,KAAK,CAACF,MAAM,CAAC;EACjC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,EAAEG,CAAC,EAAE,EAAE;IAC/B,MAAMC,CAAC,GAAGN,SAAS,CAACK,CAAC,CAAC;IACtBF,OAAO,CAACE,CAAC,CAAC,GAAGJ,SAAS,CAACM,uBAAuB,CAACD,CAAC,EAAER,YAAY,CAAC,CAACU,MAAM;EACxE;EACA,OAAOL,OAAO;AAChB,CAAC;AAED,MAAMM,yBAAyB,GAAG,IAAI7B,OAAO,CAAC,CAAC;AAC/C,MAAM8B,mBAAmB,GAAG,IAAIxC,UAAU,CAAC,CAAC;AAC5C,MAAMyC,qBAAqB,GAAG,IAAIzC,UAAU,CAAC,CAAC;AAC9C,MAAM0C,oBAAoB,GAAG,IAAI/B,KAAK,CAACX,UAAU,CAAC2C,MAAM,EAAE,GAAG,CAAC;AAC9D,MAAMC,qBAAqB,GAAG,IAAI5C,UAAU,CAAC,CAAC;AAC9C,MAAM6C,oBAAoB,GAAG,IAAIlC,KAAK,CAACX,UAAU,CAAC2C,MAAM,EAAE,GAAG,CAAC;AAC9D,MAAMG,yBAAyB,GAAG,IAAI9C,UAAU,CAAC,CAAC;AAClD,MAAM+C,mBAAmB,GAAG,IAAI/C,UAAU,CAAC,CAAC;AAE5C,MAAMgD,4BAA4B,GAAG,EAAE;AAEvC,SAASC,gBAAgBA,CAACC,SAAS,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAC3C,MAAMnB,OAAO,GAAGe,4BAA4B;EAC5Cf,OAAO,CAACD,MAAM,GAAGkB,SAAS;EAE1B,IAAIf,CAAC;EACL,IAAIgB,EAAE,KAAKC,EAAE,EAAE;IACb,KAAKjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,SAAS,EAAEf,CAAC,EAAE,EAAE;MAC9BF,OAAO,CAACE,CAAC,CAAC,GAAGgB,EAAE;IACjB;IACA,OAAOlB,OAAO;EAChB;EAEA,MAAMoB,OAAO,GAAGD,EAAE,GAAGD,EAAE;EACvB,MAAMG,eAAe,GAAGD,OAAO,GAAGH,SAAS;EAE3C,KAAKf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,SAAS,EAAEf,CAAC,EAAE,EAAE;IAC9B,MAAMoB,CAAC,GAAGJ,EAAE,GAAGhB,CAAC,GAAGmB,eAAe;IAClCrB,OAAO,CAACE,CAAC,CAAC,GAAGoB,CAAC;EAChB;EAEA,OAAOtB,OAAO;AAChB;AAEA,MAAMuB,MAAM,GAAG,IAAIvD,YAAY,CAAC,CAAC;AACjC,MAAMwD,MAAM,GAAG,IAAIxD,YAAY,CAAC,CAAC;AACjC,MAAMyD,SAAS,GAAG,IAAI1D,UAAU,CAAC,CAAC;AAClC,MAAM2D,UAAU,GAAG,IAAI3D,UAAU,CAAC,CAAC;AACnC,MAAM4D,SAAS,GAAG,IAAI5D,UAAU,CAAC,CAAC;AAClC,MAAM6D,iBAAiB,GAAG,IAAIvD,iBAAiB,CAAC,CAAC;AACjD,IAAIwD,cAAc,GAAG,IAAIvD,kBAAkB,CAAC,CAAC;;AAE7C;AACA;AACA;AACA,SAASwD,oBAAoBA,CAC3BjD,EAAE,EACFC,EAAE,EACFC,WAAW,EACXe,SAAS,EACToB,EAAE,EACFC,EAAE,EACFY,KAAK,EACLC,MAAM,EACN;EACA,MAAMC,KAAK,GAAGnC,SAAS,CAACoC,sBAAsB,CAACrD,EAAE,EAAE6C,UAAU,CAAC;EAC9D,MAAMS,IAAI,GAAGrC,SAAS,CAACoC,sBAAsB,CAACpD,EAAE,EAAE6C,SAAS,CAAC;EAC5D,MAAMV,SAAS,GAAGtC,gBAAgB,CAACC,cAAc,CAACC,EAAE,EAAEC,EAAE,EAAEC,WAAW,CAAC;EACtE,MAAMqD,KAAK,GAAGtC,SAAS,CAACM,uBAAuB,CAAC6B,KAAK,EAAEV,MAAM,CAAC;EAC9D,MAAMc,GAAG,GAAGvC,SAAS,CAACM,uBAAuB,CAAC+B,IAAI,EAAEX,MAAM,CAAC;EAC3D,MAAMxB,OAAO,GAAGgB,gBAAgB,CAACC,SAAS,EAAEC,EAAE,EAAEC,EAAE,CAAC;EAEnDS,iBAAiB,CAACU,YAAY,CAACF,KAAK,EAAEC,GAAG,CAAC;EAC1C,MAAME,4BAA4B,GAChCX,iBAAiB,CAACY,eAAe,GAAGvB,SAAS;EAE/C,IAAIwB,KAAK,GAAGT,MAAM;EAClBI,KAAK,CAAC/B,MAAM,GAAGa,EAAE;EACjB,IAAIwB,IAAI,GAAG5C,SAAS,CAAC6C,uBAAuB,CAACP,KAAK,EAAEX,SAAS,CAAC;EAC9D1D,UAAU,CAAC6E,IAAI,CAACF,IAAI,EAAEX,KAAK,EAAEU,KAAK,CAAC;EACnCA,KAAK,IAAI,CAAC;EAEV,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,SAAS,EAAEf,CAAC,EAAE,EAAE;IAClC,MAAM2C,KAAK,GAAGjB,iBAAiB,CAACkB,+BAA+B,CAC7D5C,CAAC,GAAGqC,4BAA4B,EAChCf,MACF,CAAC;IACDqB,KAAK,CAACxC,MAAM,GAAGL,OAAO,CAACE,CAAC,CAAC;IACzBwC,IAAI,GAAG5C,SAAS,CAAC6C,uBAAuB,CAACE,KAAK,EAAEpB,SAAS,CAAC;IAC1D1D,UAAU,CAAC6E,IAAI,CAACF,IAAI,EAAEX,KAAK,EAAEU,KAAK,CAAC;IACnCA,KAAK,IAAI,CAAC;EACZ;EAEA,OAAOA,KAAK;AACd;;AAEA;AACA;AACA;AACA,SAASM,yBAAyBA,CAChClE,EAAE,EACFC,EAAE,EACFM,WAAW,EACXU,SAAS,EACToB,EAAE,EACFC,EAAE,EACFY,KAAK,EACLC,MAAM,EACN;EACA,MAAMI,KAAK,GAAGtC,SAAS,CAACM,uBAAuB,CAACvB,EAAE,EAAE0C,MAAM,CAAC;EAC3D,MAAMc,GAAG,GAAGvC,SAAS,CAACM,uBAAuB,CAACtB,EAAE,EAAE0C,MAAM,CAAC;EACzD,MAAMP,SAAS,GAAGtC,gBAAgB,CAACQ,uBAAuB,CACxDiD,KAAK,EACLC,GAAG,EACHjD,WACF,CAAC;EACDgD,KAAK,CAAC/B,MAAM,GAAG,GAAG;EAClBgC,GAAG,CAAChC,MAAM,GAAG,GAAG;EAChB,MAAML,OAAO,GAAGgB,gBAAgB,CAACC,SAAS,EAAEC,EAAE,EAAEC,EAAE,CAAC;EAEnD,IAAI,CAACU,cAAc,CAAC/B,SAAS,CAACkD,MAAM,CAAClD,SAAS,CAAC,EAAE;IAC/C+B,cAAc,GAAG,IAAIvD,kBAAkB,CAAC2E,SAAS,EAAEA,SAAS,EAAEnD,SAAS,CAAC;EAC1E;EACA+B,cAAc,CAACS,YAAY,CAACF,KAAK,EAAEC,GAAG,CAAC;EACvC,MAAME,4BAA4B,GAChCV,cAAc,CAACW,eAAe,GAAGvB,SAAS;EAE5C,IAAIwB,KAAK,GAAGT,MAAM;EAClBI,KAAK,CAAC/B,MAAM,GAAGa,EAAE;EACjB,IAAIwB,IAAI,GAAG5C,SAAS,CAAC6C,uBAAuB,CAACP,KAAK,EAAEX,SAAS,CAAC;EAC9D1D,UAAU,CAAC6E,IAAI,CAACF,IAAI,EAAEX,KAAK,EAAEU,KAAK,CAAC;EACnCA,KAAK,IAAI,CAAC;EAEV,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,SAAS,EAAEf,CAAC,EAAE,EAAE;IAClC,MAAM2C,KAAK,GAAGhB,cAAc,CAACiB,+BAA+B,CAC1D5C,CAAC,GAAGqC,4BAA4B,EAChCf,MACF,CAAC;IACDqB,KAAK,CAACxC,MAAM,GAAGL,OAAO,CAACE,CAAC,CAAC;IACzBwC,IAAI,GAAG5C,SAAS,CAAC6C,uBAAuB,CAACE,KAAK,EAAEpB,SAAS,CAAC;IAC1D1D,UAAU,CAAC6E,IAAI,CAACF,IAAI,EAAEX,KAAK,EAAEU,KAAK,CAAC;IACnCA,KAAK,IAAI,CAAC;EACZ;EAEA,OAAOA,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9D,gBAAgB,CAACuE,aAAa,GAAG,UAAUrD,SAAS,EAAEsD,WAAW,EAAE;EACjE,MAAMC,UAAU,GAAG,EAAE;EACrB,MAAMC,QAAQ,GAAG,EAAE;EAEnB,IAAInF,OAAO,CAAC2B,SAAS,CAAC,IAAIA,SAAS,CAACE,MAAM,GAAG,CAAC,EAAE;IAC9CoD,WAAW,GAAGlF,YAAY,CAACkF,WAAW,EAAE1E,OAAO,CAAC6E,QAAQ,CAAC;IACzD,MAAMC,kBAAkB,GAAG9E,OAAO,CAAC+E,qBAAqB,CACtDL,WAAW,EACX7C,yBACF,CAAC;IAED,MAAMmD,MAAM,GAAGhF,OAAO,CAACiF,eAAe,CACpCH,kBAAkB,EAClBxF,UAAU,CAAC4F,IAAI,EACfpD,mBACF,CAAC;IACD,MAAMqD,QAAQ,GAAG7F,UAAU,CAAC8F,SAAS,CACnCpF,OAAO,CAACqF,uBAAuB,CAC7BP,kBAAkB,EAClBxF,UAAU,CAACgG,MAAM,EACjBvD,qBACF,CAAC,EACDA,qBACF,CAAC;IACD,MAAMwD,OAAO,GAAGtF,KAAK,CAACuF,eAAe,CACnCR,MAAM,EACNG,QAAQ,EACRnD,oBACF,CAAC;IACD,MAAMyD,QAAQ,GAAGnG,UAAU,CAAC8F,SAAS,CACnCpF,OAAO,CAACqF,uBAAuB,CAC7BP,kBAAkB,EAClBxF,UAAU,CAAC2C,MAAM,EACjBC,qBACF,CAAC,EACDA,qBACF,CAAC;IACD,MAAMwD,OAAO,GAAGzF,KAAK,CAACuF,eAAe,CACnCR,MAAM,EACNS,QAAQ,EACRtD,oBACF,CAAC;IAED,IAAIwD,KAAK,GAAG,CAAC;IACbhB,UAAU,CAACiB,IAAI,CAACtG,UAAU,CAACuG,KAAK,CAACzE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAI0E,IAAI,GAAGnB,UAAU,CAAC,CAAC,CAAC;IAExB,MAAMrD,MAAM,GAAGF,SAAS,CAACE,MAAM;IAC/B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,EAAE,EAAEG,CAAC,EAAE;MAC/B,MAAMsE,GAAG,GAAG3E,SAAS,CAACK,CAAC,CAAC;;MAExB;MACA,IACExB,KAAK,CAAC+F,gBAAgB,CAACN,OAAO,EAAEI,IAAI,CAAC,GAAG,GAAG,IAC3C7F,KAAK,CAAC+F,gBAAgB,CAACN,OAAO,EAAEK,GAAG,CAAC,GAAG,GAAG,EAC1C;QACA;QACA,MAAME,YAAY,GAAGnG,iBAAiB,CAACoG,gBAAgB,CACrDJ,IAAI,EACJC,GAAG,EACHR,OAAO,EACPnD,yBACF,CAAC;QACD,IAAI3C,OAAO,CAACwG,YAAY,CAAC,EAAE;UACzB;UACA,MAAM1C,MAAM,GAAGjE,UAAU,CAAC6G,gBAAgB,CACxChB,QAAQ,EACR,MAAM,EACN9C,mBACF,CAAC;UACD,IAAIpC,KAAK,CAAC+F,gBAAgB,CAACT,OAAO,EAAEO,IAAI,CAAC,GAAG,GAAG,EAAE;YAC/CxG,UAAU,CAAC8G,MAAM,CAAC7C,MAAM,EAAEA,MAAM,CAAC;UACnC;UAEAoB,UAAU,CAACiB,IAAI,CACbtG,UAAU,CAAC+G,GAAG,CAACJ,YAAY,EAAE1C,MAAM,EAAE,IAAIjE,UAAU,CAAC,CAAC,CACvD,CAAC;UACDsF,QAAQ,CAACgB,IAAI,CAACD,KAAK,GAAG,CAAC,CAAC;UAExBrG,UAAU,CAAC8G,MAAM,CAAC7C,MAAM,EAAEA,MAAM,CAAC;UACjCoB,UAAU,CAACiB,IAAI,CACbtG,UAAU,CAAC+G,GAAG,CAACJ,YAAY,EAAE1C,MAAM,EAAE,IAAIjE,UAAU,CAAC,CAAC,CACvD,CAAC;UACDqG,KAAK,GAAG,CAAC;QACX;MACF;MAEAhB,UAAU,CAACiB,IAAI,CAACtG,UAAU,CAACuG,KAAK,CAACzE,SAAS,CAACK,CAAC,CAAC,CAAC,CAAC;MAC/CkE,KAAK,EAAE;MAEPG,IAAI,GAAGC,GAAG;IACZ;IAEAnB,QAAQ,CAACgB,IAAI,CAACD,KAAK,CAAC;EACtB;EAEA,OAAO;IACLvE,SAAS,EAAEuD,UAAU;IACrB2B,OAAO,EAAE1B;EACX,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1E,gBAAgB,CAACqG,WAAW,GAAG,UAAUC,OAAO,EAAE;EAChD,IAAI,CAAC/G,OAAO,CAAC+G,OAAO,CAAC,EAAE;IACrBA,OAAO,GAAG,CAAC,CAAC;EACd;EACA,MAAMpF,SAAS,GAAGoF,OAAO,CAACpF,SAAS;EACnC;EACA,IAAI,CAAC3B,OAAO,CAAC2B,SAAS,CAAC,EAAE;IACvB,MAAM,IAAI1B,cAAc,CAAC,gCAAgC,CAAC;EAC5D;EACA;;EAEA,MAAM4B,MAAM,GAAGF,SAAS,CAACE,MAAM;EAC/B,MAAMD,SAAS,GAAG7B,YAAY,CAACgH,OAAO,CAACnF,SAAS,EAAE1B,SAAS,CAAC8G,OAAO,CAAC;EACpE,IAAI7E,MAAM,GAAGpC,YAAY,CAACgH,OAAO,CAAC5E,MAAM,EAAE,CAAC,CAAC;EAC5C,MAAM8E,cAAc,GAAGlF,KAAK,CAACmF,OAAO,CAAC/E,MAAM,CAAC;EAE5C,IAAIN,MAAM,GAAG,CAAC,EAAE;IACd,OAAO,EAAE;EACX,CAAC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;IACvB,MAAMI,CAAC,GAAGL,SAAS,CAACoC,sBAAsB,CAACrC,SAAS,CAAC,CAAC,CAAC,EAAE6B,UAAU,CAAC;IACpErB,MAAM,GAAG8E,cAAc,GAAG9E,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM;IAC5C,IAAIA,MAAM,KAAK,CAAC,EAAE;MAChB,MAAMgF,CAAC,GAAGvF,SAAS,CAACwF,qBAAqB,CAACnF,CAAC,EAAEsB,SAAS,CAAC;MACvD1D,UAAU,CAAC6G,gBAAgB,CAACS,CAAC,EAAEhF,MAAM,EAAEgF,CAAC,CAAC;MACzCtH,UAAU,CAAC+G,GAAG,CAAC3E,CAAC,EAAEkF,CAAC,EAAElF,CAAC,CAAC;IACzB;IAEA,OAAO,CAACA,CAAC,CAACoF,CAAC,EAAEpF,CAAC,CAACqF,CAAC,EAAErF,CAAC,CAACsF,CAAC,CAAC;EACxB;EAEA,IAAI1G,WAAW,GAAGkG,OAAO,CAAClG,WAAW;EACrC,IAAI,CAACb,OAAO,CAACa,WAAW,CAAC,EAAE;IACzB,MAAMK,WAAW,GAAGnB,YAAY,CAC9BgH,OAAO,CAAC7F,WAAW,EACnBZ,UAAU,CAACkH,kBACb,CAAC;IACD3G,WAAW,GAAGP,UAAU,CAACmH,WAAW,CAACvG,WAAW,EAAEU,SAAS,CAAC8F,aAAa,CAAC;EAC5E;EAEA,IAAI3E,SAAS,GAAG,CAAC;EACjB,IAAIf,CAAC;EAEL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;IAC/Be,SAAS,IAAItC,gBAAgB,CAACC,cAAc,CAC1CiB,SAAS,CAACK,CAAC,CAAC,EACZL,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC,EAChBnB,WACF,CAAC;EACH;EAEA,MAAM8G,WAAW,GAAG,CAAC5E,SAAS,GAAG,CAAC,IAAI,CAAC;EACvC,MAAM6E,YAAY,GAAG,IAAI7F,KAAK,CAAC4F,WAAW,CAAC;EAC3C,IAAI7D,MAAM,GAAG,CAAC;EAEd,KAAK9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;IAC/B,MAAMrB,EAAE,GAAGgB,SAAS,CAACK,CAAC,CAAC;IACvB,MAAMpB,EAAE,GAAGe,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC;IAE3B,MAAMgB,EAAE,GAAGiE,cAAc,GAAG9E,MAAM,CAACH,CAAC,CAAC,GAAGG,MAAM;IAC9C,MAAMc,EAAE,GAAGgE,cAAc,GAAG9E,MAAM,CAACH,CAAC,GAAG,CAAC,CAAC,GAAGG,MAAM;IAElD2B,MAAM,GAAGF,oBAAoB,CAC3BjD,EAAE,EACFC,EAAE,EACFC,WAAW,EACXe,SAAS,EACToB,EAAE,EACFC,EAAE,EACF2E,YAAY,EACZ9D,MACF,CAAC;EACH;EAEAjB,4BAA4B,CAAChB,MAAM,GAAG,CAAC;EAEvC,MAAMgG,SAAS,GAAGlG,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;EACvC,MAAM8C,KAAK,GAAG/C,SAAS,CAACM,uBAAuB,CAAC2F,SAAS,EAAExE,MAAM,CAAC;EAClEsB,KAAK,CAACxC,MAAM,GAAG8E,cAAc,GAAG9E,MAAM,CAACN,MAAM,GAAG,CAAC,CAAC,GAAGM,MAAM;EAC3D,MAAMqC,IAAI,GAAG5C,SAAS,CAAC6C,uBAAuB,CAACE,KAAK,EAAEpB,SAAS,CAAC;EAChE1D,UAAU,CAAC6E,IAAI,CAACF,IAAI,EAAEoD,YAAY,EAAED,WAAW,GAAG,CAAC,CAAC;EAEpD,OAAOC,YAAY;AACrB,CAAC;AAED,MAAME,oBAAoB,GAAG,IAAIhI,YAAY,CAAC,CAAC;AAC/C,MAAMiI,oBAAoB,GAAG,IAAIjI,YAAY,CAAC,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAW,gBAAgB,CAACuH,gBAAgB,GAAG,UAAUjB,OAAO,EAAE;EACrD,IAAI,CAAC/G,OAAO,CAAC+G,OAAO,CAAC,EAAE;IACrBA,OAAO,GAAG,CAAC,CAAC;EACd;EACA,MAAMpF,SAAS,GAAGoF,OAAO,CAACpF,SAAS;EACnC;EACA,IAAI,CAAC3B,OAAO,CAAC2B,SAAS,CAAC,EAAE;IACvB,MAAM,IAAI1B,cAAc,CAAC,gCAAgC,CAAC;EAC5D;EACA;;EAEA,MAAM4B,MAAM,GAAGF,SAAS,CAACE,MAAM;EAC/B,MAAMD,SAAS,GAAG7B,YAAY,CAACgH,OAAO,CAACnF,SAAS,EAAE1B,SAAS,CAAC8G,OAAO,CAAC;EACpE,IAAI7E,MAAM,GAAGpC,YAAY,CAACgH,OAAO,CAAC5E,MAAM,EAAE,CAAC,CAAC;EAC5C,MAAM8E,cAAc,GAAGlF,KAAK,CAACmF,OAAO,CAAC/E,MAAM,CAAC;EAE5C,IAAIN,MAAM,GAAG,CAAC,EAAE;IACd,OAAO,EAAE;EACX,CAAC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;IACvB,MAAMI,CAAC,GAAGL,SAAS,CAACoC,sBAAsB,CAACrC,SAAS,CAAC,CAAC,CAAC,EAAE6B,UAAU,CAAC;IACpErB,MAAM,GAAG8E,cAAc,GAAG9E,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM;IAC5C,IAAIA,MAAM,KAAK,CAAC,EAAE;MAChB,MAAMgF,CAAC,GAAGvF,SAAS,CAACwF,qBAAqB,CAACnF,CAAC,EAAEsB,SAAS,CAAC;MACvD1D,UAAU,CAAC6G,gBAAgB,CAACS,CAAC,EAAEhF,MAAM,EAAEgF,CAAC,CAAC;MACzCtH,UAAU,CAAC+G,GAAG,CAAC3E,CAAC,EAAEkF,CAAC,EAAElF,CAAC,CAAC;IACzB;IAEA,OAAO,CAACA,CAAC,CAACoF,CAAC,EAAEpF,CAAC,CAACqF,CAAC,EAAErF,CAAC,CAACsF,CAAC,CAAC;EACxB;EAEA,MAAMrG,WAAW,GAAGnB,YAAY,CAC9BgH,OAAO,CAAC7F,WAAW,EACnBZ,UAAU,CAACkH,kBACb,CAAC;EAED,IAAIzE,SAAS,GAAG,CAAC;EACjB,IAAIf,CAAC;EAEL,IAAIiG,EAAE,GAAGrG,SAAS,CAACM,uBAAuB,CACxCP,SAAS,CAAC,CAAC,CAAC,EACZmG,oBACF,CAAC;EACD,IAAII,EAAE;EACN,KAAKlG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;IAC/BkG,EAAE,GAAGtG,SAAS,CAACM,uBAAuB,CACpCP,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC,EAChB+F,oBACF,CAAC;IACDhF,SAAS,IAAItC,gBAAgB,CAACQ,uBAAuB,CAACgH,EAAE,EAAEC,EAAE,EAAEhH,WAAW,CAAC;IAC1E+G,EAAE,GAAGnI,YAAY,CAACsG,KAAK,CAAC8B,EAAE,EAAEJ,oBAAoB,CAAC;EACnD;EAEA,MAAMH,WAAW,GAAG,CAAC5E,SAAS,GAAG,CAAC,IAAI,CAAC;EACvC,MAAM6E,YAAY,GAAG,IAAI7F,KAAK,CAAC4F,WAAW,CAAC;EAC3C,IAAI7D,MAAM,GAAG,CAAC;EAEd,KAAK9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;IAC/B,MAAMrB,EAAE,GAAGgB,SAAS,CAACK,CAAC,CAAC;IACvB,MAAMpB,EAAE,GAAGe,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC;IAE3B,MAAMgB,EAAE,GAAGiE,cAAc,GAAG9E,MAAM,CAACH,CAAC,CAAC,GAAGG,MAAM;IAC9C,MAAMc,EAAE,GAAGgE,cAAc,GAAG9E,MAAM,CAACH,CAAC,GAAG,CAAC,CAAC,GAAGG,MAAM;IAElD2B,MAAM,GAAGe,yBAAyB,CAChClE,EAAE,EACFC,EAAE,EACFM,WAAW,EACXU,SAAS,EACToB,EAAE,EACFC,EAAE,EACF2E,YAAY,EACZ9D,MACF,CAAC;EACH;EAEAjB,4BAA4B,CAAChB,MAAM,GAAG,CAAC;EAEvC,MAAMgG,SAAS,GAAGlG,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;EACvC,MAAM8C,KAAK,GAAG/C,SAAS,CAACM,uBAAuB,CAAC2F,SAAS,EAAExE,MAAM,CAAC;EAClEsB,KAAK,CAACxC,MAAM,GAAG8E,cAAc,GAAG9E,MAAM,CAACN,MAAM,GAAG,CAAC,CAAC,GAAGM,MAAM;EAC3D,MAAMqC,IAAI,GAAG5C,SAAS,CAAC6C,uBAAuB,CAACE,KAAK,EAAEpB,SAAS,CAAC;EAChE1D,UAAU,CAAC6E,IAAI,CAACF,IAAI,EAAEoD,YAAY,EAAED,WAAW,GAAG,CAAC,CAAC;EAEpD,OAAOC,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnH,gBAAgB,CAACmD,oBAAoB,GAAG,UAAUmD,OAAO,EAAE;EACzD,MAAMoB,WAAW,GAAG1H,gBAAgB,CAACqG,WAAW,CAACC,OAAO,CAAC;EACzD,MAAMqB,IAAI,GAAGD,WAAW,CAACtG,MAAM,GAAG,CAAC;EACnC,MAAM+F,YAAY,GAAG,IAAI7F,KAAK,CAACqG,IAAI,CAAC;EACpC,KAAK,IAAIpG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoG,IAAI,EAAEpG,CAAC,EAAE,EAAE;IAC7B4F,YAAY,CAAC5F,CAAC,CAAC,GAAGnC,UAAU,CAACwI,MAAM,CAACF,WAAW,EAAEnG,CAAC,GAAG,CAAC,CAAC;EACzD;EACA,OAAO4F,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnH,gBAAgB,CAACoE,yBAAyB,GAAG,UAAUkC,OAAO,EAAE;EAC9D,MAAMoB,WAAW,GAAG1H,gBAAgB,CAACuH,gBAAgB,CAACjB,OAAO,CAAC;EAC9D,MAAMqB,IAAI,GAAGD,WAAW,CAACtG,MAAM,GAAG,CAAC;EACnC,MAAM+F,YAAY,GAAG,IAAI7F,KAAK,CAACqG,IAAI,CAAC;EACpC,KAAK,IAAIpG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoG,IAAI,EAAEpG,CAAC,EAAE,EAAE;IAC7B4F,YAAY,CAAC5F,CAAC,CAAC,GAAGnC,UAAU,CAACwI,MAAM,CAACF,WAAW,EAAEnG,CAAC,GAAG,CAAC,CAAC;EACzD;EACA,OAAO4F,YAAY;AACrB,CAAC;AACD,eAAenH,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}