{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\n\n/**\n * @private\n */\nfunction CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized) {\n  this._context = context;\n  this._texture = texture;\n  this._textureTarget = textureTarget;\n  this._targetFace = targetFace;\n  this._pixelDatatype = pixelDatatype;\n  this._internalFormat = internalFormat;\n  this._pixelFormat = pixelFormat;\n  this._size = size;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._initialized = initialized;\n}\nObject.defineProperties(CubeMapFace.prototype, {\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    }\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    }\n  },\n  _target: {\n    get: function () {\n      return this._targetFace;\n    }\n  }\n});\n\n/**\n * Copies texels from the source to the cubemap's face.\n * @param {object} options Object with the following properties:\n * @param {object} options.source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, {@link HTMLVideoElement},\n *                              or an object with a width, height, and arrayBufferView properties.\n * @param {number} [options.xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {number} [options.yOffset=0] An offset in the y direction in the cubemap where copying begins.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the texture will be ignored.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Create a cubemap with 1x1 faces, and make the +x face red.\n * const cubeMap = new CubeMap({\n *   context : context\n *   width : 1,\n *   height : 1\n * });\n * cubeMap.positiveX.copyFrom({\n *   source: {\n *     width : 1,\n *     height : 1,\n *     arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *   }\n * });\n */\nCubeMapFace.prototype.copyFrom = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options\", options);\n  //>>includeEnd('debug');\n\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    source,\n    skipColorSpaceConversion = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.source\", source);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  if (xOffset + source.width > this._size) {\n    throw new DeveloperError(\"xOffset + options.source.width must be less than or equal to width.\");\n  }\n  if (yOffset + source.height > this._size) {\n    throw new DeveloperError(\"yOffset + options.source.height must be less than or equal to height.\");\n  }\n  //>>includeEnd('debug');\n\n  const {\n    width,\n    height\n  } = source;\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  const targetFace = this._targetFace;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  let arrayBufferView = source.arrayBufferView;\n  const size = this._size;\n  const pixelFormat = this._pixelFormat;\n  const internalFormat = this._internalFormat;\n  const pixelDatatype = this._pixelDatatype;\n  const preMultiplyAlpha = this._preMultiplyAlpha;\n  const flipY = this._flipY;\n  let unpackAlignment = 4;\n  if (defined(arrayBufferView)) {\n    unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);\n  }\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);\n  }\n  let uploaded = false;\n  if (!this._initialized) {\n    let pixels;\n    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {\n      // initialize the entire texture\n      if (defined(arrayBufferView)) {\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n        if (flipY) {\n          arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, size, size);\n        }\n        pixels = arrayBufferView;\n      } else {\n        // Only valid for DOM-Element uploads\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n        pixels = source;\n      }\n      uploaded = true;\n    } else {\n      // initialize the entire texture to zero\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n      pixels = PixelFormat.createTypedArray(pixelFormat, pixelDatatype, size, size);\n    }\n    gl.texImage2D(targetFace, 0, internalFormat, size, size, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), pixels);\n    this._initialized = true;\n  }\n  if (!uploaded) {\n    if (defined(arrayBufferView)) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n      if (flipY) {\n        arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);\n      }\n      gl.texSubImage2D(targetFace, 0, xOffset, yOffset, width, height, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), arrayBufferView);\n    } else {\n      // Only valid for DOM-Element uploads\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\n      // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement\n      gl.texSubImage2D(targetFace, 0, xOffset, yOffset, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), source);\n    }\n  }\n  gl.bindTexture(target, null);\n};\n\n/**\n * Copies texels from the framebuffer to the cubemap's face.\n * @param {number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.\n * @param {number} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {number} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {number} [width=CubeMap's width] The width of the subimage to copy.\n * @param {number} [height=CubeMap's height] The height of the subimage to copy.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @throws {DeveloperError} xOffset must be greater than or equal to zero.\n * @throws {DeveloperError} yOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @throws {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @throws {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @example\n * // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();\n */\nCubeMapFace.prototype.copyFromFramebuffer = function (xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n  framebufferXOffset = defaultValue(framebufferXOffset, 0);\n  framebufferYOffset = defaultValue(framebufferYOffset, 0);\n  width = defaultValue(width, this._size);\n  height = defaultValue(height, this._size);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferXOffset\", framebufferXOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferYOffset\", framebufferYOffset, 0);\n  if (xOffset + width > this._size) {\n    throw new DeveloperError(\"xOffset + source.width must be less than or equal to width.\");\n  }\n  if (yOffset + height > this._size) {\n    throw new DeveloperError(\"yOffset + source.height must be less than or equal to height.\");\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\");\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\");\n  }\n  //>>includeEnd('debug');\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexSubImage2D(this._targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\n\n/**\n * Copies texels from the framebuffer to the cubemap's face mipmap.\n * @param {number} [xOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {number} [yOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {number} [width=CubeMap's width] The width of the subimage to copy.\n * @param {number} [height=CubeMap's height] The height of the subimage to copy.\n * @param {number} [level=0] The level of detail. Level 0 is the base image level and level n is the n-th mipmap reduction level.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @throws {DeveloperError} xOffset must be greater than or equal to zero.\n * @throws {DeveloperError} yOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @throws {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @throws {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();\n */\nCubeMapFace.prototype.copyMipmapFromFramebuffer = function (xOffset, yOffset, width, height, level) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n  width = defaultValue(width, this._size);\n  height = defaultValue(height, this._size);\n  level = defaultValue(level, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  if (xOffset + width > this._size) {\n    throw new DeveloperError(\"xOffset + source.width must be less than or equal to width.\");\n  }\n  if (yOffset + height > this._size) {\n    throw new DeveloperError(\"yOffset + source.height must be less than or equal to height.\");\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\");\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\");\n  }\n  //>>includeEnd('debug');\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexImage2D(this._targetFace, level, this._internalFormat, xOffset, yOffset, width, height, 0);\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\nexport default CubeMapFace;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","PixelFormat","PixelDatatype","CubeMapFace","context","texture","textureTarget","targetFace","internalFormat","pixelFormat","pixelDatatype","size","preMultiplyAlpha","flipY","initialized","_context","_texture","_textureTarget","_targetFace","_pixelDatatype","_internalFormat","_pixelFormat","_size","_preMultiplyAlpha","_flipY","_initialized","Object","defineProperties","prototype","get","_target","copyFrom","options","xOffset","yOffset","source","skipColorSpaceConversion","typeOf","number","greaterThanOrEquals","width","height","gl","_gl","target","activeTexture","TEXTURE0","bindTexture","arrayBufferView","unpackAlignment","alignmentInBytes","pixelStorei","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","BROWSER_DEFAULT_WEBGL","uploaded","pixels","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","createTypedArray","texImage2D","toWebGLConstant","texSubImage2D","copyFromFramebuffer","framebufferXOffset","framebufferYOffset","FLOAT","HALF_FLOAT","copyTexSubImage2D","copyMipmapFromFramebuffer","level","copyTexImage2D"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/CubeMapFace.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\n\n/**\n * @private\n */\nfunction CubeMapFace(\n  context,\n  texture,\n  textureTarget,\n  targetFace,\n  internalFormat,\n  pixelFormat,\n  pixelDatatype,\n  size,\n  preMultiplyAlpha,\n  flipY,\n  initialized,\n) {\n  this._context = context;\n  this._texture = texture;\n  this._textureTarget = textureTarget;\n  this._targetFace = targetFace;\n  this._pixelDatatype = pixelDatatype;\n  this._internalFormat = internalFormat;\n  this._pixelFormat = pixelFormat;\n  this._size = size;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._initialized = initialized;\n}\n\nObject.defineProperties(CubeMapFace.prototype, {\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  _target: {\n    get: function () {\n      return this._targetFace;\n    },\n  },\n});\n\n/**\n * Copies texels from the source to the cubemap's face.\n * @param {object} options Object with the following properties:\n * @param {object} options.source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, {@link HTMLVideoElement},\n *                              or an object with a width, height, and arrayBufferView properties.\n * @param {number} [options.xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {number} [options.yOffset=0] An offset in the y direction in the cubemap where copying begins.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the texture will be ignored.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Create a cubemap with 1x1 faces, and make the +x face red.\n * const cubeMap = new CubeMap({\n *   context : context\n *   width : 1,\n *   height : 1\n * });\n * cubeMap.positiveX.copyFrom({\n *   source: {\n *     width : 1,\n *     height : 1,\n *     arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *   }\n * });\n */\nCubeMapFace.prototype.copyFrom = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options\", options);\n  //>>includeEnd('debug');\n\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    source,\n    skipColorSpaceConversion = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.source\", source);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  if (xOffset + source.width > this._size) {\n    throw new DeveloperError(\n      \"xOffset + options.source.width must be less than or equal to width.\",\n    );\n  }\n  if (yOffset + source.height > this._size) {\n    throw new DeveloperError(\n      \"yOffset + options.source.height must be less than or equal to height.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const { width, height } = source;\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  const targetFace = this._targetFace;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n\n  let arrayBufferView = source.arrayBufferView;\n\n  const size = this._size;\n  const pixelFormat = this._pixelFormat;\n  const internalFormat = this._internalFormat;\n  const pixelDatatype = this._pixelDatatype;\n\n  const preMultiplyAlpha = this._preMultiplyAlpha;\n  const flipY = this._flipY;\n\n  let unpackAlignment = 4;\n  if (defined(arrayBufferView)) {\n    unpackAlignment = PixelFormat.alignmentInBytes(\n      pixelFormat,\n      pixelDatatype,\n      width,\n    );\n  }\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(\n      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,\n      gl.BROWSER_DEFAULT_WEBGL,\n    );\n  }\n\n  let uploaded = false;\n  if (!this._initialized) {\n    let pixels;\n    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {\n      // initialize the entire texture\n      if (defined(arrayBufferView)) {\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n        if (flipY) {\n          arrayBufferView = PixelFormat.flipY(\n            arrayBufferView,\n            pixelFormat,\n            pixelDatatype,\n            size,\n            size,\n          );\n        }\n        pixels = arrayBufferView;\n      } else {\n        // Only valid for DOM-Element uploads\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n        pixels = source;\n      }\n      uploaded = true;\n    } else {\n      // initialize the entire texture to zero\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n      pixels = PixelFormat.createTypedArray(\n        pixelFormat,\n        pixelDatatype,\n        size,\n        size,\n      );\n    }\n    gl.texImage2D(\n      targetFace,\n      0,\n      internalFormat,\n      size,\n      size,\n      0,\n      pixelFormat,\n      PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n      pixels,\n    );\n    this._initialized = true;\n  }\n\n  if (!uploaded) {\n    if (defined(arrayBufferView)) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n      if (flipY) {\n        arrayBufferView = PixelFormat.flipY(\n          arrayBufferView,\n          pixelFormat,\n          pixelDatatype,\n          width,\n          height,\n        );\n      }\n      gl.texSubImage2D(\n        targetFace,\n        0,\n        xOffset,\n        yOffset,\n        width,\n        height,\n        pixelFormat,\n        PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n        arrayBufferView,\n      );\n    } else {\n      // Only valid for DOM-Element uploads\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\n      // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement\n      gl.texSubImage2D(\n        targetFace,\n        0,\n        xOffset,\n        yOffset,\n        pixelFormat,\n        PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n        source,\n      );\n    }\n  }\n\n  gl.bindTexture(target, null);\n};\n\n/**\n * Copies texels from the framebuffer to the cubemap's face.\n * @param {number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.\n * @param {number} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {number} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {number} [width=CubeMap's width] The width of the subimage to copy.\n * @param {number} [height=CubeMap's height] The height of the subimage to copy.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @throws {DeveloperError} xOffset must be greater than or equal to zero.\n * @throws {DeveloperError} yOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @throws {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @throws {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @example\n * // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();\n */\nCubeMapFace.prototype.copyFromFramebuffer = function (\n  xOffset,\n  yOffset,\n  framebufferXOffset,\n  framebufferYOffset,\n  width,\n  height,\n) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n  framebufferXOffset = defaultValue(framebufferXOffset, 0);\n  framebufferYOffset = defaultValue(framebufferYOffset, 0);\n  width = defaultValue(width, this._size);\n  height = defaultValue(height, this._size);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferXOffset\",\n    framebufferXOffset,\n    0,\n  );\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferYOffset\",\n    framebufferYOffset,\n    0,\n  );\n  if (xOffset + width > this._size) {\n    throw new DeveloperError(\n      \"xOffset + source.width must be less than or equal to width.\",\n    );\n  }\n  if (yOffset + height > this._size) {\n    throw new DeveloperError(\n      \"yOffset + source.height must be less than or equal to height.\",\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\",\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexSubImage2D(\n    this._targetFace,\n    0,\n    xOffset,\n    yOffset,\n    framebufferXOffset,\n    framebufferYOffset,\n    width,\n    height,\n  );\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\n\n/**\n * Copies texels from the framebuffer to the cubemap's face mipmap.\n * @param {number} [xOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {number} [yOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {number} [width=CubeMap's width] The width of the subimage to copy.\n * @param {number} [height=CubeMap's height] The height of the subimage to copy.\n * @param {number} [level=0] The level of detail. Level 0 is the base image level and level n is the n-th mipmap reduction level.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @throws {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @throws {DeveloperError} xOffset must be greater than or equal to zero.\n * @throws {DeveloperError} yOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @throws {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @throws {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @throws {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @throws {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();\n */\nCubeMapFace.prototype.copyMipmapFromFramebuffer = function (\n  xOffset,\n  yOffset,\n  width,\n  height,\n  level,\n) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n  width = defaultValue(width, this._size);\n  height = defaultValue(height, this._size);\n  level = defaultValue(level, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n\n  if (xOffset + width > this._size) {\n    throw new DeveloperError(\n      \"xOffset + source.width must be less than or equal to width.\",\n    );\n  }\n  if (yOffset + height > this._size) {\n    throw new DeveloperError(\n      \"yOffset + source.height must be less than or equal to height.\",\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\",\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexImage2D(\n    this._targetFace,\n    level,\n    this._internalFormat,\n    xOffset,\n    yOffset,\n    width,\n    height,\n    0,\n  );\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\nexport default CubeMapFace;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}