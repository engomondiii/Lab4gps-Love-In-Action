{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of box, cylinder, ellipsoid and/or sphere geometries intersecting terrain or 3D Tiles.\n *\n * @alias Vector3DTileGeometry\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Float32Array} [options.boxes] The boxes in the tile.\n * @param {Uint16Array} [options.boxBatchIds] The batch ids for each box.\n * @param {Float32Array} [options.cylinders] The cylinders in the tile.\n * @param {Uint16Array} [options.cylinderBatchIds] The batch ids for each cylinder.\n * @param {Float32Array} [options.ellipsoids] The ellipsoids in the tile.\n * @param {Uint16Array} [options.ellipsoidBatchIds] The batch ids for each ellipsoid.\n * @param {Float32Array} [options.spheres] The spheres in the tile.\n * @param {Uint16Array} [options.sphereBatchIds] The batch ids for each sphere.\n * @param {Cartesian3} options.center The RTC center of all geometries.\n * @param {Matrix4} options.modelMatrix The model matrix of all geometries. Applied after the individual geometry model matrices.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table.\n * @param {BoundingSphere} options.boundingVolume The bounding volume containing all of the geometry in the tile.\n *\n * @private\n */\nfunction Vector3DTileGeometry(options) {\n  // these will all be released after the primitive is created\n  this._boxes = options.boxes;\n  this._boxBatchIds = options.boxBatchIds;\n  this._cylinders = options.cylinders;\n  this._cylinderBatchIds = options.cylinderBatchIds;\n  this._ellipsoids = options.ellipsoids;\n  this._ellipsoidBatchIds = options.ellipsoidBatchIds;\n  this._spheres = options.spheres;\n  this._sphereBatchIds = options.sphereBatchIds;\n  this._modelMatrix = options.modelMatrix;\n  this._batchTable = options.batchTable;\n  this._boundingVolume = options.boundingVolume;\n  this._center = options.center;\n  if (!defined(this._center)) {\n    if (defined(this._boundingVolume)) {\n      this._center = Cartesian3.clone(this._boundingVolume.center);\n    } else {\n      this._center = Cartesian3.clone(Cartesian3.ZERO);\n    }\n  }\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n  this._indices = undefined;\n  this._indexOffsets = undefined;\n  this._indexCounts = undefined;\n  this._positions = undefined;\n  this._vertexBatchIds = undefined;\n  this._batchIds = undefined;\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n  this._verticesPromise = undefined;\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification geometries.\n   * @type {boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\nObject.defineProperties(Vector3DTileGeometry.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    }\n  },\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    }\n  },\n  /**\n   * Return true when the primitive is ready to render.\n   * @memberof Vector3DTileGeometry.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  }\n});\nVector3DTileGeometry.packedBoxLength = Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedCylinderLength = Matrix4.packedLength + 2;\nVector3DTileGeometry.packedEllipsoidLength = Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedSphereLength = Cartesian3.packedLength + 1;\nfunction packBuffer(geometries) {\n  const packedBuffer = new Float64Array(Matrix4.packedLength + Cartesian3.packedLength);\n  let offset = 0;\n  Cartesian3.pack(geometries._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Matrix4.pack(geometries._modelMatrix, packedBuffer, offset);\n  return packedBuffer;\n}\nfunction unpackBuffer(geometries, packedBuffer) {\n  let offset = 0;\n  const indicesBytesPerElement = packedBuffer[offset++];\n  const numBVS = packedBuffer[offset++];\n  const bvs = geometries._boundingVolumes = new Array(numBVS);\n  for (let i = 0; i < numBVS; ++i) {\n    bvs[i] = BoundingSphere.unpack(packedBuffer, offset);\n    offset += BoundingSphere.packedLength;\n  }\n  const numBatchedIndices = packedBuffer[offset++];\n  const bis = geometries._batchedIndices = new Array(numBatchedIndices);\n  for (let j = 0; j < numBatchedIndices; ++j) {\n    const color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n    const indexOffset = packedBuffer[offset++];\n    const count = packedBuffer[offset++];\n    const length = packedBuffer[offset++];\n    const batchIds = new Array(length);\n    for (let k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds\n    });\n  }\n  return indicesBytesPerElement;\n}\nconst createVerticesTaskProcessor = new TaskProcessor(\"createVectorTileGeometries\", 5);\nconst scratchColor = new Color();\nfunction createPrimitive(geometries) {\n  if (defined(geometries._primitive)) {\n    return;\n  }\n  if (!defined(geometries._verticesPromise)) {\n    let boxes = geometries._boxes;\n    let boxBatchIds = geometries._boxBatchIds;\n    let cylinders = geometries._cylinders;\n    let cylinderBatchIds = geometries._cylinderBatchIds;\n    let ellipsoids = geometries._ellipsoids;\n    let ellipsoidBatchIds = geometries._ellipsoidBatchIds;\n    let spheres = geometries._spheres;\n    let sphereBatchIds = geometries._sphereBatchIds;\n    let batchTableColors = geometries._batchTableColors;\n    let packedBuffer = geometries._packedBuffer;\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      let length = 0;\n      if (defined(geometries._boxes)) {\n        boxes = geometries._boxes = boxes.slice();\n        boxBatchIds = geometries._boxBatchIds = boxBatchIds.slice();\n        length += boxBatchIds.length;\n      }\n      if (defined(geometries._cylinders)) {\n        cylinders = geometries._cylinders = cylinders.slice();\n        cylinderBatchIds = geometries._cylinderBatchIds = cylinderBatchIds.slice();\n        length += cylinderBatchIds.length;\n      }\n      if (defined(geometries._ellipsoids)) {\n        ellipsoids = geometries._ellipsoids = ellipsoids.slice();\n        ellipsoidBatchIds = geometries._ellipsoidBatchIds = ellipsoidBatchIds.slice();\n        length += ellipsoidBatchIds.length;\n      }\n      if (defined(geometries._spheres)) {\n        spheres = geometries._sphere = spheres.slice();\n        sphereBatchIds = geometries._sphereBatchIds = sphereBatchIds.slice();\n        length += sphereBatchIds.length;\n      }\n      batchTableColors = geometries._batchTableColors = new Uint32Array(length);\n      const batchTable = geometries._batchTable;\n      for (let i = 0; i < length; ++i) {\n        const color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n      packedBuffer = geometries._packedBuffer = packBuffer(geometries);\n    }\n    const transferrableObjects = [];\n    if (defined(boxes)) {\n      transferrableObjects.push(boxes.buffer, boxBatchIds.buffer);\n    }\n    if (defined(cylinders)) {\n      transferrableObjects.push(cylinders.buffer, cylinderBatchIds.buffer);\n    }\n    if (defined(ellipsoids)) {\n      transferrableObjects.push(ellipsoids.buffer, ellipsoidBatchIds.buffer);\n    }\n    if (defined(spheres)) {\n      transferrableObjects.push(spheres.buffer, sphereBatchIds.buffer);\n    }\n    transferrableObjects.push(batchTableColors.buffer, packedBuffer.buffer);\n    const parameters = {\n      boxes: defined(boxes) ? boxes.buffer : undefined,\n      boxBatchIds: defined(boxes) ? boxBatchIds.buffer : undefined,\n      cylinders: defined(cylinders) ? cylinders.buffer : undefined,\n      cylinderBatchIds: defined(cylinders) ? cylinderBatchIds.buffer : undefined,\n      ellipsoids: defined(ellipsoids) ? ellipsoids.buffer : undefined,\n      ellipsoidBatchIds: defined(ellipsoids) ? ellipsoidBatchIds.buffer : undefined,\n      spheres: defined(spheres) ? spheres.buffer : undefined,\n      sphereBatchIds: defined(spheres) ? sphereBatchIds.buffer : undefined,\n      batchTableColors: batchTableColors.buffer,\n      packedBuffer: packedBuffer.buffer\n    };\n    const verticesPromise = geometries._verticesPromise = createVerticesTaskProcessor.scheduleTask(parameters, transferrableObjects);\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n    return verticesPromise.then(function (result) {\n      if (geometries.isDestroyed()) {\n        return;\n      }\n      const packedBuffer = new Float64Array(result.packedBuffer);\n      const indicesBytesPerElement = unpackBuffer(geometries, packedBuffer);\n      if (indicesBytesPerElement === 2) {\n        geometries._indices = new Uint16Array(result.indices);\n      } else {\n        geometries._indices = new Uint32Array(result.indices);\n      }\n      geometries._indexOffsets = new Uint32Array(result.indexOffsets);\n      geometries._indexCounts = new Uint32Array(result.indexCounts);\n      geometries._positions = new Float32Array(result.positions);\n      geometries._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n      geometries._batchIds = new Uint16Array(result.batchIds);\n      finishPrimitive(geometries);\n      geometries._ready = true;\n    }).catch(error => {\n      if (geometries.isDestroyed()) {\n        return;\n      }\n      geometries._error = error;\n    });\n  }\n}\nfunction finishPrimitive(geometries) {\n  if (!defined(geometries._primitive)) {\n    geometries._primitive = new Vector3DTilePrimitive({\n      batchTable: geometries._batchTable,\n      positions: geometries._positions,\n      batchIds: geometries._batchIds,\n      vertexBatchIds: geometries._vertexBatchIds,\n      indices: geometries._indices,\n      indexOffsets: geometries._indexOffsets,\n      indexCounts: geometries._indexCounts,\n      batchedIndices: geometries._batchedIndices,\n      boundingVolume: geometries._boundingVolume,\n      boundingVolumes: geometries._boundingVolumes,\n      center: geometries._center,\n      pickObject: defaultValue(geometries._pickObject, geometries)\n    });\n    geometries._boxes = undefined;\n    geometries._boxBatchIds = undefined;\n    geometries._cylinders = undefined;\n    geometries._cylinderBatchIds = undefined;\n    geometries._ellipsoids = undefined;\n    geometries._ellipsoidBatchIds = undefined;\n    geometries._spheres = undefined;\n    geometries._sphereBatchIds = undefined;\n    geometries._center = undefined;\n    geometries._modelMatrix = undefined;\n    geometries._batchTable = undefined;\n    geometries._boundingVolume = undefined;\n    geometries._boundingVolumes = undefined;\n    geometries._batchedIndices = undefined;\n    geometries._indices = undefined;\n    geometries._indexOffsets = undefined;\n    geometries._indexCounts = undefined;\n    geometries._positions = undefined;\n    geometries._vertexBatchIds = undefined;\n    geometries._batchIds = undefined;\n    geometries._batchTableColors = undefined;\n    geometries._packedBuffer = undefined;\n    geometries._verticesPromise = undefined;\n  }\n}\n\n/**\n * Creates features for each geometry and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileGeometry.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (geometry batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileGeometry.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTileGeometry.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a geometry with batchId changes color. The geometries will need to be re-batched\n * on the next update.\n *\n * @param {number} batchId The batch id of the geometries whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTileGeometry.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileGeometry.prototype.update = function (frameState) {\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = createPrimitive(this);\n    }\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n    return;\n  }\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileGeometry.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileGeometry.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Color","defaultValue","defined","destroyObject","Matrix4","TaskProcessor","ClassificationType","Vector3DTileBatch","Vector3DTilePrimitive","Vector3DTileGeometry","options","_boxes","boxes","_boxBatchIds","boxBatchIds","_cylinders","cylinders","_cylinderBatchIds","cylinderBatchIds","_ellipsoids","ellipsoids","_ellipsoidBatchIds","ellipsoidBatchIds","_spheres","spheres","_sphereBatchIds","sphereBatchIds","_modelMatrix","modelMatrix","_batchTable","batchTable","_boundingVolume","boundingVolume","_center","center","clone","ZERO","_boundingVolumes","undefined","_batchedIndices","_indices","_indexOffsets","_indexCounts","_positions","_vertexBatchIds","_batchIds","_batchTableColors","_packedBuffer","_ready","_promise","_error","_verticesPromise","_primitive","debugWireframe","forceRebatch","classificationType","BOTH","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","ready","packedBoxLength","packedLength","packedCylinderLength","packedEllipsoidLength","packedSphereLength","packBuffer","geometries","packedBuffer","Float64Array","offset","pack","unpackBuffer","indicesBytesPerElement","numBVS","bvs","Array","i","unpack","numBatchedIndices","bis","j","color","indexOffset","count","length","batchIds","k","createVerticesTaskProcessor","scratchColor","createPrimitive","batchTableColors","slice","_sphere","Uint32Array","getColor","toRgba","transferrableObjects","push","buffer","parameters","verticesPromise","scheduleTask","then","result","isDestroyed","Uint16Array","indices","indexOffsets","indexCounts","Float32Array","positions","vertexBatchIds","finishPrimitive","catch","error","batchedIndices","boundingVolumes","pickObject","_pickObject","createFeatures","content","features","applyDebugSettings","enabled","applyStyle","style","updateCommands","batchId","update","frameState","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Vector3DTileGeometry.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of box, cylinder, ellipsoid and/or sphere geometries intersecting terrain or 3D Tiles.\n *\n * @alias Vector3DTileGeometry\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Float32Array} [options.boxes] The boxes in the tile.\n * @param {Uint16Array} [options.boxBatchIds] The batch ids for each box.\n * @param {Float32Array} [options.cylinders] The cylinders in the tile.\n * @param {Uint16Array} [options.cylinderBatchIds] The batch ids for each cylinder.\n * @param {Float32Array} [options.ellipsoids] The ellipsoids in the tile.\n * @param {Uint16Array} [options.ellipsoidBatchIds] The batch ids for each ellipsoid.\n * @param {Float32Array} [options.spheres] The spheres in the tile.\n * @param {Uint16Array} [options.sphereBatchIds] The batch ids for each sphere.\n * @param {Cartesian3} options.center The RTC center of all geometries.\n * @param {Matrix4} options.modelMatrix The model matrix of all geometries. Applied after the individual geometry model matrices.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table.\n * @param {BoundingSphere} options.boundingVolume The bounding volume containing all of the geometry in the tile.\n *\n * @private\n */\nfunction Vector3DTileGeometry(options) {\n  // these will all be released after the primitive is created\n  this._boxes = options.boxes;\n  this._boxBatchIds = options.boxBatchIds;\n  this._cylinders = options.cylinders;\n  this._cylinderBatchIds = options.cylinderBatchIds;\n  this._ellipsoids = options.ellipsoids;\n  this._ellipsoidBatchIds = options.ellipsoidBatchIds;\n  this._spheres = options.spheres;\n  this._sphereBatchIds = options.sphereBatchIds;\n  this._modelMatrix = options.modelMatrix;\n  this._batchTable = options.batchTable;\n  this._boundingVolume = options.boundingVolume;\n\n  this._center = options.center;\n  if (!defined(this._center)) {\n    if (defined(this._boundingVolume)) {\n      this._center = Cartesian3.clone(this._boundingVolume.center);\n    } else {\n      this._center = Cartesian3.clone(Cartesian3.ZERO);\n    }\n  }\n\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n\n  this._indices = undefined;\n  this._indexOffsets = undefined;\n  this._indexCounts = undefined;\n\n  this._positions = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._batchIds = undefined;\n\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n\n  this._verticesPromise = undefined;\n\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification geometries.\n   * @type {boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTileGeometry.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Return true when the primitive is ready to render.\n   * @memberof Vector3DTileGeometry.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\nVector3DTileGeometry.packedBoxLength =\n  Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedCylinderLength = Matrix4.packedLength + 2;\nVector3DTileGeometry.packedEllipsoidLength =\n  Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedSphereLength = Cartesian3.packedLength + 1;\n\nfunction packBuffer(geometries) {\n  const packedBuffer = new Float64Array(\n    Matrix4.packedLength + Cartesian3.packedLength,\n  );\n\n  let offset = 0;\n  Cartesian3.pack(geometries._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Matrix4.pack(geometries._modelMatrix, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nfunction unpackBuffer(geometries, packedBuffer) {\n  let offset = 0;\n\n  const indicesBytesPerElement = packedBuffer[offset++];\n  const numBVS = packedBuffer[offset++];\n  const bvs = (geometries._boundingVolumes = new Array(numBVS));\n\n  for (let i = 0; i < numBVS; ++i) {\n    bvs[i] = BoundingSphere.unpack(packedBuffer, offset);\n    offset += BoundingSphere.packedLength;\n  }\n\n  const numBatchedIndices = packedBuffer[offset++];\n  const bis = (geometries._batchedIndices = new Array(numBatchedIndices));\n\n  for (let j = 0; j < numBatchedIndices; ++j) {\n    const color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n\n    const indexOffset = packedBuffer[offset++];\n    const count = packedBuffer[offset++];\n\n    const length = packedBuffer[offset++];\n    const batchIds = new Array(length);\n\n    for (let k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds,\n    });\n  }\n\n  return indicesBytesPerElement;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTileGeometries\",\n  5,\n);\nconst scratchColor = new Color();\n\nfunction createPrimitive(geometries) {\n  if (defined(geometries._primitive)) {\n    return;\n  }\n\n  if (!defined(geometries._verticesPromise)) {\n    let boxes = geometries._boxes;\n    let boxBatchIds = geometries._boxBatchIds;\n    let cylinders = geometries._cylinders;\n    let cylinderBatchIds = geometries._cylinderBatchIds;\n    let ellipsoids = geometries._ellipsoids;\n    let ellipsoidBatchIds = geometries._ellipsoidBatchIds;\n    let spheres = geometries._spheres;\n    let sphereBatchIds = geometries._sphereBatchIds;\n\n    let batchTableColors = geometries._batchTableColors;\n    let packedBuffer = geometries._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      let length = 0;\n      if (defined(geometries._boxes)) {\n        boxes = geometries._boxes = boxes.slice();\n        boxBatchIds = geometries._boxBatchIds = boxBatchIds.slice();\n        length += boxBatchIds.length;\n      }\n      if (defined(geometries._cylinders)) {\n        cylinders = geometries._cylinders = cylinders.slice();\n        cylinderBatchIds = geometries._cylinderBatchIds =\n          cylinderBatchIds.slice();\n        length += cylinderBatchIds.length;\n      }\n      if (defined(geometries._ellipsoids)) {\n        ellipsoids = geometries._ellipsoids = ellipsoids.slice();\n        ellipsoidBatchIds = geometries._ellipsoidBatchIds =\n          ellipsoidBatchIds.slice();\n        length += ellipsoidBatchIds.length;\n      }\n      if (defined(geometries._spheres)) {\n        spheres = geometries._sphere = spheres.slice();\n        sphereBatchIds = geometries._sphereBatchIds = sphereBatchIds.slice();\n        length += sphereBatchIds.length;\n      }\n\n      batchTableColors = geometries._batchTableColors = new Uint32Array(length);\n      const batchTable = geometries._batchTable;\n\n      for (let i = 0; i < length; ++i) {\n        const color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = geometries._packedBuffer = packBuffer(geometries);\n    }\n\n    const transferrableObjects = [];\n    if (defined(boxes)) {\n      transferrableObjects.push(boxes.buffer, boxBatchIds.buffer);\n    }\n    if (defined(cylinders)) {\n      transferrableObjects.push(cylinders.buffer, cylinderBatchIds.buffer);\n    }\n    if (defined(ellipsoids)) {\n      transferrableObjects.push(ellipsoids.buffer, ellipsoidBatchIds.buffer);\n    }\n    if (defined(spheres)) {\n      transferrableObjects.push(spheres.buffer, sphereBatchIds.buffer);\n    }\n    transferrableObjects.push(batchTableColors.buffer, packedBuffer.buffer);\n\n    const parameters = {\n      boxes: defined(boxes) ? boxes.buffer : undefined,\n      boxBatchIds: defined(boxes) ? boxBatchIds.buffer : undefined,\n      cylinders: defined(cylinders) ? cylinders.buffer : undefined,\n      cylinderBatchIds: defined(cylinders)\n        ? cylinderBatchIds.buffer\n        : undefined,\n      ellipsoids: defined(ellipsoids) ? ellipsoids.buffer : undefined,\n      ellipsoidBatchIds: defined(ellipsoids)\n        ? ellipsoidBatchIds.buffer\n        : undefined,\n      spheres: defined(spheres) ? spheres.buffer : undefined,\n      sphereBatchIds: defined(spheres) ? sphereBatchIds.buffer : undefined,\n      batchTableColors: batchTableColors.buffer,\n      packedBuffer: packedBuffer.buffer,\n    };\n\n    const verticesPromise = (geometries._verticesPromise =\n      createVerticesTaskProcessor.scheduleTask(\n        parameters,\n        transferrableObjects,\n      ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    return verticesPromise\n      .then(function (result) {\n        if (geometries.isDestroyed()) {\n          return;\n        }\n\n        const packedBuffer = new Float64Array(result.packedBuffer);\n        const indicesBytesPerElement = unpackBuffer(geometries, packedBuffer);\n\n        if (indicesBytesPerElement === 2) {\n          geometries._indices = new Uint16Array(result.indices);\n        } else {\n          geometries._indices = new Uint32Array(result.indices);\n        }\n\n        geometries._indexOffsets = new Uint32Array(result.indexOffsets);\n        geometries._indexCounts = new Uint32Array(result.indexCounts);\n\n        geometries._positions = new Float32Array(result.positions);\n        geometries._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n\n        geometries._batchIds = new Uint16Array(result.batchIds);\n\n        finishPrimitive(geometries);\n\n        geometries._ready = true;\n      })\n      .catch((error) => {\n        if (geometries.isDestroyed()) {\n          return;\n        }\n\n        geometries._error = error;\n      });\n  }\n}\n\nfunction finishPrimitive(geometries) {\n  if (!defined(geometries._primitive)) {\n    geometries._primitive = new Vector3DTilePrimitive({\n      batchTable: geometries._batchTable,\n      positions: geometries._positions,\n      batchIds: geometries._batchIds,\n      vertexBatchIds: geometries._vertexBatchIds,\n      indices: geometries._indices,\n      indexOffsets: geometries._indexOffsets,\n      indexCounts: geometries._indexCounts,\n      batchedIndices: geometries._batchedIndices,\n      boundingVolume: geometries._boundingVolume,\n      boundingVolumes: geometries._boundingVolumes,\n      center: geometries._center,\n      pickObject: defaultValue(geometries._pickObject, geometries),\n    });\n\n    geometries._boxes = undefined;\n    geometries._boxBatchIds = undefined;\n    geometries._cylinders = undefined;\n    geometries._cylinderBatchIds = undefined;\n    geometries._ellipsoids = undefined;\n    geometries._ellipsoidBatchIds = undefined;\n    geometries._spheres = undefined;\n    geometries._sphereBatchIds = undefined;\n    geometries._center = undefined;\n    geometries._modelMatrix = undefined;\n    geometries._batchTable = undefined;\n    geometries._boundingVolume = undefined;\n\n    geometries._boundingVolumes = undefined;\n    geometries._batchedIndices = undefined;\n\n    geometries._indices = undefined;\n    geometries._indexOffsets = undefined;\n    geometries._indexCounts = undefined;\n\n    geometries._positions = undefined;\n    geometries._vertexBatchIds = undefined;\n\n    geometries._batchIds = undefined;\n\n    geometries._batchTableColors = undefined;\n    geometries._packedBuffer = undefined;\n\n    geometries._verticesPromise = undefined;\n  }\n}\n\n/**\n * Creates features for each geometry and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileGeometry.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (geometry batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileGeometry.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTileGeometry.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a geometry with batchId changes color. The geometries will need to be re-batched\n * on the next update.\n *\n * @param {number} batchId The batch id of the geometries whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTileGeometry.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileGeometry.prototype.update = function (frameState) {\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = createPrimitive(this);\n    }\n\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n\n    return;\n  }\n\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileGeometry.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileGeometry.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}