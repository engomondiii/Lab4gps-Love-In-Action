{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport BufferLoader from \"./BufferLoader.js\";\nimport GltfBufferViewLoader from \"./GltfBufferViewLoader.js\";\nimport GltfDracoLoader from \"./GltfDracoLoader.js\";\nimport GltfImageLoader from \"./GltfImageLoader.js\";\nimport GltfIndexBufferLoader from \"./GltfIndexBufferLoader.js\";\nimport GltfJsonLoader from \"./GltfJsonLoader.js\";\nimport GltfTextureLoader from \"./GltfTextureLoader.js\";\nimport GltfVertexBufferLoader from \"./GltfVertexBufferLoader.js\";\nimport MetadataSchemaLoader from \"./MetadataSchemaLoader.js\";\nimport ResourceCacheKey from \"./ResourceCacheKey.js\";\nimport ResourceCacheStatistics from \"./ResourceCacheStatistics.js\";\n\n/**\n * Cache for resources shared across 3D Tiles and glTF.\n *\n * @namespace ResourceCache\n *\n * @private\n */\nfunction ResourceCache() {}\nResourceCache.cacheEntries = {};\n\n// Statistics about binary data stored in the resource cache\nResourceCache.statistics = new ResourceCacheStatistics();\n\n/**\n * A reference-counted cache entry.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @alias CacheEntry\n * @constructor\n *\n * @private\n */\nfunction CacheEntry(resourceLoader) {\n  this.referenceCount = 1;\n  this.resourceLoader = resourceLoader;\n\n  // For unit testing only\n  this._statisticsPromise = undefined;\n}\n\n/**\n * Gets a resource from the cache. If the resource exists its reference count is\n * incremented. Otherwise, if no resource loader exists, undefined is returned.\n *\n * @param {string} cacheKey The cache key of the resource.\n *\n * @returns {ResourceLoader|undefined} The resource.\n * @private\n */\nResourceCache.get = function (cacheKey) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"cacheKey\", cacheKey);\n  //>>includeEnd('debug');\n\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n  if (defined(cacheEntry)) {\n    ++cacheEntry.referenceCount;\n    return cacheEntry.resourceLoader;\n  }\n  return undefined;\n};\n\n/**\n * Adds it to the cache.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n * @returns {ResourceLoader} The resource.\n *\n * @exception {DeveloperError} Resource with this cacheKey is already in the cache\n * @private\n */\nResourceCache.add = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.resourceLoader.cacheKey\", cacheKey);\n  if (defined(ResourceCache.cacheEntries[cacheKey])) {\n    throw new DeveloperError(`Resource with this cacheKey is already in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  ResourceCache.cacheEntries[cacheKey] = new CacheEntry(resourceLoader);\n  return resourceLoader;\n};\n\n/**\n * Unloads a resource from the cache. When the reference count hits zero the\n * resource is destroyed.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @exception {DeveloperError} Resource is not in the cache.\n * @exception {DeveloperError} Cannot unload resource that has no references.\n * @private\n */\nResourceCache.unload = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cacheEntry)) {\n    throw new DeveloperError(`Resource is not in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  --cacheEntry.referenceCount;\n  if (cacheEntry.referenceCount === 0) {\n    ResourceCache.statistics.removeLoader(resourceLoader);\n    resourceLoader.destroy();\n    delete ResourceCache.cacheEntries[cacheKey];\n  }\n};\n\n/**\n * Gets an existing schema loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n *\n * @returns {MetadataSchemaLoader} The cached schema resource.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n * @private\n */\nResourceCache.getSchemaLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    schema,\n    resource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\"One of options.schema and options.resource must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSchemaCacheKey({\n    schema: schema,\n    resource: resource\n  });\n  let schemaLoader = ResourceCache.get(cacheKey);\n  if (defined(schemaLoader)) {\n    return schemaLoader;\n  }\n  schemaLoader = new MetadataSchemaLoader({\n    schema: schema,\n    resource: resource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(schemaLoader);\n};\n\n/**\n * Gets an existing embedded buffer loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.parentResource The {@link Resource} containing the embedded buffer.\n * @param {number} options.bufferId A unique identifier of the embedded buffer within the parent resource.\n * @param {Uint8Array} [options.typedArray] The typed array containing the embedded buffer contents.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getEmbeddedBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    parentResource,\n    bufferId,\n    typedArray\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.parentResource\", parentResource);\n  Check.typeOf.number(\"options.bufferId\", bufferId);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getEmbeddedBufferCacheKey({\n    parentResource: parentResource,\n    bufferId: bufferId\n  });\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.typedArray\", typedArray);\n  //>>includeEnd('debug');\n\n  bufferLoader = new BufferLoader({\n    typedArray: typedArray,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing external buffer from loader the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.resource The {@link Resource} pointing to the external buffer.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getExternalBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    resource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resource\", resource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getExternalBufferCacheKey({\n    resource: resource\n  });\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n  bufferLoader = new BufferLoader({\n    resource: resource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing glTF JSON loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents.\n * @param {object} [options.gltfJson] The parsed glTF JSON contents.\n *\n * @returns {GltfJsonLoader} The cached glTF JSON loader.\n * @private\n */\nResourceCache.getGltfJsonLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltfResource,\n    baseResource,\n    typedArray,\n    gltfJson\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getGltfCacheKey({\n    gltfResource: gltfResource\n  });\n  let gltfJsonLoader = ResourceCache.get(cacheKey);\n  if (defined(gltfJsonLoader)) {\n    return gltfJsonLoader;\n  }\n  gltfJsonLoader = new GltfJsonLoader({\n    resourceCache: ResourceCache,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    typedArray: typedArray,\n    gltfJson: gltfJson,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(gltfJsonLoader);\n};\n\n/**\n * Gets an existing glTF buffer view from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.bufferViewId The bufferView ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfBufferViewLoader} The cached buffer view loader.\n * @private\n */\nResourceCache.getBufferViewLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    bufferViewId,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getBufferViewCacheKey({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let bufferViewLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferViewLoader)) {\n    return bufferViewLoader;\n  }\n  bufferViewLoader = new GltfBufferViewLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(bufferViewLoader);\n};\n\n/**\n * Gets an existing Draco data from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfDracoLoader} The cached Draco loader.\n * @private\n */\nResourceCache.getDracoLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    draco,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getDracoCacheKey({\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let dracoLoader = ResourceCache.get(cacheKey);\n  if (defined(dracoLoader)) {\n    return dracoLoader;\n  }\n  dracoLoader = new GltfDracoLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(dracoLoader);\n};\n\n/**\n * Gets an existing glTF vertex buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor ID.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @returns {GltfVertexBufferLoader} The cached vertex buffer loader.\n * @private\n */\nResourceCache.getVertexBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    gltfResource,\n    baseResource,\n    frameState,\n    bufferViewId,\n    draco,\n    attributeSemantic,\n    accessorId,\n    asynchronous = true,\n    dequantize = false,\n    loadBuffer = false,\n    loadTypedArray = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\"One of options.bufferViewId and options.draco must be defined.\");\n  }\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\"When options.draco is defined options.attributeSemantic must also be defined.\");\n  }\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\"When options.draco is defined options.haAccessorId must also be defined.\");\n  }\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getVertexBufferCacheKey({\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: attributeSemantic,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  let vertexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(vertexBufferLoader)) {\n    return vertexBufferLoader;\n  }\n  vertexBufferLoader = new GltfVertexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: attributeSemantic,\n    accessorId: accessorId,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  return ResourceCache.add(vertexBufferLoader);\n};\nfunction hasDracoCompression(draco, semantic) {\n  return defined(draco) && defined(draco.attributes) && defined(draco.attributes[semantic]);\n}\n\n/**\n * Gets an existing glTF index buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {object} [options.draco] The Draco extension object.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load index buffer as a typed array.\n * @returns {GltfIndexBufferLoader} The cached index buffer loader.\n * @private\n */\nResourceCache.getIndexBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    accessorId,\n    gltfResource,\n    baseResource,\n    frameState,\n    draco,\n    asynchronous = true,\n    loadBuffer = false,\n    loadTypedArray = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getIndexBufferCacheKey({\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    draco: draco,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  let indexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(indexBufferLoader)) {\n    return indexBufferLoader;\n  }\n  indexBufferLoader = new GltfIndexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    draco: draco,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  return ResourceCache.add(indexBufferLoader);\n};\n\n/**\n * Gets an existing glTF image from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfImageLoader} The cached image loader.\n * @private\n */\nResourceCache.getImageLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    imageId,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getImageCacheKey({\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let imageLoader = ResourceCache.get(cacheKey);\n  if (defined(imageLoader)) {\n    return imageLoader;\n  }\n  imageLoader = new GltfImageLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(imageLoader);\n};\n\n/**\n * Gets an existing glTF texture from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @returns {GltfTextureLoader} The cached texture loader.\n * @private\n */\nResourceCache.getTextureLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    textureInfo,\n    gltfResource,\n    baseResource,\n    supportedImageFormats,\n    frameState,\n    asynchronous = true\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getTextureCacheKey({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    frameState: frameState\n  });\n  let textureLoader = ResourceCache.get(cacheKey);\n  if (defined(textureLoader)) {\n    return textureLoader;\n  }\n  textureLoader = new GltfTextureLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous\n  });\n  return ResourceCache.add(textureLoader);\n};\n\n/**\n * Unload everything from the cache. This is used for unit testing.\n *\n * @private\n */\nResourceCache.clearForSpecs = function () {\n  // Unload in the order below. This prevents an unload function from unloading\n  // a resource that has already been unloaded.\n  const precedence = [GltfVertexBufferLoader, GltfIndexBufferLoader, GltfDracoLoader, GltfTextureLoader, GltfImageLoader, GltfBufferViewLoader, BufferLoader, MetadataSchemaLoader, GltfJsonLoader];\n  let cacheKey;\n  const cacheEntries = ResourceCache.cacheEntries;\n  const cacheEntriesSorted = [];\n  for (cacheKey in cacheEntries) {\n    if (cacheEntries.hasOwnProperty(cacheKey)) {\n      cacheEntriesSorted.push(cacheEntries[cacheKey]);\n    }\n  }\n  cacheEntriesSorted.sort(function (a, b) {\n    const indexA = precedence.indexOf(a.resourceLoader.constructor);\n    const indexB = precedence.indexOf(b.resourceLoader.constructor);\n    return indexA - indexB;\n  });\n  const cacheEntriesLength = cacheEntriesSorted.length;\n  for (let i = 0; i < cacheEntriesLength; ++i) {\n    const cacheEntry = cacheEntriesSorted[i];\n    cacheKey = cacheEntry.resourceLoader.cacheKey;\n    if (defined(cacheEntries[cacheKey])) {\n      cacheEntry.resourceLoader.destroy();\n      delete cacheEntries[cacheKey];\n    }\n  }\n  ResourceCache.statistics.clear();\n};\nexport default ResourceCache;","map":{"version":3,"names":["Check","defaultValue","defined","DeveloperError","BufferLoader","GltfBufferViewLoader","GltfDracoLoader","GltfImageLoader","GltfIndexBufferLoader","GltfJsonLoader","GltfTextureLoader","GltfVertexBufferLoader","MetadataSchemaLoader","ResourceCacheKey","ResourceCacheStatistics","ResourceCache","cacheEntries","statistics","CacheEntry","resourceLoader","referenceCount","_statisticsPromise","undefined","get","cacheKey","typeOf","string","cacheEntry","add","object","unload","removeLoader","destroy","getSchemaLoader","options","EMPTY_OBJECT","schema","resource","getSchemaCacheKey","schemaLoader","getEmbeddedBufferLoader","parentResource","bufferId","typedArray","number","getEmbeddedBufferCacheKey","bufferLoader","getExternalBufferLoader","getExternalBufferCacheKey","getGltfJsonLoader","gltfResource","baseResource","gltfJson","getGltfCacheKey","gltfJsonLoader","resourceCache","getBufferViewLoader","gltf","bufferViewId","getBufferViewCacheKey","bufferViewLoader","getDracoLoader","draco","getDracoCacheKey","dracoLoader","getVertexBufferLoader","frameState","attributeSemantic","accessorId","asynchronous","dequantize","loadBuffer","loadTypedArray","hasBufferViewId","hasDraco","hasDracoCompression","hasAttributeSemantic","hasAccessorId","getVertexBufferCacheKey","vertexBufferLoader","semantic","attributes","getIndexBufferLoader","getIndexBufferCacheKey","indexBufferLoader","getImageLoader","imageId","getImageCacheKey","imageLoader","getTextureLoader","textureInfo","supportedImageFormats","getTextureCacheKey","textureLoader","clearForSpecs","precedence","cacheEntriesSorted","hasOwnProperty","push","sort","a","b","indexA","indexOf","constructor","indexB","cacheEntriesLength","length","i","clear"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ResourceCache.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport BufferLoader from \"./BufferLoader.js\";\nimport GltfBufferViewLoader from \"./GltfBufferViewLoader.js\";\nimport GltfDracoLoader from \"./GltfDracoLoader.js\";\nimport GltfImageLoader from \"./GltfImageLoader.js\";\nimport GltfIndexBufferLoader from \"./GltfIndexBufferLoader.js\";\nimport GltfJsonLoader from \"./GltfJsonLoader.js\";\nimport GltfTextureLoader from \"./GltfTextureLoader.js\";\nimport GltfVertexBufferLoader from \"./GltfVertexBufferLoader.js\";\nimport MetadataSchemaLoader from \"./MetadataSchemaLoader.js\";\nimport ResourceCacheKey from \"./ResourceCacheKey.js\";\nimport ResourceCacheStatistics from \"./ResourceCacheStatistics.js\";\n\n/**\n * Cache for resources shared across 3D Tiles and glTF.\n *\n * @namespace ResourceCache\n *\n * @private\n */\nfunction ResourceCache() {}\n\nResourceCache.cacheEntries = {};\n\n// Statistics about binary data stored in the resource cache\nResourceCache.statistics = new ResourceCacheStatistics();\n\n/**\n * A reference-counted cache entry.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @alias CacheEntry\n * @constructor\n *\n * @private\n */\nfunction CacheEntry(resourceLoader) {\n  this.referenceCount = 1;\n  this.resourceLoader = resourceLoader;\n\n  // For unit testing only\n  this._statisticsPromise = undefined;\n}\n\n/**\n * Gets a resource from the cache. If the resource exists its reference count is\n * incremented. Otherwise, if no resource loader exists, undefined is returned.\n *\n * @param {string} cacheKey The cache key of the resource.\n *\n * @returns {ResourceLoader|undefined} The resource.\n * @private\n */\nResourceCache.get = function (cacheKey) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"cacheKey\", cacheKey);\n  //>>includeEnd('debug');\n\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n  if (defined(cacheEntry)) {\n    ++cacheEntry.referenceCount;\n    return cacheEntry.resourceLoader;\n  }\n  return undefined;\n};\n\n/**\n * Adds it to the cache.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n * @returns {ResourceLoader} The resource.\n *\n * @exception {DeveloperError} Resource with this cacheKey is already in the cache\n * @private\n */\nResourceCache.add = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.resourceLoader.cacheKey\", cacheKey);\n\n  if (defined(ResourceCache.cacheEntries[cacheKey])) {\n    throw new DeveloperError(\n      `Resource with this cacheKey is already in the cache: ${cacheKey}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  ResourceCache.cacheEntries[cacheKey] = new CacheEntry(resourceLoader);\n\n  return resourceLoader;\n};\n\n/**\n * Unloads a resource from the cache. When the reference count hits zero the\n * resource is destroyed.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @exception {DeveloperError} Resource is not in the cache.\n * @exception {DeveloperError} Cannot unload resource that has no references.\n * @private\n */\nResourceCache.unload = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cacheEntry)) {\n    throw new DeveloperError(`Resource is not in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  --cacheEntry.referenceCount;\n\n  if (cacheEntry.referenceCount === 0) {\n    ResourceCache.statistics.removeLoader(resourceLoader);\n    resourceLoader.destroy();\n    delete ResourceCache.cacheEntries[cacheKey];\n  }\n};\n\n/**\n * Gets an existing schema loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n *\n * @returns {MetadataSchemaLoader} The cached schema resource.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n * @private\n */\nResourceCache.getSchemaLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { schema, resource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\n      \"One of options.schema and options.resource must be defined.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSchemaCacheKey({\n    schema: schema,\n    resource: resource,\n  });\n\n  let schemaLoader = ResourceCache.get(cacheKey);\n  if (defined(schemaLoader)) {\n    return schemaLoader;\n  }\n\n  schemaLoader = new MetadataSchemaLoader({\n    schema: schema,\n    resource: resource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(schemaLoader);\n};\n\n/**\n * Gets an existing embedded buffer loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.parentResource The {@link Resource} containing the embedded buffer.\n * @param {number} options.bufferId A unique identifier of the embedded buffer within the parent resource.\n * @param {Uint8Array} [options.typedArray] The typed array containing the embedded buffer contents.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getEmbeddedBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { parentResource, bufferId, typedArray } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.parentResource\", parentResource);\n  Check.typeOf.number(\"options.bufferId\", bufferId);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getEmbeddedBufferCacheKey({\n    parentResource: parentResource,\n    bufferId: bufferId,\n  });\n\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.typedArray\", typedArray);\n  //>>includeEnd('debug');\n\n  bufferLoader = new BufferLoader({\n    typedArray: typedArray,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing external buffer from loader the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.resource The {@link Resource} pointing to the external buffer.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getExternalBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { resource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resource\", resource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getExternalBufferCacheKey({\n    resource: resource,\n  });\n\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  bufferLoader = new BufferLoader({\n    resource: resource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing glTF JSON loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents.\n * @param {object} [options.gltfJson] The parsed glTF JSON contents.\n *\n * @returns {GltfJsonLoader} The cached glTF JSON loader.\n * @private\n */\nResourceCache.getGltfJsonLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { gltfResource, baseResource, typedArray, gltfJson } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getGltfCacheKey({\n    gltfResource: gltfResource,\n  });\n\n  let gltfJsonLoader = ResourceCache.get(cacheKey);\n  if (defined(gltfJsonLoader)) {\n    return gltfJsonLoader;\n  }\n\n  gltfJsonLoader = new GltfJsonLoader({\n    resourceCache: ResourceCache,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    typedArray: typedArray,\n    gltfJson: gltfJson,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(gltfJsonLoader);\n};\n\n/**\n * Gets an existing glTF buffer view from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.bufferViewId The bufferView ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfBufferViewLoader} The cached buffer view loader.\n * @private\n */\nResourceCache.getBufferViewLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { gltf, bufferViewId, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getBufferViewCacheKey({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let bufferViewLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferViewLoader)) {\n    return bufferViewLoader;\n  }\n\n  bufferViewLoader = new GltfBufferViewLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(bufferViewLoader);\n};\n\n/**\n * Gets an existing Draco data from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfDracoLoader} The cached Draco loader.\n * @private\n */\nResourceCache.getDracoLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { gltf, draco, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getDracoCacheKey({\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let dracoLoader = ResourceCache.get(cacheKey);\n  if (defined(dracoLoader)) {\n    return dracoLoader;\n  }\n\n  dracoLoader = new GltfDracoLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(dracoLoader);\n};\n\n/**\n * Gets an existing glTF vertex buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor ID.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @returns {GltfVertexBufferLoader} The cached vertex buffer loader.\n * @private\n */\nResourceCache.getVertexBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    gltfResource,\n    baseResource,\n    frameState,\n    bufferViewId,\n    draco,\n    attributeSemantic,\n    accessorId,\n    asynchronous = true,\n    dequantize = false,\n    loadBuffer = false,\n    loadTypedArray = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId and options.draco must be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.haAccessorId must also be defined.\",\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getVertexBufferCacheKey({\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: attributeSemantic,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  let vertexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(vertexBufferLoader)) {\n    return vertexBufferLoader;\n  }\n\n  vertexBufferLoader = new GltfVertexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: attributeSemantic,\n    accessorId: accessorId,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  return ResourceCache.add(vertexBufferLoader);\n};\n\nfunction hasDracoCompression(draco, semantic) {\n  return (\n    defined(draco) &&\n    defined(draco.attributes) &&\n    defined(draco.attributes[semantic])\n  );\n}\n\n/**\n * Gets an existing glTF index buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {object} [options.draco] The Draco extension object.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load index buffer as a typed array.\n * @returns {GltfIndexBufferLoader} The cached index buffer loader.\n * @private\n */\nResourceCache.getIndexBufferLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    accessorId,\n    gltfResource,\n    baseResource,\n    frameState,\n    draco,\n    asynchronous = true,\n    loadBuffer = false,\n    loadTypedArray = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getIndexBufferCacheKey({\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    draco: draco,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  let indexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(indexBufferLoader)) {\n    return indexBufferLoader;\n  }\n\n  indexBufferLoader = new GltfIndexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    draco: draco,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  return ResourceCache.add(indexBufferLoader);\n};\n\n/**\n * Gets an existing glTF image from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfImageLoader} The cached image loader.\n * @private\n */\nResourceCache.getImageLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const { gltf, imageId, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getImageCacheKey({\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let imageLoader = ResourceCache.get(cacheKey);\n  if (defined(imageLoader)) {\n    return imageLoader;\n  }\n\n  imageLoader = new GltfImageLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(imageLoader);\n};\n\n/**\n * Gets an existing glTF texture from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @returns {GltfTextureLoader} The cached texture loader.\n * @private\n */\nResourceCache.getTextureLoader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const {\n    gltf,\n    textureInfo,\n    gltfResource,\n    baseResource,\n    supportedImageFormats,\n    frameState,\n    asynchronous = true,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getTextureCacheKey({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    frameState: frameState,\n  });\n\n  let textureLoader = ResourceCache.get(cacheKey);\n  if (defined(textureLoader)) {\n    return textureLoader;\n  }\n\n  textureLoader = new GltfTextureLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n  });\n\n  return ResourceCache.add(textureLoader);\n};\n\n/**\n * Unload everything from the cache. This is used for unit testing.\n *\n * @private\n */\nResourceCache.clearForSpecs = function () {\n  // Unload in the order below. This prevents an unload function from unloading\n  // a resource that has already been unloaded.\n  const precedence = [\n    GltfVertexBufferLoader,\n    GltfIndexBufferLoader,\n    GltfDracoLoader,\n    GltfTextureLoader,\n    GltfImageLoader,\n    GltfBufferViewLoader,\n    BufferLoader,\n    MetadataSchemaLoader,\n    GltfJsonLoader,\n  ];\n\n  let cacheKey;\n  const cacheEntries = ResourceCache.cacheEntries;\n\n  const cacheEntriesSorted = [];\n  for (cacheKey in cacheEntries) {\n    if (cacheEntries.hasOwnProperty(cacheKey)) {\n      cacheEntriesSorted.push(cacheEntries[cacheKey]);\n    }\n  }\n\n  cacheEntriesSorted.sort(function (a, b) {\n    const indexA = precedence.indexOf(a.resourceLoader.constructor);\n    const indexB = precedence.indexOf(b.resourceLoader.constructor);\n    return indexA - indexB;\n  });\n\n  const cacheEntriesLength = cacheEntriesSorted.length;\n  for (let i = 0; i < cacheEntriesLength; ++i) {\n    const cacheEntry = cacheEntriesSorted[i];\n    cacheKey = cacheEntry.resourceLoader.cacheKey;\n    if (defined(cacheEntries[cacheKey])) {\n      cacheEntry.resourceLoader.destroy();\n      delete cacheEntries[cacheKey];\n    }\n  }\n\n  ResourceCache.statistics.clear();\n};\n\nexport default ResourceCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}