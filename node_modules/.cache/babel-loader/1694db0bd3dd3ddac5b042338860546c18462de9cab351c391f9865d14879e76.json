{"ast":null,"code":"import AttributeType from \"./AttributeType.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Object for handling the <code>3DTILES_batch_table_hierarchy</code> extension\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The <code>3DTILES_batch_table_hierarchy</code> extension object.\n * @param {Uint8Array} [options.binaryBody] The binary body of the batch table\n *\n * @alias BatchTableHierarchy\n * @constructor\n *\n * @private\n */\nfunction BatchTableHierarchy(options) {\n  this._classes = undefined;\n  this._classIds = undefined;\n  this._classIndexes = undefined;\n  this._parentCounts = undefined;\n  this._parentIndexes = undefined;\n  this._parentIds = undefined;\n\n  // Total memory used by the typed arrays\n  this._byteLength = 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", options.extension);\n  //>>includeEnd('debug');\n\n  initialize(this, options.extension, options.binaryBody);\n\n  //>>includeStart('debug', pragmas.debug);\n  validateHierarchy(this);\n  //>>includeEnd('debug');\n}\nObject.defineProperties(BatchTableHierarchy.prototype, {\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    }\n  }\n});\n\n/**\n * Parse the batch table hierarchy from the\n * <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {BatchTableHierarchy} hierarchy The hierarchy instance\n * @param {object} hierarchyJson The JSON of the extension\n * @param {Uint8Array} [binaryBody] The binary body of the batch table for accessing binary properties\n * @private\n */\nfunction initialize(hierarchy, hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n  let byteLength = 0;\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, ComponentDatatype.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n    byteLength += classIds.byteLength;\n  }\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, ComponentDatatype.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n      byteLength += parentCounts.byteLength;\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n    byteLength += parentIndexes.byteLength;\n  }\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, ComponentDatatype.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n    byteLength += parentIds.byteLength;\n  }\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    byteLength += countBinaryPropertyMemory(binaryProperties);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n  byteLength += classIndexes.byteLength;\n  hierarchy._classes = classes;\n  hierarchy._classIds = classIds;\n  hierarchy._classIndexes = classIndexes;\n  hierarchy._parentCounts = parentCounts;\n  hierarchy._parentIndexes = parentIndexes;\n  hierarchy._parentIds = parentIds;\n  hierarchy._byteLength = byteLength;\n}\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  let binaryProperties;\n  for (const name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      const property = properties[name];\n      const byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        const componentType = property.componentType;\n        const type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(`Property ${name} requires a batch table binary.`);\n        }\n        const binaryAccessor = getBinaryAccessor(property);\n        const componentCount = binaryAccessor.componentsPerAttribute;\n        const classType = binaryAccessor.classType;\n        const typedArray = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + byteOffset, featuresLength);\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\nfunction countBinaryPropertyMemory(binaryProperties) {\n  let byteLength = 0;\n  for (const name in binaryProperties) {\n    if (binaryProperties.hasOwnProperty(name)) {\n      byteLength += binaryProperties[name].typedArray.byteLength;\n    }\n  }\n  return byteLength;\n}\n\n//>>includeStart('debug', pragmas.debug);\nconst scratchValidateStack = [];\nfunction validateHierarchy(hierarchy) {\n  const stack = scratchValidateStack;\n  stack.length = 0;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(`Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);\n  }\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\"Circular dependency detected in the batch table hierarchy.\");\n  }\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n//>>includeEnd('debug');\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nconst scratchVisited = [];\nconst scratchStack = [];\nlet marker = 0;\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy._classIds;\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy._parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\n/**\n * Returns whether the feature has this property.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.hasProperty = function (batchId, propertyId) {\n  const result = traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\n/**\n * Returns whether any feature has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether any feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.propertyExists = function (propertyId) {\n  const classes = this._classes;\n  const classesLength = classes.length;\n  for (let i = 0; i < classesLength; ++i) {\n    const instances = classes[i].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {number} index The index of the entity.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nBatchTableHierarchy.prototype.getPropertyIds = function (batchId, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n  traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nBatchTableHierarchy.prototype.getProperty = function (batchId, propertyId) {\n  return traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n};\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\n/**\n * Sets the value of the property with the given ID. Only properties of the\n * instance may be set; parent properties may not be set.\n *\n * @param {number} batchId The batchId of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} when setting an inherited property\n * @private\n */\nBatchTableHierarchy.prototype.setProperty = function (batchId, propertyId, value) {\n  const result = traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      //>>includeStart('debug', pragmas.debug);\n      if (instanceIndex !== batchId) {\n        throw new DeveloperError(`Inherited property \"${propertyId}\" is read-only.`);\n      }\n      //>>includeEnd('debug');\n      if (defined(propertyValues.typedArray)) {\n        setBinaryProperty(propertyValues, indexInClass, value);\n      } else {\n        propertyValues[indexInClass] = clone(value, true);\n      }\n      return true;\n    }\n  });\n  return defined(result);\n};\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\n/**\n * Check if a feature belongs to a class with the given name\n *\n * @param {number} batchId The batch ID of the feature\n * @param {string} className The name of the class\n * @return {boolean} <code>true</code> if the feature belongs to the class given by className, or <code>false</code> otherwise\n * @private\n */\nBatchTableHierarchy.prototype.isClass = function (batchId, className) {\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n  // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n  const result = traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    if (instanceClass.name === className) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\n/**\n * Get the name of the class a given feature belongs to\n *\n * @param {number} batchId The batch ID of the feature\n * @return {string} The name of the class this feature belongs to\n */\nBatchTableHierarchy.prototype.getClassName = function (batchId) {\n  const classId = this._classIds[batchId];\n  const instanceClass = this._classes[classId];\n  return instanceClass.name;\n};\nexport default BatchTableHierarchy;","map":{"version":3,"names":["AttributeType","Check","clone","combine","ComponentDatatype","defined","defaultValue","DeveloperError","getBinaryAccessor","RuntimeError","BatchTableHierarchy","options","_classes","undefined","_classIds","_classIndexes","_parentCounts","_parentIndexes","_parentIds","_byteLength","typeOf","object","extension","initialize","binaryBody","validateHierarchy","Object","defineProperties","prototype","byteLength","get","hierarchy","hierarchyJson","i","classId","binaryAccessor","instancesLength","classes","classIds","parentCounts","parentIds","parentIdsLength","byteOffset","componentType","UNSIGNED_SHORT","type","SCALAR","createArrayBufferView","buffer","parentIndexes","Uint16Array","classesLength","length","classInstancesLength","properties","instances","binaryProperties","getBinaryProperties","countBinaryPropertyMemory","classCounts","Array","fill","classIndexes","featuresLength","name","hasOwnProperty","property","componentCount","componentsPerAttribute","classType","typedArray","scratchValidateStack","stack","validateInstance","instanceIndex","indexOf","push","parentCount","parentIndex","parentId","pop","scratchVisited","scratchStack","marker","traverseHierarchyMultipleParents","endConditionCallback","visited","Math","max","visitedMarker","result","traverseHierarchySingleParent","hasParent","traverseHierarchy","hasProperty","batchId","propertyId","propertyExists","getPropertyIds","results","getProperty","instanceClass","indexInClass","propertyValues","getBinaryProperty","binaryProperty","index","unpack","setProperty","value","setBinaryProperty","pack","isClass","className","getClassName"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/BatchTableHierarchy.js"],"sourcesContent":["import AttributeType from \"./AttributeType.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Object for handling the <code>3DTILES_batch_table_hierarchy</code> extension\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The <code>3DTILES_batch_table_hierarchy</code> extension object.\n * @param {Uint8Array} [options.binaryBody] The binary body of the batch table\n *\n * @alias BatchTableHierarchy\n * @constructor\n *\n * @private\n */\nfunction BatchTableHierarchy(options) {\n  this._classes = undefined;\n  this._classIds = undefined;\n  this._classIndexes = undefined;\n  this._parentCounts = undefined;\n  this._parentIndexes = undefined;\n  this._parentIds = undefined;\n\n  // Total memory used by the typed arrays\n  this._byteLength = 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", options.extension);\n  //>>includeEnd('debug');\n\n  initialize(this, options.extension, options.binaryBody);\n\n  //>>includeStart('debug', pragmas.debug);\n  validateHierarchy(this);\n  //>>includeEnd('debug');\n}\n\nObject.defineProperties(BatchTableHierarchy.prototype, {\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    },\n  },\n});\n\n/**\n * Parse the batch table hierarchy from the\n * <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {BatchTableHierarchy} hierarchy The hierarchy instance\n * @param {object} hierarchyJson The JSON of the extension\n * @param {Uint8Array} [binaryBody] The binary body of the batch table for accessing binary properties\n * @private\n */\nfunction initialize(hierarchy, hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n  let byteLength = 0;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(\n      classIds.componentType,\n      ComponentDatatype.UNSIGNED_SHORT,\n    );\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength,\n    );\n    byteLength += classIds.byteLength;\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(\n        parentCounts.componentType,\n        ComponentDatatype.UNSIGNED_SHORT,\n      );\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength,\n      );\n      byteLength += parentCounts.byteLength;\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n\n    byteLength += parentIndexes.byteLength;\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(\n      parentIds.componentType,\n      ComponentDatatype.UNSIGNED_SHORT,\n    );\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength,\n    );\n\n    byteLength += parentIds.byteLength;\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(\n      classInstancesLength,\n      properties,\n      binaryBody,\n    );\n    byteLength += countBinaryPropertyMemory(binaryProperties);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n  byteLength += classIndexes.byteLength;\n\n  hierarchy._classes = classes;\n  hierarchy._classIds = classIds;\n  hierarchy._classIndexes = classIndexes;\n  hierarchy._parentCounts = parentCounts;\n  hierarchy._parentIndexes = parentIndexes;\n  hierarchy._parentIds = parentIds;\n  hierarchy._byteLength = byteLength;\n}\n\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  let binaryProperties;\n  for (const name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      const property = properties[name];\n      const byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        const componentType = property.componentType;\n        const type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(\n            `Property ${name} requires a batch table binary.`,\n          );\n        }\n\n        const binaryAccessor = getBinaryAccessor(property);\n        const componentCount = binaryAccessor.componentsPerAttribute;\n        const classType = binaryAccessor.classType;\n        const typedArray = binaryAccessor.createArrayBufferView(\n          binaryBody.buffer,\n          binaryBody.byteOffset + byteOffset,\n          featuresLength,\n        );\n\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType,\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\n\nfunction countBinaryPropertyMemory(binaryProperties) {\n  let byteLength = 0;\n  for (const name in binaryProperties) {\n    if (binaryProperties.hasOwnProperty(name)) {\n      byteLength += binaryProperties[name].typedArray.byteLength;\n    }\n  }\n  return byteLength;\n}\n\n//>>includeStart('debug', pragmas.debug);\nconst scratchValidateStack = [];\nfunction validateHierarchy(hierarchy) {\n  const stack = scratchValidateStack;\n  stack.length = 0;\n\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(\n      `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`,\n    );\n  }\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\n      \"Circular dependency detected in the batch table hierarchy.\",\n    );\n  }\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts)\n    ? parentIndexes[instanceIndex]\n    : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n//>>includeEnd('debug');\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nconst scratchVisited = [];\nconst scratchStack = [];\nlet marker = 0;\nfunction traverseHierarchyMultipleParents(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback,\n) {\n  const classIds = hierarchy._classIds;\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\n\nfunction traverseHierarchySingleParent(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback,\n) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy._parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\n\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(\n      hierarchy,\n      instanceIndex,\n      endConditionCallback,\n    );\n  }\n  return traverseHierarchySingleParent(\n    hierarchy,\n    instanceIndex,\n    endConditionCallback,\n  );\n}\n\n/**\n * Returns whether the feature has this property.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.hasProperty = function (batchId, propertyId) {\n  const result = traverseHierarchy(\n    this,\n    batchId,\n    function (hierarchy, instanceIndex) {\n      const classId = hierarchy._classIds[instanceIndex];\n      const instances = hierarchy._classes[classId].instances;\n      if (defined(instances[propertyId])) {\n        return true;\n      }\n    },\n  );\n  return defined(result);\n};\n\n/**\n * Returns whether any feature has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether any feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.propertyExists = function (propertyId) {\n  const classes = this._classes;\n  const classesLength = classes.length;\n  for (let i = 0; i < classesLength; ++i) {\n    const instances = classes[i].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {number} index The index of the entity.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nBatchTableHierarchy.prototype.getPropertyIds = function (batchId, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nBatchTableHierarchy.prototype.getProperty = function (batchId, propertyId) {\n  return traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\n/**\n * Sets the value of the property with the given ID. Only properties of the\n * instance may be set; parent properties may not be set.\n *\n * @param {number} batchId The batchId of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} when setting an inherited property\n * @private\n */\nBatchTableHierarchy.prototype.setProperty = function (\n  batchId,\n  propertyId,\n  value,\n) {\n  const result = traverseHierarchy(\n    this,\n    batchId,\n    function (hierarchy, instanceIndex) {\n      const classId = hierarchy._classIds[instanceIndex];\n      const instanceClass = hierarchy._classes[classId];\n      const indexInClass = hierarchy._classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[propertyId];\n      if (defined(propertyValues)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (instanceIndex !== batchId) {\n          throw new DeveloperError(\n            `Inherited property \"${propertyId}\" is read-only.`,\n          );\n        }\n        //>>includeEnd('debug');\n        if (defined(propertyValues.typedArray)) {\n          setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n    },\n  );\n  return defined(result);\n};\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\n/**\n * Check if a feature belongs to a class with the given name\n *\n * @param {number} batchId The batch ID of the feature\n * @param {string} className The name of the class\n * @return {boolean} <code>true</code> if the feature belongs to the class given by className, or <code>false</code> otherwise\n * @private\n */\nBatchTableHierarchy.prototype.isClass = function (batchId, className) {\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n  // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n  const result = traverseHierarchy(\n    this,\n    batchId,\n    function (hierarchy, instanceIndex) {\n      const classId = hierarchy._classIds[instanceIndex];\n      const instanceClass = hierarchy._classes[classId];\n      if (instanceClass.name === className) {\n        return true;\n      }\n    },\n  );\n  return defined(result);\n};\n\n/**\n * Get the name of the class a given feature belongs to\n *\n * @param {number} batchId The batch ID of the feature\n * @return {string} The name of the class this feature belongs to\n */\nBatchTableHierarchy.prototype.getClassName = function (batchId) {\n  const classId = this._classIds[batchId];\n  const instanceClass = this._classes[classId];\n  return instanceClass.name;\n};\n\nexport default BatchTableHierarchy;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}