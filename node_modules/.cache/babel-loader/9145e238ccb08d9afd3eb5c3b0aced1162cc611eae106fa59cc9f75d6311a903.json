{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport getImageFromTypedArray from \"../../Core/getImageFromTypedArray.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport resizeImageToNextPowerOfTwo from \"../../Core/resizeImageToNextPowerOfTwo.js\";\nimport PixelDatatype from \"../../Renderer/PixelDatatype.js\";\nimport Texture from \"../../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n/**\n * An object to manage loading textures\n *\n * @alias TextureManager\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction TextureManager() {\n  this._defaultTexture = undefined;\n  this._textures = {};\n  this._loadedImages = [];\n\n  // Keep track of the last time update() was called to avoid\n  // calling update() twice.\n  this._lastUpdatedFrame = -1;\n}\n\n/**\n * Get one of the loaded textures\n * @param {string} textureId The unique ID of the texture loaded by {@link TextureManager#loadTexture2D}\n * @return {Texture} The texture or <code>undefined</code> if no texture exists\n */\nTextureManager.prototype.getTexture = function (textureId) {\n  return this._textures[textureId];\n};\nfunction fetchTexture2D(textureManager, textureId, textureUniform) {\n  textureUniform.resource.fetchImage().then(function (image) {\n    textureManager._loadedImages.push({\n      id: textureId,\n      image: image,\n      textureUniform: textureUniform\n    });\n  }).catch(function () {\n    const texture = textureManager._textures[textureId];\n    if (defined(texture) && texture !== textureManager._defaultTexture) {\n      texture.destroy();\n    }\n    textureManager._textures[textureId] = textureManager._defaultTexture;\n  });\n}\n\n/**\n * Load a texture 2D asynchronously. Note that {@link TextureManager#update}\n * must be called in the render loop to finish processing the textures.\n *\n * @param {string} textureId A unique ID to identify this texture.\n * @param {TextureUniform} textureUniform A description of the texture\n *\n * @private\n */\nTextureManager.prototype.loadTexture2D = function (textureId, textureUniform) {\n  if (defined(textureUniform.typedArray)) {\n    this._loadedImages.push({\n      id: textureId,\n      textureUniform: textureUniform\n    });\n  } else {\n    fetchTexture2D(this, textureId, textureUniform);\n  }\n};\nfunction createTexture(textureManager, loadedImage, context) {\n  const {\n    id,\n    textureUniform,\n    image\n  } = loadedImage;\n\n  // If the context is WebGL1, and the sampler needs mipmaps or repeating\n  // boundary conditions, the image may need to be resized first\n  const texture = context.webgl2 ? getTextureAndMips(textureUniform, image, context) : getWebGL1Texture(textureUniform, image, context);\n\n  // Destroy the old texture once the new one is loaded for more seamless\n  // transitions between values\n  const oldTexture = textureManager._textures[id];\n  if (defined(oldTexture) && oldTexture !== context.defaultTexture) {\n    oldTexture.destroy();\n  }\n  textureManager._textures[id] = texture;\n}\nfunction getTextureAndMips(textureUniform, image, context) {\n  const {\n    typedArray,\n    sampler\n  } = textureUniform;\n  const texture = defined(typedArray) ? getTextureFromTypedArray(textureUniform, context) : new Texture({\n    context,\n    source: image,\n    sampler\n  });\n  if (samplerRequiresMipmap(sampler)) {\n    texture.generateMipmap();\n  }\n  return texture;\n}\nfunction getWebGL1Texture(textureUniform, image, context) {\n  const {\n    typedArray,\n    sampler\n  } = textureUniform;\n\n  // WebGL1 requires power-of-two texture dimensions for mipmapping and REPEAT wrap modes\n  const needMipmap = samplerRequiresMipmap(sampler);\n  const samplerRepeats = sampler.wrapS === TextureWrap.REPEAT || sampler.wrapS === TextureWrap.MIRRORED_REPEAT || sampler.wrapT === TextureWrap.REPEAT || sampler.wrapT === TextureWrap.MIRRORED_REPEAT;\n  const {\n    width,\n    height\n  } = defined(typedArray) ? textureUniform : image;\n  const isPowerOfTwo = [width, height].every(CesiumMath.isPowerOfTwo);\n  const requiresResize = (needMipmap || samplerRepeats) && !isPowerOfTwo;\n  if (!requiresResize) {\n    return getTextureAndMips(textureUniform, image, context);\n  } else if (!defined(typedArray)) {\n    const resizedImage = resizeImageToNextPowerOfTwo(image);\n    return getTextureAndMips(textureUniform, resizedImage, context);\n  } else if (textureUniform.pixelDatatype === PixelDatatype.UNSIGNED_BYTE) {\n    const imageFromArray = getImageFromTypedArray(typedArray, width, height);\n    const resizedImage = resizeImageToNextPowerOfTwo(imageFromArray);\n    return getTextureAndMips({\n      sampler\n    }, resizedImage, context);\n  }\n\n  // typedArray is non-power-of-two but can't be resized. Warn and return raw texture (no mipmaps)\n  if (needMipmap) {\n    console.warn(\"Texture requires resizing for mipmaps but pixelDataType cannot be resized. The texture may be rendered incorrectly.\");\n  } else if (samplerRepeats) {\n    console.warn(\"Texture requires resizing for wrapping but pixelDataType cannot be resized. The texture may be rendered incorrectly.\");\n  }\n  return getTextureFromTypedArray(textureUniform, context);\n}\nfunction samplerRequiresMipmap(sampler) {\n  return [TextureMinificationFilter.NEAREST_MIPMAP_NEAREST, TextureMinificationFilter.NEAREST_MIPMAP_LINEAR, TextureMinificationFilter.LINEAR_MIPMAP_NEAREST, TextureMinificationFilter.LINEAR_MIPMAP_LINEAR].includes(sampler.minificationFilter);\n}\nfunction getTextureFromTypedArray(textureUniform, context) {\n  const {\n    pixelFormat,\n    pixelDatatype,\n    width,\n    height,\n    typedArray: arrayBufferView,\n    sampler\n  } = textureUniform;\n  return new Texture({\n    context,\n    pixelFormat,\n    pixelDatatype,\n    source: {\n      arrayBufferView,\n      width,\n      height\n    },\n    sampler,\n    flipY: false\n  });\n}\nTextureManager.prototype.update = function (frameState) {\n  // update only needs to be called once a frame.\n  if (frameState.frameNumber === this._lastUpdatedFrame) {\n    return;\n  }\n  this._lastUpdatedFrame = frameState.frameNumber;\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  // If any images were loaded since the last frame, create Textures\n  // for them and store in the uniform dictionary\n  const loadedImages = this._loadedImages;\n  for (let i = 0; i < loadedImages.length; i++) {\n    const loadedImage = loadedImages[i];\n    createTexture(this, loadedImage, context);\n  }\n  loadedImages.length = 0;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureManager#destroy\n * @private\n */\nTextureManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * textureManager = textureManager && textureManager.destroy();\n *\n * @see TextureManager#isDestroyed\n * @private\n */\nTextureManager.prototype.destroy = function () {\n  const textures = this._textures;\n  for (const texture in textures) {\n    if (textures.hasOwnProperty(texture)) {\n      const instance = textures[texture];\n      if (instance !== this._defaultTexture) {\n        instance.destroy();\n      }\n    }\n  }\n  return destroyObject(this);\n};\nexport default TextureManager;","map":{"version":3,"names":["defined","destroyObject","getImageFromTypedArray","CesiumMath","resizeImageToNextPowerOfTwo","PixelDatatype","Texture","TextureMinificationFilter","TextureWrap","TextureManager","_defaultTexture","undefined","_textures","_loadedImages","_lastUpdatedFrame","prototype","getTexture","textureId","fetchTexture2D","textureManager","textureUniform","resource","fetchImage","then","image","push","id","catch","texture","destroy","loadTexture2D","typedArray","createTexture","loadedImage","context","webgl2","getTextureAndMips","getWebGL1Texture","oldTexture","defaultTexture","sampler","getTextureFromTypedArray","source","samplerRequiresMipmap","generateMipmap","needMipmap","samplerRepeats","wrapS","REPEAT","MIRRORED_REPEAT","wrapT","width","height","isPowerOfTwo","every","requiresResize","resizedImage","pixelDatatype","UNSIGNED_BYTE","imageFromArray","console","warn","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","includes","minificationFilter","pixelFormat","arrayBufferView","flipY","update","frameState","frameNumber","loadedImages","i","length","isDestroyed","textures","hasOwnProperty","instance"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/TextureManager.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport getImageFromTypedArray from \"../../Core/getImageFromTypedArray.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport resizeImageToNextPowerOfTwo from \"../../Core/resizeImageToNextPowerOfTwo.js\";\nimport PixelDatatype from \"../../Renderer/PixelDatatype.js\";\nimport Texture from \"../../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n/**\n * An object to manage loading textures\n *\n * @alias TextureManager\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction TextureManager() {\n  this._defaultTexture = undefined;\n  this._textures = {};\n  this._loadedImages = [];\n\n  // Keep track of the last time update() was called to avoid\n  // calling update() twice.\n  this._lastUpdatedFrame = -1;\n}\n\n/**\n * Get one of the loaded textures\n * @param {string} textureId The unique ID of the texture loaded by {@link TextureManager#loadTexture2D}\n * @return {Texture} The texture or <code>undefined</code> if no texture exists\n */\nTextureManager.prototype.getTexture = function (textureId) {\n  return this._textures[textureId];\n};\n\nfunction fetchTexture2D(textureManager, textureId, textureUniform) {\n  textureUniform.resource\n    .fetchImage()\n    .then(function (image) {\n      textureManager._loadedImages.push({\n        id: textureId,\n        image: image,\n        textureUniform: textureUniform,\n      });\n    })\n    .catch(function () {\n      const texture = textureManager._textures[textureId];\n      if (defined(texture) && texture !== textureManager._defaultTexture) {\n        texture.destroy();\n      }\n\n      textureManager._textures[textureId] = textureManager._defaultTexture;\n    });\n}\n\n/**\n * Load a texture 2D asynchronously. Note that {@link TextureManager#update}\n * must be called in the render loop to finish processing the textures.\n *\n * @param {string} textureId A unique ID to identify this texture.\n * @param {TextureUniform} textureUniform A description of the texture\n *\n * @private\n */\nTextureManager.prototype.loadTexture2D = function (textureId, textureUniform) {\n  if (defined(textureUniform.typedArray)) {\n    this._loadedImages.push({\n      id: textureId,\n      textureUniform: textureUniform,\n    });\n  } else {\n    fetchTexture2D(this, textureId, textureUniform);\n  }\n};\n\nfunction createTexture(textureManager, loadedImage, context) {\n  const { id, textureUniform, image } = loadedImage;\n\n  // If the context is WebGL1, and the sampler needs mipmaps or repeating\n  // boundary conditions, the image may need to be resized first\n  const texture = context.webgl2\n    ? getTextureAndMips(textureUniform, image, context)\n    : getWebGL1Texture(textureUniform, image, context);\n\n  // Destroy the old texture once the new one is loaded for more seamless\n  // transitions between values\n  const oldTexture = textureManager._textures[id];\n  if (defined(oldTexture) && oldTexture !== context.defaultTexture) {\n    oldTexture.destroy();\n  }\n  textureManager._textures[id] = texture;\n}\n\nfunction getTextureAndMips(textureUniform, image, context) {\n  const { typedArray, sampler } = textureUniform;\n\n  const texture = defined(typedArray)\n    ? getTextureFromTypedArray(textureUniform, context)\n    : new Texture({ context, source: image, sampler });\n\n  if (samplerRequiresMipmap(sampler)) {\n    texture.generateMipmap();\n  }\n\n  return texture;\n}\n\nfunction getWebGL1Texture(textureUniform, image, context) {\n  const { typedArray, sampler } = textureUniform;\n\n  // WebGL1 requires power-of-two texture dimensions for mipmapping and REPEAT wrap modes\n  const needMipmap = samplerRequiresMipmap(sampler);\n\n  const samplerRepeats =\n    sampler.wrapS === TextureWrap.REPEAT ||\n    sampler.wrapS === TextureWrap.MIRRORED_REPEAT ||\n    sampler.wrapT === TextureWrap.REPEAT ||\n    sampler.wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  const { width, height } = defined(typedArray) ? textureUniform : image;\n  const isPowerOfTwo = [width, height].every(CesiumMath.isPowerOfTwo);\n  const requiresResize = (needMipmap || samplerRepeats) && !isPowerOfTwo;\n\n  if (!requiresResize) {\n    return getTextureAndMips(textureUniform, image, context);\n  } else if (!defined(typedArray)) {\n    const resizedImage = resizeImageToNextPowerOfTwo(image);\n    return getTextureAndMips(textureUniform, resizedImage, context);\n  } else if (textureUniform.pixelDatatype === PixelDatatype.UNSIGNED_BYTE) {\n    const imageFromArray = getImageFromTypedArray(typedArray, width, height);\n    const resizedImage = resizeImageToNextPowerOfTwo(imageFromArray);\n    return getTextureAndMips({ sampler }, resizedImage, context);\n  }\n\n  // typedArray is non-power-of-two but can't be resized. Warn and return raw texture (no mipmaps)\n  if (needMipmap) {\n    console.warn(\n      \"Texture requires resizing for mipmaps but pixelDataType cannot be resized. The texture may be rendered incorrectly.\",\n    );\n  } else if (samplerRepeats) {\n    console.warn(\n      \"Texture requires resizing for wrapping but pixelDataType cannot be resized. The texture may be rendered incorrectly.\",\n    );\n  }\n  return getTextureFromTypedArray(textureUniform, context);\n}\n\nfunction samplerRequiresMipmap(sampler) {\n  return [\n    TextureMinificationFilter.NEAREST_MIPMAP_NEAREST,\n    TextureMinificationFilter.NEAREST_MIPMAP_LINEAR,\n    TextureMinificationFilter.LINEAR_MIPMAP_NEAREST,\n    TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n  ].includes(sampler.minificationFilter);\n}\n\nfunction getTextureFromTypedArray(textureUniform, context) {\n  const {\n    pixelFormat,\n    pixelDatatype,\n    width,\n    height,\n    typedArray: arrayBufferView,\n    sampler,\n  } = textureUniform;\n\n  return new Texture({\n    context,\n    pixelFormat,\n    pixelDatatype,\n    source: { arrayBufferView, width, height },\n    sampler,\n    flipY: false,\n  });\n}\n\nTextureManager.prototype.update = function (frameState) {\n  // update only needs to be called once a frame.\n  if (frameState.frameNumber === this._lastUpdatedFrame) {\n    return;\n  }\n  this._lastUpdatedFrame = frameState.frameNumber;\n\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  // If any images were loaded since the last frame, create Textures\n  // for them and store in the uniform dictionary\n  const loadedImages = this._loadedImages;\n  for (let i = 0; i < loadedImages.length; i++) {\n    const loadedImage = loadedImages[i];\n    createTexture(this, loadedImage, context);\n  }\n  loadedImages.length = 0;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureManager#destroy\n * @private\n */\nTextureManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * textureManager = textureManager && textureManager.destroy();\n *\n * @see TextureManager#isDestroyed\n * @private\n */\nTextureManager.prototype.destroy = function () {\n  const textures = this._textures;\n  for (const texture in textures) {\n    if (textures.hasOwnProperty(texture)) {\n      const instance = textures[texture];\n      if (instance !== this._defaultTexture) {\n        instance.destroy();\n      }\n    }\n  }\n  return destroyObject(this);\n};\n\nexport default TextureManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}