{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of pre-triangulated polygons draped on terrain and/or 3D Tiles.\n *\n * @alias Vector3DTilePolygons\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Float32Array|Uint16Array} options.positions The positions of the polygons. The positions must be contiguous\n * so that the positions for polygon n are in [c, c + counts[n]] where c = sum{counts[0], counts[n - 1]} and they are the outer ring of\n * the polygon in counter-clockwise order.\n * @param {Uint32Array} options.counts The number of positions in the each polygon.\n * @param {Uint32Array} options.indices The indices of the triangulated polygons. The indices must be contiguous so that\n * the indices for polygon n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each polygon.\n * @param {number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Float32Array} [options.polygonMinimumHeights] An array containing the minimum heights for each polygon.\n * @param {Float32Array} [options.polygonMaximumHeights] An array containing the maximum heights for each polygon.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polygons.\n * @param {Uint16Array} options.batchIds The batch ids for each polygon.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polygons.\n *\n * @private\n */\nfunction Vector3DTilePolygons(options) {\n  // All of the private properties will be released except _primitive after the Vector3DTilePrimitive is created.\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n  this._positions = options.positions;\n  this._counts = options.counts;\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = undefined;\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n  this._batchedPositions = undefined;\n  this._transferrableBatchIds = undefined;\n  this._vertexBatchIds = undefined;\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._polygonMinimumHeights = options.polygonMinimumHeights;\n  this._polygonMaximumHeights = options.polygonMaximumHeights;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._rectangle = options.rectangle;\n  this._center = undefined;\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification meshes.\n   * @type {boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\nObject.defineProperties(Vector3DTilePolygons.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    }\n  },\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    }\n  },\n  /**\n   * Returns true when the primitive is ready to render.\n   * @memberof Vector3DTilePolygons.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  }\n});\nfunction packBuffer(polygons) {\n  const packedBuffer = new Float64Array(3 + Cartesian3.packedLength + Ellipsoid.packedLength + Rectangle.packedLength);\n  let offset = 0;\n  packedBuffer[offset++] = polygons._indices.BYTES_PER_ELEMENT;\n  packedBuffer[offset++] = polygons._minimumHeight;\n  packedBuffer[offset++] = polygons._maximumHeight;\n  Cartesian3.pack(polygons._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Ellipsoid.pack(polygons._ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n  Rectangle.pack(polygons._rectangle, packedBuffer, offset);\n  return packedBuffer;\n}\nfunction unpackBuffer(polygons, packedBuffer) {\n  let offset = 1;\n  const numBVS = packedBuffer[offset++];\n  const bvs = polygons._boundingVolumes = new Array(numBVS);\n  for (let i = 0; i < numBVS; ++i) {\n    bvs[i] = OrientedBoundingBox.unpack(packedBuffer, offset);\n    offset += OrientedBoundingBox.packedLength;\n  }\n  const numBatchedIndices = packedBuffer[offset++];\n  const bis = polygons._batchedIndices = new Array(numBatchedIndices);\n  for (let j = 0; j < numBatchedIndices; ++j) {\n    const color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n    const indexOffset = packedBuffer[offset++];\n    const count = packedBuffer[offset++];\n    const length = packedBuffer[offset++];\n    const batchIds = new Array(length);\n    for (let k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds\n    });\n  }\n}\nconst createVerticesTaskProcessor = new TaskProcessor(\"createVectorTilePolygons\", 5);\nconst scratchColor = new Color();\nfunction createPrimitive(polygons) {\n  if (defined(polygons._primitive)) {\n    return;\n  }\n  let positions = polygons._positions;\n  let counts = polygons._counts;\n  let indexCounts = polygons._indexCounts;\n  let indices = polygons._indices;\n  let batchIds = polygons._transferrableBatchIds;\n  let batchTableColors = polygons._batchTableColors;\n  let packedBuffer = polygons._packedBuffer;\n  if (!defined(batchTableColors)) {\n    // Copy because they may be the views on the same buffer.\n    positions = polygons._positions = polygons._positions.slice();\n    counts = polygons._counts = polygons._counts.slice();\n    indexCounts = polygons._indexCounts = polygons._indexCounts.slice();\n    indices = polygons._indices = polygons._indices.slice();\n    polygons._center = polygons._ellipsoid.cartographicToCartesian(Rectangle.center(polygons._rectangle));\n    batchIds = polygons._transferrableBatchIds = new Uint32Array(polygons._batchIds);\n    batchTableColors = polygons._batchTableColors = new Uint32Array(batchIds.length);\n    const batchTable = polygons._batchTable;\n    const length = batchTableColors.length;\n    for (let i = 0; i < length; ++i) {\n      const color = batchTable.getColor(i, scratchColor);\n      batchTableColors[i] = color.toRgba();\n    }\n    packedBuffer = polygons._packedBuffer = packBuffer(polygons);\n  }\n  const transferrableObjects = [positions.buffer, counts.buffer, indexCounts.buffer, indices.buffer, batchIds.buffer, batchTableColors.buffer, packedBuffer.buffer];\n  const parameters = {\n    packedBuffer: packedBuffer.buffer,\n    positions: positions.buffer,\n    counts: counts.buffer,\n    indexCounts: indexCounts.buffer,\n    indices: indices.buffer,\n    batchIds: batchIds.buffer,\n    batchTableColors: batchTableColors.buffer\n  };\n  let minimumHeights = polygons._polygonMinimumHeights;\n  let maximumHeights = polygons._polygonMaximumHeights;\n  if (defined(minimumHeights) && defined(maximumHeights)) {\n    minimumHeights = minimumHeights.slice();\n    maximumHeights = maximumHeights.slice();\n    transferrableObjects.push(minimumHeights.buffer, maximumHeights.buffer);\n    parameters.minimumHeights = minimumHeights;\n    parameters.maximumHeights = maximumHeights;\n  }\n  const verticesPromise = createVerticesTaskProcessor.scheduleTask(parameters, transferrableObjects);\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return;\n  }\n  return verticesPromise.then(result => {\n    if (polygons.isDestroyed()) {\n      return;\n    }\n    polygons._positions = undefined;\n    polygons._counts = undefined;\n    polygons._polygonMinimumHeights = undefined;\n    polygons._polygonMaximumHeights = undefined;\n    const packedBuffer = new Float64Array(result.packedBuffer);\n    const indexDatatype = packedBuffer[0];\n    unpackBuffer(polygons, packedBuffer);\n    polygons._indices = IndexDatatype.getSizeInBytes(indexDatatype) === 2 ? new Uint16Array(result.indices) : new Uint32Array(result.indices);\n    polygons._indexOffsets = new Uint32Array(result.indexOffsets);\n    polygons._indexCounts = new Uint32Array(result.indexCounts);\n\n    // will be released\n    polygons._batchedPositions = new Float32Array(result.positions);\n    polygons._vertexBatchIds = new Uint16Array(result.batchIds);\n    finishPrimitive(polygons);\n    polygons._ready = true;\n  }).catch(error => {\n    if (polygons.isDestroyed()) {\n      return;\n    }\n\n    // Throw the error next frame\n    polygons._error = error;\n  });\n}\nfunction finishPrimitive(polygons) {\n  if (!defined(polygons._primitive)) {\n    polygons._primitive = new Vector3DTilePrimitive({\n      batchTable: polygons._batchTable,\n      positions: polygons._batchedPositions,\n      batchIds: polygons._batchIds,\n      vertexBatchIds: polygons._vertexBatchIds,\n      indices: polygons._indices,\n      indexOffsets: polygons._indexOffsets,\n      indexCounts: polygons._indexCounts,\n      batchedIndices: polygons._batchedIndices,\n      boundingVolume: polygons._boundingVolume,\n      boundingVolumes: polygons._boundingVolumes,\n      center: polygons._center\n    });\n    polygons._batchTable = undefined;\n    polygons._batchIds = undefined;\n    polygons._positions = undefined;\n    polygons._counts = undefined;\n    polygons._indices = undefined;\n    polygons._indexCounts = undefined;\n    polygons._indexOffsets = undefined;\n    polygons._batchTableColors = undefined;\n    polygons._packedBuffer = undefined;\n    polygons._batchedPositions = undefined;\n    polygons._transferrableBatchIds = undefined;\n    polygons._vertexBatchIds = undefined;\n    polygons._ellipsoid = undefined;\n    polygons._minimumHeight = undefined;\n    polygons._maximumHeight = undefined;\n    polygons._polygonMinimumHeights = undefined;\n    polygons._polygonMaximumHeights = undefined;\n    polygons._center = undefined;\n    polygons._rectangle = undefined;\n    polygons._boundingVolume = undefined;\n    polygons._boundingVolumes = undefined;\n    polygons._batchedIndices = undefined;\n  }\n}\n\n/**\n * Creates features for each polygon and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolygons.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polygon batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolygons.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolygons.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a polygon with batchId changes color. The polygons will need to be re-batched\n * on the next update.\n *\n * @param {number} batchId The batch id of the polygon whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePolygons.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolygons.prototype.update = function (frameState) {\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = createPrimitive(this);\n    }\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n    return;\n  }\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolygons.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolygons.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolygons;","map":{"version":3,"names":["Cartesian3","Color","defaultValue","defined","destroyObject","Ellipsoid","IndexDatatype","OrientedBoundingBox","Rectangle","TaskProcessor","ClassificationType","Vector3DTileBatch","Vector3DTilePrimitive","Vector3DTilePolygons","options","_batchTable","batchTable","_batchIds","batchIds","_positions","positions","_counts","counts","_indices","indices","_indexCounts","indexCounts","_indexOffsets","undefined","_batchTableColors","_packedBuffer","_batchedPositions","_transferrableBatchIds","_vertexBatchIds","_ellipsoid","ellipsoid","WGS84","_minimumHeight","minimumHeight","_maximumHeight","maximumHeight","_polygonMinimumHeights","polygonMinimumHeights","_polygonMaximumHeights","polygonMaximumHeights","_center","center","ZERO","_rectangle","rectangle","_boundingVolume","boundingVolume","_boundingVolumes","_batchedIndices","_ready","_promise","_error","_primitive","debugWireframe","forceRebatch","classificationType","BOTH","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","ready","packBuffer","polygons","packedBuffer","Float64Array","packedLength","offset","BYTES_PER_ELEMENT","pack","unpackBuffer","numBVS","bvs","Array","i","unpack","numBatchedIndices","bis","j","color","indexOffset","count","length","k","createVerticesTaskProcessor","scratchColor","createPrimitive","batchTableColors","slice","cartographicToCartesian","Uint32Array","getColor","toRgba","transferrableObjects","buffer","parameters","minimumHeights","maximumHeights","push","verticesPromise","scheduleTask","then","result","isDestroyed","indexDatatype","getSizeInBytes","Uint16Array","indexOffsets","Float32Array","finishPrimitive","catch","error","vertexBatchIds","batchedIndices","boundingVolumes","createFeatures","content","features","applyDebugSettings","enabled","applyStyle","style","updateCommands","batchId","update","frameState","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Vector3DTilePolygons.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of pre-triangulated polygons draped on terrain and/or 3D Tiles.\n *\n * @alias Vector3DTilePolygons\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Float32Array|Uint16Array} options.positions The positions of the polygons. The positions must be contiguous\n * so that the positions for polygon n are in [c, c + counts[n]] where c = sum{counts[0], counts[n - 1]} and they are the outer ring of\n * the polygon in counter-clockwise order.\n * @param {Uint32Array} options.counts The number of positions in the each polygon.\n * @param {Uint32Array} options.indices The indices of the triangulated polygons. The indices must be contiguous so that\n * the indices for polygon n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each polygon.\n * @param {number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Float32Array} [options.polygonMinimumHeights] An array containing the minimum heights for each polygon.\n * @param {Float32Array} [options.polygonMaximumHeights] An array containing the maximum heights for each polygon.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polygons.\n * @param {Uint16Array} options.batchIds The batch ids for each polygon.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polygons.\n *\n * @private\n */\nfunction Vector3DTilePolygons(options) {\n  // All of the private properties will be released except _primitive after the Vector3DTilePrimitive is created.\n  this._batchTable = options.batchTable;\n\n  this._batchIds = options.batchIds;\n  this._positions = options.positions;\n  this._counts = options.counts;\n\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = undefined;\n\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n\n  this._batchedPositions = undefined;\n  this._transferrableBatchIds = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._polygonMinimumHeights = options.polygonMinimumHeights;\n  this._polygonMaximumHeights = options.polygonMaximumHeights;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._rectangle = options.rectangle;\n\n  this._center = undefined;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = undefined;\n\n  this._batchedIndices = undefined;\n\n  this._ready = false;\n  this._promise = undefined;\n  this._error = undefined;\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification meshes.\n   * @type {boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTilePolygons.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Returns true when the primitive is ready to render.\n   * @memberof Vector3DTilePolygons.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n});\n\nfunction packBuffer(polygons) {\n  const packedBuffer = new Float64Array(\n    3 +\n      Cartesian3.packedLength +\n      Ellipsoid.packedLength +\n      Rectangle.packedLength,\n  );\n\n  let offset = 0;\n  packedBuffer[offset++] = polygons._indices.BYTES_PER_ELEMENT;\n\n  packedBuffer[offset++] = polygons._minimumHeight;\n  packedBuffer[offset++] = polygons._maximumHeight;\n\n  Cartesian3.pack(polygons._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n\n  Ellipsoid.pack(polygons._ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Rectangle.pack(polygons._rectangle, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nfunction unpackBuffer(polygons, packedBuffer) {\n  let offset = 1;\n\n  const numBVS = packedBuffer[offset++];\n  const bvs = (polygons._boundingVolumes = new Array(numBVS));\n\n  for (let i = 0; i < numBVS; ++i) {\n    bvs[i] = OrientedBoundingBox.unpack(packedBuffer, offset);\n    offset += OrientedBoundingBox.packedLength;\n  }\n\n  const numBatchedIndices = packedBuffer[offset++];\n  const bis = (polygons._batchedIndices = new Array(numBatchedIndices));\n\n  for (let j = 0; j < numBatchedIndices; ++j) {\n    const color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n\n    const indexOffset = packedBuffer[offset++];\n    const count = packedBuffer[offset++];\n\n    const length = packedBuffer[offset++];\n    const batchIds = new Array(length);\n\n    for (let k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds,\n    });\n  }\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTilePolygons\",\n  5,\n);\nconst scratchColor = new Color();\n\nfunction createPrimitive(polygons) {\n  if (defined(polygons._primitive)) {\n    return;\n  }\n\n  let positions = polygons._positions;\n  let counts = polygons._counts;\n  let indexCounts = polygons._indexCounts;\n  let indices = polygons._indices;\n\n  let batchIds = polygons._transferrableBatchIds;\n  let batchTableColors = polygons._batchTableColors;\n\n  let packedBuffer = polygons._packedBuffer;\n\n  if (!defined(batchTableColors)) {\n    // Copy because they may be the views on the same buffer.\n    positions = polygons._positions = polygons._positions.slice();\n    counts = polygons._counts = polygons._counts.slice();\n    indexCounts = polygons._indexCounts = polygons._indexCounts.slice();\n    indices = polygons._indices = polygons._indices.slice();\n\n    polygons._center = polygons._ellipsoid.cartographicToCartesian(\n      Rectangle.center(polygons._rectangle),\n    );\n\n    batchIds = polygons._transferrableBatchIds = new Uint32Array(\n      polygons._batchIds,\n    );\n    batchTableColors = polygons._batchTableColors = new Uint32Array(\n      batchIds.length,\n    );\n    const batchTable = polygons._batchTable;\n\n    const length = batchTableColors.length;\n    for (let i = 0; i < length; ++i) {\n      const color = batchTable.getColor(i, scratchColor);\n      batchTableColors[i] = color.toRgba();\n    }\n\n    packedBuffer = polygons._packedBuffer = packBuffer(polygons);\n  }\n\n  const transferrableObjects = [\n    positions.buffer,\n    counts.buffer,\n    indexCounts.buffer,\n    indices.buffer,\n    batchIds.buffer,\n    batchTableColors.buffer,\n    packedBuffer.buffer,\n  ];\n  const parameters = {\n    packedBuffer: packedBuffer.buffer,\n    positions: positions.buffer,\n    counts: counts.buffer,\n    indexCounts: indexCounts.buffer,\n    indices: indices.buffer,\n    batchIds: batchIds.buffer,\n    batchTableColors: batchTableColors.buffer,\n  };\n\n  let minimumHeights = polygons._polygonMinimumHeights;\n  let maximumHeights = polygons._polygonMaximumHeights;\n  if (defined(minimumHeights) && defined(maximumHeights)) {\n    minimumHeights = minimumHeights.slice();\n    maximumHeights = maximumHeights.slice();\n\n    transferrableObjects.push(minimumHeights.buffer, maximumHeights.buffer);\n    parameters.minimumHeights = minimumHeights;\n    parameters.maximumHeights = maximumHeights;\n  }\n\n  const verticesPromise = createVerticesTaskProcessor.scheduleTask(\n    parameters,\n    transferrableObjects,\n  );\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return;\n  }\n\n  return verticesPromise\n    .then((result) => {\n      if (polygons.isDestroyed()) {\n        return;\n      }\n\n      polygons._positions = undefined;\n      polygons._counts = undefined;\n      polygons._polygonMinimumHeights = undefined;\n      polygons._polygonMaximumHeights = undefined;\n\n      const packedBuffer = new Float64Array(result.packedBuffer);\n      const indexDatatype = packedBuffer[0];\n      unpackBuffer(polygons, packedBuffer);\n\n      polygons._indices =\n        IndexDatatype.getSizeInBytes(indexDatatype) === 2\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n      polygons._indexOffsets = new Uint32Array(result.indexOffsets);\n      polygons._indexCounts = new Uint32Array(result.indexCounts);\n\n      // will be released\n      polygons._batchedPositions = new Float32Array(result.positions);\n      polygons._vertexBatchIds = new Uint16Array(result.batchIds);\n\n      finishPrimitive(polygons);\n\n      polygons._ready = true;\n    })\n    .catch((error) => {\n      if (polygons.isDestroyed()) {\n        return;\n      }\n\n      // Throw the error next frame\n      polygons._error = error;\n    });\n}\n\nfunction finishPrimitive(polygons) {\n  if (!defined(polygons._primitive)) {\n    polygons._primitive = new Vector3DTilePrimitive({\n      batchTable: polygons._batchTable,\n      positions: polygons._batchedPositions,\n      batchIds: polygons._batchIds,\n      vertexBatchIds: polygons._vertexBatchIds,\n      indices: polygons._indices,\n      indexOffsets: polygons._indexOffsets,\n      indexCounts: polygons._indexCounts,\n      batchedIndices: polygons._batchedIndices,\n      boundingVolume: polygons._boundingVolume,\n      boundingVolumes: polygons._boundingVolumes,\n      center: polygons._center,\n    });\n\n    polygons._batchTable = undefined;\n    polygons._batchIds = undefined;\n    polygons._positions = undefined;\n    polygons._counts = undefined;\n    polygons._indices = undefined;\n    polygons._indexCounts = undefined;\n    polygons._indexOffsets = undefined;\n    polygons._batchTableColors = undefined;\n    polygons._packedBuffer = undefined;\n    polygons._batchedPositions = undefined;\n    polygons._transferrableBatchIds = undefined;\n    polygons._vertexBatchIds = undefined;\n    polygons._ellipsoid = undefined;\n    polygons._minimumHeight = undefined;\n    polygons._maximumHeight = undefined;\n    polygons._polygonMinimumHeights = undefined;\n    polygons._polygonMaximumHeights = undefined;\n    polygons._center = undefined;\n    polygons._rectangle = undefined;\n    polygons._boundingVolume = undefined;\n    polygons._boundingVolumes = undefined;\n    polygons._batchedIndices = undefined;\n  }\n}\n\n/**\n * Creates features for each polygon and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolygons.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polygon batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolygons.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolygons.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a polygon with batchId changes color. The polygons will need to be re-batched\n * on the next update.\n *\n * @param {number} batchId The batch id of the polygon whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePolygons.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolygons.prototype.update = function (frameState) {\n  if (!this._ready) {\n    if (!defined(this._promise)) {\n      this._promise = createPrimitive(this);\n    }\n\n    if (defined(this._error)) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n\n    return;\n  }\n\n  this._primitive.debugWireframe = this.debugWireframe;\n  this._primitive.forceRebatch = this.forceRebatch;\n  this._primitive.classificationType = this.classificationType;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolygons.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolygons.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolygons;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}