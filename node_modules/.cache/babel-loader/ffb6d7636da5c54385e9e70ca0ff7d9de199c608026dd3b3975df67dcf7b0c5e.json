{"ast":null,"code":"import Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Cesium3DTile from \"./Cesium3DTile.js\";\nimport I3SDataProvider from \"./I3SDataProvider.js\";\nimport I3SDecoder from \"./I3SDecoder.js\";\nimport I3SFeature from \"./I3SFeature.js\";\nimport I3SField from \"./I3SField.js\";\nimport I3SGeometry from \"./I3SGeometry.js\";\n\n/**\n * @typedef {object} I3SNode.AttributeFilter\n *\n * A filter given by an attribute name and values.\n * The 3D feature object should be hidden if its value for the attribute name is not specified in the collection of values.\n *\n * @property {string} name The name of the attribute\n * @property {string[]|number[]} values The collection of values\n */\n\n/**\n * This class implements an I3S Node. In CesiumJS each I3SNode creates a Cesium3DTile.\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SLayer}.\n * </p>\n * @alias I3SNode\n * @internalConstructor\n */\nfunction I3SNode(parent, ref, isRoot) {\n  let level;\n  let layer;\n  let nodeIndex;\n  let resource;\n  if (isRoot) {\n    level = 0;\n    layer = parent;\n  } else {\n    level = parent._level + 1;\n    layer = parent._layer;\n  }\n  if (typeof ref === \"number\") {\n    nodeIndex = ref;\n  } else {\n    resource = parent.resource.getDerivedResource({\n      url: `${ref}/`\n    });\n  }\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  this._isRoot = isRoot;\n  this._level = level;\n  this._layer = layer;\n  this._nodeIndex = nodeIndex;\n  this._resource = resource;\n  this._isLoading = false;\n  this._tile = undefined;\n  this._data = undefined;\n  this._geometryData = [];\n  this._featureData = [];\n  this._fields = {};\n  this._children = [];\n  this._childrenReadyPromise = undefined;\n  this._globalTransform = undefined;\n  this._inverseGlobalTransform = undefined;\n  this._inverseRotationMatrix = undefined;\n  this._symbologyData = undefined;\n}\nObject.defineProperties(I3SNode.prototype, {\n  /**\n   * Gets the resource for the node.\n   * @memberof I3SNode.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    }\n  },\n  /**\n   * Gets the parent layer.\n   * @memberof I3SNode.prototype\n   * @type {I3SLayer}\n   * @readonly\n   */\n  layer: {\n    get: function () {\n      return this._layer;\n    }\n  },\n  /**\n   * Gets the parent node.\n   * @memberof I3SNode.prototype\n   * @type {I3SNode|undefined}\n   * @readonly\n   */\n  parent: {\n    get: function () {\n      return this._parent;\n    }\n  },\n  /**\n   * Gets the children nodes.\n   * @memberof I3SNode.prototype\n   * @type {I3SNode[]}\n   * @readonly\n   */\n  children: {\n    get: function () {\n      return this._children;\n    }\n  },\n  /**\n   * Gets the collection of geometries.\n   * @memberof I3SNode.prototype\n   * @type {I3SGeometry[]}\n   * @readonly\n   */\n  geometryData: {\n    get: function () {\n      return this._geometryData;\n    }\n  },\n  /**\n   * Gets the collection of features.\n   * @memberof I3SNode.prototype\n   * @type {I3SFeature[]}\n   * @readonly\n   */\n  featureData: {\n    get: function () {\n      return this._featureData;\n    }\n  },\n  /**\n   * Gets the collection of fields.\n   * @memberof I3SNode.prototype\n   * @type {I3SField[]}\n   * @readonly\n   */\n  fields: {\n    get: function () {\n      return this._fields;\n    }\n  },\n  /**\n   * Gets the Cesium3DTile for this node.\n   * @memberof I3SNode.prototype\n   * @type {Cesium3DTile}\n   * @readonly\n   */\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SNode.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    }\n  }\n});\n\n/**\n * @private\n */\nI3SNode.prototype.load = async function () {\n  const that = this;\n  function processData() {\n    if (!that._isRoot) {\n      // Create a new tile\n      const tileDefinition = that._create3DTileDefinition();\n      that._tile = new Cesium3DTile(that._layer._tileset, that._dataProvider.resource, tileDefinition, that._parent._tile);\n      that._tile._i3sNode = that;\n    }\n  }\n\n  // If we don't have a nodepage index load from json\n  if (!defined(this._nodeIndex)) {\n    const data = await I3SDataProvider.loadJson(this._resource);\n    that._data = data;\n    processData();\n    return;\n  }\n  const node = await this._layer._getNodeInNodePages(this._nodeIndex);\n  that._data = node;\n  let uri;\n  if (that._isRoot) {\n    uri = \"nodes/root/\";\n  } else if (defined(node.mesh)) {\n    const uriIndex = node.mesh.geometry.resource;\n    uri = `../${uriIndex}/`;\n  }\n  if (defined(uri) && defined(that._parent.resource)) {\n    that._resource = that._parent.resource.getDerivedResource({\n      url: uri\n    });\n  }\n  processData();\n};\nfunction createAndLoadField(node, storageInfo) {\n  const newField = new I3SField(node, storageInfo);\n  node._fields[storageInfo.name] = newField;\n  return newField.load();\n}\n\n/**\n * Loads the node fields.\n * @returns {Promise<void>} A promise that is resolved when the I3S Node fields are loaded\n */\nI3SNode.prototype.loadFields = function () {\n  // Check if we must load fields\n  const fields = this._layer._data.attributeStorageInfo;\n  const promises = [];\n  if (defined(fields)) {\n    for (let i = 0; i < fields.length; i++) {\n      const storageInfo = fields[i];\n      const field = this._fields[storageInfo.name];\n      if (defined(field)) {\n        promises.push(field.load());\n      } else {\n        promises.push(createAndLoadField(this, storageInfo));\n      }\n    }\n  }\n  return Promise.all(promises);\n};\n\n/**\n * Loads the node field.\n * @param {string} name The field name\n * @returns {Promise<void>} A promise that is resolved when the I3S Node field is loaded\n */\nI3SNode.prototype.loadField = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"name\", name);\n  //>>includeEnd('debug');\n\n  const field = this._fields[name];\n  if (defined(field)) {\n    return field.load();\n  }\n  const fields = this._layer._data.attributeStorageInfo;\n  if (defined(fields)) {\n    for (let i = 0; i < fields.length; i++) {\n      const storageInfo = fields[i];\n      if (storageInfo.name === name) {\n        return createAndLoadField(this, storageInfo);\n      }\n    }\n  }\n  return Promise.resolve();\n};\n\n/**\n * Returns the fields for a given picked position\n * @param {Cartesian3} pickedPosition The picked position\n * @returns {object} Object containing field names and their values\n */\nI3SNode.prototype.getFieldsForPickedPosition = function (pickedPosition) {\n  const geometry = this.geometryData[0];\n  if (!defined(geometry.customAttributes.featureIndex)) {\n    return {};\n  }\n  const location = geometry.getClosestPointIndexOnTriangle(pickedPosition.x, pickedPosition.y, pickedPosition.z);\n  if (location.index === -1 || location.index > geometry.customAttributes.featureIndex.length) {\n    return {};\n  }\n  const featureIndex = geometry.customAttributes.featureIndex[location.index];\n  return this.getFieldsForFeature(featureIndex);\n};\n\n/**\n * Returns the fields for a given feature\n * @param {number} featureIndex Index of the feature whose attributes we want to get\n * @returns {object} Object containing field names and their values\n */\nI3SNode.prototype.getFieldsForFeature = function (featureIndex) {\n  const featureFields = {};\n  for (const fieldName in this.fields) {\n    if (this.fields.hasOwnProperty(fieldName)) {\n      const field = this.fields[fieldName];\n      if (featureIndex >= 0 && featureIndex < field.values.length) {\n        featureFields[field.name] = field.values[featureIndex];\n      }\n    }\n  }\n  return featureFields;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadChildren = function () {\n  const that = this;\n  // If the promise for loading the children was already created, just return it\n  if (defined(this._childrenReadyPromise)) {\n    return this._childrenReadyPromise;\n  }\n  const childPromises = [];\n  if (defined(that._data.children)) {\n    for (let childIndex = 0; childIndex < that._data.children.length; childIndex++) {\n      const child = that._data.children[childIndex];\n      const newChild = new I3SNode(that, defaultValue(child.href, child), false);\n      that._children.push(newChild);\n      childPromises.push(newChild.load());\n    }\n  }\n  this._childrenReadyPromise = Promise.all(childPromises).then(function () {\n    for (let i = 0; i < that._children.length; i++) {\n      that._tile.children.push(that._children[i]._tile);\n    }\n  });\n  return this._childrenReadyPromise;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadGeometryData = function () {\n  const geometryPromises = [];\n\n  // To debug decoding for a specific tile, add a condition\n  // that wraps this if/else to match the tile uri\n  if (defined(this._data.geometryData)) {\n    for (let geomIndex = 0; geomIndex < this._data.geometryData.length; geomIndex++) {\n      const curGeometryData = new I3SGeometry(this, this._data.geometryData[geomIndex].href);\n      this._geometryData.push(curGeometryData);\n      geometryPromises.push(curGeometryData.load());\n    }\n  } else if (defined(this._data.mesh)) {\n    const geometryDefinition = this._layer._findBestGeometryBuffers(this._data.mesh.geometry.definition, [\"position\", \"uv0\"]);\n    const geometryURI = `./geometries/${geometryDefinition.bufferIndex}/`;\n    const newGeometryData = new I3SGeometry(this, geometryURI);\n    newGeometryData._geometryDefinitions = geometryDefinition.definition;\n    newGeometryData._geometryBufferInfo = geometryDefinition.geometryBufferInfo;\n    this._geometryData.push(newGeometryData);\n    geometryPromises.push(newGeometryData.load());\n  }\n  return Promise.all(geometryPromises);\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadFeatureData = function () {\n  const featurePromises = [];\n\n  // To debug decoding for a specific tile, add a condition\n  // that wraps this if/else to match the tile uri\n  if (defined(this._data.featureData)) {\n    for (let featureIndex = 0; featureIndex < this._data.featureData.length; featureIndex++) {\n      const newFeatureData = new I3SFeature(this, this._data.featureData[featureIndex].href);\n      this._featureData.push(newFeatureData);\n      featurePromises.push(newFeatureData.load());\n    }\n  }\n  return Promise.all(featurePromises);\n};\n\n/**\n * @private\n */\nI3SNode.prototype._clearGeometryData = function () {\n  this._geometryData = [];\n};\n\n/**\n * @private\n */\nI3SNode.prototype._create3DTileDefinition = function () {\n  const obb = this._data.obb;\n  const mbs = this._data.mbs;\n  if (!defined(obb) && !defined(mbs)) {\n    console.error(\"Failed to load I3S node. Bounding volume is required.\");\n    return undefined;\n  }\n  let geoPosition;\n  if (defined(obb)) {\n    geoPosition = Cartographic.fromDegrees(obb.center[0], obb.center[1], obb.center[2]);\n  } else {\n    geoPosition = Cartographic.fromDegrees(mbs[0], mbs[1], mbs[2]);\n  }\n\n  // Offset bounding box position if we have a geoid service defined\n  if (defined(this._dataProvider._geoidDataList) && defined(geoPosition)) {\n    for (let i = 0; i < this._dataProvider._geoidDataList.length; i++) {\n      const tile = this._dataProvider._geoidDataList[i];\n      const projectedPos = tile.projection.project(geoPosition);\n      if (projectedPos.x > tile.nativeExtent.west && projectedPos.x < tile.nativeExtent.east && projectedPos.y > tile.nativeExtent.south && projectedPos.y < tile.nativeExtent.north) {\n        geoPosition.height += sampleGeoid(projectedPos.x, projectedPos.y, tile);\n        break;\n      }\n    }\n  }\n  let boundingVolume = {};\n  let position;\n  let span = 0;\n  if (defined(obb)) {\n    boundingVolume = {\n      box: [0, 0, 0, obb.halfSize[0], 0, 0, 0, obb.halfSize[1], 0, 0, 0, obb.halfSize[2]]\n    };\n    span = Math.max(Math.max(this._data.obb.halfSize[0], this._data.obb.halfSize[1]), this._data.obb.halfSize[2]);\n    position = Ellipsoid.WGS84.cartographicToCartesian(geoPosition);\n  } else {\n    boundingVolume = {\n      sphere: [0, 0, 0, mbs[3]]\n    };\n    position = Ellipsoid.WGS84.cartographicToCartesian(geoPosition);\n    span = this._data.mbs[3];\n  }\n  span *= 2;\n  // Compute the geometric error\n  let metersPerPixel = Infinity;\n\n  // Get the meters/pixel density required to pop the next LOD\n  if (defined(this._data.lodThreshold)) {\n    if (this._layer._data.nodePages.lodSelectionMetricType === \"maxScreenThresholdSQ\") {\n      const maxScreenThreshold = Math.sqrt(this._data.lodThreshold / (Math.PI * 0.25));\n      metersPerPixel = span / maxScreenThreshold;\n    } else if (this._layer._data.nodePages.lodSelectionMetricType === \"maxScreenThreshold\") {\n      const maxScreenThreshold = this._data.lodThreshold;\n      metersPerPixel = span / maxScreenThreshold;\n    } else {\n      // Other LOD selection types can only be used for point cloud data\n      console.error(\"Invalid lodSelectionMetricType in Layer\");\n    }\n  } else if (defined(this._data.lodSelection)) {\n    for (let lodIndex = 0; lodIndex < this._data.lodSelection.length; lodIndex++) {\n      if (this._data.lodSelection[lodIndex].metricType === \"maxScreenThreshold\") {\n        metersPerPixel = span / this._data.lodSelection[lodIndex].maxError;\n      }\n    }\n  }\n  if (metersPerPixel === Infinity) {\n    metersPerPixel = 100000;\n  }\n\n  // Calculate the length of 16 pixels in order to trigger the screen space error\n  const geometricError = metersPerPixel * 16;\n\n  // Transformations\n  const hpr = new HeadingPitchRoll(0, 0, 0);\n  let orientation = Transforms.headingPitchRollQuaternion(position, hpr);\n  if (defined(this._data.obb)) {\n    orientation = new Quaternion(this._data.obb.quaternion[0], this._data.obb.quaternion[1], this._data.obb.quaternion[2], this._data.obb.quaternion[3]);\n  }\n  const rotationMatrix = Matrix3.fromQuaternion(orientation);\n  const inverseRotationMatrix = Matrix3.inverse(rotationMatrix, new Matrix3());\n  const globalTransform = new Matrix4(rotationMatrix[0], rotationMatrix[1], rotationMatrix[2], 0, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5], 0, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8], 0, position.x, position.y, position.z, 1);\n  const inverseGlobalTransform = Matrix4.inverse(globalTransform, new Matrix4());\n  const localTransform = Matrix4.clone(globalTransform);\n  if (defined(this._parent._globalTransform)) {\n    Matrix4.multiply(globalTransform, this._parent._inverseGlobalTransform, localTransform);\n  }\n  this._globalTransform = globalTransform;\n  this._inverseGlobalTransform = inverseGlobalTransform;\n  this._inverseRotationMatrix = inverseRotationMatrix;\n\n  // get children definition\n  const childrenDefinition = [];\n  for (let childIndex = 0; childIndex < this._children.length; childIndex++) {\n    childrenDefinition.push(this._children[childIndex]._create3DTileDefinition());\n  }\n\n  // Create a tile set\n  const inPlaceTileDefinition = {\n    children: childrenDefinition,\n    refine: \"REPLACE\",\n    boundingVolume: boundingVolume,\n    transform: [localTransform[0], localTransform[4], localTransform[8], localTransform[12], localTransform[1], localTransform[5], localTransform[9], localTransform[13], localTransform[2], localTransform[6], localTransform[10], localTransform[14], localTransform[3], localTransform[7], localTransform[11], localTransform[15]],\n    content: {\n      uri: defined(this._resource) ? this._resource.url : undefined\n    },\n    geometricError: geometricError\n  };\n  return inPlaceTileDefinition;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadSymbology = async function () {\n  if (!defined(this._symbologyData) && defined(this._layer._symbology)) {\n    this._symbologyData = await this._layer._symbology._getSymbology(this);\n  }\n};\n\n/**\n * @private\n */\nI3SNode.prototype._createContentURL = async function () {\n  let rawGltf = {\n    scene: 0,\n    scenes: [{\n      nodes: [0]\n    }],\n    nodes: [{\n      name: \"singleNode\"\n    }],\n    meshes: [],\n    buffers: [],\n    bufferViews: [],\n    accessors: [],\n    materials: [],\n    textures: [],\n    images: [],\n    samplers: [],\n    asset: {\n      version: \"2.0\"\n    }\n  };\n\n  // Load the geometry data\n  const dataPromises = [this._loadGeometryData()];\n  if (this._dataProvider.legacyVersion16) {\n    dataPromises.push(this._loadFeatureData());\n  }\n  await Promise.all(dataPromises);\n  // Binary glTF\n  if (defined(this._geometryData) && this._geometryData.length > 0) {\n    if (this._dataProvider._applySymbology) {\n      await this._loadSymbology();\n    }\n    const url = this._geometryData[0].resource.url;\n    const geometrySchema = this._layer._data.store.defaultGeometrySchema;\n    const geometryData = this._geometryData[0];\n    const result = await I3SDecoder.decode(url, geometrySchema, geometryData, this._featureData[0], this._symbologyData);\n    if (!defined(result)) {\n      // Postponed\n      return;\n    }\n    rawGltf = geometryData._generateGltf(result.meshData.nodesInScene, result.meshData.nodes, result.meshData.meshes, result.meshData.buffers, result.meshData.bufferViews, result.meshData.accessors, result.meshData.rootExtensions, result.meshData.extensionsUsed);\n    this._geometryData[0]._customAttributes = result.meshData._customAttributes;\n  }\n  const binaryGltfData = this._dataProvider._binarizeGltf(rawGltf);\n  const glbDataBlob = new Blob([binaryGltfData], {\n    type: \"application/binary\"\n  });\n  return URL.createObjectURL(glbDataBlob);\n};\nasync function loadFilters(node) {\n  const filters = node._layer._filters;\n  const promises = [];\n  for (let i = 0; i < filters.length; i++) {\n    const promise = node.loadField(filters[i].name);\n    promises.push(promise);\n  }\n  await Promise.all(promises);\n  return filters;\n}\nfunction checkFeatureValue(featureIndex, field, filter) {\n  if (!defined(filter.values) || filter.values.length === 0) {\n    return false;\n  }\n  const fieldValues = defined(field) ? field.values : [];\n  let featureValue;\n  if (featureIndex < fieldValues.length) {\n    featureValue = fieldValues[featureIndex];\n  }\n  let matches = false;\n  for (let i = 0; i < filter.values.length; i++) {\n    if (filter.values[i] === featureValue) {\n      matches = true;\n      break;\n    }\n  }\n  return matches;\n}\nasync function filterFeatures(node, contentModel) {\n  const batchTable = node._tile.content.batchTable;\n  if (defined(batchTable) && batchTable.featuresLength > 0) {\n    batchTable.setAllShow(true);\n    const filters = await loadFilters(node);\n    if (filters.length > 0) {\n      for (let featureIndex = 0; featureIndex < batchTable.featuresLength; featureIndex++) {\n        for (let filterIndex = 0; filterIndex < filters.length; filterIndex++) {\n          const filter = filters[filterIndex];\n          if (!checkFeatureValue(featureIndex, node._fields[filter.name], filter)) {\n            batchTable.setShow(featureIndex, false);\n            break;\n          }\n        }\n      }\n    }\n  }\n  contentModel.show = true;\n}\n\n/**\n * @private\n */\nI3SNode.prototype._filterFeatures = function () {\n  const promises = [];\n  // Forced filtering is required for loaded nodes only\n  for (let i = 0; i < this._children.length; i++) {\n    const promise = this._children[i]._filterFeatures();\n    promises.push(promise);\n  }\n\n  // Filters are applied for nodes with geometry data only\n  const contentModel = this._tile?.content?._model;\n  if (defined(this._geometryData) && this._geometryData.length > 0 && defined(contentModel) && contentModel.ready) {\n    // The model needs to be hidden till the filters are applied\n    contentModel.show = false;\n    const promise = filterFeatures(this, contentModel);\n    promises.push(promise);\n  }\n  return Promise.all(promises);\n};\n\n// Reimplement Cesium3DTile.prototype.requestContent so that\n// We get a chance to load our own gltf from I3S data\nCesium3DTile.prototype._hookedRequestContent = Cesium3DTile.prototype.requestContent;\n\n/**\n * Requests the tile's content.\n * <p>\n * The request may not be made if the Cesium Request Scheduler can't prioritize it.\n * </p>\n *\n * @return {Promise<Cesium3DTileContent>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nCesium3DTile.prototype.requestContent = function () {\n  if (!this.tileset._isI3STileSet) {\n    return this._hookedRequestContent();\n  }\n  if (!this._isLoading) {\n    this._isLoading = true;\n    const that = this;\n    return this._i3sNode._createContentURL().then(url => {\n      if (!defined(url)) {\n        that._isLoading = false;\n        return;\n      }\n      that._contentResource = new Resource({\n        url: url\n      });\n      return that._hookedRequestContent();\n    }).then(content => {\n      // Filters are applied for nodes with geometry data only\n      const contentModel = content?._model;\n      if (defined(that._i3sNode._geometryData) && that._i3sNode._geometryData.length > 0 && defined(contentModel)) {\n        // The model needs to be hidden till the filters are applied\n        contentModel.show = false;\n        contentModel.readyEvent.addEventListener(() => {\n          filterFeatures(that._i3sNode, contentModel);\n        });\n      }\n      that._isLoading = false;\n      return content;\n    });\n  }\n};\nfunction bilinearInterpolate(tx, ty, h00, h10, h01, h11) {\n  const a = h00 * (1 - tx) + h10 * tx;\n  const b = h01 * (1 - tx) + h11 * tx;\n  return a * (1 - ty) + b * ty;\n}\nfunction sampleMap(u, v, width, data) {\n  const address = u + v * width;\n  return data[address];\n}\nfunction sampleGeoid(sampleX, sampleY, geoidData) {\n  const extent = geoidData.nativeExtent;\n  let x = (sampleX - extent.west) / (extent.east - extent.west) * (geoidData.width - 1);\n  let y = (sampleY - extent.south) / (extent.north - extent.south) * (geoidData.height - 1);\n  const xi = Math.floor(x);\n  let yi = Math.floor(y);\n  x -= xi;\n  y -= yi;\n  const xNext = xi < geoidData.width ? xi + 1 : xi;\n  let yNext = yi < geoidData.height ? yi + 1 : yi;\n  yi = geoidData.height - 1 - yi;\n  yNext = geoidData.height - 1 - yNext;\n  const h00 = sampleMap(xi, yi, geoidData.width, geoidData.buffer);\n  const h10 = sampleMap(xNext, yi, geoidData.width, geoidData.buffer);\n  const h01 = sampleMap(xi, yNext, geoidData.width, geoidData.buffer);\n  const h11 = sampleMap(xNext, yNext, geoidData.width, geoidData.buffer);\n  let finalHeight = bilinearInterpolate(x, y, h00, h10, h01, h11);\n  finalHeight = finalHeight * geoidData.scale + geoidData.offset;\n  return finalHeight;\n}\nObject.defineProperties(Cesium3DTile.prototype, {\n  /**\n   * Gets the I3S Node for the tile.\n   * @memberof Cesium3DTile.prototype\n   * @type {string}\n   */\n  i3sNode: {\n    get: function () {\n      return this._i3sNode;\n    }\n  }\n});\nexport default I3SNode;","map":{"version":3,"names":["Cartographic","Check","defaultValue","defined","Ellipsoid","HeadingPitchRoll","Matrix3","Matrix4","Resource","Quaternion","Transforms","Cesium3DTile","I3SDataProvider","I3SDecoder","I3SFeature","I3SField","I3SGeometry","I3SNode","parent","ref","isRoot","level","layer","nodeIndex","resource","_level","_layer","getDerivedResource","url","_parent","_dataProvider","_isRoot","_nodeIndex","_resource","_isLoading","_tile","undefined","_data","_geometryData","_featureData","_fields","_children","_childrenReadyPromise","_globalTransform","_inverseGlobalTransform","_inverseRotationMatrix","_symbologyData","Object","defineProperties","prototype","get","children","geometryData","featureData","fields","tile","data","load","that","processData","tileDefinition","_create3DTileDefinition","_tileset","_i3sNode","loadJson","node","_getNodeInNodePages","uri","mesh","uriIndex","geometry","createAndLoadField","storageInfo","newField","name","loadFields","attributeStorageInfo","promises","i","length","field","push","Promise","all","loadField","resolve","getFieldsForPickedPosition","pickedPosition","customAttributes","featureIndex","location","getClosestPointIndexOnTriangle","x","y","z","index","getFieldsForFeature","featureFields","fieldName","hasOwnProperty","values","_loadChildren","childPromises","childIndex","child","newChild","href","then","_loadGeometryData","geometryPromises","geomIndex","curGeometryData","geometryDefinition","_findBestGeometryBuffers","definition","geometryURI","bufferIndex","newGeometryData","_geometryDefinitions","_geometryBufferInfo","geometryBufferInfo","_loadFeatureData","featurePromises","newFeatureData","_clearGeometryData","obb","mbs","console","error","geoPosition","fromDegrees","center","_geoidDataList","projectedPos","projection","project","nativeExtent","west","east","south","north","height","sampleGeoid","boundingVolume","position","span","box","halfSize","Math","max","WGS84","cartographicToCartesian","sphere","metersPerPixel","Infinity","lodThreshold","nodePages","lodSelectionMetricType","maxScreenThreshold","sqrt","PI","lodSelection","lodIndex","metricType","maxError","geometricError","hpr","orientation","headingPitchRollQuaternion","quaternion","rotationMatrix","fromQuaternion","inverseRotationMatrix","inverse","globalTransform","inverseGlobalTransform","localTransform","clone","multiply","childrenDefinition","inPlaceTileDefinition","refine","transform","content","_loadSymbology","_symbology","_getSymbology","_createContentURL","rawGltf","scene","scenes","nodes","meshes","buffers","bufferViews","accessors","materials","textures","images","samplers","asset","version","dataPromises","legacyVersion16","_applySymbology","geometrySchema","store","defaultGeometrySchema","result","decode","_generateGltf","meshData","nodesInScene","rootExtensions","extensionsUsed","_customAttributes","binaryGltfData","_binarizeGltf","glbDataBlob","Blob","type","URL","createObjectURL","loadFilters","filters","_filters","promise","checkFeatureValue","filter","fieldValues","featureValue","matches","filterFeatures","contentModel","batchTable","featuresLength","setAllShow","filterIndex","setShow","show","_filterFeatures","_model","ready","_hookedRequestContent","requestContent","tileset","_isI3STileSet","_contentResource","readyEvent","addEventListener","bilinearInterpolate","tx","ty","h00","h10","h01","h11","a","b","sampleMap","u","v","width","address","sampleX","sampleY","geoidData","extent","xi","floor","yi","xNext","yNext","buffer","finalHeight","scale","offset","i3sNode"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/I3SNode.js"],"sourcesContent":["import Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Cesium3DTile from \"./Cesium3DTile.js\";\nimport I3SDataProvider from \"./I3SDataProvider.js\";\nimport I3SDecoder from \"./I3SDecoder.js\";\nimport I3SFeature from \"./I3SFeature.js\";\nimport I3SField from \"./I3SField.js\";\nimport I3SGeometry from \"./I3SGeometry.js\";\n\n/**\n * @typedef {object} I3SNode.AttributeFilter\n *\n * A filter given by an attribute name and values.\n * The 3D feature object should be hidden if its value for the attribute name is not specified in the collection of values.\n *\n * @property {string} name The name of the attribute\n * @property {string[]|number[]} values The collection of values\n */\n\n/**\n * This class implements an I3S Node. In CesiumJS each I3SNode creates a Cesium3DTile.\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SLayer}.\n * </p>\n * @alias I3SNode\n * @internalConstructor\n */\nfunction I3SNode(parent, ref, isRoot) {\n  let level;\n  let layer;\n  let nodeIndex;\n  let resource;\n\n  if (isRoot) {\n    level = 0;\n    layer = parent;\n  } else {\n    level = parent._level + 1;\n    layer = parent._layer;\n  }\n\n  if (typeof ref === \"number\") {\n    nodeIndex = ref;\n  } else {\n    resource = parent.resource.getDerivedResource({\n      url: `${ref}/`,\n    });\n  }\n\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  this._isRoot = isRoot;\n  this._level = level;\n  this._layer = layer;\n  this._nodeIndex = nodeIndex;\n  this._resource = resource;\n  this._isLoading = false;\n\n  this._tile = undefined;\n  this._data = undefined;\n  this._geometryData = [];\n  this._featureData = [];\n  this._fields = {};\n  this._children = [];\n  this._childrenReadyPromise = undefined;\n  this._globalTransform = undefined;\n  this._inverseGlobalTransform = undefined;\n  this._inverseRotationMatrix = undefined;\n  this._symbologyData = undefined;\n}\n\nObject.defineProperties(I3SNode.prototype, {\n  /**\n   * Gets the resource for the node.\n   * @memberof I3SNode.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n  /**\n   * Gets the parent layer.\n   * @memberof I3SNode.prototype\n   * @type {I3SLayer}\n   * @readonly\n   */\n  layer: {\n    get: function () {\n      return this._layer;\n    },\n  },\n  /**\n   * Gets the parent node.\n   * @memberof I3SNode.prototype\n   * @type {I3SNode|undefined}\n   * @readonly\n   */\n  parent: {\n    get: function () {\n      return this._parent;\n    },\n  },\n  /**\n   * Gets the children nodes.\n   * @memberof I3SNode.prototype\n   * @type {I3SNode[]}\n   * @readonly\n   */\n  children: {\n    get: function () {\n      return this._children;\n    },\n  },\n  /**\n   * Gets the collection of geometries.\n   * @memberof I3SNode.prototype\n   * @type {I3SGeometry[]}\n   * @readonly\n   */\n  geometryData: {\n    get: function () {\n      return this._geometryData;\n    },\n  },\n  /**\n   * Gets the collection of features.\n   * @memberof I3SNode.prototype\n   * @type {I3SFeature[]}\n   * @readonly\n   */\n  featureData: {\n    get: function () {\n      return this._featureData;\n    },\n  },\n  /**\n   * Gets the collection of fields.\n   * @memberof I3SNode.prototype\n   * @type {I3SField[]}\n   * @readonly\n   */\n  fields: {\n    get: function () {\n      return this._fields;\n    },\n  },\n  /**\n   * Gets the Cesium3DTile for this node.\n   * @memberof I3SNode.prototype\n   * @type {Cesium3DTile}\n   * @readonly\n   */\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SNode.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n});\n\n/**\n * @private\n */\nI3SNode.prototype.load = async function () {\n  const that = this;\n\n  function processData() {\n    if (!that._isRoot) {\n      // Create a new tile\n      const tileDefinition = that._create3DTileDefinition();\n\n      that._tile = new Cesium3DTile(\n        that._layer._tileset,\n        that._dataProvider.resource,\n        tileDefinition,\n        that._parent._tile,\n      );\n\n      that._tile._i3sNode = that;\n    }\n  }\n\n  // If we don't have a nodepage index load from json\n  if (!defined(this._nodeIndex)) {\n    const data = await I3SDataProvider.loadJson(this._resource);\n    that._data = data;\n    processData();\n    return;\n  }\n\n  const node = await this._layer._getNodeInNodePages(this._nodeIndex);\n  that._data = node;\n  let uri;\n  if (that._isRoot) {\n    uri = \"nodes/root/\";\n  } else if (defined(node.mesh)) {\n    const uriIndex = node.mesh.geometry.resource;\n    uri = `../${uriIndex}/`;\n  }\n  if (defined(uri) && defined(that._parent.resource)) {\n    that._resource = that._parent.resource.getDerivedResource({ url: uri });\n  }\n\n  processData();\n};\n\nfunction createAndLoadField(node, storageInfo) {\n  const newField = new I3SField(node, storageInfo);\n  node._fields[storageInfo.name] = newField;\n  return newField.load();\n}\n\n/**\n * Loads the node fields.\n * @returns {Promise<void>} A promise that is resolved when the I3S Node fields are loaded\n */\nI3SNode.prototype.loadFields = function () {\n  // Check if we must load fields\n  const fields = this._layer._data.attributeStorageInfo;\n\n  const promises = [];\n  if (defined(fields)) {\n    for (let i = 0; i < fields.length; i++) {\n      const storageInfo = fields[i];\n      const field = this._fields[storageInfo.name];\n      if (defined(field)) {\n        promises.push(field.load());\n      } else {\n        promises.push(createAndLoadField(this, storageInfo));\n      }\n    }\n  }\n\n  return Promise.all(promises);\n};\n\n/**\n * Loads the node field.\n * @param {string} name The field name\n * @returns {Promise<void>} A promise that is resolved when the I3S Node field is loaded\n */\nI3SNode.prototype.loadField = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"name\", name);\n  //>>includeEnd('debug');\n\n  const field = this._fields[name];\n  if (defined(field)) {\n    return field.load();\n  }\n\n  const fields = this._layer._data.attributeStorageInfo;\n  if (defined(fields)) {\n    for (let i = 0; i < fields.length; i++) {\n      const storageInfo = fields[i];\n      if (storageInfo.name === name) {\n        return createAndLoadField(this, storageInfo);\n      }\n    }\n  }\n\n  return Promise.resolve();\n};\n\n/**\n * Returns the fields for a given picked position\n * @param {Cartesian3} pickedPosition The picked position\n * @returns {object} Object containing field names and their values\n */\nI3SNode.prototype.getFieldsForPickedPosition = function (pickedPosition) {\n  const geometry = this.geometryData[0];\n  if (!defined(geometry.customAttributes.featureIndex)) {\n    return {};\n  }\n\n  const location = geometry.getClosestPointIndexOnTriangle(\n    pickedPosition.x,\n    pickedPosition.y,\n    pickedPosition.z,\n  );\n\n  if (\n    location.index === -1 ||\n    location.index > geometry.customAttributes.featureIndex.length\n  ) {\n    return {};\n  }\n\n  const featureIndex = geometry.customAttributes.featureIndex[location.index];\n  return this.getFieldsForFeature(featureIndex);\n};\n\n/**\n * Returns the fields for a given feature\n * @param {number} featureIndex Index of the feature whose attributes we want to get\n * @returns {object} Object containing field names and their values\n */\nI3SNode.prototype.getFieldsForFeature = function (featureIndex) {\n  const featureFields = {};\n  for (const fieldName in this.fields) {\n    if (this.fields.hasOwnProperty(fieldName)) {\n      const field = this.fields[fieldName];\n      if (featureIndex >= 0 && featureIndex < field.values.length) {\n        featureFields[field.name] = field.values[featureIndex];\n      }\n    }\n  }\n  return featureFields;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadChildren = function () {\n  const that = this;\n  // If the promise for loading the children was already created, just return it\n  if (defined(this._childrenReadyPromise)) {\n    return this._childrenReadyPromise;\n  }\n\n  const childPromises = [];\n  if (defined(that._data.children)) {\n    for (\n      let childIndex = 0;\n      childIndex < that._data.children.length;\n      childIndex++\n    ) {\n      const child = that._data.children[childIndex];\n      const newChild = new I3SNode(\n        that,\n        defaultValue(child.href, child),\n        false,\n      );\n      that._children.push(newChild);\n      childPromises.push(newChild.load());\n    }\n  }\n\n  this._childrenReadyPromise = Promise.all(childPromises).then(function () {\n    for (let i = 0; i < that._children.length; i++) {\n      that._tile.children.push(that._children[i]._tile);\n    }\n  });\n\n  return this._childrenReadyPromise;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadGeometryData = function () {\n  const geometryPromises = [];\n\n  // To debug decoding for a specific tile, add a condition\n  // that wraps this if/else to match the tile uri\n  if (defined(this._data.geometryData)) {\n    for (\n      let geomIndex = 0;\n      geomIndex < this._data.geometryData.length;\n      geomIndex++\n    ) {\n      const curGeometryData = new I3SGeometry(\n        this,\n        this._data.geometryData[geomIndex].href,\n      );\n      this._geometryData.push(curGeometryData);\n      geometryPromises.push(curGeometryData.load());\n    }\n  } else if (defined(this._data.mesh)) {\n    const geometryDefinition = this._layer._findBestGeometryBuffers(\n      this._data.mesh.geometry.definition,\n      [\"position\", \"uv0\"],\n    );\n\n    const geometryURI = `./geometries/${geometryDefinition.bufferIndex}/`;\n    const newGeometryData = new I3SGeometry(this, geometryURI);\n    newGeometryData._geometryDefinitions = geometryDefinition.definition;\n    newGeometryData._geometryBufferInfo = geometryDefinition.geometryBufferInfo;\n    this._geometryData.push(newGeometryData);\n    geometryPromises.push(newGeometryData.load());\n  }\n\n  return Promise.all(geometryPromises);\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadFeatureData = function () {\n  const featurePromises = [];\n\n  // To debug decoding for a specific tile, add a condition\n  // that wraps this if/else to match the tile uri\n  if (defined(this._data.featureData)) {\n    for (\n      let featureIndex = 0;\n      featureIndex < this._data.featureData.length;\n      featureIndex++\n    ) {\n      const newFeatureData = new I3SFeature(\n        this,\n        this._data.featureData[featureIndex].href,\n      );\n      this._featureData.push(newFeatureData);\n      featurePromises.push(newFeatureData.load());\n    }\n  }\n\n  return Promise.all(featurePromises);\n};\n\n/**\n * @private\n */\nI3SNode.prototype._clearGeometryData = function () {\n  this._geometryData = [];\n};\n\n/**\n * @private\n */\nI3SNode.prototype._create3DTileDefinition = function () {\n  const obb = this._data.obb;\n  const mbs = this._data.mbs;\n\n  if (!defined(obb) && !defined(mbs)) {\n    console.error(\"Failed to load I3S node. Bounding volume is required.\");\n    return undefined;\n  }\n\n  let geoPosition;\n\n  if (defined(obb)) {\n    geoPosition = Cartographic.fromDegrees(\n      obb.center[0],\n      obb.center[1],\n      obb.center[2],\n    );\n  } else {\n    geoPosition = Cartographic.fromDegrees(mbs[0], mbs[1], mbs[2]);\n  }\n\n  // Offset bounding box position if we have a geoid service defined\n  if (defined(this._dataProvider._geoidDataList) && defined(geoPosition)) {\n    for (let i = 0; i < this._dataProvider._geoidDataList.length; i++) {\n      const tile = this._dataProvider._geoidDataList[i];\n      const projectedPos = tile.projection.project(geoPosition);\n      if (\n        projectedPos.x > tile.nativeExtent.west &&\n        projectedPos.x < tile.nativeExtent.east &&\n        projectedPos.y > tile.nativeExtent.south &&\n        projectedPos.y < tile.nativeExtent.north\n      ) {\n        geoPosition.height += sampleGeoid(projectedPos.x, projectedPos.y, tile);\n        break;\n      }\n    }\n  }\n\n  let boundingVolume = {};\n  let position;\n  let span = 0;\n  if (defined(obb)) {\n    boundingVolume = {\n      box: [\n        0,\n        0,\n        0,\n        obb.halfSize[0],\n        0,\n        0,\n        0,\n        obb.halfSize[1],\n        0,\n        0,\n        0,\n        obb.halfSize[2],\n      ],\n    };\n    span = Math.max(\n      Math.max(this._data.obb.halfSize[0], this._data.obb.halfSize[1]),\n      this._data.obb.halfSize[2],\n    );\n    position = Ellipsoid.WGS84.cartographicToCartesian(geoPosition);\n  } else {\n    boundingVolume = {\n      sphere: [0, 0, 0, mbs[3]],\n    };\n    position = Ellipsoid.WGS84.cartographicToCartesian(geoPosition);\n    span = this._data.mbs[3];\n  }\n  span *= 2;\n  // Compute the geometric error\n  let metersPerPixel = Infinity;\n\n  // Get the meters/pixel density required to pop the next LOD\n  if (defined(this._data.lodThreshold)) {\n    if (\n      this._layer._data.nodePages.lodSelectionMetricType ===\n      \"maxScreenThresholdSQ\"\n    ) {\n      const maxScreenThreshold = Math.sqrt(\n        this._data.lodThreshold / (Math.PI * 0.25),\n      );\n      metersPerPixel = span / maxScreenThreshold;\n    } else if (\n      this._layer._data.nodePages.lodSelectionMetricType ===\n      \"maxScreenThreshold\"\n    ) {\n      const maxScreenThreshold = this._data.lodThreshold;\n      metersPerPixel = span / maxScreenThreshold;\n    } else {\n      // Other LOD selection types can only be used for point cloud data\n      console.error(\"Invalid lodSelectionMetricType in Layer\");\n    }\n  } else if (defined(this._data.lodSelection)) {\n    for (\n      let lodIndex = 0;\n      lodIndex < this._data.lodSelection.length;\n      lodIndex++\n    ) {\n      if (\n        this._data.lodSelection[lodIndex].metricType === \"maxScreenThreshold\"\n      ) {\n        metersPerPixel = span / this._data.lodSelection[lodIndex].maxError;\n      }\n    }\n  }\n\n  if (metersPerPixel === Infinity) {\n    metersPerPixel = 100000;\n  }\n\n  // Calculate the length of 16 pixels in order to trigger the screen space error\n  const geometricError = metersPerPixel * 16;\n\n  // Transformations\n  const hpr = new HeadingPitchRoll(0, 0, 0);\n  let orientation = Transforms.headingPitchRollQuaternion(position, hpr);\n\n  if (defined(this._data.obb)) {\n    orientation = new Quaternion(\n      this._data.obb.quaternion[0],\n      this._data.obb.quaternion[1],\n      this._data.obb.quaternion[2],\n      this._data.obb.quaternion[3],\n    );\n  }\n\n  const rotationMatrix = Matrix3.fromQuaternion(orientation);\n  const inverseRotationMatrix = Matrix3.inverse(rotationMatrix, new Matrix3());\n\n  const globalTransform = new Matrix4(\n    rotationMatrix[0],\n    rotationMatrix[1],\n    rotationMatrix[2],\n    0,\n    rotationMatrix[3],\n    rotationMatrix[4],\n    rotationMatrix[5],\n    0,\n    rotationMatrix[6],\n    rotationMatrix[7],\n    rotationMatrix[8],\n    0,\n    position.x,\n    position.y,\n    position.z,\n    1,\n  );\n\n  const inverseGlobalTransform = Matrix4.inverse(\n    globalTransform,\n    new Matrix4(),\n  );\n\n  const localTransform = Matrix4.clone(globalTransform);\n\n  if (defined(this._parent._globalTransform)) {\n    Matrix4.multiply(\n      globalTransform,\n      this._parent._inverseGlobalTransform,\n      localTransform,\n    );\n  }\n\n  this._globalTransform = globalTransform;\n  this._inverseGlobalTransform = inverseGlobalTransform;\n  this._inverseRotationMatrix = inverseRotationMatrix;\n\n  // get children definition\n  const childrenDefinition = [];\n  for (let childIndex = 0; childIndex < this._children.length; childIndex++) {\n    childrenDefinition.push(\n      this._children[childIndex]._create3DTileDefinition(),\n    );\n  }\n\n  // Create a tile set\n  const inPlaceTileDefinition = {\n    children: childrenDefinition,\n    refine: \"REPLACE\",\n    boundingVolume: boundingVolume,\n    transform: [\n      localTransform[0],\n      localTransform[4],\n      localTransform[8],\n      localTransform[12],\n      localTransform[1],\n      localTransform[5],\n      localTransform[9],\n      localTransform[13],\n      localTransform[2],\n      localTransform[6],\n      localTransform[10],\n      localTransform[14],\n      localTransform[3],\n      localTransform[7],\n      localTransform[11],\n      localTransform[15],\n    ],\n    content: {\n      uri: defined(this._resource) ? this._resource.url : undefined,\n    },\n    geometricError: geometricError,\n  };\n\n  return inPlaceTileDefinition;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadSymbology = async function () {\n  if (!defined(this._symbologyData) && defined(this._layer._symbology)) {\n    this._symbologyData = await this._layer._symbology._getSymbology(this);\n  }\n};\n\n/**\n * @private\n */\nI3SNode.prototype._createContentURL = async function () {\n  let rawGltf = {\n    scene: 0,\n    scenes: [\n      {\n        nodes: [0],\n      },\n    ],\n    nodes: [\n      {\n        name: \"singleNode\",\n      },\n    ],\n    meshes: [],\n    buffers: [],\n    bufferViews: [],\n    accessors: [],\n    materials: [],\n    textures: [],\n    images: [],\n    samplers: [],\n    asset: {\n      version: \"2.0\",\n    },\n  };\n\n  // Load the geometry data\n  const dataPromises = [this._loadGeometryData()];\n  if (this._dataProvider.legacyVersion16) {\n    dataPromises.push(this._loadFeatureData());\n  }\n\n  await Promise.all(dataPromises);\n  // Binary glTF\n  if (defined(this._geometryData) && this._geometryData.length > 0) {\n    if (this._dataProvider._applySymbology) {\n      await this._loadSymbology();\n    }\n\n    const url = this._geometryData[0].resource.url;\n    const geometrySchema = this._layer._data.store.defaultGeometrySchema;\n    const geometryData = this._geometryData[0];\n    const result = await I3SDecoder.decode(\n      url,\n      geometrySchema,\n      geometryData,\n      this._featureData[0],\n      this._symbologyData,\n    );\n    if (!defined(result)) {\n      // Postponed\n      return;\n    }\n\n    rawGltf = geometryData._generateGltf(\n      result.meshData.nodesInScene,\n      result.meshData.nodes,\n      result.meshData.meshes,\n      result.meshData.buffers,\n      result.meshData.bufferViews,\n      result.meshData.accessors,\n      result.meshData.rootExtensions,\n      result.meshData.extensionsUsed,\n    );\n\n    this._geometryData[0]._customAttributes = result.meshData._customAttributes;\n  }\n\n  const binaryGltfData = this._dataProvider._binarizeGltf(rawGltf);\n  const glbDataBlob = new Blob([binaryGltfData], {\n    type: \"application/binary\",\n  });\n  return URL.createObjectURL(glbDataBlob);\n};\n\nasync function loadFilters(node) {\n  const filters = node._layer._filters;\n  const promises = [];\n  for (let i = 0; i < filters.length; i++) {\n    const promise = node.loadField(filters[i].name);\n    promises.push(promise);\n  }\n  await Promise.all(promises);\n  return filters;\n}\n\nfunction checkFeatureValue(featureIndex, field, filter) {\n  if (!defined(filter.values) || filter.values.length === 0) {\n    return false;\n  }\n\n  const fieldValues = defined(field) ? field.values : [];\n  let featureValue;\n  if (featureIndex < fieldValues.length) {\n    featureValue = fieldValues[featureIndex];\n  }\n  let matches = false;\n  for (let i = 0; i < filter.values.length; i++) {\n    if (filter.values[i] === featureValue) {\n      matches = true;\n      break;\n    }\n  }\n  return matches;\n}\n\nasync function filterFeatures(node, contentModel) {\n  const batchTable = node._tile.content.batchTable;\n  if (defined(batchTable) && batchTable.featuresLength > 0) {\n    batchTable.setAllShow(true);\n\n    const filters = await loadFilters(node);\n    if (filters.length > 0) {\n      for (\n        let featureIndex = 0;\n        featureIndex < batchTable.featuresLength;\n        featureIndex++\n      ) {\n        for (let filterIndex = 0; filterIndex < filters.length; filterIndex++) {\n          const filter = filters[filterIndex];\n          if (\n            !checkFeatureValue(featureIndex, node._fields[filter.name], filter)\n          ) {\n            batchTable.setShow(featureIndex, false);\n            break;\n          }\n        }\n      }\n    }\n  }\n  contentModel.show = true;\n}\n\n/**\n * @private\n */\nI3SNode.prototype._filterFeatures = function () {\n  const promises = [];\n  // Forced filtering is required for loaded nodes only\n  for (let i = 0; i < this._children.length; i++) {\n    const promise = this._children[i]._filterFeatures();\n    promises.push(promise);\n  }\n\n  // Filters are applied for nodes with geometry data only\n  const contentModel = this._tile?.content?._model;\n  if (\n    defined(this._geometryData) &&\n    this._geometryData.length > 0 &&\n    defined(contentModel) &&\n    contentModel.ready\n  ) {\n    // The model needs to be hidden till the filters are applied\n    contentModel.show = false;\n    const promise = filterFeatures(this, contentModel);\n    promises.push(promise);\n  }\n  return Promise.all(promises);\n};\n\n// Reimplement Cesium3DTile.prototype.requestContent so that\n// We get a chance to load our own gltf from I3S data\nCesium3DTile.prototype._hookedRequestContent =\n  Cesium3DTile.prototype.requestContent;\n\n/**\n * Requests the tile's content.\n * <p>\n * The request may not be made if the Cesium Request Scheduler can't prioritize it.\n * </p>\n *\n * @return {Promise<Cesium3DTileContent>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nCesium3DTile.prototype.requestContent = function () {\n  if (!this.tileset._isI3STileSet) {\n    return this._hookedRequestContent();\n  }\n\n  if (!this._isLoading) {\n    this._isLoading = true;\n    const that = this;\n    return this._i3sNode\n      ._createContentURL()\n      .then((url) => {\n        if (!defined(url)) {\n          that._isLoading = false;\n          return;\n        }\n\n        that._contentResource = new Resource({ url: url });\n        return that._hookedRequestContent();\n      })\n      .then((content) => {\n        // Filters are applied for nodes with geometry data only\n        const contentModel = content?._model;\n        if (\n          defined(that._i3sNode._geometryData) &&\n          that._i3sNode._geometryData.length > 0 &&\n          defined(contentModel)\n        ) {\n          // The model needs to be hidden till the filters are applied\n          contentModel.show = false;\n          contentModel.readyEvent.addEventListener(() => {\n            filterFeatures(that._i3sNode, contentModel);\n          });\n        }\n        that._isLoading = false;\n        return content;\n      });\n  }\n};\n\nfunction bilinearInterpolate(tx, ty, h00, h10, h01, h11) {\n  const a = h00 * (1 - tx) + h10 * tx;\n  const b = h01 * (1 - tx) + h11 * tx;\n  return a * (1 - ty) + b * ty;\n}\n\nfunction sampleMap(u, v, width, data) {\n  const address = u + v * width;\n  return data[address];\n}\n\nfunction sampleGeoid(sampleX, sampleY, geoidData) {\n  const extent = geoidData.nativeExtent;\n  let x =\n    ((sampleX - extent.west) / (extent.east - extent.west)) *\n    (geoidData.width - 1);\n  let y =\n    ((sampleY - extent.south) / (extent.north - extent.south)) *\n    (geoidData.height - 1);\n  const xi = Math.floor(x);\n  let yi = Math.floor(y);\n\n  x -= xi;\n  y -= yi;\n\n  const xNext = xi < geoidData.width ? xi + 1 : xi;\n  let yNext = yi < geoidData.height ? yi + 1 : yi;\n\n  yi = geoidData.height - 1 - yi;\n  yNext = geoidData.height - 1 - yNext;\n\n  const h00 = sampleMap(xi, yi, geoidData.width, geoidData.buffer);\n  const h10 = sampleMap(xNext, yi, geoidData.width, geoidData.buffer);\n  const h01 = sampleMap(xi, yNext, geoidData.width, geoidData.buffer);\n  const h11 = sampleMap(xNext, yNext, geoidData.width, geoidData.buffer);\n\n  let finalHeight = bilinearInterpolate(x, y, h00, h10, h01, h11);\n  finalHeight = finalHeight * geoidData.scale + geoidData.offset;\n  return finalHeight;\n}\n\nObject.defineProperties(Cesium3DTile.prototype, {\n  /**\n   * Gets the I3S Node for the tile.\n   * @memberof Cesium3DTile.prototype\n   * @type {string}\n   */\n  i3sNode: {\n    get: function () {\n      return this._i3sNode;\n    },\n  },\n});\n\nexport default I3SNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}