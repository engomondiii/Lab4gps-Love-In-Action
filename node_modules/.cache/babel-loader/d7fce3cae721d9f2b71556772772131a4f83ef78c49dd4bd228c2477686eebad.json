{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport AdjustTranslucentFS from \"../Shaders/AdjustTranslucentFS.js\";\nimport CompositeOITFS from \"../Shaders/CompositeOITFS.js\";\nimport BlendEquation from \"./BlendEquation.js\";\nimport BlendFunction from \"./BlendFunction.js\";\n\n/**\n * @private\n * @constructor\n * @param {Context} context\n */\nfunction OIT(context) {\n  this._numSamples = 1;\n  // We support multipass for the Chrome D3D9 backend and ES 2.0 on mobile.\n  this._translucentMultipassSupport = false;\n  this._translucentMRTSupport = false;\n  const extensionsSupported = context.colorBufferFloat && context.depthTexture && context.floatBlend;\n  this._translucentMRTSupport = context.drawBuffers && extensionsSupported;\n  this._translucentMultipassSupport = !this._translucentMRTSupport && extensionsSupported;\n  this._opaqueFBO = undefined;\n  this._opaqueTexture = undefined;\n  this._depthStencilTexture = undefined;\n  this._accumulationTexture = undefined;\n  this._translucentFBO = new FramebufferManager({\n    colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1,\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depth: true\n  });\n  this._alphaFBO = new FramebufferManager({\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depth: true\n  });\n  this._adjustTranslucentFBO = new FramebufferManager({\n    colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1,\n    createColorAttachments: false\n  });\n  this._adjustAlphaFBO = new FramebufferManager({\n    createColorAttachments: false\n  });\n  this._opaqueClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this\n  });\n  this._translucentMRTClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 1.0),\n    owner: this\n  });\n  this._translucentMultipassClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this\n  });\n  this._alphaClearCommand = new ClearCommand({\n    color: new Color(1.0, 1.0, 1.0, 1.0),\n    owner: this\n  });\n  this._translucentRenderStateCache = {};\n  this._alphaRenderStateCache = {};\n  this._compositeCommand = undefined;\n  this._adjustTranslucentCommand = undefined;\n  this._adjustAlphaCommand = undefined;\n  this._viewport = new BoundingRectangle();\n  this._rs = undefined;\n  this._useScissorTest = false;\n  this._scissorRectangle = undefined;\n  this._useHDR = false;\n}\n\n/**\n * @private\n * @param {OIT} oit\n */\nfunction destroyTextures(oit) {\n  oit._accumulationTexture = oit._accumulationTexture && !oit._accumulationTexture.isDestroyed() && oit._accumulationTexture.destroy();\n  oit._revealageTexture = oit._revealageTexture && !oit._revealageTexture.isDestroyed() && oit._revealageTexture.destroy();\n}\n\n/**\n * @private\n * @param {OIT} oit\n */\nfunction destroyFramebuffers(oit) {\n  oit._translucentFBO.destroy();\n  oit._alphaFBO.destroy();\n  oit._adjustTranslucentFBO.destroy();\n  oit._adjustAlphaFBO.destroy();\n}\n\n/**\n * @private\n * @param {OIT} oit\n */\nfunction destroyResources(oit) {\n  destroyTextures(oit);\n  destroyFramebuffers(oit);\n}\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Context} context\n * @param {number} width\n * @param {number} height\n */\nfunction updateTextures(oit, context, width, height) {\n  destroyTextures(oit);\n  oit._accumulationTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.FLOAT\n  });\n  oit._revealageTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.FLOAT,\n    width: width,\n    height: height,\n    flipY: false\n  });\n}\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Context} context\n * @returns {boolean}\n */\nfunction updateFramebuffers(oit, context) {\n  destroyFramebuffers(oit);\n  const completeFBO = WebGLConstants.FRAMEBUFFER_COMPLETE;\n  let supported = true;\n  const {\n    width,\n    height\n  } = oit._accumulationTexture;\n\n  // if MRT is supported, attempt to make an FBO with multiple color attachments\n  if (oit._translucentMRTSupport) {\n    oit._translucentFBO.setColorTexture(oit._accumulationTexture, 0);\n    oit._translucentFBO.setColorTexture(oit._revealageTexture, 1);\n    oit._translucentFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._translucentFBO.update(context, width, height);\n    oit._adjustTranslucentFBO.setColorTexture(oit._accumulationTexture, 0);\n    oit._adjustTranslucentFBO.setColorTexture(oit._revealageTexture, 1);\n    oit._adjustTranslucentFBO.update(context, width, height);\n    if (oit._translucentFBO.status !== completeFBO || oit._adjustTranslucentFBO.status !== completeFBO) {\n      destroyFramebuffers(oit);\n      oit._translucentMRTSupport = false;\n    }\n  }\n\n  // either MRT isn't supported or FBO creation failed, attempt multipass\n  if (!oit._translucentMRTSupport) {\n    oit._translucentFBO.setColorTexture(oit._accumulationTexture);\n    oit._translucentFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._translucentFBO.update(context, width, height);\n    oit._alphaFBO.setColorTexture(oit._revealageTexture);\n    oit._alphaFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._alphaFBO.update(context, width, height);\n    oit._adjustTranslucentFBO.setColorTexture(oit._accumulationTexture);\n    oit._adjustTranslucentFBO.update(context, width, height);\n    oit._adjustAlphaFBO.setColorTexture(oit._revealageTexture);\n    oit._adjustAlphaFBO.update(context, width, height);\n    const translucentComplete = oit._translucentFBO.status === completeFBO;\n    const alphaComplete = oit._alphaFBO.status === completeFBO;\n    const adjustTranslucentComplete = oit._adjustTranslucentFBO.status === completeFBO;\n    const adjustAlphaComplete = oit._adjustAlphaFBO.status === completeFBO;\n    if (!translucentComplete || !alphaComplete || !adjustTranslucentComplete || !adjustAlphaComplete) {\n      destroyResources(oit);\n      oit._translucentMultipassSupport = false;\n      supported = false;\n    }\n  }\n  return supported;\n}\n\n/**\n * @private\n * @param {Context} context\n * @param {PassState} passState\n * @param {Framebuffer} framebuffer\n * @param {boolean} useHDR\n * @param {number} numSamples\n */\nOIT.prototype.update = function (context, passState, framebuffer, useHDR, numSamples) {\n  if (!this.isSupported()) {\n    return;\n  }\n  this._opaqueFBO = framebuffer;\n  this._opaqueTexture = framebuffer.getColorTexture(0);\n  this._depthStencilTexture = framebuffer.getDepthStencilTexture();\n  const {\n    width,\n    height\n  } = this._opaqueTexture;\n  const accumulationTexture = this._accumulationTexture;\n  const textureChanged = !defined(accumulationTexture) || accumulationTexture.width !== width || accumulationTexture.height !== height || useHDR !== this._useHDR;\n  const samplesChanged = this._numSamples !== numSamples;\n  if (textureChanged || samplesChanged) {\n    this._numSamples = numSamples;\n    updateTextures(this, context, width, height);\n  }\n  if (!defined(this._translucentFBO.framebuffer) || textureChanged || samplesChanged) {\n    if (!updateFramebuffers(this, context)) {\n      // framebuffer creation failed\n      return;\n    }\n  }\n  this._useHDR = useHDR;\n  const that = this;\n  let fs;\n  let uniformMap;\n  if (!defined(this._compositeCommand)) {\n    fs = new ShaderSource({\n      sources: [CompositeOITFS]\n    });\n    if (this._translucentMRTSupport) {\n      fs.defines.push(\"MRT\");\n    }\n    uniformMap = {\n      u_opaque: function () {\n        return that._opaqueTexture;\n      },\n      u_accumulation: function () {\n        return that._accumulationTexture;\n      },\n      u_revealage: function () {\n        return that._revealageTexture;\n      }\n    };\n    this._compositeCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: this\n    });\n  }\n  if (!defined(this._adjustTranslucentCommand)) {\n    if (this._translucentMRTSupport) {\n      fs = new ShaderSource({\n        defines: [\"MRT\"],\n        sources: [AdjustTranslucentFS]\n      });\n      uniformMap = {\n        u_bgColor: function () {\n          return that._translucentMRTClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        }\n      };\n      this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this\n      });\n    } else if (this._translucentMultipassSupport) {\n      fs = new ShaderSource({\n        sources: [AdjustTranslucentFS]\n      });\n      uniformMap = {\n        u_bgColor: function () {\n          return that._translucentMultipassClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        }\n      };\n      this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this\n      });\n      uniformMap = {\n        u_bgColor: function () {\n          return that._alphaClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        }\n      };\n      this._adjustAlphaCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this\n      });\n    }\n  }\n  this._viewport.width = width;\n  this._viewport.height = height;\n  const useScissorTest = !BoundingRectangle.equals(this._viewport, passState.viewport);\n  let updateScissor = useScissorTest !== this._useScissorTest;\n  this._useScissorTest = useScissorTest;\n  if (!BoundingRectangle.equals(this._scissorRectangle, passState.viewport)) {\n    this._scissorRectangle = BoundingRectangle.clone(passState.viewport, this._scissorRectangle);\n    updateScissor = true;\n  }\n  if (!defined(this._rs) || !BoundingRectangle.equals(this._viewport, this._rs.viewport) || updateScissor) {\n    this._rs = RenderState.fromCache({\n      viewport: this._viewport,\n      scissorTest: {\n        enabled: this._useScissorTest,\n        rectangle: this._scissorRectangle\n      }\n    });\n  }\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.renderState = this._rs;\n  }\n  if (this._adjustTranslucentCommand) {\n    this._adjustTranslucentCommand.renderState = this._rs;\n  }\n  if (defined(this._adjustAlphaCommand)) {\n    this._adjustAlphaCommand.renderState = this._rs;\n  }\n};\nconst translucentMRTBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ONE,\n  functionDestinationRgb: BlendFunction.ONE,\n  functionSourceAlpha: BlendFunction.ZERO,\n  functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA\n};\nconst translucentColorBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ONE,\n  functionDestinationRgb: BlendFunction.ONE,\n  functionSourceAlpha: BlendFunction.ONE,\n  functionDestinationAlpha: BlendFunction.ONE\n};\nconst translucentAlphaBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ZERO,\n  functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n  functionSourceAlpha: BlendFunction.ZERO,\n  functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA\n};\nfunction getTranslucentRenderState(context, translucentBlending, cache, renderState) {\n  let translucentState = cache[renderState.id];\n  if (!defined(translucentState)) {\n    const rs = RenderState.getState(renderState);\n    rs.depthMask = false;\n    rs.blending = translucentBlending;\n    translucentState = RenderState.fromCache(rs);\n    cache[renderState.id] = translucentState;\n  }\n  return translucentState;\n}\nfunction getTranslucentMRTRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(context, translucentMRTBlend, oit._translucentRenderStateCache, renderState);\n}\nfunction getTranslucentColorRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(context, translucentColorBlend, oit._translucentRenderStateCache, renderState);\n}\nfunction getTranslucentAlphaRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(context, translucentAlphaBlend, oit._alphaRenderStateCache, renderState);\n}\nconst mrtShaderSource = \"    vec3 Ci = czm_out_FragColor.rgb * czm_out_FragColor.a;\\n\" + \"    float ai = czm_out_FragColor.a;\\n\" + \"    float wzi = czm_alphaWeight(ai);\\n\" + \"    out_FragData_0 = vec4(Ci * wzi, ai);\\n\" + \"    out_FragData_1 = vec4(ai * wzi);\\n\";\nconst colorShaderSource = \"    vec3 Ci = czm_out_FragColor.rgb * czm_out_FragColor.a;\\n\" + \"    float ai = czm_out_FragColor.a;\\n\" + \"    float wzi = czm_alphaWeight(ai);\\n\" + \"    out_FragColor = vec4(Ci, ai) * wzi;\\n\";\nconst alphaShaderSource = \"    float ai = czm_out_FragColor.a;\\n\" + \"    out_FragColor = vec4(ai);\\n\";\n\n/**\n * @private\n * @param {Context} context\n * @param {ShaderProgram} shaderProgram\n * @param {string} keyword\n * @param {string} source\n * @returns {ShaderProgram}\n */\nfunction getTranslucentShaderProgram(context, shaderProgram, keyword, source) {\n  const {\n    shaderCache\n  } = context;\n  const shader = shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n  if (defined(shader)) {\n    return shader;\n  }\n  const attributeLocations = shaderProgram._attributeLocations;\n  const fs = shaderProgram.fragmentShaderSource.clone();\n  fs.sources = fs.sources.map(function (fsSource) {\n    return ShaderSource.replaceMain(fsSource, \"czm_translucent_main\").replace(/out_FragColor/g, \"czm_out_FragColor\").replace(/layout\\s*\\(location\\s*=\\s*0\\)\\s*out\\s+vec4\\s+out_FragColor;/g, \"\").replace(/\\bdiscard\\b/g, \"czm_discard = true\").replace(/czm_phong/g, \"czm_translucentPhong\");\n  });\n\n  // Discarding the fragment in main is a workaround for ANGLE D3D9\n  // shader compilation errors.\n  fs.sources.splice(0, 0, `vec4 czm_out_FragColor;\\n` + `bool czm_discard = false;\\n`);\n  const fragDataMatches = [...source.matchAll(/out_FragData_(\\d+)/g)];\n  let fragDataDeclarations = ``;\n  for (let i = 0; i < fragDataMatches.length; i++) {\n    const fragDataMatch = fragDataMatches[i];\n    fragDataDeclarations = `layout (location = ${fragDataMatch[1]}) out vec4 ${fragDataMatch[0]};\\n${fragDataDeclarations}`;\n  }\n  fs.sources.push(fragDataDeclarations);\n  fs.sources.push(`${\"void main()\\n\" + \"{\\n\" + \"    czm_translucent_main();\\n\" + \"    if (czm_discard)\\n\" + \"    {\\n\" + \"        discard;\\n\" + \"    }\\n\"}${source}}\\n`);\n  return shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n    vertexShaderSource: shaderProgram.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\nfunction getTranslucentMRTShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(context, shaderProgram, \"translucentMRT\", mrtShaderSource);\n}\nfunction getTranslucentColorShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(context, shaderProgram, \"translucentMultipass\", colorShaderSource);\n}\nfunction getTranslucentAlphaShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(context, shaderProgram, \"alphaMultipass\", alphaShaderSource);\n}\n\n/**\n * @private\n * @param {DrawCommand} command\n * @param {Context} context\n * @param {*} result\n * @returns {*}\n */\nOIT.prototype.createDerivedCommands = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n  if (this._translucentMRTSupport) {\n    let translucentShader;\n    let translucentRenderState;\n    if (defined(result.translucentCommand)) {\n      translucentShader = result.translucentCommand.shaderProgram;\n      translucentRenderState = result.translucentCommand.renderState;\n    }\n    result.translucentCommand = DrawCommand.shallowClone(command, result.translucentCommand);\n    if (!defined(translucentShader) || result.shaderProgramId !== command.shaderProgram.id) {\n      result.translucentCommand.shaderProgram = getTranslucentMRTShaderProgram(context, command.shaderProgram);\n      result.translucentCommand.renderState = getTranslucentMRTRenderState(this, context, command.renderState);\n      result.shaderProgramId = command.shaderProgram.id;\n    } else {\n      result.translucentCommand.shaderProgram = translucentShader;\n      result.translucentCommand.renderState = translucentRenderState;\n    }\n    return result;\n  }\n  let colorShader;\n  let colorRenderState;\n  let alphaShader;\n  let alphaRenderState;\n  if (defined(result.translucentCommand)) {\n    colorShader = result.translucentCommand.shaderProgram;\n    colorRenderState = result.translucentCommand.renderState;\n    alphaShader = result.alphaCommand.shaderProgram;\n    alphaRenderState = result.alphaCommand.renderState;\n  }\n  result.translucentCommand = DrawCommand.shallowClone(command, result.translucentCommand);\n  result.alphaCommand = DrawCommand.shallowClone(command, result.alphaCommand);\n  if (!defined(colorShader) || result.shaderProgramId !== command.shaderProgram.id) {\n    result.translucentCommand.shaderProgram = getTranslucentColorShaderProgram(context, command.shaderProgram);\n    result.translucentCommand.renderState = getTranslucentColorRenderState(this, context, command.renderState);\n    result.alphaCommand.shaderProgram = getTranslucentAlphaShaderProgram(context, command.shaderProgram);\n    result.alphaCommand.renderState = getTranslucentAlphaRenderState(this, context, command.renderState);\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.translucentCommand.shaderProgram = colorShader;\n    result.translucentCommand.renderState = colorRenderState;\n    result.alphaCommand.shaderProgram = alphaShader;\n    result.alphaCommand.renderState = alphaRenderState;\n  }\n  return result;\n};\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Scene} scene\n * @param {Function} executeFunction\n * @param {PassState} passState\n * @param {DrawCommand[]} commands\n * @param {InvertClassification} invertClassification\n */\nfunction executeTranslucentCommandsSortedMultipass(oit, scene, executeFunction, passState, commands, invertClassification) {\n  const {\n    context,\n    frameState\n  } = scene;\n  const {\n    useLogDepth,\n    shadowState\n  } = frameState;\n  const useHdr = scene._hdr;\n  const framebuffer = passState.framebuffer;\n  const lightShadowsEnabled = shadowState.lightShadowsEnabled;\n  passState.framebuffer = oit._adjustTranslucentFBO.framebuffer;\n  oit._adjustTranslucentCommand.execute(context, passState);\n  passState.framebuffer = oit._adjustAlphaFBO.framebuffer;\n  oit._adjustAlphaCommand.execute(context, passState);\n  const debugFramebuffer = oit._opaqueFBO.framebuffer;\n  passState.framebuffer = oit._translucentFBO.framebuffer;\n  for (let j = 0; j < commands.length; ++j) {\n    let command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    const derivedCommand = lightShadowsEnabled && command.receiveShadows ? command.derivedCommands.oit.shadows.translucentCommand : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n  if (defined(invertClassification)) {\n    const command = invertClassification.unclassifiedCommand;\n    const derivedCommand = lightShadowsEnabled && command.receiveShadows ? command.derivedCommands.oit.shadows.translucentCommand : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n  passState.framebuffer = oit._alphaFBO.framebuffer;\n  for (let j = 0; j < commands.length; ++j) {\n    let command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    const derivedCommand = lightShadowsEnabled && command.receiveShadows ? command.derivedCommands.oit.shadows.alphaCommand : command.derivedCommands.oit.alphaCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n  if (defined(invertClassification)) {\n    const command = invertClassification.unclassifiedCommand;\n    const derivedCommand = lightShadowsEnabled && command.receiveShadows ? command.derivedCommands.oit.shadows.alphaCommand : command.derivedCommands.oit.alphaCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n  passState.framebuffer = framebuffer;\n}\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Scene} scene\n * @param {Function} executeFunction\n * @param {PassState} passState\n * @param {DrawCommand[]} commands\n * @param {InvertClassification} invertClassification\n */\nfunction executeTranslucentCommandsSortedMRT(oit, scene, executeFunction, passState, commands, invertClassification) {\n  const {\n    context,\n    frameState\n  } = scene;\n  const {\n    useLogDepth,\n    shadowState\n  } = frameState;\n  const useHdr = scene._hdr;\n  const framebuffer = passState.framebuffer;\n  const lightShadowsEnabled = shadowState.lightShadowsEnabled;\n  passState.framebuffer = oit._adjustTranslucentFBO.framebuffer;\n  oit._adjustTranslucentCommand.execute(context, passState);\n  const debugFramebuffer = oit._opaqueFBO.framebuffer;\n  passState.framebuffer = oit._translucentFBO.framebuffer;\n  for (let j = 0; j < commands.length; ++j) {\n    let command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    const derivedCommand = lightShadowsEnabled && command.receiveShadows ? command.derivedCommands.oit.shadows.translucentCommand : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n  if (defined(invertClassification)) {\n    const command = invertClassification.unclassifiedCommand;\n    const derivedCommand = lightShadowsEnabled && command.receiveShadows ? command.derivedCommands.oit.shadows.translucentCommand : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n  passState.framebuffer = framebuffer;\n}\n\n/**\n * @private\n * @param {Scene} scene\n * @param {Function} executeFunction\n * @param {PassState} passState\n * @param {DrawCommand[]} commands\n * @param {InvertClassification} invertClassification\n */\nOIT.prototype.executeCommands = function (scene, executeFunction, passState, commands, invertClassification) {\n  if (this._translucentMRTSupport) {\n    executeTranslucentCommandsSortedMRT(this, scene, executeFunction, passState, commands, invertClassification);\n    return;\n  }\n  executeTranslucentCommandsSortedMultipass(this, scene, executeFunction, passState, commands, invertClassification);\n};\n\n/**\n * @private\n * @param {Context} context\n * @param {PassState} passState\n */\nOIT.prototype.execute = function (context, passState) {\n  this._compositeCommand.execute(context, passState);\n};\n\n/**\n * @private\n * @param {Context} context\n * @param {PassState} passState\n * @param {Color} clearColor\n */\nOIT.prototype.clear = function (context, passState, clearColor) {\n  const framebuffer = passState.framebuffer;\n  passState.framebuffer = this._opaqueFBO.framebuffer;\n  Color.clone(clearColor, this._opaqueClearCommand.color);\n  this._opaqueClearCommand.execute(context, passState);\n  passState.framebuffer = this._translucentFBO.framebuffer;\n  const translucentClearCommand = this._translucentMRTSupport ? this._translucentMRTClearCommand : this._translucentMultipassClearCommand;\n  translucentClearCommand.execute(context, passState);\n  if (this._translucentMultipassSupport) {\n    passState.framebuffer = this._alphaFBO.framebuffer;\n    this._alphaClearCommand.execute(context, passState);\n  }\n  passState.framebuffer = framebuffer;\n};\n\n/**\n * @private\n * @returns {boolean}\n */\nOIT.prototype.isSupported = function () {\n  return this._translucentMRTSupport || this._translucentMultipassSupport;\n};\n\n/**\n * @private\n * @returns {boolean}\n */\nOIT.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nOIT.prototype.destroy = function () {\n  destroyResources(this);\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.shaderProgram = this._compositeCommand.shaderProgram && this._compositeCommand.shaderProgram.destroy();\n  }\n  if (defined(this._adjustTranslucentCommand)) {\n    this._adjustTranslucentCommand.shaderProgram = this._adjustTranslucentCommand.shaderProgram && this._adjustTranslucentCommand.shaderProgram.destroy();\n  }\n  if (defined(this._adjustAlphaCommand)) {\n    this._adjustAlphaCommand.shaderProgram = this._adjustAlphaCommand.shaderProgram && this._adjustAlphaCommand.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\nexport default OIT;","map":{"version":3,"names":["BoundingRectangle","Color","defined","destroyObject","PixelFormat","WebGLConstants","ClearCommand","DrawCommand","FramebufferManager","PixelDatatype","RenderState","ShaderSource","Texture","AdjustTranslucentFS","CompositeOITFS","BlendEquation","BlendFunction","OIT","context","_numSamples","_translucentMultipassSupport","_translucentMRTSupport","extensionsSupported","colorBufferFloat","depthTexture","floatBlend","drawBuffers","_opaqueFBO","undefined","_opaqueTexture","_depthStencilTexture","_accumulationTexture","_translucentFBO","colorAttachmentsLength","createColorAttachments","createDepthAttachments","depth","_alphaFBO","_adjustTranslucentFBO","_adjustAlphaFBO","_opaqueClearCommand","color","owner","_translucentMRTClearCommand","_translucentMultipassClearCommand","_alphaClearCommand","_translucentRenderStateCache","_alphaRenderStateCache","_compositeCommand","_adjustTranslucentCommand","_adjustAlphaCommand","_viewport","_rs","_useScissorTest","_scissorRectangle","_useHDR","destroyTextures","oit","isDestroyed","destroy","_revealageTexture","destroyFramebuffers","destroyResources","updateTextures","width","height","pixelFormat","RGBA","pixelDatatype","FLOAT","flipY","updateFramebuffers","completeFBO","FRAMEBUFFER_COMPLETE","supported","setColorTexture","setDepthStencilTexture","update","status","translucentComplete","alphaComplete","adjustTranslucentComplete","adjustAlphaComplete","prototype","passState","framebuffer","useHDR","numSamples","isSupported","getColorTexture","getDepthStencilTexture","accumulationTexture","textureChanged","samplesChanged","that","fs","uniformMap","sources","defines","push","u_opaque","u_accumulation","u_revealage","createViewportQuadCommand","u_bgColor","u_depthTexture","useScissorTest","equals","viewport","updateScissor","clone","fromCache","scissorTest","enabled","rectangle","renderState","translucentMRTBlend","equationRgb","ADD","equationAlpha","functionSourceRgb","ONE","functionDestinationRgb","functionSourceAlpha","ZERO","functionDestinationAlpha","ONE_MINUS_SOURCE_ALPHA","translucentColorBlend","translucentAlphaBlend","getTranslucentRenderState","translucentBlending","cache","translucentState","id","rs","getState","depthMask","blending","getTranslucentMRTRenderState","getTranslucentColorRenderState","getTranslucentAlphaRenderState","mrtShaderSource","colorShaderSource","alphaShaderSource","getTranslucentShaderProgram","shaderProgram","keyword","source","shaderCache","shader","getDerivedShaderProgram","attributeLocations","_attributeLocations","fragmentShaderSource","map","fsSource","replaceMain","replace","splice","fragDataMatches","matchAll","fragDataDeclarations","i","length","fragDataMatch","createDerivedShaderProgram","vertexShaderSource","getTranslucentMRTShaderProgram","getTranslucentColorShaderProgram","getTranslucentAlphaShaderProgram","createDerivedCommands","command","result","translucentShader","translucentRenderState","translucentCommand","shallowClone","shaderProgramId","colorShader","colorRenderState","alphaShader","alphaRenderState","alphaCommand","executeTranslucentCommandsSortedMultipass","scene","executeFunction","commands","invertClassification","frameState","useLogDepth","shadowState","useHdr","_hdr","lightShadowsEnabled","execute","debugFramebuffer","j","derivedCommands","logDepth","hdr","derivedCommand","receiveShadows","shadows","unclassifiedCommand","executeTranslucentCommandsSortedMRT","executeCommands","clear","clearColor","translucentClearCommand"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/OIT.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport AdjustTranslucentFS from \"../Shaders/AdjustTranslucentFS.js\";\nimport CompositeOITFS from \"../Shaders/CompositeOITFS.js\";\nimport BlendEquation from \"./BlendEquation.js\";\nimport BlendFunction from \"./BlendFunction.js\";\n\n/**\n * @private\n * @constructor\n * @param {Context} context\n */\nfunction OIT(context) {\n  this._numSamples = 1;\n  // We support multipass for the Chrome D3D9 backend and ES 2.0 on mobile.\n  this._translucentMultipassSupport = false;\n  this._translucentMRTSupport = false;\n\n  const extensionsSupported =\n    context.colorBufferFloat && context.depthTexture && context.floatBlend;\n  this._translucentMRTSupport = context.drawBuffers && extensionsSupported;\n  this._translucentMultipassSupport =\n    !this._translucentMRTSupport && extensionsSupported;\n\n  this._opaqueFBO = undefined;\n  this._opaqueTexture = undefined;\n  this._depthStencilTexture = undefined;\n\n  this._accumulationTexture = undefined;\n\n  this._translucentFBO = new FramebufferManager({\n    colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1,\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depth: true,\n  });\n  this._alphaFBO = new FramebufferManager({\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depth: true,\n  });\n\n  this._adjustTranslucentFBO = new FramebufferManager({\n    colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1,\n    createColorAttachments: false,\n  });\n  this._adjustAlphaFBO = new FramebufferManager({\n    createColorAttachments: false,\n  });\n\n  this._opaqueClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this,\n  });\n  this._translucentMRTClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 1.0),\n    owner: this,\n  });\n  this._translucentMultipassClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this,\n  });\n  this._alphaClearCommand = new ClearCommand({\n    color: new Color(1.0, 1.0, 1.0, 1.0),\n    owner: this,\n  });\n\n  this._translucentRenderStateCache = {};\n  this._alphaRenderStateCache = {};\n\n  this._compositeCommand = undefined;\n  this._adjustTranslucentCommand = undefined;\n  this._adjustAlphaCommand = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._rs = undefined;\n\n  this._useScissorTest = false;\n  this._scissorRectangle = undefined;\n\n  this._useHDR = false;\n}\n\n/**\n * @private\n * @param {OIT} oit\n */\nfunction destroyTextures(oit) {\n  oit._accumulationTexture =\n    oit._accumulationTexture &&\n    !oit._accumulationTexture.isDestroyed() &&\n    oit._accumulationTexture.destroy();\n  oit._revealageTexture =\n    oit._revealageTexture &&\n    !oit._revealageTexture.isDestroyed() &&\n    oit._revealageTexture.destroy();\n}\n\n/**\n * @private\n * @param {OIT} oit\n */\nfunction destroyFramebuffers(oit) {\n  oit._translucentFBO.destroy();\n  oit._alphaFBO.destroy();\n  oit._adjustTranslucentFBO.destroy();\n  oit._adjustAlphaFBO.destroy();\n}\n\n/**\n * @private\n * @param {OIT} oit\n */\nfunction destroyResources(oit) {\n  destroyTextures(oit);\n  destroyFramebuffers(oit);\n}\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Context} context\n * @param {number} width\n * @param {number} height\n */\nfunction updateTextures(oit, context, width, height) {\n  destroyTextures(oit);\n\n  oit._accumulationTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.FLOAT,\n  });\n\n  oit._revealageTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.FLOAT,\n    width: width,\n    height: height,\n    flipY: false,\n  });\n}\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Context} context\n * @returns {boolean}\n */\nfunction updateFramebuffers(oit, context) {\n  destroyFramebuffers(oit);\n\n  const completeFBO = WebGLConstants.FRAMEBUFFER_COMPLETE;\n  let supported = true;\n\n  const { width, height } = oit._accumulationTexture;\n\n  // if MRT is supported, attempt to make an FBO with multiple color attachments\n  if (oit._translucentMRTSupport) {\n    oit._translucentFBO.setColorTexture(oit._accumulationTexture, 0);\n    oit._translucentFBO.setColorTexture(oit._revealageTexture, 1);\n    oit._translucentFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._translucentFBO.update(context, width, height);\n\n    oit._adjustTranslucentFBO.setColorTexture(oit._accumulationTexture, 0);\n    oit._adjustTranslucentFBO.setColorTexture(oit._revealageTexture, 1);\n    oit._adjustTranslucentFBO.update(context, width, height);\n\n    if (\n      oit._translucentFBO.status !== completeFBO ||\n      oit._adjustTranslucentFBO.status !== completeFBO\n    ) {\n      destroyFramebuffers(oit);\n      oit._translucentMRTSupport = false;\n    }\n  }\n\n  // either MRT isn't supported or FBO creation failed, attempt multipass\n  if (!oit._translucentMRTSupport) {\n    oit._translucentFBO.setColorTexture(oit._accumulationTexture);\n    oit._translucentFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._translucentFBO.update(context, width, height);\n\n    oit._alphaFBO.setColorTexture(oit._revealageTexture);\n    oit._alphaFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._alphaFBO.update(context, width, height);\n\n    oit._adjustTranslucentFBO.setColorTexture(oit._accumulationTexture);\n    oit._adjustTranslucentFBO.update(context, width, height);\n\n    oit._adjustAlphaFBO.setColorTexture(oit._revealageTexture);\n    oit._adjustAlphaFBO.update(context, width, height);\n\n    const translucentComplete = oit._translucentFBO.status === completeFBO;\n    const alphaComplete = oit._alphaFBO.status === completeFBO;\n    const adjustTranslucentComplete =\n      oit._adjustTranslucentFBO.status === completeFBO;\n    const adjustAlphaComplete = oit._adjustAlphaFBO.status === completeFBO;\n    if (\n      !translucentComplete ||\n      !alphaComplete ||\n      !adjustTranslucentComplete ||\n      !adjustAlphaComplete\n    ) {\n      destroyResources(oit);\n      oit._translucentMultipassSupport = false;\n      supported = false;\n    }\n  }\n\n  return supported;\n}\n\n/**\n * @private\n * @param {Context} context\n * @param {PassState} passState\n * @param {Framebuffer} framebuffer\n * @param {boolean} useHDR\n * @param {number} numSamples\n */\nOIT.prototype.update = function (\n  context,\n  passState,\n  framebuffer,\n  useHDR,\n  numSamples,\n) {\n  if (!this.isSupported()) {\n    return;\n  }\n\n  this._opaqueFBO = framebuffer;\n  this._opaqueTexture = framebuffer.getColorTexture(0);\n  this._depthStencilTexture = framebuffer.getDepthStencilTexture();\n\n  const { width, height } = this._opaqueTexture;\n\n  const accumulationTexture = this._accumulationTexture;\n  const textureChanged =\n    !defined(accumulationTexture) ||\n    accumulationTexture.width !== width ||\n    accumulationTexture.height !== height ||\n    useHDR !== this._useHDR;\n  const samplesChanged = this._numSamples !== numSamples;\n\n  if (textureChanged || samplesChanged) {\n    this._numSamples = numSamples;\n    updateTextures(this, context, width, height);\n  }\n\n  if (\n    !defined(this._translucentFBO.framebuffer) ||\n    textureChanged ||\n    samplesChanged\n  ) {\n    if (!updateFramebuffers(this, context)) {\n      // framebuffer creation failed\n      return;\n    }\n  }\n\n  this._useHDR = useHDR;\n\n  const that = this;\n  let fs;\n  let uniformMap;\n\n  if (!defined(this._compositeCommand)) {\n    fs = new ShaderSource({\n      sources: [CompositeOITFS],\n    });\n    if (this._translucentMRTSupport) {\n      fs.defines.push(\"MRT\");\n    }\n\n    uniformMap = {\n      u_opaque: function () {\n        return that._opaqueTexture;\n      },\n      u_accumulation: function () {\n        return that._accumulationTexture;\n      },\n      u_revealage: function () {\n        return that._revealageTexture;\n      },\n    };\n    this._compositeCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: this,\n    });\n  }\n\n  if (!defined(this._adjustTranslucentCommand)) {\n    if (this._translucentMRTSupport) {\n      fs = new ShaderSource({\n        defines: [\"MRT\"],\n        sources: [AdjustTranslucentFS],\n      });\n\n      uniformMap = {\n        u_bgColor: function () {\n          return that._translucentMRTClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        },\n      };\n\n      this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this,\n      });\n    } else if (this._translucentMultipassSupport) {\n      fs = new ShaderSource({\n        sources: [AdjustTranslucentFS],\n      });\n\n      uniformMap = {\n        u_bgColor: function () {\n          return that._translucentMultipassClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        },\n      };\n\n      this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this,\n      });\n\n      uniformMap = {\n        u_bgColor: function () {\n          return that._alphaClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        },\n      };\n\n      this._adjustAlphaCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this,\n      });\n    }\n  }\n\n  this._viewport.width = width;\n  this._viewport.height = height;\n\n  const useScissorTest = !BoundingRectangle.equals(\n    this._viewport,\n    passState.viewport,\n  );\n  let updateScissor = useScissorTest !== this._useScissorTest;\n  this._useScissorTest = useScissorTest;\n\n  if (!BoundingRectangle.equals(this._scissorRectangle, passState.viewport)) {\n    this._scissorRectangle = BoundingRectangle.clone(\n      passState.viewport,\n      this._scissorRectangle,\n    );\n    updateScissor = true;\n  }\n\n  if (\n    !defined(this._rs) ||\n    !BoundingRectangle.equals(this._viewport, this._rs.viewport) ||\n    updateScissor\n  ) {\n    this._rs = RenderState.fromCache({\n      viewport: this._viewport,\n      scissorTest: {\n        enabled: this._useScissorTest,\n        rectangle: this._scissorRectangle,\n      },\n    });\n  }\n\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.renderState = this._rs;\n  }\n\n  if (this._adjustTranslucentCommand) {\n    this._adjustTranslucentCommand.renderState = this._rs;\n  }\n\n  if (defined(this._adjustAlphaCommand)) {\n    this._adjustAlphaCommand.renderState = this._rs;\n  }\n};\n\nconst translucentMRTBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ONE,\n  functionDestinationRgb: BlendFunction.ONE,\n  functionSourceAlpha: BlendFunction.ZERO,\n  functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n};\n\nconst translucentColorBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ONE,\n  functionDestinationRgb: BlendFunction.ONE,\n  functionSourceAlpha: BlendFunction.ONE,\n  functionDestinationAlpha: BlendFunction.ONE,\n};\n\nconst translucentAlphaBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ZERO,\n  functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n  functionSourceAlpha: BlendFunction.ZERO,\n  functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n};\n\nfunction getTranslucentRenderState(\n  context,\n  translucentBlending,\n  cache,\n  renderState,\n) {\n  let translucentState = cache[renderState.id];\n  if (!defined(translucentState)) {\n    const rs = RenderState.getState(renderState);\n    rs.depthMask = false;\n    rs.blending = translucentBlending;\n\n    translucentState = RenderState.fromCache(rs);\n    cache[renderState.id] = translucentState;\n  }\n\n  return translucentState;\n}\n\nfunction getTranslucentMRTRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(\n    context,\n    translucentMRTBlend,\n    oit._translucentRenderStateCache,\n    renderState,\n  );\n}\n\nfunction getTranslucentColorRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(\n    context,\n    translucentColorBlend,\n    oit._translucentRenderStateCache,\n    renderState,\n  );\n}\n\nfunction getTranslucentAlphaRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(\n    context,\n    translucentAlphaBlend,\n    oit._alphaRenderStateCache,\n    renderState,\n  );\n}\n\nconst mrtShaderSource =\n  \"    vec3 Ci = czm_out_FragColor.rgb * czm_out_FragColor.a;\\n\" +\n  \"    float ai = czm_out_FragColor.a;\\n\" +\n  \"    float wzi = czm_alphaWeight(ai);\\n\" +\n  \"    out_FragData_0 = vec4(Ci * wzi, ai);\\n\" +\n  \"    out_FragData_1 = vec4(ai * wzi);\\n\";\n\nconst colorShaderSource =\n  \"    vec3 Ci = czm_out_FragColor.rgb * czm_out_FragColor.a;\\n\" +\n  \"    float ai = czm_out_FragColor.a;\\n\" +\n  \"    float wzi = czm_alphaWeight(ai);\\n\" +\n  \"    out_FragColor = vec4(Ci, ai) * wzi;\\n\";\n\nconst alphaShaderSource =\n  \"    float ai = czm_out_FragColor.a;\\n\" + \"    out_FragColor = vec4(ai);\\n\";\n\n/**\n * @private\n * @param {Context} context\n * @param {ShaderProgram} shaderProgram\n * @param {string} keyword\n * @param {string} source\n * @returns {ShaderProgram}\n */\nfunction getTranslucentShaderProgram(context, shaderProgram, keyword, source) {\n  const { shaderCache } = context;\n  const shader = shaderCache.getDerivedShaderProgram(shaderProgram, keyword);\n  if (defined(shader)) {\n    return shader;\n  }\n\n  const attributeLocations = shaderProgram._attributeLocations;\n  const fs = shaderProgram.fragmentShaderSource.clone();\n\n  fs.sources = fs.sources.map(function (fsSource) {\n    return ShaderSource.replaceMain(fsSource, \"czm_translucent_main\")\n      .replace(/out_FragColor/g, \"czm_out_FragColor\")\n      .replace(\n        /layout\\s*\\(location\\s*=\\s*0\\)\\s*out\\s+vec4\\s+out_FragColor;/g,\n        \"\",\n      )\n      .replace(/\\bdiscard\\b/g, \"czm_discard = true\")\n      .replace(/czm_phong/g, \"czm_translucentPhong\");\n  });\n\n  // Discarding the fragment in main is a workaround for ANGLE D3D9\n  // shader compilation errors.\n  fs.sources.splice(\n    0,\n    0,\n    `vec4 czm_out_FragColor;\\n` + `bool czm_discard = false;\\n`,\n  );\n\n  const fragDataMatches = [...source.matchAll(/out_FragData_(\\d+)/g)];\n  let fragDataDeclarations = ``;\n  for (let i = 0; i < fragDataMatches.length; i++) {\n    const fragDataMatch = fragDataMatches[i];\n    fragDataDeclarations = `layout (location = ${fragDataMatch[1]}) out vec4 ${fragDataMatch[0]};\\n${fragDataDeclarations}`;\n  }\n  fs.sources.push(fragDataDeclarations);\n\n  fs.sources.push(\n    `${\n      \"void main()\\n\" +\n      \"{\\n\" +\n      \"    czm_translucent_main();\\n\" +\n      \"    if (czm_discard)\\n\" +\n      \"    {\\n\" +\n      \"        discard;\\n\" +\n      \"    }\\n\"\n    }${source}}\\n`,\n  );\n\n  return shaderCache.createDerivedShaderProgram(shaderProgram, keyword, {\n    vertexShaderSource: shaderProgram.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction getTranslucentMRTShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(\n    context,\n    shaderProgram,\n    \"translucentMRT\",\n    mrtShaderSource,\n  );\n}\n\nfunction getTranslucentColorShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(\n    context,\n    shaderProgram,\n    \"translucentMultipass\",\n    colorShaderSource,\n  );\n}\n\nfunction getTranslucentAlphaShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(\n    context,\n    shaderProgram,\n    \"alphaMultipass\",\n    alphaShaderSource,\n  );\n}\n\n/**\n * @private\n * @param {DrawCommand} command\n * @param {Context} context\n * @param {*} result\n * @returns {*}\n */\nOIT.prototype.createDerivedCommands = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  if (this._translucentMRTSupport) {\n    let translucentShader;\n    let translucentRenderState;\n    if (defined(result.translucentCommand)) {\n      translucentShader = result.translucentCommand.shaderProgram;\n      translucentRenderState = result.translucentCommand.renderState;\n    }\n\n    result.translucentCommand = DrawCommand.shallowClone(\n      command,\n      result.translucentCommand,\n    );\n\n    if (\n      !defined(translucentShader) ||\n      result.shaderProgramId !== command.shaderProgram.id\n    ) {\n      result.translucentCommand.shaderProgram = getTranslucentMRTShaderProgram(\n        context,\n        command.shaderProgram,\n      );\n      result.translucentCommand.renderState = getTranslucentMRTRenderState(\n        this,\n        context,\n        command.renderState,\n      );\n      result.shaderProgramId = command.shaderProgram.id;\n    } else {\n      result.translucentCommand.shaderProgram = translucentShader;\n      result.translucentCommand.renderState = translucentRenderState;\n    }\n    return result;\n  }\n\n  let colorShader;\n  let colorRenderState;\n  let alphaShader;\n  let alphaRenderState;\n  if (defined(result.translucentCommand)) {\n    colorShader = result.translucentCommand.shaderProgram;\n    colorRenderState = result.translucentCommand.renderState;\n    alphaShader = result.alphaCommand.shaderProgram;\n    alphaRenderState = result.alphaCommand.renderState;\n  }\n\n  result.translucentCommand = DrawCommand.shallowClone(\n    command,\n    result.translucentCommand,\n  );\n  result.alphaCommand = DrawCommand.shallowClone(command, result.alphaCommand);\n\n  if (\n    !defined(colorShader) ||\n    result.shaderProgramId !== command.shaderProgram.id\n  ) {\n    result.translucentCommand.shaderProgram = getTranslucentColorShaderProgram(\n      context,\n      command.shaderProgram,\n    );\n    result.translucentCommand.renderState = getTranslucentColorRenderState(\n      this,\n      context,\n      command.renderState,\n    );\n    result.alphaCommand.shaderProgram = getTranslucentAlphaShaderProgram(\n      context,\n      command.shaderProgram,\n    );\n    result.alphaCommand.renderState = getTranslucentAlphaRenderState(\n      this,\n      context,\n      command.renderState,\n    );\n    result.shaderProgramId = command.shaderProgram.id;\n  } else {\n    result.translucentCommand.shaderProgram = colorShader;\n    result.translucentCommand.renderState = colorRenderState;\n    result.alphaCommand.shaderProgram = alphaShader;\n    result.alphaCommand.renderState = alphaRenderState;\n  }\n\n  return result;\n};\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Scene} scene\n * @param {Function} executeFunction\n * @param {PassState} passState\n * @param {DrawCommand[]} commands\n * @param {InvertClassification} invertClassification\n */\nfunction executeTranslucentCommandsSortedMultipass(\n  oit,\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification,\n) {\n  const { context, frameState } = scene;\n  const { useLogDepth, shadowState } = frameState;\n  const useHdr = scene._hdr;\n  const framebuffer = passState.framebuffer;\n\n  const lightShadowsEnabled = shadowState.lightShadowsEnabled;\n\n  passState.framebuffer = oit._adjustTranslucentFBO.framebuffer;\n  oit._adjustTranslucentCommand.execute(context, passState);\n  passState.framebuffer = oit._adjustAlphaFBO.framebuffer;\n  oit._adjustAlphaCommand.execute(context, passState);\n\n  const debugFramebuffer = oit._opaqueFBO.framebuffer;\n  passState.framebuffer = oit._translucentFBO.framebuffer;\n\n  for (let j = 0; j < commands.length; ++j) {\n    let command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    const derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n\n  if (defined(invertClassification)) {\n    const command = invertClassification.unclassifiedCommand;\n    const derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n\n  passState.framebuffer = oit._alphaFBO.framebuffer;\n\n  for (let j = 0; j < commands.length; ++j) {\n    let command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    const derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.alphaCommand\n        : command.derivedCommands.oit.alphaCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n\n  if (defined(invertClassification)) {\n    const command = invertClassification.unclassifiedCommand;\n    const derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.alphaCommand\n        : command.derivedCommands.oit.alphaCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n\n  passState.framebuffer = framebuffer;\n}\n\n/**\n * @private\n * @param {OIT} oit\n * @param {Scene} scene\n * @param {Function} executeFunction\n * @param {PassState} passState\n * @param {DrawCommand[]} commands\n * @param {InvertClassification} invertClassification\n */\nfunction executeTranslucentCommandsSortedMRT(\n  oit,\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification,\n) {\n  const { context, frameState } = scene;\n  const { useLogDepth, shadowState } = frameState;\n  const useHdr = scene._hdr;\n  const framebuffer = passState.framebuffer;\n\n  const lightShadowsEnabled = shadowState.lightShadowsEnabled;\n\n  passState.framebuffer = oit._adjustTranslucentFBO.framebuffer;\n  oit._adjustTranslucentCommand.execute(context, passState);\n\n  const debugFramebuffer = oit._opaqueFBO.framebuffer;\n  passState.framebuffer = oit._translucentFBO.framebuffer;\n\n  for (let j = 0; j < commands.length; ++j) {\n    let command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    const derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n\n  if (defined(invertClassification)) {\n    const command = invertClassification.unclassifiedCommand;\n    const derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(derivedCommand, scene, passState, debugFramebuffer);\n  }\n\n  passState.framebuffer = framebuffer;\n}\n\n/**\n * @private\n * @param {Scene} scene\n * @param {Function} executeFunction\n * @param {PassState} passState\n * @param {DrawCommand[]} commands\n * @param {InvertClassification} invertClassification\n */\nOIT.prototype.executeCommands = function (\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification,\n) {\n  if (this._translucentMRTSupport) {\n    executeTranslucentCommandsSortedMRT(\n      this,\n      scene,\n      executeFunction,\n      passState,\n      commands,\n      invertClassification,\n    );\n    return;\n  }\n\n  executeTranslucentCommandsSortedMultipass(\n    this,\n    scene,\n    executeFunction,\n    passState,\n    commands,\n    invertClassification,\n  );\n};\n\n/**\n * @private\n * @param {Context} context\n * @param {PassState} passState\n */\nOIT.prototype.execute = function (context, passState) {\n  this._compositeCommand.execute(context, passState);\n};\n\n/**\n * @private\n * @param {Context} context\n * @param {PassState} passState\n * @param {Color} clearColor\n */\nOIT.prototype.clear = function (context, passState, clearColor) {\n  const framebuffer = passState.framebuffer;\n\n  passState.framebuffer = this._opaqueFBO.framebuffer;\n  Color.clone(clearColor, this._opaqueClearCommand.color);\n  this._opaqueClearCommand.execute(context, passState);\n\n  passState.framebuffer = this._translucentFBO.framebuffer;\n  const translucentClearCommand = this._translucentMRTSupport\n    ? this._translucentMRTClearCommand\n    : this._translucentMultipassClearCommand;\n  translucentClearCommand.execute(context, passState);\n\n  if (this._translucentMultipassSupport) {\n    passState.framebuffer = this._alphaFBO.framebuffer;\n    this._alphaClearCommand.execute(context, passState);\n  }\n\n  passState.framebuffer = framebuffer;\n};\n\n/**\n * @private\n * @returns {boolean}\n */\nOIT.prototype.isSupported = function () {\n  return this._translucentMRTSupport || this._translucentMultipassSupport;\n};\n\n/**\n * @private\n * @returns {boolean}\n */\nOIT.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nOIT.prototype.destroy = function () {\n  destroyResources(this);\n\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.shaderProgram =\n      this._compositeCommand.shaderProgram &&\n      this._compositeCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._adjustTranslucentCommand)) {\n    this._adjustTranslucentCommand.shaderProgram =\n      this._adjustTranslucentCommand.shaderProgram &&\n      this._adjustTranslucentCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._adjustAlphaCommand)) {\n    this._adjustAlphaCommand.shaderProgram =\n      this._adjustAlphaCommand.shaderProgram &&\n      this._adjustAlphaCommand.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\n\nexport default OIT;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}