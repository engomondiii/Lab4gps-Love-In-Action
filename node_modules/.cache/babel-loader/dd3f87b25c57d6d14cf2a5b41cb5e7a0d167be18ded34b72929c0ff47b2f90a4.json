{"ast":null,"code":"import binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport TimeInterval from \"./TimeInterval.js\";\nfunction compareIntervalStartTimes(left, right) {\n  return JulianDate.compare(left.start, right.start);\n}\n\n/**\n * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.\n * @alias TimeIntervalCollection\n * @constructor\n *\n * @param {TimeInterval[]} [intervals] An array of intervals to add to the collection.\n */\nfunction TimeIntervalCollection(intervals) {\n  this._intervals = [];\n  this._changedEvent = new Event();\n  if (defined(intervals)) {\n    const length = intervals.length;\n    for (let i = 0; i < length; i++) {\n      this.addInterval(intervals[i]);\n    }\n  }\n}\nObject.defineProperties(TimeIntervalCollection.prototype, {\n  /**\n   * Gets an event that is raised whenever the collection of intervals change.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changedEvent: {\n    get: function () {\n      return this._changedEvent;\n    }\n  },\n  /**\n   * Gets the start time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      const intervals = this._intervals;\n      return intervals.length === 0 ? undefined : intervals[0].start;\n    }\n  },\n  /**\n   * Gets whether or not the start time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isStartIncluded: {\n    get: function () {\n      const intervals = this._intervals;\n      return intervals.length === 0 ? false : intervals[0].isStartIncluded;\n    }\n  },\n  /**\n   * Gets the stop time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  stop: {\n    get: function () {\n      const intervals = this._intervals;\n      const length = intervals.length;\n      return length === 0 ? undefined : intervals[length - 1].stop;\n    }\n  },\n  /**\n   * Gets whether or not the stop time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isStopIncluded: {\n    get: function () {\n      const intervals = this._intervals;\n      const length = intervals.length;\n      return length === 0 ? false : intervals[length - 1].isStopIncluded;\n    }\n  },\n  /**\n   * Gets the number of intervals in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._intervals.length;\n    }\n  },\n  /**\n   * Gets whether or not the collection is empty.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      return this._intervals.length === 0;\n    }\n  }\n});\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeIntervalCollection} [right] The right hand side collection.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.equals = function (right, dataComparer) {\n  if (this === right) {\n    return true;\n  }\n  if (!(right instanceof TimeIntervalCollection)) {\n    return false;\n  }\n  const intervals = this._intervals;\n  const rightIntervals = right._intervals;\n  const length = intervals.length;\n  if (length !== rightIntervals.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (!TimeInterval.equals(intervals[i], rightIntervals[i], dataComparer)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Gets the interval at the specified index.\n *\n * @param {number} index The index of the interval to retrieve.\n * @returns {TimeInterval|undefined} The interval at the specified index, or <code>undefined</code> if no interval exists as that index.\n */\nTimeIntervalCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._intervals[index];\n};\n\n/**\n * Removes all intervals from the collection.\n */\nTimeIntervalCollection.prototype.removeAll = function () {\n  if (this._intervals.length > 0) {\n    this._intervals.length = 0;\n    this._changedEvent.raiseEvent(this);\n  }\n};\n\n/**\n * Finds and returns the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {TimeInterval|undefined} The interval containing the specified date, <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findIntervalContainingDate = function (date) {\n  const index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index] : undefined;\n};\n\n/**\n * Finds and returns the data for the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {object} The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findDataForIntervalContainingDate = function (date) {\n  const index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index].data : undefined;\n};\n\n/**\n * Checks if the specified date is inside this collection.\n *\n * @param {JulianDate} julianDate The date to check.\n * @returns {boolean} <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.contains = function (julianDate) {\n  return this.indexOf(julianDate) >= 0;\n};\nconst indexOfScratch = new TimeInterval();\n\n/**\n * Finds and returns the index of the interval in the collection that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {number} The index of the interval that contains the specified date, if no such interval exists,\n * it returns a negative number which is the bitwise complement of the index of the next interval that\n * starts after the date, or if no interval starts after the specified date, the bitwise complement of\n * the length of the collection.\n */\nTimeIntervalCollection.prototype.indexOf = function (date) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required\");\n  }\n  //>>includeEnd('debug');\n\n  const intervals = this._intervals;\n  indexOfScratch.start = date;\n  indexOfScratch.stop = date;\n  let index = binarySearch(intervals, indexOfScratch, compareIntervalStartTimes);\n  if (index >= 0) {\n    if (intervals[index].isStartIncluded) {\n      return index;\n    }\n    if (index > 0 && intervals[index - 1].stop.equals(date) && intervals[index - 1].isStopIncluded) {\n      return index - 1;\n    }\n    return ~index;\n  }\n  index = ~index;\n  if (index > 0 && index - 1 < intervals.length && TimeInterval.contains(intervals[index - 1], date)) {\n    return index - 1;\n  }\n  return ~index;\n};\n\n/**\n * Returns the first interval in the collection that matches the specified parameters.\n * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.start] The start time of the interval.\n * @param {JulianDate} [options.stop] The stop time of the interval.\n * @param {boolean} [options.isStartIncluded] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @returns {TimeInterval|undefined} The first interval in the collection that matches the specified parameters.\n */\nTimeIntervalCollection.prototype.findInterval = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const start = options.start;\n  const stop = options.stop;\n  const isStartIncluded = options.isStartIncluded;\n  const isStopIncluded = options.isStopIncluded;\n  const intervals = this._intervals;\n  for (let i = 0, len = intervals.length; i < len; i++) {\n    const interval = intervals[i];\n    if ((!defined(start) || interval.start.equals(start)) && (!defined(stop) || interval.stop.equals(stop)) && (!defined(isStartIncluded) || interval.isStartIncluded === isStartIncluded) && (!defined(isStopIncluded) || interval.isStopIncluded === isStopIncluded)) {\n      return intervals[i];\n    }\n  }\n  return undefined;\n};\n\n/**\n * Adds an interval to the collection, merging intervals that contain the same data and\n * splitting intervals of different data as needed in order to maintain a non-overlapping collection.\n * The data in the new interval takes precedence over any existing intervals in the collection.\n *\n * @param {TimeInterval} interval The interval to add.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n */\nTimeIntervalCollection.prototype.addInterval = function (interval, dataComparer) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(interval)) {\n    throw new DeveloperError(\"interval is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (interval.isEmpty) {\n    return;\n  }\n  const intervals = this._intervals;\n\n  // Handle the common case quickly: we're adding a new interval which is after all existing intervals.\n  if (intervals.length === 0 || JulianDate.greaterThan(interval.start, intervals[intervals.length - 1].stop)) {\n    intervals.push(interval);\n    this._changedEvent.raiseEvent(this);\n    return;\n  }\n\n  // Keep the list sorted by the start date\n  let index = binarySearch(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  } else {\n    // interval's start date exactly equals the start date of at least one interval in the collection.\n    // It could actually equal the start date of two intervals if one of them does not actually\n    // include the date.  In that case, the binary search could have found either.  We need to\n    // look at the surrounding intervals and their IsStartIncluded properties in order to make sure\n    // we're working with the correct interval.\n\n    // eslint-disable-next-line no-lonely-if\n    if (index > 0 && interval.isStartIncluded && intervals[index - 1].isStartIncluded && intervals[index - 1].start.equals(interval.start)) {\n      --index;\n    } else if (index < intervals.length && !interval.isStartIncluded && intervals[index].isStartIncluded && intervals[index].start.equals(interval.start)) {\n      ++index;\n    }\n  }\n  let comparison;\n  if (index > 0) {\n    // Not the first thing in the list, so see if the interval before this one\n    // overlaps this one.\n\n    comparison = JulianDate.compare(intervals[index - 1].stop, interval.start);\n    if (comparison > 0 || comparison === 0 && (intervals[index - 1].isStopIncluded || interval.isStartIncluded)) {\n      // There is an overlap\n      if (defined(dataComparer) ? dataComparer(intervals[index - 1].data, interval.data) : intervals[index - 1].data === interval.data) {\n        // Overlapping intervals have the same data, so combine them\n        if (JulianDate.greaterThan(interval.stop, intervals[index - 1].stop)) {\n          interval = new TimeInterval({\n            start: intervals[index - 1].start,\n            stop: interval.stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded: interval.isStopIncluded,\n            data: interval.data\n          });\n        } else {\n          interval = new TimeInterval({\n            start: intervals[index - 1].start,\n            stop: intervals[index - 1].stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded: intervals[index - 1].isStopIncluded || interval.stop.equals(intervals[index - 1].stop) && interval.isStopIncluded,\n            data: interval.data\n          });\n        }\n        intervals.splice(index - 1, 1);\n        --index;\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added 'wins' so truncate the previous interval.\n        // If the existing interval extends past the end of the new one,\n        // split the existing interval into two intervals.\n        comparison = JulianDate.compare(intervals[index - 1].stop, interval.stop);\n        if (comparison > 0 || comparison === 0 && intervals[index - 1].isStopIncluded && !interval.isStopIncluded) {\n          intervals.splice(index, 0, new TimeInterval({\n            start: interval.stop,\n            stop: intervals[index - 1].stop,\n            isStartIncluded: !interval.isStopIncluded,\n            isStopIncluded: intervals[index - 1].isStopIncluded,\n            data: intervals[index - 1].data\n          }));\n        }\n        intervals[index - 1] = new TimeInterval({\n          start: intervals[index - 1].start,\n          stop: interval.start,\n          isStartIncluded: intervals[index - 1].isStartIncluded,\n          isStopIncluded: !interval.isStartIncluded,\n          data: intervals[index - 1].data\n        });\n      }\n    }\n  }\n  while (index < intervals.length) {\n    // Not the last thing in the list, so see if the intervals after this one overlap this one.\n    comparison = JulianDate.compare(interval.stop, intervals[index].start);\n    if (comparison > 0 || comparison === 0 && (interval.isStopIncluded || intervals[index].isStartIncluded)) {\n      // There is an overlap\n      if (defined(dataComparer) ? dataComparer(intervals[index].data, interval.data) : intervals[index].data === interval.data) {\n        // Overlapping intervals have the same data, so combine them\n        interval = new TimeInterval({\n          start: interval.start,\n          stop: JulianDate.greaterThan(intervals[index].stop, interval.stop) ? intervals[index].stop : interval.stop,\n          isStartIncluded: interval.isStartIncluded,\n          isStopIncluded: JulianDate.greaterThan(intervals[index].stop, interval.stop) ? intervals[index].isStopIncluded : interval.isStopIncluded,\n          data: interval.data\n        });\n        intervals.splice(index, 1);\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added 'wins' so truncate the next interval.\n        intervals[index] = new TimeInterval({\n          start: interval.stop,\n          stop: intervals[index].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data\n        });\n        if (intervals[index].isEmpty) {\n          intervals.splice(index, 1);\n        } else {\n          // Found a partial span, so it is not possible for the next\n          // interval to be spanned at all.  Stop looking.\n          break;\n        }\n      }\n    } else {\n      // Found the last one we're spanning, so stop looking.\n      break;\n    }\n  }\n\n  // Add the new interval\n  intervals.splice(index, 0, interval);\n  this._changedEvent.raiseEvent(this);\n};\n\n/**\n * Removes the specified interval from this interval collection, creating a hole over the specified interval.\n * The data property of the input interval is ignored.\n *\n * @param {TimeInterval} interval The interval to remove.\n * @returns {boolean} <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.\n */\nTimeIntervalCollection.prototype.removeInterval = function (interval) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(interval)) {\n    throw new DeveloperError(\"interval is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (interval.isEmpty) {\n    return false;\n  }\n  const intervals = this._intervals;\n  let index = binarySearch(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  }\n  let result = false;\n\n  // Check for truncation of the end of the previous interval.\n  if (index > 0 && (JulianDate.greaterThan(intervals[index - 1].stop, interval.start) || intervals[index - 1].stop.equals(interval.start) && intervals[index - 1].isStopIncluded && interval.isStartIncluded)) {\n    result = true;\n    if (JulianDate.greaterThan(intervals[index - 1].stop, interval.stop) || intervals[index - 1].isStopIncluded && !interval.isStopIncluded && intervals[index - 1].stop.equals(interval.stop)) {\n      // Break the existing interval into two pieces\n      intervals.splice(index, 0, new TimeInterval({\n        start: interval.stop,\n        stop: intervals[index - 1].stop,\n        isStartIncluded: !interval.isStopIncluded,\n        isStopIncluded: intervals[index - 1].isStopIncluded,\n        data: intervals[index - 1].data\n      }));\n    }\n    intervals[index - 1] = new TimeInterval({\n      start: intervals[index - 1].start,\n      stop: interval.start,\n      isStartIncluded: intervals[index - 1].isStartIncluded,\n      isStopIncluded: !interval.isStartIncluded,\n      data: intervals[index - 1].data\n    });\n  }\n\n  // Check if the Start of the current interval should remain because interval.start is the same but\n  // it is not included.\n  if (index < intervals.length && !interval.isStartIncluded && intervals[index].isStartIncluded && interval.start.equals(intervals[index].start)) {\n    result = true;\n    intervals.splice(index, 0, new TimeInterval({\n      start: intervals[index].start,\n      stop: intervals[index].start,\n      isStartIncluded: true,\n      isStopIncluded: true,\n      data: intervals[index].data\n    }));\n    ++index;\n  }\n\n  // Remove any intervals that are completely overlapped by the input interval.\n  while (index < intervals.length && JulianDate.greaterThan(interval.stop, intervals[index].stop)) {\n    result = true;\n    intervals.splice(index, 1);\n  }\n\n  // Check for the case where the input interval ends on the same date\n  // as an existing interval.\n  if (index < intervals.length && interval.stop.equals(intervals[index].stop)) {\n    result = true;\n    if (!interval.isStopIncluded && intervals[index].isStopIncluded) {\n      // Last point of interval should remain because the stop date is included in\n      // the existing interval but is not included in the input interval.\n      if (index + 1 < intervals.length && intervals[index + 1].start.equals(interval.stop) && intervals[index].data === intervals[index + 1].data) {\n        // Combine single point with the next interval\n        intervals.splice(index, 1);\n        intervals[index] = new TimeInterval({\n          start: intervals[index].start,\n          stop: intervals[index].stop,\n          isStartIncluded: true,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data\n        });\n      } else {\n        intervals[index] = new TimeInterval({\n          start: interval.stop,\n          stop: interval.stop,\n          isStartIncluded: true,\n          isStopIncluded: true,\n          data: intervals[index].data\n        });\n      }\n    } else {\n      // Interval is completely overlapped\n      intervals.splice(index, 1);\n    }\n  }\n\n  // Truncate any partially-overlapped intervals.\n  if (index < intervals.length && (JulianDate.greaterThan(interval.stop, intervals[index].start) || interval.stop.equals(intervals[index].start) && interval.isStopIncluded && intervals[index].isStartIncluded)) {\n    result = true;\n    intervals[index] = new TimeInterval({\n      start: interval.stop,\n      stop: intervals[index].stop,\n      isStartIncluded: !interval.isStopIncluded,\n      isStopIncluded: intervals[index].isStopIncluded,\n      data: intervals[index].data\n    });\n  }\n  if (result) {\n    this._changedEvent.raiseEvent(this);\n  }\n  return result;\n};\n\n/**\n * Creates a new instance that is the intersection of this collection and the provided collection.\n *\n * @param {TimeIntervalCollection} other The collection to intersect with.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeIntervalCollection} A new TimeIntervalCollection which is the intersection of this collection and the provided collection.\n */\nTimeIntervalCollection.prototype.intersect = function (other, dataComparer, mergeCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(other)) {\n    throw new DeveloperError(\"other is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const result = new TimeIntervalCollection();\n  let left = 0;\n  let right = 0;\n  const intervals = this._intervals;\n  const otherIntervals = other._intervals;\n  while (left < intervals.length && right < otherIntervals.length) {\n    const leftInterval = intervals[left];\n    const rightInterval = otherIntervals[right];\n    if (JulianDate.lessThan(leftInterval.stop, rightInterval.start)) {\n      ++left;\n    } else if (JulianDate.lessThan(rightInterval.stop, leftInterval.start)) {\n      ++right;\n    } else {\n      // The following will return an intersection whose data is 'merged' if the callback is defined\n      if (defined(mergeCallback) || defined(dataComparer) && dataComparer(leftInterval.data, rightInterval.data) || !defined(dataComparer) && rightInterval.data === leftInterval.data) {\n        const intersection = TimeInterval.intersect(leftInterval, rightInterval, new TimeInterval(), mergeCallback);\n        if (!intersection.isEmpty) {\n          // Since we start with an empty collection for 'result', and there are no overlapping intervals in 'this' (as a rule),\n          // the 'intersection' will never overlap with a previous interval in 'result'.  So, no need to do any additional 'merging'.\n          result.addInterval(intersection, dataComparer);\n        }\n      }\n      if (JulianDate.lessThan(leftInterval.stop, rightInterval.stop) || leftInterval.stop.equals(rightInterval.stop) && !leftInterval.isStopIncluded && rightInterval.isStopIncluded) {\n        ++left;\n      } else {\n        ++right;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Creates a new instance from a JulianDate array.\n *\n * @param {object} options Object with the following properties:\n * @param {JulianDate[]} options.julianDates An array of ISO 8601 dates.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromJulianDateArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.julianDates)) {\n    throw new DeveloperError(\"options.iso8601Array is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new TimeIntervalCollection();\n  }\n  const julianDates = options.julianDates;\n  const length = julianDates.length;\n  const dataCallback = options.dataCallback;\n  const isStartIncluded = defaultValue(options.isStartIncluded, true);\n  const isStopIncluded = defaultValue(options.isStopIncluded, true);\n  const leadingInterval = defaultValue(options.leadingInterval, false);\n  const trailingInterval = defaultValue(options.trailingInterval, false);\n  let interval;\n\n  // Add a default interval, which will only end up being used up to first interval\n  let startIndex = 0;\n  if (leadingInterval) {\n    ++startIndex;\n    interval = new TimeInterval({\n      start: Iso8601.MINIMUM_VALUE,\n      stop: julianDates[0],\n      isStartIncluded: true,\n      isStopIncluded: !isStartIncluded\n    });\n    interval.data = defined(dataCallback) ? dataCallback(interval, result.length) : result.length;\n    result.addInterval(interval);\n  }\n  for (let i = 0; i < length - 1; ++i) {\n    let startDate = julianDates[i];\n    const endDate = julianDates[i + 1];\n    interval = new TimeInterval({\n      start: startDate,\n      stop: endDate,\n      isStartIncluded: result.length === startIndex ? isStartIncluded : true,\n      isStopIncluded: i === length - 2 ? isStopIncluded : false\n    });\n    interval.data = defined(dataCallback) ? dataCallback(interval, result.length) : result.length;\n    result.addInterval(interval);\n    startDate = endDate;\n  }\n  if (trailingInterval) {\n    interval = new TimeInterval({\n      start: julianDates[length - 1],\n      stop: Iso8601.MAXIMUM_VALUE,\n      isStartIncluded: !isStopIncluded,\n      isStopIncluded: true\n    });\n    interval.data = defined(dataCallback) ? dataCallback(interval, result.length) : result.length;\n    result.addInterval(interval);\n  }\n  return result;\n};\nconst scratchGregorianDate = new GregorianDate();\nconst monthLengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * Adds duration represented as a GregorianDate to a JulianDate\n *\n * @param {JulianDate} julianDate The date.\n * @param {GregorianDate} duration An duration represented as a GregorianDate.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n *\n * @private\n */\nfunction addToDate(julianDate, duration, result) {\n  if (!defined(result)) {\n    result = new JulianDate();\n  }\n  JulianDate.toGregorianDate(julianDate, scratchGregorianDate);\n  let millisecond = scratchGregorianDate.millisecond + duration.millisecond;\n  let second = scratchGregorianDate.second + duration.second;\n  let minute = scratchGregorianDate.minute + duration.minute;\n  let hour = scratchGregorianDate.hour + duration.hour;\n  let day = scratchGregorianDate.day + duration.day;\n  let month = scratchGregorianDate.month + duration.month;\n  let year = scratchGregorianDate.year + duration.year;\n  if (millisecond >= 1000) {\n    second += Math.floor(millisecond / 1000);\n    millisecond = millisecond % 1000;\n  }\n  if (second >= 60) {\n    minute += Math.floor(second / 60);\n    second = second % 60;\n  }\n  if (minute >= 60) {\n    hour += Math.floor(minute / 60);\n    minute = minute % 60;\n  }\n  if (hour >= 24) {\n    day += Math.floor(hour / 24);\n    hour = hour % 24;\n  }\n\n  // If days is greater than the month's length we need to remove those number of days,\n  //  readjust month and year and repeat until days is less than the month's length.\n  monthLengths[2] = isLeapYear(year) ? 29 : 28;\n  while (day > monthLengths[month] || month >= 13) {\n    if (day > monthLengths[month]) {\n      day -= monthLengths[month];\n      ++month;\n    }\n    if (month >= 13) {\n      --month;\n      year += Math.floor(month / 12);\n      month = month % 12;\n      ++month;\n    }\n    monthLengths[2] = isLeapYear(year) ? 29 : 28;\n  }\n  scratchGregorianDate.millisecond = millisecond;\n  scratchGregorianDate.second = second;\n  scratchGregorianDate.minute = minute;\n  scratchGregorianDate.hour = hour;\n  scratchGregorianDate.day = day;\n  scratchGregorianDate.month = month;\n  scratchGregorianDate.year = year;\n  return JulianDate.fromGregorianDate(scratchGregorianDate, result);\n}\nconst scratchJulianDate = new JulianDate();\nconst durationRegex = /P(?:([\\d.,]+)Y)?(?:([\\d.,]+)M)?(?:([\\d.,]+)W)?(?:([\\d.,]+)D)?(?:T(?:([\\d.,]+)H)?(?:([\\d.,]+)M)?(?:([\\d.,]+)S)?)?/;\n\n/**\n * Parses ISO8601 duration string\n *\n * @param {string} iso8601 An ISO 8601 duration.\n * @param {GregorianDate} result An existing instance to use for the result.\n * @returns {boolean} True is parsing succeeded, false otherwise\n *\n * @private\n */\nfunction parseDuration(iso8601, result) {\n  if (!defined(iso8601) || iso8601.length === 0) {\n    return false;\n  }\n\n  // Reset object\n  result.year = 0;\n  result.month = 0;\n  result.day = 0;\n  result.hour = 0;\n  result.minute = 0;\n  result.second = 0;\n  result.millisecond = 0;\n  if (iso8601[0] === \"P\") {\n    const matches = iso8601.match(durationRegex);\n    if (!defined(matches)) {\n      return false;\n    }\n    if (defined(matches[1])) {\n      // Years\n      result.year = Number(matches[1].replace(\",\", \".\"));\n    }\n    if (defined(matches[2])) {\n      // Months\n      result.month = Number(matches[2].replace(\",\", \".\"));\n    }\n    if (defined(matches[3])) {\n      // Weeks\n      result.day = Number(matches[3].replace(\",\", \".\")) * 7;\n    }\n    if (defined(matches[4])) {\n      // Days\n      result.day += Number(matches[4].replace(\",\", \".\"));\n    }\n    if (defined(matches[5])) {\n      // Hours\n      result.hour = Number(matches[5].replace(\",\", \".\"));\n    }\n    if (defined(matches[6])) {\n      // Weeks\n      result.minute = Number(matches[6].replace(\",\", \".\"));\n    }\n    if (defined(matches[7])) {\n      // Seconds\n      const seconds = Number(matches[7].replace(\",\", \".\"));\n      result.second = Math.floor(seconds);\n      result.millisecond = seconds % 1 * 1000;\n    }\n  } else {\n    // They can technically specify the duration as a normal date with some caveats. Try our best to load it.\n    if (iso8601[iso8601.length - 1] !== \"Z\") {\n      // It's not a date, its a duration, so it always has to be UTC\n      iso8601 += \"Z\";\n    }\n    JulianDate.toGregorianDate(JulianDate.fromIso8601(iso8601, scratchJulianDate), result);\n  }\n\n  // A duration of 0 will cause an infinite loop, so just make sure something is non-zero\n  return result.year || result.month || result.day || result.hour || result.minute || result.second || result.millisecond;\n}\nconst scratchDuration = new GregorianDate();\n/**\n * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.iso8601 An ISO 8601 interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.iso8601)) {\n    throw new DeveloperError(\"options.iso8601 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dates = options.iso8601.split(\"/\");\n  const start = JulianDate.fromIso8601(dates[0]);\n  const stop = JulianDate.fromIso8601(dates[1]);\n  const julianDates = [];\n  if (!parseDuration(dates[2], scratchDuration)) {\n    julianDates.push(start, stop);\n  } else {\n    let date = JulianDate.clone(start);\n    julianDates.push(date);\n    while (JulianDate.compare(date, stop) < 0) {\n      date = addToDate(date, scratchDuration);\n      const afterStop = JulianDate.compare(stop, date) <= 0;\n      if (afterStop) {\n        JulianDate.clone(stop, date);\n      }\n      julianDates.push(date);\n    }\n  }\n  return TimeIntervalCollection.fromJulianDateArray({\n    julianDates: julianDates,\n    isStartIncluded: options.isStartIncluded,\n    isStopIncluded: options.isStopIncluded,\n    leadingInterval: options.leadingInterval,\n    trailingInterval: options.trailingInterval,\n    dataCallback: options.dataCallback\n  }, result);\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.\n *\n * @param {object} options Object with the following properties:\n * @param {string[]} options.iso8601Dates An array of ISO 8601 dates.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DateArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.iso8601Dates)) {\n    throw new DeveloperError(\"options.iso8601Dates is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return TimeIntervalCollection.fromJulianDateArray({\n    julianDates: options.iso8601Dates.map(function (date) {\n      return JulianDate.fromIso8601(date);\n    }),\n    isStartIncluded: options.isStartIncluded,\n    isStopIncluded: options.isStopIncluded,\n    leadingInterval: options.leadingInterval,\n    trailingInterval: options.trailingInterval,\n    dataCallback: options.dataCallback\n  }, result);\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.\n *\n * @param {object} options Object with the following properties:\n * @param {JulianDate} options.epoch An date that the durations are relative to.\n * @param {string} options.iso8601Durations An array of ISO 8601 durations.\n * @param {boolean} [options.relativeToPrevious=false] <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DurationArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.epoch)) {\n    throw new DeveloperError(\"options.epoch is required.\");\n  }\n  if (!defined(options.iso8601Durations)) {\n    throw new DeveloperError(\"options.iso8601Durations is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const epoch = options.epoch;\n  const iso8601Durations = options.iso8601Durations;\n  const relativeToPrevious = defaultValue(options.relativeToPrevious, false);\n  const julianDates = [];\n  let date, previousDate;\n  const length = iso8601Durations.length;\n  for (let i = 0; i < length; ++i) {\n    // Allow a duration of 0 on the first iteration, because then it is just the epoch\n    if (parseDuration(iso8601Durations[i], scratchDuration) || i === 0) {\n      if (relativeToPrevious && defined(previousDate)) {\n        date = addToDate(previousDate, scratchDuration);\n      } else {\n        date = addToDate(epoch, scratchDuration);\n      }\n      julianDates.push(date);\n      previousDate = date;\n    }\n  }\n  return TimeIntervalCollection.fromJulianDateArray({\n    julianDates: julianDates,\n    isStartIncluded: options.isStartIncluded,\n    isStopIncluded: options.isStopIncluded,\n    leadingInterval: options.leadingInterval,\n    trailingInterval: options.trailingInterval,\n    dataCallback: options.dataCallback\n  }, result);\n};\nexport default TimeIntervalCollection;","map":{"version":3,"names":["binarySearch","defaultValue","defined","DeveloperError","Event","GregorianDate","isLeapYear","Iso8601","JulianDate","TimeInterval","compareIntervalStartTimes","left","right","compare","start","TimeIntervalCollection","intervals","_intervals","_changedEvent","length","i","addInterval","Object","defineProperties","prototype","changedEvent","get","undefined","isStartIncluded","stop","isStopIncluded","isEmpty","equals","dataComparer","rightIntervals","index","removeAll","raiseEvent","findIntervalContainingDate","date","indexOf","findDataForIntervalContainingDate","data","contains","julianDate","indexOfScratch","findInterval","options","EMPTY_OBJECT","len","interval","greaterThan","push","comparison","splice","removeInterval","result","intersect","other","mergeCallback","otherIntervals","leftInterval","rightInterval","lessThan","intersection","fromJulianDateArray","julianDates","dataCallback","leadingInterval","trailingInterval","startIndex","MINIMUM_VALUE","startDate","endDate","MAXIMUM_VALUE","scratchGregorianDate","monthLengths","addToDate","duration","toGregorianDate","millisecond","second","minute","hour","day","month","year","Math","floor","fromGregorianDate","scratchJulianDate","durationRegex","parseDuration","iso8601","matches","match","Number","replace","seconds","fromIso8601","scratchDuration","dates","split","clone","afterStop","fromIso8601DateArray","iso8601Dates","map","fromIso8601DurationArray","epoch","iso8601Durations","relativeToPrevious","previousDate"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/TimeIntervalCollection.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport Iso8601 from \"./Iso8601.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport TimeInterval from \"./TimeInterval.js\";\n\nfunction compareIntervalStartTimes(left, right) {\n  return JulianDate.compare(left.start, right.start);\n}\n\n/**\n * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.\n * @alias TimeIntervalCollection\n * @constructor\n *\n * @param {TimeInterval[]} [intervals] An array of intervals to add to the collection.\n */\nfunction TimeIntervalCollection(intervals) {\n  this._intervals = [];\n  this._changedEvent = new Event();\n\n  if (defined(intervals)) {\n    const length = intervals.length;\n    for (let i = 0; i < length; i++) {\n      this.addInterval(intervals[i]);\n    }\n  }\n}\n\nObject.defineProperties(TimeIntervalCollection.prototype, {\n  /**\n   * Gets an event that is raised whenever the collection of intervals change.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changedEvent: {\n    get: function () {\n      return this._changedEvent;\n    },\n  },\n\n  /**\n   * Gets the start time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      const intervals = this._intervals;\n      return intervals.length === 0 ? undefined : intervals[0].start;\n    },\n  },\n\n  /**\n   * Gets whether or not the start time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isStartIncluded: {\n    get: function () {\n      const intervals = this._intervals;\n      return intervals.length === 0 ? false : intervals[0].isStartIncluded;\n    },\n  },\n\n  /**\n   * Gets the stop time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  stop: {\n    get: function () {\n      const intervals = this._intervals;\n      const length = intervals.length;\n      return length === 0 ? undefined : intervals[length - 1].stop;\n    },\n  },\n\n  /**\n   * Gets whether or not the stop time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isStopIncluded: {\n    get: function () {\n      const intervals = this._intervals;\n      const length = intervals.length;\n      return length === 0 ? false : intervals[length - 1].isStopIncluded;\n    },\n  },\n\n  /**\n   * Gets the number of intervals in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._intervals.length;\n    },\n  },\n\n  /**\n   * Gets whether or not the collection is empty.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      return this._intervals.length === 0;\n    },\n  },\n});\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeIntervalCollection} [right] The right hand side collection.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.equals = function (right, dataComparer) {\n  if (this === right) {\n    return true;\n  }\n  if (!(right instanceof TimeIntervalCollection)) {\n    return false;\n  }\n  const intervals = this._intervals;\n  const rightIntervals = right._intervals;\n  const length = intervals.length;\n  if (length !== rightIntervals.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (!TimeInterval.equals(intervals[i], rightIntervals[i], dataComparer)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Gets the interval at the specified index.\n *\n * @param {number} index The index of the interval to retrieve.\n * @returns {TimeInterval|undefined} The interval at the specified index, or <code>undefined</code> if no interval exists as that index.\n */\nTimeIntervalCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._intervals[index];\n};\n\n/**\n * Removes all intervals from the collection.\n */\nTimeIntervalCollection.prototype.removeAll = function () {\n  if (this._intervals.length > 0) {\n    this._intervals.length = 0;\n    this._changedEvent.raiseEvent(this);\n  }\n};\n\n/**\n * Finds and returns the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {TimeInterval|undefined} The interval containing the specified date, <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findIntervalContainingDate = function (date) {\n  const index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index] : undefined;\n};\n\n/**\n * Finds and returns the data for the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {object} The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findDataForIntervalContainingDate = function (\n  date,\n) {\n  const index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index].data : undefined;\n};\n\n/**\n * Checks if the specified date is inside this collection.\n *\n * @param {JulianDate} julianDate The date to check.\n * @returns {boolean} <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.contains = function (julianDate) {\n  return this.indexOf(julianDate) >= 0;\n};\n\nconst indexOfScratch = new TimeInterval();\n\n/**\n * Finds and returns the index of the interval in the collection that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {number} The index of the interval that contains the specified date, if no such interval exists,\n * it returns a negative number which is the bitwise complement of the index of the next interval that\n * starts after the date, or if no interval starts after the specified date, the bitwise complement of\n * the length of the collection.\n */\nTimeIntervalCollection.prototype.indexOf = function (date) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required\");\n  }\n  //>>includeEnd('debug');\n\n  const intervals = this._intervals;\n  indexOfScratch.start = date;\n  indexOfScratch.stop = date;\n  let index = binarySearch(\n    intervals,\n    indexOfScratch,\n    compareIntervalStartTimes,\n  );\n  if (index >= 0) {\n    if (intervals[index].isStartIncluded) {\n      return index;\n    }\n\n    if (\n      index > 0 &&\n      intervals[index - 1].stop.equals(date) &&\n      intervals[index - 1].isStopIncluded\n    ) {\n      return index - 1;\n    }\n    return ~index;\n  }\n\n  index = ~index;\n  if (\n    index > 0 &&\n    index - 1 < intervals.length &&\n    TimeInterval.contains(intervals[index - 1], date)\n  ) {\n    return index - 1;\n  }\n  return ~index;\n};\n\n/**\n * Returns the first interval in the collection that matches the specified parameters.\n * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.start] The start time of the interval.\n * @param {JulianDate} [options.stop] The stop time of the interval.\n * @param {boolean} [options.isStartIncluded] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @returns {TimeInterval|undefined} The first interval in the collection that matches the specified parameters.\n */\nTimeIntervalCollection.prototype.findInterval = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const start = options.start;\n  const stop = options.stop;\n  const isStartIncluded = options.isStartIncluded;\n  const isStopIncluded = options.isStopIncluded;\n\n  const intervals = this._intervals;\n  for (let i = 0, len = intervals.length; i < len; i++) {\n    const interval = intervals[i];\n    if (\n      (!defined(start) || interval.start.equals(start)) &&\n      (!defined(stop) || interval.stop.equals(stop)) &&\n      (!defined(isStartIncluded) ||\n        interval.isStartIncluded === isStartIncluded) &&\n      (!defined(isStopIncluded) || interval.isStopIncluded === isStopIncluded)\n    ) {\n      return intervals[i];\n    }\n  }\n  return undefined;\n};\n\n/**\n * Adds an interval to the collection, merging intervals that contain the same data and\n * splitting intervals of different data as needed in order to maintain a non-overlapping collection.\n * The data in the new interval takes precedence over any existing intervals in the collection.\n *\n * @param {TimeInterval} interval The interval to add.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n */\nTimeIntervalCollection.prototype.addInterval = function (\n  interval,\n  dataComparer,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(interval)) {\n    throw new DeveloperError(\"interval is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (interval.isEmpty) {\n    return;\n  }\n\n  const intervals = this._intervals;\n\n  // Handle the common case quickly: we're adding a new interval which is after all existing intervals.\n  if (\n    intervals.length === 0 ||\n    JulianDate.greaterThan(interval.start, intervals[intervals.length - 1].stop)\n  ) {\n    intervals.push(interval);\n    this._changedEvent.raiseEvent(this);\n    return;\n  }\n\n  // Keep the list sorted by the start date\n  let index = binarySearch(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  } else {\n    // interval's start date exactly equals the start date of at least one interval in the collection.\n    // It could actually equal the start date of two intervals if one of them does not actually\n    // include the date.  In that case, the binary search could have found either.  We need to\n    // look at the surrounding intervals and their IsStartIncluded properties in order to make sure\n    // we're working with the correct interval.\n\n    // eslint-disable-next-line no-lonely-if\n    if (\n      index > 0 &&\n      interval.isStartIncluded &&\n      intervals[index - 1].isStartIncluded &&\n      intervals[index - 1].start.equals(interval.start)\n    ) {\n      --index;\n    } else if (\n      index < intervals.length &&\n      !interval.isStartIncluded &&\n      intervals[index].isStartIncluded &&\n      intervals[index].start.equals(interval.start)\n    ) {\n      ++index;\n    }\n  }\n\n  let comparison;\n  if (index > 0) {\n    // Not the first thing in the list, so see if the interval before this one\n    // overlaps this one.\n\n    comparison = JulianDate.compare(intervals[index - 1].stop, interval.start);\n    if (\n      comparison > 0 ||\n      (comparison === 0 &&\n        (intervals[index - 1].isStopIncluded || interval.isStartIncluded))\n    ) {\n      // There is an overlap\n      if (\n        defined(dataComparer)\n          ? dataComparer(intervals[index - 1].data, interval.data)\n          : intervals[index - 1].data === interval.data\n      ) {\n        // Overlapping intervals have the same data, so combine them\n        if (JulianDate.greaterThan(interval.stop, intervals[index - 1].stop)) {\n          interval = new TimeInterval({\n            start: intervals[index - 1].start,\n            stop: interval.stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded: interval.isStopIncluded,\n            data: interval.data,\n          });\n        } else {\n          interval = new TimeInterval({\n            start: intervals[index - 1].start,\n            stop: intervals[index - 1].stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded:\n              intervals[index - 1].isStopIncluded ||\n              (interval.stop.equals(intervals[index - 1].stop) &&\n                interval.isStopIncluded),\n            data: interval.data,\n          });\n        }\n        intervals.splice(index - 1, 1);\n        --index;\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added 'wins' so truncate the previous interval.\n        // If the existing interval extends past the end of the new one,\n        // split the existing interval into two intervals.\n        comparison = JulianDate.compare(\n          intervals[index - 1].stop,\n          interval.stop,\n        );\n        if (\n          comparison > 0 ||\n          (comparison === 0 &&\n            intervals[index - 1].isStopIncluded &&\n            !interval.isStopIncluded)\n        ) {\n          intervals.splice(\n            index,\n            0,\n            new TimeInterval({\n              start: interval.stop,\n              stop: intervals[index - 1].stop,\n              isStartIncluded: !interval.isStopIncluded,\n              isStopIncluded: intervals[index - 1].isStopIncluded,\n              data: intervals[index - 1].data,\n            }),\n          );\n        }\n        intervals[index - 1] = new TimeInterval({\n          start: intervals[index - 1].start,\n          stop: interval.start,\n          isStartIncluded: intervals[index - 1].isStartIncluded,\n          isStopIncluded: !interval.isStartIncluded,\n          data: intervals[index - 1].data,\n        });\n      }\n    }\n  }\n\n  while (index < intervals.length) {\n    // Not the last thing in the list, so see if the intervals after this one overlap this one.\n    comparison = JulianDate.compare(interval.stop, intervals[index].start);\n    if (\n      comparison > 0 ||\n      (comparison === 0 &&\n        (interval.isStopIncluded || intervals[index].isStartIncluded))\n    ) {\n      // There is an overlap\n      if (\n        defined(dataComparer)\n          ? dataComparer(intervals[index].data, interval.data)\n          : intervals[index].data === interval.data\n      ) {\n        // Overlapping intervals have the same data, so combine them\n        interval = new TimeInterval({\n          start: interval.start,\n          stop: JulianDate.greaterThan(intervals[index].stop, interval.stop)\n            ? intervals[index].stop\n            : interval.stop,\n          isStartIncluded: interval.isStartIncluded,\n          isStopIncluded: JulianDate.greaterThan(\n            intervals[index].stop,\n            interval.stop,\n          )\n            ? intervals[index].isStopIncluded\n            : interval.isStopIncluded,\n          data: interval.data,\n        });\n        intervals.splice(index, 1);\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added 'wins' so truncate the next interval.\n        intervals[index] = new TimeInterval({\n          start: interval.stop,\n          stop: intervals[index].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data,\n        });\n\n        if (intervals[index].isEmpty) {\n          intervals.splice(index, 1);\n        } else {\n          // Found a partial span, so it is not possible for the next\n          // interval to be spanned at all.  Stop looking.\n          break;\n        }\n      }\n    } else {\n      // Found the last one we're spanning, so stop looking.\n      break;\n    }\n  }\n\n  // Add the new interval\n  intervals.splice(index, 0, interval);\n  this._changedEvent.raiseEvent(this);\n};\n\n/**\n * Removes the specified interval from this interval collection, creating a hole over the specified interval.\n * The data property of the input interval is ignored.\n *\n * @param {TimeInterval} interval The interval to remove.\n * @returns {boolean} <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.\n */\nTimeIntervalCollection.prototype.removeInterval = function (interval) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(interval)) {\n    throw new DeveloperError(\"interval is required\");\n  }\n  //>>includeEnd('debug');\n\n  if (interval.isEmpty) {\n    return false;\n  }\n\n  const intervals = this._intervals;\n\n  let index = binarySearch(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  }\n\n  let result = false;\n\n  // Check for truncation of the end of the previous interval.\n  if (\n    index > 0 &&\n    (JulianDate.greaterThan(intervals[index - 1].stop, interval.start) ||\n      (intervals[index - 1].stop.equals(interval.start) &&\n        intervals[index - 1].isStopIncluded &&\n        interval.isStartIncluded))\n  ) {\n    result = true;\n\n    if (\n      JulianDate.greaterThan(intervals[index - 1].stop, interval.stop) ||\n      (intervals[index - 1].isStopIncluded &&\n        !interval.isStopIncluded &&\n        intervals[index - 1].stop.equals(interval.stop))\n    ) {\n      // Break the existing interval into two pieces\n      intervals.splice(\n        index,\n        0,\n        new TimeInterval({\n          start: interval.stop,\n          stop: intervals[index - 1].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index - 1].isStopIncluded,\n          data: intervals[index - 1].data,\n        }),\n      );\n    }\n    intervals[index - 1] = new TimeInterval({\n      start: intervals[index - 1].start,\n      stop: interval.start,\n      isStartIncluded: intervals[index - 1].isStartIncluded,\n      isStopIncluded: !interval.isStartIncluded,\n      data: intervals[index - 1].data,\n    });\n  }\n\n  // Check if the Start of the current interval should remain because interval.start is the same but\n  // it is not included.\n  if (\n    index < intervals.length &&\n    !interval.isStartIncluded &&\n    intervals[index].isStartIncluded &&\n    interval.start.equals(intervals[index].start)\n  ) {\n    result = true;\n\n    intervals.splice(\n      index,\n      0,\n      new TimeInterval({\n        start: intervals[index].start,\n        stop: intervals[index].start,\n        isStartIncluded: true,\n        isStopIncluded: true,\n        data: intervals[index].data,\n      }),\n    );\n    ++index;\n  }\n\n  // Remove any intervals that are completely overlapped by the input interval.\n  while (\n    index < intervals.length &&\n    JulianDate.greaterThan(interval.stop, intervals[index].stop)\n  ) {\n    result = true;\n    intervals.splice(index, 1);\n  }\n\n  // Check for the case where the input interval ends on the same date\n  // as an existing interval.\n  if (index < intervals.length && interval.stop.equals(intervals[index].stop)) {\n    result = true;\n\n    if (!interval.isStopIncluded && intervals[index].isStopIncluded) {\n      // Last point of interval should remain because the stop date is included in\n      // the existing interval but is not included in the input interval.\n      if (\n        index + 1 < intervals.length &&\n        intervals[index + 1].start.equals(interval.stop) &&\n        intervals[index].data === intervals[index + 1].data\n      ) {\n        // Combine single point with the next interval\n        intervals.splice(index, 1);\n        intervals[index] = new TimeInterval({\n          start: intervals[index].start,\n          stop: intervals[index].stop,\n          isStartIncluded: true,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data,\n        });\n      } else {\n        intervals[index] = new TimeInterval({\n          start: interval.stop,\n          stop: interval.stop,\n          isStartIncluded: true,\n          isStopIncluded: true,\n          data: intervals[index].data,\n        });\n      }\n    } else {\n      // Interval is completely overlapped\n      intervals.splice(index, 1);\n    }\n  }\n\n  // Truncate any partially-overlapped intervals.\n  if (\n    index < intervals.length &&\n    (JulianDate.greaterThan(interval.stop, intervals[index].start) ||\n      (interval.stop.equals(intervals[index].start) &&\n        interval.isStopIncluded &&\n        intervals[index].isStartIncluded))\n  ) {\n    result = true;\n    intervals[index] = new TimeInterval({\n      start: interval.stop,\n      stop: intervals[index].stop,\n      isStartIncluded: !interval.isStopIncluded,\n      isStopIncluded: intervals[index].isStopIncluded,\n      data: intervals[index].data,\n    });\n  }\n\n  if (result) {\n    this._changedEvent.raiseEvent(this);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that is the intersection of this collection and the provided collection.\n *\n * @param {TimeIntervalCollection} other The collection to intersect with.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeIntervalCollection} A new TimeIntervalCollection which is the intersection of this collection and the provided collection.\n */\nTimeIntervalCollection.prototype.intersect = function (\n  other,\n  dataComparer,\n  mergeCallback,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(other)) {\n    throw new DeveloperError(\"other is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const result = new TimeIntervalCollection();\n  let left = 0;\n  let right = 0;\n  const intervals = this._intervals;\n  const otherIntervals = other._intervals;\n\n  while (left < intervals.length && right < otherIntervals.length) {\n    const leftInterval = intervals[left];\n    const rightInterval = otherIntervals[right];\n    if (JulianDate.lessThan(leftInterval.stop, rightInterval.start)) {\n      ++left;\n    } else if (JulianDate.lessThan(rightInterval.stop, leftInterval.start)) {\n      ++right;\n    } else {\n      // The following will return an intersection whose data is 'merged' if the callback is defined\n      if (\n        defined(mergeCallback) ||\n        (defined(dataComparer) &&\n          dataComparer(leftInterval.data, rightInterval.data)) ||\n        (!defined(dataComparer) && rightInterval.data === leftInterval.data)\n      ) {\n        const intersection = TimeInterval.intersect(\n          leftInterval,\n          rightInterval,\n          new TimeInterval(),\n          mergeCallback,\n        );\n        if (!intersection.isEmpty) {\n          // Since we start with an empty collection for 'result', and there are no overlapping intervals in 'this' (as a rule),\n          // the 'intersection' will never overlap with a previous interval in 'result'.  So, no need to do any additional 'merging'.\n          result.addInterval(intersection, dataComparer);\n        }\n      }\n\n      if (\n        JulianDate.lessThan(leftInterval.stop, rightInterval.stop) ||\n        (leftInterval.stop.equals(rightInterval.stop) &&\n          !leftInterval.isStopIncluded &&\n          rightInterval.isStopIncluded)\n      ) {\n        ++left;\n      } else {\n        ++right;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Creates a new instance from a JulianDate array.\n *\n * @param {object} options Object with the following properties:\n * @param {JulianDate[]} options.julianDates An array of ISO 8601 dates.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromJulianDateArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.julianDates)) {\n    throw new DeveloperError(\"options.iso8601Array is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new TimeIntervalCollection();\n  }\n\n  const julianDates = options.julianDates;\n  const length = julianDates.length;\n  const dataCallback = options.dataCallback;\n\n  const isStartIncluded = defaultValue(options.isStartIncluded, true);\n  const isStopIncluded = defaultValue(options.isStopIncluded, true);\n  const leadingInterval = defaultValue(options.leadingInterval, false);\n  const trailingInterval = defaultValue(options.trailingInterval, false);\n  let interval;\n\n  // Add a default interval, which will only end up being used up to first interval\n  let startIndex = 0;\n  if (leadingInterval) {\n    ++startIndex;\n    interval = new TimeInterval({\n      start: Iso8601.MINIMUM_VALUE,\n      stop: julianDates[0],\n      isStartIncluded: true,\n      isStopIncluded: !isStartIncluded,\n    });\n    interval.data = defined(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n  }\n\n  for (let i = 0; i < length - 1; ++i) {\n    let startDate = julianDates[i];\n    const endDate = julianDates[i + 1];\n\n    interval = new TimeInterval({\n      start: startDate,\n      stop: endDate,\n      isStartIncluded: result.length === startIndex ? isStartIncluded : true,\n      isStopIncluded: i === length - 2 ? isStopIncluded : false,\n    });\n    interval.data = defined(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n\n    startDate = endDate;\n  }\n\n  if (trailingInterval) {\n    interval = new TimeInterval({\n      start: julianDates[length - 1],\n      stop: Iso8601.MAXIMUM_VALUE,\n      isStartIncluded: !isStopIncluded,\n      isStopIncluded: true,\n    });\n    interval.data = defined(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n  }\n\n  return result;\n};\n\nconst scratchGregorianDate = new GregorianDate();\nconst monthLengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * Adds duration represented as a GregorianDate to a JulianDate\n *\n * @param {JulianDate} julianDate The date.\n * @param {GregorianDate} duration An duration represented as a GregorianDate.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n *\n * @private\n */\nfunction addToDate(julianDate, duration, result) {\n  if (!defined(result)) {\n    result = new JulianDate();\n  }\n  JulianDate.toGregorianDate(julianDate, scratchGregorianDate);\n\n  let millisecond = scratchGregorianDate.millisecond + duration.millisecond;\n  let second = scratchGregorianDate.second + duration.second;\n  let minute = scratchGregorianDate.minute + duration.minute;\n  let hour = scratchGregorianDate.hour + duration.hour;\n  let day = scratchGregorianDate.day + duration.day;\n  let month = scratchGregorianDate.month + duration.month;\n  let year = scratchGregorianDate.year + duration.year;\n\n  if (millisecond >= 1000) {\n    second += Math.floor(millisecond / 1000);\n    millisecond = millisecond % 1000;\n  }\n\n  if (second >= 60) {\n    minute += Math.floor(second / 60);\n    second = second % 60;\n  }\n\n  if (minute >= 60) {\n    hour += Math.floor(minute / 60);\n    minute = minute % 60;\n  }\n\n  if (hour >= 24) {\n    day += Math.floor(hour / 24);\n    hour = hour % 24;\n  }\n\n  // If days is greater than the month's length we need to remove those number of days,\n  //  readjust month and year and repeat until days is less than the month's length.\n  monthLengths[2] = isLeapYear(year) ? 29 : 28;\n  while (day > monthLengths[month] || month >= 13) {\n    if (day > monthLengths[month]) {\n      day -= monthLengths[month];\n      ++month;\n    }\n\n    if (month >= 13) {\n      --month;\n      year += Math.floor(month / 12);\n      month = month % 12;\n      ++month;\n    }\n\n    monthLengths[2] = isLeapYear(year) ? 29 : 28;\n  }\n\n  scratchGregorianDate.millisecond = millisecond;\n  scratchGregorianDate.second = second;\n  scratchGregorianDate.minute = minute;\n  scratchGregorianDate.hour = hour;\n  scratchGregorianDate.day = day;\n  scratchGregorianDate.month = month;\n  scratchGregorianDate.year = year;\n\n  return JulianDate.fromGregorianDate(scratchGregorianDate, result);\n}\n\nconst scratchJulianDate = new JulianDate();\nconst durationRegex =\n  /P(?:([\\d.,]+)Y)?(?:([\\d.,]+)M)?(?:([\\d.,]+)W)?(?:([\\d.,]+)D)?(?:T(?:([\\d.,]+)H)?(?:([\\d.,]+)M)?(?:([\\d.,]+)S)?)?/;\n\n/**\n * Parses ISO8601 duration string\n *\n * @param {string} iso8601 An ISO 8601 duration.\n * @param {GregorianDate} result An existing instance to use for the result.\n * @returns {boolean} True is parsing succeeded, false otherwise\n *\n * @private\n */\nfunction parseDuration(iso8601, result) {\n  if (!defined(iso8601) || iso8601.length === 0) {\n    return false;\n  }\n\n  // Reset object\n  result.year = 0;\n  result.month = 0;\n  result.day = 0;\n  result.hour = 0;\n  result.minute = 0;\n  result.second = 0;\n  result.millisecond = 0;\n\n  if (iso8601[0] === \"P\") {\n    const matches = iso8601.match(durationRegex);\n    if (!defined(matches)) {\n      return false;\n    }\n    if (defined(matches[1])) {\n      // Years\n      result.year = Number(matches[1].replace(\",\", \".\"));\n    }\n    if (defined(matches[2])) {\n      // Months\n      result.month = Number(matches[2].replace(\",\", \".\"));\n    }\n    if (defined(matches[3])) {\n      // Weeks\n      result.day = Number(matches[3].replace(\",\", \".\")) * 7;\n    }\n    if (defined(matches[4])) {\n      // Days\n      result.day += Number(matches[4].replace(\",\", \".\"));\n    }\n    if (defined(matches[5])) {\n      // Hours\n      result.hour = Number(matches[5].replace(\",\", \".\"));\n    }\n    if (defined(matches[6])) {\n      // Weeks\n      result.minute = Number(matches[6].replace(\",\", \".\"));\n    }\n    if (defined(matches[7])) {\n      // Seconds\n      const seconds = Number(matches[7].replace(\",\", \".\"));\n      result.second = Math.floor(seconds);\n      result.millisecond = (seconds % 1) * 1000;\n    }\n  } else {\n    // They can technically specify the duration as a normal date with some caveats. Try our best to load it.\n    if (iso8601[iso8601.length - 1] !== \"Z\") {\n      // It's not a date, its a duration, so it always has to be UTC\n      iso8601 += \"Z\";\n    }\n    JulianDate.toGregorianDate(\n      JulianDate.fromIso8601(iso8601, scratchJulianDate),\n      result,\n    );\n  }\n\n  // A duration of 0 will cause an infinite loop, so just make sure something is non-zero\n  return (\n    result.year ||\n    result.month ||\n    result.day ||\n    result.hour ||\n    result.minute ||\n    result.second ||\n    result.millisecond\n  );\n}\n\nconst scratchDuration = new GregorianDate();\n/**\n * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.iso8601 An ISO 8601 interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.iso8601)) {\n    throw new DeveloperError(\"options.iso8601 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dates = options.iso8601.split(\"/\");\n  const start = JulianDate.fromIso8601(dates[0]);\n  const stop = JulianDate.fromIso8601(dates[1]);\n  const julianDates = [];\n\n  if (!parseDuration(dates[2], scratchDuration)) {\n    julianDates.push(start, stop);\n  } else {\n    let date = JulianDate.clone(start);\n    julianDates.push(date);\n    while (JulianDate.compare(date, stop) < 0) {\n      date = addToDate(date, scratchDuration);\n      const afterStop = JulianDate.compare(stop, date) <= 0;\n      if (afterStop) {\n        JulianDate.clone(stop, date);\n      }\n\n      julianDates.push(date);\n    }\n  }\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: julianDates,\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result,\n  );\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.\n *\n * @param {object} options Object with the following properties:\n * @param {string[]} options.iso8601Dates An array of ISO 8601 dates.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DateArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.iso8601Dates)) {\n    throw new DeveloperError(\"options.iso8601Dates is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: options.iso8601Dates.map(function (date) {\n        return JulianDate.fromIso8601(date);\n      }),\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result,\n  );\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.\n *\n * @param {object} options Object with the following properties:\n * @param {JulianDate} options.epoch An date that the durations are relative to.\n * @param {string} options.iso8601Durations An array of ISO 8601 durations.\n * @param {boolean} [options.relativeToPrevious=false] <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DurationArray = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.epoch)) {\n    throw new DeveloperError(\"options.epoch is required.\");\n  }\n  if (!defined(options.iso8601Durations)) {\n    throw new DeveloperError(\"options.iso8601Durations is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const epoch = options.epoch;\n  const iso8601Durations = options.iso8601Durations;\n  const relativeToPrevious = defaultValue(options.relativeToPrevious, false);\n  const julianDates = [];\n  let date, previousDate;\n\n  const length = iso8601Durations.length;\n  for (let i = 0; i < length; ++i) {\n    // Allow a duration of 0 on the first iteration, because then it is just the epoch\n    if (parseDuration(iso8601Durations[i], scratchDuration) || i === 0) {\n      if (relativeToPrevious && defined(previousDate)) {\n        date = addToDate(previousDate, scratchDuration);\n      } else {\n        date = addToDate(epoch, scratchDuration);\n      }\n      julianDates.push(date);\n      previousDate = date;\n    }\n  }\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: julianDates,\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result,\n  );\n};\nexport default TimeIntervalCollection;\n"],"mappings":"AAAA,OAAOA,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,YAAY,MAAM,mBAAmB;AAE5C,SAASC,yBAAyBA,CAACC,IAAI,EAAEC,KAAK,EAAE;EAC9C,OAAOJ,UAAU,CAACK,OAAO,CAACF,IAAI,CAACG,KAAK,EAAEF,KAAK,CAACE,KAAK,CAAC;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,sBAAsBA,CAACC,SAAS,EAAE;EACzC,IAAI,CAACC,UAAU,GAAG,EAAE;EACpB,IAAI,CAACC,aAAa,GAAG,IAAId,KAAK,CAAC,CAAC;EAEhC,IAAIF,OAAO,CAACc,SAAS,CAAC,EAAE;IACtB,MAAMG,MAAM,GAAGH,SAAS,CAACG,MAAM;IAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,IAAI,CAACC,WAAW,CAACL,SAAS,CAACI,CAAC,CAAC,CAAC;IAChC;EACF;AACF;AAEAE,MAAM,CAACC,gBAAgB,CAACR,sBAAsB,CAACS,SAAS,EAAE;EACxD;AACF;AACA;AACA;AACA;AACA;EACEC,YAAY,EAAE;IACZC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACR,aAAa;IAC3B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEJ,KAAK,EAAE;IACLY,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMV,SAAS,GAAG,IAAI,CAACC,UAAU;MACjC,OAAOD,SAAS,CAACG,MAAM,KAAK,CAAC,GAAGQ,SAAS,GAAGX,SAAS,CAAC,CAAC,CAAC,CAACF,KAAK;IAChE;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEc,eAAe,EAAE;IACfF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMV,SAAS,GAAG,IAAI,CAACC,UAAU;MACjC,OAAOD,SAAS,CAACG,MAAM,KAAK,CAAC,GAAG,KAAK,GAAGH,SAAS,CAAC,CAAC,CAAC,CAACY,eAAe;IACtE;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE;IACJH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMV,SAAS,GAAG,IAAI,CAACC,UAAU;MACjC,MAAME,MAAM,GAAGH,SAAS,CAACG,MAAM;MAC/B,OAAOA,MAAM,KAAK,CAAC,GAAGQ,SAAS,GAAGX,SAAS,CAACG,MAAM,GAAG,CAAC,CAAC,CAACU,IAAI;IAC9D;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEC,cAAc,EAAE;IACdJ,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMV,SAAS,GAAG,IAAI,CAACC,UAAU;MACjC,MAAME,MAAM,GAAGH,SAAS,CAACG,MAAM;MAC/B,OAAOA,MAAM,KAAK,CAAC,GAAG,KAAK,GAAGH,SAAS,CAACG,MAAM,GAAG,CAAC,CAAC,CAACW,cAAc;IACpE;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEX,MAAM,EAAE;IACNO,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,UAAU,CAACE,MAAM;IAC/B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEY,OAAO,EAAE;IACPL,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,UAAU,CAACE,MAAM,KAAK,CAAC;IACrC;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,sBAAsB,CAACS,SAAS,CAACQ,MAAM,GAAG,UAAUpB,KAAK,EAAEqB,YAAY,EAAE;EACvE,IAAI,IAAI,KAAKrB,KAAK,EAAE;IAClB,OAAO,IAAI;EACb;EACA,IAAI,EAAEA,KAAK,YAAYG,sBAAsB,CAAC,EAAE;IAC9C,OAAO,KAAK;EACd;EACA,MAAMC,SAAS,GAAG,IAAI,CAACC,UAAU;EACjC,MAAMiB,cAAc,GAAGtB,KAAK,CAACK,UAAU;EACvC,MAAME,MAAM,GAAGH,SAAS,CAACG,MAAM;EAC/B,IAAIA,MAAM,KAAKe,cAAc,CAACf,MAAM,EAAE;IACpC,OAAO,KAAK;EACd;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;IAC/B,IAAI,CAACX,YAAY,CAACuB,MAAM,CAAChB,SAAS,CAACI,CAAC,CAAC,EAAEc,cAAc,CAACd,CAAC,CAAC,EAAEa,YAAY,CAAC,EAAE;MACvE,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAlB,sBAAsB,CAACS,SAAS,CAACE,GAAG,GAAG,UAAUS,KAAK,EAAE;EACtD;EACA,IAAI,CAACjC,OAAO,CAACiC,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIhC,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA,OAAO,IAAI,CAACc,UAAU,CAACkB,KAAK,CAAC;AAC/B,CAAC;;AAED;AACA;AACA;AACApB,sBAAsB,CAACS,SAAS,CAACY,SAAS,GAAG,YAAY;EACvD,IAAI,IAAI,CAACnB,UAAU,CAACE,MAAM,GAAG,CAAC,EAAE;IAC9B,IAAI,CAACF,UAAU,CAACE,MAAM,GAAG,CAAC;IAC1B,IAAI,CAACD,aAAa,CAACmB,UAAU,CAAC,IAAI,CAAC;EACrC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAtB,sBAAsB,CAACS,SAAS,CAACc,0BAA0B,GAAG,UAAUC,IAAI,EAAE;EAC5E,MAAMJ,KAAK,GAAG,IAAI,CAACK,OAAO,CAACD,IAAI,CAAC;EAChC,OAAOJ,KAAK,IAAI,CAAC,GAAG,IAAI,CAAClB,UAAU,CAACkB,KAAK,CAAC,GAAGR,SAAS;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAZ,sBAAsB,CAACS,SAAS,CAACiB,iCAAiC,GAAG,UACnEF,IAAI,EACJ;EACA,MAAMJ,KAAK,GAAG,IAAI,CAACK,OAAO,CAACD,IAAI,CAAC;EAChC,OAAOJ,KAAK,IAAI,CAAC,GAAG,IAAI,CAAClB,UAAU,CAACkB,KAAK,CAAC,CAACO,IAAI,GAAGf,SAAS;AAC7D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAZ,sBAAsB,CAACS,SAAS,CAACmB,QAAQ,GAAG,UAAUC,UAAU,EAAE;EAChE,OAAO,IAAI,CAACJ,OAAO,CAACI,UAAU,CAAC,IAAI,CAAC;AACtC,CAAC;AAED,MAAMC,cAAc,GAAG,IAAIpC,YAAY,CAAC,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAM,sBAAsB,CAACS,SAAS,CAACgB,OAAO,GAAG,UAAUD,IAAI,EAAE;EACzD;EACA,IAAI,CAACrC,OAAO,CAACqC,IAAI,CAAC,EAAE;IAClB,MAAM,IAAIpC,cAAc,CAAC,kBAAkB,CAAC;EAC9C;EACA;;EAEA,MAAMa,SAAS,GAAG,IAAI,CAACC,UAAU;EACjC4B,cAAc,CAAC/B,KAAK,GAAGyB,IAAI;EAC3BM,cAAc,CAAChB,IAAI,GAAGU,IAAI;EAC1B,IAAIJ,KAAK,GAAGnC,YAAY,CACtBgB,SAAS,EACT6B,cAAc,EACdnC,yBACF,CAAC;EACD,IAAIyB,KAAK,IAAI,CAAC,EAAE;IACd,IAAInB,SAAS,CAACmB,KAAK,CAAC,CAACP,eAAe,EAAE;MACpC,OAAOO,KAAK;IACd;IAEA,IACEA,KAAK,GAAG,CAAC,IACTnB,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,CAACG,MAAM,CAACO,IAAI,CAAC,IACtCvB,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc,EACnC;MACA,OAAOK,KAAK,GAAG,CAAC;IAClB;IACA,OAAO,CAACA,KAAK;EACf;EAEAA,KAAK,GAAG,CAACA,KAAK;EACd,IACEA,KAAK,GAAG,CAAC,IACTA,KAAK,GAAG,CAAC,GAAGnB,SAAS,CAACG,MAAM,IAC5BV,YAAY,CAACkC,QAAQ,CAAC3B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,EAAEI,IAAI,CAAC,EACjD;IACA,OAAOJ,KAAK,GAAG,CAAC;EAClB;EACA,OAAO,CAACA,KAAK;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApB,sBAAsB,CAACS,SAAS,CAACsB,YAAY,GAAG,UAAUC,OAAO,EAAE;EACjEA,OAAO,GAAG9C,YAAY,CAAC8C,OAAO,EAAE9C,YAAY,CAAC+C,YAAY,CAAC;EAC1D,MAAMlC,KAAK,GAAGiC,OAAO,CAACjC,KAAK;EAC3B,MAAMe,IAAI,GAAGkB,OAAO,CAAClB,IAAI;EACzB,MAAMD,eAAe,GAAGmB,OAAO,CAACnB,eAAe;EAC/C,MAAME,cAAc,GAAGiB,OAAO,CAACjB,cAAc;EAE7C,MAAMd,SAAS,GAAG,IAAI,CAACC,UAAU;EACjC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAE6B,GAAG,GAAGjC,SAAS,CAACG,MAAM,EAAEC,CAAC,GAAG6B,GAAG,EAAE7B,CAAC,EAAE,EAAE;IACpD,MAAM8B,QAAQ,GAAGlC,SAAS,CAACI,CAAC,CAAC;IAC7B,IACE,CAAC,CAAClB,OAAO,CAACY,KAAK,CAAC,IAAIoC,QAAQ,CAACpC,KAAK,CAACkB,MAAM,CAAClB,KAAK,CAAC,MAC/C,CAACZ,OAAO,CAAC2B,IAAI,CAAC,IAAIqB,QAAQ,CAACrB,IAAI,CAACG,MAAM,CAACH,IAAI,CAAC,CAAC,KAC7C,CAAC3B,OAAO,CAAC0B,eAAe,CAAC,IACxBsB,QAAQ,CAACtB,eAAe,KAAKA,eAAe,CAAC,KAC9C,CAAC1B,OAAO,CAAC4B,cAAc,CAAC,IAAIoB,QAAQ,CAACpB,cAAc,KAAKA,cAAc,CAAC,EACxE;MACA,OAAOd,SAAS,CAACI,CAAC,CAAC;IACrB;EACF;EACA,OAAOO,SAAS;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,sBAAsB,CAACS,SAAS,CAACH,WAAW,GAAG,UAC7C6B,QAAQ,EACRjB,YAAY,EACZ;EACA;EACA,IAAI,CAAC/B,OAAO,CAACgD,QAAQ,CAAC,EAAE;IACtB,MAAM,IAAI/C,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA;;EAEA,IAAI+C,QAAQ,CAACnB,OAAO,EAAE;IACpB;EACF;EAEA,MAAMf,SAAS,GAAG,IAAI,CAACC,UAAU;;EAEjC;EACA,IACED,SAAS,CAACG,MAAM,KAAK,CAAC,IACtBX,UAAU,CAAC2C,WAAW,CAACD,QAAQ,CAACpC,KAAK,EAAEE,SAAS,CAACA,SAAS,CAACG,MAAM,GAAG,CAAC,CAAC,CAACU,IAAI,CAAC,EAC5E;IACAb,SAAS,CAACoC,IAAI,CAACF,QAAQ,CAAC;IACxB,IAAI,CAAChC,aAAa,CAACmB,UAAU,CAAC,IAAI,CAAC;IACnC;EACF;;EAEA;EACA,IAAIF,KAAK,GAAGnC,YAAY,CAACgB,SAAS,EAAEkC,QAAQ,EAAExC,yBAAyB,CAAC;EACxE,IAAIyB,KAAK,GAAG,CAAC,EAAE;IACbA,KAAK,GAAG,CAACA,KAAK;EAChB,CAAC,MAAM;IACL;IACA;IACA;IACA;IACA;;IAEA;IACA,IACEA,KAAK,GAAG,CAAC,IACTe,QAAQ,CAACtB,eAAe,IACxBZ,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACP,eAAe,IACpCZ,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACrB,KAAK,CAACkB,MAAM,CAACkB,QAAQ,CAACpC,KAAK,CAAC,EACjD;MACA,EAAEqB,KAAK;IACT,CAAC,MAAM,IACLA,KAAK,GAAGnB,SAAS,CAACG,MAAM,IACxB,CAAC+B,QAAQ,CAACtB,eAAe,IACzBZ,SAAS,CAACmB,KAAK,CAAC,CAACP,eAAe,IAChCZ,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK,CAACkB,MAAM,CAACkB,QAAQ,CAACpC,KAAK,CAAC,EAC7C;MACA,EAAEqB,KAAK;IACT;EACF;EAEA,IAAIkB,UAAU;EACd,IAAIlB,KAAK,GAAG,CAAC,EAAE;IACb;IACA;;IAEAkB,UAAU,GAAG7C,UAAU,CAACK,OAAO,CAACG,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,EAAEqB,QAAQ,CAACpC,KAAK,CAAC;IAC1E,IACEuC,UAAU,GAAG,CAAC,IACbA,UAAU,KAAK,CAAC,KACdrC,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc,IAAIoB,QAAQ,CAACtB,eAAe,CAAE,EACpE;MACA;MACA,IACE1B,OAAO,CAAC+B,YAAY,CAAC,GACjBA,YAAY,CAACjB,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO,IAAI,EAAEQ,QAAQ,CAACR,IAAI,CAAC,GACtD1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO,IAAI,KAAKQ,QAAQ,CAACR,IAAI,EAC/C;QACA;QACA,IAAIlC,UAAU,CAAC2C,WAAW,CAACD,QAAQ,CAACrB,IAAI,EAAEb,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,CAAC,EAAE;UACpEqB,QAAQ,GAAG,IAAIzC,YAAY,CAAC;YAC1BK,KAAK,EAAEE,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACrB,KAAK;YACjCe,IAAI,EAAEqB,QAAQ,CAACrB,IAAI;YACnBD,eAAe,EAAEZ,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACP,eAAe;YACrDE,cAAc,EAAEoB,QAAQ,CAACpB,cAAc;YACvCY,IAAI,EAAEQ,QAAQ,CAACR;UACjB,CAAC,CAAC;QACJ,CAAC,MAAM;UACLQ,QAAQ,GAAG,IAAIzC,YAAY,CAAC;YAC1BK,KAAK,EAAEE,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACrB,KAAK;YACjCe,IAAI,EAAEb,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI;YAC/BD,eAAe,EAAEZ,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACP,eAAe;YACrDE,cAAc,EACZd,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc,IAClCoB,QAAQ,CAACrB,IAAI,CAACG,MAAM,CAAChB,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,CAAC,IAC9CqB,QAAQ,CAACpB,cAAe;YAC5BY,IAAI,EAAEQ,QAAQ,CAACR;UACjB,CAAC,CAAC;QACJ;QACA1B,SAAS,CAACsC,MAAM,CAACnB,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC;QAC9B,EAAEA,KAAK;MACT,CAAC,MAAM;QACL;QACA;QACA;QACA;QACAkB,UAAU,GAAG7C,UAAU,CAACK,OAAO,CAC7BG,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,EACzBqB,QAAQ,CAACrB,IACX,CAAC;QACD,IACEwB,UAAU,GAAG,CAAC,IACbA,UAAU,KAAK,CAAC,IACfrC,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc,IACnC,CAACoB,QAAQ,CAACpB,cAAe,EAC3B;UACAd,SAAS,CAACsC,MAAM,CACdnB,KAAK,EACL,CAAC,EACD,IAAI1B,YAAY,CAAC;YACfK,KAAK,EAAEoC,QAAQ,CAACrB,IAAI;YACpBA,IAAI,EAAEb,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI;YAC/BD,eAAe,EAAE,CAACsB,QAAQ,CAACpB,cAAc;YACzCA,cAAc,EAAEd,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc;YACnDY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO;UAC7B,CAAC,CACH,CAAC;QACH;QACA1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI1B,YAAY,CAAC;UACtCK,KAAK,EAAEE,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACrB,KAAK;UACjCe,IAAI,EAAEqB,QAAQ,CAACpC,KAAK;UACpBc,eAAe,EAAEZ,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACP,eAAe;UACrDE,cAAc,EAAE,CAACoB,QAAQ,CAACtB,eAAe;UACzCc,IAAI,EAAE1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO;QAC7B,CAAC,CAAC;MACJ;IACF;EACF;EAEA,OAAOP,KAAK,GAAGnB,SAAS,CAACG,MAAM,EAAE;IAC/B;IACAkC,UAAU,GAAG7C,UAAU,CAACK,OAAO,CAACqC,QAAQ,CAACrB,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK,CAAC;IACtE,IACEuC,UAAU,GAAG,CAAC,IACbA,UAAU,KAAK,CAAC,KACdH,QAAQ,CAACpB,cAAc,IAAId,SAAS,CAACmB,KAAK,CAAC,CAACP,eAAe,CAAE,EAChE;MACA;MACA,IACE1B,OAAO,CAAC+B,YAAY,CAAC,GACjBA,YAAY,CAACjB,SAAS,CAACmB,KAAK,CAAC,CAACO,IAAI,EAAEQ,QAAQ,CAACR,IAAI,CAAC,GAClD1B,SAAS,CAACmB,KAAK,CAAC,CAACO,IAAI,KAAKQ,QAAQ,CAACR,IAAI,EAC3C;QACA;QACAQ,QAAQ,GAAG,IAAIzC,YAAY,CAAC;UAC1BK,KAAK,EAAEoC,QAAQ,CAACpC,KAAK;UACrBe,IAAI,EAAErB,UAAU,CAAC2C,WAAW,CAACnC,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI,EAAEqB,QAAQ,CAACrB,IAAI,CAAC,GAC9Db,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI,GACrBqB,QAAQ,CAACrB,IAAI;UACjBD,eAAe,EAAEsB,QAAQ,CAACtB,eAAe;UACzCE,cAAc,EAAEtB,UAAU,CAAC2C,WAAW,CACpCnC,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI,EACrBqB,QAAQ,CAACrB,IACX,CAAC,GACGb,SAAS,CAACmB,KAAK,CAAC,CAACL,cAAc,GAC/BoB,QAAQ,CAACpB,cAAc;UAC3BY,IAAI,EAAEQ,QAAQ,CAACR;QACjB,CAAC,CAAC;QACF1B,SAAS,CAACsC,MAAM,CAACnB,KAAK,EAAE,CAAC,CAAC;MAC5B,CAAC,MAAM;QACL;QACA;QACAnB,SAAS,CAACmB,KAAK,CAAC,GAAG,IAAI1B,YAAY,CAAC;UAClCK,KAAK,EAAEoC,QAAQ,CAACrB,IAAI;UACpBA,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI;UAC3BD,eAAe,EAAE,CAACsB,QAAQ,CAACpB,cAAc;UACzCA,cAAc,EAAEd,SAAS,CAACmB,KAAK,CAAC,CAACL,cAAc;UAC/CY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,CAAC,CAACO;QACzB,CAAC,CAAC;QAEF,IAAI1B,SAAS,CAACmB,KAAK,CAAC,CAACJ,OAAO,EAAE;UAC5Bf,SAAS,CAACsC,MAAM,CAACnB,KAAK,EAAE,CAAC,CAAC;QAC5B,CAAC,MAAM;UACL;UACA;UACA;QACF;MACF;IACF,CAAC,MAAM;MACL;MACA;IACF;EACF;;EAEA;EACAnB,SAAS,CAACsC,MAAM,CAACnB,KAAK,EAAE,CAAC,EAAEe,QAAQ,CAAC;EACpC,IAAI,CAAChC,aAAa,CAACmB,UAAU,CAAC,IAAI,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAtB,sBAAsB,CAACS,SAAS,CAAC+B,cAAc,GAAG,UAAUL,QAAQ,EAAE;EACpE;EACA,IAAI,CAAChD,OAAO,CAACgD,QAAQ,CAAC,EAAE;IACtB,MAAM,IAAI/C,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA;;EAEA,IAAI+C,QAAQ,CAACnB,OAAO,EAAE;IACpB,OAAO,KAAK;EACd;EAEA,MAAMf,SAAS,GAAG,IAAI,CAACC,UAAU;EAEjC,IAAIkB,KAAK,GAAGnC,YAAY,CAACgB,SAAS,EAAEkC,QAAQ,EAAExC,yBAAyB,CAAC;EACxE,IAAIyB,KAAK,GAAG,CAAC,EAAE;IACbA,KAAK,GAAG,CAACA,KAAK;EAChB;EAEA,IAAIqB,MAAM,GAAG,KAAK;;EAElB;EACA,IACErB,KAAK,GAAG,CAAC,KACR3B,UAAU,CAAC2C,WAAW,CAACnC,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,EAAEqB,QAAQ,CAACpC,KAAK,CAAC,IAC/DE,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,CAACG,MAAM,CAACkB,QAAQ,CAACpC,KAAK,CAAC,IAC/CE,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc,IACnCoB,QAAQ,CAACtB,eAAgB,CAAC,EAC9B;IACA4B,MAAM,GAAG,IAAI;IAEb,IACEhD,UAAU,CAAC2C,WAAW,CAACnC,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,EAAEqB,QAAQ,CAACrB,IAAI,CAAC,IAC/Db,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc,IAClC,CAACoB,QAAQ,CAACpB,cAAc,IACxBd,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI,CAACG,MAAM,CAACkB,QAAQ,CAACrB,IAAI,CAAE,EAClD;MACA;MACAb,SAAS,CAACsC,MAAM,CACdnB,KAAK,EACL,CAAC,EACD,IAAI1B,YAAY,CAAC;QACfK,KAAK,EAAEoC,QAAQ,CAACrB,IAAI;QACpBA,IAAI,EAAEb,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACN,IAAI;QAC/BD,eAAe,EAAE,CAACsB,QAAQ,CAACpB,cAAc;QACzCA,cAAc,EAAEd,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACL,cAAc;QACnDY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO;MAC7B,CAAC,CACH,CAAC;IACH;IACA1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI1B,YAAY,CAAC;MACtCK,KAAK,EAAEE,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACrB,KAAK;MACjCe,IAAI,EAAEqB,QAAQ,CAACpC,KAAK;MACpBc,eAAe,EAAEZ,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACP,eAAe;MACrDE,cAAc,EAAE,CAACoB,QAAQ,CAACtB,eAAe;MACzCc,IAAI,EAAE1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO;IAC7B,CAAC,CAAC;EACJ;;EAEA;EACA;EACA,IACEP,KAAK,GAAGnB,SAAS,CAACG,MAAM,IACxB,CAAC+B,QAAQ,CAACtB,eAAe,IACzBZ,SAAS,CAACmB,KAAK,CAAC,CAACP,eAAe,IAChCsB,QAAQ,CAACpC,KAAK,CAACkB,MAAM,CAAChB,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK,CAAC,EAC7C;IACA0C,MAAM,GAAG,IAAI;IAEbxC,SAAS,CAACsC,MAAM,CACdnB,KAAK,EACL,CAAC,EACD,IAAI1B,YAAY,CAAC;MACfK,KAAK,EAAEE,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK;MAC7Be,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK;MAC5Bc,eAAe,EAAE,IAAI;MACrBE,cAAc,EAAE,IAAI;MACpBY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,CAAC,CAACO;IACzB,CAAC,CACH,CAAC;IACD,EAAEP,KAAK;EACT;;EAEA;EACA,OACEA,KAAK,GAAGnB,SAAS,CAACG,MAAM,IACxBX,UAAU,CAAC2C,WAAW,CAACD,QAAQ,CAACrB,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI,CAAC,EAC5D;IACA2B,MAAM,GAAG,IAAI;IACbxC,SAAS,CAACsC,MAAM,CAACnB,KAAK,EAAE,CAAC,CAAC;EAC5B;;EAEA;EACA;EACA,IAAIA,KAAK,GAAGnB,SAAS,CAACG,MAAM,IAAI+B,QAAQ,CAACrB,IAAI,CAACG,MAAM,CAAChB,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI,CAAC,EAAE;IAC3E2B,MAAM,GAAG,IAAI;IAEb,IAAI,CAACN,QAAQ,CAACpB,cAAc,IAAId,SAAS,CAACmB,KAAK,CAAC,CAACL,cAAc,EAAE;MAC/D;MACA;MACA,IACEK,KAAK,GAAG,CAAC,GAAGnB,SAAS,CAACG,MAAM,IAC5BH,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACrB,KAAK,CAACkB,MAAM,CAACkB,QAAQ,CAACrB,IAAI,CAAC,IAChDb,SAAS,CAACmB,KAAK,CAAC,CAACO,IAAI,KAAK1B,SAAS,CAACmB,KAAK,GAAG,CAAC,CAAC,CAACO,IAAI,EACnD;QACA;QACA1B,SAAS,CAACsC,MAAM,CAACnB,KAAK,EAAE,CAAC,CAAC;QAC1BnB,SAAS,CAACmB,KAAK,CAAC,GAAG,IAAI1B,YAAY,CAAC;UAClCK,KAAK,EAAEE,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK;UAC7Be,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI;UAC3BD,eAAe,EAAE,IAAI;UACrBE,cAAc,EAAEd,SAAS,CAACmB,KAAK,CAAC,CAACL,cAAc;UAC/CY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,CAAC,CAACO;QACzB,CAAC,CAAC;MACJ,CAAC,MAAM;QACL1B,SAAS,CAACmB,KAAK,CAAC,GAAG,IAAI1B,YAAY,CAAC;UAClCK,KAAK,EAAEoC,QAAQ,CAACrB,IAAI;UACpBA,IAAI,EAAEqB,QAAQ,CAACrB,IAAI;UACnBD,eAAe,EAAE,IAAI;UACrBE,cAAc,EAAE,IAAI;UACpBY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,CAAC,CAACO;QACzB,CAAC,CAAC;MACJ;IACF,CAAC,MAAM;MACL;MACA1B,SAAS,CAACsC,MAAM,CAACnB,KAAK,EAAE,CAAC,CAAC;IAC5B;EACF;;EAEA;EACA,IACEA,KAAK,GAAGnB,SAAS,CAACG,MAAM,KACvBX,UAAU,CAAC2C,WAAW,CAACD,QAAQ,CAACrB,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK,CAAC,IAC3DoC,QAAQ,CAACrB,IAAI,CAACG,MAAM,CAAChB,SAAS,CAACmB,KAAK,CAAC,CAACrB,KAAK,CAAC,IAC3CoC,QAAQ,CAACpB,cAAc,IACvBd,SAAS,CAACmB,KAAK,CAAC,CAACP,eAAgB,CAAC,EACtC;IACA4B,MAAM,GAAG,IAAI;IACbxC,SAAS,CAACmB,KAAK,CAAC,GAAG,IAAI1B,YAAY,CAAC;MAClCK,KAAK,EAAEoC,QAAQ,CAACrB,IAAI;MACpBA,IAAI,EAAEb,SAAS,CAACmB,KAAK,CAAC,CAACN,IAAI;MAC3BD,eAAe,EAAE,CAACsB,QAAQ,CAACpB,cAAc;MACzCA,cAAc,EAAEd,SAAS,CAACmB,KAAK,CAAC,CAACL,cAAc;MAC/CY,IAAI,EAAE1B,SAAS,CAACmB,KAAK,CAAC,CAACO;IACzB,CAAC,CAAC;EACJ;EAEA,IAAIc,MAAM,EAAE;IACV,IAAI,CAACtC,aAAa,CAACmB,UAAU,CAAC,IAAI,CAAC;EACrC;EAEA,OAAOmB,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,sBAAsB,CAACS,SAAS,CAACiC,SAAS,GAAG,UAC3CC,KAAK,EACLzB,YAAY,EACZ0B,aAAa,EACb;EACA;EACA,IAAI,CAACzD,OAAO,CAACwD,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIvD,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA,MAAMqD,MAAM,GAAG,IAAIzC,sBAAsB,CAAC,CAAC;EAC3C,IAAIJ,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK,GAAG,CAAC;EACb,MAAMI,SAAS,GAAG,IAAI,CAACC,UAAU;EACjC,MAAM2C,cAAc,GAAGF,KAAK,CAACzC,UAAU;EAEvC,OAAON,IAAI,GAAGK,SAAS,CAACG,MAAM,IAAIP,KAAK,GAAGgD,cAAc,CAACzC,MAAM,EAAE;IAC/D,MAAM0C,YAAY,GAAG7C,SAAS,CAACL,IAAI,CAAC;IACpC,MAAMmD,aAAa,GAAGF,cAAc,CAAChD,KAAK,CAAC;IAC3C,IAAIJ,UAAU,CAACuD,QAAQ,CAACF,YAAY,CAAChC,IAAI,EAAEiC,aAAa,CAAChD,KAAK,CAAC,EAAE;MAC/D,EAAEH,IAAI;IACR,CAAC,MAAM,IAAIH,UAAU,CAACuD,QAAQ,CAACD,aAAa,CAACjC,IAAI,EAAEgC,YAAY,CAAC/C,KAAK,CAAC,EAAE;MACtE,EAAEF,KAAK;IACT,CAAC,MAAM;MACL;MACA,IACEV,OAAO,CAACyD,aAAa,CAAC,IACrBzD,OAAO,CAAC+B,YAAY,CAAC,IACpBA,YAAY,CAAC4B,YAAY,CAACnB,IAAI,EAAEoB,aAAa,CAACpB,IAAI,CAAE,IACrD,CAACxC,OAAO,CAAC+B,YAAY,CAAC,IAAI6B,aAAa,CAACpB,IAAI,KAAKmB,YAAY,CAACnB,IAAK,EACpE;QACA,MAAMsB,YAAY,GAAGvD,YAAY,CAACgD,SAAS,CACzCI,YAAY,EACZC,aAAa,EACb,IAAIrD,YAAY,CAAC,CAAC,EAClBkD,aACF,CAAC;QACD,IAAI,CAACK,YAAY,CAACjC,OAAO,EAAE;UACzB;UACA;UACAyB,MAAM,CAACnC,WAAW,CAAC2C,YAAY,EAAE/B,YAAY,CAAC;QAChD;MACF;MAEA,IACEzB,UAAU,CAACuD,QAAQ,CAACF,YAAY,CAAChC,IAAI,EAAEiC,aAAa,CAACjC,IAAI,CAAC,IACzDgC,YAAY,CAAChC,IAAI,CAACG,MAAM,CAAC8B,aAAa,CAACjC,IAAI,CAAC,IAC3C,CAACgC,YAAY,CAAC/B,cAAc,IAC5BgC,aAAa,CAAChC,cAAe,EAC/B;QACA,EAAEnB,IAAI;MACR,CAAC,MAAM;QACL,EAAEC,KAAK;MACT;IACF;EACF;EACA,OAAO4C,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,sBAAsB,CAACkD,mBAAmB,GAAG,UAAUlB,OAAO,EAAES,MAAM,EAAE;EACtE;EACA,IAAI,CAACtD,OAAO,CAAC6C,OAAO,CAAC,EAAE;IACrB,MAAM,IAAI5C,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA,IAAI,CAACD,OAAO,CAAC6C,OAAO,CAACmB,WAAW,CAAC,EAAE;IACjC,MAAM,IAAI/D,cAAc,CAAC,mCAAmC,CAAC;EAC/D;EACA;;EAEA,IAAI,CAACD,OAAO,CAACsD,MAAM,CAAC,EAAE;IACpBA,MAAM,GAAG,IAAIzC,sBAAsB,CAAC,CAAC;EACvC;EAEA,MAAMmD,WAAW,GAAGnB,OAAO,CAACmB,WAAW;EACvC,MAAM/C,MAAM,GAAG+C,WAAW,CAAC/C,MAAM;EACjC,MAAMgD,YAAY,GAAGpB,OAAO,CAACoB,YAAY;EAEzC,MAAMvC,eAAe,GAAG3B,YAAY,CAAC8C,OAAO,CAACnB,eAAe,EAAE,IAAI,CAAC;EACnE,MAAME,cAAc,GAAG7B,YAAY,CAAC8C,OAAO,CAACjB,cAAc,EAAE,IAAI,CAAC;EACjE,MAAMsC,eAAe,GAAGnE,YAAY,CAAC8C,OAAO,CAACqB,eAAe,EAAE,KAAK,CAAC;EACpE,MAAMC,gBAAgB,GAAGpE,YAAY,CAAC8C,OAAO,CAACsB,gBAAgB,EAAE,KAAK,CAAC;EACtE,IAAInB,QAAQ;;EAEZ;EACA,IAAIoB,UAAU,GAAG,CAAC;EAClB,IAAIF,eAAe,EAAE;IACnB,EAAEE,UAAU;IACZpB,QAAQ,GAAG,IAAIzC,YAAY,CAAC;MAC1BK,KAAK,EAAEP,OAAO,CAACgE,aAAa;MAC5B1C,IAAI,EAAEqC,WAAW,CAAC,CAAC,CAAC;MACpBtC,eAAe,EAAE,IAAI;MACrBE,cAAc,EAAE,CAACF;IACnB,CAAC,CAAC;IACFsB,QAAQ,CAACR,IAAI,GAAGxC,OAAO,CAACiE,YAAY,CAAC,GACjCA,YAAY,CAACjB,QAAQ,EAAEM,MAAM,CAACrC,MAAM,CAAC,GACrCqC,MAAM,CAACrC,MAAM;IACjBqC,MAAM,CAACnC,WAAW,CAAC6B,QAAQ,CAAC;EAC9B;EAEA,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,GAAG,CAAC,EAAE,EAAEC,CAAC,EAAE;IACnC,IAAIoD,SAAS,GAAGN,WAAW,CAAC9C,CAAC,CAAC;IAC9B,MAAMqD,OAAO,GAAGP,WAAW,CAAC9C,CAAC,GAAG,CAAC,CAAC;IAElC8B,QAAQ,GAAG,IAAIzC,YAAY,CAAC;MAC1BK,KAAK,EAAE0D,SAAS;MAChB3C,IAAI,EAAE4C,OAAO;MACb7C,eAAe,EAAE4B,MAAM,CAACrC,MAAM,KAAKmD,UAAU,GAAG1C,eAAe,GAAG,IAAI;MACtEE,cAAc,EAAEV,CAAC,KAAKD,MAAM,GAAG,CAAC,GAAGW,cAAc,GAAG;IACtD,CAAC,CAAC;IACFoB,QAAQ,CAACR,IAAI,GAAGxC,OAAO,CAACiE,YAAY,CAAC,GACjCA,YAAY,CAACjB,QAAQ,EAAEM,MAAM,CAACrC,MAAM,CAAC,GACrCqC,MAAM,CAACrC,MAAM;IACjBqC,MAAM,CAACnC,WAAW,CAAC6B,QAAQ,CAAC;IAE5BsB,SAAS,GAAGC,OAAO;EACrB;EAEA,IAAIJ,gBAAgB,EAAE;IACpBnB,QAAQ,GAAG,IAAIzC,YAAY,CAAC;MAC1BK,KAAK,EAAEoD,WAAW,CAAC/C,MAAM,GAAG,CAAC,CAAC;MAC9BU,IAAI,EAAEtB,OAAO,CAACmE,aAAa;MAC3B9C,eAAe,EAAE,CAACE,cAAc;MAChCA,cAAc,EAAE;IAClB,CAAC,CAAC;IACFoB,QAAQ,CAACR,IAAI,GAAGxC,OAAO,CAACiE,YAAY,CAAC,GACjCA,YAAY,CAACjB,QAAQ,EAAEM,MAAM,CAACrC,MAAM,CAAC,GACrCqC,MAAM,CAACrC,MAAM;IACjBqC,MAAM,CAACnC,WAAW,CAAC6B,QAAQ,CAAC;EAC9B;EAEA,OAAOM,MAAM;AACf,CAAC;AAED,MAAMmB,oBAAoB,GAAG,IAAItE,aAAa,CAAC,CAAC;AAChD,MAAMuE,YAAY,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACjC,UAAU,EAAEkC,QAAQ,EAAEtB,MAAM,EAAE;EAC/C,IAAI,CAACtD,OAAO,CAACsD,MAAM,CAAC,EAAE;IACpBA,MAAM,GAAG,IAAIhD,UAAU,CAAC,CAAC;EAC3B;EACAA,UAAU,CAACuE,eAAe,CAACnC,UAAU,EAAE+B,oBAAoB,CAAC;EAE5D,IAAIK,WAAW,GAAGL,oBAAoB,CAACK,WAAW,GAAGF,QAAQ,CAACE,WAAW;EACzE,IAAIC,MAAM,GAAGN,oBAAoB,CAACM,MAAM,GAAGH,QAAQ,CAACG,MAAM;EAC1D,IAAIC,MAAM,GAAGP,oBAAoB,CAACO,MAAM,GAAGJ,QAAQ,CAACI,MAAM;EAC1D,IAAIC,IAAI,GAAGR,oBAAoB,CAACQ,IAAI,GAAGL,QAAQ,CAACK,IAAI;EACpD,IAAIC,GAAG,GAAGT,oBAAoB,CAACS,GAAG,GAAGN,QAAQ,CAACM,GAAG;EACjD,IAAIC,KAAK,GAAGV,oBAAoB,CAACU,KAAK,GAAGP,QAAQ,CAACO,KAAK;EACvD,IAAIC,IAAI,GAAGX,oBAAoB,CAACW,IAAI,GAAGR,QAAQ,CAACQ,IAAI;EAEpD,IAAIN,WAAW,IAAI,IAAI,EAAE;IACvBC,MAAM,IAAIM,IAAI,CAACC,KAAK,CAACR,WAAW,GAAG,IAAI,CAAC;IACxCA,WAAW,GAAGA,WAAW,GAAG,IAAI;EAClC;EAEA,IAAIC,MAAM,IAAI,EAAE,EAAE;IAChBC,MAAM,IAAIK,IAAI,CAACC,KAAK,CAACP,MAAM,GAAG,EAAE,CAAC;IACjCA,MAAM,GAAGA,MAAM,GAAG,EAAE;EACtB;EAEA,IAAIC,MAAM,IAAI,EAAE,EAAE;IAChBC,IAAI,IAAII,IAAI,CAACC,KAAK,CAACN,MAAM,GAAG,EAAE,CAAC;IAC/BA,MAAM,GAAGA,MAAM,GAAG,EAAE;EACtB;EAEA,IAAIC,IAAI,IAAI,EAAE,EAAE;IACdC,GAAG,IAAIG,IAAI,CAACC,KAAK,CAACL,IAAI,GAAG,EAAE,CAAC;IAC5BA,IAAI,GAAGA,IAAI,GAAG,EAAE;EAClB;;EAEA;EACA;EACAP,YAAY,CAAC,CAAC,CAAC,GAAGtE,UAAU,CAACgF,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE;EAC5C,OAAOF,GAAG,GAAGR,YAAY,CAACS,KAAK,CAAC,IAAIA,KAAK,IAAI,EAAE,EAAE;IAC/C,IAAID,GAAG,GAAGR,YAAY,CAACS,KAAK,CAAC,EAAE;MAC7BD,GAAG,IAAIR,YAAY,CAACS,KAAK,CAAC;MAC1B,EAAEA,KAAK;IACT;IAEA,IAAIA,KAAK,IAAI,EAAE,EAAE;MACf,EAAEA,KAAK;MACPC,IAAI,IAAIC,IAAI,CAACC,KAAK,CAACH,KAAK,GAAG,EAAE,CAAC;MAC9BA,KAAK,GAAGA,KAAK,GAAG,EAAE;MAClB,EAAEA,KAAK;IACT;IAEAT,YAAY,CAAC,CAAC,CAAC,GAAGtE,UAAU,CAACgF,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE;EAC9C;EAEAX,oBAAoB,CAACK,WAAW,GAAGA,WAAW;EAC9CL,oBAAoB,CAACM,MAAM,GAAGA,MAAM;EACpCN,oBAAoB,CAACO,MAAM,GAAGA,MAAM;EACpCP,oBAAoB,CAACQ,IAAI,GAAGA,IAAI;EAChCR,oBAAoB,CAACS,GAAG,GAAGA,GAAG;EAC9BT,oBAAoB,CAACU,KAAK,GAAGA,KAAK;EAClCV,oBAAoB,CAACW,IAAI,GAAGA,IAAI;EAEhC,OAAO9E,UAAU,CAACiF,iBAAiB,CAACd,oBAAoB,EAAEnB,MAAM,CAAC;AACnE;AAEA,MAAMkC,iBAAiB,GAAG,IAAIlF,UAAU,CAAC,CAAC;AAC1C,MAAMmF,aAAa,GACjB,kHAAkH;;AAEpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,OAAO,EAAErC,MAAM,EAAE;EACtC,IAAI,CAACtD,OAAO,CAAC2F,OAAO,CAAC,IAAIA,OAAO,CAAC1E,MAAM,KAAK,CAAC,EAAE;IAC7C,OAAO,KAAK;EACd;;EAEA;EACAqC,MAAM,CAAC8B,IAAI,GAAG,CAAC;EACf9B,MAAM,CAAC6B,KAAK,GAAG,CAAC;EAChB7B,MAAM,CAAC4B,GAAG,GAAG,CAAC;EACd5B,MAAM,CAAC2B,IAAI,GAAG,CAAC;EACf3B,MAAM,CAAC0B,MAAM,GAAG,CAAC;EACjB1B,MAAM,CAACyB,MAAM,GAAG,CAAC;EACjBzB,MAAM,CAACwB,WAAW,GAAG,CAAC;EAEtB,IAAIa,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IACtB,MAAMC,OAAO,GAAGD,OAAO,CAACE,KAAK,CAACJ,aAAa,CAAC;IAC5C,IAAI,CAACzF,OAAO,CAAC4F,OAAO,CAAC,EAAE;MACrB,OAAO,KAAK;IACd;IACA,IAAI5F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACAtC,MAAM,CAAC8B,IAAI,GAAGU,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACpD;IACA,IAAI/F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACAtC,MAAM,CAAC6B,KAAK,GAAGW,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACrD;IACA,IAAI/F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACAtC,MAAM,CAAC4B,GAAG,GAAGY,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC;IACvD;IACA,IAAI/F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACAtC,MAAM,CAAC4B,GAAG,IAAIY,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACpD;IACA,IAAI/F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACAtC,MAAM,CAAC2B,IAAI,GAAGa,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACpD;IACA,IAAI/F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACAtC,MAAM,CAAC0B,MAAM,GAAGc,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACtD;IACA,IAAI/F,OAAO,CAAC4F,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MACvB;MACA,MAAMI,OAAO,GAAGF,MAAM,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;MACpDzC,MAAM,CAACyB,MAAM,GAAGM,IAAI,CAACC,KAAK,CAACU,OAAO,CAAC;MACnC1C,MAAM,CAACwB,WAAW,GAAIkB,OAAO,GAAG,CAAC,GAAI,IAAI;IAC3C;EACF,CAAC,MAAM;IACL;IACA,IAAIL,OAAO,CAACA,OAAO,CAAC1E,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MACvC;MACA0E,OAAO,IAAI,GAAG;IAChB;IACArF,UAAU,CAACuE,eAAe,CACxBvE,UAAU,CAAC2F,WAAW,CAACN,OAAO,EAAEH,iBAAiB,CAAC,EAClDlC,MACF,CAAC;EACH;;EAEA;EACA,OACEA,MAAM,CAAC8B,IAAI,IACX9B,MAAM,CAAC6B,KAAK,IACZ7B,MAAM,CAAC4B,GAAG,IACV5B,MAAM,CAAC2B,IAAI,IACX3B,MAAM,CAAC0B,MAAM,IACb1B,MAAM,CAACyB,MAAM,IACbzB,MAAM,CAACwB,WAAW;AAEtB;AAEA,MAAMoB,eAAe,GAAG,IAAI/F,aAAa,CAAC,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAU,sBAAsB,CAACoF,WAAW,GAAG,UAAUpD,OAAO,EAAES,MAAM,EAAE;EAC9D;EACA,IAAI,CAACtD,OAAO,CAAC6C,OAAO,CAAC,EAAE;IACrB,MAAM,IAAI5C,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA,IAAI,CAACD,OAAO,CAAC6C,OAAO,CAAC8C,OAAO,CAAC,EAAE;IAC7B,MAAM,IAAI1F,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;;EAEA,MAAMkG,KAAK,GAAGtD,OAAO,CAAC8C,OAAO,CAACS,KAAK,CAAC,GAAG,CAAC;EACxC,MAAMxF,KAAK,GAAGN,UAAU,CAAC2F,WAAW,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;EAC9C,MAAMxE,IAAI,GAAGrB,UAAU,CAAC2F,WAAW,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7C,MAAMnC,WAAW,GAAG,EAAE;EAEtB,IAAI,CAAC0B,aAAa,CAACS,KAAK,CAAC,CAAC,CAAC,EAAED,eAAe,CAAC,EAAE;IAC7ClC,WAAW,CAACd,IAAI,CAACtC,KAAK,EAAEe,IAAI,CAAC;EAC/B,CAAC,MAAM;IACL,IAAIU,IAAI,GAAG/B,UAAU,CAAC+F,KAAK,CAACzF,KAAK,CAAC;IAClCoD,WAAW,CAACd,IAAI,CAACb,IAAI,CAAC;IACtB,OAAO/B,UAAU,CAACK,OAAO,CAAC0B,IAAI,EAAEV,IAAI,CAAC,GAAG,CAAC,EAAE;MACzCU,IAAI,GAAGsC,SAAS,CAACtC,IAAI,EAAE6D,eAAe,CAAC;MACvC,MAAMI,SAAS,GAAGhG,UAAU,CAACK,OAAO,CAACgB,IAAI,EAAEU,IAAI,CAAC,IAAI,CAAC;MACrD,IAAIiE,SAAS,EAAE;QACbhG,UAAU,CAAC+F,KAAK,CAAC1E,IAAI,EAAEU,IAAI,CAAC;MAC9B;MAEA2B,WAAW,CAACd,IAAI,CAACb,IAAI,CAAC;IACxB;EACF;EAEA,OAAOxB,sBAAsB,CAACkD,mBAAmB,CAC/C;IACEC,WAAW,EAAEA,WAAW;IACxBtC,eAAe,EAAEmB,OAAO,CAACnB,eAAe;IACxCE,cAAc,EAAEiB,OAAO,CAACjB,cAAc;IACtCsC,eAAe,EAAErB,OAAO,CAACqB,eAAe;IACxCC,gBAAgB,EAAEtB,OAAO,CAACsB,gBAAgB;IAC1CF,YAAY,EAAEpB,OAAO,CAACoB;EACxB,CAAC,EACDX,MACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,sBAAsB,CAAC0F,oBAAoB,GAAG,UAAU1D,OAAO,EAAES,MAAM,EAAE;EACvE;EACA,IAAI,CAACtD,OAAO,CAAC6C,OAAO,CAAC,EAAE;IACrB,MAAM,IAAI5C,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA,IAAI,CAACD,OAAO,CAAC6C,OAAO,CAAC2D,YAAY,CAAC,EAAE;IAClC,MAAM,IAAIvG,cAAc,CAAC,mCAAmC,CAAC;EAC/D;EACA;;EAEA,OAAOY,sBAAsB,CAACkD,mBAAmB,CAC/C;IACEC,WAAW,EAAEnB,OAAO,CAAC2D,YAAY,CAACC,GAAG,CAAC,UAAUpE,IAAI,EAAE;MACpD,OAAO/B,UAAU,CAAC2F,WAAW,CAAC5D,IAAI,CAAC;IACrC,CAAC,CAAC;IACFX,eAAe,EAAEmB,OAAO,CAACnB,eAAe;IACxCE,cAAc,EAAEiB,OAAO,CAACjB,cAAc;IACtCsC,eAAe,EAAErB,OAAO,CAACqB,eAAe;IACxCC,gBAAgB,EAAEtB,OAAO,CAACsB,gBAAgB;IAC1CF,YAAY,EAAEpB,OAAO,CAACoB;EACxB,CAAC,EACDX,MACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,sBAAsB,CAAC6F,wBAAwB,GAAG,UAAU7D,OAAO,EAAES,MAAM,EAAE;EAC3E;EACA,IAAI,CAACtD,OAAO,CAAC6C,OAAO,CAAC,EAAE;IACrB,MAAM,IAAI5C,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA,IAAI,CAACD,OAAO,CAAC6C,OAAO,CAAC8D,KAAK,CAAC,EAAE;IAC3B,MAAM,IAAI1G,cAAc,CAAC,4BAA4B,CAAC;EACxD;EACA,IAAI,CAACD,OAAO,CAAC6C,OAAO,CAAC+D,gBAAgB,CAAC,EAAE;IACtC,MAAM,IAAI3G,cAAc,CAAC,uCAAuC,CAAC;EACnE;EACA;;EAEA,MAAM0G,KAAK,GAAG9D,OAAO,CAAC8D,KAAK;EAC3B,MAAMC,gBAAgB,GAAG/D,OAAO,CAAC+D,gBAAgB;EACjD,MAAMC,kBAAkB,GAAG9G,YAAY,CAAC8C,OAAO,CAACgE,kBAAkB,EAAE,KAAK,CAAC;EAC1E,MAAM7C,WAAW,GAAG,EAAE;EACtB,IAAI3B,IAAI,EAAEyE,YAAY;EAEtB,MAAM7F,MAAM,GAAG2F,gBAAgB,CAAC3F,MAAM;EACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAE,EAAEC,CAAC,EAAE;IAC/B;IACA,IAAIwE,aAAa,CAACkB,gBAAgB,CAAC1F,CAAC,CAAC,EAAEgF,eAAe,CAAC,IAAIhF,CAAC,KAAK,CAAC,EAAE;MAClE,IAAI2F,kBAAkB,IAAI7G,OAAO,CAAC8G,YAAY,CAAC,EAAE;QAC/CzE,IAAI,GAAGsC,SAAS,CAACmC,YAAY,EAAEZ,eAAe,CAAC;MACjD,CAAC,MAAM;QACL7D,IAAI,GAAGsC,SAAS,CAACgC,KAAK,EAAET,eAAe,CAAC;MAC1C;MACAlC,WAAW,CAACd,IAAI,CAACb,IAAI,CAAC;MACtByE,YAAY,GAAGzE,IAAI;IACrB;EACF;EAEA,OAAOxB,sBAAsB,CAACkD,mBAAmB,CAC/C;IACEC,WAAW,EAAEA,WAAW;IACxBtC,eAAe,EAAEmB,OAAO,CAACnB,eAAe;IACxCE,cAAc,EAAEiB,OAAO,CAACjB,cAAc;IACtCsC,eAAe,EAAErB,OAAO,CAACqB,eAAe;IACxCC,gBAAgB,EAAEtB,OAAO,CAACsB,gBAAgB;IAC1CF,YAAY,EAAEpB,OAAO,CAACoB;EACxB,CAAC,EACDX,MACF,CAAC;AACH,CAAC;AACD,eAAezC,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}