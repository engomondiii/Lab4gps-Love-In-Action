{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"vec3 lambertianDiffuse(vec3 diffuseColor)\\n\\\n{\\n\\\n    return diffuseColor / czm_pi;\\n\\\n}\\n\\\n\\n\\\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\\n\\\n{\\n\\\n    float versine = 1.0 - VdotH;\\n\\\n    // pow(versine, 5.0) is slow. See https://stackoverflow.com/a/68793086/10082269\\n\\\n    float versineSquared = versine * versine;\\n\\\n    return f0 + (f90 - f0) * versineSquared * versineSquared * versine;\\n\\\n}\\n\\\n\\n\\\n#ifdef USE_ANISOTROPY\\n\\\n/**\\n\\\n * @param {float} bitangentRoughness Material roughness (along the anisotropy bitangent)\\n\\\n * @param {float} tangentialRoughness Anisotropic roughness (along the anisotropy tangent)\\n\\\n * @param {vec3} lightDirection The direction from the fragment to the light source, transformed to tangent-bitangent-normal coordinates\\n\\\n * @param {vec3} viewDirection The direction from the fragment to the camera, transformed to tangent-bitangent-normal coordinates\\n\\\n */\\n\\\nfloat smithVisibilityGGX_anisotropic(float bitangentRoughness, float tangentialRoughness, vec3 lightDirection, vec3 viewDirection)\\n\\\n{\\n\\\n    vec3 roughnessScale = vec3(tangentialRoughness, bitangentRoughness, 1.0);\\n\\\n    float GGXV = lightDirection.z * length(roughnessScale * viewDirection);\\n\\\n    float GGXL = viewDirection.z * length(roughnessScale * lightDirection);\\n\\\n    float v = 0.5 / (GGXV + GGXL);\\n\\\n    return clamp(v, 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * @param {float} bitangentRoughness Material roughness (along the anisotropy bitangent)\\n\\\n * @param {float} tangentialRoughness Anisotropic roughness (along the anisotropy tangent)\\n\\\n * @param {vec3} halfwayDirection The unit vector halfway between light and view directions, transformed to tangent-bitangent-normal coordinates\\n\\\n */\\n\\\nfloat GGX_anisotropic(float bitangentRoughness, float tangentialRoughness, vec3 halfwayDirection)\\n\\\n{\\n\\\n    float roughnessSquared = bitangentRoughness * tangentialRoughness;\\n\\\n    vec3 f = halfwayDirection * vec3(bitangentRoughness, tangentialRoughness, roughnessSquared);\\n\\\n    float w2 = roughnessSquared / dot(f, f);\\n\\\n    return roughnessSquared * w2 * w2 / czm_pi;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Estimate the geometric self-shadowing of the microfacets in a surface,\\n\\\n * using the Smith Joint GGX visibility function.\\n\\\n * Note: Vis = G / (4 * NdotL * NdotV)\\n\\\n * see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\\n\\\n * see Real-Time Rendering. Page 331 to 336.\\n\\\n * see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\\n\\\n *\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @param {float} NdotL The cosine of the angle between the surface normal and the direction to the light source.\\n\\\n * @param {float} NdotV The cosine of the angle between the surface normal and the direction to the camera.\\n\\\n */\\n\\\nfloat smithVisibilityGGX(float alphaRoughness, float NdotL, float NdotV)\\n\\\n{\\n\\\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\\n\\\n\\n\\\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n\\n\\\n    float GGX = GGXV + GGXL;\\n\\\n    if (GGX > 0.0)\\n\\\n    {\\n\\\n        return 0.5 / GGX;\\n\\\n    }\\n\\\n    return 0.0;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Estimate the fraction of the microfacets in a surface that are aligned with \\n\\\n * the halfway vector, which is aligned halfway between the directions from\\n\\\n * the fragment to the camera and from the fragment to the light source.\\n\\\n *\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @param {float} NdotH The cosine of the angle between the surface normal and the halfway vector.\\n\\\n * @return {float} The fraction of microfacets aligned to the halfway vector.\\n\\\n */\\n\\\nfloat GGX(float alphaRoughness, float NdotH)\\n\\\n{\\n\\\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\\n\\\n    float f = (NdotH * alphaRoughnessSquared - NdotH) * NdotH + 1.0;\\n\\\n    return alphaRoughnessSquared / (czm_pi * f * f);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the strength of the specular reflection due to direct lighting.\\n\\\n *\\n\\\n * @param {vec3} normal The surface normal.\\n\\\n * @param {vec3} lightDirection The unit vector pointing from the fragment to the light source.\\n\\\n * @param {vec3} viewDirection The unit vector pointing from the fragment to the camera.\\n\\\n * @param {vec3} halfwayDirection The unit vector pointing from the fragment to halfway between the light source and the camera.\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @return {float} The strength of the specular reflection.\\n\\\n */\\n\\\nfloat computeDirectSpecularStrength(vec3 normal, vec3 lightDirection, vec3 viewDirection, vec3 halfwayDirection, float alphaRoughness)\\n\\\n{\\n\\\n    float NdotL = clamp(dot(normal, lightDirection), 0.0, 1.0);\\n\\\n    float NdotV = clamp(dot(normal, viewDirection), 0.0, 1.0);\\n\\\n    float G = smithVisibilityGGX(alphaRoughness, NdotL, NdotV);\\n\\\n    float NdotH = clamp(dot(normal, halfwayDirection), 0.0, 1.0);\\n\\\n    float D = GGX(alphaRoughness, NdotH);\\n\\\n    return G * D;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the diffuse and specular contributions using physically based\\n\\\n * rendering. This function only handles direct lighting.\\n\\\n * <p>\\n\\\n * This function only handles the lighting calculations. Metallic/roughness\\n\\\n * and specular/glossy must be handled separately. See {@MaterialStageFS}\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_pbrLighting\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} viewDirectionEC Unit vector pointing from the fragment to the eye position\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates\\n\\\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\\n\\\n * @param {czm_modelMaterial} The material properties.\\n\\\n * @return {vec3} The computed HDR color\\n\\\n */\\n\\\nvec3 czm_pbrLighting(vec3 viewDirectionEC, vec3 normalEC, vec3 lightDirectionEC, czm_modelMaterial material)\\n\\\n{\\n\\\n    vec3 halfwayDirectionEC = normalize(viewDirectionEC + lightDirectionEC);\\n\\\n    float VdotH = clamp(dot(viewDirectionEC, halfwayDirectionEC), 0.0, 1.0);\\n\\\n    float NdotL = clamp(dot(normalEC, lightDirectionEC), 0.001, 1.0);\\n\\\n\\n\\\n    vec3 f0 = material.specular;\\n\\\n    float reflectance = czm_maximumComponent(f0);\\n\\\n    // Typical dielectrics will have reflectance 0.04, so f90 will be 1.0.\\n\\\n    // In this case, at grazing angle, all incident energy is reflected.\\n\\\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\\n\\\n\\n\\\n    #if defined(USE_SPECULAR)\\n\\\n        F *= material.specularWeight;\\n\\\n    #endif\\n\\\n\\n\\\n    float alphaRoughness = material.roughness * material.roughness;\\n\\\n    #ifdef USE_ANISOTROPY\\n\\\n        mat3 tbn = mat3(material.anisotropicT, material.anisotropicB, normalEC);\\n\\\n        vec3 lightDirection = lightDirectionEC * tbn;\\n\\\n        vec3 viewDirection = viewDirectionEC * tbn;\\n\\\n        vec3 halfwayDirection = halfwayDirectionEC * tbn;\\n\\\n        float anisotropyStrength = material.anisotropyStrength;\\n\\\n        float tangentialRoughness = mix(alphaRoughness, 1.0, anisotropyStrength * anisotropyStrength);\\n\\\n        float bitangentRoughness = clamp(alphaRoughness, 0.001, 1.0);\\n\\\n        float G = smithVisibilityGGX_anisotropic(bitangentRoughness, tangentialRoughness, lightDirection, viewDirection);\\n\\\n        float D = GGX_anisotropic(bitangentRoughness, tangentialRoughness, halfwayDirection);\\n\\\n        vec3 specularContribution = F * G * D;\\n\\\n    #else\\n\\\n        float specularStrength = computeDirectSpecularStrength(normalEC, lightDirectionEC, viewDirectionEC, halfwayDirectionEC, alphaRoughness);\\n\\\n        vec3 specularContribution = F * specularStrength;\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 diffuseColor = material.diffuse;\\n\\\n    // F here represents the specular contribution\\n\\\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\\n\\\n\\n\\\n    // Lo = (diffuse + specular) * Li * NdotL\\n\\\n    return (diffuseContribution + specularContribution) * NdotL;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Builtin/Functions/pbrLighting.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"vec3 lambertianDiffuse(vec3 diffuseColor)\\n\\\n{\\n\\\n    return diffuseColor / czm_pi;\\n\\\n}\\n\\\n\\n\\\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\\n\\\n{\\n\\\n    float versine = 1.0 - VdotH;\\n\\\n    // pow(versine, 5.0) is slow. See https://stackoverflow.com/a/68793086/10082269\\n\\\n    float versineSquared = versine * versine;\\n\\\n    return f0 + (f90 - f0) * versineSquared * versineSquared * versine;\\n\\\n}\\n\\\n\\n\\\n#ifdef USE_ANISOTROPY\\n\\\n/**\\n\\\n * @param {float} bitangentRoughness Material roughness (along the anisotropy bitangent)\\n\\\n * @param {float} tangentialRoughness Anisotropic roughness (along the anisotropy tangent)\\n\\\n * @param {vec3} lightDirection The direction from the fragment to the light source, transformed to tangent-bitangent-normal coordinates\\n\\\n * @param {vec3} viewDirection The direction from the fragment to the camera, transformed to tangent-bitangent-normal coordinates\\n\\\n */\\n\\\nfloat smithVisibilityGGX_anisotropic(float bitangentRoughness, float tangentialRoughness, vec3 lightDirection, vec3 viewDirection)\\n\\\n{\\n\\\n    vec3 roughnessScale = vec3(tangentialRoughness, bitangentRoughness, 1.0);\\n\\\n    float GGXV = lightDirection.z * length(roughnessScale * viewDirection);\\n\\\n    float GGXL = viewDirection.z * length(roughnessScale * lightDirection);\\n\\\n    float v = 0.5 / (GGXV + GGXL);\\n\\\n    return clamp(v, 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * @param {float} bitangentRoughness Material roughness (along the anisotropy bitangent)\\n\\\n * @param {float} tangentialRoughness Anisotropic roughness (along the anisotropy tangent)\\n\\\n * @param {vec3} halfwayDirection The unit vector halfway between light and view directions, transformed to tangent-bitangent-normal coordinates\\n\\\n */\\n\\\nfloat GGX_anisotropic(float bitangentRoughness, float tangentialRoughness, vec3 halfwayDirection)\\n\\\n{\\n\\\n    float roughnessSquared = bitangentRoughness * tangentialRoughness;\\n\\\n    vec3 f = halfwayDirection * vec3(bitangentRoughness, tangentialRoughness, roughnessSquared);\\n\\\n    float w2 = roughnessSquared / dot(f, f);\\n\\\n    return roughnessSquared * w2 * w2 / czm_pi;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Estimate the geometric self-shadowing of the microfacets in a surface,\\n\\\n * using the Smith Joint GGX visibility function.\\n\\\n * Note: Vis = G / (4 * NdotL * NdotV)\\n\\\n * see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\\n\\\n * see Real-Time Rendering. Page 331 to 336.\\n\\\n * see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\\n\\\n *\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @param {float} NdotL The cosine of the angle between the surface normal and the direction to the light source.\\n\\\n * @param {float} NdotV The cosine of the angle between the surface normal and the direction to the camera.\\n\\\n */\\n\\\nfloat smithVisibilityGGX(float alphaRoughness, float NdotL, float NdotV)\\n\\\n{\\n\\\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\\n\\\n\\n\\\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\\n\\\n\\n\\\n    float GGX = GGXV + GGXL;\\n\\\n    if (GGX > 0.0)\\n\\\n    {\\n\\\n        return 0.5 / GGX;\\n\\\n    }\\n\\\n    return 0.0;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Estimate the fraction of the microfacets in a surface that are aligned with \\n\\\n * the halfway vector, which is aligned halfway between the directions from\\n\\\n * the fragment to the camera and from the fragment to the light source.\\n\\\n *\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @param {float} NdotH The cosine of the angle between the surface normal and the halfway vector.\\n\\\n * @return {float} The fraction of microfacets aligned to the halfway vector.\\n\\\n */\\n\\\nfloat GGX(float alphaRoughness, float NdotH)\\n\\\n{\\n\\\n    float alphaRoughnessSquared = alphaRoughness * alphaRoughness;\\n\\\n    float f = (NdotH * alphaRoughnessSquared - NdotH) * NdotH + 1.0;\\n\\\n    return alphaRoughnessSquared / (czm_pi * f * f);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the strength of the specular reflection due to direct lighting.\\n\\\n *\\n\\\n * @param {vec3} normal The surface normal.\\n\\\n * @param {vec3} lightDirection The unit vector pointing from the fragment to the light source.\\n\\\n * @param {vec3} viewDirection The unit vector pointing from the fragment to the camera.\\n\\\n * @param {vec3} halfwayDirection The unit vector pointing from the fragment to halfway between the light source and the camera.\\n\\\n * @param {float} alphaRoughness The roughness of the material, expressed as the square of perceptual roughness.\\n\\\n * @return {float} The strength of the specular reflection.\\n\\\n */\\n\\\nfloat computeDirectSpecularStrength(vec3 normal, vec3 lightDirection, vec3 viewDirection, vec3 halfwayDirection, float alphaRoughness)\\n\\\n{\\n\\\n    float NdotL = clamp(dot(normal, lightDirection), 0.0, 1.0);\\n\\\n    float NdotV = clamp(dot(normal, viewDirection), 0.0, 1.0);\\n\\\n    float G = smithVisibilityGGX(alphaRoughness, NdotL, NdotV);\\n\\\n    float NdotH = clamp(dot(normal, halfwayDirection), 0.0, 1.0);\\n\\\n    float D = GGX(alphaRoughness, NdotH);\\n\\\n    return G * D;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the diffuse and specular contributions using physically based\\n\\\n * rendering. This function only handles direct lighting.\\n\\\n * <p>\\n\\\n * This function only handles the lighting calculations. Metallic/roughness\\n\\\n * and specular/glossy must be handled separately. See {@MaterialStageFS}\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_pbrLighting\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} viewDirectionEC Unit vector pointing from the fragment to the eye position\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates\\n\\\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\\n\\\n * @param {czm_modelMaterial} The material properties.\\n\\\n * @return {vec3} The computed HDR color\\n\\\n */\\n\\\nvec3 czm_pbrLighting(vec3 viewDirectionEC, vec3 normalEC, vec3 lightDirectionEC, czm_modelMaterial material)\\n\\\n{\\n\\\n    vec3 halfwayDirectionEC = normalize(viewDirectionEC + lightDirectionEC);\\n\\\n    float VdotH = clamp(dot(viewDirectionEC, halfwayDirectionEC), 0.0, 1.0);\\n\\\n    float NdotL = clamp(dot(normalEC, lightDirectionEC), 0.001, 1.0);\\n\\\n\\n\\\n    vec3 f0 = material.specular;\\n\\\n    float reflectance = czm_maximumComponent(f0);\\n\\\n    // Typical dielectrics will have reflectance 0.04, so f90 will be 1.0.\\n\\\n    // In this case, at grazing angle, all incident energy is reflected.\\n\\\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\\n\\\n\\n\\\n    #if defined(USE_SPECULAR)\\n\\\n        F *= material.specularWeight;\\n\\\n    #endif\\n\\\n\\n\\\n    float alphaRoughness = material.roughness * material.roughness;\\n\\\n    #ifdef USE_ANISOTROPY\\n\\\n        mat3 tbn = mat3(material.anisotropicT, material.anisotropicB, normalEC);\\n\\\n        vec3 lightDirection = lightDirectionEC * tbn;\\n\\\n        vec3 viewDirection = viewDirectionEC * tbn;\\n\\\n        vec3 halfwayDirection = halfwayDirectionEC * tbn;\\n\\\n        float anisotropyStrength = material.anisotropyStrength;\\n\\\n        float tangentialRoughness = mix(alphaRoughness, 1.0, anisotropyStrength * anisotropyStrength);\\n\\\n        float bitangentRoughness = clamp(alphaRoughness, 0.001, 1.0);\\n\\\n        float G = smithVisibilityGGX_anisotropic(bitangentRoughness, tangentialRoughness, lightDirection, viewDirection);\\n\\\n        float D = GGX_anisotropic(bitangentRoughness, tangentialRoughness, halfwayDirection);\\n\\\n        vec3 specularContribution = F * G * D;\\n\\\n    #else\\n\\\n        float specularStrength = computeDirectSpecularStrength(normalEC, lightDirectionEC, viewDirectionEC, halfwayDirectionEC, alphaRoughness);\\n\\\n        vec3 specularContribution = F * specularStrength;\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 diffuseColor = material.diffuse;\\n\\\n    // F here represents the specular contribution\\n\\\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\\n\\\n\\n\\\n    // Lo = (diffuse + specular) * Li * NdotL\\n\\\n    return (diffuseContribution + specularContribution) * NdotL;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}