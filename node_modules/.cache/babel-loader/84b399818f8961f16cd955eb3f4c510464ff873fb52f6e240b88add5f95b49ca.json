{"ast":null,"code":"/**\n * @implements {IHooks}\n */\nclass Hooks {\n  /**\n   * @callback HookCallback\n   * @this {*|Jsep} this\n   * @param {Jsep} env\n   * @returns: void\n   */\n  /**\n   * Adds the given callback to the list of callbacks for the given hook.\n   *\n   * The callback will be invoked when the hook it is registered for is run.\n   *\n   * One callback function can be registered to multiple hooks and the same hook multiple times.\n   *\n   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\n   * @param {HookCallback|boolean} callback The callback function which is given environment variables.\n   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\n   * @public\n   */\n  add(name, callback, first) {\n    if (typeof arguments[0] != 'string') {\n      // Multiple hook callbacks, keyed by name\n      for (let name in arguments[0]) {\n        this.add(name, arguments[0][name], arguments[1]);\n      }\n    } else {\n      (Array.isArray(name) ? name : [name]).forEach(function (name) {\n        this[name] = this[name] || [];\n        if (callback) {\n          this[name][first ? 'unshift' : 'push'](callback);\n        }\n      }, this);\n    }\n  }\n\n  /**\n   * Runs a hook invoking all registered callbacks with the given environment variables.\n   *\n   * Callbacks will be invoked synchronously and in the order in which they were registered.\n   *\n   * @param {string} name The name of the hook.\n   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n   * @public\n   */\n  run(name, env) {\n    this[name] = this[name] || [];\n    this[name].forEach(function (callback) {\n      callback.call(env && env.context ? env.context : env, env);\n    });\n  }\n}\n\n/**\n * @implements {IPlugins}\n */\nclass Plugins {\n  constructor(jsep) {\n    this.jsep = jsep;\n    this.registered = {};\n  }\n\n  /**\n   * @callback PluginSetup\n   * @this {Jsep} jsep\n   * @returns: void\n   */\n  /**\n   * Adds the given plugin(s) to the registry\n   *\n   * @param {object} plugins\n   * @param {string} plugins.name The name of the plugin\n   * @param {PluginSetup} plugins.init The init function\n   * @public\n   */\n  register(...plugins) {\n    plugins.forEach(plugin => {\n      if (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n        throw new Error('Invalid JSEP plugin format');\n      }\n      if (this.registered[plugin.name]) {\n        // already registered. Ignore.\n        return;\n      }\n      plugin.init(this.jsep);\n      this.registered[plugin.name] = plugin;\n    });\n  }\n}\n\n//     JavaScript Expression Parser (JSEP) 1.4.0\n\nclass Jsep {\n  /**\n   * @returns {string}\n   */\n  static get version() {\n    // To be filled in by the template\n    return '1.4.0';\n  }\n\n  /**\n   * @returns {string}\n   */\n  static toString() {\n    return 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\n  }\n  // ==================== CONFIG ================================\n  /**\n   * @method addUnaryOp\n   * @param {string} op_name The name of the unary op to add\n   * @returns {Jsep}\n   */\n  static addUnaryOp(op_name) {\n    Jsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\n    Jsep.unary_ops[op_name] = 1;\n    return Jsep;\n  }\n\n  /**\n   * @method jsep.addBinaryOp\n   * @param {string} op_name The name of the binary op to add\n   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\n   * @param {boolean} [isRightAssociative=false] whether operator is right-associative\n   * @returns {Jsep}\n   */\n  static addBinaryOp(op_name, precedence, isRightAssociative) {\n    Jsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\n    Jsep.binary_ops[op_name] = precedence;\n    if (isRightAssociative) {\n      Jsep.right_associative.add(op_name);\n    } else {\n      Jsep.right_associative.delete(op_name);\n    }\n    return Jsep;\n  }\n\n  /**\n   * @method addIdentifierChar\n   * @param {string} char The additional character to treat as a valid part of an identifier\n   * @returns {Jsep}\n   */\n  static addIdentifierChar(char) {\n    Jsep.additional_identifier_chars.add(char);\n    return Jsep;\n  }\n\n  /**\n   * @method addLiteral\n   * @param {string} literal_name The name of the literal to add\n   * @param {*} literal_value The value of the literal\n   * @returns {Jsep}\n   */\n  static addLiteral(literal_name, literal_value) {\n    Jsep.literals[literal_name] = literal_value;\n    return Jsep;\n  }\n\n  /**\n   * @method removeUnaryOp\n   * @param {string} op_name The name of the unary op to remove\n   * @returns {Jsep}\n   */\n  static removeUnaryOp(op_name) {\n    delete Jsep.unary_ops[op_name];\n    if (op_name.length === Jsep.max_unop_len) {\n      Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\n    }\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllUnaryOps\n   * @returns {Jsep}\n   */\n  static removeAllUnaryOps() {\n    Jsep.unary_ops = {};\n    Jsep.max_unop_len = 0;\n    return Jsep;\n  }\n\n  /**\n   * @method removeIdentifierChar\n   * @param {string} char The additional character to stop treating as a valid part of an identifier\n   * @returns {Jsep}\n   */\n  static removeIdentifierChar(char) {\n    Jsep.additional_identifier_chars.delete(char);\n    return Jsep;\n  }\n\n  /**\n   * @method removeBinaryOp\n   * @param {string} op_name The name of the binary op to remove\n   * @returns {Jsep}\n   */\n  static removeBinaryOp(op_name) {\n    delete Jsep.binary_ops[op_name];\n    if (op_name.length === Jsep.max_binop_len) {\n      Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n    }\n    Jsep.right_associative.delete(op_name);\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllBinaryOps\n   * @returns {Jsep}\n   */\n  static removeAllBinaryOps() {\n    Jsep.binary_ops = {};\n    Jsep.max_binop_len = 0;\n    return Jsep;\n  }\n\n  /**\n   * @method removeLiteral\n   * @param {string} literal_name The name of the literal to remove\n   * @returns {Jsep}\n   */\n  static removeLiteral(literal_name) {\n    delete Jsep.literals[literal_name];\n    return Jsep;\n  }\n\n  /**\n   * @method removeAllLiterals\n   * @returns {Jsep}\n   */\n  static removeAllLiterals() {\n    Jsep.literals = {};\n    return Jsep;\n  }\n  // ==================== END CONFIG ============================\n\n  /**\n   * @returns {string}\n   */\n  get char() {\n    return this.expr.charAt(this.index);\n  }\n\n  /**\n   * @returns {number}\n   */\n  get code() {\n    return this.expr.charCodeAt(this.index);\n  }\n  /**\n   * @param {string} expr a string with the passed in express\n   * @returns Jsep\n   */\n  constructor(expr) {\n    // `index` stores the character number we are currently at\n    // All of the gobbles below will modify `index` as we move along\n    this.expr = expr;\n    this.index = 0;\n  }\n\n  /**\n   * static top-level parser\n   * @returns {jsep.Expression}\n   */\n  static parse(expr) {\n    return new Jsep(expr).parse();\n  }\n\n  /**\n   * Get the longest key length of any object\n   * @param {object} obj\n   * @returns {number}\n   */\n  static getMaxKeyLen(obj) {\n    return Math.max(0, ...Object.keys(obj).map(k => k.length));\n  }\n\n  /**\n   * `ch` is a character code in the next three functions\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0...9\n  }\n\n  /**\n   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\n   * @param {string} op_val\n   * @returns {number}\n   */\n  static binaryPrecedence(op_val) {\n    return Jsep.binary_ops[op_val] || 0;\n  }\n\n  /**\n   * Looks for start of identifier\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isIdentifierStart(ch) {\n    return ch >= 65 && ch <= 90 ||\n    // A...Z\n    ch >= 97 && ch <= 122 ||\n    // a...z\n    ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)] ||\n    // any non-ASCII that is not an operator\n    Jsep.additional_identifier_chars.has(String.fromCharCode(ch)); // additional characters\n  }\n\n  /**\n   * @param {number} ch\n   * @returns {boolean}\n   */\n  static isIdentifierPart(ch) {\n    return Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\n  }\n\n  /**\n   * throw error at index of the expression\n   * @param {string} message\n   * @throws\n   */\n  throwError(message) {\n    const error = new Error(message + ' at character ' + this.index);\n    error.index = this.index;\n    error.description = message;\n    throw error;\n  }\n\n  /**\n   * Run a given hook\n   * @param {string} name\n   * @param {jsep.Expression|false} [node]\n   * @returns {?jsep.Expression}\n   */\n  runHook(name, node) {\n    if (Jsep.hooks[name]) {\n      const env = {\n        context: this,\n        node\n      };\n      Jsep.hooks.run(name, env);\n      return env.node;\n    }\n    return node;\n  }\n\n  /**\n   * Runs a given hook until one returns a node\n   * @param {string} name\n   * @returns {?jsep.Expression}\n   */\n  searchHook(name) {\n    if (Jsep.hooks[name]) {\n      const env = {\n        context: this\n      };\n      Jsep.hooks[name].find(function (callback) {\n        callback.call(env.context, env);\n        return env.node;\n      });\n      return env.node;\n    }\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  gobbleSpaces() {\n    let ch = this.code;\n    // Whitespace\n    while (ch === Jsep.SPACE_CODE || ch === Jsep.TAB_CODE || ch === Jsep.LF_CODE || ch === Jsep.CR_CODE) {\n      ch = this.expr.charCodeAt(++this.index);\n    }\n    this.runHook('gobble-spaces');\n  }\n\n  /**\n   * Top-level method to parse all expressions and returns compound or single node\n   * @returns {jsep.Expression}\n   */\n  parse() {\n    this.runHook('before-all');\n    const nodes = this.gobbleExpressions();\n\n    // If there's only one expression just try returning the expression\n    const node = nodes.length === 1 ? nodes[0] : {\n      type: Jsep.COMPOUND,\n      body: nodes\n    };\n    return this.runHook('after-all', node);\n  }\n\n  /**\n   * top-level parser (but can be reused within as well)\n   * @param {number} [untilICode]\n   * @returns {jsep.Expression[]}\n   */\n  gobbleExpressions(untilICode) {\n    let nodes = [],\n      ch_i,\n      node;\n    while (this.index < this.expr.length) {\n      ch_i = this.code;\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n        this.index++; // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        if (node = this.gobbleExpression()) {\n          nodes.push(node);\n          // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n        } else if (this.index < this.expr.length) {\n          if (ch_i === untilICode) {\n            break;\n          }\n          this.throwError('Unexpected \"' + this.char + '\"');\n        }\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * The main parsing function.\n   * @returns {?jsep.Expression}\n   */\n  gobbleExpression() {\n    const node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\n    this.gobbleSpaces();\n    return this.runHook('after-expression', node);\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   * @returns {string|boolean}\n   */\n  gobbleBinaryOp() {\n    this.gobbleSpaces();\n    let to_check = this.expr.substr(this.index, Jsep.max_binop_len);\n    let tc_len = to_check.length;\n    while (tc_len > 0) {\n      // Don't accept a binary op when it is an identifier.\n      // Binary ops that start with a identifier-valid character must be followed\n      // by a non identifier-part valid character\n      if (Jsep.binary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {\n        this.index += tc_len;\n        return to_check;\n      }\n      to_check = to_check.substr(0, --tc_len);\n    }\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   * @returns {?jsep.BinaryExpression}\n   */\n  gobbleBinaryExpression() {\n    let node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    // Don't gobbleBinaryOp without a left-hand-side\n    left = this.gobbleToken();\n    if (!left) {\n      return left;\n    }\n    biop = this.gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    biop_info = {\n      value: biop,\n      prec: Jsep.binaryPrecedence(biop),\n      right_a: Jsep.right_associative.has(biop)\n    };\n    right = this.gobbleToken();\n    if (!right) {\n      this.throwError(\"Expected expression after \" + biop);\n    }\n    stack = [left, biop_info, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    while (biop = this.gobbleBinaryOp()) {\n      prec = Jsep.binaryPrecedence(biop);\n      if (prec === 0) {\n        this.index -= biop.length;\n        break;\n      }\n      biop_info = {\n        value: biop,\n        prec,\n        right_a: Jsep.right_associative.has(biop)\n      };\n      cur_biop = biop;\n\n      // Reduce: make a binary expression from the three topmost entries.\n      const comparePrev = prev => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;\n      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = {\n          type: Jsep.BINARY_EXP,\n          operator: biop,\n          left,\n          right\n        };\n        stack.push(node);\n      }\n      node = this.gobbleToken();\n      if (!node) {\n        this.throwError(\"Expected expression after \" + cur_biop);\n      }\n      stack.push(biop_info, node);\n    }\n    i = stack.length - 1;\n    node = stack[i];\n    while (i > 1) {\n      node = {\n        type: Jsep.BINARY_EXP,\n        operator: stack[i - 1].value,\n        left: stack[i - 2],\n        right: node\n      };\n      i -= 2;\n    }\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   * @returns {boolean|jsep.Expression}\n   */\n  gobbleToken() {\n    let ch, to_check, tc_len, node;\n    this.gobbleSpaces();\n    node = this.searchHook('gobble-token');\n    if (node) {\n      return this.runHook('after-token', node);\n    }\n    ch = this.code;\n    if (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return this.gobbleNumericLiteral();\n    }\n    if (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n      // Single or double quotes\n      node = this.gobbleStringLiteral();\n    } else if (ch === Jsep.OBRACK_CODE) {\n      node = this.gobbleArray();\n    } else {\n      to_check = this.expr.substr(this.index, Jsep.max_unop_len);\n      tc_len = to_check.length;\n      while (tc_len > 0) {\n        // Don't accept an unary op when it is an identifier.\n        // Unary ops that start with a identifier-valid character must be followed\n        // by a non identifier-part valid character\n        if (Jsep.unary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {\n          this.index += tc_len;\n          const argument = this.gobbleToken();\n          if (!argument) {\n            this.throwError('missing unaryOp argument');\n          }\n          return this.runHook('after-token', {\n            type: Jsep.UNARY_EXP,\n            operator: to_check,\n            argument,\n            prefix: true\n          });\n        }\n        to_check = to_check.substr(0, --tc_len);\n      }\n      if (Jsep.isIdentifierStart(ch)) {\n        node = this.gobbleIdentifier();\n        if (Jsep.literals.hasOwnProperty(node.name)) {\n          node = {\n            type: Jsep.LITERAL,\n            value: Jsep.literals[node.name],\n            raw: node.name\n          };\n        } else if (node.name === Jsep.this_str) {\n          node = {\n            type: Jsep.THIS_EXP\n          };\n        }\n      } else if (ch === Jsep.OPAREN_CODE) {\n        // open parenthesis\n        node = this.gobbleGroup();\n      }\n    }\n    if (!node) {\n      return this.runHook('after-token', false);\n    }\n    node = this.gobbleTokenProperty(node);\n    return this.runHook('after-token', node);\n  }\n\n  /**\n   * Gobble properties of of identifiers/strings/arrays/groups.\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   * @param {jsep.Expression} node\n   * @returns {jsep.Expression}\n   */\n  gobbleTokenProperty(node) {\n    this.gobbleSpaces();\n    let ch = this.code;\n    while (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n      let optional;\n      if (ch === Jsep.QUMARK_CODE) {\n        if (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n          break;\n        }\n        optional = true;\n        this.index += 2;\n        this.gobbleSpaces();\n        ch = this.code;\n      }\n      this.index++;\n      if (ch === Jsep.OBRACK_CODE) {\n        node = {\n          type: Jsep.MEMBER_EXP,\n          computed: true,\n          object: node,\n          property: this.gobbleExpression()\n        };\n        if (!node.property) {\n          this.throwError('Unexpected \"' + this.char + '\"');\n        }\n        this.gobbleSpaces();\n        ch = this.code;\n        if (ch !== Jsep.CBRACK_CODE) {\n          this.throwError('Unclosed [');\n        }\n        this.index++;\n      } else if (ch === Jsep.OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          type: Jsep.CALL_EXP,\n          'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n          callee: node\n        };\n      } else if (ch === Jsep.PERIOD_CODE || optional) {\n        if (optional) {\n          this.index--;\n        }\n        this.gobbleSpaces();\n        node = {\n          type: Jsep.MEMBER_EXP,\n          computed: false,\n          object: node,\n          property: this.gobbleIdentifier()\n        };\n      }\n      if (optional) {\n        node.optional = true;\n      } // else leave undefined for compatibility with esprima\n\n      this.gobbleSpaces();\n      ch = this.code;\n    }\n    return node;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   * @returns {jsep.Literal}\n   */\n  gobbleNumericLiteral() {\n    let number = '',\n      ch,\n      chCode;\n    while (Jsep.isDecimalDigit(this.code)) {\n      number += this.expr.charAt(this.index++);\n    }\n    if (this.code === Jsep.PERIOD_CODE) {\n      // can start with a decimal marker\n      number += this.expr.charAt(this.index++);\n      while (Jsep.isDecimalDigit(this.code)) {\n        number += this.expr.charAt(this.index++);\n      }\n    }\n    ch = this.char;\n    if (ch === 'e' || ch === 'E') {\n      // exponent marker\n      number += this.expr.charAt(this.index++);\n      ch = this.char;\n      if (ch === '+' || ch === '-') {\n        // exponent sign\n        number += this.expr.charAt(this.index++);\n      }\n      while (Jsep.isDecimalDigit(this.code)) {\n        // exponent itself\n        number += this.expr.charAt(this.index++);\n      }\n      if (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {\n        this.throwError('Expected exponent (' + number + this.char + ')');\n      }\n    }\n    chCode = this.code;\n\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (Jsep.isIdentifierStart(chCode)) {\n      this.throwError('Variable names cannot start with a number (' + number + this.char + ')');\n    } else if (chCode === Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE) {\n      this.throwError('Unexpected period');\n    }\n    return {\n      type: Jsep.LITERAL,\n      value: parseFloat(number),\n      raw: number\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   * @returns {jsep.Literal}\n   */\n  gobbleStringLiteral() {\n    let str = '';\n    const startIndex = this.index;\n    const quote = this.expr.charAt(this.index++);\n    let closed = false;\n    while (this.index < this.expr.length) {\n      let ch = this.expr.charAt(this.index++);\n      if (ch === quote) {\n        closed = true;\n        break;\n      } else if (ch === '\\\\') {\n        // Check for all of the common escape codes\n        ch = this.expr.charAt(this.index++);\n        switch (ch) {\n          case 'n':\n            str += '\\n';\n            break;\n          case 'r':\n            str += '\\r';\n            break;\n          case 't':\n            str += '\\t';\n            break;\n          case 'b':\n            str += '\\b';\n            break;\n          case 'f':\n            str += '\\f';\n            break;\n          case 'v':\n            str += '\\x0B';\n            break;\n          default:\n            str += ch;\n        }\n      } else {\n        str += ch;\n      }\n    }\n    if (!closed) {\n      this.throwError('Unclosed quote after \"' + str + '\"');\n    }\n    return {\n      type: Jsep.LITERAL,\n      value: str,\n      raw: this.expr.substring(startIndex, this.index)\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   * @returns {jsep.Identifier}\n   */\n  gobbleIdentifier() {\n    let ch = this.code,\n      start = this.index;\n    if (Jsep.isIdentifierStart(ch)) {\n      this.index++;\n    } else {\n      this.throwError('Unexpected ' + this.char);\n    }\n    while (this.index < this.expr.length) {\n      ch = this.code;\n      if (Jsep.isIdentifierPart(ch)) {\n        this.index++;\n      } else {\n        break;\n      }\n    }\n    return {\n      type: Jsep.IDENTIFIER,\n      name: this.expr.slice(start, this.index)\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   * @param {number} termination\n   * @returns {jsep.Expression[]}\n   */\n  gobbleArguments(termination) {\n    const args = [];\n    let closed = false;\n    let separator_count = 0;\n    while (this.index < this.expr.length) {\n      this.gobbleSpaces();\n      let ch_i = this.code;\n      if (ch_i === termination) {\n        // done parsing\n        closed = true;\n        this.index++;\n        if (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {\n          this.throwError('Unexpected token ' + String.fromCharCode(termination));\n        }\n        break;\n      } else if (ch_i === Jsep.COMMA_CODE) {\n        // between expressions\n        this.index++;\n        separator_count++;\n        if (separator_count !== args.length) {\n          // missing argument\n          if (termination === Jsep.CPAREN_CODE) {\n            this.throwError('Unexpected token ,');\n          } else if (termination === Jsep.CBRACK_CODE) {\n            for (let arg = args.length; arg < separator_count; arg++) {\n              args.push(null);\n            }\n          }\n        }\n      } else if (args.length !== separator_count && separator_count !== 0) {\n        // NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n        this.throwError('Expected comma');\n      } else {\n        const node = this.gobbleExpression();\n        if (!node || node.type === Jsep.COMPOUND) {\n          this.throwError('Expected comma');\n        }\n        args.push(node);\n      }\n    }\n    if (!closed) {\n      this.throwError('Expected ' + String.fromCharCode(termination));\n    }\n    return args;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * that have no identifier in front (so not a function call)\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   * @returns {boolean|jsep.Expression}\n   */\n  gobbleGroup() {\n    this.index++;\n    let nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\n    if (this.code === Jsep.CPAREN_CODE) {\n      this.index++;\n      if (nodes.length === 1) {\n        return nodes[0];\n      } else if (!nodes.length) {\n        return false;\n      } else {\n        return {\n          type: Jsep.SEQUENCE_EXP,\n          expressions: nodes\n        };\n      }\n    } else {\n      this.throwError('Unclosed (');\n    }\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   * @returns {jsep.ArrayExpression}\n   */\n  gobbleArray() {\n    this.index++;\n    return {\n      type: Jsep.ARRAY_EXP,\n      elements: this.gobbleArguments(Jsep.CBRACK_CODE)\n    };\n  }\n}\n\n// Static fields:\nconst hooks = new Hooks();\nObject.assign(Jsep, {\n  hooks,\n  plugins: new Plugins(Jsep),\n  // Node Types\n  // ----------\n  // This is the full set of types that any JSEP node can be.\n  // Store them here to save space when minified\n  COMPOUND: 'Compound',\n  SEQUENCE_EXP: 'SequenceExpression',\n  IDENTIFIER: 'Identifier',\n  MEMBER_EXP: 'MemberExpression',\n  LITERAL: 'Literal',\n  THIS_EXP: 'ThisExpression',\n  CALL_EXP: 'CallExpression',\n  UNARY_EXP: 'UnaryExpression',\n  BINARY_EXP: 'BinaryExpression',\n  ARRAY_EXP: 'ArrayExpression',\n  TAB_CODE: 9,\n  LF_CODE: 10,\n  CR_CODE: 13,\n  SPACE_CODE: 32,\n  PERIOD_CODE: 46,\n  // '.'\n  COMMA_CODE: 44,\n  // ','\n  SQUOTE_CODE: 39,\n  // single quote\n  DQUOTE_CODE: 34,\n  // double quotes\n  OPAREN_CODE: 40,\n  // (\n  CPAREN_CODE: 41,\n  // )\n  OBRACK_CODE: 91,\n  // [\n  CBRACK_CODE: 93,\n  // ]\n  QUMARK_CODE: 63,\n  // ?\n  SEMCOL_CODE: 59,\n  // ;\n  COLON_CODE: 58,\n  // :\n\n  // Operations\n  // ----------\n  // Use a quickly-accessible map to store all of the unary operators\n  // Values are set to `1` (it really doesn't matter)\n  unary_ops: {\n    '-': 1,\n    '!': 1,\n    '~': 1,\n    '+': 1\n  },\n  // Also use a map for the binary operations but set their values to their\n  // binary precedence for quick reference (higher number = higher precedence)\n  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n  binary_ops: {\n    '||': 1,\n    '??': 1,\n    '&&': 2,\n    '|': 3,\n    '^': 4,\n    '&': 5,\n    '==': 6,\n    '!=': 6,\n    '===': 6,\n    '!==': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '<<': 8,\n    '>>': 8,\n    '>>>': 8,\n    '+': 9,\n    '-': 9,\n    '*': 10,\n    '/': 10,\n    '%': 10,\n    '**': 11\n  },\n  // sets specific binary_ops as right-associative\n  right_associative: new Set(['**']),\n  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n  additional_identifier_chars: new Set(['$', '_']),\n  // Literals\n  // ----------\n  // Store the values to return for the various literals we may encounter\n  literals: {\n    'true': true,\n    'false': false,\n    'null': null\n  },\n  // Except for `this`, which is special. This could be changed to something like `'self'` as well\n  this_str: 'this'\n});\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\n// Backward Compatibility:\nconst jsep = expr => new Jsep(expr).parse();\nconst stdClassProps = Object.getOwnPropertyNames(class Test {});\nObject.getOwnPropertyNames(Jsep).filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined).forEach(m => {\n  jsep[m] = Jsep[m];\n});\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\n\nconst CONDITIONAL_EXP = 'ConditionalExpression';\nvar ternary = {\n  name: 'ternary',\n  init(jsep) {\n    // Ternary expression: test ? consequent : alternate\n    jsep.hooks.add('after-expression', function gobbleTernary(env) {\n      if (env.node && this.code === jsep.QUMARK_CODE) {\n        this.index++;\n        const test = env.node;\n        const consequent = this.gobbleExpression();\n        if (!consequent) {\n          this.throwError('Expected expression');\n        }\n        this.gobbleSpaces();\n        if (this.code === jsep.COLON_CODE) {\n          this.index++;\n          const alternate = this.gobbleExpression();\n          if (!alternate) {\n            this.throwError('Expected expression');\n          }\n          env.node = {\n            type: CONDITIONAL_EXP,\n            test,\n            consequent,\n            alternate\n          };\n\n          // check for operators of higher priority than ternary (i.e. assignment)\n          // jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n          if (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n            let newTest = test;\n            while (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n              newTest = newTest.right;\n            }\n            env.node.test = newTest.right;\n            newTest.right = env.node;\n            env.node = test;\n          }\n        } else {\n          this.throwError('Expected :');\n        }\n      }\n    });\n  }\n};\n\n// Add default plugins:\n\njsep.plugins.register(ternary);\nexport { Jsep, jsep as default };","map":{"version":3,"names":["Hooks","add","name","callback","first","arguments","Array","isArray","forEach","run","env","call","context","Plugins","constructor","jsep","registered","register","plugins","plugin","init","Error","Jsep","version","toString","addUnaryOp","op_name","max_unop_len","Math","max","length","unary_ops","addBinaryOp","precedence","isRightAssociative","max_binop_len","binary_ops","right_associative","delete","addIdentifierChar","char","additional_identifier_chars","addLiteral","literal_name","literal_value","literals","removeUnaryOp","getMaxKeyLen","removeAllUnaryOps","removeIdentifierChar","removeBinaryOp","removeAllBinaryOps","removeLiteral","removeAllLiterals","expr","charAt","index","code","charCodeAt","parse","obj","Object","keys","map","k","isDecimalDigit","ch","binaryPrecedence","op_val","isIdentifierStart","String","fromCharCode","has","isIdentifierPart","throwError","message","error","description","runHook","node","hooks","searchHook","find","gobbleSpaces","SPACE_CODE","TAB_CODE","LF_CODE","CR_CODE","nodes","gobbleExpressions","type","COMPOUND","body","untilICode","ch_i","SEMCOL_CODE","COMMA_CODE","gobbleExpression","push","gobbleBinaryExpression","gobbleBinaryOp","to_check","substr","tc_len","hasOwnProperty","biop","prec","stack","biop_info","left","right","i","cur_biop","gobbleToken","value","right_a","comparePrev","prev","pop","BINARY_EXP","operator","PERIOD_CODE","gobbleNumericLiteral","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","OBRACK_CODE","gobbleArray","argument","UNARY_EXP","prefix","gobbleIdentifier","LITERAL","raw","this_str","THIS_EXP","OPAREN_CODE","gobbleGroup","gobbleTokenProperty","QUMARK_CODE","optional","MEMBER_EXP","computed","object","property","CBRACK_CODE","CALL_EXP","gobbleArguments","CPAREN_CODE","callee","number","chCode","parseFloat","str","startIndex","quote","closed","substring","start","IDENTIFIER","slice","termination","args","separator_count","arg","SEQUENCE_EXP","expressions","ARRAY_EXP","elements","assign","COLON_CODE","Set","stdClassProps","getOwnPropertyNames","Test","filter","prop","includes","undefined","m","CONDITIONAL_EXP","ternary","gobbleTernary","test","consequent","alternate","newTest","default"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/jsep/dist/jsep.js"],"sourcesContent":["/**\n * @implements {IHooks}\n */\nclass Hooks {\n\t/**\n\t * @callback HookCallback\n\t * @this {*|Jsep} this\n\t * @param {Jsep} env\n\t * @returns: void\n\t */\n\t/**\n\t * Adds the given callback to the list of callbacks for the given hook.\n\t *\n\t * The callback will be invoked when the hook it is registered for is run.\n\t *\n\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t *\n\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\n\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\n\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\n\t * @public\n\t */\n\tadd(name, callback, first) {\n\t\tif (typeof arguments[0] != 'string') {\n\t\t\t// Multiple hook callbacks, keyed by name\n\t\t\tfor (let name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\n\t\t\t\tthis[name] = this[name] || [];\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tthis[name][first ? 'unshift' : 'push'](callback);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t/**\n\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t *\n\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t *\n\t * @param {string} name The name of the hook.\n\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t * @public\n\t */\n\trun(name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function (callback) {\n\t\t\tcallback.call(env && env.context ? env.context : env, env);\n\t\t});\n\t}\n}\n\n/**\n * @implements {IPlugins}\n */\nclass Plugins {\n\tconstructor(jsep) {\n\t\tthis.jsep = jsep;\n\t\tthis.registered = {};\n\t}\n\n\t/**\n\t * @callback PluginSetup\n\t * @this {Jsep} jsep\n\t * @returns: void\n\t */\n\t/**\n\t * Adds the given plugin(s) to the registry\n\t *\n\t * @param {object} plugins\n\t * @param {string} plugins.name The name of the plugin\n\t * @param {PluginSetup} plugins.init The init function\n\t * @public\n\t */\n\tregister(...plugins) {\n\t\tplugins.forEach((plugin) => {\n\t\t\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n\t\t\t\tthrow new Error('Invalid JSEP plugin format');\n\t\t\t}\n\t\t\tif (this.registered[plugin.name]) {\n\t\t\t\t// already registered. Ignore.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplugin.init(this.jsep);\n\t\t\tthis.registered[plugin.name] = plugin;\n\t\t});\n\t}\n}\n\n//     JavaScript Expression Parser (JSEP) 1.4.0\n\nclass Jsep {\n\t/**\n\t * @returns {string}\n\t */\n\tstatic get version() {\n\t\t// To be filled in by the template\n\t\treturn '1.4.0';\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tstatic toString() {\n\t\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\n\t};\n\n\t// ==================== CONFIG ================================\n\t/**\n\t * @method addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @returns {Jsep}\n\t */\n\tstatic addUnaryOp(op_name) {\n\t\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\n\t\tJsep.unary_ops[op_name] = 1;\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\n\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\n\t * @returns {Jsep}\n\t */\n\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\n\t\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\n\t\tJsep.binary_ops[op_name] = precedence;\n\t\tif (isRightAssociative) {\n\t\t\tJsep.right_associative.add(op_name);\n\t\t}\n\t\telse {\n\t\t\tJsep.right_associative.delete(op_name);\n\t\t}\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method addIdentifierChar\n\t * @param {string} char The additional character to treat as a valid part of an identifier\n\t * @returns {Jsep}\n\t */\n\tstatic addIdentifierChar(char) {\n\t\tJsep.additional_identifier_chars.add(char);\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method addLiteral\n\t * @param {string} literal_name The name of the literal to add\n\t * @param {*} literal_value The value of the literal\n\t * @returns {Jsep}\n\t */\n\tstatic addLiteral(literal_name, literal_value) {\n\t\tJsep.literals[literal_name] = literal_value;\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeUnaryOp(op_name) {\n\t\tdelete Jsep.unary_ops[op_name];\n\t\tif (op_name.length === Jsep.max_unop_len) {\n\t\t\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\n\t\t}\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllUnaryOps\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllUnaryOps() {\n\t\tJsep.unary_ops = {};\n\t\tJsep.max_unop_len = 0;\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeIdentifierChar\n\t * @param {string} char The additional character to stop treating as a valid part of an identifier\n\t * @returns {Jsep}\n\t */\n\tstatic removeIdentifierChar(char) {\n\t\tJsep.additional_identifier_chars.delete(char);\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeBinaryOp(op_name) {\n\t\tdelete Jsep.binary_ops[op_name];\n\n\t\tif (op_name.length === Jsep.max_binop_len) {\n\t\t\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\t\t}\n\t\tJsep.right_associative.delete(op_name);\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllBinaryOps\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllBinaryOps() {\n\t\tJsep.binary_ops = {};\n\t\tJsep.max_binop_len = 0;\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeLiteral\n\t * @param {string} literal_name The name of the literal to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeLiteral(literal_name) {\n\t\tdelete Jsep.literals[literal_name];\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllLiterals\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllLiterals() {\n\t\tJsep.literals = {};\n\n\t\treturn Jsep;\n\t}\n\t// ==================== END CONFIG ============================\n\n\n\t/**\n\t * @returns {string}\n\t */\n\tget char() {\n\t\treturn this.expr.charAt(this.index);\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget code() {\n\t\treturn this.expr.charCodeAt(this.index);\n\t};\n\n\n\t/**\n\t * @param {string} expr a string with the passed in express\n\t * @returns Jsep\n\t */\n\tconstructor(expr) {\n\t\t// `index` stores the character number we are currently at\n\t\t// All of the gobbles below will modify `index` as we move along\n\t\tthis.expr = expr;\n\t\tthis.index = 0;\n\t}\n\n\t/**\n\t * static top-level parser\n\t * @returns {jsep.Expression}\n\t */\n\tstatic parse(expr) {\n\t\treturn (new Jsep(expr)).parse();\n\t}\n\n\t/**\n\t * Get the longest key length of any object\n\t * @param {object} obj\n\t * @returns {number}\n\t */\n\tstatic getMaxKeyLen(obj) {\n\t\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\n\t}\n\n\t/**\n\t * `ch` is a character code in the next three functions\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isDecimalDigit(ch) {\n\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t}\n\n\t/**\n\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\n\t * @param {string} op_val\n\t * @returns {number}\n\t */\n\tstatic binaryPrecedence(op_val) {\n\t\treturn Jsep.binary_ops[op_val] || 0;\n\t}\n\n\t/**\n\t * Looks for start of identifier\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isIdentifierStart(ch) {\n\t\treturn  (ch >= 65 && ch <= 90) || // A...Z\n\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\n\t\t\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\n\t}\n\n\t/**\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isIdentifierPart(ch) {\n\t\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\n\t}\n\n\t/**\n\t * throw error at index of the expression\n\t * @param {string} message\n\t * @throws\n\t */\n\tthrowError(message) {\n\t\tconst error = new Error(message + ' at character ' + this.index);\n\t\terror.index = this.index;\n\t\terror.description = message;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * Run a given hook\n\t * @param {string} name\n\t * @param {jsep.Expression|false} [node]\n\t * @returns {?jsep.Expression}\n\t */\n\trunHook(name, node) {\n\t\tif (Jsep.hooks[name]) {\n\t\t\tconst env = { context: this, node };\n\t\t\tJsep.hooks.run(name, env);\n\t\t\treturn env.node;\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Runs a given hook until one returns a node\n\t * @param {string} name\n\t * @returns {?jsep.Expression}\n\t */\n\tsearchHook(name) {\n\t\tif (Jsep.hooks[name]) {\n\t\t\tconst env = { context: this };\n\t\t\tJsep.hooks[name].find(function (callback) {\n\t\t\t\tcallback.call(env.context, env);\n\t\t\t\treturn env.node;\n\t\t\t});\n\t\t\treturn env.node;\n\t\t}\n\t}\n\n\t/**\n\t * Push `index` up to the next non-space character\n\t */\n\tgobbleSpaces() {\n\t\tlet ch = this.code;\n\t\t// Whitespace\n\t\twhile (ch === Jsep.SPACE_CODE\n\t\t|| ch === Jsep.TAB_CODE\n\t\t|| ch === Jsep.LF_CODE\n\t\t|| ch === Jsep.CR_CODE) {\n\t\t\tch = this.expr.charCodeAt(++this.index);\n\t\t}\n\t\tthis.runHook('gobble-spaces');\n\t}\n\n\t/**\n\t * Top-level method to parse all expressions and returns compound or single node\n\t * @returns {jsep.Expression}\n\t */\n\tparse() {\n\t\tthis.runHook('before-all');\n\t\tconst nodes = this.gobbleExpressions();\n\n\t\t// If there's only one expression just try returning the expression\n\t\tconst node = nodes.length === 1\n\t\t  ? nodes[0]\n\t\t\t: {\n\t\t\t\ttype: Jsep.COMPOUND,\n\t\t\t\tbody: nodes\n\t\t\t};\n\t\treturn this.runHook('after-all', node);\n\t}\n\n\t/**\n\t * top-level parser (but can be reused within as well)\n\t * @param {number} [untilICode]\n\t * @returns {jsep.Expression[]}\n\t */\n\tgobbleExpressions(untilICode) {\n\t\tlet nodes = [], ch_i, node;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tch_i = this.code;\n\n\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t// separators\n\t\t\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n\t\t\t\tthis.index++; // ignore separators\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try to gobble each expression individually\n\t\t\t\tif (node = this.gobbleExpression()) {\n\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t}\n\t\t\t\telse if (this.index < this.expr.length) {\n\t\t\t\t\tif (ch_i === untilICode) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.throwError('Unexpected \"' + this.char + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * The main parsing function.\n\t * @returns {?jsep.Expression}\n\t */\n\tgobbleExpression() {\n\t\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\n\t\tthis.gobbleSpaces();\n\n\t\treturn this.runHook('after-expression', node);\n\t}\n\n\t/**\n\t * Search for the operation portion of the string (e.g. `+`, `===`)\n\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t * then, return that binary operation\n\t * @returns {string|boolean}\n\t */\n\tgobbleBinaryOp() {\n\t\tthis.gobbleSpaces();\n\t\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\n\t\tlet tc_len = to_check.length;\n\n\t\twhile (tc_len > 0) {\n\t\t\t// Don't accept a binary op when it is an identifier.\n\t\t\t// Binary ops that start with a identifier-valid character must be followed\n\t\t\t// by a non identifier-part valid character\n\t\t\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t!Jsep.isIdentifierStart(this.code) ||\n\t\t\t\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n\t\t\t)) {\n\t\t\t\tthis.index += tc_len;\n\t\t\t\treturn to_check;\n\t\t\t}\n\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This function is responsible for gobbling an individual expression,\n\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t * @returns {?jsep.BinaryExpression}\n\t */\n\tgobbleBinaryExpression() {\n\t\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n\t\t// First, try to get the leftmost thing\n\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t// Don't gobbleBinaryOp without a left-hand-side\n\t\tleft = this.gobbleToken();\n\t\tif (!left) {\n\t\t\treturn left;\n\t\t}\n\t\tbiop = this.gobbleBinaryOp();\n\n\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\tif (!biop) {\n\t\t\treturn left;\n\t\t}\n\n\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t// precedence structure\n\t\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\n\n\t\tright = this.gobbleToken();\n\n\t\tif (!right) {\n\t\t\tthis.throwError(\"Expected expression after \" + biop);\n\t\t}\n\n\t\tstack = [left, biop_info, right];\n\n\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\twhile ((biop = this.gobbleBinaryOp())) {\n\t\t\tprec = Jsep.binaryPrecedence(biop);\n\n\t\t\tif (prec === 0) {\n\t\t\t\tthis.index -= biop.length;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\n\n\t\t\tcur_biop = biop;\n\n\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\tconst comparePrev = prev => biop_info.right_a && prev.right_a\n\t\t\t\t? prec > prev.prec\n\t\t\t\t: prec <= prev.prec;\n\t\t\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\n\t\t\t\tright = stack.pop();\n\t\t\t\tbiop = stack.pop().value;\n\t\t\t\tleft = stack.pop();\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.BINARY_EXP,\n\t\t\t\t\toperator: biop,\n\t\t\t\t\tleft,\n\t\t\t\t\tright\n\t\t\t\t};\n\t\t\t\tstack.push(node);\n\t\t\t}\n\n\t\t\tnode = this.gobbleToken();\n\n\t\t\tif (!node) {\n\t\t\t\tthis.throwError(\"Expected expression after \" + cur_biop);\n\t\t\t}\n\n\t\t\tstack.push(biop_info, node);\n\t\t}\n\n\t\ti = stack.length - 1;\n\t\tnode = stack[i];\n\n\t\twhile (i > 1) {\n\t\t\tnode = {\n\t\t\t\ttype: Jsep.BINARY_EXP,\n\t\t\t\toperator: stack[i - 1].value,\n\t\t\t\tleft: stack[i - 2],\n\t\t\t\tright: node\n\t\t\t};\n\t\t\ti -= 2;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * An individual part of a binary expression:\n\t * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t * @returns {boolean|jsep.Expression}\n\t */\n\tgobbleToken() {\n\t\tlet ch, to_check, tc_len, node;\n\n\t\tthis.gobbleSpaces();\n\t\tnode = this.searchHook('gobble-token');\n\t\tif (node) {\n\t\t\treturn this.runHook('after-token', node);\n\t\t}\n\n\t\tch = this.code;\n\n\t\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\treturn this.gobbleNumericLiteral();\n\t\t}\n\n\t\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n\t\t\t// Single or double quotes\n\t\t\tnode = this.gobbleStringLiteral();\n\t\t}\n\t\telse if (ch === Jsep.OBRACK_CODE) {\n\t\t\tnode = this.gobbleArray();\n\t\t}\n\t\telse {\n\t\t\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\n\t\t\ttc_len = to_check.length;\n\n\t\t\twhile (tc_len > 0) {\n\t\t\t\t// Don't accept an unary op when it is an identifier.\n\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\n\t\t\t\t// by a non identifier-part valid character\n\t\t\t\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t!Jsep.isIdentifierStart(this.code) ||\n\t\t\t\t\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n\t\t\t\t)) {\n\t\t\t\t\tthis.index += tc_len;\n\t\t\t\t\tconst argument = this.gobbleToken();\n\t\t\t\t\tif (!argument) {\n\t\t\t\t\t\tthis.throwError('missing unaryOp argument');\n\t\t\t\t\t}\n\t\t\t\t\treturn this.runHook('after-token', {\n\t\t\t\t\t\ttype: Jsep.UNARY_EXP,\n\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\targument,\n\t\t\t\t\t\tprefix: true\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t}\n\n\t\t\tif (Jsep.isIdentifierStart(ch)) {\n\t\t\t\tnode = this.gobbleIdentifier();\n\t\t\t\tif (Jsep.literals.hasOwnProperty(node.name)) {\n\t\t\t\t\tnode = {\n\t\t\t\t\t\ttype: Jsep.LITERAL,\n\t\t\t\t\t\tvalue: Jsep.literals[node.name],\n\t\t\t\t\t\traw: node.name,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (node.name === Jsep.this_str) {\n\t\t\t\t\tnode = { type: Jsep.THIS_EXP };\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\n\t\t\t\tnode = this.gobbleGroup();\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\treturn this.runHook('after-token', false);\n\t\t}\n\n\t\tnode = this.gobbleTokenProperty(node);\n\t\treturn this.runHook('after-token', node);\n\t}\n\n\t/**\n\t * Gobble properties of of identifiers/strings/arrays/groups.\n\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t * It also gobbles function calls:\n\t * e.g. `Math.acos(obj.angle)`\n\t * @param {jsep.Expression} node\n\t * @returns {jsep.Expression}\n\t */\n\tgobbleTokenProperty(node) {\n\t\tthis.gobbleSpaces();\n\n\t\tlet ch = this.code;\n\t\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n\t\t\tlet optional;\n\t\t\tif (ch === Jsep.QUMARK_CODE) {\n\t\t\t\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toptional = true;\n\t\t\t\tthis.index += 2;\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tch = this.code;\n\t\t\t}\n\t\t\tthis.index++;\n\n\t\t\tif (ch === Jsep.OBRACK_CODE) {\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.MEMBER_EXP,\n\t\t\t\t\tcomputed: true,\n\t\t\t\t\tobject: node,\n\t\t\t\t\tproperty: this.gobbleExpression()\n\t\t\t\t};\n\t\t\t\tif (!node.property) {\n\t\t\t\t\tthis.throwError('Unexpected \"' + this.char + '\"');\n\t\t\t\t}\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tch = this.code;\n\t\t\t\tif (ch !== Jsep.CBRACK_CODE) {\n\t\t\t\t\tthis.throwError('Unclosed [');\n\t\t\t\t}\n\t\t\t\tthis.index++;\n\t\t\t}\n\t\t\telse if (ch === Jsep.OPAREN_CODE) {\n\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.CALL_EXP,\n\t\t\t\t\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n\t\t\t\t\tcallee: node\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (ch === Jsep.PERIOD_CODE || optional) {\n\t\t\t\tif (optional) {\n\t\t\t\t\tthis.index--;\n\t\t\t\t}\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.MEMBER_EXP,\n\t\t\t\t\tcomputed: false,\n\t\t\t\t\tobject: node,\n\t\t\t\t\tproperty: this.gobbleIdentifier(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (optional) {\n\t\t\t\tnode.optional = true;\n\t\t\t} // else leave undefined for compatibility with esprima\n\n\t\t\tthis.gobbleSpaces();\n\t\t\tch = this.code;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t * @returns {jsep.Literal}\n\t */\n\tgobbleNumericLiteral() {\n\t\tlet number = '', ch, chCode;\n\n\t\twhile (Jsep.isDecimalDigit(this.code)) {\n\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t}\n\n\t\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\n\t\t\tnumber += this.expr.charAt(this.index++);\n\n\t\t\twhile (Jsep.isDecimalDigit(this.code)) {\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\t\t}\n\n\t\tch = this.char;\n\n\t\tif (ch === 'e' || ch === 'E') { // exponent marker\n\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\tch = this.char;\n\n\t\t\tif (ch === '+' || ch === '-') { // exponent sign\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\n\t\t\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\n\t\t\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\n\t\t\t\tthis.throwError('Expected exponent (' + number + this.char + ')');\n\t\t\t}\n\t\t}\n\n\t\tchCode = this.code;\n\n\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\tif (Jsep.isIdentifierStart(chCode)) {\n\t\t\tthis.throwError('Variable names cannot start with a number (' +\n\t\t\t\tnumber + this.char + ')');\n\t\t}\n\t\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\n\t\t\tthis.throwError('Unexpected period');\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Jsep.LITERAL,\n\t\t\tvalue: parseFloat(number),\n\t\t\traw: number\n\t\t};\n\t}\n\n\t/**\n\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t * @returns {jsep.Literal}\n\t */\n\tgobbleStringLiteral() {\n\t\tlet str = '';\n\t\tconst startIndex = this.index;\n\t\tconst quote = this.expr.charAt(this.index++);\n\t\tlet closed = false;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tlet ch = this.expr.charAt(this.index++);\n\n\t\t\tif (ch === quote) {\n\t\t\t\tclosed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ch === '\\\\') {\n\t\t\t\t// Check for all of the common escape codes\n\t\t\t\tch = this.expr.charAt(this.index++);\n\n\t\t\t\tswitch (ch) {\n\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\tdefault : str += ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\n\t\tif (!closed) {\n\t\t\tthis.throwError('Unclosed quote after \"' + str + '\"');\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Jsep.LITERAL,\n\t\t\tvalue: str,\n\t\t\traw: this.expr.substring(startIndex, this.index),\n\t\t};\n\t}\n\n\t/**\n\t * Gobbles only identifiers\n\t * e.g.: `foo`, `_value`, `$x1`\n\t * Also, this function checks if that identifier is a literal:\n\t * (e.g. `true`, `false`, `null`) or `this`\n\t * @returns {jsep.Identifier}\n\t */\n\tgobbleIdentifier() {\n\t\tlet ch = this.code, start = this.index;\n\n\t\tif (Jsep.isIdentifierStart(ch)) {\n\t\t\tthis.index++;\n\t\t}\n\t\telse {\n\t\t\tthis.throwError('Unexpected ' + this.char);\n\t\t}\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tch = this.code;\n\n\t\t\tif (Jsep.isIdentifierPart(ch)) {\n\t\t\t\tthis.index++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: Jsep.IDENTIFIER,\n\t\t\tname: this.expr.slice(start, this.index),\n\t\t};\n\t}\n\n\t/**\n\t * Gobbles a list of arguments within the context of a function call\n\t * or array literal. This function also assumes that the opening character\n\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t * until the terminator character `)` or `]` is encountered.\n\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t * @param {number} termination\n\t * @returns {jsep.Expression[]}\n\t */\n\tgobbleArguments(termination) {\n\t\tconst args = [];\n\t\tlet closed = false;\n\t\tlet separator_count = 0;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tthis.gobbleSpaces();\n\t\t\tlet ch_i = this.code;\n\n\t\t\tif (ch_i === termination) { // done parsing\n\t\t\t\tclosed = true;\n\t\t\t\tthis.index++;\n\n\t\t\t\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\n\t\t\t\t\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\n\t\t\t\tthis.index++;\n\t\t\t\tseparator_count++;\n\n\t\t\t\tif (separator_count !== args.length) { // missing argument\n\t\t\t\t\tif (termination === Jsep.CPAREN_CODE) {\n\t\t\t\t\t\tthis.throwError('Unexpected token ,');\n\t\t\t\t\t}\n\t\t\t\t\telse if (termination === Jsep.CBRACK_CODE) {\n\t\t\t\t\t\tfor (let arg = args.length; arg < separator_count; arg++) {\n\t\t\t\t\t\t\targs.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (args.length !== separator_count && separator_count !== 0) {\n\t\t\t\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n\t\t\t\tthis.throwError('Expected comma');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst node = this.gobbleExpression();\n\n\t\t\t\tif (!node || node.type === Jsep.COMPOUND) {\n\t\t\t\t\tthis.throwError('Expected comma');\n\t\t\t\t}\n\n\t\t\t\targs.push(node);\n\t\t\t}\n\t\t}\n\n\t\tif (!closed) {\n\t\t\tthis.throwError('Expected ' + String.fromCharCode(termination));\n\t\t}\n\n\t\treturn args;\n\t}\n\n\t/**\n\t * Responsible for parsing a group of things within parentheses `()`\n\t * that have no identifier in front (so not a function call)\n\t * This function assumes that it needs to gobble the opening parenthesis\n\t * and then tries to gobble everything within that parenthesis, assuming\n\t * that the next thing it should see is the close parenthesis. If not,\n\t * then the expression probably doesn't have a `)`\n\t * @returns {boolean|jsep.Expression}\n\t */\n\tgobbleGroup() {\n\t\tthis.index++;\n\t\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\n\t\tif (this.code === Jsep.CPAREN_CODE) {\n\t\t\tthis.index++;\n\t\t\tif (nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t}\n\t\t\telse if (!nodes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn {\n\t\t\t\t\ttype: Jsep.SEQUENCE_EXP,\n\t\t\t\t\texpressions: nodes,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.throwError('Unclosed (');\n\t\t}\n\t}\n\n\t/**\n\t * Responsible for parsing Array literals `[1, 2, 3]`\n\t * This function assumes that it needs to gobble the opening bracket\n\t * and then tries to gobble the expressions as arguments.\n\t * @returns {jsep.ArrayExpression}\n\t */\n\tgobbleArray() {\n\t\tthis.index++;\n\n\t\treturn {\n\t\t\ttype: Jsep.ARRAY_EXP,\n\t\t\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\n\t\t};\n\t}\n}\n\n// Static fields:\nconst hooks = new Hooks();\nObject.assign(Jsep, {\n\thooks,\n\tplugins: new Plugins(Jsep),\n\n\t// Node Types\n\t// ----------\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tCOMPOUND:        'Compound',\n\tSEQUENCE_EXP:    'SequenceExpression',\n\tIDENTIFIER:      'Identifier',\n\tMEMBER_EXP:      'MemberExpression',\n\tLITERAL:         'Literal',\n\tTHIS_EXP:        'ThisExpression',\n\tCALL_EXP:        'CallExpression',\n\tUNARY_EXP:       'UnaryExpression',\n\tBINARY_EXP:      'BinaryExpression',\n\tARRAY_EXP:       'ArrayExpression',\n\n\tTAB_CODE:    9,\n\tLF_CODE:     10,\n\tCR_CODE:     13,\n\tSPACE_CODE:  32,\n\tPERIOD_CODE: 46, // '.'\n\tCOMMA_CODE:  44, // ','\n\tSQUOTE_CODE: 39, // single quote\n\tDQUOTE_CODE: 34, // double quotes\n\tOPAREN_CODE: 40, // (\n\tCPAREN_CODE: 41, // )\n\tOBRACK_CODE: 91, // [\n\tCBRACK_CODE: 93, // ]\n\tQUMARK_CODE: 63, // ?\n\tSEMCOL_CODE: 59, // ;\n\tCOLON_CODE:  58, // :\n\n\n\t// Operations\n\t// ----------\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `1` (it really doesn't matter)\n\tunary_ops: {\n\t\t'-': 1,\n\t\t'!': 1,\n\t\t'~': 1,\n\t\t'+': 1\n\t},\n\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference (higher number = higher precedence)\n\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\tbinary_ops: {\n\t\t'||': 1, '??': 1,\n\t\t'&&': 2, '|': 3, '^': 4, '&': 5,\n\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t'<': 7, '>': 7, '<=': 7, '>=': 7,\n\t\t'<<': 8, '>>': 8, '>>>': 8,\n\t\t'+': 9, '-': 9,\n\t\t'*': 10, '/': 10, '%': 10,\n\t\t'**': 11,\n\t},\n\n\t// sets specific binary_ops as right-associative\n\tright_associative: new Set(['**']),\n\n\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n\tadditional_identifier_chars: new Set(['$', '_']),\n\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\tliterals: {\n\t\t'true': true,\n\t\t'false': false,\n\t\t'null': null\n\t},\n\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\tthis_str: 'this',\n});\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\n// Backward Compatibility:\nconst jsep = expr => (new Jsep(expr)).parse();\nconst stdClassProps = Object.getOwnPropertyNames(class Test{});\nObject.getOwnPropertyNames(Jsep)\n\t.filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\n\t.forEach((m) => {\n\t\tjsep[m] = Jsep[m];\n\t});\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\n\nconst CONDITIONAL_EXP = 'ConditionalExpression';\n\nvar ternary = {\n\tname: 'ternary',\n\n\tinit(jsep) {\n\t\t// Ternary expression: test ? consequent : alternate\n\t\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\n\t\t\tif (env.node && this.code === jsep.QUMARK_CODE) {\n\t\t\t\tthis.index++;\n\t\t\t\tconst test = env.node;\n\t\t\t\tconst consequent = this.gobbleExpression();\n\n\t\t\t\tif (!consequent) {\n\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t}\n\n\t\t\t\tthis.gobbleSpaces();\n\n\t\t\t\tif (this.code === jsep.COLON_CODE) {\n\t\t\t\t\tthis.index++;\n\t\t\t\t\tconst alternate = this.gobbleExpression();\n\n\t\t\t\t\tif (!alternate) {\n\t\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t\t}\n\t\t\t\t\tenv.node = {\n\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\ttest,\n\t\t\t\t\t\tconsequent,\n\t\t\t\t\t\talternate,\n\t\t\t\t\t};\n\n\t\t\t\t\t// check for operators of higher priority than ternary (i.e. assignment)\n\t\t\t\t\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n\t\t\t\t\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n\t\t\t\t\t\tlet newTest = test;\n\t\t\t\t\t\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n\t\t\t\t\t\t\tnewTest = newTest.right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.node.test = newTest.right;\n\t\t\t\t\t\tnewTest.right = env.node;\n\t\t\t\t\t\tenv.node = test;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.throwError('Expected :');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n};\n\n// Add default plugins:\n\njsep.plugins.register(ternary);\n\nexport { Jsep, jsep as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}