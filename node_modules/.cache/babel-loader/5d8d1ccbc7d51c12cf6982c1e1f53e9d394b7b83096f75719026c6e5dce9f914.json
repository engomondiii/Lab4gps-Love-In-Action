{"ast":null,"code":"import Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport Material from \"./Material.js\";\nconst scratchColor = new Color();\nconst scratchColorAbove = new Color();\nconst scratchColorBelow = new Color();\nconst scratchColorBlend = new Color();\nconst scratchPackedFloat = new Cartesian4();\nconst scratchColorBytes = new Uint8Array(4);\nfunction lerpEntryColor(height, entryBefore, entryAfter, result) {\n  const lerpFactor = entryBefore.height === entryAfter.height ? 0.0 : (height - entryBefore.height) / (entryAfter.height - entryBefore.height);\n  return Color.lerp(entryBefore.color, entryAfter.color, lerpFactor, result);\n}\nfunction createNewEntry(height, color) {\n  return {\n    height: height,\n    color: Color.clone(color)\n  };\n}\nfunction removeDuplicates(entries) {\n  // This function expects entries to be sorted from lowest to highest.\n\n  // Remove entries that have the same height as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    const hasPrev = index > 0;\n    const hasNext = index < array.length - 1;\n    const sameHeightAsPrev = hasPrev ? entry.height === array[index - 1].height : true;\n    const sameHeightAsNext = hasNext ? entry.height === array[index + 1].height : true;\n    const keep = !sameHeightAsPrev || !sameHeightAsNext;\n    return keep;\n  });\n\n  // Remove entries that have the same color as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    const hasPrev = index > 0;\n    const hasNext = index < array.length - 1;\n    const sameColorAsPrev = hasPrev ? Color.equals(entry.color, array[index - 1].color) : false;\n    const sameColorAsNext = hasNext ? Color.equals(entry.color, array[index + 1].color) : false;\n    const keep = !sameColorAsPrev || !sameColorAsNext;\n    return keep;\n  });\n\n  // Also remove entries that have the same height AND color as the entry before.\n  entries = entries.filter(function (entry, index, array) {\n    const hasPrev = index > 0;\n    const sameColorAsPrev = hasPrev ? Color.equals(entry.color, array[index - 1].color) : false;\n    const sameHeightAsPrev = hasPrev ? entry.height === array[index - 1].height : true;\n    const keep = !sameColorAsPrev || !sameHeightAsPrev;\n    return keep;\n  });\n  return entries;\n}\nfunction preprocess(layers) {\n  let i, j;\n  const layeredEntries = [];\n  const layersLength = layers.length;\n  for (i = 0; i < layersLength; i++) {\n    const layer = layers[i];\n    const entriesOrig = layer.entries;\n    const entriesLength = entriesOrig.length;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!Array.isArray(entriesOrig) || entriesLength === 0) {\n      throw new DeveloperError(\"entries must be an array with size > 0.\");\n    }\n    //>>includeEnd('debug');\n\n    let entries = [];\n    for (j = 0; j < entriesLength; j++) {\n      const entryOrig = entriesOrig[j];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(entryOrig.height)) {\n        throw new DeveloperError(\"entry requires a height.\");\n      }\n      if (!defined(entryOrig.color)) {\n        throw new DeveloperError(\"entry requires a color.\");\n      }\n      //>>includeEnd('debug');\n\n      const height = CesiumMath.clamp(entryOrig.height, createElevationBandMaterial._minimumHeight, createElevationBandMaterial._maximumHeight);\n\n      // premultiplied alpha\n      const color = Color.clone(entryOrig.color, scratchColor);\n      color.red *= color.alpha;\n      color.green *= color.alpha;\n      color.blue *= color.alpha;\n      entries.push(createNewEntry(height, color));\n    }\n    let sortedAscending = true;\n    let sortedDescending = true;\n    for (j = 0; j < entriesLength - 1; j++) {\n      const currEntry = entries[j + 0];\n      const nextEntry = entries[j + 1];\n      sortedAscending = sortedAscending && currEntry.height <= nextEntry.height;\n      sortedDescending = sortedDescending && currEntry.height >= nextEntry.height;\n    }\n\n    // When the array is fully descending, reverse it.\n    if (sortedDescending) {\n      entries = entries.reverse();\n    } else if (!sortedAscending) {\n      // Stable sort from lowest to greatest height.\n      mergeSort(entries, function (a, b) {\n        return CesiumMath.sign(a.height - b.height);\n      });\n    }\n    let extendDownwards = defaultValue(layer.extendDownwards, false);\n    let extendUpwards = defaultValue(layer.extendUpwards, false);\n\n    // Interpret a single entry to extend all the way up and down.\n    if (entries.length === 1 && !extendDownwards && !extendUpwards) {\n      extendDownwards = true;\n      extendUpwards = true;\n    }\n    if (extendDownwards) {\n      entries.splice(0, 0, createNewEntry(createElevationBandMaterial._minimumHeight, entries[0].color));\n    }\n    if (extendUpwards) {\n      entries.splice(entries.length, 0, createNewEntry(createElevationBandMaterial._maximumHeight, entries[entries.length - 1].color));\n    }\n    entries = removeDuplicates(entries);\n    layeredEntries.push(entries);\n  }\n  return layeredEntries;\n}\nfunction createLayeredEntries(layers) {\n  // clean up the input data and check for errors\n  const layeredEntries = preprocess(layers);\n  let entriesAccumNext = [];\n  let entriesAccumCurr = [];\n  let i;\n  function addEntry(height, color) {\n    entriesAccumNext.push(createNewEntry(height, color));\n  }\n  function addBlendEntry(height, a, b) {\n    let result = Color.multiplyByScalar(b, 1.0 - a.alpha, scratchColorBlend);\n    result = Color.add(result, a, result);\n    addEntry(height, result);\n  }\n\n  // alpha blend new layers on top of old ones\n  const layerLength = layeredEntries.length;\n  for (i = 0; i < layerLength; i++) {\n    const entries = layeredEntries[i];\n    let idx = 0;\n    let accumIdx = 0;\n\n    // swap the arrays\n    entriesAccumCurr = entriesAccumNext;\n    entriesAccumNext = [];\n    const entriesLength = entries.length;\n    const entriesAccumLength = entriesAccumCurr.length;\n    while (idx < entriesLength || accumIdx < entriesAccumLength) {\n      const entry = idx < entriesLength ? entries[idx] : undefined;\n      const prevEntry = idx > 0 ? entries[idx - 1] : undefined;\n      const nextEntry = idx < entriesLength - 1 ? entries[idx + 1] : undefined;\n      const entryAccum = accumIdx < entriesAccumLength ? entriesAccumCurr[accumIdx] : undefined;\n      const prevEntryAccum = accumIdx > 0 ? entriesAccumCurr[accumIdx - 1] : undefined;\n      const nextEntryAccum = accumIdx < entriesAccumLength - 1 ? entriesAccumCurr[accumIdx + 1] : undefined;\n      if (defined(entry) && defined(entryAccum) && entry.height === entryAccum.height) {\n        // New entry directly on top of accum entry\n        const isSplitAccum = defined(nextEntryAccum) && entryAccum.height === nextEntryAccum.height;\n        const isStartAccum = !defined(prevEntryAccum);\n        const isEndAccum = !defined(nextEntryAccum);\n        const isSplit = defined(nextEntry) && entry.height === nextEntry.height;\n        const isStart = !defined(prevEntry);\n        const isEnd = !defined(nextEntry);\n        if (isSplitAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, nextEntryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          }\n        } else if (isStartAccum) {\n          if (isSplit) {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isEnd) {\n            addEntry(entry.height, entry.color);\n            addEntry(entry.height, entryAccum.color);\n          } else if (isStart) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        } else if (isEndAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntry.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        }\n        idx += isSplit ? 2 : 1;\n        accumIdx += isSplitAccum ? 2 : 1;\n      } else if (defined(entry) && defined(entryAccum) && defined(prevEntryAccum) && entry.height < entryAccum.height) {\n        // New entry between two accum entries\n        const colorBelow = lerpEntryColor(entry.height, prevEntryAccum, entryAccum, scratchColorBelow);\n        if (!defined(prevEntry)) {\n          addEntry(entry.height, colorBelow);\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        } else if (!defined(nextEntry)) {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n          addEntry(entry.height, colorBelow);\n        } else {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        }\n        idx++;\n      } else if (defined(entryAccum) && defined(entry) && defined(prevEntry) && entryAccum.height < entry.height) {\n        // Accum entry between two new entries\n        const colorAbove = lerpEntryColor(entryAccum.height, prevEntry, entry, scratchColorAbove);\n        if (!defined(prevEntryAccum)) {\n          addEntry(entryAccum.height, colorAbove);\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        } else if (!defined(nextEntryAccum)) {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n          addEntry(entryAccum.height, colorAbove);\n        } else {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        }\n        accumIdx++;\n      } else if (defined(entry) && (!defined(entryAccum) || entry.height < entryAccum.height)) {\n        // New entry completely before or completely after accum entries\n        if (defined(entryAccum) && !defined(prevEntryAccum) && !defined(nextEntry)) {\n          // Insert blank gap between last entry and first accum entry\n          addEntry(entry.height, entry.color);\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entryAccum.height, createElevationBandMaterial._emptyColor);\n        } else if (!defined(entryAccum) && defined(prevEntryAccum) && !defined(prevEntry)) {\n          // Insert blank gap between last accum entry and first entry\n          addEntry(prevEntryAccum.height, createElevationBandMaterial._emptyColor);\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entry.height, entry.color);\n        } else {\n          addEntry(entry.height, entry.color);\n        }\n        idx++;\n      } else if (defined(entryAccum) && (!defined(entry) || entryAccum.height < entry.height)) {\n        // Accum entry completely before or completely after new entries\n        addEntry(entryAccum.height, entryAccum.color);\n        accumIdx++;\n      }\n    }\n  }\n\n  // one final cleanup pass in case duplicate colors show up in the final result\n  const allEntries = removeDuplicates(entriesAccumNext);\n  return allEntries;\n}\n\n/**\n * @typedef createElevationBandMaterialEntry\n *\n * @property {number} height The height.\n * @property {Color} color The color at this height.\n */\n/**\n * @typedef createElevationBandMaterialBand\n *\n * @property {createElevationBandMaterialEntry[]} entries A list of elevation entries. They will automatically be sorted from lowest to highest. If there is only one entry and <code>extendsDownards</code> and <code>extendUpwards</code> are both <code>false</code>, they will both be set to <code>true</code>.\n * @property {boolean} [extendDownwards=false] If <code>true</code>, the band's minimum elevation color will extend infinitely downwards.\n * @property {boolean} [extendUpwards=false] If <code>true</code>, the band's maximum elevation color will extend infinitely upwards.\n */\n\n/**\n * Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.\n *\n * The shader does a binary search over all the heights to find out which colors are above and below a given height, and\n * interpolates between them for the final color. This material supports hundreds of entries relatively cheaply.\n *\n * @function createElevationBandMaterial\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.scene The scene where the visualization is taking place.\n * @param {createElevationBandMaterialBand[]} options.layers A list of bands ordered from lowest to highest precedence.\n * @returns {Material} A new {@link Material} instance.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Elevation%20Band%20Material.html|Cesium Sandcastle Elevation Band Demo}\n *\n * @example\n * scene.globe.material = Cesium.createElevationBandMaterial({\n *     scene : scene,\n *     layers : [{\n *         entries : [{\n *             height : 4200.0,\n *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)\n *         }, {\n *             height : 8848.0,\n *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)\n *         }],\n *         extendDownwards : true,\n *         extendUpwards : true,\n *     }, {\n *         entries : [{\n *             height : 7000.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }, {\n *             height : 7100.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }]\n *     }]\n * });\n */\nfunction createElevationBandMaterial(options) {\n  const {\n    scene,\n    layers\n  } = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.scene\", scene);\n  Check.defined(\"options.layers\", layers);\n  Check.typeOf.number.greaterThan(\"options.layers.length\", layers.length, 0);\n  //>>includeEnd('debug');\n\n  const {\n    context\n  } = scene;\n  const entries = createLayeredEntries(layers);\n  const entriesLength = entries.length;\n  let heightTexBuffer;\n  let heightTexDatatype;\n  let heightTexFormat;\n  const isPackedHeight = !createElevationBandMaterial._useFloatTexture(context);\n  if (isPackedHeight) {\n    heightTexDatatype = PixelDatatype.UNSIGNED_BYTE;\n    heightTexFormat = PixelFormat.RGBA;\n    heightTexBuffer = new Uint8Array(entriesLength * 4);\n    for (let i = 0; i < entriesLength; i++) {\n      Cartesian4.packFloat(entries[i].height, scratchPackedFloat);\n      Cartesian4.pack(scratchPackedFloat, heightTexBuffer, i * 4);\n    }\n  } else {\n    heightTexDatatype = PixelDatatype.FLOAT;\n    heightTexFormat = context.webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE;\n    heightTexBuffer = new Float32Array(entriesLength);\n    for (let i = 0; i < entriesLength; i++) {\n      heightTexBuffer[i] = entries[i].height;\n    }\n  }\n  const heightsTex = Texture.create({\n    context: context,\n    pixelFormat: heightTexFormat,\n    pixelDatatype: heightTexDatatype,\n    source: {\n      arrayBufferView: heightTexBuffer,\n      width: entriesLength,\n      height: 1\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST\n    })\n  });\n  const colorsArray = new Uint8Array(entriesLength * 4);\n  for (let i = 0; i < entriesLength; i++) {\n    const color = entries[i].color;\n    color.toBytes(scratchColorBytes);\n    colorsArray[i * 4 + 0] = scratchColorBytes[0];\n    colorsArray[i * 4 + 1] = scratchColorBytes[1];\n    colorsArray[i * 4 + 2] = scratchColorBytes[2];\n    colorsArray[i * 4 + 3] = scratchColorBytes[3];\n  }\n  const colorsTex = Texture.create({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: colorsArray,\n      width: entriesLength,\n      height: 1\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    })\n  });\n  return Material.fromType(\"ElevationBand\", {\n    heights: heightsTex,\n    colors: colorsTex\n  });\n}\n\n/**\n * Function for checking if the context will allow floating point textures for heights.\n *\n * @param {Context} context The {@link Context}.\n * @returns {boolean} <code>true</code> if floating point textures can be used for heights.\n * @private\n */\ncreateElevationBandMaterial._useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n\n/**\n * This is the height that gets stored in the texture when using extendUpwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\ncreateElevationBandMaterial._maximumHeight = +5906376425472;\n\n/**\n * This is the height that gets stored in the texture when using extendDownwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\ncreateElevationBandMaterial._minimumHeight = -5906376425472;\n\n/**\n * Color used to create empty space in the color texture\n * @private\n */\ncreateElevationBandMaterial._emptyColor = new Color(0.0, 0.0, 0.0, 0.0);\nexport default createElevationBandMaterial;","map":{"version":3,"names":["Cartesian4","CesiumMath","Check","Color","defaultValue","defined","DeveloperError","mergeSort","PixelFormat","PixelDatatype","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","Material","scratchColor","scratchColorAbove","scratchColorBelow","scratchColorBlend","scratchPackedFloat","scratchColorBytes","Uint8Array","lerpEntryColor","height","entryBefore","entryAfter","result","lerpFactor","lerp","color","createNewEntry","clone","removeDuplicates","entries","filter","entry","index","array","hasPrev","hasNext","length","sameHeightAsPrev","sameHeightAsNext","keep","sameColorAsPrev","equals","sameColorAsNext","preprocess","layers","i","j","layeredEntries","layersLength","layer","entriesOrig","entriesLength","Array","isArray","entryOrig","clamp","createElevationBandMaterial","_minimumHeight","_maximumHeight","red","alpha","green","blue","push","sortedAscending","sortedDescending","currEntry","nextEntry","reverse","a","b","sign","extendDownwards","extendUpwards","splice","createLayeredEntries","entriesAccumNext","entriesAccumCurr","addEntry","addBlendEntry","multiplyByScalar","add","layerLength","idx","accumIdx","entriesAccumLength","undefined","prevEntry","entryAccum","prevEntryAccum","nextEntryAccum","isSplitAccum","isStartAccum","isEndAccum","isSplit","isStart","isEnd","colorBelow","colorAbove","_emptyColor","allEntries","options","scene","EMPTY_OBJECT","typeOf","object","number","greaterThan","context","heightTexBuffer","heightTexDatatype","heightTexFormat","isPackedHeight","_useFloatTexture","UNSIGNED_BYTE","RGBA","packFloat","pack","FLOAT","webgl2","RED","LUMINANCE","Float32Array","heightsTex","create","pixelFormat","pixelDatatype","source","arrayBufferView","width","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","NEAREST","magnificationFilter","colorsArray","toBytes","colorsTex","LINEAR","fromType","heights","colors","floatingPointTexture"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/createElevationBandMaterial.js"],"sourcesContent":["import Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport Material from \"./Material.js\";\n\nconst scratchColor = new Color();\nconst scratchColorAbove = new Color();\nconst scratchColorBelow = new Color();\nconst scratchColorBlend = new Color();\nconst scratchPackedFloat = new Cartesian4();\nconst scratchColorBytes = new Uint8Array(4);\n\nfunction lerpEntryColor(height, entryBefore, entryAfter, result) {\n  const lerpFactor =\n    entryBefore.height === entryAfter.height\n      ? 0.0\n      : (height - entryBefore.height) /\n        (entryAfter.height - entryBefore.height);\n  return Color.lerp(entryBefore.color, entryAfter.color, lerpFactor, result);\n}\n\nfunction createNewEntry(height, color) {\n  return {\n    height: height,\n    color: Color.clone(color),\n  };\n}\n\nfunction removeDuplicates(entries) {\n  // This function expects entries to be sorted from lowest to highest.\n\n  // Remove entries that have the same height as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    const hasPrev = index > 0;\n    const hasNext = index < array.length - 1;\n\n    const sameHeightAsPrev = hasPrev\n      ? entry.height === array[index - 1].height\n      : true;\n    const sameHeightAsNext = hasNext\n      ? entry.height === array[index + 1].height\n      : true;\n\n    const keep = !sameHeightAsPrev || !sameHeightAsNext;\n    return keep;\n  });\n\n  // Remove entries that have the same color as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    const hasPrev = index > 0;\n    const hasNext = index < array.length - 1;\n\n    const sameColorAsPrev = hasPrev\n      ? Color.equals(entry.color, array[index - 1].color)\n      : false;\n    const sameColorAsNext = hasNext\n      ? Color.equals(entry.color, array[index + 1].color)\n      : false;\n\n    const keep = !sameColorAsPrev || !sameColorAsNext;\n    return keep;\n  });\n\n  // Also remove entries that have the same height AND color as the entry before.\n  entries = entries.filter(function (entry, index, array) {\n    const hasPrev = index > 0;\n\n    const sameColorAsPrev = hasPrev\n      ? Color.equals(entry.color, array[index - 1].color)\n      : false;\n\n    const sameHeightAsPrev = hasPrev\n      ? entry.height === array[index - 1].height\n      : true;\n\n    const keep = !sameColorAsPrev || !sameHeightAsPrev;\n    return keep;\n  });\n\n  return entries;\n}\n\nfunction preprocess(layers) {\n  let i, j;\n\n  const layeredEntries = [];\n\n  const layersLength = layers.length;\n  for (i = 0; i < layersLength; i++) {\n    const layer = layers[i];\n    const entriesOrig = layer.entries;\n    const entriesLength = entriesOrig.length;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!Array.isArray(entriesOrig) || entriesLength === 0) {\n      throw new DeveloperError(\"entries must be an array with size > 0.\");\n    }\n    //>>includeEnd('debug');\n\n    let entries = [];\n\n    for (j = 0; j < entriesLength; j++) {\n      const entryOrig = entriesOrig[j];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(entryOrig.height)) {\n        throw new DeveloperError(\"entry requires a height.\");\n      }\n      if (!defined(entryOrig.color)) {\n        throw new DeveloperError(\"entry requires a color.\");\n      }\n      //>>includeEnd('debug');\n\n      const height = CesiumMath.clamp(\n        entryOrig.height,\n        createElevationBandMaterial._minimumHeight,\n        createElevationBandMaterial._maximumHeight,\n      );\n\n      // premultiplied alpha\n      const color = Color.clone(entryOrig.color, scratchColor);\n      color.red *= color.alpha;\n      color.green *= color.alpha;\n      color.blue *= color.alpha;\n\n      entries.push(createNewEntry(height, color));\n    }\n\n    let sortedAscending = true;\n    let sortedDescending = true;\n    for (j = 0; j < entriesLength - 1; j++) {\n      const currEntry = entries[j + 0];\n      const nextEntry = entries[j + 1];\n\n      sortedAscending = sortedAscending && currEntry.height <= nextEntry.height;\n      sortedDescending =\n        sortedDescending && currEntry.height >= nextEntry.height;\n    }\n\n    // When the array is fully descending, reverse it.\n    if (sortedDescending) {\n      entries = entries.reverse();\n    } else if (!sortedAscending) {\n      // Stable sort from lowest to greatest height.\n      mergeSort(entries, function (a, b) {\n        return CesiumMath.sign(a.height - b.height);\n      });\n    }\n\n    let extendDownwards = defaultValue(layer.extendDownwards, false);\n    let extendUpwards = defaultValue(layer.extendUpwards, false);\n\n    // Interpret a single entry to extend all the way up and down.\n    if (entries.length === 1 && !extendDownwards && !extendUpwards) {\n      extendDownwards = true;\n      extendUpwards = true;\n    }\n\n    if (extendDownwards) {\n      entries.splice(\n        0,\n        0,\n        createNewEntry(\n          createElevationBandMaterial._minimumHeight,\n          entries[0].color,\n        ),\n      );\n    }\n    if (extendUpwards) {\n      entries.splice(\n        entries.length,\n        0,\n        createNewEntry(\n          createElevationBandMaterial._maximumHeight,\n          entries[entries.length - 1].color,\n        ),\n      );\n    }\n\n    entries = removeDuplicates(entries);\n\n    layeredEntries.push(entries);\n  }\n\n  return layeredEntries;\n}\n\nfunction createLayeredEntries(layers) {\n  // clean up the input data and check for errors\n  const layeredEntries = preprocess(layers);\n\n  let entriesAccumNext = [];\n  let entriesAccumCurr = [];\n  let i;\n\n  function addEntry(height, color) {\n    entriesAccumNext.push(createNewEntry(height, color));\n  }\n  function addBlendEntry(height, a, b) {\n    let result = Color.multiplyByScalar(b, 1.0 - a.alpha, scratchColorBlend);\n    result = Color.add(result, a, result);\n    addEntry(height, result);\n  }\n\n  // alpha blend new layers on top of old ones\n  const layerLength = layeredEntries.length;\n  for (i = 0; i < layerLength; i++) {\n    const entries = layeredEntries[i];\n    let idx = 0;\n    let accumIdx = 0;\n\n    // swap the arrays\n    entriesAccumCurr = entriesAccumNext;\n    entriesAccumNext = [];\n\n    const entriesLength = entries.length;\n    const entriesAccumLength = entriesAccumCurr.length;\n    while (idx < entriesLength || accumIdx < entriesAccumLength) {\n      const entry = idx < entriesLength ? entries[idx] : undefined;\n      const prevEntry = idx > 0 ? entries[idx - 1] : undefined;\n      const nextEntry = idx < entriesLength - 1 ? entries[idx + 1] : undefined;\n\n      const entryAccum =\n        accumIdx < entriesAccumLength ? entriesAccumCurr[accumIdx] : undefined;\n      const prevEntryAccum =\n        accumIdx > 0 ? entriesAccumCurr[accumIdx - 1] : undefined;\n      const nextEntryAccum =\n        accumIdx < entriesAccumLength - 1\n          ? entriesAccumCurr[accumIdx + 1]\n          : undefined;\n\n      if (\n        defined(entry) &&\n        defined(entryAccum) &&\n        entry.height === entryAccum.height\n      ) {\n        // New entry directly on top of accum entry\n        const isSplitAccum =\n          defined(nextEntryAccum) &&\n          entryAccum.height === nextEntryAccum.height;\n        const isStartAccum = !defined(prevEntryAccum);\n        const isEndAccum = !defined(nextEntryAccum);\n\n        const isSplit = defined(nextEntry) && entry.height === nextEntry.height;\n        const isStart = !defined(prevEntry);\n        const isEnd = !defined(nextEntry);\n\n        if (isSplitAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, nextEntryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          }\n        } else if (isStartAccum) {\n          if (isSplit) {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isEnd) {\n            addEntry(entry.height, entry.color);\n            addEntry(entry.height, entryAccum.color);\n          } else if (isStart) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        } else if (isEndAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntry.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        }\n        idx += isSplit ? 2 : 1;\n        accumIdx += isSplitAccum ? 2 : 1;\n      } else if (\n        defined(entry) &&\n        defined(entryAccum) &&\n        defined(prevEntryAccum) &&\n        entry.height < entryAccum.height\n      ) {\n        // New entry between two accum entries\n        const colorBelow = lerpEntryColor(\n          entry.height,\n          prevEntryAccum,\n          entryAccum,\n          scratchColorBelow,\n        );\n\n        if (!defined(prevEntry)) {\n          addEntry(entry.height, colorBelow);\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        } else if (!defined(nextEntry)) {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n          addEntry(entry.height, colorBelow);\n        } else {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        }\n        idx++;\n      } else if (\n        defined(entryAccum) &&\n        defined(entry) &&\n        defined(prevEntry) &&\n        entryAccum.height < entry.height\n      ) {\n        // Accum entry between two new entries\n        const colorAbove = lerpEntryColor(\n          entryAccum.height,\n          prevEntry,\n          entry,\n          scratchColorAbove,\n        );\n\n        if (!defined(prevEntryAccum)) {\n          addEntry(entryAccum.height, colorAbove);\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        } else if (!defined(nextEntryAccum)) {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n          addEntry(entryAccum.height, colorAbove);\n        } else {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        }\n        accumIdx++;\n      } else if (\n        defined(entry) &&\n        (!defined(entryAccum) || entry.height < entryAccum.height)\n      ) {\n        // New entry completely before or completely after accum entries\n        if (\n          defined(entryAccum) &&\n          !defined(prevEntryAccum) &&\n          !defined(nextEntry)\n        ) {\n          // Insert blank gap between last entry and first accum entry\n          addEntry(entry.height, entry.color);\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entryAccum.height, createElevationBandMaterial._emptyColor);\n        } else if (\n          !defined(entryAccum) &&\n          defined(prevEntryAccum) &&\n          !defined(prevEntry)\n        ) {\n          // Insert blank gap between last accum entry and first entry\n          addEntry(\n            prevEntryAccum.height,\n            createElevationBandMaterial._emptyColor,\n          );\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entry.height, entry.color);\n        } else {\n          addEntry(entry.height, entry.color);\n        }\n        idx++;\n      } else if (\n        defined(entryAccum) &&\n        (!defined(entry) || entryAccum.height < entry.height)\n      ) {\n        // Accum entry completely before or completely after new entries\n        addEntry(entryAccum.height, entryAccum.color);\n        accumIdx++;\n      }\n    }\n  }\n\n  // one final cleanup pass in case duplicate colors show up in the final result\n  const allEntries = removeDuplicates(entriesAccumNext);\n  return allEntries;\n}\n\n/**\n * @typedef createElevationBandMaterialEntry\n *\n * @property {number} height The height.\n * @property {Color} color The color at this height.\n */\n/**\n * @typedef createElevationBandMaterialBand\n *\n * @property {createElevationBandMaterialEntry[]} entries A list of elevation entries. They will automatically be sorted from lowest to highest. If there is only one entry and <code>extendsDownards</code> and <code>extendUpwards</code> are both <code>false</code>, they will both be set to <code>true</code>.\n * @property {boolean} [extendDownwards=false] If <code>true</code>, the band's minimum elevation color will extend infinitely downwards.\n * @property {boolean} [extendUpwards=false] If <code>true</code>, the band's maximum elevation color will extend infinitely upwards.\n */\n\n/**\n * Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.\n *\n * The shader does a binary search over all the heights to find out which colors are above and below a given height, and\n * interpolates between them for the final color. This material supports hundreds of entries relatively cheaply.\n *\n * @function createElevationBandMaterial\n *\n * @param {object} options Object with the following properties:\n * @param {Scene} options.scene The scene where the visualization is taking place.\n * @param {createElevationBandMaterialBand[]} options.layers A list of bands ordered from lowest to highest precedence.\n * @returns {Material} A new {@link Material} instance.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Elevation%20Band%20Material.html|Cesium Sandcastle Elevation Band Demo}\n *\n * @example\n * scene.globe.material = Cesium.createElevationBandMaterial({\n *     scene : scene,\n *     layers : [{\n *         entries : [{\n *             height : 4200.0,\n *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)\n *         }, {\n *             height : 8848.0,\n *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)\n *         }],\n *         extendDownwards : true,\n *         extendUpwards : true,\n *     }, {\n *         entries : [{\n *             height : 7000.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }, {\n *             height : 7100.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }]\n *     }]\n * });\n */\nfunction createElevationBandMaterial(options) {\n  const { scene, layers } = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.scene\", scene);\n  Check.defined(\"options.layers\", layers);\n  Check.typeOf.number.greaterThan(\"options.layers.length\", layers.length, 0);\n  //>>includeEnd('debug');\n\n  const { context } = scene;\n  const entries = createLayeredEntries(layers);\n  const entriesLength = entries.length;\n\n  let heightTexBuffer;\n  let heightTexDatatype;\n  let heightTexFormat;\n\n  const isPackedHeight = !createElevationBandMaterial._useFloatTexture(context);\n  if (isPackedHeight) {\n    heightTexDatatype = PixelDatatype.UNSIGNED_BYTE;\n    heightTexFormat = PixelFormat.RGBA;\n    heightTexBuffer = new Uint8Array(entriesLength * 4);\n    for (let i = 0; i < entriesLength; i++) {\n      Cartesian4.packFloat(entries[i].height, scratchPackedFloat);\n      Cartesian4.pack(scratchPackedFloat, heightTexBuffer, i * 4);\n    }\n  } else {\n    heightTexDatatype = PixelDatatype.FLOAT;\n    heightTexFormat = context.webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE;\n    heightTexBuffer = new Float32Array(entriesLength);\n    for (let i = 0; i < entriesLength; i++) {\n      heightTexBuffer[i] = entries[i].height;\n    }\n  }\n\n  const heightsTex = Texture.create({\n    context: context,\n    pixelFormat: heightTexFormat,\n    pixelDatatype: heightTexDatatype,\n    source: {\n      arrayBufferView: heightTexBuffer,\n      width: entriesLength,\n      height: 1,\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST,\n    }),\n  });\n\n  const colorsArray = new Uint8Array(entriesLength * 4);\n  for (let i = 0; i < entriesLength; i++) {\n    const color = entries[i].color;\n    color.toBytes(scratchColorBytes);\n    colorsArray[i * 4 + 0] = scratchColorBytes[0];\n    colorsArray[i * 4 + 1] = scratchColorBytes[1];\n    colorsArray[i * 4 + 2] = scratchColorBytes[2];\n    colorsArray[i * 4 + 3] = scratchColorBytes[3];\n  }\n\n  const colorsTex = Texture.create({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: colorsArray,\n      width: entriesLength,\n      height: 1,\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  return Material.fromType(\"ElevationBand\", {\n    heights: heightsTex,\n    colors: colorsTex,\n  });\n}\n\n/**\n * Function for checking if the context will allow floating point textures for heights.\n *\n * @param {Context} context The {@link Context}.\n * @returns {boolean} <code>true</code> if floating point textures can be used for heights.\n * @private\n */\ncreateElevationBandMaterial._useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n\n/**\n * This is the height that gets stored in the texture when using extendUpwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\ncreateElevationBandMaterial._maximumHeight = +5906376425472;\n\n/**\n * This is the height that gets stored in the texture when using extendDownwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\ncreateElevationBandMaterial._minimumHeight = -5906376425472;\n\n/**\n * Color used to create empty space in the color texture\n * @private\n */\ncreateElevationBandMaterial._emptyColor = new Color(0.0, 0.0, 0.0, 0.0);\n\nexport default createElevationBandMaterial;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}