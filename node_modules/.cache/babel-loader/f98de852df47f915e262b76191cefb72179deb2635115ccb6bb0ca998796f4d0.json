{"ast":null,"code":"import MersenneTwister from \"mersenne-twister\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\nconst CesiumMath = {};\n\n/**\n * 0.1\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON1 = 0.1;\n\n/**\n * 0.01\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON2 = 0.01;\n\n/**\n * 0.001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON3 = 0.001;\n\n/**\n * 0.0001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON4 = 0.0001;\n\n/**\n * 0.00001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON5 = 0.00001;\n\n/**\n * 0.000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON6 = 0.000001;\n\n/**\n * 0.0000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON7 = 0.0000001;\n\n/**\n * 0.00000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON8 = 0.00000001;\n\n/**\n * 0.000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON9 = 0.000000001;\n\n/**\n * 0.0000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON10 = 0.0000000001;\n\n/**\n * 0.00000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON11 = 0.00000000001;\n\n/**\n * 0.000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON12 = 0.000000000001;\n\n/**\n * 0.0000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON13 = 0.0000000000001;\n\n/**\n * 0.00000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON14 = 0.00000000000001;\n\n/**\n * 0.000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON15 = 0.000000000000001;\n\n/**\n * 0.0000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON16 = 0.0000000000000001;\n\n/**\n * 0.00000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON17 = 0.00000000000000001;\n\n/**\n * 0.000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON18 = 0.000000000000000001;\n\n/**\n * 0.0000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n\n/**\n * 0.00000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n\n/**\n * 0.000000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {number}\n * @constant\n */\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {number}\n * @constant\n */\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {number}\n * @constant\n */\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n\n/**\n * 64 * 1024\n * @type {number}\n * @constant\n */\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {number}\n * @constant\n */\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {number} value The value to return the sign of.\n * @returns {number} The sign of value.\n */\nCesiumMath.sign = defaultValue(Math.sign, function sign(value) {\n  value = +value; // coerce to number\n  if (value === 0 || value !== value) {\n    // zero or NaN\n    return value;\n  }\n  return value > 0 ? 1 : -1;\n});\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {number} value The value to return the sign of.\n * @returns {number} The sign of value.\n */\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {number} value The scalar value in the range [-1.0, 1.0]\n * @param {number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n};\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {number} value SNORM value in the range [0, rangeMaximum]\n * @param {number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;\n};\n\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {number} rangeMinimum The minimum value in the mapped range.\n * @param {number} rangeMaximum The maximum value in the mapped range.\n * @returns {number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0 ? 0.0 : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {number} value The number whose hyperbolic sine is to be returned.\n * @returns {number} The hyperbolic sine of <code>value</code>.\n */\nCesiumMath.sinh = defaultValue(Math.sinh, function sinh(value) {\n  return (Math.exp(value) - Math.exp(-value)) / 2.0;\n});\n\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {number} value The number whose hyperbolic cosine is to be returned.\n * @returns {number} The hyperbolic cosine of <code>value</code>.\n */\nCesiumMath.cosh = defaultValue(Math.cosh, function cosh(value) {\n  return (Math.exp(value) + Math.exp(-value)) / 2.0;\n});\n\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {number} p The start value to interpolate.\n * @param {number} q The end value to interpolate.\n * @param {number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {number} The linearly interpolated value.\n *\n * @example\n * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n\n/**\n * pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI = Math.PI;\n\n/**\n * 1/pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n/**\n * pi/2\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n\n/**\n * pi/3\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n/**\n * pi/4\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n/**\n * pi/6\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n/**\n * 3pi/2\n *\n * @type {number}\n * @constant\n */\nCesiumMath.THREE_PI_OVER_TWO = 3.0 * Math.PI / 2.0;\n\n/**\n * 2pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n\n/**\n * 1/2pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n/**\n * The number of radians in a degree.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n/**\n * The number of degrees in a radian.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n/**\n * The number of radians in an arc second.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n/**\n * Converts degrees to radians.\n * @param {number} degrees The angle to convert in degrees.\n * @returns {number} The corresponding angle in radians.\n */\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degrees)) {\n    throw new DeveloperError(\"degrees is required.\");\n  }\n  //>>includeEnd('debug');\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n\n/**\n * Converts radians to degrees.\n * @param {number} radians The angle to convert in radians.\n * @returns {number} The corresponding angle in degrees.\n */\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(radians)) {\n    throw new DeveloperError(\"radians is required.\");\n  }\n  //>>includeEnd('debug');\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  const twoPi = CesiumMath.TWO_PI;\n  const simplified = angle - Math.floor(angle / twoPi) * twoPi;\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n  return simplified;\n};\n\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return CesiumMath.clamp(angle, -1 * CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n};\n\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {number} angle in radians\n * @returns {number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {number} angle in radians\n * @returns {number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n  if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(angle) > CesiumMath.EPSILON14) {\n    return CesiumMath.TWO_PI;\n  }\n  return mod;\n};\n\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {number} m The dividend.\n * @param {number} n The divisor.\n * @returns {number} The remainder.\n */\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(m)) {\n    throw new DeveloperError(\"m is required.\");\n  }\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (n === 0.0) {\n    throw new DeveloperError(\"divisor cannot be 0.\");\n  }\n  //>>includeEnd('debug');\n  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {\n    // Early exit if the input does not need to be modded. This avoids\n    // unnecessary math which could introduce floating point error.\n    return m;\n  }\n  return (m % n + n) % n;\n};\n\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {number} left The first value to compare.\n * @param {number} right The other value to compare.\n * @param {number} [relativeEpsilon=0] The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\nCesiumMath.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  relativeEpsilon = defaultValue(relativeEpsilon, 0.0);\n  absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);\n  const absDiff = Math.abs(left - right);\n  return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));\n};\n\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < -absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > -absoluteEpsilon;\n};\nconst factorials = [1];\n\n/**\n * Computes the factorial of the provided number.\n *\n * @param {number} n The number whose factorial is to be computed.\n * @returns {number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\"A number greater than or equal to 0 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = factorials.length;\n  if (n >= length) {\n    let sum = factorials[length - 1];\n    for (let i = length; i <= n; i++) {\n      const next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n  return factorials[n];\n};\n\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {number} [n] The number to be incremented.\n * @param {number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = defaultValue(minimumValue, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (maximumValue <= minimumValue) {\n    throw new DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  }\n  //>>includeEnd('debug');\n\n  ++n;\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n  return n;\n};\n\n/**\n * Determines if a non-negative integer is a power of two.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, (2^32)-1].\n * @returns {boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false\n */\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return n !== 0 && (n & n - 1) === 0;\n};\n\n/**\n * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.\n * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, 2^31].\n * @returns {number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and 2^31 is required.\n *\n * @example\n * const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 2147483648) {\n    throw new DeveloperError(\"A number between 0 and 2^31 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n  return n;\n};\n\n/**\n * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, (2^32)-1].\n * @returns {number} The previous power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32\n */\nCesiumMath.previousPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n\n  // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned\n  n = (n >>> 0) - (n >>> 1);\n  return n;\n};\n\n/**\n * Constraint a value to lie between two values.\n *\n * @param {number} value The value to clamp.\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} The clamped value such that min <= result <= max.\n */\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  Check.typeOf.number(\"min\", min);\n  Check.typeOf.number(\"max\", max);\n  //>>includeEnd('debug');\n\n  return value < min ? min : value > max ? max : value;\n};\nlet randomNumberGenerator = new MersenneTwister();\n\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {number} seed An integer used as the seed.\n */\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(seed)) {\n    throw new DeveloperError(\"seed is required.\");\n  }\n  //>>includeEnd('debug');\n\n  randomNumberGenerator = new MersenneTwister(seed);\n};\n\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n\n/**\n * Generates a random number between two numbers.\n *\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} A random number between the min and max.\n */\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {number} value The value for which to compute acos.\n * @returns {number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {number} value The value for which to compute asin.\n * @returns {number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {number} angle The angle between the two points.\n * @param {number} radius The radius of the circle.\n * @returns {number} The chord length.\n */\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  if (!defined(radius)) {\n    throw new DeveloperError(\"radius is required.\");\n  }\n  //>>includeEnd('debug');\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {number} number The number.\n * @param {number} base The base.\n * @returns {number} The result.\n */\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(number)) {\n    throw new DeveloperError(\"number is required.\");\n  }\n  if (!defined(base)) {\n    throw new DeveloperError(\"base is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.log(number) / Math.log(base);\n};\n\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {number} [number] The number.\n * @returns {number} The result.\n */\nCesiumMath.cbrt = defaultValue(Math.cbrt, function cbrt(number) {\n  const result = Math.pow(Math.abs(number), 1.0 / 3.0);\n  return number < 0.0 ? -result : result;\n});\n\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {number} number The number.\n * @returns {number} The result.\n */\nCesiumMath.log2 = defaultValue(Math.log2, function log2(number) {\n  return Math.log(number) * Math.LOG2E;\n});\n\n/**\n * Calculate the fog impact at a given distance. Useful for culling.\n * Matches the equation in `fog.glsl`\n * @private\n */\nCesiumMath.fog = function (distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {number} x An input number in the range [-1, 1]\n * @returns {number} An approximation of atan(x)\n */\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {number} x An input number that isn't zero if y is zero.\n * @param {number} y An input number that isn't zero if x is zero.\n * @returns {number} An approximation of atan2(x, y)\n */\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  //>>includeEnd('debug');\n\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n  let opposite;\n  let t = Math.abs(x); // t used as swap and atan result.\n  opposite = Math.abs(y);\n  const adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n  const oppositeOverAdjacent = opposite / adjacent;\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new DeveloperError(\"either x or y must be nonzero\");\n  }\n  //>>includeEnd('debug');\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);\n\n  // Undo range reduction\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\nexport default CesiumMath;","map":{"version":3,"names":["MersenneTwister","Check","defaultValue","defined","DeveloperError","CesiumMath","EPSILON1","EPSILON2","EPSILON3","EPSILON4","EPSILON5","EPSILON6","EPSILON7","EPSILON8","EPSILON9","EPSILON10","EPSILON11","EPSILON12","EPSILON13","EPSILON14","EPSILON15","EPSILON16","EPSILON17","EPSILON18","EPSILON19","EPSILON20","EPSILON21","GRAVITATIONALPARAMETER","SOLAR_RADIUS","LUNAR_RADIUS","SIXTY_FOUR_KILOBYTES","FOUR_GIGABYTES","sign","Math","value","signNotZero","toSNorm","rangeMaximum","round","clamp","fromSNorm","normalize","rangeMinimum","max","sinh","exp","cosh","lerp","p","q","time","PI","ONE_OVER_PI","PI_OVER_TWO","PI_OVER_THREE","PI_OVER_FOUR","PI_OVER_SIX","THREE_PI_OVER_TWO","TWO_PI","ONE_OVER_TWO_PI","RADIANS_PER_DEGREE","DEGREES_PER_RADIAN","RADIANS_PER_ARCSECOND","toRadians","degrees","toDegrees","radians","convertLongitudeRange","angle","twoPi","simplified","floor","clampToLatitudeRange","negativePiToPi","zeroToTwoPi","mod","abs","m","n","equalsEpsilon","left","right","relativeEpsilon","absoluteEpsilon","absDiff","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","factorials","factorial","length","sum","i","next","push","incrementWrap","maximumValue","minimumValue","isPowerOfTwo","nextPowerOfTwo","previousPowerOfTwo","min","typeOf","number","randomNumberGenerator","setRandomNumberSeed","seed","nextRandomNumber","random","randomBetween","acosClamped","acos","asinClamped","asin","chordLength","radius","sin","logBase","base","log","cbrt","result","pow","log2","LOG2E","fog","distanceToCamera","density","scalar","fastApproximateAtan","x","fastApproximateAtan2","y","opposite","t","adjacent","oppositeOverAdjacent","isNaN"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Math.js"],"sourcesContent":["import MersenneTwister from \"mersenne-twister\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\nconst CesiumMath = {};\n\n/**\n * 0.1\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON1 = 0.1;\n\n/**\n * 0.01\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON2 = 0.01;\n\n/**\n * 0.001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON3 = 0.001;\n\n/**\n * 0.0001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON4 = 0.0001;\n\n/**\n * 0.00001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON5 = 0.00001;\n\n/**\n * 0.000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON6 = 0.000001;\n\n/**\n * 0.0000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON7 = 0.0000001;\n\n/**\n * 0.00000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON8 = 0.00000001;\n\n/**\n * 0.000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON9 = 0.000000001;\n\n/**\n * 0.0000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON10 = 0.0000000001;\n\n/**\n * 0.00000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON11 = 0.00000000001;\n\n/**\n * 0.000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON12 = 0.000000000001;\n\n/**\n * 0.0000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON13 = 0.0000000000001;\n\n/**\n * 0.00000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON14 = 0.00000000000001;\n\n/**\n * 0.000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON15 = 0.000000000000001;\n\n/**\n * 0.0000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON16 = 0.0000000000000001;\n\n/**\n * 0.00000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON17 = 0.00000000000000001;\n\n/**\n * 0.000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON18 = 0.000000000000000001;\n\n/**\n * 0.0000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n\n/**\n * 0.00000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n\n/**\n * 0.000000000000000000001\n * @type {number}\n * @constant\n */\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {number}\n * @constant\n */\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {number}\n * @constant\n */\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {number}\n * @constant\n */\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n\n/**\n * 64 * 1024\n * @type {number}\n * @constant\n */\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {number}\n * @constant\n */\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {number} value The value to return the sign of.\n * @returns {number} The sign of value.\n */\nCesiumMath.sign = defaultValue(Math.sign, function sign(value) {\n  value = +value; // coerce to number\n  if (value === 0 || value !== value) {\n    // zero or NaN\n    return value;\n  }\n  return value > 0 ? 1 : -1;\n});\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {number} value The value to return the sign of.\n * @returns {number} The sign of value.\n */\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {number} value The scalar value in the range [-1.0, 1.0]\n * @param {number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return Math.round(\n    (CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum,\n  );\n};\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {number} value SNORM value in the range [0, rangeMaximum]\n * @param {number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return (\n    (CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0\n  );\n};\n\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {number} rangeMinimum The minimum value in the mapped range.\n * @param {number} rangeMaximum The maximum value in the mapped range.\n * @returns {number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0\n    ? 0.0\n    : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {number} value The number whose hyperbolic sine is to be returned.\n * @returns {number} The hyperbolic sine of <code>value</code>.\n */\nCesiumMath.sinh = defaultValue(Math.sinh, function sinh(value) {\n  return (Math.exp(value) - Math.exp(-value)) / 2.0;\n});\n\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {number} value The number whose hyperbolic cosine is to be returned.\n * @returns {number} The hyperbolic cosine of <code>value</code>.\n */\nCesiumMath.cosh = defaultValue(Math.cosh, function cosh(value) {\n  return (Math.exp(value) + Math.exp(-value)) / 2.0;\n});\n\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {number} p The start value to interpolate.\n * @param {number} q The end value to interpolate.\n * @param {number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {number} The linearly interpolated value.\n *\n * @example\n * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n\n/**\n * pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI = Math.PI;\n\n/**\n * 1/pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n/**\n * pi/2\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n\n/**\n * pi/3\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n/**\n * pi/4\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n/**\n * pi/6\n *\n * @type {number}\n * @constant\n */\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n/**\n * 3pi/2\n *\n * @type {number}\n * @constant\n */\nCesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) / 2.0;\n\n/**\n * 2pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n\n/**\n * 1/2pi\n *\n * @type {number}\n * @constant\n */\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n/**\n * The number of radians in a degree.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n/**\n * The number of degrees in a radian.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n/**\n * The number of radians in an arc second.\n *\n * @type {number}\n * @constant\n */\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n/**\n * Converts degrees to radians.\n * @param {number} degrees The angle to convert in degrees.\n * @returns {number} The corresponding angle in radians.\n */\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degrees)) {\n    throw new DeveloperError(\"degrees is required.\");\n  }\n  //>>includeEnd('debug');\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n\n/**\n * Converts radians to degrees.\n * @param {number} radians The angle to convert in radians.\n * @returns {number} The corresponding angle in degrees.\n */\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(radians)) {\n    throw new DeveloperError(\"radians is required.\");\n  }\n  //>>includeEnd('debug');\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  const twoPi = CesiumMath.TWO_PI;\n\n  const simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n\n  return simplified;\n};\n\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return CesiumMath.clamp(\n    angle,\n    -1 * CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO,\n  );\n};\n\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {number} angle in radians\n * @returns {number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {number} angle in radians\n * @returns {number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n  if (\n    Math.abs(mod) < CesiumMath.EPSILON14 &&\n    Math.abs(angle) > CesiumMath.EPSILON14\n  ) {\n    return CesiumMath.TWO_PI;\n  }\n  return mod;\n};\n\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {number} m The dividend.\n * @param {number} n The divisor.\n * @returns {number} The remainder.\n */\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(m)) {\n    throw new DeveloperError(\"m is required.\");\n  }\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (n === 0.0) {\n    throw new DeveloperError(\"divisor cannot be 0.\");\n  }\n  //>>includeEnd('debug');\n  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {\n    // Early exit if the input does not need to be modded. This avoids\n    // unnecessary math which could introduce floating point error.\n    return m;\n  }\n\n  return ((m % n) + n) % n;\n};\n\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {number} left The first value to compare.\n * @param {number} right The other value to compare.\n * @param {number} [relativeEpsilon=0] The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\nCesiumMath.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  relativeEpsilon = defaultValue(relativeEpsilon, 0.0);\n  absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);\n  const absDiff = Math.abs(left - right);\n  return (\n    absDiff <= absoluteEpsilon ||\n    absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right))\n  );\n};\n\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < -absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {number} left The first number to compare.\n * @param {number} right The second number to compare.\n * @param {number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > -absoluteEpsilon;\n};\n\nconst factorials = [1];\n\n/**\n * Computes the factorial of the provided number.\n *\n * @param {number} n The number whose factorial is to be computed.\n * @returns {number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\n      \"A number greater than or equal to 0 is required.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = factorials.length;\n  if (n >= length) {\n    let sum = factorials[length - 1];\n    for (let i = length; i <= n; i++) {\n      const next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n  return factorials[n];\n};\n\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {number} [n] The number to be incremented.\n * @param {number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = defaultValue(minimumValue, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (maximumValue <= minimumValue) {\n    throw new DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  }\n  //>>includeEnd('debug');\n\n  ++n;\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n  return n;\n};\n\n/**\n * Determines if a non-negative integer is a power of two.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, (2^32)-1].\n * @returns {boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false\n */\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return n !== 0 && (n & (n - 1)) === 0;\n};\n\n/**\n * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.\n * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, 2^31].\n * @returns {number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and 2^31 is required.\n *\n * @example\n * const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 2147483648) {\n    throw new DeveloperError(\"A number between 0 and 2^31 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n\n  return n;\n};\n\n/**\n * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {number} n The integer to test in the range [0, (2^32)-1].\n * @returns {number} The previous power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32\n */\nCesiumMath.previousPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n\n  // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned\n  n = (n >>> 0) - (n >>> 1);\n\n  return n;\n};\n\n/**\n * Constraint a value to lie between two values.\n *\n * @param {number} value The value to clamp.\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} The clamped value such that min <= result <= max.\n */\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  Check.typeOf.number(\"min\", min);\n  Check.typeOf.number(\"max\", max);\n  //>>includeEnd('debug');\n\n  return value < min ? min : value > max ? max : value;\n};\n\nlet randomNumberGenerator = new MersenneTwister();\n\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {number} seed An integer used as the seed.\n */\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(seed)) {\n    throw new DeveloperError(\"seed is required.\");\n  }\n  //>>includeEnd('debug');\n\n  randomNumberGenerator = new MersenneTwister(seed);\n};\n\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n\n/**\n * Generates a random number between two numbers.\n *\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} A random number between the min and max.\n */\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {number} value The value for which to compute acos.\n * @returns {number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {number} value The value for which to compute asin.\n * @returns {number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {number} angle The angle between the two points.\n * @param {number} radius The radius of the circle.\n * @returns {number} The chord length.\n */\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  if (!defined(radius)) {\n    throw new DeveloperError(\"radius is required.\");\n  }\n  //>>includeEnd('debug');\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {number} number The number.\n * @param {number} base The base.\n * @returns {number} The result.\n */\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(number)) {\n    throw new DeveloperError(\"number is required.\");\n  }\n  if (!defined(base)) {\n    throw new DeveloperError(\"base is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.log(number) / Math.log(base);\n};\n\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {number} [number] The number.\n * @returns {number} The result.\n */\nCesiumMath.cbrt = defaultValue(Math.cbrt, function cbrt(number) {\n  const result = Math.pow(Math.abs(number), 1.0 / 3.0);\n  return number < 0.0 ? -result : result;\n});\n\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {number} number The number.\n * @returns {number} The result.\n */\nCesiumMath.log2 = defaultValue(Math.log2, function log2(number) {\n  return Math.log(number) * Math.LOG2E;\n});\n\n/**\n * Calculate the fog impact at a given distance. Useful for culling.\n * Matches the equation in `fog.glsl`\n * @private\n */\nCesiumMath.fog = function (distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {number} x An input number in the range [-1, 1]\n * @returns {number} An approximation of atan(x)\n */\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {number} x An input number that isn't zero if y is zero.\n * @param {number} y An input number that isn't zero if x is zero.\n * @returns {number} An approximation of atan2(x, y)\n */\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  //>>includeEnd('debug');\n\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n  let opposite;\n  let t = Math.abs(x); // t used as swap and atan result.\n  opposite = Math.abs(y);\n  const adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n\n  const oppositeOverAdjacent = opposite / adjacent;\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new DeveloperError(\"either x or y must be nonzero\");\n  }\n  //>>includeEnd('debug');\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);\n\n  // Undo range reduction\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\nexport default CesiumMath;\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,kBAAkB;AAC9C,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG,CAAC,CAAC;;AAErB;AACA;AACA;AACA;AACA;AACAA,UAAU,CAACC,QAAQ,GAAG,GAAG;;AAEzB;AACA;AACA;AACA;AACA;AACAD,UAAU,CAACE,QAAQ,GAAG,IAAI;;AAE1B;AACA;AACA;AACA;AACA;AACAF,UAAU,CAACG,QAAQ,GAAG,KAAK;;AAE3B;AACA;AACA;AACA;AACA;AACAH,UAAU,CAACI,QAAQ,GAAG,MAAM;;AAE5B;AACA;AACA;AACA;AACA;AACAJ,UAAU,CAACK,QAAQ,GAAG,OAAO;;AAE7B;AACA;AACA;AACA;AACA;AACAL,UAAU,CAACM,QAAQ,GAAG,QAAQ;;AAE9B;AACA;AACA;AACA;AACA;AACAN,UAAU,CAACO,QAAQ,GAAG,SAAS;;AAE/B;AACA;AACA;AACA;AACA;AACAP,UAAU,CAACQ,QAAQ,GAAG,UAAU;;AAEhC;AACA;AACA;AACA;AACA;AACAR,UAAU,CAACS,QAAQ,GAAG,WAAW;;AAEjC;AACA;AACA;AACA;AACA;AACAT,UAAU,CAACU,SAAS,GAAG,YAAY;;AAEnC;AACA;AACA;AACA;AACA;AACAV,UAAU,CAACW,SAAS,GAAG,aAAa;;AAEpC;AACA;AACA;AACA;AACA;AACAX,UAAU,CAACY,SAAS,GAAG,cAAc;;AAErC;AACA;AACA;AACA;AACA;AACAZ,UAAU,CAACa,SAAS,GAAG,eAAe;;AAEtC;AACA;AACA;AACA;AACA;AACAb,UAAU,CAACc,SAAS,GAAG,gBAAgB;;AAEvC;AACA;AACA;AACA;AACA;AACAd,UAAU,CAACe,SAAS,GAAG,iBAAiB;;AAExC;AACA;AACA;AACA;AACA;AACAf,UAAU,CAACgB,SAAS,GAAG,kBAAkB;;AAEzC;AACA;AACA;AACA;AACA;AACAhB,UAAU,CAACiB,SAAS,GAAG,mBAAmB;;AAE1C;AACA;AACA;AACA;AACA;AACAjB,UAAU,CAACkB,SAAS,GAAG,oBAAoB;;AAE3C;AACA;AACA;AACA;AACA;AACAlB,UAAU,CAACmB,SAAS,GAAG,qBAAqB;;AAE5C;AACA;AACA;AACA;AACA;AACAnB,UAAU,CAACoB,SAAS,GAAG,sBAAsB;;AAE7C;AACA;AACA;AACA;AACA;AACApB,UAAU,CAACqB,SAAS,GAAG,uBAAuB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACArB,UAAU,CAACsB,sBAAsB,GAAG,cAAc;;AAElD;AACA;AACA;AACA;AACA;AACAtB,UAAU,CAACuB,YAAY,GAAG,OAAO;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,UAAU,CAACwB,YAAY,GAAG,SAAS;;AAEnC;AACA;AACA;AACA;AACA;AACAxB,UAAU,CAACyB,oBAAoB,GAAG,EAAE,GAAG,IAAI;;AAE3C;AACA;AACA;AACA;AACA;AACAzB,UAAU,CAAC0B,cAAc,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1B,UAAU,CAAC2B,IAAI,GAAG9B,YAAY,CAAC+B,IAAI,CAACD,IAAI,EAAE,SAASA,IAAIA,CAACE,KAAK,EAAE;EAC7DA,KAAK,GAAG,CAACA,KAAK,CAAC,CAAC;EAChB,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAKA,KAAK,EAAE;IAClC;IACA,OAAOA,KAAK;EACd;EACA,OAAOA,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC3B,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,UAAU,CAAC8B,WAAW,GAAG,UAAUD,KAAK,EAAE;EACxC,OAAOA,KAAK,GAAG,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,UAAU,CAAC+B,OAAO,GAAG,UAAUF,KAAK,EAAEG,YAAY,EAAE;EAClDA,YAAY,GAAGnC,YAAY,CAACmC,YAAY,EAAE,GAAG,CAAC;EAC9C,OAAOJ,IAAI,CAACK,KAAK,CACf,CAACjC,UAAU,CAACkC,KAAK,CAACL,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,IAAIG,YACrD,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhC,UAAU,CAACmC,SAAS,GAAG,UAAUN,KAAK,EAAEG,YAAY,EAAE;EACpDA,YAAY,GAAGnC,YAAY,CAACmC,YAAY,EAAE,GAAG,CAAC;EAC9C,OACGhC,UAAU,CAACkC,KAAK,CAACL,KAAK,EAAE,GAAG,EAAEG,YAAY,CAAC,GAAGA,YAAY,GAAI,GAAG,GAAG,GAAG;AAE3E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAhC,UAAU,CAACoC,SAAS,GAAG,UAAUP,KAAK,EAAEQ,YAAY,EAAEL,YAAY,EAAE;EAClEA,YAAY,GAAGJ,IAAI,CAACU,GAAG,CAACN,YAAY,GAAGK,YAAY,EAAE,GAAG,CAAC;EACzD,OAAOL,YAAY,KAAK,GAAG,GACvB,GAAG,GACHhC,UAAU,CAACkC,KAAK,CAAC,CAACL,KAAK,GAAGQ,YAAY,IAAIL,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC;AACvE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhC,UAAU,CAACuC,IAAI,GAAG1C,YAAY,CAAC+B,IAAI,CAACW,IAAI,EAAE,SAASA,IAAIA,CAACV,KAAK,EAAE;EAC7D,OAAO,CAACD,IAAI,CAACY,GAAG,CAACX,KAAK,CAAC,GAAGD,IAAI,CAACY,GAAG,CAAC,CAACX,KAAK,CAAC,IAAI,GAAG;AACnD,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,UAAU,CAACyC,IAAI,GAAG5C,YAAY,CAAC+B,IAAI,CAACa,IAAI,EAAE,SAASA,IAAIA,CAACZ,KAAK,EAAE;EAC7D,OAAO,CAACD,IAAI,CAACY,GAAG,CAACX,KAAK,CAAC,GAAGD,IAAI,CAACY,GAAG,CAAC,CAACX,KAAK,CAAC,IAAI,GAAG;AACnD,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,UAAU,CAAC0C,IAAI,GAAG,UAAUC,CAAC,EAAEC,CAAC,EAAEC,IAAI,EAAE;EACtC,OAAO,CAAC,GAAG,GAAGA,IAAI,IAAIF,CAAC,GAAGE,IAAI,GAAGD,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA5C,UAAU,CAAC8C,EAAE,GAAGlB,IAAI,CAACkB,EAAE;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAAC+C,WAAW,GAAG,GAAG,GAAGnB,IAAI,CAACkB,EAAE;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACgD,WAAW,GAAGpB,IAAI,CAACkB,EAAE,GAAG,GAAG;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACiD,aAAa,GAAGrB,IAAI,CAACkB,EAAE,GAAG,GAAG;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACkD,YAAY,GAAGtB,IAAI,CAACkB,EAAE,GAAG,GAAG;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACmD,WAAW,GAAGvB,IAAI,CAACkB,EAAE,GAAG,GAAG;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACoD,iBAAiB,GAAI,GAAG,GAAGxB,IAAI,CAACkB,EAAE,GAAI,GAAG;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACqD,MAAM,GAAG,GAAG,GAAGzB,IAAI,CAACkB,EAAE;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACsD,eAAe,GAAG,GAAG,IAAI,GAAG,GAAG1B,IAAI,CAACkB,EAAE,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACuD,kBAAkB,GAAG3B,IAAI,CAACkB,EAAE,GAAG,KAAK;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACwD,kBAAkB,GAAG,KAAK,GAAG5B,IAAI,CAACkB,EAAE;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACyD,qBAAqB,GAAGzD,UAAU,CAACuD,kBAAkB,GAAG,MAAM;;AAEzE;AACA;AACA;AACA;AACA;AACAvD,UAAU,CAAC0D,SAAS,GAAG,UAAUC,OAAO,EAAE;EACxC;EACA,IAAI,CAAC7D,OAAO,CAAC6D,OAAO,CAAC,EAAE;IACrB,MAAM,IAAI5D,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA;EACA,OAAO4D,OAAO,GAAG3D,UAAU,CAACuD,kBAAkB;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAvD,UAAU,CAAC4D,SAAS,GAAG,UAAUC,OAAO,EAAE;EACxC;EACA,IAAI,CAAC/D,OAAO,CAAC+D,OAAO,CAAC,EAAE;IACrB,MAAM,IAAI9D,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA;EACA,OAAO8D,OAAO,GAAG7D,UAAU,CAACwD,kBAAkB;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxD,UAAU,CAAC8D,qBAAqB,GAAG,UAAUC,KAAK,EAAE;EAClD;EACA,IAAI,CAACjE,OAAO,CAACiE,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIhE,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;EACA,MAAMiE,KAAK,GAAGhE,UAAU,CAACqD,MAAM;EAE/B,MAAMY,UAAU,GAAGF,KAAK,GAAGnC,IAAI,CAACsC,KAAK,CAACH,KAAK,GAAGC,KAAK,CAAC,GAAGA,KAAK;EAE5D,IAAIC,UAAU,GAAG,CAACrC,IAAI,CAACkB,EAAE,EAAE;IACzB,OAAOmB,UAAU,GAAGD,KAAK;EAC3B;EACA,IAAIC,UAAU,IAAIrC,IAAI,CAACkB,EAAE,EAAE;IACzB,OAAOmB,UAAU,GAAGD,KAAK;EAC3B;EAEA,OAAOC,UAAU;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjE,UAAU,CAACmE,oBAAoB,GAAG,UAAUJ,KAAK,EAAE;EACjD;EACA,IAAI,CAACjE,OAAO,CAACiE,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIhE,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA,OAAOC,UAAU,CAACkC,KAAK,CACrB6B,KAAK,EACL,CAAC,CAAC,GAAG/D,UAAU,CAACgD,WAAW,EAC3BhD,UAAU,CAACgD,WACb,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAhD,UAAU,CAACoE,cAAc,GAAG,UAAUL,KAAK,EAAE;EAC3C;EACA,IAAI,CAACjE,OAAO,CAACiE,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIhE,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;EACA,IAAIgE,KAAK,IAAI,CAAC/D,UAAU,CAAC8C,EAAE,IAAIiB,KAAK,IAAI/D,UAAU,CAAC8C,EAAE,EAAE;IACrD;IACA;IACA,OAAOiB,KAAK;EACd;EACA,OAAO/D,UAAU,CAACqE,WAAW,CAACN,KAAK,GAAG/D,UAAU,CAAC8C,EAAE,CAAC,GAAG9C,UAAU,CAAC8C,EAAE;AACtE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACqE,WAAW,GAAG,UAAUN,KAAK,EAAE;EACxC;EACA,IAAI,CAACjE,OAAO,CAACiE,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIhE,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;EACA,IAAIgE,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI/D,UAAU,CAACqD,MAAM,EAAE;IAC5C;IACA;IACA,OAAOU,KAAK;EACd;EACA,MAAMO,GAAG,GAAGtE,UAAU,CAACsE,GAAG,CAACP,KAAK,EAAE/D,UAAU,CAACqD,MAAM,CAAC;EACpD,IACEzB,IAAI,CAAC2C,GAAG,CAACD,GAAG,CAAC,GAAGtE,UAAU,CAACc,SAAS,IACpCc,IAAI,CAAC2C,GAAG,CAACR,KAAK,CAAC,GAAG/D,UAAU,CAACc,SAAS,EACtC;IACA,OAAOd,UAAU,CAACqD,MAAM;EAC1B;EACA,OAAOiB,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAtE,UAAU,CAACsE,GAAG,GAAG,UAAUE,CAAC,EAAEC,CAAC,EAAE;EAC/B;EACA,IAAI,CAAC3E,OAAO,CAAC0E,CAAC,CAAC,EAAE;IACf,MAAM,IAAIzE,cAAc,CAAC,gBAAgB,CAAC;EAC5C;EACA,IAAI,CAACD,OAAO,CAAC2E,CAAC,CAAC,EAAE;IACf,MAAM,IAAI1E,cAAc,CAAC,gBAAgB,CAAC;EAC5C;EACA,IAAI0E,CAAC,KAAK,GAAG,EAAE;IACb,MAAM,IAAI1E,cAAc,CAAC,sBAAsB,CAAC;EAClD;EACA;EACA,IAAIC,UAAU,CAAC2B,IAAI,CAAC6C,CAAC,CAAC,KAAKxE,UAAU,CAAC2B,IAAI,CAAC8C,CAAC,CAAC,IAAI7C,IAAI,CAAC2C,GAAG,CAACC,CAAC,CAAC,GAAG5C,IAAI,CAAC2C,GAAG,CAACE,CAAC,CAAC,EAAE;IAC1E;IACA;IACA,OAAOD,CAAC;EACV;EAEA,OAAO,CAAEA,CAAC,GAAGC,CAAC,GAAIA,CAAC,IAAIA,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,UAAU,CAAC0E,aAAa,GAAG,UACzBC,IAAI,EACJC,KAAK,EACLC,eAAe,EACfC,eAAe,EACf;EACA;EACA,IAAI,CAAChF,OAAO,CAAC6E,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI5E,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA,IAAI,CAACD,OAAO,CAAC8E,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI7E,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA8E,eAAe,GAAGhF,YAAY,CAACgF,eAAe,EAAE,GAAG,CAAC;EACpDC,eAAe,GAAGjF,YAAY,CAACiF,eAAe,EAAED,eAAe,CAAC;EAChE,MAAME,OAAO,GAAGnD,IAAI,CAAC2C,GAAG,CAACI,IAAI,GAAGC,KAAK,CAAC;EACtC,OACEG,OAAO,IAAID,eAAe,IAC1BC,OAAO,IAAIF,eAAe,GAAGjD,IAAI,CAACU,GAAG,CAACV,IAAI,CAAC2C,GAAG,CAACI,IAAI,CAAC,EAAE/C,IAAI,CAAC2C,GAAG,CAACK,KAAK,CAAC,CAAC;AAE1E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5E,UAAU,CAACgF,QAAQ,GAAG,UAAUL,IAAI,EAAEC,KAAK,EAAEE,eAAe,EAAE;EAC5D;EACA,IAAI,CAAChF,OAAO,CAAC6E,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI5E,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA,IAAI,CAACD,OAAO,CAAC8E,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI7E,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA,IAAI,CAACD,OAAO,CAACgF,eAAe,CAAC,EAAE;IAC7B,MAAM,IAAI/E,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;EACA,OAAO4E,IAAI,GAAGC,KAAK,GAAG,CAACE,eAAe;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9E,UAAU,CAACiF,gBAAgB,GAAG,UAAUN,IAAI,EAAEC,KAAK,EAAEE,eAAe,EAAE;EACpE;EACA,IAAI,CAAChF,OAAO,CAAC6E,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI5E,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA,IAAI,CAACD,OAAO,CAAC8E,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI7E,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA,IAAI,CAACD,OAAO,CAACgF,eAAe,CAAC,EAAE;IAC7B,MAAM,IAAI/E,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;EACA,OAAO4E,IAAI,GAAGC,KAAK,GAAGE,eAAe;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9E,UAAU,CAACkF,WAAW,GAAG,UAAUP,IAAI,EAAEC,KAAK,EAAEE,eAAe,EAAE;EAC/D;EACA,IAAI,CAAChF,OAAO,CAAC6E,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI5E,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA,IAAI,CAACD,OAAO,CAAC8E,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI7E,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA,IAAI,CAACD,OAAO,CAACgF,eAAe,CAAC,EAAE;IAC7B,MAAM,IAAI/E,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;EACA,OAAO4E,IAAI,GAAGC,KAAK,GAAGE,eAAe;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9E,UAAU,CAACmF,mBAAmB,GAAG,UAAUR,IAAI,EAAEC,KAAK,EAAEE,eAAe,EAAE;EACvE;EACA,IAAI,CAAChF,OAAO,CAAC6E,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI5E,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA,IAAI,CAACD,OAAO,CAAC8E,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI7E,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA,IAAI,CAACD,OAAO,CAACgF,eAAe,CAAC,EAAE;IAC7B,MAAM,IAAI/E,cAAc,CAAC,8BAA8B,CAAC;EAC1D;EACA;EACA,OAAO4E,IAAI,GAAGC,KAAK,GAAG,CAACE,eAAe;AACxC,CAAC;AAED,MAAMM,UAAU,GAAG,CAAC,CAAC,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApF,UAAU,CAACqF,SAAS,GAAG,UAAUZ,CAAC,EAAE;EAClC;EACA,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,EAAE;IAClC,MAAM,IAAI1E,cAAc,CACtB,kDACF,CAAC;EACH;EACA;;EAEA,MAAMuF,MAAM,GAAGF,UAAU,CAACE,MAAM;EAChC,IAAIb,CAAC,IAAIa,MAAM,EAAE;IACf,IAAIC,GAAG,GAAGH,UAAU,CAACE,MAAM,GAAG,CAAC,CAAC;IAChC,KAAK,IAAIE,CAAC,GAAGF,MAAM,EAAEE,CAAC,IAAIf,CAAC,EAAEe,CAAC,EAAE,EAAE;MAChC,MAAMC,IAAI,GAAGF,GAAG,GAAGC,CAAC;MACpBJ,UAAU,CAACM,IAAI,CAACD,IAAI,CAAC;MACrBF,GAAG,GAAGE,IAAI;IACZ;EACF;EACA,OAAOL,UAAU,CAACX,CAAC,CAAC;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,UAAU,CAAC2F,aAAa,GAAG,UAAUlB,CAAC,EAAEmB,YAAY,EAAEC,YAAY,EAAE;EAClEA,YAAY,GAAGhG,YAAY,CAACgG,YAAY,EAAE,GAAG,CAAC;;EAE9C;EACA,IAAI,CAAC/F,OAAO,CAAC2E,CAAC,CAAC,EAAE;IACf,MAAM,IAAI1E,cAAc,CAAC,gBAAgB,CAAC;EAC5C;EACA,IAAI6F,YAAY,IAAIC,YAAY,EAAE;IAChC,MAAM,IAAI9F,cAAc,CAAC,iDAAiD,CAAC;EAC7E;EACA;;EAEA,EAAE0E,CAAC;EACH,IAAIA,CAAC,GAAGmB,YAAY,EAAE;IACpBnB,CAAC,GAAGoB,YAAY;EAClB;EACA,OAAOpB,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,UAAU,CAAC8F,YAAY,GAAG,UAAUrB,CAAC,EAAE;EACrC;EACA,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAG,UAAU,EAAE;IACpD,MAAM,IAAI1E,cAAc,CAAC,8CAA8C,CAAC;EAC1E;EACA;;EAEA,OAAO0E,CAAC,KAAK,CAAC,IAAI,CAACA,CAAC,GAAIA,CAAC,GAAG,CAAE,MAAM,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,UAAU,CAAC+F,cAAc,GAAG,UAAUtB,CAAC,EAAE;EACvC;EACA,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAG,UAAU,EAAE;IACpD,MAAM,IAAI1E,cAAc,CAAC,0CAA0C,CAAC;EACtE;EACA;;EAEA;EACA,EAAE0E,CAAC;EACHA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,EAAE;EACZ,EAAEA,CAAC;EAEH,OAAOA,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,UAAU,CAACgG,kBAAkB,GAAG,UAAUvB,CAAC,EAAE;EAC3C;EACA,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAG,UAAU,EAAE;IACpD,MAAM,IAAI1E,cAAc,CAAC,8CAA8C,CAAC;EAC1E;EACA;;EAEA0E,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,CAAC;EACXA,CAAC,IAAIA,CAAC,IAAI,EAAE;EACZA,CAAC,IAAIA,CAAC,IAAI,EAAE;;EAEZ;EACAA,CAAC,GAAG,CAACA,CAAC,KAAK,CAAC,KAAKA,CAAC,KAAK,CAAC,CAAC;EAEzB,OAAOA,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzE,UAAU,CAACkC,KAAK,GAAG,UAAUL,KAAK,EAAEoE,GAAG,EAAE3D,GAAG,EAAE;EAC5C;EACA1C,KAAK,CAACsG,MAAM,CAACC,MAAM,CAAC,OAAO,EAAEtE,KAAK,CAAC;EACnCjC,KAAK,CAACsG,MAAM,CAACC,MAAM,CAAC,KAAK,EAAEF,GAAG,CAAC;EAC/BrG,KAAK,CAACsG,MAAM,CAACC,MAAM,CAAC,KAAK,EAAE7D,GAAG,CAAC;EAC/B;;EAEA,OAAOT,KAAK,GAAGoE,GAAG,GAAGA,GAAG,GAAGpE,KAAK,GAAGS,GAAG,GAAGA,GAAG,GAAGT,KAAK;AACtD,CAAC;AAED,IAAIuE,qBAAqB,GAAG,IAAIzG,eAAe,CAAC,CAAC;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACAK,UAAU,CAACqG,mBAAmB,GAAG,UAAUC,IAAI,EAAE;EAC/C;EACA,IAAI,CAACxG,OAAO,CAACwG,IAAI,CAAC,EAAE;IAClB,MAAM,IAAIvG,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA;;EAEAqG,qBAAqB,GAAG,IAAIzG,eAAe,CAAC2G,IAAI,CAAC;AACnD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtG,UAAU,CAACuG,gBAAgB,GAAG,YAAY;EACxC,OAAOH,qBAAqB,CAACI,MAAM,CAAC,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAxG,UAAU,CAACyG,aAAa,GAAG,UAAUR,GAAG,EAAE3D,GAAG,EAAE;EAC7C,OAAOtC,UAAU,CAACuG,gBAAgB,CAAC,CAAC,IAAIjE,GAAG,GAAG2D,GAAG,CAAC,GAAGA,GAAG;AAC1D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjG,UAAU,CAAC0G,WAAW,GAAG,UAAU7E,KAAK,EAAE;EACxC;EACA,IAAI,CAAC/B,OAAO,CAAC+B,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI9B,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;EACA,OAAO6B,IAAI,CAAC+E,IAAI,CAAC3G,UAAU,CAACkC,KAAK,CAACL,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,UAAU,CAAC4G,WAAW,GAAG,UAAU/E,KAAK,EAAE;EACxC;EACA,IAAI,CAAC/B,OAAO,CAAC+B,KAAK,CAAC,EAAE;IACnB,MAAM,IAAI9B,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;EACA,OAAO6B,IAAI,CAACiF,IAAI,CAAC7G,UAAU,CAACkC,KAAK,CAACL,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,UAAU,CAAC8G,WAAW,GAAG,UAAU/C,KAAK,EAAEgD,MAAM,EAAE;EAChD;EACA,IAAI,CAACjH,OAAO,CAACiE,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIhE,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA,IAAI,CAACD,OAAO,CAACiH,MAAM,CAAC,EAAE;IACpB,MAAM,IAAIhH,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA;EACA,OAAO,GAAG,GAAGgH,MAAM,GAAGnF,IAAI,CAACoF,GAAG,CAACjD,KAAK,GAAG,GAAG,CAAC;AAC7C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA/D,UAAU,CAACiH,OAAO,GAAG,UAAUd,MAAM,EAAEe,IAAI,EAAE;EAC3C;EACA,IAAI,CAACpH,OAAO,CAACqG,MAAM,CAAC,EAAE;IACpB,MAAM,IAAIpG,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA,IAAI,CAACD,OAAO,CAACoH,IAAI,CAAC,EAAE;IAClB,MAAM,IAAInH,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA;EACA,OAAO6B,IAAI,CAACuF,GAAG,CAAChB,MAAM,CAAC,GAAGvE,IAAI,CAACuF,GAAG,CAACD,IAAI,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlH,UAAU,CAACoH,IAAI,GAAGvH,YAAY,CAAC+B,IAAI,CAACwF,IAAI,EAAE,SAASA,IAAIA,CAACjB,MAAM,EAAE;EAC9D,MAAMkB,MAAM,GAAGzF,IAAI,CAAC0F,GAAG,CAAC1F,IAAI,CAAC2C,GAAG,CAAC4B,MAAM,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC;EACpD,OAAOA,MAAM,GAAG,GAAG,GAAG,CAACkB,MAAM,GAAGA,MAAM;AACxC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACArH,UAAU,CAACuH,IAAI,GAAG1H,YAAY,CAAC+B,IAAI,CAAC2F,IAAI,EAAE,SAASA,IAAIA,CAACpB,MAAM,EAAE;EAC9D,OAAOvE,IAAI,CAACuF,GAAG,CAAChB,MAAM,CAAC,GAAGvE,IAAI,CAAC4F,KAAK;AACtC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACAxH,UAAU,CAACyH,GAAG,GAAG,UAAUC,gBAAgB,EAAEC,OAAO,EAAE;EACpD,MAAMC,MAAM,GAAGF,gBAAgB,GAAGC,OAAO;EACzC,OAAO,GAAG,GAAG/F,IAAI,CAACY,GAAG,CAAC,EAAEoF,MAAM,GAAGA,MAAM,CAAC,CAAC;AAC3C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5H,UAAU,CAAC6H,mBAAmB,GAAG,UAAUC,CAAC,EAAE;EAC5C;EACAlI,KAAK,CAACsG,MAAM,CAACC,MAAM,CAAC,GAAG,EAAE2B,CAAC,CAAC;EAC3B;;EAEA,OAAOA,CAAC,IAAI,CAAC,MAAM,GAAGlG,IAAI,CAAC2C,GAAG,CAACuD,CAAC,CAAC,GAAG,MAAM,GAAGA,CAAC,GAAGA,CAAC,GAAG,MAAM,CAAC;AAC9D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9H,UAAU,CAAC+H,oBAAoB,GAAG,UAAUD,CAAC,EAAEE,CAAC,EAAE;EAChD;EACApI,KAAK,CAACsG,MAAM,CAACC,MAAM,CAAC,GAAG,EAAE2B,CAAC,CAAC;EAC3BlI,KAAK,CAACsG,MAAM,CAACC,MAAM,CAAC,GAAG,EAAE6B,CAAC,CAAC;EAC3B;;EAEA;EACA;EACA,IAAIC,QAAQ;EACZ,IAAIC,CAAC,GAAGtG,IAAI,CAAC2C,GAAG,CAACuD,CAAC,CAAC,CAAC,CAAC;EACrBG,QAAQ,GAAGrG,IAAI,CAAC2C,GAAG,CAACyD,CAAC,CAAC;EACtB,MAAMG,QAAQ,GAAGvG,IAAI,CAACU,GAAG,CAAC4F,CAAC,EAAED,QAAQ,CAAC;EACtCA,QAAQ,GAAGrG,IAAI,CAACqE,GAAG,CAACiC,CAAC,EAAED,QAAQ,CAAC;EAEhC,MAAMG,oBAAoB,GAAGH,QAAQ,GAAGE,QAAQ;EAChD;EACA,IAAIE,KAAK,CAACD,oBAAoB,CAAC,EAAE;IAC/B,MAAM,IAAIrI,cAAc,CAAC,+BAA+B,CAAC;EAC3D;EACA;EACAmI,CAAC,GAAGlI,UAAU,CAAC6H,mBAAmB,CAACO,oBAAoB,CAAC;;EAExD;EACAF,CAAC,GAAGtG,IAAI,CAAC2C,GAAG,CAACyD,CAAC,CAAC,GAAGpG,IAAI,CAAC2C,GAAG,CAACuD,CAAC,CAAC,GAAG9H,UAAU,CAACgD,WAAW,GAAGkF,CAAC,GAAGA,CAAC;EAC9DA,CAAC,GAAGJ,CAAC,GAAG,GAAG,GAAG9H,UAAU,CAAC8C,EAAE,GAAGoF,CAAC,GAAGA,CAAC;EACnCA,CAAC,GAAGF,CAAC,GAAG,GAAG,GAAG,CAACE,CAAC,GAAGA,CAAC;EACpB,OAAOA,CAAC;AACV,CAAC;AACD,eAAelI,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}