{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport MetadataTable from \"./MetadataTable.js\";\n\n/**\n * An object representing voxel content for a {@link Cesium3DTilesVoxelProvider}.\n *\n * @alias VoxelContent\n * @constructor\n *\n * @param {Resource} resource The resource for this voxel content. This is used for fetching external buffers as needed.\n *\n * @private\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelContent(resource) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  //>>includeEnd('debug');\n\n  this._resource = resource;\n  this._metadataTable = undefined;\n}\nObject.defineProperties(VoxelContent.prototype, {\n  /**\n   * The {@link MetadataTable} storing voxel property values.\n   *\n   * @type {MetadataTable}\n   * @readonly\n   * @private\n   */\n  metadataTable: {\n    get: function () {\n      return this._metadataTable;\n    }\n  }\n});\n\n/**\n * Creates an object representing voxel content for a {@link Cesium3DTilesVoxelProvider}.\n *\n * @param {Resource} resource The resource for this voxel content. This is used for fetching external buffers as needed.\n * @param {object} [json] Voxel JSON contents. Mutually exclusive with binary.\n * @param {Uint8Array} [binary] Voxel binary contents. Mutually exclusive with json.\n * @param {MetadataSchema} metadataSchema The metadata schema used by property tables in the voxel content\n * @returns {Promise<VoxelContent>}\n *\n * @exception {DeveloperError} One of json and binary must be defined.\n */\nVoxelContent.fromJson = async function (resource, json, binary, metadataSchema) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  if (defined(json) === defined(binary)) {\n    throw new DeveloperError(\"One of json and binary must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  let chunks;\n  if (defined(json)) {\n    chunks = {\n      json: json,\n      binary: undefined\n    };\n  } else {\n    chunks = parseVoxelChunks(binary);\n  }\n  const buffersU8 = await requestBuffers(resource, chunks.json, chunks.binary);\n  const bufferViewsU8 = {};\n  const bufferViewsLength = chunks.json.bufferViews.length;\n  for (let i = 0; i < bufferViewsLength; ++i) {\n    const bufferViewJson = chunks.json.bufferViews[i];\n    const start = bufferViewJson.byteOffset;\n    const end = start + bufferViewJson.byteLength;\n    const buffer = buffersU8[bufferViewJson.buffer];\n    const bufferView = buffer.subarray(start, end);\n    bufferViewsU8[i] = bufferView;\n  }\n  const propertyTableIndex = chunks.json.voxelTable;\n  const propertyTableJson = chunks.json.propertyTables[propertyTableIndex];\n  const content = new VoxelContent(resource);\n  content._metadataTable = new MetadataTable({\n    count: propertyTableJson.count,\n    properties: propertyTableJson.properties,\n    class: metadataSchema.classes[propertyTableJson.class],\n    bufferViews: bufferViewsU8\n  });\n  return content;\n};\nfunction requestBuffers(resource, json, binary) {\n  const buffersLength = json.buffers.length;\n  const bufferPromises = new Array(buffersLength);\n  for (let i = 0; i < buffersLength; i++) {\n    const buffer = json.buffers[i];\n    if (defined(buffer.uri)) {\n      const baseResource = resource;\n      const bufferResource = baseResource.getDerivedResource({\n        url: buffer.uri\n      });\n      bufferPromises[i] = bufferResource.fetchArrayBuffer().then(function (arrayBuffer) {\n        return new Uint8Array(arrayBuffer);\n      });\n    } else {\n      bufferPromises[i] = Promise.resolve(binary);\n    }\n  }\n  return Promise.all(bufferPromises);\n}\n\n/**\n * A helper object for storing the two parts of the binary voxel content\n *\n * @typedef {object} VoxelChunks\n * @property {object} json The json chunk of the binary voxel content\n * @property {Uint8Array} binary The binary chunk of the binary voxel content. This represents the internal buffer.\n * @private\n */\n\n/**\n * Given binary voxel content, split into JSON and binary chunks\n *\n * @param {Uint8Array} binaryView The binary voxel content\n * @returns {VoxelChunks} An object containing the JSON and binary chunks\n * @private\n */\nfunction parseVoxelChunks(binaryView) {\n  // Parse the header\n  const littleEndian = true;\n  const reader = new DataView(binaryView.buffer, binaryView.byteOffset);\n  // Skip to the chunk lengths\n  let byteOffset = 8;\n\n  // Read the bottom 32 bits of the 64-bit byte length. This is ok for now because:\n  // 1) not all browsers have native 64-bit operations\n  // 2) the data is well under 4GB\n  const jsonByteLength = reader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const binaryByteLength = reader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const json = getJsonFromTypedArray(binaryView, byteOffset, jsonByteLength);\n  byteOffset += jsonByteLength;\n  const binary = binaryView.subarray(byteOffset, byteOffset + binaryByteLength);\n  return {\n    json: json,\n    binary: binary\n  };\n}\nexport default VoxelContent;","map":{"version":3,"names":["Check","DeveloperError","defined","getJsonFromTypedArray","MetadataTable","VoxelContent","resource","typeOf","object","_resource","_metadataTable","undefined","Object","defineProperties","prototype","metadataTable","get","fromJson","json","binary","metadataSchema","chunks","parseVoxelChunks","buffersU8","requestBuffers","bufferViewsU8","bufferViewsLength","bufferViews","length","i","bufferViewJson","start","byteOffset","end","byteLength","buffer","bufferView","subarray","propertyTableIndex","voxelTable","propertyTableJson","propertyTables","content","count","properties","class","classes","buffersLength","buffers","bufferPromises","Array","uri","baseResource","bufferResource","getDerivedResource","url","fetchArrayBuffer","then","arrayBuffer","Uint8Array","Promise","resolve","all","binaryView","littleEndian","reader","DataView","jsonByteLength","getUint32","binaryByteLength"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelContent.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport MetadataTable from \"./MetadataTable.js\";\n\n/**\n * An object representing voxel content for a {@link Cesium3DTilesVoxelProvider}.\n *\n * @alias VoxelContent\n * @constructor\n *\n * @param {Resource} resource The resource for this voxel content. This is used for fetching external buffers as needed.\n *\n * @private\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelContent(resource) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  //>>includeEnd('debug');\n\n  this._resource = resource;\n  this._metadataTable = undefined;\n}\n\nObject.defineProperties(VoxelContent.prototype, {\n  /**\n   * The {@link MetadataTable} storing voxel property values.\n   *\n   * @type {MetadataTable}\n   * @readonly\n   * @private\n   */\n  metadataTable: {\n    get: function () {\n      return this._metadataTable;\n    },\n  },\n});\n\n/**\n * Creates an object representing voxel content for a {@link Cesium3DTilesVoxelProvider}.\n *\n * @param {Resource} resource The resource for this voxel content. This is used for fetching external buffers as needed.\n * @param {object} [json] Voxel JSON contents. Mutually exclusive with binary.\n * @param {Uint8Array} [binary] Voxel binary contents. Mutually exclusive with json.\n * @param {MetadataSchema} metadataSchema The metadata schema used by property tables in the voxel content\n * @returns {Promise<VoxelContent>}\n *\n * @exception {DeveloperError} One of json and binary must be defined.\n */\nVoxelContent.fromJson = async function (\n  resource,\n  json,\n  binary,\n  metadataSchema,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  if (defined(json) === defined(binary)) {\n    throw new DeveloperError(\"One of json and binary must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  let chunks;\n  if (defined(json)) {\n    chunks = {\n      json: json,\n      binary: undefined,\n    };\n  } else {\n    chunks = parseVoxelChunks(binary);\n  }\n\n  const buffersU8 = await requestBuffers(resource, chunks.json, chunks.binary);\n  const bufferViewsU8 = {};\n  const bufferViewsLength = chunks.json.bufferViews.length;\n  for (let i = 0; i < bufferViewsLength; ++i) {\n    const bufferViewJson = chunks.json.bufferViews[i];\n    const start = bufferViewJson.byteOffset;\n    const end = start + bufferViewJson.byteLength;\n    const buffer = buffersU8[bufferViewJson.buffer];\n    const bufferView = buffer.subarray(start, end);\n    bufferViewsU8[i] = bufferView;\n  }\n\n  const propertyTableIndex = chunks.json.voxelTable;\n  const propertyTableJson = chunks.json.propertyTables[propertyTableIndex];\n\n  const content = new VoxelContent(resource);\n\n  content._metadataTable = new MetadataTable({\n    count: propertyTableJson.count,\n    properties: propertyTableJson.properties,\n    class: metadataSchema.classes[propertyTableJson.class],\n    bufferViews: bufferViewsU8,\n  });\n\n  return content;\n};\n\nfunction requestBuffers(resource, json, binary) {\n  const buffersLength = json.buffers.length;\n  const bufferPromises = new Array(buffersLength);\n  for (let i = 0; i < buffersLength; i++) {\n    const buffer = json.buffers[i];\n    if (defined(buffer.uri)) {\n      const baseResource = resource;\n      const bufferResource = baseResource.getDerivedResource({\n        url: buffer.uri,\n      });\n      bufferPromises[i] = bufferResource\n        .fetchArrayBuffer()\n        .then(function (arrayBuffer) {\n          return new Uint8Array(arrayBuffer);\n        });\n    } else {\n      bufferPromises[i] = Promise.resolve(binary);\n    }\n  }\n\n  return Promise.all(bufferPromises);\n}\n\n/**\n * A helper object for storing the two parts of the binary voxel content\n *\n * @typedef {object} VoxelChunks\n * @property {object} json The json chunk of the binary voxel content\n * @property {Uint8Array} binary The binary chunk of the binary voxel content. This represents the internal buffer.\n * @private\n */\n\n/**\n * Given binary voxel content, split into JSON and binary chunks\n *\n * @param {Uint8Array} binaryView The binary voxel content\n * @returns {VoxelChunks} An object containing the JSON and binary chunks\n * @private\n */\nfunction parseVoxelChunks(binaryView) {\n  // Parse the header\n  const littleEndian = true;\n  const reader = new DataView(binaryView.buffer, binaryView.byteOffset);\n  // Skip to the chunk lengths\n  let byteOffset = 8;\n\n  // Read the bottom 32 bits of the 64-bit byte length. This is ok for now because:\n  // 1) not all browsers have native 64-bit operations\n  // 2) the data is well under 4GB\n  const jsonByteLength = reader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const binaryByteLength = reader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n\n  const json = getJsonFromTypedArray(binaryView, byteOffset, jsonByteLength);\n  byteOffset += jsonByteLength;\n  const binary = binaryView.subarray(byteOffset, byteOffset + binaryByteLength);\n\n  return {\n    json: json,\n    binary: binary,\n  };\n}\n\nexport default VoxelContent;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,aAAa,MAAM,oBAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,QAAQ,EAAE;EAC9B;EACAN,KAAK,CAACO,MAAM,CAACC,MAAM,CAAC,UAAU,EAAEF,QAAQ,CAAC;EACzC;;EAEA,IAAI,CAACG,SAAS,GAAGH,QAAQ;EACzB,IAAI,CAACI,cAAc,GAAGC,SAAS;AACjC;AAEAC,MAAM,CAACC,gBAAgB,CAACR,YAAY,CAACS,SAAS,EAAE;EAC9C;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,aAAa,EAAE;IACbC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACN,cAAc;IAC5B;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,YAAY,CAACY,QAAQ,GAAG,gBACtBX,QAAQ,EACRY,IAAI,EACJC,MAAM,EACNC,cAAc,EACd;EACA;EACApB,KAAK,CAACO,MAAM,CAACC,MAAM,CAAC,UAAU,EAAEF,QAAQ,CAAC;EACzC,IAAIJ,OAAO,CAACgB,IAAI,CAAC,KAAKhB,OAAO,CAACiB,MAAM,CAAC,EAAE;IACrC,MAAM,IAAIlB,cAAc,CAAC,yCAAyC,CAAC;EACrE;EACA;;EAEA,IAAIoB,MAAM;EACV,IAAInB,OAAO,CAACgB,IAAI,CAAC,EAAE;IACjBG,MAAM,GAAG;MACPH,IAAI,EAAEA,IAAI;MACVC,MAAM,EAAER;IACV,CAAC;EACH,CAAC,MAAM;IACLU,MAAM,GAAGC,gBAAgB,CAACH,MAAM,CAAC;EACnC;EAEA,MAAMI,SAAS,GAAG,MAAMC,cAAc,CAAClB,QAAQ,EAAEe,MAAM,CAACH,IAAI,EAAEG,MAAM,CAACF,MAAM,CAAC;EAC5E,MAAMM,aAAa,GAAG,CAAC,CAAC;EACxB,MAAMC,iBAAiB,GAAGL,MAAM,CAACH,IAAI,CAACS,WAAW,CAACC,MAAM;EACxD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,iBAAiB,EAAE,EAAEG,CAAC,EAAE;IAC1C,MAAMC,cAAc,GAAGT,MAAM,CAACH,IAAI,CAACS,WAAW,CAACE,CAAC,CAAC;IACjD,MAAME,KAAK,GAAGD,cAAc,CAACE,UAAU;IACvC,MAAMC,GAAG,GAAGF,KAAK,GAAGD,cAAc,CAACI,UAAU;IAC7C,MAAMC,MAAM,GAAGZ,SAAS,CAACO,cAAc,CAACK,MAAM,CAAC;IAC/C,MAAMC,UAAU,GAAGD,MAAM,CAACE,QAAQ,CAACN,KAAK,EAAEE,GAAG,CAAC;IAC9CR,aAAa,CAACI,CAAC,CAAC,GAAGO,UAAU;EAC/B;EAEA,MAAME,kBAAkB,GAAGjB,MAAM,CAACH,IAAI,CAACqB,UAAU;EACjD,MAAMC,iBAAiB,GAAGnB,MAAM,CAACH,IAAI,CAACuB,cAAc,CAACH,kBAAkB,CAAC;EAExE,MAAMI,OAAO,GAAG,IAAIrC,YAAY,CAACC,QAAQ,CAAC;EAE1CoC,OAAO,CAAChC,cAAc,GAAG,IAAIN,aAAa,CAAC;IACzCuC,KAAK,EAAEH,iBAAiB,CAACG,KAAK;IAC9BC,UAAU,EAAEJ,iBAAiB,CAACI,UAAU;IACxCC,KAAK,EAAEzB,cAAc,CAAC0B,OAAO,CAACN,iBAAiB,CAACK,KAAK,CAAC;IACtDlB,WAAW,EAAEF;EACf,CAAC,CAAC;EAEF,OAAOiB,OAAO;AAChB,CAAC;AAED,SAASlB,cAAcA,CAAClB,QAAQ,EAAEY,IAAI,EAAEC,MAAM,EAAE;EAC9C,MAAM4B,aAAa,GAAG7B,IAAI,CAAC8B,OAAO,CAACpB,MAAM;EACzC,MAAMqB,cAAc,GAAG,IAAIC,KAAK,CAACH,aAAa,CAAC;EAC/C,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,aAAa,EAAElB,CAAC,EAAE,EAAE;IACtC,MAAMM,MAAM,GAAGjB,IAAI,CAAC8B,OAAO,CAACnB,CAAC,CAAC;IAC9B,IAAI3B,OAAO,CAACiC,MAAM,CAACgB,GAAG,CAAC,EAAE;MACvB,MAAMC,YAAY,GAAG9C,QAAQ;MAC7B,MAAM+C,cAAc,GAAGD,YAAY,CAACE,kBAAkB,CAAC;QACrDC,GAAG,EAAEpB,MAAM,CAACgB;MACd,CAAC,CAAC;MACFF,cAAc,CAACpB,CAAC,CAAC,GAAGwB,cAAc,CAC/BG,gBAAgB,CAAC,CAAC,CAClBC,IAAI,CAAC,UAAUC,WAAW,EAAE;QAC3B,OAAO,IAAIC,UAAU,CAACD,WAAW,CAAC;MACpC,CAAC,CAAC;IACN,CAAC,MAAM;MACLT,cAAc,CAACpB,CAAC,CAAC,GAAG+B,OAAO,CAACC,OAAO,CAAC1C,MAAM,CAAC;IAC7C;EACF;EAEA,OAAOyC,OAAO,CAACE,GAAG,CAACb,cAAc,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3B,gBAAgBA,CAACyC,UAAU,EAAE;EACpC;EACA,MAAMC,YAAY,GAAG,IAAI;EACzB,MAAMC,MAAM,GAAG,IAAIC,QAAQ,CAACH,UAAU,CAAC5B,MAAM,EAAE4B,UAAU,CAAC/B,UAAU,CAAC;EACrE;EACA,IAAIA,UAAU,GAAG,CAAC;;EAElB;EACA;EACA;EACA,MAAMmC,cAAc,GAAGF,MAAM,CAACG,SAAS,CAACpC,UAAU,EAAEgC,YAAY,CAAC;EACjEhC,UAAU,IAAI,CAAC;EACf,MAAMqC,gBAAgB,GAAGJ,MAAM,CAACG,SAAS,CAACpC,UAAU,EAAEgC,YAAY,CAAC;EACnEhC,UAAU,IAAI,CAAC;EAEf,MAAMd,IAAI,GAAGf,qBAAqB,CAAC4D,UAAU,EAAE/B,UAAU,EAAEmC,cAAc,CAAC;EAC1EnC,UAAU,IAAImC,cAAc;EAC5B,MAAMhD,MAAM,GAAG4C,UAAU,CAAC1B,QAAQ,CAACL,UAAU,EAAEA,UAAU,GAAGqC,gBAAgB,CAAC;EAE7E,OAAO;IACLnD,IAAI,EAAEA,IAAI;IACVC,MAAM,EAAEA;EACV,CAAC;AACH;AAEA,eAAed,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}