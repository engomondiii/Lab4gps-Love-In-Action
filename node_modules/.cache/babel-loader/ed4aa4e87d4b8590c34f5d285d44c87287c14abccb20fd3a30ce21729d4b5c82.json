{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = 2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n  array[startingIndex++] = frustumType;\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n  return array;\n};\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const frustumType = array[startingIndex++];\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(array, startingIndex, scratchPackPerspective);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(array, startingIndex, scratchPackOrthographic);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(array, startingIndex, scratchPackQuaternion);\n  startingIndex += Quaternion.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane\n    });\n  }\n  const frustumResult = frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n  return result;\n};\n\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n  const positions = new Float64Array(3 * 4 * 2);\n  FrustumGeometry._computeNearFarPlanes(origin, orientation, frustumType, frustum, positions);\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions\n    })\n  });\n  let offset;\n  let index;\n  const numberOfPlanes = drawNearPlane ? 2 : 1;\n  const indices = new Uint16Array(8 * (numberOfPlanes + 1));\n\n  // Build the near/far planes\n  let i = drawNearPlane ? 0 : 1;\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  }\n\n  // Build the sides of the frustums\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions)\n  });\n};\nexport default FrustumOutlineGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","ComponentDatatype","defaultValue","defined","FrustumGeometry","Geometry","GeometryAttribute","GeometryAttributes","OrthographicFrustum","PerspectiveFrustum","PrimitiveType","Quaternion","PERSPECTIVE","ORTHOGRAPHIC","FrustumOutlineGeometry","options","typeOf","object","frustum","origin","orientation","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","packedLength","_frustumType","_frustum","clone","_origin","_orientation","_workerName","pack","value","array","startingIndex","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","unpack","result","frustumResult","undefined","createGeometry","frustumGeometry","positions","Float64Array","_computeNearFarPlanes","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","offset","index","numberOfPlanes","indices","Uint16Array","i","primitiveType","LINES","boundingSphere","fromVertices"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/FrustumOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective,\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic,\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion,\n  );\n  startingIndex += Quaternion.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n\n  const positions = new Float64Array(3 * 4 * 2);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions,\n  );\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  let offset;\n  let index;\n\n  const numberOfPlanes = drawNearPlane ? 2 : 1;\n  const indices = new Uint16Array(8 * (numberOfPlanes + 1));\n\n  // Build the near/far planes\n  let i = drawNearPlane ? 0 : 1;\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  }\n\n  // Build the sides of the frustums\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}