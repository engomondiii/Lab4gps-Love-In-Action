{"ast":null,"code":"import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport Property from \"./Property.js\";\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\nconst scratchColor = new Color();\nfunction BoxGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.dimensions = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for boxes.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias BoxGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction BoxGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new BoxGeometryOptions(entity),\n    geometryPropertyName: \"box\",\n    observedPropertyNames: [\"availability\", \"position\", \"orientation\", \"box\"]\n  });\n  this._onEntityPropertyChanged(entity, \"box\", entity.box, undefined);\n}\nif (defined(Object.create)) {\n  BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;\n}\nObject.defineProperties(BoxGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof BoxGeometryUpdater.prototype\n   * @readonly\n   * @private\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    }\n  }\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nBoxGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: BoxGeometry.fromDimensions(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.ellipsoid),\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nBoxGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: BoxOutlineGeometry.fromDimensions(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.ellipsoid),\n    attributes: attributes\n  });\n};\nBoxGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\nBoxGeometryUpdater.prototype._isHidden = function (entity, box) {\n  return !defined(box.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, box);\n};\nBoxGeometryUpdater.prototype._isDynamic = function (entity, box) {\n  return !entity.position.isConstant || !Property.isConstant(entity.orientation) || !box.dimensions.isConstant || !Property.isConstant(box.outlineWidth);\n};\nBoxGeometryUpdater.prototype._setStaticOptions = function (entity, box) {\n  const heightReference = Property.getValueOrDefault(box.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  const options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.dimensions = box.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n  options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n};\nBoxGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\nBoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicBoxGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\nif (defined(Object.create)) {\n  DynamicBoxGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;\n}\nDynamicBoxGeometryUpdater.prototype._isHidden = function (entity, box, time) {\n  const position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n  const dimensions = this._options.dimensions;\n  return !defined(position) || !defined(dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time);\n};\nDynamicBoxGeometryUpdater.prototype._setOptions = function (entity, box, time) {\n  const heightReference = Property.getValueOrDefault(box.heightReference, time, HeightReference.NONE);\n  const options = this._options;\n  options.dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);\n  options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n};\nexport default BoxGeometryUpdater;","map":{"version":3,"names":["BoxGeometry","BoxOutlineGeometry","Cartesian3","Check","Color","ColorGeometryInstanceAttribute","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","GeometryInstance","GeometryOffsetAttribute","Iso8601","OffsetGeometryInstanceAttribute","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","heightReferenceOnEntityPropertyChanged","Property","defaultOffset","ZERO","offsetScratch","positionScratch","scratchColor","BoxGeometryOptions","entity","id","vertexFormat","undefined","dimensions","offsetAttribute","BoxGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","box","Object","create","prototype","constructor","defineProperties","terrainOffsetProperty","get","_terrainOffsetProperty","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","_distanceDisplayConditionProperty","distanceDisplayConditionAttribute","fromDistanceDisplayCondition","attributes","color","offset","_materialProperty","currentColor","isConstant","WHITE","fromColor","_options","fromCartesian3","getValueOrDefault","geometry","fromDimensions","modelMatrix","computeModelMatrixForHeightReference","heightReference","z","_scene","ellipsoid","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","position","_isHidden","_isDynamic","orientation","outlineWidth","_setStaticOptions","MINIMUM_VALUE","NONE","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","ALL","DynamicBoxGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/BoxGeometryUpdater.js"],"sourcesContent":["import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport heightReferenceOnEntityPropertyChanged from \"./heightReferenceOnEntityPropertyChanged.js\";\nimport Property from \"./Property.js\";\n\nconst defaultOffset = Cartesian3.ZERO;\n\nconst offsetScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\nconst scratchColor = new Color();\n\nfunction BoxGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.dimensions = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for boxes.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias BoxGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction BoxGeometryUpdater(entity, scene) {\n  GeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new BoxGeometryOptions(entity),\n    geometryPropertyName: \"box\",\n    observedPropertyNames: [\"availability\", \"position\", \"orientation\", \"box\"],\n  });\n\n  this._onEntityPropertyChanged(entity, \"box\", entity.box, undefined);\n}\n\nif (defined(Object.create)) {\n  BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n  BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;\n}\n\nObject.defineProperties(BoxGeometryUpdater.prototype, {\n  /**\n   * Gets the terrain offset property\n   * @type {TerrainOffsetProperty}\n   * @memberof BoxGeometryUpdater.prototype\n   * @readonly\n   * @private\n   */\n  terrainOffsetProperty: {\n    get: function () {\n      return this._terrainOffsetProperty;\n    },\n  },\n});\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nBoxGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n\n  const show = new ShowGeometryInstanceAttribute(\n    isAvailable &&\n      entity.isShowing &&\n      this._showProperty.getValue(time) &&\n      this._fillProperty.getValue(time),\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n  const distanceDisplayConditionAttribute =\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n      distanceDisplayCondition,\n    );\n\n  const attributes = {\n    show: show,\n    distanceDisplayCondition: distanceDisplayConditionAttribute,\n    color: undefined,\n    offset: undefined,\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: BoxGeometry.fromDimensions(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(\n      time,\n      entity.box.heightReference,\n      this._options.dimensions.z * 0.5,\n      this._scene.ellipsoid,\n    ),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nBoxGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time),\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        distanceDisplayCondition,\n      ),\n    offset: undefined,\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: BoxOutlineGeometry.fromDimensions(this._options),\n    modelMatrix: entity.computeModelMatrixForHeightReference(\n      time,\n      entity.box.heightReference,\n      this._options.dimensions.z * 0.5,\n      this._scene.ellipsoid,\n    ),\n    attributes: attributes,\n  });\n};\n\nBoxGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nBoxGeometryUpdater.prototype._isHidden = function (entity, box) {\n  return (\n    !defined(box.dimensions) ||\n    !defined(entity.position) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, box)\n  );\n};\n\nBoxGeometryUpdater.prototype._isDynamic = function (entity, box) {\n  return (\n    !entity.position.isConstant ||\n    !Property.isConstant(entity.orientation) ||\n    !box.dimensions.isConstant ||\n    !Property.isConstant(box.outlineWidth)\n  );\n};\n\nBoxGeometryUpdater.prototype._setStaticOptions = function (entity, box) {\n  const heightReference = Property.getValueOrDefault(\n    box.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n\n  const options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.dimensions = box.dimensions.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.dimensions,\n  );\n  options.offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n};\n\nBoxGeometryUpdater.prototype._onEntityPropertyChanged =\n  heightReferenceOnEntityPropertyChanged;\n\nBoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicBoxGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives,\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives,\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicBoxGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype,\n  );\n  DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;\n}\n\nDynamicBoxGeometryUpdater.prototype._isHidden = function (entity, box, time) {\n  const position = Property.getValueOrUndefined(\n    entity.position,\n    time,\n    positionScratch,\n  );\n  const dimensions = this._options.dimensions;\n  return (\n    !defined(position) ||\n    !defined(dimensions) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time)\n  );\n};\n\nDynamicBoxGeometryUpdater.prototype._setOptions = function (entity, box, time) {\n  const heightReference = Property.getValueOrDefault(\n    box.heightReference,\n    time,\n    HeightReference.NONE,\n  );\n  const options = this._options;\n  options.dimensions = Property.getValueOrUndefined(\n    box.dimensions,\n    time,\n    options.dimensions,\n  );\n  options.offsetAttribute =\n    heightReference !== HeightReference.NONE\n      ? GeometryOffsetAttribute.ALL\n      : undefined;\n};\nexport default BoxGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}