{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PolylineShadowVolumeFS from \"../Shaders/PolylineShadowVolumeFS.js\";\nimport PolylineShadowVolumeMorphFS from \"../Shaders/PolylineShadowVolumeMorphFS.js\";\nimport PolylineShadowVolumeMorphVS from \"../Shaders/PolylineShadowVolumeMorphVS.js\";\nimport PolylineShadowVolumeVS from \"../Shaders/PolylineShadowVolumeVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport PolylineColorAppearance from \"./PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"./PolylineMaterialAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.\n * </p>\n *\n * @alias GroundPolylinePrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] GeometryInstances containing GroundPolylineGeometry\n * @param {Appearance} [options.appearance] The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.\n *\n * @example\n * // 1. Draw a polyline on terrain with a basic color material\n *\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * const instance2 = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance2,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));\n */\nfunction GroundPolylinePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive. This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  this._hasPerInstanceColors = true;\n  let appearance = options.appearance;\n  if (!defined(appearance)) {\n    appearance = new PolylineMaterialAppearance();\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PolylineColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n\n  // Shadow volume is shown by removing a discard in the shader, so this isn't toggleable.\n  this._debugShowShadowVolume = defaultValue(options.debugShowShadowVolume, false);\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: false,\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(options.releaseGeometryInstances, true),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: false,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined\n  };\n\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n  this._ready = false;\n  this._primitive = undefined;\n  this._sp = undefined;\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n  this._renderState = getRenderState(false);\n  this._renderState3DTiles = getRenderState(true);\n  this._renderStateMorph = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT // Geometry is \"inverted,\" so cull front when materials on volume instead of on terrain (morph)\n    },\n    depthTest: {\n      enabled: true\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false\n  });\n}\nObject.defineProperties(GroundPolylinePrimitive.prototype, {\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    }\n  },\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    }\n  },\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    }\n  },\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    }\n  },\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * If true, draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  debugShowShadowVolume: {\n    get: function () {\n      return this._debugShowShadowVolume;\n    }\n  }\n});\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPolylinePrimitive synchronously.\n *\n * @returns {Promise<void>} A promise that will resolve once the terrain heights have been loaded.\n */\nGroundPolylinePrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\nfunction createShaderProgram(groundPolylinePrimitive, frameState, appearance) {\n  const context = frameState.context;\n  const primitive = groundPolylinePrimitive._primitive;\n  const attributeLocations = primitive._attributeLocations;\n  let vs = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeVS);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(groundPolylinePrimitive, vs, frameState.scene3DOnly);\n  let vsMorph = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeMorphVS);\n  vsMorph = Primitive._appendShowToShader(primitive, vsMorph);\n  vsMorph = Primitive._appendDistanceDisplayConditionToShader(primitive, vsMorph);\n  vsMorph = Primitive._modifyShaderPosition(groundPolylinePrimitive, vsMorph, frameState.scene3DOnly);\n\n  // Access pick color from fragment shader.\n  // Helps with varying budget.\n  let fs = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeFS);\n  const vsDefines = [`GLOBE_MINIMUM_ALTITUDE ${frameState.mapProjection.ellipsoid.minimumRadius.toFixed(1)}`];\n  let colorDefine = \"\";\n  let materialShaderSource = \"\";\n  if (defined(appearance.material)) {\n    materialShaderSource = defined(appearance.material) ? appearance.material.shaderSource : \"\";\n\n    // Check for use of v_width and v_polylineAngle in material shader\n    // to determine whether these varyings should be active in the vertex shader.\n    if (materialShaderSource.search(/in\\s+float\\s+v_polylineAngle;/g) !== -1) {\n      vsDefines.push(\"ANGLE_VARYING\");\n    }\n    if (materialShaderSource.search(/in\\s+float\\s+v_width;/g) !== -1) {\n      vsDefines.push(\"WIDTH_VARYING\");\n    }\n  } else {\n    colorDefine = \"PER_INSTANCE_COLOR\";\n  }\n  vsDefines.push(colorDefine);\n  const fsDefines = groundPolylinePrimitive.debugShowShadowVolume ? [\"DEBUG_SHOW_VOLUME\", colorDefine] : [colorDefine];\n  const vsColor3D = new ShaderSource({\n    defines: vsDefines,\n    sources: [vs]\n  });\n  const fsColor3D = new ShaderSource({\n    defines: fsDefines,\n    sources: [materialShaderSource, fs]\n  });\n  groundPolylinePrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vsColor3D,\n    fragmentShaderSource: fsColor3D,\n    attributeLocations: attributeLocations\n  });\n\n  // Derive 2D/CV\n  let colorProgram2D = context.shaderCache.getDerivedShaderProgram(groundPolylinePrimitive._sp, \"2dColor\");\n  if (!defined(colorProgram2D)) {\n    const vsColor2D = new ShaderSource({\n      defines: vsDefines.concat([\"COLUMBUS_VIEW_2D\"]),\n      sources: [vs]\n    });\n    colorProgram2D = context.shaderCache.createDerivedShaderProgram(groundPolylinePrimitive._sp, \"2dColor\", {\n      context: context,\n      shaderProgram: groundPolylinePrimitive._sp2D,\n      vertexShaderSource: vsColor2D,\n      fragmentShaderSource: fsColor3D,\n      attributeLocations: attributeLocations\n    });\n  }\n  groundPolylinePrimitive._sp2D = colorProgram2D;\n\n  // Derive Morph\n  let colorProgramMorph = context.shaderCache.getDerivedShaderProgram(groundPolylinePrimitive._sp, \"MorphColor\");\n  if (!defined(colorProgramMorph)) {\n    const vsColorMorph = new ShaderSource({\n      defines: vsDefines.concat([`MAX_TERRAIN_HEIGHT ${ApproximateTerrainHeights._defaultMaxTerrainHeight.toFixed(1)}`]),\n      sources: [vsMorph]\n    });\n    fs = primitive._batchTable.getVertexShaderCallback()(PolylineShadowVolumeMorphFS);\n    const fsColorMorph = new ShaderSource({\n      defines: fsDefines,\n      sources: [materialShaderSource, fs]\n    });\n    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(groundPolylinePrimitive._sp, \"MorphColor\", {\n      context: context,\n      shaderProgram: groundPolylinePrimitive._spMorph,\n      vertexShaderSource: vsColorMorph,\n      fragmentShaderSource: fsColorMorph,\n      attributeLocations: attributeLocations\n    });\n  }\n  groundPolylinePrimitive._spMorph = colorProgramMorph;\n}\nfunction getRenderState(mask3DTiles) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true // prevent double-draw. Geometry is \"inverted\" (reversed winding order) so we're drawing backfaces.\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    }\n  });\n}\nfunction createCommands(groundPolylinePrimitive, appearance, material, translucent, colorCommands, pickCommands) {\n  const primitive = groundPolylinePrimitive._primitive;\n  const length = primitive._va.length;\n  colorCommands.length = length;\n  pickCommands.length = length;\n  const isPolylineColorAppearance = appearance instanceof PolylineColorAppearance;\n  const materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;\n  const uniformMap = primitive._batchTable.getUniformMapCallback()(materialUniforms);\n  for (let i = 0; i < length; i++) {\n    const vertexArray = primitive._va[i];\n    let command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: groundPolylinePrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n    command.vertexArray = vertexArray;\n    command.renderState = groundPolylinePrimitive._renderState;\n    command.shaderProgram = groundPolylinePrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    command.pickId = \"czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)\";\n    const derivedTilesetCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedTilesetCommand.renderState = groundPolylinePrimitive._renderState3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n\n    // derive for 2D\n    const derived2DCommand = DrawCommand.shallowClone(command, command.derivedCommands.color2D);\n    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    command.derivedCommands.color2D = derived2DCommand;\n    const derived2DTilesetCommand = DrawCommand.shallowClone(derivedTilesetCommand, derivedTilesetCommand.derivedCommands.color2D);\n    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;\n\n    // derive for Morph\n    const derivedMorphCommand = DrawCommand.shallowClone(command, command.derivedCommands.colorMorph);\n    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;\n    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;\n    derivedMorphCommand.pickId = \"czm_batchTable_pickColor(v_batchId)\";\n    command.derivedCommands.colorMorph = derivedMorphCommand;\n  }\n}\nfunction updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {\n  // Use derived appearance command for morph and 2D\n  if (frameState.mode === SceneMode.MORPHING) {\n    command = command.derivedCommands.colorMorph;\n  } else if (frameState.mode !== SceneMode.SCENE3D) {\n    command = command.derivedCommands.color2D;\n  }\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n  frameState.commandList.push(command);\n}\nfunction updateAndQueueCommands(groundPolylinePrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume) {\n  const primitive = groundPolylinePrimitive._primitive;\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix); // Expected to be identity - GroundPrimitives don't support other model matrices\n\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n  const morphing = frameState.mode === SceneMode.MORPHING;\n  const classificationType = groundPolylinePrimitive.classificationType;\n  const queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN && !morphing;\n  let command;\n  const passes = frameState.passes;\n  if (passes.render || passes.pick && primitive.allowPicking) {\n    const colorLength = colorCommands.length;\n    for (let j = 0; j < colorLength; ++j) {\n      const boundingVolume = boundingSpheres[j];\n      if (queueTerrainCommands) {\n        command = colorCommands[j];\n        updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[j].derivedCommands.tileset;\n        updateAndQueueCommand(groundPolylinePrimitive, command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\n */\nGroundPolylinePrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\"For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\");\n    }\n    //>>includeEnd('debug');\n\n    GroundPolylinePrimitive.initializeTerrainHeights();\n    return;\n  }\n  let i;\n  const that = this;\n  const primitiveOptions = this._primitiveOptions;\n  if (!defined(this._primitive)) {\n    const geometryInstances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];\n    const geometryInstancesLength = geometryInstances.length;\n    const groundInstances = new Array(geometryInstancesLength);\n    let attributes;\n\n    // Check if each instance has a color attribute.\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      attributes = geometryInstances[i].attributes;\n      if (!defined(attributes) || !defined(attributes.color)) {\n        this._hasPerInstanceColors = false;\n        break;\n      }\n    }\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      const geometryInstance = geometryInstances[i];\n      attributes = {};\n      const instanceAttributes = geometryInstance.attributes;\n      for (const attributeKey in instanceAttributes) {\n        if (instanceAttributes.hasOwnProperty(attributeKey)) {\n          attributes[attributeKey] = instanceAttributes[attributeKey];\n        }\n      }\n\n      // Automatically create line width attribute if not already given\n      if (!defined(attributes.width)) {\n        attributes.width = new GeometryInstanceAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1.0,\n          value: [geometryInstance.geometry.width]\n        });\n      }\n\n      // Update each geometry for framestate.scene3DOnly = true and projection\n      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;\n      GroundPolylineGeometry.setProjectionAndEllipsoid(geometryInstance.geometry, frameState.mapProjection);\n      groundInstances[i] = new GeometryInstance({\n        geometry: geometryInstance.geometry,\n        attributes: attributes,\n        id: geometryInstance.id,\n        pickPrimitive: that\n      });\n    }\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n    primitiveOptions._createShaderProgramFunction = function (primitive, frameState, appearance) {\n      createShaderProgram(that, frameState, appearance);\n    };\n    primitiveOptions._createCommandsFunction = function (primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {\n      createCommands(that, appearance, material, translucent, colorCommands, pickCommands);\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n      updateAndQueueCommands(that, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume);\n    };\n    this._primitive = new Primitive(primitiveOptions);\n  }\n  if (this.appearance instanceof PolylineColorAppearance && !this._hasPerInstanceColors) {\n    throw new DeveloperError(\"All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\");\n  }\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n  frameState.afterRender.push(() => {\n    if (!this._ready && defined(this._primitive) && this._primitive.ready) {\n      this._ready = true;\n      if (this.releaseGeometryInstances) {\n        this.geometryInstances = undefined;\n      }\n    }\n  });\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Checks if the given Scene supports GroundPolylinePrimitives.\n * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {boolean} Whether or not the current scene supports GroundPolylinePrimitives.\n */\nGroundPolylinePrimitive.isSupported = function (scene) {\n  return scene.frameState.context.depthTexture;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPolylinePrimitive#destroy\n */\nGroundPolylinePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPolylinePrimitive#isDestroyed\n */\nGroundPolylinePrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n  return destroyObject(this);\n};\nexport default GroundPolylinePrimitive;","map":{"version":3,"names":["ApproximateTerrainHeights","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","GeometryInstance","GeometryInstanceAttribute","GroundPolylineGeometry","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","PolylineShadowVolumeFS","PolylineShadowVolumeMorphFS","PolylineShadowVolumeMorphVS","PolylineShadowVolumeVS","BlendingState","ClassificationType","CullFace","PolylineColorAppearance","PolylineMaterialAppearance","Primitive","SceneMode","StencilConstants","StencilFunction","StencilOperation","GroundPolylinePrimitive","options","EMPTY_OBJECT","geometryInstances","_hasPerInstanceColors","appearance","show","classificationType","BOTH","debugShowBoundingVolume","_debugShowShadowVolume","debugShowShadowVolume","_primitiveOptions","undefined","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","asynchronous","compressVertices","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_zIndex","_ready","_primitive","_sp","_sp2D","_spMorph","_renderState","getRenderState","_renderState3DTiles","_renderStateMorph","fromCache","cull","enabled","face","FRONT","depthTest","blending","PRE_MULTIPLIED_ALPHA_BLEND","depthMask","Object","defineProperties","prototype","get","ready","initializeTerrainHeights","initialize","createShaderProgram","groundPolylinePrimitive","frameState","context","primitive","attributeLocations","_attributeLocations","vs","_batchTable","getVertexShaderCallback","_appendShowToShader","_appendDistanceDisplayConditionToShader","_modifyShaderPosition","scene3DOnly","vsMorph","fs","vsDefines","mapProjection","ellipsoid","minimumRadius","toFixed","colorDefine","materialShaderSource","material","shaderSource","search","push","fsDefines","vsColor3D","defines","sources","fsColor3D","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","colorProgram2D","shaderCache","getDerivedShaderProgram","vsColor2D","concat","createDerivedShaderProgram","colorProgramMorph","vsColorMorph","_defaultMaxTerrainHeight","fsColorMorph","mask3DTiles","stencilTest","frontFunction","EQUAL","frontOperation","fail","KEEP","zFail","zPass","backFunction","backOperation","reference","CESIUM_3D_TILE_MASK","mask","createCommands","translucent","colorCommands","pickCommands","length","_va","isPolylineColorAppearance","materialUniforms","_uniforms","uniformMap","getUniformMapCallback","i","vertexArray","command","owner","primitiveType","_primitiveType","renderState","pass","TERRAIN_CLASSIFICATION","pickId","derivedTilesetCommand","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","derived2DCommand","color2D","derived2DTilesetCommand","derivedMorphCommand","colorMorph","updateAndQueueCommand","modelMatrix","boundingVolume","mode","MORPHING","SCENE3D","commandList","updateAndQueueCommands","_updateBoundingVolumes","boundingSpheres","_boundingSphereWC","COLUMBUS_VIEW","_boundingSphereCV","SCENE2D","_boundingSphere2D","_boundingSphereMorph","morphing","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","TERRAIN","passes","render","pick","colorLength","j","update","initialized","that","primitiveOptions","Array","isArray","geometryInstancesLength","groundInstances","attributes","color","geometryInstance","instanceAttributes","attributeKey","hasOwnProperty","width","componentDatatype","UNSIGNED_BYTE","componentsPerAttribute","value","geometry","_scene3DOnly","setProjectionAndEllipsoid","id","pickPrimitive","twoPasses","afterRender","getGeometryInstanceAttributes","isSupported","scene","depthTexture","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GroundPolylinePrimitive.js"],"sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PolylineShadowVolumeFS from \"../Shaders/PolylineShadowVolumeFS.js\";\nimport PolylineShadowVolumeMorphFS from \"../Shaders/PolylineShadowVolumeMorphFS.js\";\nimport PolylineShadowVolumeMorphVS from \"../Shaders/PolylineShadowVolumeMorphVS.js\";\nimport PolylineShadowVolumeVS from \"../Shaders/PolylineShadowVolumeVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport PolylineColorAppearance from \"./PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"./PolylineMaterialAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.\n * </p>\n *\n * @alias GroundPolylinePrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] GeometryInstances containing GroundPolylineGeometry\n * @param {Appearance} [options.appearance] The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.\n *\n * @example\n * // 1. Draw a polyline on terrain with a basic color material\n *\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * const instance2 = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance2,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));\n */\nfunction GroundPolylinePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive. This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  this._hasPerInstanceColors = true;\n\n  let appearance = options.appearance;\n  if (!defined(appearance)) {\n    appearance = new PolylineMaterialAppearance();\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PolylineColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH,\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false,\n  );\n\n  // Shadow volume is shown by removing a discard in the shader, so this isn't toggleable.\n  this._debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false,\n  );\n\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: false,\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true,\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: false,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n  };\n\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n\n  this._ready = false;\n  this._primitive = undefined;\n\n  this._sp = undefined;\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n\n  this._renderState = getRenderState(false);\n  this._renderState3DTiles = getRenderState(true);\n\n  this._renderStateMorph = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT, // Geometry is \"inverted,\" so cull front when materials on volume instead of on terrain (morph)\n    },\n    depthTest: {\n      enabled: true,\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n  });\n}\n\nObject.defineProperties(GroundPolylinePrimitive.prototype, {\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * If true, draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  debugShowShadowVolume: {\n    get: function () {\n      return this._debugShowShadowVolume;\n    },\n  },\n});\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPolylinePrimitive synchronously.\n *\n * @returns {Promise<void>} A promise that will resolve once the terrain heights have been loaded.\n */\nGroundPolylinePrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\nfunction createShaderProgram(groundPolylinePrimitive, frameState, appearance) {\n  const context = frameState.context;\n  const primitive = groundPolylinePrimitive._primitive;\n  const attributeLocations = primitive._attributeLocations;\n\n  let vs = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeVS,\n  );\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(\n    groundPolylinePrimitive,\n    vs,\n    frameState.scene3DOnly,\n  );\n\n  let vsMorph = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeMorphVS,\n  );\n  vsMorph = Primitive._appendShowToShader(primitive, vsMorph);\n  vsMorph = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vsMorph,\n  );\n  vsMorph = Primitive._modifyShaderPosition(\n    groundPolylinePrimitive,\n    vsMorph,\n    frameState.scene3DOnly,\n  );\n\n  // Access pick color from fragment shader.\n  // Helps with varying budget.\n  let fs = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeFS,\n  );\n\n  const vsDefines = [\n    `GLOBE_MINIMUM_ALTITUDE ${frameState.mapProjection.ellipsoid.minimumRadius.toFixed(\n      1,\n    )}`,\n  ];\n  let colorDefine = \"\";\n  let materialShaderSource = \"\";\n  if (defined(appearance.material)) {\n    materialShaderSource = defined(appearance.material)\n      ? appearance.material.shaderSource\n      : \"\";\n\n    // Check for use of v_width and v_polylineAngle in material shader\n    // to determine whether these varyings should be active in the vertex shader.\n    if (materialShaderSource.search(/in\\s+float\\s+v_polylineAngle;/g) !== -1) {\n      vsDefines.push(\"ANGLE_VARYING\");\n    }\n    if (materialShaderSource.search(/in\\s+float\\s+v_width;/g) !== -1) {\n      vsDefines.push(\"WIDTH_VARYING\");\n    }\n  } else {\n    colorDefine = \"PER_INSTANCE_COLOR\";\n  }\n\n  vsDefines.push(colorDefine);\n  const fsDefines = groundPolylinePrimitive.debugShowShadowVolume\n    ? [\"DEBUG_SHOW_VOLUME\", colorDefine]\n    : [colorDefine];\n\n  const vsColor3D = new ShaderSource({\n    defines: vsDefines,\n    sources: [vs],\n  });\n  const fsColor3D = new ShaderSource({\n    defines: fsDefines,\n    sources: [materialShaderSource, fs],\n  });\n  groundPolylinePrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vsColor3D,\n    fragmentShaderSource: fsColor3D,\n    attributeLocations: attributeLocations,\n  });\n\n  // Derive 2D/CV\n  let colorProgram2D = context.shaderCache.getDerivedShaderProgram(\n    groundPolylinePrimitive._sp,\n    \"2dColor\",\n  );\n  if (!defined(colorProgram2D)) {\n    const vsColor2D = new ShaderSource({\n      defines: vsDefines.concat([\"COLUMBUS_VIEW_2D\"]),\n      sources: [vs],\n    });\n    colorProgram2D = context.shaderCache.createDerivedShaderProgram(\n      groundPolylinePrimitive._sp,\n      \"2dColor\",\n      {\n        context: context,\n        shaderProgram: groundPolylinePrimitive._sp2D,\n        vertexShaderSource: vsColor2D,\n        fragmentShaderSource: fsColor3D,\n        attributeLocations: attributeLocations,\n      },\n    );\n  }\n  groundPolylinePrimitive._sp2D = colorProgram2D;\n\n  // Derive Morph\n  let colorProgramMorph = context.shaderCache.getDerivedShaderProgram(\n    groundPolylinePrimitive._sp,\n    \"MorphColor\",\n  );\n  if (!defined(colorProgramMorph)) {\n    const vsColorMorph = new ShaderSource({\n      defines: vsDefines.concat([\n        `MAX_TERRAIN_HEIGHT ${ApproximateTerrainHeights._defaultMaxTerrainHeight.toFixed(\n          1,\n        )}`,\n      ]),\n      sources: [vsMorph],\n    });\n\n    fs = primitive._batchTable.getVertexShaderCallback()(\n      PolylineShadowVolumeMorphFS,\n    );\n    const fsColorMorph = new ShaderSource({\n      defines: fsDefines,\n      sources: [materialShaderSource, fs],\n    });\n    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(\n      groundPolylinePrimitive._sp,\n      \"MorphColor\",\n      {\n        context: context,\n        shaderProgram: groundPolylinePrimitive._spMorph,\n        vertexShaderSource: vsColorMorph,\n        fragmentShaderSource: fsColorMorph,\n        attributeLocations: attributeLocations,\n      },\n    );\n  }\n  groundPolylinePrimitive._spMorph = colorProgramMorph;\n}\n\nfunction getRenderState(mask3DTiles) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true, // prevent double-draw. Geometry is \"inverted\" (reversed winding order) so we're drawing backfaces.\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n  });\n}\n\nfunction createCommands(\n  groundPolylinePrimitive,\n  appearance,\n  material,\n  translucent,\n  colorCommands,\n  pickCommands,\n) {\n  const primitive = groundPolylinePrimitive._primitive;\n  const length = primitive._va.length;\n  colorCommands.length = length;\n  pickCommands.length = length;\n\n  const isPolylineColorAppearance =\n    appearance instanceof PolylineColorAppearance;\n\n  const materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;\n  const uniformMap =\n    primitive._batchTable.getUniformMapCallback()(materialUniforms);\n\n  for (let i = 0; i < length; i++) {\n    const vertexArray = primitive._va[i];\n\n    let command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: groundPolylinePrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = groundPolylinePrimitive._renderState;\n    command.shaderProgram = groundPolylinePrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    command.pickId = \"czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)\";\n\n    const derivedTilesetCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset,\n    );\n    derivedTilesetCommand.renderState =\n      groundPolylinePrimitive._renderState3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n\n    // derive for 2D\n    const derived2DCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.color2D,\n    );\n    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    command.derivedCommands.color2D = derived2DCommand;\n\n    const derived2DTilesetCommand = DrawCommand.shallowClone(\n      derivedTilesetCommand,\n      derivedTilesetCommand.derivedCommands.color2D,\n    );\n    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;\n\n    // derive for Morph\n    const derivedMorphCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.colorMorph,\n    );\n    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;\n    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;\n    derivedMorphCommand.pickId = \"czm_batchTable_pickColor(v_batchId)\";\n    command.derivedCommands.colorMorph = derivedMorphCommand;\n  }\n}\n\nfunction updateAndQueueCommand(\n  groundPolylinePrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume,\n) {\n  // Use derived appearance command for morph and 2D\n  if (frameState.mode === SceneMode.MORPHING) {\n    command = command.derivedCommands.colorMorph;\n  } else if (frameState.mode !== SceneMode.SCENE3D) {\n    command = command.derivedCommands.color2D;\n  }\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  groundPolylinePrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n) {\n  const primitive = groundPolylinePrimitive._primitive;\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix); // Expected to be identity - GroundPrimitives don't support other model matrices\n\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  const morphing = frameState.mode === SceneMode.MORPHING;\n  const classificationType = groundPolylinePrimitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN && !morphing;\n\n  let command;\n  const passes = frameState.passes;\n  if (passes.render || (passes.pick && primitive.allowPicking)) {\n    const colorLength = colorCommands.length;\n    for (let j = 0; j < colorLength; ++j) {\n      const boundingVolume = boundingSpheres[j];\n      if (queueTerrainCommands) {\n        command = colorCommands[j];\n        updateAndQueueCommand(\n          groundPolylinePrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[j].derivedCommands.tileset;\n        updateAndQueueCommand(\n          groundPolylinePrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\n */\nGroundPolylinePrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\n        \"For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    GroundPolylinePrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  let i;\n\n  const that = this;\n  const primitiveOptions = this._primitiveOptions;\n  if (!defined(this._primitive)) {\n    const geometryInstances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    const geometryInstancesLength = geometryInstances.length;\n    const groundInstances = new Array(geometryInstancesLength);\n\n    let attributes;\n\n    // Check if each instance has a color attribute.\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      attributes = geometryInstances[i].attributes;\n      if (!defined(attributes) || !defined(attributes.color)) {\n        this._hasPerInstanceColors = false;\n        break;\n      }\n    }\n\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      const geometryInstance = geometryInstances[i];\n      attributes = {};\n      const instanceAttributes = geometryInstance.attributes;\n      for (const attributeKey in instanceAttributes) {\n        if (instanceAttributes.hasOwnProperty(attributeKey)) {\n          attributes[attributeKey] = instanceAttributes[attributeKey];\n        }\n      }\n\n      // Automatically create line width attribute if not already given\n      if (!defined(attributes.width)) {\n        attributes.width = new GeometryInstanceAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1.0,\n          value: [geometryInstance.geometry.width],\n        });\n      }\n\n      // Update each geometry for framestate.scene3DOnly = true and projection\n      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;\n      GroundPolylineGeometry.setProjectionAndEllipsoid(\n        geometryInstance.geometry,\n        frameState.mapProjection,\n      );\n\n      groundInstances[i] = new GeometryInstance({\n        geometry: geometryInstance.geometry,\n        attributes: attributes,\n        id: geometryInstance.id,\n        pickPrimitive: that,\n      });\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createShaderProgramFunction = function (\n      primitive,\n      frameState,\n      appearance,\n    ) {\n      createShaderProgram(that, frameState, appearance);\n    };\n    primitiveOptions._createCommandsFunction = function (\n      primitive,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      colorCommands,\n      pickCommands,\n    ) {\n      createCommands(\n        that,\n        appearance,\n        material,\n        translucent,\n        colorCommands,\n        pickCommands,\n      );\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (\n      primitive,\n      frameState,\n      colorCommands,\n      pickCommands,\n      modelMatrix,\n      cull,\n      debugShowBoundingVolume,\n      twoPasses,\n    ) {\n      updateAndQueueCommands(\n        that,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n      );\n    };\n\n    this._primitive = new Primitive(primitiveOptions);\n  }\n\n  if (\n    this.appearance instanceof PolylineColorAppearance &&\n    !this._hasPerInstanceColors\n  ) {\n    throw new DeveloperError(\n      \"All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\",\n    );\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n  frameState.afterRender.push(() => {\n    if (!this._ready && defined(this._primitive) && this._primitive.ready) {\n      this._ready = true;\n\n      if (this.releaseGeometryInstances) {\n        this.geometryInstances = undefined;\n      }\n    }\n  });\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function (\n  id,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\",\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Checks if the given Scene supports GroundPolylinePrimitives.\n * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {boolean} Whether or not the current scene supports GroundPolylinePrimitives.\n */\nGroundPolylinePrimitive.isSupported = function (scene) {\n  return scene.frameState.context.depthTexture;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPolylinePrimitive#destroy\n */\nGroundPolylinePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPolylinePrimitive#isDestroyed\n */\nGroundPolylinePrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n\n  return destroyObject(this);\n};\nexport default GroundPolylinePrimitive;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}