{"ast":null,"code":"import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\nfunction combine(computedPositions, cornerType) {\n  const wallIndices = [];\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length / 3 * 4;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length / 3 * 2;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length / 3 * 2;\n    }\n  }\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 4;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n  let index = 0;\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  if (addEndPositions) {\n    // add rounded end\n    wallIndices.push(front / 3);\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const firstEndPositions = endPositions[0];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n  }\n  let posIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n  length = leftEdge.length - 3;\n  wallIndices.push(front / 3, (back - 2) / 3);\n  for (i = 0; i < length; i += 3) {\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n    front += 3;\n    back -= 3;\n  }\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let start;\n    let outsidePoint = cartesian3;\n    if (defined(l)) {\n      back -= 3;\n      start = UR;\n      wallIndices.push(LR);\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n        back -= 3;\n      }\n      wallIndices.push(start - Math.floor(l.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push((back - 2) / 3 + 1);\n      }\n      front += 3;\n    } else {\n      front += 3;\n      start = LR;\n      wallIndices.push(UR);\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n        front += 3;\n      }\n      wallIndices.push(start + Math.floor(r.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push(front / 3 - 1);\n      }\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n    for (j = 0; j < leftEdge.length; j += 3) {\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    wallIndices.push(front / 3);\n  } else {\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions\n  });\n  return {\n    attributes: attributes,\n    indices: indices,\n    wallIndices: wallIndices\n  };\n}\nfunction computePositionsExtruded(params) {\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, params.cornerType);\n  const wallIndices = attr.wallIndices;\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  const attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  const newPositions = new Float64Array(length * 2);\n  positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  attributes.position.values = newPositions;\n  length /= 3;\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length * 2);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, length);\n    } else {\n      const applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset\n    });\n  }\n  let i;\n  const iLength = indices.length;\n  const newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 2) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    newIndices[index++] = v0 + length;\n    newIndices[index++] = v1 + length;\n  }\n  let UL, LL;\n  for (i = 0; i < wallIndices.length; i++) {\n    //wall indices\n    UL = wallIndices[i];\n    LL = UL + length;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n  }\n  return {\n    attributes: attributes,\n    indices: newIndices\n  };\n}\n\n/**\n * A description of a corridor outline.\n *\n * @alias CorridorOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n * @param {number} options.width The distance between the edges of the corridor outline.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorOutlineGeometry.createGeometry\n *\n * @example\n * const corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.positions\", positions);\n  Check.typeOf.number(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.default));\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCorridorOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCorridorOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n */\nCorridorOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorOutlineGeometry(scratchOptions);\n  }\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {\n  let positions = corridorOutlineGeometry._positions;\n  const width = corridorOutlineGeometry._width;\n  const ellipsoid = corridorOutlineGeometry._ellipsoid;\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n  const height = corridorOutlineGeometry._height;\n  const extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorOutlineGeometry._cornerType,\n    granularity: corridorOutlineGeometry._granularity,\n    saveAttributes: false\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, params.cornerType);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n    if (defined(corridorOutlineGeometry._offsetAttribute)) {\n      const length = attr.attributes.position.values.length;\n      const offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorOutlineGeometry._offsetAttribute\n  });\n};\nexport default CorridorOutlineGeometry;","map":{"version":3,"names":["arrayRemoveDuplicates","BoundingSphere","Cartesian3","Check","ComponentDatatype","CornerType","CorridorGeometryLibrary","defaultValue","defined","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PolygonPipeline","PrimitiveType","cartesian1","cartesian2","cartesian3","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","combine","computedPositions","cornerType","wallIndices","corners","endPositions","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","front","back","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","createTypedArray","index","push","firstEndPositions","fromArray","addAttribute","undefined","posIndex","rightEdge","leftEdge","set","j","l","r","start","outsidePoint","Math","floor","BEVELED","splice","lastEndPositions","position","componentDatatype","DOUBLE","componentsPerAttribute","values","computePositionsExtruded","params","computePositions","attr","height","extrudedHeight","extrudedPositions","newPositions","scaleToGeodeticHeight","offsetAttribute","applyOffset","Uint8Array","TOP","fill","applyOffsetValue","NONE","UNSIGNED_BYTE","iLength","newIndices","v0","v1","CorridorOutlineGeometry","options","EMPTY_OBJECT","width","typeOf","object","number","_positions","_ellipsoid","clone","default","_width","_height","max","_extrudedHeight","min","_cornerType","ROUNDED","_granularity","granularity","RADIANS_PER_DEGREE","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchOptions","unpack","result","Array","createGeometry","corridorOutlineGeometry","cleanPositions","equalsEpsilon","extrude","EPSILON2","saveAttributes","offsetValue","boundingSphere","fromVertices","primitiveType","LINES"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/CorridorOutlineGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction combine(computedPositions, cornerType) {\n  const wallIndices = [];\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += (length / 3) * 4;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += (length / 3) * 2;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += (length / 3) * 2;\n    }\n  }\n\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 4;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n  let index = 0;\n\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  if (addEndPositions) {\n    // add rounded end\n    wallIndices.push(front / 3);\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const firstEndPositions = endPositions[0];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  let posIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  length = leftEdge.length - 3;\n  wallIndices.push(front / 3, (back - 2) / 3);\n  for (i = 0; i < length; i += 3) {\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let start;\n    let outsidePoint = cartesian3;\n    if (defined(l)) {\n      back -= 3;\n      start = UR;\n      wallIndices.push(LR);\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back,\n        );\n        back -= 3;\n      }\n      wallIndices.push(start - Math.floor(l.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push((back - 2) / 3 + 1);\n      }\n      front += 3;\n    } else {\n      front += 3;\n      start = LR;\n      wallIndices.push(UR);\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front,\n        );\n        front += 3;\n      }\n      wallIndices.push(start + Math.floor(r.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push(front / 3 - 1);\n      }\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    for (j = 0; j < leftEdge.length; j += 3) {\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos,\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back,\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n\n    wallIndices.push(front / 3);\n  } else {\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  return {\n    attributes: attributes,\n    indices: indices,\n    wallIndices: wallIndices,\n  };\n}\n\nfunction computePositionsExtruded(params) {\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, params.cornerType);\n  const wallIndices = attr.wallIndices;\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  const attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  const newPositions = new Float64Array(length * 2);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid,\n  );\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid,\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  attributes.position.values = newPositions;\n\n  length /= 3;\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length * 2);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = applyOffset.fill(1, 0, length);\n    } else {\n      const applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = applyOffset.fill(applyOffsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let i;\n  const iLength = indices.length;\n  const newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    (iLength + wallIndices.length) * 2,\n  );\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 2) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    newIndices[index++] = v0 + length;\n    newIndices[index++] = v1 + length;\n  }\n\n  let UL, LL;\n  for (i = 0; i < wallIndices.length; i++) {\n    //wall indices\n    UL = wallIndices[i];\n    LL = UL + length;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\n/**\n * A description of a corridor outline.\n *\n * @alias CorridorOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n * @param {number} options.width The distance between the edges of the corridor outline.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n * @param {number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorOutlineGeometry.createGeometry\n *\n * @example\n * const corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.positions\", positions);\n  Check.typeOf.number(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.default),\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCorridorOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCorridorOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n */\nCorridorOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {\n  let positions = corridorOutlineGeometry._positions;\n  const width = corridorOutlineGeometry._width;\n  const ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  const height = corridorOutlineGeometry._height;\n  const extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorOutlineGeometry._cornerType,\n    granularity: corridorOutlineGeometry._granularity,\n    saveAttributes: false,\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, params.cornerType);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid,\n    );\n\n    if (defined(corridorOutlineGeometry._offsetAttribute)) {\n      const length = attr.attributes.position.values.length;\n      const offsetValue =\n        corridorOutlineGeometry._offsetAttribute ===\n        GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3,\n  );\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorOutlineGeometry._offsetAttribute,\n  });\n};\nexport default CorridorOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}