{"ast":null,"code":"import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Finds the min and max values of the accessor.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor object from the glTF asset to read.\n * @returns {{min: Array, max: Array}} min holding the array of minimum values and max holding the array of maximum values.\n *\n * @private\n */\nfunction findAccessorMinMax(gltf, accessor) {\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const bufferViewId = accessor.bufferView;\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n\n  // According to the spec, when bufferView is not defined, accessor must be initialized with zeros\n  if (!defined(accessor.bufferView)) {\n    return {\n      min: new Array(numberOfComponents).fill(0.0),\n      max: new Array(numberOfComponents).fill(0.0)\n    };\n  }\n  const min = new Array(numberOfComponents).fill(Number.POSITIVE_INFINITY);\n  const max = new Array(numberOfComponents).fill(Number.NEGATIVE_INFINITY);\n  const bufferView = bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = buffers[bufferId];\n  const source = buffer.extras._pipeline.source;\n  const count = accessor.count;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  let byteOffset = accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n  const componentType = accessor.componentType;\n  const componentTypeByteLength = ComponentDatatype.getSizeInBytes(componentType);\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(componentType);\n  for (let i = 0; i < count; i++) {\n    componentReader(dataView, byteOffset, numberOfComponents, componentTypeByteLength, components);\n    for (let j = 0; j < numberOfComponents; j++) {\n      const value = components[j];\n      min[j] = Math.min(min[j], value);\n      max[j] = Math.max(max[j], value);\n    }\n    byteOffset += byteStride;\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport default findAccessorMinMax;","map":{"version":3,"names":["getAccessorByteStride","getComponentReader","numberOfComponentsForType","ComponentDatatype","defined","findAccessorMinMax","gltf","accessor","bufferViews","buffers","bufferViewId","bufferView","numberOfComponents","type","min","Array","fill","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","bufferId","buffer","source","extras","_pipeline","count","byteStride","byteOffset","componentType","componentTypeByteLength","getSizeInBytes","dataView","DataView","components","componentReader","i","j","value","Math"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GltfPipeline/findAccessorMinMax.js"],"sourcesContent":["import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Finds the min and max values of the accessor.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {object} accessor The accessor object from the glTF asset to read.\n * @returns {{min: Array, max: Array}} min holding the array of minimum values and max holding the array of maximum values.\n *\n * @private\n */\nfunction findAccessorMinMax(gltf, accessor) {\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const bufferViewId = accessor.bufferView;\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n\n  // According to the spec, when bufferView is not defined, accessor must be initialized with zeros\n  if (!defined(accessor.bufferView)) {\n    return {\n      min: new Array(numberOfComponents).fill(0.0),\n      max: new Array(numberOfComponents).fill(0.0),\n    };\n  }\n\n  const min = new Array(numberOfComponents).fill(Number.POSITIVE_INFINITY);\n  const max = new Array(numberOfComponents).fill(Number.NEGATIVE_INFINITY);\n\n  const bufferView = bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = buffers[bufferId];\n  const source = buffer.extras._pipeline.source;\n\n  const count = accessor.count;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  let byteOffset =\n    accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n  const componentType = accessor.componentType;\n  const componentTypeByteLength =\n    ComponentDatatype.getSizeInBytes(componentType);\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(componentType);\n\n  for (let i = 0; i < count; i++) {\n    componentReader(\n      dataView,\n      byteOffset,\n      numberOfComponents,\n      componentTypeByteLength,\n      components\n    );\n    for (let j = 0; j < numberOfComponents; j++) {\n      const value = components[j];\n      min[j] = Math.min(min[j], value);\n      max[j] = Math.max(max[j], value);\n    }\n    byteOffset += byteStride;\n  }\n\n  return {\n    min: min,\n    max: max,\n  };\n}\n\nexport default findAccessorMinMax;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}