{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport ShaderBuilder from \"../Renderer/ShaderBuilder.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport VoxelUtils from \"../Shaders/Voxels/VoxelUtils.js\";\nimport VoxelFS from \"../Shaders/Voxels/VoxelFS.js\";\nimport VoxelVS from \"../Shaders/Voxels/VoxelVS.js\";\nimport IntersectionUtils from \"../Shaders/Voxels/IntersectionUtils.js\";\nimport IntersectDepth from \"../Shaders/Voxels/IntersectDepth.js\";\nimport IntersectClippingPlanes from \"../Shaders/Voxels/IntersectClippingPlanes.js\";\nimport IntersectLongitude from \"../Shaders/Voxels/IntersectLongitude.js\";\nimport IntersectBox from \"../Shaders/Voxels/IntersectBox.js\";\nimport IntersectCylinder from \"../Shaders/Voxels/IntersectCylinder.js\";\nimport IntersectEllipsoid from \"../Shaders/Voxels/IntersectEllipsoid.js\";\nimport Intersection from \"../Shaders/Voxels/Intersection.js\";\nimport convertUvToBox from \"../Shaders/Voxels/convertUvToBox.js\";\nimport convertUvToCylinder from \"../Shaders/Voxels/convertUvToCylinder.js\";\nimport convertUvToEllipsoid from \"../Shaders/Voxels/convertUvToEllipsoid.js\";\nimport Octree from \"../Shaders/Voxels/Octree.js\";\nimport Megatexture from \"../Shaders/Voxels/Megatexture.js\";\n\n/**\n * Set up render resources, including basic shader code, for rendering\n * a Voxel primitive.\n * The shader code generated by this function may be modified in later stages.\n * @constructor\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction VoxelRenderResources(primitive) {\n  const shaderBuilder = new ShaderBuilder();\n  /**\n   * An object used to build a shader incrementally. Each pipeline stage\n   * may add lines of shader code to this object.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = shaderBuilder;\n\n  // Custom shader uniforms\n  const customShader = primitive._customShader;\n  const uniformMap = combine(primitive._uniformMap, customShader.uniformMap);\n  primitive._uniformMap = uniformMap;\n  const customShaderUniforms = customShader.uniforms;\n  for (const uniformName in customShaderUniforms) {\n    if (customShaderUniforms.hasOwnProperty(uniformName)) {\n      const uniform = customShaderUniforms[uniformName];\n      shaderBuilder.addUniform(uniform.type, uniformName, ShaderDestination.FRAGMENT);\n    }\n  }\n  // The reason this uniform is added by shader builder is because some of the\n  // dynamically generated shader code reads from it.\n  shaderBuilder.addUniform(\"sampler2D\", \"u_megatextureTextures[METADATA_COUNT]\", ShaderDestination.FRAGMENT);\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values.\n   *\n   * @type {Object<string, Function>}\n   */\n  this.uniformMap = uniformMap;\n  const clippingPlanes = primitive._clippingPlanes;\n  const clippingPlanesLength = defined(clippingPlanes) && clippingPlanes.enabled ? clippingPlanes.length : 0;\n  this.clippingPlanes = clippingPlanes;\n  this.clippingPlanesLength = clippingPlanesLength;\n\n  // Build shader\n  shaderBuilder.addVertexLines([VoxelVS]);\n  shaderBuilder.addFragmentLines([customShader.fragmentShaderText, \"#line 0\", Octree, VoxelUtils, IntersectionUtils, Megatexture]);\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\"CLIPPING_PLANES\", undefined, ShaderDestination.FRAGMENT);\n    shaderBuilder.addDefine(\"CLIPPING_PLANES_COUNT\", clippingPlanesLength, ShaderDestination.FRAGMENT);\n    if (clippingPlanes.unionClippingRegions) {\n      shaderBuilder.addDefine(\"CLIPPING_PLANES_UNION\", undefined, ShaderDestination.FRAGMENT);\n    }\n    shaderBuilder.addFragmentLines([IntersectClippingPlanes]);\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\"DEPTH_TEST\", undefined, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFragmentLines([IntersectDepth]);\n  }\n  const shapeType = primitive._provider.shape;\n  if (shapeType === \"BOX\") {\n    shaderBuilder.addFragmentLines([convertUvToBox, IntersectBox, Intersection]);\n  } else if (shapeType === \"CYLINDER\") {\n    shaderBuilder.addFragmentLines([convertUvToCylinder, IntersectLongitude, IntersectCylinder, Intersection]);\n  } else if (shapeType === \"ELLIPSOID\") {\n    shaderBuilder.addDefine(\"SHAPE_ELLIPSOID\", undefined, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFragmentLines([convertUvToEllipsoid, IntersectLongitude, IntersectEllipsoid, Intersection]);\n  }\n  shaderBuilder.addFragmentLines([VoxelFS]);\n  const shape = primitive._shape;\n  const shapeDefines = shape.shaderDefines;\n  for (const key in shapeDefines) {\n    if (shapeDefines.hasOwnProperty(key)) {\n      let value = shapeDefines[key];\n      // if value is undefined, don't define it\n      // if value is true, define it to nothing\n      if (defined(value)) {\n        value = value === true ? undefined : value;\n        shaderBuilder.addDefine(key, value, ShaderDestination.FRAGMENT);\n      }\n    }\n  }\n\n  // Count how many intersections the shader will do.\n  let intersectionCount = shape.shaderMaximumIntersectionsLength;\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\"CLIPPING_PLANES_INTERSECTION_INDEX\", intersectionCount, ShaderDestination.FRAGMENT);\n    if (clippingPlanesLength === 1) {\n      intersectionCount += 1;\n    } else if (clippingPlanes.unionClippingRegions) {\n      intersectionCount += 2;\n    } else {\n      intersectionCount += 1;\n    }\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\"DEPTH_INTERSECTION_INDEX\", intersectionCount, ShaderDestination.FRAGMENT);\n    intersectionCount += 1;\n  }\n  shaderBuilder.addDefine(\"INTERSECTION_COUNT\", intersectionCount, ShaderDestination.FRAGMENT);\n\n  // Additional fragment shader defines\n  if (!Cartesian3.equals(primitive.paddingBefore, Cartesian3.ZERO) || !Cartesian3.equals(primitive.paddingAfter, Cartesian3.ZERO)) {\n    shaderBuilder.addDefine(\"PADDING\", undefined, ShaderDestination.FRAGMENT);\n  }\n  // Allow reading from log depth texture, but don't write log depth anywhere.\n  // Note: This needs to be set even if depthTest is off because it affects the\n  // derived command system.\n  if (primitive._useLogDepth) {\n    shaderBuilder.addDefine(\"LOG_DEPTH_READ_ONLY\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (primitive._nearestSampling) {\n    shaderBuilder.addDefine(\"NEAREST_SAMPLING\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const traversal = primitive._traversal;\n  shaderBuilder.addDefine(\"SAMPLE_COUNT\", `${traversal._sampleCount}`, ShaderDestination.FRAGMENT);\n}\nexport default VoxelRenderResources;","map":{"version":3,"names":["Cartesian3","combine","defined","ShaderBuilder","ShaderDestination","VoxelUtils","VoxelFS","VoxelVS","IntersectionUtils","IntersectDepth","IntersectClippingPlanes","IntersectLongitude","IntersectBox","IntersectCylinder","IntersectEllipsoid","Intersection","convertUvToBox","convertUvToCylinder","convertUvToEllipsoid","Octree","Megatexture","VoxelRenderResources","primitive","shaderBuilder","customShader","_customShader","uniformMap","_uniformMap","customShaderUniforms","uniforms","uniformName","hasOwnProperty","uniform","addUniform","type","FRAGMENT","clippingPlanes","_clippingPlanes","clippingPlanesLength","enabled","length","addVertexLines","addFragmentLines","fragmentShaderText","addDefine","undefined","unionClippingRegions","_depthTest","shapeType","_provider","shape","_shape","shapeDefines","shaderDefines","key","value","intersectionCount","shaderMaximumIntersectionsLength","equals","paddingBefore","ZERO","paddingAfter","_useLogDepth","_nearestSampling","traversal","_traversal","_sampleCount"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelRenderResources.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport ShaderBuilder from \"../Renderer/ShaderBuilder.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport VoxelUtils from \"../Shaders/Voxels/VoxelUtils.js\";\nimport VoxelFS from \"../Shaders/Voxels/VoxelFS.js\";\nimport VoxelVS from \"../Shaders/Voxels/VoxelVS.js\";\nimport IntersectionUtils from \"../Shaders/Voxels/IntersectionUtils.js\";\nimport IntersectDepth from \"../Shaders/Voxels/IntersectDepth.js\";\nimport IntersectClippingPlanes from \"../Shaders/Voxels/IntersectClippingPlanes.js\";\nimport IntersectLongitude from \"../Shaders/Voxels/IntersectLongitude.js\";\nimport IntersectBox from \"../Shaders/Voxels/IntersectBox.js\";\nimport IntersectCylinder from \"../Shaders/Voxels/IntersectCylinder.js\";\nimport IntersectEllipsoid from \"../Shaders/Voxels/IntersectEllipsoid.js\";\nimport Intersection from \"../Shaders/Voxels/Intersection.js\";\nimport convertUvToBox from \"../Shaders/Voxels/convertUvToBox.js\";\nimport convertUvToCylinder from \"../Shaders/Voxels/convertUvToCylinder.js\";\nimport convertUvToEllipsoid from \"../Shaders/Voxels/convertUvToEllipsoid.js\";\nimport Octree from \"../Shaders/Voxels/Octree.js\";\nimport Megatexture from \"../Shaders/Voxels/Megatexture.js\";\n\n/**\n * Set up render resources, including basic shader code, for rendering\n * a Voxel primitive.\n * The shader code generated by this function may be modified in later stages.\n * @constructor\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction VoxelRenderResources(primitive) {\n  const shaderBuilder = new ShaderBuilder();\n  /**\n   * An object used to build a shader incrementally. Each pipeline stage\n   * may add lines of shader code to this object.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = shaderBuilder;\n\n  // Custom shader uniforms\n  const customShader = primitive._customShader;\n  const uniformMap = combine(primitive._uniformMap, customShader.uniformMap);\n  primitive._uniformMap = uniformMap;\n\n  const customShaderUniforms = customShader.uniforms;\n  for (const uniformName in customShaderUniforms) {\n    if (customShaderUniforms.hasOwnProperty(uniformName)) {\n      const uniform = customShaderUniforms[uniformName];\n      shaderBuilder.addUniform(\n        uniform.type,\n        uniformName,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n  // The reason this uniform is added by shader builder is because some of the\n  // dynamically generated shader code reads from it.\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"u_megatextureTextures[METADATA_COUNT]\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values.\n   *\n   * @type {Object<string, Function>}\n   */\n  this.uniformMap = uniformMap;\n\n  const clippingPlanes = primitive._clippingPlanes;\n  const clippingPlanesLength =\n    defined(clippingPlanes) && clippingPlanes.enabled\n      ? clippingPlanes.length\n      : 0;\n\n  this.clippingPlanes = clippingPlanes;\n  this.clippingPlanesLength = clippingPlanesLength;\n\n  // Build shader\n  shaderBuilder.addVertexLines([VoxelVS]);\n\n  shaderBuilder.addFragmentLines([\n    customShader.fragmentShaderText,\n    \"#line 0\",\n    Octree,\n    VoxelUtils,\n    IntersectionUtils,\n    Megatexture,\n  ]);\n\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\n      \"CLIPPING_PLANES\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addDefine(\n      \"CLIPPING_PLANES_COUNT\",\n      clippingPlanesLength,\n      ShaderDestination.FRAGMENT,\n    );\n    if (clippingPlanes.unionClippingRegions) {\n      shaderBuilder.addDefine(\n        \"CLIPPING_PLANES_UNION\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    shaderBuilder.addFragmentLines([IntersectClippingPlanes]);\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\n      \"DEPTH_TEST\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFragmentLines([IntersectDepth]);\n  }\n\n  const shapeType = primitive._provider.shape;\n  if (shapeType === \"BOX\") {\n    shaderBuilder.addFragmentLines([\n      convertUvToBox,\n      IntersectBox,\n      Intersection,\n    ]);\n  } else if (shapeType === \"CYLINDER\") {\n    shaderBuilder.addFragmentLines([\n      convertUvToCylinder,\n      IntersectLongitude,\n      IntersectCylinder,\n      Intersection,\n    ]);\n  } else if (shapeType === \"ELLIPSOID\") {\n    shaderBuilder.addDefine(\n      \"SHAPE_ELLIPSOID\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFragmentLines([\n      convertUvToEllipsoid,\n      IntersectLongitude,\n      IntersectEllipsoid,\n      Intersection,\n    ]);\n  }\n\n  shaderBuilder.addFragmentLines([VoxelFS]);\n\n  const shape = primitive._shape;\n  const shapeDefines = shape.shaderDefines;\n  for (const key in shapeDefines) {\n    if (shapeDefines.hasOwnProperty(key)) {\n      let value = shapeDefines[key];\n      // if value is undefined, don't define it\n      // if value is true, define it to nothing\n      if (defined(value)) {\n        value = value === true ? undefined : value;\n        shaderBuilder.addDefine(key, value, ShaderDestination.FRAGMENT);\n      }\n    }\n  }\n\n  // Count how many intersections the shader will do.\n  let intersectionCount = shape.shaderMaximumIntersectionsLength;\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\n      \"CLIPPING_PLANES_INTERSECTION_INDEX\",\n      intersectionCount,\n      ShaderDestination.FRAGMENT,\n    );\n    if (clippingPlanesLength === 1) {\n      intersectionCount += 1;\n    } else if (clippingPlanes.unionClippingRegions) {\n      intersectionCount += 2;\n    } else {\n      intersectionCount += 1;\n    }\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\n      \"DEPTH_INTERSECTION_INDEX\",\n      intersectionCount,\n      ShaderDestination.FRAGMENT,\n    );\n    intersectionCount += 1;\n  }\n  shaderBuilder.addDefine(\n    \"INTERSECTION_COUNT\",\n    intersectionCount,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Additional fragment shader defines\n  if (\n    !Cartesian3.equals(primitive.paddingBefore, Cartesian3.ZERO) ||\n    !Cartesian3.equals(primitive.paddingAfter, Cartesian3.ZERO)\n  ) {\n    shaderBuilder.addDefine(\"PADDING\", undefined, ShaderDestination.FRAGMENT);\n  }\n  // Allow reading from log depth texture, but don't write log depth anywhere.\n  // Note: This needs to be set even if depthTest is off because it affects the\n  // derived command system.\n  if (primitive._useLogDepth) {\n    shaderBuilder.addDefine(\n      \"LOG_DEPTH_READ_ONLY\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n  if (primitive._nearestSampling) {\n    shaderBuilder.addDefine(\n      \"NEAREST_SAMPLING\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n  const traversal = primitive._traversal;\n  shaderBuilder.addDefine(\n    \"SAMPLE_COUNT\",\n    `${traversal._sampleCount}`,\n    ShaderDestination.FRAGMENT,\n  );\n}\n\nexport default VoxelRenderResources;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,iBAAiB,MAAM,kCAAkC;AAChE,OAAOC,UAAU,MAAM,iCAAiC;AACxD,OAAOC,OAAO,MAAM,8BAA8B;AAClD,OAAOC,OAAO,MAAM,8BAA8B;AAClD,OAAOC,iBAAiB,MAAM,wCAAwC;AACtE,OAAOC,cAAc,MAAM,qCAAqC;AAChE,OAAOC,uBAAuB,MAAM,8CAA8C;AAClF,OAAOC,kBAAkB,MAAM,yCAAyC;AACxE,OAAOC,YAAY,MAAM,mCAAmC;AAC5D,OAAOC,iBAAiB,MAAM,wCAAwC;AACtE,OAAOC,kBAAkB,MAAM,yCAAyC;AACxE,OAAOC,YAAY,MAAM,mCAAmC;AAC5D,OAAOC,cAAc,MAAM,qCAAqC;AAChE,OAAOC,mBAAmB,MAAM,0CAA0C;AAC1E,OAAOC,oBAAoB,MAAM,2CAA2C;AAC5E,OAAOC,MAAM,MAAM,6BAA6B;AAChD,OAAOC,WAAW,MAAM,kCAAkC;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAACC,SAAS,EAAE;EACvC,MAAMC,aAAa,GAAG,IAAIpB,aAAa,CAAC,CAAC;EACzC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACoB,aAAa,GAAGA,aAAa;;EAElC;EACA,MAAMC,YAAY,GAAGF,SAAS,CAACG,aAAa;EAC5C,MAAMC,UAAU,GAAGzB,OAAO,CAACqB,SAAS,CAACK,WAAW,EAAEH,YAAY,CAACE,UAAU,CAAC;EAC1EJ,SAAS,CAACK,WAAW,GAAGD,UAAU;EAElC,MAAME,oBAAoB,GAAGJ,YAAY,CAACK,QAAQ;EAClD,KAAK,MAAMC,WAAW,IAAIF,oBAAoB,EAAE;IAC9C,IAAIA,oBAAoB,CAACG,cAAc,CAACD,WAAW,CAAC,EAAE;MACpD,MAAME,OAAO,GAAGJ,oBAAoB,CAACE,WAAW,CAAC;MACjDP,aAAa,CAACU,UAAU,CACtBD,OAAO,CAACE,IAAI,EACZJ,WAAW,EACX1B,iBAAiB,CAAC+B,QACpB,CAAC;IACH;EACF;EACA;EACA;EACAZ,aAAa,CAACU,UAAU,CACtB,WAAW,EACX,uCAAuC,EACvC7B,iBAAiB,CAAC+B,QACpB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACT,UAAU,GAAGA,UAAU;EAE5B,MAAMU,cAAc,GAAGd,SAAS,CAACe,eAAe;EAChD,MAAMC,oBAAoB,GACxBpC,OAAO,CAACkC,cAAc,CAAC,IAAIA,cAAc,CAACG,OAAO,GAC7CH,cAAc,CAACI,MAAM,GACrB,CAAC;EAEP,IAAI,CAACJ,cAAc,GAAGA,cAAc;EACpC,IAAI,CAACE,oBAAoB,GAAGA,oBAAoB;;EAEhD;EACAf,aAAa,CAACkB,cAAc,CAAC,CAAClC,OAAO,CAAC,CAAC;EAEvCgB,aAAa,CAACmB,gBAAgB,CAAC,CAC7BlB,YAAY,CAACmB,kBAAkB,EAC/B,SAAS,EACTxB,MAAM,EACNd,UAAU,EACVG,iBAAiB,EACjBY,WAAW,CACZ,CAAC;EAEF,IAAIkB,oBAAoB,GAAG,CAAC,EAAE;IAC5Bf,aAAa,CAACqB,SAAS,CACrB,iBAAiB,EACjBC,SAAS,EACTzC,iBAAiB,CAAC+B,QACpB,CAAC;IACDZ,aAAa,CAACqB,SAAS,CACrB,uBAAuB,EACvBN,oBAAoB,EACpBlC,iBAAiB,CAAC+B,QACpB,CAAC;IACD,IAAIC,cAAc,CAACU,oBAAoB,EAAE;MACvCvB,aAAa,CAACqB,SAAS,CACrB,uBAAuB,EACvBC,SAAS,EACTzC,iBAAiB,CAAC+B,QACpB,CAAC;IACH;IACAZ,aAAa,CAACmB,gBAAgB,CAAC,CAAChC,uBAAuB,CAAC,CAAC;EAC3D;EACA,IAAIY,SAAS,CAACyB,UAAU,EAAE;IACxBxB,aAAa,CAACqB,SAAS,CACrB,YAAY,EACZC,SAAS,EACTzC,iBAAiB,CAAC+B,QACpB,CAAC;IACDZ,aAAa,CAACmB,gBAAgB,CAAC,CAACjC,cAAc,CAAC,CAAC;EAClD;EAEA,MAAMuC,SAAS,GAAG1B,SAAS,CAAC2B,SAAS,CAACC,KAAK;EAC3C,IAAIF,SAAS,KAAK,KAAK,EAAE;IACvBzB,aAAa,CAACmB,gBAAgB,CAAC,CAC7B1B,cAAc,EACdJ,YAAY,EACZG,YAAY,CACb,CAAC;EACJ,CAAC,MAAM,IAAIiC,SAAS,KAAK,UAAU,EAAE;IACnCzB,aAAa,CAACmB,gBAAgB,CAAC,CAC7BzB,mBAAmB,EACnBN,kBAAkB,EAClBE,iBAAiB,EACjBE,YAAY,CACb,CAAC;EACJ,CAAC,MAAM,IAAIiC,SAAS,KAAK,WAAW,EAAE;IACpCzB,aAAa,CAACqB,SAAS,CACrB,iBAAiB,EACjBC,SAAS,EACTzC,iBAAiB,CAAC+B,QACpB,CAAC;IACDZ,aAAa,CAACmB,gBAAgB,CAAC,CAC7BxB,oBAAoB,EACpBP,kBAAkB,EAClBG,kBAAkB,EAClBC,YAAY,CACb,CAAC;EACJ;EAEAQ,aAAa,CAACmB,gBAAgB,CAAC,CAACpC,OAAO,CAAC,CAAC;EAEzC,MAAM4C,KAAK,GAAG5B,SAAS,CAAC6B,MAAM;EAC9B,MAAMC,YAAY,GAAGF,KAAK,CAACG,aAAa;EACxC,KAAK,MAAMC,GAAG,IAAIF,YAAY,EAAE;IAC9B,IAAIA,YAAY,CAACrB,cAAc,CAACuB,GAAG,CAAC,EAAE;MACpC,IAAIC,KAAK,GAAGH,YAAY,CAACE,GAAG,CAAC;MAC7B;MACA;MACA,IAAIpD,OAAO,CAACqD,KAAK,CAAC,EAAE;QAClBA,KAAK,GAAGA,KAAK,KAAK,IAAI,GAAGV,SAAS,GAAGU,KAAK;QAC1ChC,aAAa,CAACqB,SAAS,CAACU,GAAG,EAAEC,KAAK,EAAEnD,iBAAiB,CAAC+B,QAAQ,CAAC;MACjE;IACF;EACF;;EAEA;EACA,IAAIqB,iBAAiB,GAAGN,KAAK,CAACO,gCAAgC;EAC9D,IAAInB,oBAAoB,GAAG,CAAC,EAAE;IAC5Bf,aAAa,CAACqB,SAAS,CACrB,oCAAoC,EACpCY,iBAAiB,EACjBpD,iBAAiB,CAAC+B,QACpB,CAAC;IACD,IAAIG,oBAAoB,KAAK,CAAC,EAAE;MAC9BkB,iBAAiB,IAAI,CAAC;IACxB,CAAC,MAAM,IAAIpB,cAAc,CAACU,oBAAoB,EAAE;MAC9CU,iBAAiB,IAAI,CAAC;IACxB,CAAC,MAAM;MACLA,iBAAiB,IAAI,CAAC;IACxB;EACF;EACA,IAAIlC,SAAS,CAACyB,UAAU,EAAE;IACxBxB,aAAa,CAACqB,SAAS,CACrB,0BAA0B,EAC1BY,iBAAiB,EACjBpD,iBAAiB,CAAC+B,QACpB,CAAC;IACDqB,iBAAiB,IAAI,CAAC;EACxB;EACAjC,aAAa,CAACqB,SAAS,CACrB,oBAAoB,EACpBY,iBAAiB,EACjBpD,iBAAiB,CAAC+B,QACpB,CAAC;;EAED;EACA,IACE,CAACnC,UAAU,CAAC0D,MAAM,CAACpC,SAAS,CAACqC,aAAa,EAAE3D,UAAU,CAAC4D,IAAI,CAAC,IAC5D,CAAC5D,UAAU,CAAC0D,MAAM,CAACpC,SAAS,CAACuC,YAAY,EAAE7D,UAAU,CAAC4D,IAAI,CAAC,EAC3D;IACArC,aAAa,CAACqB,SAAS,CAAC,SAAS,EAAEC,SAAS,EAAEzC,iBAAiB,CAAC+B,QAAQ,CAAC;EAC3E;EACA;EACA;EACA;EACA,IAAIb,SAAS,CAACwC,YAAY,EAAE;IAC1BvC,aAAa,CAACqB,SAAS,CACrB,qBAAqB,EACrBC,SAAS,EACTzC,iBAAiB,CAAC+B,QACpB,CAAC;EACH;EACA,IAAIb,SAAS,CAACyC,gBAAgB,EAAE;IAC9BxC,aAAa,CAACqB,SAAS,CACrB,kBAAkB,EAClBC,SAAS,EACTzC,iBAAiB,CAAC+B,QACpB,CAAC;EACH;EACA,MAAM6B,SAAS,GAAG1C,SAAS,CAAC2C,UAAU;EACtC1C,aAAa,CAACqB,SAAS,CACrB,cAAc,EACd,GAAGoB,SAAS,CAACE,YAAY,EAAE,EAC3B9D,iBAAiB,CAAC+B,QACpB,CAAC;AACH;AAEA,eAAed,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}