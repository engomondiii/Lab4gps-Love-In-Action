{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The primitive statistics update stage updates memory usage statistics\n * on the primitive level. This counts the binary resources that exist\n * for the lifetime of the Model (e.g. attributes and textures\n * loaded by GltfLoader). It does not count resources that are created\n * every time the pipeline is run. The individual pipeline stages are\n * responsible for tracking the additional memory they allocate.\n *\n * @namespace PrimitiveStatisticsPipelineStage\n *\n * @private\n */\nconst PrimitiveStatisticsPipelineStage = {\n  name: \"PrimitiveStatisticsPipelineStage\",\n  // Helps with debugging\n\n  // Expose some methods for testing\n  _countGeometry: countGeometry,\n  _count2DPositions: count2DPositions,\n  _countMorphTargetAttributes: countMorphTargetAttributes,\n  _countMaterialTextures: countMaterialTextures,\n  _countFeatureIdTextures: countFeatureIdTextures,\n  _countBinaryMetadata: countBinaryMetadata\n};\nPrimitiveStatisticsPipelineStage.process = function (renderResources, primitive, frameState) {\n  const model = renderResources.model;\n  const statistics = model.statistics;\n  countGeometry(statistics, primitive);\n  count2DPositions(statistics, renderResources.runtimePrimitive);\n  countMorphTargetAttributes(statistics, primitive);\n  countMaterialTextures(statistics, primitive.material);\n  countFeatureIdTextures(statistics, primitive.featureIds);\n  countBinaryMetadata(statistics, model);\n\n  // The following stages handle their own memory statistics, since all their\n  // resources are generated each time draw commands are built:\n  //\n  // - PickingPipelineStage\n  // - WireframePipelineStage\n  // - InstancingPipelineStage\n  // - FeatureIdPipelineStage (feature ID implicit ranges only)\n};\nfunction countGeometry(statistics, primitive) {\n  const indicesCount = defined(primitive.indices) ? primitive.indices.count : ModelUtility.getAttributeBySemantic(primitive, \"POSITION\").count;\n  const primitiveType = primitive.primitiveType;\n  if (primitiveType === PrimitiveType.POINTS) {\n    statistics.pointsLength += indicesCount;\n  } else if (PrimitiveType.isTriangles(primitiveType)) {\n    statistics.trianglesLength += countTriangles(primitiveType, indicesCount);\n  }\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      const hasCpuCopy = defined(attribute.typedArray);\n      statistics.addBuffer(attribute.buffer, hasCpuCopy);\n    }\n  }\n  const outlineCoordinates = primitive.outlineCoordinates;\n  if (defined(outlineCoordinates) && defined(outlineCoordinates.buffer)) {\n    const hasCpuCopy = false;\n    statistics.addBuffer(outlineCoordinates.buffer, hasCpuCopy);\n  }\n  const indices = primitive.indices;\n  if (defined(indices) && defined(indices.buffer)) {\n    // Wireframe mode will have both GPU and CPU copies\n    const hasCpuCopy = defined(indices.typedArray);\n    statistics.addBuffer(indices.buffer, hasCpuCopy);\n  }\n}\nfunction countTriangles(primitiveType, indicesCount) {\n  switch (primitiveType) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\nfunction count2DPositions(statistics, runtimePrimitive) {\n  const buffer2D = runtimePrimitive.positionBuffer2D;\n\n  // The 2D buffer is only created the first time the scene switches to 2D mode.\n  // This means there's two main cases for accounting for 2D positions:\n  // 1. The scene was in 3D mode so positions were never generated from\n  //    positionAttribute.typedArray. In this case, countGeometry() will\n  //    detect the typed array and set hasCpuCopy = true. No memory is counted\n  //    here.\n  // 2. The scene was in 2D mode so positions were generated as a buffer.\n  //    Even though the typed array was unlinked from the attribute, it still\n  //    exists in the loader so we count it here.\n  if (defined(buffer2D)) {\n    const hasCpuCopy = true;\n    statistics.addBuffer(buffer2D, hasCpuCopy);\n  }\n}\nfunction countMorphTargetAttributes(statistics, primitive) {\n  const morphTargets = primitive.morphTargets;\n  if (!defined(morphTargets)) {\n    return;\n  }\n  const hasCpuCopy = false;\n  const morphTargetsLength = morphTargets.length;\n  for (let i = 0; i < morphTargetsLength; i++) {\n    const attributes = morphTargets[i].attributes;\n    const attributesLength = attributes.length;\n    for (let j = 0; j < attributesLength; j++) {\n      const attribute = attributes[j];\n      if (defined(attribute.buffer)) {\n        statistics.addBuffer(attribute.buffer, hasCpuCopy);\n      }\n    }\n  }\n}\nfunction countMaterialTextures(statistics, material) {\n  // gltf-pipeline provides a default material so material will always be\n  // defined.\n  const textureReaders = getAllTextureReaders(material);\n  const length = textureReaders.length;\n  for (let i = 0; i < length; i++) {\n    const textureReader = textureReaders[i];\n    // If textures were loaded asynchronously, the texture may not be available\n    // the first time this is run.\n    if (defined(textureReader) && defined(textureReader.texture)) {\n      statistics.addTexture(textureReader.texture);\n    }\n  }\n}\nfunction getAllTextureReaders(material) {\n  const metallicRoughness = material.metallicRoughness;\n  const textureReaders = [material.emissiveTexture, material.normalTexture, material.occlusionTexture, metallicRoughness.baseColorTexture, metallicRoughness.metallicRoughnessTexture];\n  const specularGlossiness = material.specularGlossiness;\n  if (defined(specularGlossiness)) {\n    textureReaders.push(specularGlossiness.diffuseTexture);\n    textureReaders.push(specularGlossiness.specularGlossinessTexture);\n  }\n  return textureReaders;\n}\nfunction countFeatureIdTextures(statistics, featureIdSets) {\n  // Feature ID attributes are handled by countGeometry()\n\n  // Feature ID implicit ranges are handled in the FeatureIdPipelineStage,\n  // as they only are created as-needed.\n\n  const length = featureIdSets.length;\n  for (let i = 0; i < length; i++) {\n    const featureIds = featureIdSets[i];\n    if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n      const textureReader = featureIds.textureReader;\n      if (defined(textureReader.texture)) {\n        statistics.addTexture(textureReader.texture);\n      }\n    }\n  }\n}\nfunction countBinaryMetadata(statistics, model) {\n  // Add metadata memory to the statistics. Note that feature ID memory is\n  // handled by the Feature ID pipeline stage.\n  const structuralMetadata = model.structuralMetadata;\n  if (defined(structuralMetadata)) {\n    // Property textures are added to the texture memory count. If textures\n    // are loaded asynchronously, this may add 0 to the total. The pipeline\n    // will be re-run when textures are loaded for an accurate count.\n    countPropertyTextures(statistics, structuralMetadata);\n\n    // Property tables are accounted for here.\n    statistics.propertyTablesByteLength += structuralMetadata.propertyTablesByteLength;\n\n    // Skip property attributes since those are handled in countGeometry().\n  }\n\n  // Model feature tables also have batch and pick textures that need to be\n  // counted.\n  const featureTables = model.featureTables;\n  if (!defined(featureTables)) {\n    return;\n  }\n  const length = featureTables.length;\n  for (let i = 0; i < length; i++) {\n    const featureTable = featureTables[i];\n\n    // This does not include the property table memory, since\n    // it is counted through the structuralMetadata above.\n    statistics.addBatchTexture(featureTable.batchTexture);\n  }\n}\nfunction countPropertyTextures(statistics, structuralMetadata) {\n  const propertyTextures = structuralMetadata.propertyTextures;\n  if (!defined(propertyTextures)) {\n    return;\n  }\n\n  // Loop over the property textures from here so we can use\n  // statistics.addTexture() which avoids double-counting shared textures.\n  const texturesLength = propertyTextures.length;\n  for (let i = 0; i < texturesLength; i++) {\n    const propertyTexture = propertyTextures[i];\n    const properties = propertyTexture.properties;\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const property = properties[propertyId];\n        const textureReader = property.textureReader;\n        if (defined(textureReader.texture)) {\n          statistics.addTexture(textureReader.texture);\n        }\n      }\n    }\n  }\n}\nexport default PrimitiveStatisticsPipelineStage;","map":{"version":3,"names":["defined","PrimitiveType","ModelComponents","ModelUtility","PrimitiveStatisticsPipelineStage","name","_countGeometry","countGeometry","_count2DPositions","count2DPositions","_countMorphTargetAttributes","countMorphTargetAttributes","_countMaterialTextures","countMaterialTextures","_countFeatureIdTextures","countFeatureIdTextures","_countBinaryMetadata","countBinaryMetadata","process","renderResources","primitive","frameState","model","statistics","runtimePrimitive","material","featureIds","indicesCount","indices","count","getAttributeBySemantic","primitiveType","POINTS","pointsLength","isTriangles","trianglesLength","countTriangles","attributes","length","i","attribute","buffer","hasCpuCopy","typedArray","addBuffer","outlineCoordinates","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Math","max","buffer2D","positionBuffer2D","morphTargets","morphTargetsLength","attributesLength","j","textureReaders","getAllTextureReaders","textureReader","texture","addTexture","metallicRoughness","emissiveTexture","normalTexture","occlusionTexture","baseColorTexture","metallicRoughnessTexture","specularGlossiness","push","diffuseTexture","specularGlossinessTexture","featureIdSets","FeatureIdTexture","structuralMetadata","countPropertyTextures","propertyTablesByteLength","featureTables","featureTable","addBatchTexture","batchTexture","propertyTextures","texturesLength","propertyTexture","properties","propertyId","hasOwnProperty","property"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/PrimitiveStatisticsPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The primitive statistics update stage updates memory usage statistics\n * on the primitive level. This counts the binary resources that exist\n * for the lifetime of the Model (e.g. attributes and textures\n * loaded by GltfLoader). It does not count resources that are created\n * every time the pipeline is run. The individual pipeline stages are\n * responsible for tracking the additional memory they allocate.\n *\n * @namespace PrimitiveStatisticsPipelineStage\n *\n * @private\n */\nconst PrimitiveStatisticsPipelineStage = {\n  name: \"PrimitiveStatisticsPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _countGeometry: countGeometry,\n  _count2DPositions: count2DPositions,\n  _countMorphTargetAttributes: countMorphTargetAttributes,\n  _countMaterialTextures: countMaterialTextures,\n  _countFeatureIdTextures: countFeatureIdTextures,\n  _countBinaryMetadata: countBinaryMetadata,\n};\n\nPrimitiveStatisticsPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const model = renderResources.model;\n  const statistics = model.statistics;\n\n  countGeometry(statistics, primitive);\n  count2DPositions(statistics, renderResources.runtimePrimitive);\n  countMorphTargetAttributes(statistics, primitive);\n  countMaterialTextures(statistics, primitive.material);\n  countFeatureIdTextures(statistics, primitive.featureIds);\n  countBinaryMetadata(statistics, model);\n\n  // The following stages handle their own memory statistics, since all their\n  // resources are generated each time draw commands are built:\n  //\n  // - PickingPipelineStage\n  // - WireframePipelineStage\n  // - InstancingPipelineStage\n  // - FeatureIdPipelineStage (feature ID implicit ranges only)\n};\n\nfunction countGeometry(statistics, primitive) {\n  const indicesCount = defined(primitive.indices)\n    ? primitive.indices.count\n    : ModelUtility.getAttributeBySemantic(primitive, \"POSITION\").count;\n\n  const primitiveType = primitive.primitiveType;\n\n  if (primitiveType === PrimitiveType.POINTS) {\n    statistics.pointsLength += indicesCount;\n  } else if (PrimitiveType.isTriangles(primitiveType)) {\n    statistics.trianglesLength += countTriangles(primitiveType, indicesCount);\n  }\n\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      const hasCpuCopy = defined(attribute.typedArray);\n      statistics.addBuffer(attribute.buffer, hasCpuCopy);\n    }\n  }\n\n  const outlineCoordinates = primitive.outlineCoordinates;\n  if (defined(outlineCoordinates) && defined(outlineCoordinates.buffer)) {\n    const hasCpuCopy = false;\n    statistics.addBuffer(outlineCoordinates.buffer, hasCpuCopy);\n  }\n\n  const indices = primitive.indices;\n  if (defined(indices) && defined(indices.buffer)) {\n    // Wireframe mode will have both GPU and CPU copies\n    const hasCpuCopy = defined(indices.typedArray);\n    statistics.addBuffer(indices.buffer, hasCpuCopy);\n  }\n}\n\nfunction countTriangles(primitiveType, indicesCount) {\n  switch (primitiveType) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\n\nfunction count2DPositions(statistics, runtimePrimitive) {\n  const buffer2D = runtimePrimitive.positionBuffer2D;\n\n  // The 2D buffer is only created the first time the scene switches to 2D mode.\n  // This means there's two main cases for accounting for 2D positions:\n  // 1. The scene was in 3D mode so positions were never generated from\n  //    positionAttribute.typedArray. In this case, countGeometry() will\n  //    detect the typed array and set hasCpuCopy = true. No memory is counted\n  //    here.\n  // 2. The scene was in 2D mode so positions were generated as a buffer.\n  //    Even though the typed array was unlinked from the attribute, it still\n  //    exists in the loader so we count it here.\n  if (defined(buffer2D)) {\n    const hasCpuCopy = true;\n    statistics.addBuffer(buffer2D, hasCpuCopy);\n  }\n}\n\nfunction countMorphTargetAttributes(statistics, primitive) {\n  const morphTargets = primitive.morphTargets;\n  if (!defined(morphTargets)) {\n    return;\n  }\n\n  const hasCpuCopy = false;\n  const morphTargetsLength = morphTargets.length;\n  for (let i = 0; i < morphTargetsLength; i++) {\n    const attributes = morphTargets[i].attributes;\n\n    const attributesLength = attributes.length;\n    for (let j = 0; j < attributesLength; j++) {\n      const attribute = attributes[j];\n\n      if (defined(attribute.buffer)) {\n        statistics.addBuffer(attribute.buffer, hasCpuCopy);\n      }\n    }\n  }\n}\n\nfunction countMaterialTextures(statistics, material) {\n  // gltf-pipeline provides a default material so material will always be\n  // defined.\n  const textureReaders = getAllTextureReaders(material);\n  const length = textureReaders.length;\n  for (let i = 0; i < length; i++) {\n    const textureReader = textureReaders[i];\n    // If textures were loaded asynchronously, the texture may not be available\n    // the first time this is run.\n    if (defined(textureReader) && defined(textureReader.texture)) {\n      statistics.addTexture(textureReader.texture);\n    }\n  }\n}\n\nfunction getAllTextureReaders(material) {\n  const metallicRoughness = material.metallicRoughness;\n  const textureReaders = [\n    material.emissiveTexture,\n    material.normalTexture,\n    material.occlusionTexture,\n    metallicRoughness.baseColorTexture,\n    metallicRoughness.metallicRoughnessTexture,\n  ];\n\n  const specularGlossiness = material.specularGlossiness;\n  if (defined(specularGlossiness)) {\n    textureReaders.push(specularGlossiness.diffuseTexture);\n    textureReaders.push(specularGlossiness.specularGlossinessTexture);\n  }\n\n  return textureReaders;\n}\n\nfunction countFeatureIdTextures(statistics, featureIdSets) {\n  // Feature ID attributes are handled by countGeometry()\n\n  // Feature ID implicit ranges are handled in the FeatureIdPipelineStage,\n  // as they only are created as-needed.\n\n  const length = featureIdSets.length;\n  for (let i = 0; i < length; i++) {\n    const featureIds = featureIdSets[i];\n    if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n      const textureReader = featureIds.textureReader;\n      if (defined(textureReader.texture)) {\n        statistics.addTexture(textureReader.texture);\n      }\n    }\n  }\n}\n\nfunction countBinaryMetadata(statistics, model) {\n  // Add metadata memory to the statistics. Note that feature ID memory is\n  // handled by the Feature ID pipeline stage.\n  const structuralMetadata = model.structuralMetadata;\n  if (defined(structuralMetadata)) {\n    // Property textures are added to the texture memory count. If textures\n    // are loaded asynchronously, this may add 0 to the total. The pipeline\n    // will be re-run when textures are loaded for an accurate count.\n    countPropertyTextures(statistics, structuralMetadata);\n\n    // Property tables are accounted for here.\n    statistics.propertyTablesByteLength +=\n      structuralMetadata.propertyTablesByteLength;\n\n    // Skip property attributes since those are handled in countGeometry().\n  }\n\n  // Model feature tables also have batch and pick textures that need to be\n  // counted.\n  const featureTables = model.featureTables;\n  if (!defined(featureTables)) {\n    return;\n  }\n\n  const length = featureTables.length;\n  for (let i = 0; i < length; i++) {\n    const featureTable = featureTables[i];\n\n    // This does not include the property table memory, since\n    // it is counted through the structuralMetadata above.\n    statistics.addBatchTexture(featureTable.batchTexture);\n  }\n}\n\nfunction countPropertyTextures(statistics, structuralMetadata) {\n  const propertyTextures = structuralMetadata.propertyTextures;\n  if (!defined(propertyTextures)) {\n    return;\n  }\n\n  // Loop over the property textures from here so we can use\n  // statistics.addTexture() which avoids double-counting shared textures.\n  const texturesLength = propertyTextures.length;\n  for (let i = 0; i < texturesLength; i++) {\n    const propertyTexture = propertyTextures[i];\n    const properties = propertyTexture.properties;\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const property = properties[propertyId];\n        const textureReader = property.textureReader;\n        if (defined(textureReader.texture)) {\n          statistics.addTexture(textureReader.texture);\n        }\n      }\n    }\n  }\n}\n\nexport default PrimitiveStatisticsPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}