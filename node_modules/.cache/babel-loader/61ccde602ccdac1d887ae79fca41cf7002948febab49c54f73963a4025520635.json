{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"void verticalExaggerationStage(\\n\\\n  inout ProcessedAttributes attributes\\n\\\n) {\\n\\\n  // Compute the distance from the camera to the local center of curvature.\\n\\\n  vec4 vertexPositionENU = czm_modelToEnu * vec4(attributes.positionMC, 1.0);\\n\\\n  vec2 vertexAzimuth = normalize(vertexPositionENU.xy);\\n\\\n  // Curvature = 1 / radius of curvature.\\n\\\n  float azimuthalCurvature = dot(vertexAzimuth * vertexAzimuth, czm_eyeEllipsoidCurvature);\\n\\\n  float eyeToCenter = 1.0 / azimuthalCurvature + czm_eyeHeight;\\n\\\n\\n\\\n  // Compute the approximate ellipsoid normal at the vertex position.\\n\\\n  // Uses a circular approximation for the Earth curvature along the geodesic.\\n\\\n  vec3 vertexPositionEC = (czm_modelView * vec4(attributes.positionMC, 1.0)).xyz;\\n\\\n  vec3 centerToVertex = eyeToCenter * czm_eyeEllipsoidNormalEC + vertexPositionEC;\\n\\\n  vec3 vertexNormal = normalize(centerToVertex);\\n\\\n\\n\\\n  // Estimate the (sine of the) angle between the camera direction and the vertex normal\\n\\\n  float verticalDistance = dot(vertexPositionEC, czm_eyeEllipsoidNormalEC);\\n\\\n  float horizontalDistance = length(vertexPositionEC - verticalDistance * czm_eyeEllipsoidNormalEC);\\n\\\n  float sinTheta = horizontalDistance / (eyeToCenter + verticalDistance);\\n\\\n  bool isSmallAngle = clamp(sinTheta, 0.0, 0.05) == sinTheta;\\n\\\n\\n\\\n  // Approximate the change in height above the ellipsoid, from camera to vertex position.\\n\\\n  float exactVersine = 1.0 - dot(czm_eyeEllipsoidNormalEC, vertexNormal);\\n\\\n  float smallAngleVersine = 0.5 * sinTheta * sinTheta;\\n\\\n  float versine = isSmallAngle ? smallAngleVersine : exactVersine;\\n\\\n  float dHeight = dot(vertexPositionEC, vertexNormal) - eyeToCenter * versine;\\n\\\n  float vertexHeight = czm_eyeHeight + dHeight;\\n\\\n\\n\\\n  // Transform the approximate vertex normal to model coordinates.\\n\\\n  vec3 vertexNormalMC = (czm_inverseModelView * vec4(vertexNormal, 0.0)).xyz;\\n\\\n  vertexNormalMC = normalize(vertexNormalMC);\\n\\\n\\n\\\n  // Compute the exaggeration and apply it along the approximate vertex normal.\\n\\\n  float stretch = u_verticalExaggerationAndRelativeHeight.x;\\n\\\n  float shift = u_verticalExaggerationAndRelativeHeight.y;\\n\\\n  float exaggeration = (vertexHeight - shift) * (stretch - 1.0);\\n\\\n  attributes.positionMC += exaggeration * vertexNormalMC;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Model/VerticalExaggerationStageVS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"void verticalExaggerationStage(\\n\\\n  inout ProcessedAttributes attributes\\n\\\n) {\\n\\\n  // Compute the distance from the camera to the local center of curvature.\\n\\\n  vec4 vertexPositionENU = czm_modelToEnu * vec4(attributes.positionMC, 1.0);\\n\\\n  vec2 vertexAzimuth = normalize(vertexPositionENU.xy);\\n\\\n  // Curvature = 1 / radius of curvature.\\n\\\n  float azimuthalCurvature = dot(vertexAzimuth * vertexAzimuth, czm_eyeEllipsoidCurvature);\\n\\\n  float eyeToCenter = 1.0 / azimuthalCurvature + czm_eyeHeight;\\n\\\n\\n\\\n  // Compute the approximate ellipsoid normal at the vertex position.\\n\\\n  // Uses a circular approximation for the Earth curvature along the geodesic.\\n\\\n  vec3 vertexPositionEC = (czm_modelView * vec4(attributes.positionMC, 1.0)).xyz;\\n\\\n  vec3 centerToVertex = eyeToCenter * czm_eyeEllipsoidNormalEC + vertexPositionEC;\\n\\\n  vec3 vertexNormal = normalize(centerToVertex);\\n\\\n\\n\\\n  // Estimate the (sine of the) angle between the camera direction and the vertex normal\\n\\\n  float verticalDistance = dot(vertexPositionEC, czm_eyeEllipsoidNormalEC);\\n\\\n  float horizontalDistance = length(vertexPositionEC - verticalDistance * czm_eyeEllipsoidNormalEC);\\n\\\n  float sinTheta = horizontalDistance / (eyeToCenter + verticalDistance);\\n\\\n  bool isSmallAngle = clamp(sinTheta, 0.0, 0.05) == sinTheta;\\n\\\n\\n\\\n  // Approximate the change in height above the ellipsoid, from camera to vertex position.\\n\\\n  float exactVersine = 1.0 - dot(czm_eyeEllipsoidNormalEC, vertexNormal);\\n\\\n  float smallAngleVersine = 0.5 * sinTheta * sinTheta;\\n\\\n  float versine = isSmallAngle ? smallAngleVersine : exactVersine;\\n\\\n  float dHeight = dot(vertexPositionEC, vertexNormal) - eyeToCenter * versine;\\n\\\n  float vertexHeight = czm_eyeHeight + dHeight;\\n\\\n\\n\\\n  // Transform the approximate vertex normal to model coordinates.\\n\\\n  vec3 vertexNormalMC = (czm_inverseModelView * vec4(vertexNormal, 0.0)).xyz;\\n\\\n  vertexNormalMC = normalize(vertexNormalMC);\\n\\\n\\n\\\n  // Compute the exaggeration and apply it along the approximate vertex normal.\\n\\\n  float stretch = u_verticalExaggerationAndRelativeHeight.x;\\n\\\n  float shift = u_verticalExaggerationAndRelativeHeight.y;\\n\\\n  float exaggeration = (vertexHeight - shift) * (stretch - 1.0);\\n\\\n  attributes.positionMC += exaggeration * vertexNormalMC;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}