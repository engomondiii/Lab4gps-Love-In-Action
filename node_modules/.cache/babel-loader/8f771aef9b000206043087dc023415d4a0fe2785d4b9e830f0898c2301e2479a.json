{"ast":null,"code":"import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport clone from \"../../Core/clone.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport ClassificationModelDrawCommand from \"./ClassificationModelDrawCommand.js\";\nimport ModelDrawCommand from \"./ModelDrawCommand.js\";\nimport VertexArray from \"../../Renderer/VertexArray.js\";\nimport ModelVS from \"../../Shaders/Model/ModelVS.js\";\nimport ModelFS from \"../../Shaders/Model/ModelFS.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\n/**\n * Internal functions to build draw commands for models.\n *\n * (The core of these functions was taken from `buildDrawCommand.js´,\n * as of commit hash 7b93161da1cc03bdc796b204e7aa51fb7acebf04)\n *\n * @private\n */\nfunction ModelDrawCommands() {}\n\n/**\n * Builds the {@link ModelDrawCommand} for a {@link ModelRuntimePrimitive}\n * using its render resources. If the model classifies another asset, it\n * builds a {@link ClassificationModelDrawCommand} instead.\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {FrameState} frameState The frame state for creating GPU resources.\n * @returns {ModelDrawCommand|ClassificationModelDrawCommand} The generated ModelDrawCommand or ClassificationModelDrawCommand.\n *\n * @private\n */\nModelDrawCommands.buildModelDrawCommand = function (primitiveRenderResources, frameState) {\n  const shaderBuilder = primitiveRenderResources.shaderBuilder;\n  const shaderProgram = createShaderProgram(primitiveRenderResources, shaderBuilder, frameState);\n  const command = buildDrawCommandForModel(primitiveRenderResources, shaderProgram, frameState);\n  const model = primitiveRenderResources.model;\n  const hasClassification = defined(model.classificationType);\n  if (hasClassification) {\n    return new ClassificationModelDrawCommand({\n      primitiveRenderResources: primitiveRenderResources,\n      command: command\n    });\n  }\n  return new ModelDrawCommand({\n    primitiveRenderResources: primitiveRenderResources,\n    command: command\n  });\n};\n\n/**\n * @private\n */\nfunction createShaderProgram(primitiveRenderResources, shaderBuilder, frameState) {\n  shaderBuilder.addVertexLines(ModelVS);\n  shaderBuilder.addFragmentLines(ModelFS);\n  const model = primitiveRenderResources.model;\n  const shaderProgram = shaderBuilder.buildShaderProgram(frameState.context);\n  model._pipelineResources.push(shaderProgram);\n  return shaderProgram;\n}\n\n/**\n * Builds the {@link DrawCommand} that serves as the basis for either creating\n * a {@link ModelDrawCommand} or a {@link ModelRuntimePrimitive}\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {ShaderProgram} shaderProgram The shader program\n * @param {FrameState} frameState The frame state for creating GPU resources.\n *\n * @returns {DrawCommand} The generated DrawCommand, to be passed to\n * the ModelDrawCommand or ClassificationModelDrawCommand\n *\n * @private\n */\nfunction buildDrawCommandForModel(primitiveRenderResources, shaderProgram, frameState) {\n  const indexBuffer = getIndexBuffer(primitiveRenderResources);\n  const vertexArray = new VertexArray({\n    context: frameState.context,\n    indexBuffer: indexBuffer,\n    attributes: primitiveRenderResources.attributes\n  });\n  const model = primitiveRenderResources.model;\n  model._pipelineResources.push(vertexArray);\n  const pass = primitiveRenderResources.alphaOptions.pass;\n  const sceneGraph = model.sceneGraph;\n  const is3D = frameState.mode === SceneMode.SCENE3D;\n  let modelMatrix, boundingSphere;\n  if (!is3D && !frameState.scene3DOnly && model._projectTo2D) {\n    modelMatrix = Matrix4.multiplyTransformation(sceneGraph._computedModelMatrix, primitiveRenderResources.runtimeNode.computedTransform, new Matrix4());\n    const runtimePrimitive = primitiveRenderResources.runtimePrimitive;\n    boundingSphere = runtimePrimitive.boundingSphere2D;\n  } else {\n    const computedModelMatrix = is3D ? sceneGraph._computedModelMatrix : sceneGraph._computedModelMatrix2D;\n    modelMatrix = Matrix4.multiplyTransformation(computedModelMatrix, primitiveRenderResources.runtimeNode.computedTransform, new Matrix4());\n    boundingSphere = BoundingSphere.transform(primitiveRenderResources.boundingSphere, modelMatrix);\n  }\n\n  // Initialize render state with default values\n  let renderState = clone(RenderState.fromCache(primitiveRenderResources.renderStateOptions), true);\n  renderState.cull.face = ModelUtility.getCullFace(modelMatrix, primitiveRenderResources.primitiveType);\n  renderState = RenderState.fromCache(renderState);\n  const hasClassification = defined(model.classificationType);\n  const castShadows = hasClassification ? false : ShadowMode.castShadows(model.shadows);\n  const receiveShadows = hasClassification ? false : ShadowMode.receiveShadows(model.shadows);\n  // Pick IDs are only added to specific draw commands for classification.\n  // This behavior is handled by ClassificationModelDrawCommand.\n  const pickId = hasClassification ? undefined : primitiveRenderResources.pickId;\n  const command = new DrawCommand({\n    boundingVolume: boundingSphere,\n    modelMatrix: modelMatrix,\n    uniformMap: primitiveRenderResources.uniformMap,\n    renderState: renderState,\n    vertexArray: vertexArray,\n    shaderProgram: shaderProgram,\n    cull: model.cull,\n    pass: pass,\n    count: primitiveRenderResources.count,\n    owner: model,\n    pickId: pickId,\n    pickMetadataAllowed: true,\n    instanceCount: primitiveRenderResources.instanceCount,\n    primitiveType: primitiveRenderResources.primitiveType,\n    debugShowBoundingVolume: model.debugShowBoundingVolume,\n    castShadows: castShadows,\n    receiveShadows: receiveShadows\n  });\n  return command;\n}\n\n/**\n * @private\n */\nfunction getIndexBuffer(primitiveRenderResources) {\n  const wireframeIndexBuffer = primitiveRenderResources.wireframeIndexBuffer;\n  if (defined(wireframeIndexBuffer)) {\n    return wireframeIndexBuffer;\n  }\n  const indices = primitiveRenderResources.indices;\n  if (!defined(indices)) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices.buffer)) {\n    throw new DeveloperError(\"Indices must be provided as a Buffer\");\n  }\n  //>>includeEnd('debug');\n\n  return indices.buffer;\n}\nexport default ModelDrawCommands;","map":{"version":3,"names":["BoundingSphere","clone","defined","Matrix4","DrawCommand","RenderState","SceneMode","ShadowMode","ClassificationModelDrawCommand","ModelDrawCommand","VertexArray","ModelVS","ModelFS","ModelUtility","DeveloperError","ModelDrawCommands","buildModelDrawCommand","primitiveRenderResources","frameState","shaderBuilder","shaderProgram","createShaderProgram","command","buildDrawCommandForModel","model","hasClassification","classificationType","addVertexLines","addFragmentLines","buildShaderProgram","context","_pipelineResources","push","indexBuffer","getIndexBuffer","vertexArray","attributes","pass","alphaOptions","sceneGraph","is3D","mode","SCENE3D","modelMatrix","boundingSphere","scene3DOnly","_projectTo2D","multiplyTransformation","_computedModelMatrix","runtimeNode","computedTransform","runtimePrimitive","boundingSphere2D","computedModelMatrix","_computedModelMatrix2D","transform","renderState","fromCache","renderStateOptions","cull","face","getCullFace","primitiveType","castShadows","shadows","receiveShadows","pickId","undefined","boundingVolume","uniformMap","count","owner","pickMetadataAllowed","instanceCount","debugShowBoundingVolume","wireframeIndexBuffer","indices","buffer"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelDrawCommands.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport clone from \"../../Core/clone.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport ClassificationModelDrawCommand from \"./ClassificationModelDrawCommand.js\";\nimport ModelDrawCommand from \"./ModelDrawCommand.js\";\nimport VertexArray from \"../../Renderer/VertexArray.js\";\nimport ModelVS from \"../../Shaders/Model/ModelVS.js\";\nimport ModelFS from \"../../Shaders/Model/ModelFS.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\n/**\n * Internal functions to build draw commands for models.\n *\n * (The core of these functions was taken from `buildDrawCommand.js´,\n * as of commit hash 7b93161da1cc03bdc796b204e7aa51fb7acebf04)\n *\n * @private\n */\nfunction ModelDrawCommands() {}\n\n/**\n * Builds the {@link ModelDrawCommand} for a {@link ModelRuntimePrimitive}\n * using its render resources. If the model classifies another asset, it\n * builds a {@link ClassificationModelDrawCommand} instead.\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {FrameState} frameState The frame state for creating GPU resources.\n * @returns {ModelDrawCommand|ClassificationModelDrawCommand} The generated ModelDrawCommand or ClassificationModelDrawCommand.\n *\n * @private\n */\nModelDrawCommands.buildModelDrawCommand = function (\n  primitiveRenderResources,\n  frameState,\n) {\n  const shaderBuilder = primitiveRenderResources.shaderBuilder;\n  const shaderProgram = createShaderProgram(\n    primitiveRenderResources,\n    shaderBuilder,\n    frameState,\n  );\n\n  const command = buildDrawCommandForModel(\n    primitiveRenderResources,\n    shaderProgram,\n    frameState,\n  );\n\n  const model = primitiveRenderResources.model;\n  const hasClassification = defined(model.classificationType);\n  if (hasClassification) {\n    return new ClassificationModelDrawCommand({\n      primitiveRenderResources: primitiveRenderResources,\n      command: command,\n    });\n  }\n\n  return new ModelDrawCommand({\n    primitiveRenderResources: primitiveRenderResources,\n    command: command,\n  });\n};\n\n/**\n * @private\n */\nfunction createShaderProgram(\n  primitiveRenderResources,\n  shaderBuilder,\n  frameState,\n) {\n  shaderBuilder.addVertexLines(ModelVS);\n  shaderBuilder.addFragmentLines(ModelFS);\n\n  const model = primitiveRenderResources.model;\n  const shaderProgram = shaderBuilder.buildShaderProgram(frameState.context);\n  model._pipelineResources.push(shaderProgram);\n  return shaderProgram;\n}\n\n/**\n * Builds the {@link DrawCommand} that serves as the basis for either creating\n * a {@link ModelDrawCommand} or a {@link ModelRuntimePrimitive}\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {ShaderProgram} shaderProgram The shader program\n * @param {FrameState} frameState The frame state for creating GPU resources.\n *\n * @returns {DrawCommand} The generated DrawCommand, to be passed to\n * the ModelDrawCommand or ClassificationModelDrawCommand\n *\n * @private\n */\nfunction buildDrawCommandForModel(\n  primitiveRenderResources,\n  shaderProgram,\n  frameState,\n) {\n  const indexBuffer = getIndexBuffer(primitiveRenderResources);\n\n  const vertexArray = new VertexArray({\n    context: frameState.context,\n    indexBuffer: indexBuffer,\n    attributes: primitiveRenderResources.attributes,\n  });\n\n  const model = primitiveRenderResources.model;\n  model._pipelineResources.push(vertexArray);\n\n  const pass = primitiveRenderResources.alphaOptions.pass;\n  const sceneGraph = model.sceneGraph;\n\n  const is3D = frameState.mode === SceneMode.SCENE3D;\n  let modelMatrix, boundingSphere;\n\n  if (!is3D && !frameState.scene3DOnly && model._projectTo2D) {\n    modelMatrix = Matrix4.multiplyTransformation(\n      sceneGraph._computedModelMatrix,\n      primitiveRenderResources.runtimeNode.computedTransform,\n      new Matrix4(),\n    );\n\n    const runtimePrimitive = primitiveRenderResources.runtimePrimitive;\n    boundingSphere = runtimePrimitive.boundingSphere2D;\n  } else {\n    const computedModelMatrix = is3D\n      ? sceneGraph._computedModelMatrix\n      : sceneGraph._computedModelMatrix2D;\n\n    modelMatrix = Matrix4.multiplyTransformation(\n      computedModelMatrix,\n      primitiveRenderResources.runtimeNode.computedTransform,\n      new Matrix4(),\n    );\n\n    boundingSphere = BoundingSphere.transform(\n      primitiveRenderResources.boundingSphere,\n      modelMatrix,\n    );\n  }\n\n  // Initialize render state with default values\n  let renderState = clone(\n    RenderState.fromCache(primitiveRenderResources.renderStateOptions),\n    true,\n  );\n\n  renderState.cull.face = ModelUtility.getCullFace(\n    modelMatrix,\n    primitiveRenderResources.primitiveType,\n  );\n  renderState = RenderState.fromCache(renderState);\n\n  const hasClassification = defined(model.classificationType);\n  const castShadows = hasClassification\n    ? false\n    : ShadowMode.castShadows(model.shadows);\n  const receiveShadows = hasClassification\n    ? false\n    : ShadowMode.receiveShadows(model.shadows);\n  // Pick IDs are only added to specific draw commands for classification.\n  // This behavior is handled by ClassificationModelDrawCommand.\n  const pickId = hasClassification\n    ? undefined\n    : primitiveRenderResources.pickId;\n\n  const command = new DrawCommand({\n    boundingVolume: boundingSphere,\n    modelMatrix: modelMatrix,\n    uniformMap: primitiveRenderResources.uniformMap,\n    renderState: renderState,\n    vertexArray: vertexArray,\n    shaderProgram: shaderProgram,\n    cull: model.cull,\n    pass: pass,\n    count: primitiveRenderResources.count,\n    owner: model,\n    pickId: pickId,\n    pickMetadataAllowed: true,\n    instanceCount: primitiveRenderResources.instanceCount,\n    primitiveType: primitiveRenderResources.primitiveType,\n    debugShowBoundingVolume: model.debugShowBoundingVolume,\n    castShadows: castShadows,\n    receiveShadows: receiveShadows,\n  });\n  return command;\n}\n\n/**\n * @private\n */\nfunction getIndexBuffer(primitiveRenderResources) {\n  const wireframeIndexBuffer = primitiveRenderResources.wireframeIndexBuffer;\n  if (defined(wireframeIndexBuffer)) {\n    return wireframeIndexBuffer;\n  }\n\n  const indices = primitiveRenderResources.indices;\n  if (!defined(indices)) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices.buffer)) {\n    throw new DeveloperError(\"Indices must be provided as a Buffer\");\n  }\n  //>>includeEnd('debug');\n\n  return indices.buffer;\n}\n\nexport default ModelDrawCommands;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}